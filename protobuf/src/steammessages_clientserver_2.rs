// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_clientserver_2.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:CMsgClientUCMAddScreenshot)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMAddScreenshot {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.filename)
    pub filename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.thumbname)
    pub thumbname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.vr_filename)
    pub vr_filename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.rtime32_created)
    pub rtime32_created: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.width)
    pub width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.height)
    pub height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.permissions)
    pub permissions: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.caption)
    pub caption: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.shortcut_name)
    pub shortcut_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.tag)
    pub tag: ::std::vec::Vec<cmsg_client_ucmadd_screenshot::Tag>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.tagged_steamid)
    pub tagged_steamid: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.spoiler_tag)
    pub spoiler_tag: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.tagged_publishedfileid)
    pub tagged_publishedfileid: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMAddScreenshot.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMAddScreenshot {
    fn default() -> &'a CMsgClientUCMAddScreenshot {
        <CMsgClientUCMAddScreenshot as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMAddScreenshot {
    pub fn new() -> CMsgClientUCMAddScreenshot {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string filename = 2;

    pub fn filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename = ::std::option::Option::None;
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string thumbname = 3;

    pub fn thumbname(&self) -> &str {
        match self.thumbname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_thumbname(&mut self) {
        self.thumbname = ::std::option::Option::None;
    }

    pub fn has_thumbname(&self) -> bool {
        self.thumbname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbname(&mut self, v: ::std::string::String) {
        self.thumbname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbname(&mut self) -> &mut ::std::string::String {
        if self.thumbname.is_none() {
            self.thumbname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.thumbname.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbname(&mut self) -> ::std::string::String {
        self.thumbname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string vr_filename = 14;

    pub fn vr_filename(&self) -> &str {
        match self.vr_filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_vr_filename(&mut self) {
        self.vr_filename = ::std::option::Option::None;
    }

    pub fn has_vr_filename(&self) -> bool {
        self.vr_filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vr_filename(&mut self, v: ::std::string::String) {
        self.vr_filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vr_filename(&mut self) -> &mut ::std::string::String {
        if self.vr_filename.is_none() {
            self.vr_filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.vr_filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_vr_filename(&mut self) -> ::std::string::String {
        self.vr_filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed32 rtime32_created = 4;

    pub fn rtime32_created(&self) -> u32 {
        self.rtime32_created.unwrap_or(0)
    }

    pub fn clear_rtime32_created(&mut self) {
        self.rtime32_created = ::std::option::Option::None;
    }

    pub fn has_rtime32_created(&self) -> bool {
        self.rtime32_created.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_created(&mut self, v: u32) {
        self.rtime32_created = ::std::option::Option::Some(v);
    }

    // optional uint32 width = 5;

    pub fn width(&self) -> u32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 6;

    pub fn height(&self) -> u32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional uint32 permissions = 7;

    pub fn permissions(&self) -> u32 {
        self.permissions.unwrap_or(0)
    }

    pub fn clear_permissions(&mut self) {
        self.permissions = ::std::option::Option::None;
    }

    pub fn has_permissions(&self) -> bool {
        self.permissions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permissions(&mut self, v: u32) {
        self.permissions = ::std::option::Option::Some(v);
    }

    // optional string caption = 8;

    pub fn caption(&self) -> &str {
        match self.caption.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_caption(&mut self) {
        self.caption = ::std::option::Option::None;
    }

    pub fn has_caption(&self) -> bool {
        self.caption.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caption(&mut self, v: ::std::string::String) {
        self.caption = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caption(&mut self) -> &mut ::std::string::String {
        if self.caption.is_none() {
            self.caption = ::std::option::Option::Some(::std::string::String::new());
        }
        self.caption.as_mut().unwrap()
    }

    // Take field
    pub fn take_caption(&mut self) -> ::std::string::String {
        self.caption.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string shortcut_name = 9;

    pub fn shortcut_name(&self) -> &str {
        match self.shortcut_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_shortcut_name(&mut self) {
        self.shortcut_name = ::std::option::Option::None;
    }

    pub fn has_shortcut_name(&self) -> bool {
        self.shortcut_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shortcut_name(&mut self, v: ::std::string::String) {
        self.shortcut_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shortcut_name(&mut self) -> &mut ::std::string::String {
        if self.shortcut_name.is_none() {
            self.shortcut_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.shortcut_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_shortcut_name(&mut self) -> ::std::string::String {
        self.shortcut_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool spoiler_tag = 12;

    pub fn spoiler_tag(&self) -> bool {
        self.spoiler_tag.unwrap_or(false)
    }

    pub fn clear_spoiler_tag(&mut self) {
        self.spoiler_tag = ::std::option::Option::None;
    }

    pub fn has_spoiler_tag(&self) -> bool {
        self.spoiler_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spoiler_tag(&mut self, v: bool) {
        self.spoiler_tag = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CMsgClientUCMAddScreenshot| { &m.appid },
            |m: &mut CMsgClientUCMAddScreenshot| { &mut m.appid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "filename",
            |m: &CMsgClientUCMAddScreenshot| { &m.filename },
            |m: &mut CMsgClientUCMAddScreenshot| { &mut m.filename },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbname",
            |m: &CMsgClientUCMAddScreenshot| { &m.thumbname },
            |m: &mut CMsgClientUCMAddScreenshot| { &mut m.thumbname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vr_filename",
            |m: &CMsgClientUCMAddScreenshot| { &m.vr_filename },
            |m: &mut CMsgClientUCMAddScreenshot| { &mut m.vr_filename },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime32_created",
            |m: &CMsgClientUCMAddScreenshot| { &m.rtime32_created },
            |m: &mut CMsgClientUCMAddScreenshot| { &mut m.rtime32_created },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &CMsgClientUCMAddScreenshot| { &m.width },
            |m: &mut CMsgClientUCMAddScreenshot| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &CMsgClientUCMAddScreenshot| { &m.height },
            |m: &mut CMsgClientUCMAddScreenshot| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "permissions",
            |m: &CMsgClientUCMAddScreenshot| { &m.permissions },
            |m: &mut CMsgClientUCMAddScreenshot| { &mut m.permissions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caption",
            |m: &CMsgClientUCMAddScreenshot| { &m.caption },
            |m: &mut CMsgClientUCMAddScreenshot| { &mut m.caption },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shortcut_name",
            |m: &CMsgClientUCMAddScreenshot| { &m.shortcut_name },
            |m: &mut CMsgClientUCMAddScreenshot| { &mut m.shortcut_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tag",
            |m: &CMsgClientUCMAddScreenshot| { &m.tag },
            |m: &mut CMsgClientUCMAddScreenshot| { &mut m.tag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tagged_steamid",
            |m: &CMsgClientUCMAddScreenshot| { &m.tagged_steamid },
            |m: &mut CMsgClientUCMAddScreenshot| { &mut m.tagged_steamid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "spoiler_tag",
            |m: &CMsgClientUCMAddScreenshot| { &m.spoiler_tag },
            |m: &mut CMsgClientUCMAddScreenshot| { &mut m.spoiler_tag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tagged_publishedfileid",
            |m: &CMsgClientUCMAddScreenshot| { &m.tagged_publishedfileid },
            |m: &mut CMsgClientUCMAddScreenshot| { &mut m.tagged_publishedfileid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUCMAddScreenshot>(
            "CMsgClientUCMAddScreenshot",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUCMAddScreenshot {
    const NAME: &'static str = "CMsgClientUCMAddScreenshot";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.filename = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.thumbname = ::std::option::Option::Some(is.read_string()?);
                },
                114 => {
                    self.vr_filename = ::std::option::Option::Some(is.read_string()?);
                },
                37 => {
                    self.rtime32_created = ::std::option::Option::Some(is.read_fixed32()?);
                },
                40 => {
                    self.width = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.height = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.permissions = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.caption = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.shortcut_name = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.tag.push(is.read_message()?);
                },
                90 => {
                    is.read_repeated_packed_fixed64_into(&mut self.tagged_steamid)?;
                },
                89 => {
                    self.tagged_steamid.push(is.read_fixed64()?);
                },
                96 => {
                    self.spoiler_tag = ::std::option::Option::Some(is.read_bool()?);
                },
                106 => {
                    is.read_repeated_packed_uint64_into(&mut self.tagged_publishedfileid)?;
                },
                104 => {
                    self.tagged_publishedfileid.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.thumbname.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.vr_filename.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.rtime32_created {
            my_size += 1 + 4;
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.permissions {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.caption.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.shortcut_name.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        for value in &self.tag {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += 9 * self.tagged_steamid.len() as u64;
        if let Some(v) = self.spoiler_tag {
            my_size += 1 + 1;
        }
        for value in &self.tagged_publishedfileid {
            my_size += ::protobuf::rt::uint64_size(13, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.filename.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.thumbname.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.vr_filename.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.rtime32_created {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.width {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.permissions {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.caption.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.shortcut_name.as_ref() {
            os.write_string(9, v)?;
        }
        for v in &self.tag {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        for v in &self.tagged_steamid {
            os.write_fixed64(11, *v)?;
        };
        if let Some(v) = self.spoiler_tag {
            os.write_bool(12, v)?;
        }
        for v in &self.tagged_publishedfileid {
            os.write_uint64(13, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMAddScreenshot {
        CMsgClientUCMAddScreenshot::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.filename = ::std::option::Option::None;
        self.thumbname = ::std::option::Option::None;
        self.vr_filename = ::std::option::Option::None;
        self.rtime32_created = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.permissions = ::std::option::Option::None;
        self.caption = ::std::option::Option::None;
        self.shortcut_name = ::std::option::Option::None;
        self.tag.clear();
        self.tagged_steamid.clear();
        self.spoiler_tag = ::std::option::Option::None;
        self.tagged_publishedfileid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMAddScreenshot {
        static instance: CMsgClientUCMAddScreenshot = CMsgClientUCMAddScreenshot {
            appid: ::std::option::Option::None,
            filename: ::std::option::Option::None,
            thumbname: ::std::option::Option::None,
            vr_filename: ::std::option::Option::None,
            rtime32_created: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            permissions: ::std::option::Option::None,
            caption: ::std::option::Option::None,
            shortcut_name: ::std::option::Option::None,
            tag: ::std::vec::Vec::new(),
            tagged_steamid: ::std::vec::Vec::new(),
            spoiler_tag: ::std::option::Option::None,
            tagged_publishedfileid: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUCMAddScreenshot {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUCMAddScreenshot").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUCMAddScreenshot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMAddScreenshot {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientUCMAddScreenshot`
pub mod cmsg_client_ucmadd_screenshot {
    // @@protoc_insertion_point(message:CMsgClientUCMAddScreenshot.Tag)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Tag {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.Tag.tag_name)
        pub tag_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshot.Tag.tag_value)
        pub tag_value: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientUCMAddScreenshot.Tag.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Tag {
        fn default() -> &'a Tag {
            <Tag as ::protobuf::Message>::default_instance()
        }
    }

    impl Tag {
        pub fn new() -> Tag {
            ::std::default::Default::default()
        }

        // optional string tag_name = 1;

        pub fn tag_name(&self) -> &str {
            match self.tag_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_tag_name(&mut self) {
            self.tag_name = ::std::option::Option::None;
        }

        pub fn has_tag_name(&self) -> bool {
            self.tag_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tag_name(&mut self, v: ::std::string::String) {
            self.tag_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_tag_name(&mut self) -> &mut ::std::string::String {
            if self.tag_name.is_none() {
                self.tag_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.tag_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_tag_name(&mut self) -> ::std::string::String {
            self.tag_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string tag_value = 2;

        pub fn tag_value(&self) -> &str {
            match self.tag_value.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_tag_value(&mut self) {
            self.tag_value = ::std::option::Option::None;
        }

        pub fn has_tag_value(&self) -> bool {
            self.tag_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tag_value(&mut self, v: ::std::string::String) {
            self.tag_value = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_tag_value(&mut self) -> &mut ::std::string::String {
            if self.tag_value.is_none() {
                self.tag_value = ::std::option::Option::Some(::std::string::String::new());
            }
            self.tag_value.as_mut().unwrap()
        }

        // Take field
        pub fn take_tag_value(&mut self) -> ::std::string::String {
            self.tag_value.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "tag_name",
                |m: &Tag| { &m.tag_name },
                |m: &mut Tag| { &mut m.tag_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "tag_value",
                |m: &Tag| { &m.tag_value },
                |m: &mut Tag| { &mut m.tag_value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Tag>(
                "CMsgClientUCMAddScreenshot.Tag",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Tag {
        const NAME: &'static str = "Tag";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.tag_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.tag_value = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.tag_name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.tag_value.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.tag_name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.tag_value.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Tag {
            Tag::new()
        }

        fn clear(&mut self) {
            self.tag_name = ::std::option::Option::None;
            self.tag_value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Tag {
            static instance: Tag = Tag {
                tag_name: ::std::option::Option::None,
                tag_value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Tag {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientUCMAddScreenshot.Tag").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Tag {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Tag {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientUCMAddScreenshotResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMAddScreenshotResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshotResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUCMAddScreenshotResponse.screenshotid)
    pub screenshotid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMAddScreenshotResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMAddScreenshotResponse {
    fn default() -> &'a CMsgClientUCMAddScreenshotResponse {
        <CMsgClientUCMAddScreenshotResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMAddScreenshotResponse {
    pub fn new() -> CMsgClientUCMAddScreenshotResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional fixed64 screenshotid = 2;

    pub fn screenshotid(&self) -> u64 {
        self.screenshotid.unwrap_or(18446744073709551615u64)
    }

    pub fn clear_screenshotid(&mut self) {
        self.screenshotid = ::std::option::Option::None;
    }

    pub fn has_screenshotid(&self) -> bool {
        self.screenshotid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screenshotid(&mut self, v: u64) {
        self.screenshotid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientUCMAddScreenshotResponse| { &m.eresult },
            |m: &mut CMsgClientUCMAddScreenshotResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "screenshotid",
            |m: &CMsgClientUCMAddScreenshotResponse| { &m.screenshotid },
            |m: &mut CMsgClientUCMAddScreenshotResponse| { &mut m.screenshotid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUCMAddScreenshotResponse>(
            "CMsgClientUCMAddScreenshotResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUCMAddScreenshotResponse {
    const NAME: &'static str = "CMsgClientUCMAddScreenshotResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                17 => {
                    self.screenshotid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.screenshotid {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.screenshotid {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMAddScreenshotResponse {
        CMsgClientUCMAddScreenshotResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.screenshotid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMAddScreenshotResponse {
        static instance: CMsgClientUCMAddScreenshotResponse = CMsgClientUCMAddScreenshotResponse {
            eresult: ::std::option::Option::None,
            screenshotid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUCMAddScreenshotResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUCMAddScreenshotResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUCMAddScreenshotResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMAddScreenshotResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUCMDeleteScreenshot)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMDeleteScreenshot {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMDeleteScreenshot.screenshotid)
    pub screenshotid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMDeleteScreenshot.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMDeleteScreenshot {
    fn default() -> &'a CMsgClientUCMDeleteScreenshot {
        <CMsgClientUCMDeleteScreenshot as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMDeleteScreenshot {
    pub fn new() -> CMsgClientUCMDeleteScreenshot {
        ::std::default::Default::default()
    }

    // optional fixed64 screenshotid = 1;

    pub fn screenshotid(&self) -> u64 {
        self.screenshotid.unwrap_or(18446744073709551615u64)
    }

    pub fn clear_screenshotid(&mut self) {
        self.screenshotid = ::std::option::Option::None;
    }

    pub fn has_screenshotid(&self) -> bool {
        self.screenshotid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screenshotid(&mut self, v: u64) {
        self.screenshotid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "screenshotid",
            |m: &CMsgClientUCMDeleteScreenshot| { &m.screenshotid },
            |m: &mut CMsgClientUCMDeleteScreenshot| { &mut m.screenshotid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUCMDeleteScreenshot>(
            "CMsgClientUCMDeleteScreenshot",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUCMDeleteScreenshot {
    const NAME: &'static str = "CMsgClientUCMDeleteScreenshot";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.screenshotid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.screenshotid {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.screenshotid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMDeleteScreenshot {
        CMsgClientUCMDeleteScreenshot::new()
    }

    fn clear(&mut self) {
        self.screenshotid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMDeleteScreenshot {
        static instance: CMsgClientUCMDeleteScreenshot = CMsgClientUCMDeleteScreenshot {
            screenshotid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUCMDeleteScreenshot {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUCMDeleteScreenshot").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUCMDeleteScreenshot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMDeleteScreenshot {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUCMDeleteScreenshotResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMDeleteScreenshotResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMDeleteScreenshotResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMDeleteScreenshotResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMDeleteScreenshotResponse {
    fn default() -> &'a CMsgClientUCMDeleteScreenshotResponse {
        <CMsgClientUCMDeleteScreenshotResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMDeleteScreenshotResponse {
    pub fn new() -> CMsgClientUCMDeleteScreenshotResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientUCMDeleteScreenshotResponse| { &m.eresult },
            |m: &mut CMsgClientUCMDeleteScreenshotResponse| { &mut m.eresult },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUCMDeleteScreenshotResponse>(
            "CMsgClientUCMDeleteScreenshotResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUCMDeleteScreenshotResponse {
    const NAME: &'static str = "CMsgClientUCMDeleteScreenshotResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMDeleteScreenshotResponse {
        CMsgClientUCMDeleteScreenshotResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMDeleteScreenshotResponse {
        static instance: CMsgClientUCMDeleteScreenshotResponse = CMsgClientUCMDeleteScreenshotResponse {
            eresult: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUCMDeleteScreenshotResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUCMDeleteScreenshotResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUCMDeleteScreenshotResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMDeleteScreenshotResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUCMPublishFile)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMPublishFile {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.file_name)
    pub file_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.preview_file_name)
    pub preview_file_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.consumer_app_id)
    pub consumer_app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.tags)
    pub tags: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.workshop_file)
    pub workshop_file: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.visibility)
    pub visibility: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.file_type)
    pub file_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.video_provider)
    pub video_provider: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.video_account_name)
    pub video_account_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.video_identifier)
    pub video_identifier: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFile.in_progress)
    pub in_progress: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMPublishFile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMPublishFile {
    fn default() -> &'a CMsgClientUCMPublishFile {
        <CMsgClientUCMPublishFile as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMPublishFile {
    pub fn new() -> CMsgClientUCMPublishFile {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional string file_name = 2;

    pub fn file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_name(&mut self) {
        self.file_name = ::std::option::Option::None;
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string preview_file_name = 3;

    pub fn preview_file_name(&self) -> &str {
        match self.preview_file_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_preview_file_name(&mut self) {
        self.preview_file_name = ::std::option::Option::None;
    }

    pub fn has_preview_file_name(&self) -> bool {
        self.preview_file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preview_file_name(&mut self, v: ::std::string::String) {
        self.preview_file_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preview_file_name(&mut self) -> &mut ::std::string::String {
        if self.preview_file_name.is_none() {
            self.preview_file_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.preview_file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_preview_file_name(&mut self) -> ::std::string::String {
        self.preview_file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 consumer_app_id = 4;

    pub fn consumer_app_id(&self) -> u32 {
        self.consumer_app_id.unwrap_or(0)
    }

    pub fn clear_consumer_app_id(&mut self) {
        self.consumer_app_id = ::std::option::Option::None;
    }

    pub fn has_consumer_app_id(&self) -> bool {
        self.consumer_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumer_app_id(&mut self, v: u32) {
        self.consumer_app_id = ::std::option::Option::Some(v);
    }

    // optional string title = 5;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 6;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool workshop_file = 9;

    pub fn workshop_file(&self) -> bool {
        self.workshop_file.unwrap_or(false)
    }

    pub fn clear_workshop_file(&mut self) {
        self.workshop_file = ::std::option::Option::None;
    }

    pub fn has_workshop_file(&self) -> bool {
        self.workshop_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_workshop_file(&mut self, v: bool) {
        self.workshop_file = ::std::option::Option::Some(v);
    }

    // optional int32 visibility = 10;

    pub fn visibility(&self) -> i32 {
        self.visibility.unwrap_or(0)
    }

    pub fn clear_visibility(&mut self) {
        self.visibility = ::std::option::Option::None;
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: i32) {
        self.visibility = ::std::option::Option::Some(v);
    }

    // optional uint32 file_type = 11;

    pub fn file_type(&self) -> u32 {
        self.file_type.unwrap_or(0)
    }

    pub fn clear_file_type(&mut self) {
        self.file_type = ::std::option::Option::None;
    }

    pub fn has_file_type(&self) -> bool {
        self.file_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_type(&mut self, v: u32) {
        self.file_type = ::std::option::Option::Some(v);
    }

    // optional string url = 12;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 video_provider = 13;

    pub fn video_provider(&self) -> u32 {
        self.video_provider.unwrap_or(0)
    }

    pub fn clear_video_provider(&mut self) {
        self.video_provider = ::std::option::Option::None;
    }

    pub fn has_video_provider(&self) -> bool {
        self.video_provider.is_some()
    }

    // Param is passed by value, moved
    pub fn set_video_provider(&mut self, v: u32) {
        self.video_provider = ::std::option::Option::Some(v);
    }

    // optional string video_account_name = 14;

    pub fn video_account_name(&self) -> &str {
        match self.video_account_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_video_account_name(&mut self) {
        self.video_account_name = ::std::option::Option::None;
    }

    pub fn has_video_account_name(&self) -> bool {
        self.video_account_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_video_account_name(&mut self, v: ::std::string::String) {
        self.video_account_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_video_account_name(&mut self) -> &mut ::std::string::String {
        if self.video_account_name.is_none() {
            self.video_account_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.video_account_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_video_account_name(&mut self) -> ::std::string::String {
        self.video_account_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string video_identifier = 15;

    pub fn video_identifier(&self) -> &str {
        match self.video_identifier.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_video_identifier(&mut self) {
        self.video_identifier = ::std::option::Option::None;
    }

    pub fn has_video_identifier(&self) -> bool {
        self.video_identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_video_identifier(&mut self, v: ::std::string::String) {
        self.video_identifier = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_video_identifier(&mut self) -> &mut ::std::string::String {
        if self.video_identifier.is_none() {
            self.video_identifier = ::std::option::Option::Some(::std::string::String::new());
        }
        self.video_identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_video_identifier(&mut self) -> ::std::string::String {
        self.video_identifier.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool in_progress = 16;

    pub fn in_progress(&self) -> bool {
        self.in_progress.unwrap_or(false)
    }

    pub fn clear_in_progress(&mut self) {
        self.in_progress = ::std::option::Option::None;
    }

    pub fn has_in_progress(&self) -> bool {
        self.in_progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_progress(&mut self, v: bool) {
        self.in_progress = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(15);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientUCMPublishFile| { &m.app_id },
            |m: &mut CMsgClientUCMPublishFile| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_name",
            |m: &CMsgClientUCMPublishFile| { &m.file_name },
            |m: &mut CMsgClientUCMPublishFile| { &mut m.file_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "preview_file_name",
            |m: &CMsgClientUCMPublishFile| { &m.preview_file_name },
            |m: &mut CMsgClientUCMPublishFile| { &mut m.preview_file_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "consumer_app_id",
            |m: &CMsgClientUCMPublishFile| { &m.consumer_app_id },
            |m: &mut CMsgClientUCMPublishFile| { &mut m.consumer_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &CMsgClientUCMPublishFile| { &m.title },
            |m: &mut CMsgClientUCMPublishFile| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &CMsgClientUCMPublishFile| { &m.description },
            |m: &mut CMsgClientUCMPublishFile| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tags",
            |m: &CMsgClientUCMPublishFile| { &m.tags },
            |m: &mut CMsgClientUCMPublishFile| { &mut m.tags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "workshop_file",
            |m: &CMsgClientUCMPublishFile| { &m.workshop_file },
            |m: &mut CMsgClientUCMPublishFile| { &mut m.workshop_file },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "visibility",
            |m: &CMsgClientUCMPublishFile| { &m.visibility },
            |m: &mut CMsgClientUCMPublishFile| { &mut m.visibility },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_type",
            |m: &CMsgClientUCMPublishFile| { &m.file_type },
            |m: &mut CMsgClientUCMPublishFile| { &mut m.file_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgClientUCMPublishFile| { &m.url },
            |m: &mut CMsgClientUCMPublishFile| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "video_provider",
            |m: &CMsgClientUCMPublishFile| { &m.video_provider },
            |m: &mut CMsgClientUCMPublishFile| { &mut m.video_provider },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "video_account_name",
            |m: &CMsgClientUCMPublishFile| { &m.video_account_name },
            |m: &mut CMsgClientUCMPublishFile| { &mut m.video_account_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "video_identifier",
            |m: &CMsgClientUCMPublishFile| { &m.video_identifier },
            |m: &mut CMsgClientUCMPublishFile| { &mut m.video_identifier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "in_progress",
            |m: &CMsgClientUCMPublishFile| { &m.in_progress },
            |m: &mut CMsgClientUCMPublishFile| { &mut m.in_progress },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUCMPublishFile>(
            "CMsgClientUCMPublishFile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUCMPublishFile {
    const NAME: &'static str = "CMsgClientUCMPublishFile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.file_name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.preview_file_name = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.consumer_app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.tags.push(is.read_string()?);
                },
                72 => {
                    self.workshop_file = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.visibility = ::std::option::Option::Some(is.read_int32()?);
                },
                88 => {
                    self.file_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                98 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                104 => {
                    self.video_provider = ::std::option::Option::Some(is.read_uint32()?);
                },
                114 => {
                    self.video_account_name = ::std::option::Option::Some(is.read_string()?);
                },
                122 => {
                    self.video_identifier = ::std::option::Option::Some(is.read_string()?);
                },
                128 => {
                    self.in_progress = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.preview_file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.consumer_app_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        if let Some(v) = self.workshop_file {
            my_size += 1 + 1;
        }
        if let Some(v) = self.visibility {
            my_size += ::protobuf::rt::int32_size(10, v);
        }
        if let Some(v) = self.file_type {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.video_provider {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.video_account_name.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.video_identifier.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.in_progress {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.file_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.preview_file_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.consumer_app_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(6, v)?;
        }
        for v in &self.tags {
            os.write_string(8, &v)?;
        };
        if let Some(v) = self.workshop_file {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.visibility {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.file_type {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.video_provider {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.video_account_name.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.video_identifier.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.in_progress {
            os.write_bool(16, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMPublishFile {
        CMsgClientUCMPublishFile::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.file_name = ::std::option::Option::None;
        self.preview_file_name = ::std::option::Option::None;
        self.consumer_app_id = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.tags.clear();
        self.workshop_file = ::std::option::Option::None;
        self.visibility = ::std::option::Option::None;
        self.file_type = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.video_provider = ::std::option::Option::None;
        self.video_account_name = ::std::option::Option::None;
        self.video_identifier = ::std::option::Option::None;
        self.in_progress = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMPublishFile {
        static instance: CMsgClientUCMPublishFile = CMsgClientUCMPublishFile {
            app_id: ::std::option::Option::None,
            file_name: ::std::option::Option::None,
            preview_file_name: ::std::option::Option::None,
            consumer_app_id: ::std::option::Option::None,
            title: ::std::option::Option::None,
            description: ::std::option::Option::None,
            tags: ::std::vec::Vec::new(),
            workshop_file: ::std::option::Option::None,
            visibility: ::std::option::Option::None,
            file_type: ::std::option::Option::None,
            url: ::std::option::Option::None,
            video_provider: ::std::option::Option::None,
            video_account_name: ::std::option::Option::None,
            video_identifier: ::std::option::Option::None,
            in_progress: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUCMPublishFile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUCMPublishFile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUCMPublishFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMPublishFile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUCMPublishFileResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMPublishFileResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFileResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFileResponse.published_file_id)
    pub published_file_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishFileResponse.needs_workshop_legal_agreement_acceptance)
    pub needs_workshop_legal_agreement_acceptance: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMPublishFileResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMPublishFileResponse {
    fn default() -> &'a CMsgClientUCMPublishFileResponse {
        <CMsgClientUCMPublishFileResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMPublishFileResponse {
    pub fn new() -> CMsgClientUCMPublishFileResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional fixed64 published_file_id = 2;

    pub fn published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(18446744073709551615u64)
    }

    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional bool needs_workshop_legal_agreement_acceptance = 3;

    pub fn needs_workshop_legal_agreement_acceptance(&self) -> bool {
        self.needs_workshop_legal_agreement_acceptance.unwrap_or(false)
    }

    pub fn clear_needs_workshop_legal_agreement_acceptance(&mut self) {
        self.needs_workshop_legal_agreement_acceptance = ::std::option::Option::None;
    }

    pub fn has_needs_workshop_legal_agreement_acceptance(&self) -> bool {
        self.needs_workshop_legal_agreement_acceptance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needs_workshop_legal_agreement_acceptance(&mut self, v: bool) {
        self.needs_workshop_legal_agreement_acceptance = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientUCMPublishFileResponse| { &m.eresult },
            |m: &mut CMsgClientUCMPublishFileResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "published_file_id",
            |m: &CMsgClientUCMPublishFileResponse| { &m.published_file_id },
            |m: &mut CMsgClientUCMPublishFileResponse| { &mut m.published_file_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "needs_workshop_legal_agreement_acceptance",
            |m: &CMsgClientUCMPublishFileResponse| { &m.needs_workshop_legal_agreement_acceptance },
            |m: &mut CMsgClientUCMPublishFileResponse| { &mut m.needs_workshop_legal_agreement_acceptance },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUCMPublishFileResponse>(
            "CMsgClientUCMPublishFileResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUCMPublishFileResponse {
    const NAME: &'static str = "CMsgClientUCMPublishFileResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                17 => {
                    self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.needs_workshop_legal_agreement_acceptance = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.published_file_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.needs_workshop_legal_agreement_acceptance {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.published_file_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.needs_workshop_legal_agreement_acceptance {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMPublishFileResponse {
        CMsgClientUCMPublishFileResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.published_file_id = ::std::option::Option::None;
        self.needs_workshop_legal_agreement_acceptance = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMPublishFileResponse {
        static instance: CMsgClientUCMPublishFileResponse = CMsgClientUCMPublishFileResponse {
            eresult: ::std::option::Option::None,
            published_file_id: ::std::option::Option::None,
            needs_workshop_legal_agreement_acceptance: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUCMPublishFileResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUCMPublishFileResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUCMPublishFileResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMPublishFileResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUCMUpdatePublishedFile)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMUpdatePublishedFile {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.published_file_id)
    pub published_file_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.file_name)
    pub file_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.preview_file_name)
    pub preview_file_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.tags)
    pub tags: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.visibility)
    pub visibility: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.update_file)
    pub update_file: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.update_preview_file)
    pub update_preview_file: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.update_title)
    pub update_title: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.update_description)
    pub update_description: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.update_tags)
    pub update_tags: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.update_visibility)
    pub update_visibility: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.change_description)
    pub change_description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.update_url)
    pub update_url: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.update_content_manifest)
    pub update_content_manifest: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.content_manifest)
    pub content_manifest: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.metadata)
    pub metadata: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.update_metadata)
    pub update_metadata: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.language)
    pub language: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.removed_kvtags)
    pub removed_kvtags: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.kvtags)
    pub kvtags: ::std::vec::Vec<cmsg_client_ucmupdate_published_file::KeyValueTag>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.previews)
    pub previews: ::std::vec::Vec<cmsg_client_ucmupdate_published_file::AdditionalPreview>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.previews_to_remove)
    pub previews_to_remove: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.clear_in_progress)
    pub clear_in_progress: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.remove_all_kvtags)
    pub remove_all_kvtags: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMUpdatePublishedFile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMUpdatePublishedFile {
    fn default() -> &'a CMsgClientUCMUpdatePublishedFile {
        <CMsgClientUCMUpdatePublishedFile as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMUpdatePublishedFile {
    pub fn new() -> CMsgClientUCMUpdatePublishedFile {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 published_file_id = 2;

    pub fn published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }

    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional string file_name = 3;

    pub fn file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_name(&mut self) {
        self.file_name = ::std::option::Option::None;
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string preview_file_name = 4;

    pub fn preview_file_name(&self) -> &str {
        match self.preview_file_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_preview_file_name(&mut self) {
        self.preview_file_name = ::std::option::Option::None;
    }

    pub fn has_preview_file_name(&self) -> bool {
        self.preview_file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preview_file_name(&mut self, v: ::std::string::String) {
        self.preview_file_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preview_file_name(&mut self) -> &mut ::std::string::String {
        if self.preview_file_name.is_none() {
            self.preview_file_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.preview_file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_preview_file_name(&mut self) -> ::std::string::String {
        self.preview_file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string title = 5;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 6;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 visibility = 8;

    pub fn visibility(&self) -> i32 {
        self.visibility.unwrap_or(0)
    }

    pub fn clear_visibility(&mut self) {
        self.visibility = ::std::option::Option::None;
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: i32) {
        self.visibility = ::std::option::Option::Some(v);
    }

    // optional bool update_file = 9;

    pub fn update_file(&self) -> bool {
        self.update_file.unwrap_or(false)
    }

    pub fn clear_update_file(&mut self) {
        self.update_file = ::std::option::Option::None;
    }

    pub fn has_update_file(&self) -> bool {
        self.update_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_file(&mut self, v: bool) {
        self.update_file = ::std::option::Option::Some(v);
    }

    // optional bool update_preview_file = 10;

    pub fn update_preview_file(&self) -> bool {
        self.update_preview_file.unwrap_or(false)
    }

    pub fn clear_update_preview_file(&mut self) {
        self.update_preview_file = ::std::option::Option::None;
    }

    pub fn has_update_preview_file(&self) -> bool {
        self.update_preview_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_preview_file(&mut self, v: bool) {
        self.update_preview_file = ::std::option::Option::Some(v);
    }

    // optional bool update_title = 11;

    pub fn update_title(&self) -> bool {
        self.update_title.unwrap_or(false)
    }

    pub fn clear_update_title(&mut self) {
        self.update_title = ::std::option::Option::None;
    }

    pub fn has_update_title(&self) -> bool {
        self.update_title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_title(&mut self, v: bool) {
        self.update_title = ::std::option::Option::Some(v);
    }

    // optional bool update_description = 12;

    pub fn update_description(&self) -> bool {
        self.update_description.unwrap_or(false)
    }

    pub fn clear_update_description(&mut self) {
        self.update_description = ::std::option::Option::None;
    }

    pub fn has_update_description(&self) -> bool {
        self.update_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_description(&mut self, v: bool) {
        self.update_description = ::std::option::Option::Some(v);
    }

    // optional bool update_tags = 13;

    pub fn update_tags(&self) -> bool {
        self.update_tags.unwrap_or(false)
    }

    pub fn clear_update_tags(&mut self) {
        self.update_tags = ::std::option::Option::None;
    }

    pub fn has_update_tags(&self) -> bool {
        self.update_tags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_tags(&mut self, v: bool) {
        self.update_tags = ::std::option::Option::Some(v);
    }

    // optional bool update_visibility = 14;

    pub fn update_visibility(&self) -> bool {
        self.update_visibility.unwrap_or(false)
    }

    pub fn clear_update_visibility(&mut self) {
        self.update_visibility = ::std::option::Option::None;
    }

    pub fn has_update_visibility(&self) -> bool {
        self.update_visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_visibility(&mut self, v: bool) {
        self.update_visibility = ::std::option::Option::Some(v);
    }

    // optional string change_description = 15;

    pub fn change_description(&self) -> &str {
        match self.change_description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_change_description(&mut self) {
        self.change_description = ::std::option::Option::None;
    }

    pub fn has_change_description(&self) -> bool {
        self.change_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_change_description(&mut self, v: ::std::string::String) {
        self.change_description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_change_description(&mut self) -> &mut ::std::string::String {
        if self.change_description.is_none() {
            self.change_description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.change_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_change_description(&mut self) -> ::std::string::String {
        self.change_description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool update_url = 16;

    pub fn update_url(&self) -> bool {
        self.update_url.unwrap_or(false)
    }

    pub fn clear_update_url(&mut self) {
        self.update_url = ::std::option::Option::None;
    }

    pub fn has_update_url(&self) -> bool {
        self.update_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_url(&mut self, v: bool) {
        self.update_url = ::std::option::Option::Some(v);
    }

    // optional string url = 17;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool update_content_manifest = 18;

    pub fn update_content_manifest(&self) -> bool {
        self.update_content_manifest.unwrap_or(false)
    }

    pub fn clear_update_content_manifest(&mut self) {
        self.update_content_manifest = ::std::option::Option::None;
    }

    pub fn has_update_content_manifest(&self) -> bool {
        self.update_content_manifest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_content_manifest(&mut self, v: bool) {
        self.update_content_manifest = ::std::option::Option::Some(v);
    }

    // optional fixed64 content_manifest = 19;

    pub fn content_manifest(&self) -> u64 {
        self.content_manifest.unwrap_or(0)
    }

    pub fn clear_content_manifest(&mut self) {
        self.content_manifest = ::std::option::Option::None;
    }

    pub fn has_content_manifest(&self) -> bool {
        self.content_manifest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_content_manifest(&mut self, v: u64) {
        self.content_manifest = ::std::option::Option::Some(v);
    }

    // optional string metadata = 20;

    pub fn metadata(&self) -> &str {
        match self.metadata.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_metadata(&mut self) {
        self.metadata = ::std::option::Option::None;
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::string::String) {
        self.metadata = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::string::String {
        if self.metadata.is_none() {
            self.metadata = ::std::option::Option::Some(::std::string::String::new());
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::string::String {
        self.metadata.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool update_metadata = 21;

    pub fn update_metadata(&self) -> bool {
        self.update_metadata.unwrap_or(false)
    }

    pub fn clear_update_metadata(&mut self) {
        self.update_metadata = ::std::option::Option::None;
    }

    pub fn has_update_metadata(&self) -> bool {
        self.update_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_metadata(&mut self, v: bool) {
        self.update_metadata = ::std::option::Option::Some(v);
    }

    // optional int32 language = 22;

    pub fn language(&self) -> i32 {
        self.language.unwrap_or(0i32)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }

    // optional bool clear_in_progress = 27;

    pub fn clear_in_progress(&self) -> bool {
        self.clear_in_progress.unwrap_or(false)
    }

    pub fn clear_clear_in_progress(&mut self) {
        self.clear_in_progress = ::std::option::Option::None;
    }

    pub fn has_clear_in_progress(&self) -> bool {
        self.clear_in_progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clear_in_progress(&mut self, v: bool) {
        self.clear_in_progress = ::std::option::Option::Some(v);
    }

    // optional bool remove_all_kvtags = 28;

    pub fn remove_all_kvtags(&self) -> bool {
        self.remove_all_kvtags.unwrap_or(false)
    }

    pub fn clear_remove_all_kvtags(&mut self) {
        self.remove_all_kvtags = ::std::option::Option::None;
    }

    pub fn has_remove_all_kvtags(&self) -> bool {
        self.remove_all_kvtags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remove_all_kvtags(&mut self, v: bool) {
        self.remove_all_kvtags = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(28);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.app_id },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "published_file_id",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.published_file_id },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.published_file_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_name",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.file_name },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.file_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "preview_file_name",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.preview_file_name },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.preview_file_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.title },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.description },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tags",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.tags },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.tags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "visibility",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.visibility },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.visibility },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "update_file",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.update_file },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.update_file },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "update_preview_file",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.update_preview_file },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.update_preview_file },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "update_title",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.update_title },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.update_title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "update_description",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.update_description },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.update_description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "update_tags",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.update_tags },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.update_tags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "update_visibility",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.update_visibility },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.update_visibility },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "change_description",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.change_description },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.change_description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "update_url",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.update_url },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.update_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.url },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "update_content_manifest",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.update_content_manifest },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.update_content_manifest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "content_manifest",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.content_manifest },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.content_manifest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "metadata",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.metadata },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "update_metadata",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.update_metadata },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.update_metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "language",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.language },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.language },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "removed_kvtags",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.removed_kvtags },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.removed_kvtags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "kvtags",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.kvtags },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.kvtags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "previews",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.previews },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.previews },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "previews_to_remove",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.previews_to_remove },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.previews_to_remove },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "clear_in_progress",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.clear_in_progress },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.clear_in_progress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "remove_all_kvtags",
            |m: &CMsgClientUCMUpdatePublishedFile| { &m.remove_all_kvtags },
            |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.remove_all_kvtags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUCMUpdatePublishedFile>(
            "CMsgClientUCMUpdatePublishedFile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUCMUpdatePublishedFile {
    const NAME: &'static str = "CMsgClientUCMUpdatePublishedFile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.file_name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.preview_file_name = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.tags.push(is.read_string()?);
                },
                64 => {
                    self.visibility = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.update_file = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.update_preview_file = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.update_title = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.update_description = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.update_tags = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.update_visibility = ::std::option::Option::Some(is.read_bool()?);
                },
                122 => {
                    self.change_description = ::std::option::Option::Some(is.read_string()?);
                },
                128 => {
                    self.update_url = ::std::option::Option::Some(is.read_bool()?);
                },
                138 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                144 => {
                    self.update_content_manifest = ::std::option::Option::Some(is.read_bool()?);
                },
                153 => {
                    self.content_manifest = ::std::option::Option::Some(is.read_fixed64()?);
                },
                162 => {
                    self.metadata = ::std::option::Option::Some(is.read_string()?);
                },
                168 => {
                    self.update_metadata = ::std::option::Option::Some(is.read_bool()?);
                },
                176 => {
                    self.language = ::std::option::Option::Some(is.read_int32()?);
                },
                186 => {
                    self.removed_kvtags.push(is.read_string()?);
                },
                194 => {
                    self.kvtags.push(is.read_message()?);
                },
                202 => {
                    self.previews.push(is.read_message()?);
                },
                210 => {
                    is.read_repeated_packed_int32_into(&mut self.previews_to_remove)?;
                },
                208 => {
                    self.previews_to_remove.push(is.read_int32()?);
                },
                216 => {
                    self.clear_in_progress = ::std::option::Option::Some(is.read_bool()?);
                },
                224 => {
                    self.remove_all_kvtags = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.published_file_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.preview_file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(v) = self.visibility {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.update_file {
            my_size += 1 + 1;
        }
        if let Some(v) = self.update_preview_file {
            my_size += 1 + 1;
        }
        if let Some(v) = self.update_title {
            my_size += 1 + 1;
        }
        if let Some(v) = self.update_description {
            my_size += 1 + 1;
        }
        if let Some(v) = self.update_tags {
            my_size += 1 + 1;
        }
        if let Some(v) = self.update_visibility {
            my_size += 1 + 1;
        }
        if let Some(v) = self.change_description.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.update_url {
            my_size += 2 + 1;
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        if let Some(v) = self.update_content_manifest {
            my_size += 2 + 1;
        }
        if let Some(v) = self.content_manifest {
            my_size += 2 + 8;
        }
        if let Some(v) = self.metadata.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        if let Some(v) = self.update_metadata {
            my_size += 2 + 1;
        }
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::int32_size(22, v);
        }
        for value in &self.removed_kvtags {
            my_size += ::protobuf::rt::string_size(23, &value);
        };
        for value in &self.kvtags {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.previews {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.previews_to_remove {
            my_size += ::protobuf::rt::int32_size(26, *value);
        };
        if let Some(v) = self.clear_in_progress {
            my_size += 2 + 1;
        }
        if let Some(v) = self.remove_all_kvtags {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.published_file_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.file_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.preview_file_name.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(6, v)?;
        }
        for v in &self.tags {
            os.write_string(7, &v)?;
        };
        if let Some(v) = self.visibility {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.update_file {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.update_preview_file {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.update_title {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.update_description {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.update_tags {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.update_visibility {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.change_description.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.update_url {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(17, v)?;
        }
        if let Some(v) = self.update_content_manifest {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.content_manifest {
            os.write_fixed64(19, v)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            os.write_string(20, v)?;
        }
        if let Some(v) = self.update_metadata {
            os.write_bool(21, v)?;
        }
        if let Some(v) = self.language {
            os.write_int32(22, v)?;
        }
        for v in &self.removed_kvtags {
            os.write_string(23, &v)?;
        };
        for v in &self.kvtags {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        };
        for v in &self.previews {
            ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
        };
        for v in &self.previews_to_remove {
            os.write_int32(26, *v)?;
        };
        if let Some(v) = self.clear_in_progress {
            os.write_bool(27, v)?;
        }
        if let Some(v) = self.remove_all_kvtags {
            os.write_bool(28, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMUpdatePublishedFile {
        CMsgClientUCMUpdatePublishedFile::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.published_file_id = ::std::option::Option::None;
        self.file_name = ::std::option::Option::None;
        self.preview_file_name = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.tags.clear();
        self.visibility = ::std::option::Option::None;
        self.update_file = ::std::option::Option::None;
        self.update_preview_file = ::std::option::Option::None;
        self.update_title = ::std::option::Option::None;
        self.update_description = ::std::option::Option::None;
        self.update_tags = ::std::option::Option::None;
        self.update_visibility = ::std::option::Option::None;
        self.change_description = ::std::option::Option::None;
        self.update_url = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.update_content_manifest = ::std::option::Option::None;
        self.content_manifest = ::std::option::Option::None;
        self.metadata = ::std::option::Option::None;
        self.update_metadata = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.removed_kvtags.clear();
        self.kvtags.clear();
        self.previews.clear();
        self.previews_to_remove.clear();
        self.clear_in_progress = ::std::option::Option::None;
        self.remove_all_kvtags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMUpdatePublishedFile {
        static instance: CMsgClientUCMUpdatePublishedFile = CMsgClientUCMUpdatePublishedFile {
            app_id: ::std::option::Option::None,
            published_file_id: ::std::option::Option::None,
            file_name: ::std::option::Option::None,
            preview_file_name: ::std::option::Option::None,
            title: ::std::option::Option::None,
            description: ::std::option::Option::None,
            tags: ::std::vec::Vec::new(),
            visibility: ::std::option::Option::None,
            update_file: ::std::option::Option::None,
            update_preview_file: ::std::option::Option::None,
            update_title: ::std::option::Option::None,
            update_description: ::std::option::Option::None,
            update_tags: ::std::option::Option::None,
            update_visibility: ::std::option::Option::None,
            change_description: ::std::option::Option::None,
            update_url: ::std::option::Option::None,
            url: ::std::option::Option::None,
            update_content_manifest: ::std::option::Option::None,
            content_manifest: ::std::option::Option::None,
            metadata: ::std::option::Option::None,
            update_metadata: ::std::option::Option::None,
            language: ::std::option::Option::None,
            removed_kvtags: ::std::vec::Vec::new(),
            kvtags: ::std::vec::Vec::new(),
            previews: ::std::vec::Vec::new(),
            previews_to_remove: ::std::vec::Vec::new(),
            clear_in_progress: ::std::option::Option::None,
            remove_all_kvtags: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUCMUpdatePublishedFile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUCMUpdatePublishedFile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUCMUpdatePublishedFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMUpdatePublishedFile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientUCMUpdatePublishedFile`
pub mod cmsg_client_ucmupdate_published_file {
    // @@protoc_insertion_point(message:CMsgClientUCMUpdatePublishedFile.KeyValueTag)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct KeyValueTag {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.KeyValueTag.key)
        pub key: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.KeyValueTag.value)
        pub value: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientUCMUpdatePublishedFile.KeyValueTag.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a KeyValueTag {
        fn default() -> &'a KeyValueTag {
            <KeyValueTag as ::protobuf::Message>::default_instance()
        }
    }

    impl KeyValueTag {
        pub fn new() -> KeyValueTag {
            ::std::default::Default::default()
        }

        // optional string key = 1;

        pub fn key(&self) -> &str {
            match self.key.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_key(&mut self) {
            self.key = ::std::option::Option::None;
        }

        pub fn has_key(&self) -> bool {
            self.key.is_some()
        }

        // Param is passed by value, moved
        pub fn set_key(&mut self, v: ::std::string::String) {
            self.key = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_key(&mut self) -> &mut ::std::string::String {
            if self.key.is_none() {
                self.key = ::std::option::Option::Some(::std::string::String::new());
            }
            self.key.as_mut().unwrap()
        }

        // Take field
        pub fn take_key(&mut self) -> ::std::string::String {
            self.key.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string value = 2;

        pub fn value(&self) -> &str {
            match self.value.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: ::std::string::String) {
            self.value = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_value(&mut self) -> &mut ::std::string::String {
            if self.value.is_none() {
                self.value = ::std::option::Option::Some(::std::string::String::new());
            }
            self.value.as_mut().unwrap()
        }

        // Take field
        pub fn take_value(&mut self) -> ::std::string::String {
            self.value.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "key",
                |m: &KeyValueTag| { &m.key },
                |m: &mut KeyValueTag| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "value",
                |m: &KeyValueTag| { &m.value },
                |m: &mut KeyValueTag| { &mut m.value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KeyValueTag>(
                "CMsgClientUCMUpdatePublishedFile.KeyValueTag",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for KeyValueTag {
        const NAME: &'static str = "KeyValueTag";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.key = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.value = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.key.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.value.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.key.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.value.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> KeyValueTag {
            KeyValueTag::new()
        }

        fn clear(&mut self) {
            self.key = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static KeyValueTag {
            static instance: KeyValueTag = KeyValueTag {
                key: ::std::option::Option::None,
                value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for KeyValueTag {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientUCMUpdatePublishedFile.KeyValueTag").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for KeyValueTag {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for KeyValueTag {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgClientUCMUpdatePublishedFile.AdditionalPreview)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AdditionalPreview {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.AdditionalPreview.original_file_name)
        pub original_file_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.AdditionalPreview.internal_file_name)
        pub internal_file_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.AdditionalPreview.videoid)
        pub videoid: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.AdditionalPreview.preview_type)
        pub preview_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFile.AdditionalPreview.update_index)
        pub update_index: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientUCMUpdatePublishedFile.AdditionalPreview.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AdditionalPreview {
        fn default() -> &'a AdditionalPreview {
            <AdditionalPreview as ::protobuf::Message>::default_instance()
        }
    }

    impl AdditionalPreview {
        pub fn new() -> AdditionalPreview {
            ::std::default::Default::default()
        }

        // optional string original_file_name = 1;

        pub fn original_file_name(&self) -> &str {
            match self.original_file_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_original_file_name(&mut self) {
            self.original_file_name = ::std::option::Option::None;
        }

        pub fn has_original_file_name(&self) -> bool {
            self.original_file_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_original_file_name(&mut self, v: ::std::string::String) {
            self.original_file_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_original_file_name(&mut self) -> &mut ::std::string::String {
            if self.original_file_name.is_none() {
                self.original_file_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.original_file_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_original_file_name(&mut self) -> ::std::string::String {
            self.original_file_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string internal_file_name = 2;

        pub fn internal_file_name(&self) -> &str {
            match self.internal_file_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_internal_file_name(&mut self) {
            self.internal_file_name = ::std::option::Option::None;
        }

        pub fn has_internal_file_name(&self) -> bool {
            self.internal_file_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_internal_file_name(&mut self, v: ::std::string::String) {
            self.internal_file_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_internal_file_name(&mut self) -> &mut ::std::string::String {
            if self.internal_file_name.is_none() {
                self.internal_file_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.internal_file_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_internal_file_name(&mut self) -> ::std::string::String {
            self.internal_file_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string videoid = 3;

        pub fn videoid(&self) -> &str {
            match self.videoid.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_videoid(&mut self) {
            self.videoid = ::std::option::Option::None;
        }

        pub fn has_videoid(&self) -> bool {
            self.videoid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_videoid(&mut self, v: ::std::string::String) {
            self.videoid = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_videoid(&mut self) -> &mut ::std::string::String {
            if self.videoid.is_none() {
                self.videoid = ::std::option::Option::Some(::std::string::String::new());
            }
            self.videoid.as_mut().unwrap()
        }

        // Take field
        pub fn take_videoid(&mut self) -> ::std::string::String {
            self.videoid.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 preview_type = 4;

        pub fn preview_type(&self) -> u32 {
            self.preview_type.unwrap_or(0)
        }

        pub fn clear_preview_type(&mut self) {
            self.preview_type = ::std::option::Option::None;
        }

        pub fn has_preview_type(&self) -> bool {
            self.preview_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_preview_type(&mut self, v: u32) {
            self.preview_type = ::std::option::Option::Some(v);
        }

        // optional int32 update_index = 5;

        pub fn update_index(&self) -> i32 {
            self.update_index.unwrap_or(-1i32)
        }

        pub fn clear_update_index(&mut self) {
            self.update_index = ::std::option::Option::None;
        }

        pub fn has_update_index(&self) -> bool {
            self.update_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_update_index(&mut self, v: i32) {
            self.update_index = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "original_file_name",
                |m: &AdditionalPreview| { &m.original_file_name },
                |m: &mut AdditionalPreview| { &mut m.original_file_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "internal_file_name",
                |m: &AdditionalPreview| { &m.internal_file_name },
                |m: &mut AdditionalPreview| { &mut m.internal_file_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "videoid",
                |m: &AdditionalPreview| { &m.videoid },
                |m: &mut AdditionalPreview| { &mut m.videoid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "preview_type",
                |m: &AdditionalPreview| { &m.preview_type },
                |m: &mut AdditionalPreview| { &mut m.preview_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "update_index",
                |m: &AdditionalPreview| { &m.update_index },
                |m: &mut AdditionalPreview| { &mut m.update_index },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AdditionalPreview>(
                "CMsgClientUCMUpdatePublishedFile.AdditionalPreview",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AdditionalPreview {
        const NAME: &'static str = "AdditionalPreview";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.original_file_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.internal_file_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.videoid = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.preview_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.update_index = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.original_file_name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.internal_file_name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.videoid.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.preview_type {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.update_index {
                my_size += ::protobuf::rt::int32_size(5, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.original_file_name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.internal_file_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.videoid.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.preview_type {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.update_index {
                os.write_int32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AdditionalPreview {
            AdditionalPreview::new()
        }

        fn clear(&mut self) {
            self.original_file_name = ::std::option::Option::None;
            self.internal_file_name = ::std::option::Option::None;
            self.videoid = ::std::option::Option::None;
            self.preview_type = ::std::option::Option::None;
            self.update_index = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AdditionalPreview {
            static instance: AdditionalPreview = AdditionalPreview {
                original_file_name: ::std::option::Option::None,
                internal_file_name: ::std::option::Option::None,
                videoid: ::std::option::Option::None,
                preview_type: ::std::option::Option::None,
                update_index: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AdditionalPreview {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientUCMUpdatePublishedFile.AdditionalPreview").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AdditionalPreview {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AdditionalPreview {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientUCMUpdatePublishedFileResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMUpdatePublishedFileResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFileResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUCMUpdatePublishedFileResponse.needs_workshop_legal_agreement_acceptance)
    pub needs_workshop_legal_agreement_acceptance: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMUpdatePublishedFileResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMUpdatePublishedFileResponse {
    fn default() -> &'a CMsgClientUCMUpdatePublishedFileResponse {
        <CMsgClientUCMUpdatePublishedFileResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMUpdatePublishedFileResponse {
    pub fn new() -> CMsgClientUCMUpdatePublishedFileResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional bool needs_workshop_legal_agreement_acceptance = 2;

    pub fn needs_workshop_legal_agreement_acceptance(&self) -> bool {
        self.needs_workshop_legal_agreement_acceptance.unwrap_or(false)
    }

    pub fn clear_needs_workshop_legal_agreement_acceptance(&mut self) {
        self.needs_workshop_legal_agreement_acceptance = ::std::option::Option::None;
    }

    pub fn has_needs_workshop_legal_agreement_acceptance(&self) -> bool {
        self.needs_workshop_legal_agreement_acceptance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needs_workshop_legal_agreement_acceptance(&mut self, v: bool) {
        self.needs_workshop_legal_agreement_acceptance = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientUCMUpdatePublishedFileResponse| { &m.eresult },
            |m: &mut CMsgClientUCMUpdatePublishedFileResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "needs_workshop_legal_agreement_acceptance",
            |m: &CMsgClientUCMUpdatePublishedFileResponse| { &m.needs_workshop_legal_agreement_acceptance },
            |m: &mut CMsgClientUCMUpdatePublishedFileResponse| { &mut m.needs_workshop_legal_agreement_acceptance },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUCMUpdatePublishedFileResponse>(
            "CMsgClientUCMUpdatePublishedFileResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUCMUpdatePublishedFileResponse {
    const NAME: &'static str = "CMsgClientUCMUpdatePublishedFileResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.needs_workshop_legal_agreement_acceptance = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.needs_workshop_legal_agreement_acceptance {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.needs_workshop_legal_agreement_acceptance {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMUpdatePublishedFileResponse {
        CMsgClientUCMUpdatePublishedFileResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.needs_workshop_legal_agreement_acceptance = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMUpdatePublishedFileResponse {
        static instance: CMsgClientUCMUpdatePublishedFileResponse = CMsgClientUCMUpdatePublishedFileResponse {
            eresult: ::std::option::Option::None,
            needs_workshop_legal_agreement_acceptance: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUCMUpdatePublishedFileResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUCMUpdatePublishedFileResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUCMUpdatePublishedFileResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMUpdatePublishedFileResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUCMDeletePublishedFile)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMDeletePublishedFile {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMDeletePublishedFile.published_file_id)
    pub published_file_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUCMDeletePublishedFile.app_id)
    pub app_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMDeletePublishedFile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMDeletePublishedFile {
    fn default() -> &'a CMsgClientUCMDeletePublishedFile {
        <CMsgClientUCMDeletePublishedFile as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMDeletePublishedFile {
    pub fn new() -> CMsgClientUCMDeletePublishedFile {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;

    pub fn published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }

    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "published_file_id",
            |m: &CMsgClientUCMDeletePublishedFile| { &m.published_file_id },
            |m: &mut CMsgClientUCMDeletePublishedFile| { &mut m.published_file_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientUCMDeletePublishedFile| { &m.app_id },
            |m: &mut CMsgClientUCMDeletePublishedFile| { &mut m.app_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUCMDeletePublishedFile>(
            "CMsgClientUCMDeletePublishedFile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUCMDeletePublishedFile {
    const NAME: &'static str = "CMsgClientUCMDeletePublishedFile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMDeletePublishedFile {
        CMsgClientUCMDeletePublishedFile::new()
    }

    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMDeletePublishedFile {
        static instance: CMsgClientUCMDeletePublishedFile = CMsgClientUCMDeletePublishedFile {
            published_file_id: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUCMDeletePublishedFile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUCMDeletePublishedFile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUCMDeletePublishedFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMDeletePublishedFile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUCMDeletePublishedFileResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMDeletePublishedFileResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMDeletePublishedFileResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMDeletePublishedFileResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMDeletePublishedFileResponse {
    fn default() -> &'a CMsgClientUCMDeletePublishedFileResponse {
        <CMsgClientUCMDeletePublishedFileResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMDeletePublishedFileResponse {
    pub fn new() -> CMsgClientUCMDeletePublishedFileResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientUCMDeletePublishedFileResponse| { &m.eresult },
            |m: &mut CMsgClientUCMDeletePublishedFileResponse| { &mut m.eresult },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUCMDeletePublishedFileResponse>(
            "CMsgClientUCMDeletePublishedFileResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUCMDeletePublishedFileResponse {
    const NAME: &'static str = "CMsgClientUCMDeletePublishedFileResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMDeletePublishedFileResponse {
        CMsgClientUCMDeletePublishedFileResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMDeletePublishedFileResponse {
        static instance: CMsgClientUCMDeletePublishedFileResponse = CMsgClientUCMDeletePublishedFileResponse {
            eresult: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUCMDeletePublishedFileResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUCMDeletePublishedFileResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUCMDeletePublishedFileResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMDeletePublishedFileResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUCMEnumerateUserPublishedFiles)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMEnumerateUserPublishedFiles {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserPublishedFiles.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserPublishedFiles.start_index)
    pub start_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserPublishedFiles.sort_order)
    pub sort_order: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMEnumerateUserPublishedFiles.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMEnumerateUserPublishedFiles {
    fn default() -> &'a CMsgClientUCMEnumerateUserPublishedFiles {
        <CMsgClientUCMEnumerateUserPublishedFiles as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMEnumerateUserPublishedFiles {
    pub fn new() -> CMsgClientUCMEnumerateUserPublishedFiles {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 start_index = 2;

    pub fn start_index(&self) -> u32 {
        self.start_index.unwrap_or(0)
    }

    pub fn clear_start_index(&mut self) {
        self.start_index = ::std::option::Option::None;
    }

    pub fn has_start_index(&self) -> bool {
        self.start_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_index(&mut self, v: u32) {
        self.start_index = ::std::option::Option::Some(v);
    }

    // optional uint32 sort_order = 3;

    pub fn sort_order(&self) -> u32 {
        self.sort_order.unwrap_or(0)
    }

    pub fn clear_sort_order(&mut self) {
        self.sort_order = ::std::option::Option::None;
    }

    pub fn has_sort_order(&self) -> bool {
        self.sort_order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sort_order(&mut self, v: u32) {
        self.sort_order = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientUCMEnumerateUserPublishedFiles| { &m.app_id },
            |m: &mut CMsgClientUCMEnumerateUserPublishedFiles| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_index",
            |m: &CMsgClientUCMEnumerateUserPublishedFiles| { &m.start_index },
            |m: &mut CMsgClientUCMEnumerateUserPublishedFiles| { &mut m.start_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sort_order",
            |m: &CMsgClientUCMEnumerateUserPublishedFiles| { &m.sort_order },
            |m: &mut CMsgClientUCMEnumerateUserPublishedFiles| { &mut m.sort_order },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUCMEnumerateUserPublishedFiles>(
            "CMsgClientUCMEnumerateUserPublishedFiles",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUCMEnumerateUserPublishedFiles {
    const NAME: &'static str = "CMsgClientUCMEnumerateUserPublishedFiles";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.start_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.sort_order = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.start_index {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.sort_order {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.start_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.sort_order {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMEnumerateUserPublishedFiles {
        CMsgClientUCMEnumerateUserPublishedFiles::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.start_index = ::std::option::Option::None;
        self.sort_order = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMEnumerateUserPublishedFiles {
        static instance: CMsgClientUCMEnumerateUserPublishedFiles = CMsgClientUCMEnumerateUserPublishedFiles {
            app_id: ::std::option::Option::None,
            start_index: ::std::option::Option::None,
            sort_order: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUCMEnumerateUserPublishedFiles {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUCMEnumerateUserPublishedFiles").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUCMEnumerateUserPublishedFiles {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMEnumerateUserPublishedFiles {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUCMEnumerateUserPublishedFilesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMEnumerateUserPublishedFilesResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserPublishedFilesResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserPublishedFilesResponse.published_files)
    pub published_files: ::std::vec::Vec<cmsg_client_ucmenumerate_user_published_files_response::PublishedFileId>,
    // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserPublishedFilesResponse.total_results)
    pub total_results: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMEnumerateUserPublishedFilesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMEnumerateUserPublishedFilesResponse {
    fn default() -> &'a CMsgClientUCMEnumerateUserPublishedFilesResponse {
        <CMsgClientUCMEnumerateUserPublishedFilesResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMEnumerateUserPublishedFilesResponse {
    pub fn new() -> CMsgClientUCMEnumerateUserPublishedFilesResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 total_results = 3;

    pub fn total_results(&self) -> u32 {
        self.total_results.unwrap_or(0)
    }

    pub fn clear_total_results(&mut self) {
        self.total_results = ::std::option::Option::None;
    }

    pub fn has_total_results(&self) -> bool {
        self.total_results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_results(&mut self, v: u32) {
        self.total_results = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientUCMEnumerateUserPublishedFilesResponse| { &m.eresult },
            |m: &mut CMsgClientUCMEnumerateUserPublishedFilesResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "published_files",
            |m: &CMsgClientUCMEnumerateUserPublishedFilesResponse| { &m.published_files },
            |m: &mut CMsgClientUCMEnumerateUserPublishedFilesResponse| { &mut m.published_files },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_results",
            |m: &CMsgClientUCMEnumerateUserPublishedFilesResponse| { &m.total_results },
            |m: &mut CMsgClientUCMEnumerateUserPublishedFilesResponse| { &mut m.total_results },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUCMEnumerateUserPublishedFilesResponse>(
            "CMsgClientUCMEnumerateUserPublishedFilesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUCMEnumerateUserPublishedFilesResponse {
    const NAME: &'static str = "CMsgClientUCMEnumerateUserPublishedFilesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.published_files.push(is.read_message()?);
                },
                24 => {
                    self.total_results = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.published_files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.total_results {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.published_files {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.total_results {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMEnumerateUserPublishedFilesResponse {
        CMsgClientUCMEnumerateUserPublishedFilesResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.published_files.clear();
        self.total_results = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMEnumerateUserPublishedFilesResponse {
        static instance: CMsgClientUCMEnumerateUserPublishedFilesResponse = CMsgClientUCMEnumerateUserPublishedFilesResponse {
            eresult: ::std::option::Option::None,
            published_files: ::std::vec::Vec::new(),
            total_results: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUCMEnumerateUserPublishedFilesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUCMEnumerateUserPublishedFilesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUCMEnumerateUserPublishedFilesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMEnumerateUserPublishedFilesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientUCMEnumerateUserPublishedFilesResponse`
pub mod cmsg_client_ucmenumerate_user_published_files_response {
    // @@protoc_insertion_point(message:CMsgClientUCMEnumerateUserPublishedFilesResponse.PublishedFileId)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PublishedFileId {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserPublishedFilesResponse.PublishedFileId.published_file_id)
        pub published_file_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientUCMEnumerateUserPublishedFilesResponse.PublishedFileId.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PublishedFileId {
        fn default() -> &'a PublishedFileId {
            <PublishedFileId as ::protobuf::Message>::default_instance()
        }
    }

    impl PublishedFileId {
        pub fn new() -> PublishedFileId {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "published_file_id",
                |m: &PublishedFileId| { &m.published_file_id },
                |m: &mut PublishedFileId| { &mut m.published_file_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PublishedFileId>(
                "CMsgClientUCMEnumerateUserPublishedFilesResponse.PublishedFileId",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PublishedFileId {
        const NAME: &'static str = "PublishedFileId";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PublishedFileId {
            PublishedFileId::new()
        }

        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PublishedFileId {
            static instance: PublishedFileId = PublishedFileId {
                published_file_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PublishedFileId {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientUCMEnumerateUserPublishedFilesResponse.PublishedFileId").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PublishedFileId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PublishedFileId {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientUCMEnumerateUserSubscribedFiles)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMEnumerateUserSubscribedFiles {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFiles.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFiles.start_index)
    pub start_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFiles.list_type)
    pub list_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFiles.matching_file_type)
    pub matching_file_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFiles.count)
    pub count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMEnumerateUserSubscribedFiles.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMEnumerateUserSubscribedFiles {
    fn default() -> &'a CMsgClientUCMEnumerateUserSubscribedFiles {
        <CMsgClientUCMEnumerateUserSubscribedFiles as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMEnumerateUserSubscribedFiles {
    pub fn new() -> CMsgClientUCMEnumerateUserSubscribedFiles {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 start_index = 2;

    pub fn start_index(&self) -> u32 {
        self.start_index.unwrap_or(0)
    }

    pub fn clear_start_index(&mut self) {
        self.start_index = ::std::option::Option::None;
    }

    pub fn has_start_index(&self) -> bool {
        self.start_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_index(&mut self, v: u32) {
        self.start_index = ::std::option::Option::Some(v);
    }

    // optional uint32 list_type = 3;

    pub fn list_type(&self) -> u32 {
        self.list_type.unwrap_or(1u32)
    }

    pub fn clear_list_type(&mut self) {
        self.list_type = ::std::option::Option::None;
    }

    pub fn has_list_type(&self) -> bool {
        self.list_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_list_type(&mut self, v: u32) {
        self.list_type = ::std::option::Option::Some(v);
    }

    // optional uint32 matching_file_type = 4;

    pub fn matching_file_type(&self) -> u32 {
        self.matching_file_type.unwrap_or(0u32)
    }

    pub fn clear_matching_file_type(&mut self) {
        self.matching_file_type = ::std::option::Option::None;
    }

    pub fn has_matching_file_type(&self) -> bool {
        self.matching_file_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matching_file_type(&mut self, v: u32) {
        self.matching_file_type = ::std::option::Option::Some(v);
    }

    // optional uint32 count = 5;

    pub fn count(&self) -> u32 {
        self.count.unwrap_or(50u32)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientUCMEnumerateUserSubscribedFiles| { &m.app_id },
            |m: &mut CMsgClientUCMEnumerateUserSubscribedFiles| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_index",
            |m: &CMsgClientUCMEnumerateUserSubscribedFiles| { &m.start_index },
            |m: &mut CMsgClientUCMEnumerateUserSubscribedFiles| { &mut m.start_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "list_type",
            |m: &CMsgClientUCMEnumerateUserSubscribedFiles| { &m.list_type },
            |m: &mut CMsgClientUCMEnumerateUserSubscribedFiles| { &mut m.list_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matching_file_type",
            |m: &CMsgClientUCMEnumerateUserSubscribedFiles| { &m.matching_file_type },
            |m: &mut CMsgClientUCMEnumerateUserSubscribedFiles| { &mut m.matching_file_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "count",
            |m: &CMsgClientUCMEnumerateUserSubscribedFiles| { &m.count },
            |m: &mut CMsgClientUCMEnumerateUserSubscribedFiles| { &mut m.count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUCMEnumerateUserSubscribedFiles>(
            "CMsgClientUCMEnumerateUserSubscribedFiles",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUCMEnumerateUserSubscribedFiles {
    const NAME: &'static str = "CMsgClientUCMEnumerateUserSubscribedFiles";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.start_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.list_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.matching_file_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.start_index {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.list_type {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.matching_file_type {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.start_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.list_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.matching_file_type {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.count {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMEnumerateUserSubscribedFiles {
        CMsgClientUCMEnumerateUserSubscribedFiles::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.start_index = ::std::option::Option::None;
        self.list_type = ::std::option::Option::None;
        self.matching_file_type = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMEnumerateUserSubscribedFiles {
        static instance: CMsgClientUCMEnumerateUserSubscribedFiles = CMsgClientUCMEnumerateUserSubscribedFiles {
            app_id: ::std::option::Option::None,
            start_index: ::std::option::Option::None,
            list_type: ::std::option::Option::None,
            matching_file_type: ::std::option::Option::None,
            count: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUCMEnumerateUserSubscribedFiles {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUCMEnumerateUserSubscribedFiles").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUCMEnumerateUserSubscribedFiles {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMEnumerateUserSubscribedFiles {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUCMEnumerateUserSubscribedFilesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMEnumerateUserSubscribedFilesResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesResponse.subscribed_files)
    pub subscribed_files: ::std::vec::Vec<cmsg_client_ucmenumerate_user_subscribed_files_response::PublishedFileId>,
    // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesResponse.total_results)
    pub total_results: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMEnumerateUserSubscribedFilesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMEnumerateUserSubscribedFilesResponse {
    fn default() -> &'a CMsgClientUCMEnumerateUserSubscribedFilesResponse {
        <CMsgClientUCMEnumerateUserSubscribedFilesResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMEnumerateUserSubscribedFilesResponse {
    pub fn new() -> CMsgClientUCMEnumerateUserSubscribedFilesResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 total_results = 3;

    pub fn total_results(&self) -> u32 {
        self.total_results.unwrap_or(0)
    }

    pub fn clear_total_results(&mut self) {
        self.total_results = ::std::option::Option::None;
    }

    pub fn has_total_results(&self) -> bool {
        self.total_results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_results(&mut self, v: u32) {
        self.total_results = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientUCMEnumerateUserSubscribedFilesResponse| { &m.eresult },
            |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "subscribed_files",
            |m: &CMsgClientUCMEnumerateUserSubscribedFilesResponse| { &m.subscribed_files },
            |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesResponse| { &mut m.subscribed_files },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_results",
            |m: &CMsgClientUCMEnumerateUserSubscribedFilesResponse| { &m.total_results },
            |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesResponse| { &mut m.total_results },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUCMEnumerateUserSubscribedFilesResponse>(
            "CMsgClientUCMEnumerateUserSubscribedFilesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUCMEnumerateUserSubscribedFilesResponse {
    const NAME: &'static str = "CMsgClientUCMEnumerateUserSubscribedFilesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.subscribed_files.push(is.read_message()?);
                },
                24 => {
                    self.total_results = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.subscribed_files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.total_results {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.subscribed_files {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.total_results {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMEnumerateUserSubscribedFilesResponse {
        CMsgClientUCMEnumerateUserSubscribedFilesResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.subscribed_files.clear();
        self.total_results = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMEnumerateUserSubscribedFilesResponse {
        static instance: CMsgClientUCMEnumerateUserSubscribedFilesResponse = CMsgClientUCMEnumerateUserSubscribedFilesResponse {
            eresult: ::std::option::Option::None,
            subscribed_files: ::std::vec::Vec::new(),
            total_results: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUCMEnumerateUserSubscribedFilesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUCMEnumerateUserSubscribedFilesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUCMEnumerateUserSubscribedFilesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMEnumerateUserSubscribedFilesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientUCMEnumerateUserSubscribedFilesResponse`
pub mod cmsg_client_ucmenumerate_user_subscribed_files_response {
    // @@protoc_insertion_point(message:CMsgClientUCMEnumerateUserSubscribedFilesResponse.PublishedFileId)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PublishedFileId {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesResponse.PublishedFileId.published_file_id)
        pub published_file_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesResponse.PublishedFileId.rtime32_subscribed)
        pub rtime32_subscribed: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientUCMEnumerateUserSubscribedFilesResponse.PublishedFileId.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PublishedFileId {
        fn default() -> &'a PublishedFileId {
            <PublishedFileId as ::protobuf::Message>::default_instance()
        }
    }

    impl PublishedFileId {
        pub fn new() -> PublishedFileId {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }

        // optional fixed32 rtime32_subscribed = 2;

        pub fn rtime32_subscribed(&self) -> u32 {
            self.rtime32_subscribed.unwrap_or(0u32)
        }

        pub fn clear_rtime32_subscribed(&mut self) {
            self.rtime32_subscribed = ::std::option::Option::None;
        }

        pub fn has_rtime32_subscribed(&self) -> bool {
            self.rtime32_subscribed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rtime32_subscribed(&mut self, v: u32) {
            self.rtime32_subscribed = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "published_file_id",
                |m: &PublishedFileId| { &m.published_file_id },
                |m: &mut PublishedFileId| { &mut m.published_file_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rtime32_subscribed",
                |m: &PublishedFileId| { &m.rtime32_subscribed },
                |m: &mut PublishedFileId| { &mut m.rtime32_subscribed },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PublishedFileId>(
                "CMsgClientUCMEnumerateUserSubscribedFilesResponse.PublishedFileId",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PublishedFileId {
        const NAME: &'static str = "PublishedFileId";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    21 => {
                        self.rtime32_subscribed = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.rtime32_subscribed {
                my_size += 1 + 4;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.rtime32_subscribed {
                os.write_fixed32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PublishedFileId {
            PublishedFileId::new()
        }

        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.rtime32_subscribed = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PublishedFileId {
            static instance: PublishedFileId = PublishedFileId {
                published_file_id: ::std::option::Option::None,
                rtime32_subscribed: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PublishedFileId {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientUCMEnumerateUserSubscribedFilesResponse.PublishedFileId").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PublishedFileId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PublishedFileId {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates.start_index)
    pub start_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates.start_time)
    pub start_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates.desired_revision)
    pub desired_revision: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
    fn default() -> &'a CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
        <CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
    pub fn new() -> CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 start_index = 2;

    pub fn start_index(&self) -> u32 {
        self.start_index.unwrap_or(0)
    }

    pub fn clear_start_index(&mut self) {
        self.start_index = ::std::option::Option::None;
    }

    pub fn has_start_index(&self) -> bool {
        self.start_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_index(&mut self, v: u32) {
        self.start_index = ::std::option::Option::Some(v);
    }

    // optional fixed32 start_time = 3;

    pub fn start_time(&self) -> u32 {
        self.start_time.unwrap_or(0)
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional uint32 desired_revision = 4;

    pub fn desired_revision(&self) -> u32 {
        self.desired_revision.unwrap_or(0u32)
    }

    pub fn clear_desired_revision(&mut self) {
        self.desired_revision = ::std::option::Option::None;
    }

    pub fn has_desired_revision(&self) -> bool {
        self.desired_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desired_revision(&mut self, v: u32) {
        self.desired_revision = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates| { &m.app_id },
            |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_index",
            |m: &CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates| { &m.start_index },
            |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates| { &mut m.start_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_time",
            |m: &CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates| { &m.start_time },
            |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates| { &mut m.start_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "desired_revision",
            |m: &CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates| { &m.desired_revision },
            |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates| { &mut m.desired_revision },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates>(
            "CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
    const NAME: &'static str = "CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.start_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                29 => {
                    self.start_time = ::std::option::Option::Some(is.read_fixed32()?);
                },
                32 => {
                    self.desired_revision = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.start_index {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.start_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.desired_revision {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.start_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.desired_revision {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
        CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.start_index = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.desired_revision = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
        static instance: CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates = CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
            app_id: ::std::option::Option::None,
            start_index: ::std::option::Option::None,
            start_time: ::std::option::Option::None,
            desired_revision: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.subscribed_files)
    pub subscribed_files: ::std::vec::Vec<cmsg_client_ucmenumerate_user_subscribed_files_with_updates_response::PublishedFileId>,
    // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.total_results)
    pub total_results: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
    fn default() -> &'a CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
        <CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
    pub fn new() -> CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 total_results = 3;

    pub fn total_results(&self) -> u32 {
        self.total_results.unwrap_or(0)
    }

    pub fn clear_total_results(&mut self) {
        self.total_results = ::std::option::Option::None;
    }

    pub fn has_total_results(&self) -> bool {
        self.total_results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_results(&mut self, v: u32) {
        self.total_results = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse| { &m.eresult },
            |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "subscribed_files",
            |m: &CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse| { &m.subscribed_files },
            |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse| { &mut m.subscribed_files },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_results",
            |m: &CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse| { &m.total_results },
            |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse| { &mut m.total_results },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse>(
            "CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
    const NAME: &'static str = "CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.subscribed_files.push(is.read_message()?);
                },
                24 => {
                    self.total_results = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.subscribed_files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.total_results {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.subscribed_files {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.total_results {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
        CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.subscribed_files.clear();
        self.total_results = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
        static instance: CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse = CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
            eresult: ::std::option::Option::None,
            subscribed_files: ::std::vec::Vec::new(),
            total_results: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse`
pub mod cmsg_client_ucmenumerate_user_subscribed_files_with_updates_response {
    // @@protoc_insertion_point(message:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PublishedFileId {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId.published_file_id)
        pub published_file_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId.rtime32_subscribed)
        pub rtime32_subscribed: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId.appid)
        pub appid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId.file_hcontent)
        pub file_hcontent: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId.file_size)
        pub file_size: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId.rtime32_last_updated)
        pub rtime32_last_updated: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId.is_depot_content)
        pub is_depot_content: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PublishedFileId {
        fn default() -> &'a PublishedFileId {
            <PublishedFileId as ::protobuf::Message>::default_instance()
        }
    }

    impl PublishedFileId {
        pub fn new() -> PublishedFileId {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }

        // optional fixed32 rtime32_subscribed = 2;

        pub fn rtime32_subscribed(&self) -> u32 {
            self.rtime32_subscribed.unwrap_or(0u32)
        }

        pub fn clear_rtime32_subscribed(&mut self) {
            self.rtime32_subscribed = ::std::option::Option::None;
        }

        pub fn has_rtime32_subscribed(&self) -> bool {
            self.rtime32_subscribed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rtime32_subscribed(&mut self, v: u32) {
            self.rtime32_subscribed = ::std::option::Option::Some(v);
        }

        // optional uint32 appid = 3;

        pub fn appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional fixed64 file_hcontent = 4;

        pub fn file_hcontent(&self) -> u64 {
            self.file_hcontent.unwrap_or(0)
        }

        pub fn clear_file_hcontent(&mut self) {
            self.file_hcontent = ::std::option::Option::None;
        }

        pub fn has_file_hcontent(&self) -> bool {
            self.file_hcontent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_file_hcontent(&mut self, v: u64) {
            self.file_hcontent = ::std::option::Option::Some(v);
        }

        // optional uint32 file_size = 5;

        pub fn file_size(&self) -> u32 {
            self.file_size.unwrap_or(0)
        }

        pub fn clear_file_size(&mut self) {
            self.file_size = ::std::option::Option::None;
        }

        pub fn has_file_size(&self) -> bool {
            self.file_size.is_some()
        }

        // Param is passed by value, moved
        pub fn set_file_size(&mut self, v: u32) {
            self.file_size = ::std::option::Option::Some(v);
        }

        // optional fixed32 rtime32_last_updated = 6;

        pub fn rtime32_last_updated(&self) -> u32 {
            self.rtime32_last_updated.unwrap_or(0)
        }

        pub fn clear_rtime32_last_updated(&mut self) {
            self.rtime32_last_updated = ::std::option::Option::None;
        }

        pub fn has_rtime32_last_updated(&self) -> bool {
            self.rtime32_last_updated.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rtime32_last_updated(&mut self, v: u32) {
            self.rtime32_last_updated = ::std::option::Option::Some(v);
        }

        // optional bool is_depot_content = 7;

        pub fn is_depot_content(&self) -> bool {
            self.is_depot_content.unwrap_or(false)
        }

        pub fn clear_is_depot_content(&mut self) {
            self.is_depot_content = ::std::option::Option::None;
        }

        pub fn has_is_depot_content(&self) -> bool {
            self.is_depot_content.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_depot_content(&mut self, v: bool) {
            self.is_depot_content = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(7);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "published_file_id",
                |m: &PublishedFileId| { &m.published_file_id },
                |m: &mut PublishedFileId| { &mut m.published_file_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rtime32_subscribed",
                |m: &PublishedFileId| { &m.rtime32_subscribed },
                |m: &mut PublishedFileId| { &mut m.rtime32_subscribed },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "appid",
                |m: &PublishedFileId| { &m.appid },
                |m: &mut PublishedFileId| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "file_hcontent",
                |m: &PublishedFileId| { &m.file_hcontent },
                |m: &mut PublishedFileId| { &mut m.file_hcontent },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "file_size",
                |m: &PublishedFileId| { &m.file_size },
                |m: &mut PublishedFileId| { &mut m.file_size },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rtime32_last_updated",
                |m: &PublishedFileId| { &m.rtime32_last_updated },
                |m: &mut PublishedFileId| { &mut m.rtime32_last_updated },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_depot_content",
                |m: &PublishedFileId| { &m.is_depot_content },
                |m: &mut PublishedFileId| { &mut m.is_depot_content },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PublishedFileId>(
                "CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PublishedFileId {
        const NAME: &'static str = "PublishedFileId";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    21 => {
                        self.rtime32_subscribed = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    24 => {
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    33 => {
                        self.file_hcontent = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    40 => {
                        self.file_size = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    53 => {
                        self.rtime32_last_updated = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    56 => {
                        self.is_depot_content = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.rtime32_subscribed {
                my_size += 1 + 4;
            }
            if let Some(v) = self.appid {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.file_hcontent {
                my_size += 1 + 8;
            }
            if let Some(v) = self.file_size {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.rtime32_last_updated {
                my_size += 1 + 4;
            }
            if let Some(v) = self.is_depot_content {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.rtime32_subscribed {
                os.write_fixed32(2, v)?;
            }
            if let Some(v) = self.appid {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.file_hcontent {
                os.write_fixed64(4, v)?;
            }
            if let Some(v) = self.file_size {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.rtime32_last_updated {
                os.write_fixed32(6, v)?;
            }
            if let Some(v) = self.is_depot_content {
                os.write_bool(7, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PublishedFileId {
            PublishedFileId::new()
        }

        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.rtime32_subscribed = ::std::option::Option::None;
            self.appid = ::std::option::Option::None;
            self.file_hcontent = ::std::option::Option::None;
            self.file_size = ::std::option::Option::None;
            self.rtime32_last_updated = ::std::option::Option::None;
            self.is_depot_content = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PublishedFileId {
            static instance: PublishedFileId = PublishedFileId {
                published_file_id: ::std::option::Option::None,
                rtime32_subscribed: ::std::option::Option::None,
                appid: ::std::option::Option::None,
                file_hcontent: ::std::option::Option::None,
                file_size: ::std::option::Option::None,
                rtime32_last_updated: ::std::option::Option::None,
                is_depot_content: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PublishedFileId {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PublishedFileId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PublishedFileId {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientUCMPublishedFileUpdated)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMPublishedFileUpdated {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMPublishedFileUpdated.published_file_id)
    pub published_file_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishedFileUpdated.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishedFileUpdated.time_updated)
    pub time_updated: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishedFileUpdated.hcontent)
    pub hcontent: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishedFileUpdated.file_size)
    pub file_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishedFileUpdated.is_depot_content)
    pub is_depot_content: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUCMPublishedFileUpdated.revision)
    pub revision: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMPublishedFileUpdated.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMPublishedFileUpdated {
    fn default() -> &'a CMsgClientUCMPublishedFileUpdated {
        <CMsgClientUCMPublishedFileUpdated as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMPublishedFileUpdated {
    pub fn new() -> CMsgClientUCMPublishedFileUpdated {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;

    pub fn published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }

    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 time_updated = 3;

    pub fn time_updated(&self) -> u32 {
        self.time_updated.unwrap_or(0)
    }

    pub fn clear_time_updated(&mut self) {
        self.time_updated = ::std::option::Option::None;
    }

    pub fn has_time_updated(&self) -> bool {
        self.time_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_updated(&mut self, v: u32) {
        self.time_updated = ::std::option::Option::Some(v);
    }

    // optional fixed64 hcontent = 4;

    pub fn hcontent(&self) -> u64 {
        self.hcontent.unwrap_or(0)
    }

    pub fn clear_hcontent(&mut self) {
        self.hcontent = ::std::option::Option::None;
    }

    pub fn has_hcontent(&self) -> bool {
        self.hcontent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hcontent(&mut self, v: u64) {
        self.hcontent = ::std::option::Option::Some(v);
    }

    // optional fixed32 file_size = 5;

    pub fn file_size(&self) -> u32 {
        self.file_size.unwrap_or(0)
    }

    pub fn clear_file_size(&mut self) {
        self.file_size = ::std::option::Option::None;
    }

    pub fn has_file_size(&self) -> bool {
        self.file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: u32) {
        self.file_size = ::std::option::Option::Some(v);
    }

    // optional bool is_depot_content = 6;

    pub fn is_depot_content(&self) -> bool {
        self.is_depot_content.unwrap_or(false)
    }

    pub fn clear_is_depot_content(&mut self) {
        self.is_depot_content = ::std::option::Option::None;
    }

    pub fn has_is_depot_content(&self) -> bool {
        self.is_depot_content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_depot_content(&mut self, v: bool) {
        self.is_depot_content = ::std::option::Option::Some(v);
    }

    // optional uint32 revision = 7;

    pub fn revision(&self) -> u32 {
        self.revision.unwrap_or(0)
    }

    pub fn clear_revision(&mut self) {
        self.revision = ::std::option::Option::None;
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: u32) {
        self.revision = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "published_file_id",
            |m: &CMsgClientUCMPublishedFileUpdated| { &m.published_file_id },
            |m: &mut CMsgClientUCMPublishedFileUpdated| { &mut m.published_file_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientUCMPublishedFileUpdated| { &m.app_id },
            |m: &mut CMsgClientUCMPublishedFileUpdated| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_updated",
            |m: &CMsgClientUCMPublishedFileUpdated| { &m.time_updated },
            |m: &mut CMsgClientUCMPublishedFileUpdated| { &mut m.time_updated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hcontent",
            |m: &CMsgClientUCMPublishedFileUpdated| { &m.hcontent },
            |m: &mut CMsgClientUCMPublishedFileUpdated| { &mut m.hcontent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_size",
            |m: &CMsgClientUCMPublishedFileUpdated| { &m.file_size },
            |m: &mut CMsgClientUCMPublishedFileUpdated| { &mut m.file_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_depot_content",
            |m: &CMsgClientUCMPublishedFileUpdated| { &m.is_depot_content },
            |m: &mut CMsgClientUCMPublishedFileUpdated| { &mut m.is_depot_content },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "revision",
            |m: &CMsgClientUCMPublishedFileUpdated| { &m.revision },
            |m: &mut CMsgClientUCMPublishedFileUpdated| { &mut m.revision },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUCMPublishedFileUpdated>(
            "CMsgClientUCMPublishedFileUpdated",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUCMPublishedFileUpdated {
    const NAME: &'static str = "CMsgClientUCMPublishedFileUpdated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.time_updated = ::std::option::Option::Some(is.read_uint32()?);
                },
                33 => {
                    self.hcontent = ::std::option::Option::Some(is.read_fixed64()?);
                },
                45 => {
                    self.file_size = ::std::option::Option::Some(is.read_fixed32()?);
                },
                48 => {
                    self.is_depot_content = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.revision = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.time_updated {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.hcontent {
            my_size += 1 + 8;
        }
        if let Some(v) = self.file_size {
            my_size += 1 + 4;
        }
        if let Some(v) = self.is_depot_content {
            my_size += 1 + 1;
        }
        if let Some(v) = self.revision {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.time_updated {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.hcontent {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.file_size {
            os.write_fixed32(5, v)?;
        }
        if let Some(v) = self.is_depot_content {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.revision {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMPublishedFileUpdated {
        CMsgClientUCMPublishedFileUpdated::new()
    }

    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.time_updated = ::std::option::Option::None;
        self.hcontent = ::std::option::Option::None;
        self.file_size = ::std::option::Option::None;
        self.is_depot_content = ::std::option::Option::None;
        self.revision = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMPublishedFileUpdated {
        static instance: CMsgClientUCMPublishedFileUpdated = CMsgClientUCMPublishedFileUpdated {
            published_file_id: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            time_updated: ::std::option::Option::None,
            hcontent: ::std::option::Option::None,
            file_size: ::std::option::Option::None,
            is_depot_content: ::std::option::Option::None,
            revision: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUCMPublishedFileUpdated {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUCMPublishedFileUpdated").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUCMPublishedFileUpdated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMPublishedFileUpdated {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientWorkshopItemChangesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientWorkshopItemChangesRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientWorkshopItemChangesRequest.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientWorkshopItemChangesRequest.last_time_updated)
    pub last_time_updated: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientWorkshopItemChangesRequest.num_items_needed)
    pub num_items_needed: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientWorkshopItemChangesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientWorkshopItemChangesRequest {
    fn default() -> &'a CMsgClientWorkshopItemChangesRequest {
        <CMsgClientWorkshopItemChangesRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientWorkshopItemChangesRequest {
    pub fn new() -> CMsgClientWorkshopItemChangesRequest {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 last_time_updated = 2;

    pub fn last_time_updated(&self) -> u32 {
        self.last_time_updated.unwrap_or(0)
    }

    pub fn clear_last_time_updated(&mut self) {
        self.last_time_updated = ::std::option::Option::None;
    }

    pub fn has_last_time_updated(&self) -> bool {
        self.last_time_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_time_updated(&mut self, v: u32) {
        self.last_time_updated = ::std::option::Option::Some(v);
    }

    // optional uint32 num_items_needed = 3;

    pub fn num_items_needed(&self) -> u32 {
        self.num_items_needed.unwrap_or(0)
    }

    pub fn clear_num_items_needed(&mut self) {
        self.num_items_needed = ::std::option::Option::None;
    }

    pub fn has_num_items_needed(&self) -> bool {
        self.num_items_needed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_items_needed(&mut self, v: u32) {
        self.num_items_needed = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientWorkshopItemChangesRequest| { &m.app_id },
            |m: &mut CMsgClientWorkshopItemChangesRequest| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_time_updated",
            |m: &CMsgClientWorkshopItemChangesRequest| { &m.last_time_updated },
            |m: &mut CMsgClientWorkshopItemChangesRequest| { &mut m.last_time_updated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_items_needed",
            |m: &CMsgClientWorkshopItemChangesRequest| { &m.num_items_needed },
            |m: &mut CMsgClientWorkshopItemChangesRequest| { &mut m.num_items_needed },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientWorkshopItemChangesRequest>(
            "CMsgClientWorkshopItemChangesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientWorkshopItemChangesRequest {
    const NAME: &'static str = "CMsgClientWorkshopItemChangesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.last_time_updated = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.num_items_needed = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.last_time_updated {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.num_items_needed {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.last_time_updated {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.num_items_needed {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientWorkshopItemChangesRequest {
        CMsgClientWorkshopItemChangesRequest::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.last_time_updated = ::std::option::Option::None;
        self.num_items_needed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientWorkshopItemChangesRequest {
        static instance: CMsgClientWorkshopItemChangesRequest = CMsgClientWorkshopItemChangesRequest {
            app_id: ::std::option::Option::None,
            last_time_updated: ::std::option::Option::None,
            num_items_needed: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientWorkshopItemChangesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientWorkshopItemChangesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientWorkshopItemChangesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientWorkshopItemChangesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientWorkshopItemChangesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientWorkshopItemChangesResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientWorkshopItemChangesResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientWorkshopItemChangesResponse.update_time)
    pub update_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientWorkshopItemChangesResponse.workshop_items)
    pub workshop_items: ::std::vec::Vec<cmsg_client_workshop_item_changes_response::WorkshopItemInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientWorkshopItemChangesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientWorkshopItemChangesResponse {
    fn default() -> &'a CMsgClientWorkshopItemChangesResponse {
        <CMsgClientWorkshopItemChangesResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientWorkshopItemChangesResponse {
    pub fn new() -> CMsgClientWorkshopItemChangesResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 update_time = 2;

    pub fn update_time(&self) -> u32 {
        self.update_time.unwrap_or(0)
    }

    pub fn clear_update_time(&mut self) {
        self.update_time = ::std::option::Option::None;
    }

    pub fn has_update_time(&self) -> bool {
        self.update_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_time(&mut self, v: u32) {
        self.update_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientWorkshopItemChangesResponse| { &m.eresult },
            |m: &mut CMsgClientWorkshopItemChangesResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "update_time",
            |m: &CMsgClientWorkshopItemChangesResponse| { &m.update_time },
            |m: &mut CMsgClientWorkshopItemChangesResponse| { &mut m.update_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "workshop_items",
            |m: &CMsgClientWorkshopItemChangesResponse| { &m.workshop_items },
            |m: &mut CMsgClientWorkshopItemChangesResponse| { &mut m.workshop_items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientWorkshopItemChangesResponse>(
            "CMsgClientWorkshopItemChangesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientWorkshopItemChangesResponse {
    const NAME: &'static str = "CMsgClientWorkshopItemChangesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.update_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.workshop_items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.update_time {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.workshop_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.update_time {
            os.write_uint32(2, v)?;
        }
        for v in &self.workshop_items {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientWorkshopItemChangesResponse {
        CMsgClientWorkshopItemChangesResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.update_time = ::std::option::Option::None;
        self.workshop_items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientWorkshopItemChangesResponse {
        static instance: CMsgClientWorkshopItemChangesResponse = CMsgClientWorkshopItemChangesResponse {
            eresult: ::std::option::Option::None,
            update_time: ::std::option::Option::None,
            workshop_items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientWorkshopItemChangesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientWorkshopItemChangesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientWorkshopItemChangesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientWorkshopItemChangesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientWorkshopItemChangesResponse`
pub mod cmsg_client_workshop_item_changes_response {
    // @@protoc_insertion_point(message:CMsgClientWorkshopItemChangesResponse.WorkshopItemInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct WorkshopItemInfo {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientWorkshopItemChangesResponse.WorkshopItemInfo.published_file_id)
        pub published_file_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientWorkshopItemChangesResponse.WorkshopItemInfo.time_updated)
        pub time_updated: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientWorkshopItemChangesResponse.WorkshopItemInfo.manifest_id)
        pub manifest_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientWorkshopItemChangesResponse.WorkshopItemInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a WorkshopItemInfo {
        fn default() -> &'a WorkshopItemInfo {
            <WorkshopItemInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl WorkshopItemInfo {
        pub fn new() -> WorkshopItemInfo {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }

        // optional uint32 time_updated = 2;

        pub fn time_updated(&self) -> u32 {
            self.time_updated.unwrap_or(0)
        }

        pub fn clear_time_updated(&mut self) {
            self.time_updated = ::std::option::Option::None;
        }

        pub fn has_time_updated(&self) -> bool {
            self.time_updated.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_updated(&mut self, v: u32) {
            self.time_updated = ::std::option::Option::Some(v);
        }

        // optional fixed64 manifest_id = 3;

        pub fn manifest_id(&self) -> u64 {
            self.manifest_id.unwrap_or(0)
        }

        pub fn clear_manifest_id(&mut self) {
            self.manifest_id = ::std::option::Option::None;
        }

        pub fn has_manifest_id(&self) -> bool {
            self.manifest_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_manifest_id(&mut self, v: u64) {
            self.manifest_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "published_file_id",
                |m: &WorkshopItemInfo| { &m.published_file_id },
                |m: &mut WorkshopItemInfo| { &mut m.published_file_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "time_updated",
                |m: &WorkshopItemInfo| { &m.time_updated },
                |m: &mut WorkshopItemInfo| { &mut m.time_updated },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "manifest_id",
                |m: &WorkshopItemInfo| { &m.manifest_id },
                |m: &mut WorkshopItemInfo| { &mut m.manifest_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WorkshopItemInfo>(
                "CMsgClientWorkshopItemChangesResponse.WorkshopItemInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for WorkshopItemInfo {
        const NAME: &'static str = "WorkshopItemInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.time_updated = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    25 => {
                        self.manifest_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.time_updated {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.manifest_id {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.time_updated {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.manifest_id {
                os.write_fixed64(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> WorkshopItemInfo {
            WorkshopItemInfo::new()
        }

        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.time_updated = ::std::option::Option::None;
            self.manifest_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static WorkshopItemInfo {
            static instance: WorkshopItemInfo = WorkshopItemInfo {
                published_file_id: ::std::option::Option::None,
                time_updated: ::std::option::Option::None,
                manifest_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for WorkshopItemInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientWorkshopItemChangesResponse.WorkshopItemInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for WorkshopItemInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for WorkshopItemInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientWorkshopItemInfoRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientWorkshopItemInfoRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientWorkshopItemInfoRequest.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientWorkshopItemInfoRequest.last_time_updated)
    pub last_time_updated: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientWorkshopItemInfoRequest.workshop_items)
    pub workshop_items: ::std::vec::Vec<cmsg_client_workshop_item_info_request::WorkshopItem>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientWorkshopItemInfoRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientWorkshopItemInfoRequest {
    fn default() -> &'a CMsgClientWorkshopItemInfoRequest {
        <CMsgClientWorkshopItemInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientWorkshopItemInfoRequest {
    pub fn new() -> CMsgClientWorkshopItemInfoRequest {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 last_time_updated = 2;

    pub fn last_time_updated(&self) -> u32 {
        self.last_time_updated.unwrap_or(0)
    }

    pub fn clear_last_time_updated(&mut self) {
        self.last_time_updated = ::std::option::Option::None;
    }

    pub fn has_last_time_updated(&self) -> bool {
        self.last_time_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_time_updated(&mut self, v: u32) {
        self.last_time_updated = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientWorkshopItemInfoRequest| { &m.app_id },
            |m: &mut CMsgClientWorkshopItemInfoRequest| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_time_updated",
            |m: &CMsgClientWorkshopItemInfoRequest| { &m.last_time_updated },
            |m: &mut CMsgClientWorkshopItemInfoRequest| { &mut m.last_time_updated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "workshop_items",
            |m: &CMsgClientWorkshopItemInfoRequest| { &m.workshop_items },
            |m: &mut CMsgClientWorkshopItemInfoRequest| { &mut m.workshop_items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientWorkshopItemInfoRequest>(
            "CMsgClientWorkshopItemInfoRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientWorkshopItemInfoRequest {
    const NAME: &'static str = "CMsgClientWorkshopItemInfoRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.last_time_updated = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.workshop_items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.last_time_updated {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.workshop_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.last_time_updated {
            os.write_uint32(2, v)?;
        }
        for v in &self.workshop_items {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientWorkshopItemInfoRequest {
        CMsgClientWorkshopItemInfoRequest::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.last_time_updated = ::std::option::Option::None;
        self.workshop_items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientWorkshopItemInfoRequest {
        static instance: CMsgClientWorkshopItemInfoRequest = CMsgClientWorkshopItemInfoRequest {
            app_id: ::std::option::Option::None,
            last_time_updated: ::std::option::Option::None,
            workshop_items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientWorkshopItemInfoRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientWorkshopItemInfoRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientWorkshopItemInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientWorkshopItemInfoRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientWorkshopItemInfoRequest`
pub mod cmsg_client_workshop_item_info_request {
    // @@protoc_insertion_point(message:CMsgClientWorkshopItemInfoRequest.WorkshopItem)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct WorkshopItem {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientWorkshopItemInfoRequest.WorkshopItem.published_file_id)
        pub published_file_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientWorkshopItemInfoRequest.WorkshopItem.time_updated)
        pub time_updated: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientWorkshopItemInfoRequest.WorkshopItem.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a WorkshopItem {
        fn default() -> &'a WorkshopItem {
            <WorkshopItem as ::protobuf::Message>::default_instance()
        }
    }

    impl WorkshopItem {
        pub fn new() -> WorkshopItem {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }

        // optional uint32 time_updated = 2;

        pub fn time_updated(&self) -> u32 {
            self.time_updated.unwrap_or(0)
        }

        pub fn clear_time_updated(&mut self) {
            self.time_updated = ::std::option::Option::None;
        }

        pub fn has_time_updated(&self) -> bool {
            self.time_updated.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_updated(&mut self, v: u32) {
            self.time_updated = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "published_file_id",
                |m: &WorkshopItem| { &m.published_file_id },
                |m: &mut WorkshopItem| { &mut m.published_file_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "time_updated",
                |m: &WorkshopItem| { &m.time_updated },
                |m: &mut WorkshopItem| { &mut m.time_updated },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WorkshopItem>(
                "CMsgClientWorkshopItemInfoRequest.WorkshopItem",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for WorkshopItem {
        const NAME: &'static str = "WorkshopItem";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.time_updated = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.time_updated {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.time_updated {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> WorkshopItem {
            WorkshopItem::new()
        }

        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.time_updated = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static WorkshopItem {
            static instance: WorkshopItem = WorkshopItem {
                published_file_id: ::std::option::Option::None,
                time_updated: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for WorkshopItem {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientWorkshopItemInfoRequest.WorkshopItem").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for WorkshopItem {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for WorkshopItem {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientWorkshopItemInfoResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientWorkshopItemInfoResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientWorkshopItemInfoResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientWorkshopItemInfoResponse.update_time)
    pub update_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientWorkshopItemInfoResponse.workshop_items)
    pub workshop_items: ::std::vec::Vec<cmsg_client_workshop_item_info_response::WorkshopItemInfo>,
    // @@protoc_insertion_point(field:CMsgClientWorkshopItemInfoResponse.private_items)
    pub private_items: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientWorkshopItemInfoResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientWorkshopItemInfoResponse {
    fn default() -> &'a CMsgClientWorkshopItemInfoResponse {
        <CMsgClientWorkshopItemInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientWorkshopItemInfoResponse {
    pub fn new() -> CMsgClientWorkshopItemInfoResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 update_time = 2;

    pub fn update_time(&self) -> u32 {
        self.update_time.unwrap_or(0)
    }

    pub fn clear_update_time(&mut self) {
        self.update_time = ::std::option::Option::None;
    }

    pub fn has_update_time(&self) -> bool {
        self.update_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_time(&mut self, v: u32) {
        self.update_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientWorkshopItemInfoResponse| { &m.eresult },
            |m: &mut CMsgClientWorkshopItemInfoResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "update_time",
            |m: &CMsgClientWorkshopItemInfoResponse| { &m.update_time },
            |m: &mut CMsgClientWorkshopItemInfoResponse| { &mut m.update_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "workshop_items",
            |m: &CMsgClientWorkshopItemInfoResponse| { &m.workshop_items },
            |m: &mut CMsgClientWorkshopItemInfoResponse| { &mut m.workshop_items },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "private_items",
            |m: &CMsgClientWorkshopItemInfoResponse| { &m.private_items },
            |m: &mut CMsgClientWorkshopItemInfoResponse| { &mut m.private_items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientWorkshopItemInfoResponse>(
            "CMsgClientWorkshopItemInfoResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientWorkshopItemInfoResponse {
    const NAME: &'static str = "CMsgClientWorkshopItemInfoResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.update_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.workshop_items.push(is.read_message()?);
                },
                34 => {
                    is.read_repeated_packed_fixed64_into(&mut self.private_items)?;
                },
                33 => {
                    self.private_items.push(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.update_time {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.workshop_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += 9 * self.private_items.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.update_time {
            os.write_uint32(2, v)?;
        }
        for v in &self.workshop_items {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.private_items {
            os.write_fixed64(4, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientWorkshopItemInfoResponse {
        CMsgClientWorkshopItemInfoResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.update_time = ::std::option::Option::None;
        self.workshop_items.clear();
        self.private_items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientWorkshopItemInfoResponse {
        static instance: CMsgClientWorkshopItemInfoResponse = CMsgClientWorkshopItemInfoResponse {
            eresult: ::std::option::Option::None,
            update_time: ::std::option::Option::None,
            workshop_items: ::std::vec::Vec::new(),
            private_items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientWorkshopItemInfoResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientWorkshopItemInfoResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientWorkshopItemInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientWorkshopItemInfoResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientWorkshopItemInfoResponse`
pub mod cmsg_client_workshop_item_info_response {
    // @@protoc_insertion_point(message:CMsgClientWorkshopItemInfoResponse.WorkshopItemInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct WorkshopItemInfo {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientWorkshopItemInfoResponse.WorkshopItemInfo.published_file_id)
        pub published_file_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientWorkshopItemInfoResponse.WorkshopItemInfo.time_updated)
        pub time_updated: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientWorkshopItemInfoResponse.WorkshopItemInfo.manifest_id)
        pub manifest_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientWorkshopItemInfoResponse.WorkshopItemInfo.is_legacy)
        pub is_legacy: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientWorkshopItemInfoResponse.WorkshopItemInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a WorkshopItemInfo {
        fn default() -> &'a WorkshopItemInfo {
            <WorkshopItemInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl WorkshopItemInfo {
        pub fn new() -> WorkshopItemInfo {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }

        // optional uint32 time_updated = 2;

        pub fn time_updated(&self) -> u32 {
            self.time_updated.unwrap_or(0)
        }

        pub fn clear_time_updated(&mut self) {
            self.time_updated = ::std::option::Option::None;
        }

        pub fn has_time_updated(&self) -> bool {
            self.time_updated.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_updated(&mut self, v: u32) {
            self.time_updated = ::std::option::Option::Some(v);
        }

        // optional fixed64 manifest_id = 3;

        pub fn manifest_id(&self) -> u64 {
            self.manifest_id.unwrap_or(0)
        }

        pub fn clear_manifest_id(&mut self) {
            self.manifest_id = ::std::option::Option::None;
        }

        pub fn has_manifest_id(&self) -> bool {
            self.manifest_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_manifest_id(&mut self, v: u64) {
            self.manifest_id = ::std::option::Option::Some(v);
        }

        // optional bool is_legacy = 4;

        pub fn is_legacy(&self) -> bool {
            self.is_legacy.unwrap_or(false)
        }

        pub fn clear_is_legacy(&mut self) {
            self.is_legacy = ::std::option::Option::None;
        }

        pub fn has_is_legacy(&self) -> bool {
            self.is_legacy.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_legacy(&mut self, v: bool) {
            self.is_legacy = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "published_file_id",
                |m: &WorkshopItemInfo| { &m.published_file_id },
                |m: &mut WorkshopItemInfo| { &mut m.published_file_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "time_updated",
                |m: &WorkshopItemInfo| { &m.time_updated },
                |m: &mut WorkshopItemInfo| { &mut m.time_updated },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "manifest_id",
                |m: &WorkshopItemInfo| { &m.manifest_id },
                |m: &mut WorkshopItemInfo| { &mut m.manifest_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_legacy",
                |m: &WorkshopItemInfo| { &m.is_legacy },
                |m: &mut WorkshopItemInfo| { &mut m.is_legacy },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WorkshopItemInfo>(
                "CMsgClientWorkshopItemInfoResponse.WorkshopItemInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for WorkshopItemInfo {
        const NAME: &'static str = "WorkshopItemInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.time_updated = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    25 => {
                        self.manifest_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    32 => {
                        self.is_legacy = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.time_updated {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.manifest_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.is_legacy {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.time_updated {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.manifest_id {
                os.write_fixed64(3, v)?;
            }
            if let Some(v) = self.is_legacy {
                os.write_bool(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> WorkshopItemInfo {
            WorkshopItemInfo::new()
        }

        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.time_updated = ::std::option::Option::None;
            self.manifest_id = ::std::option::Option::None;
            self.is_legacy = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static WorkshopItemInfo {
            static instance: WorkshopItemInfo = WorkshopItemInfo {
                published_file_id: ::std::option::Option::None,
                time_updated: ::std::option::Option::None,
                manifest_id: ::std::option::Option::None,
                is_legacy: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for WorkshopItemInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientWorkshopItemInfoResponse.WorkshopItemInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for WorkshopItemInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for WorkshopItemInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientUCMGetPublishedFilesForUser)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMGetPublishedFilesForUser {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMGetPublishedFilesForUser.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMGetPublishedFilesForUser.creator_steam_id)
    pub creator_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUCMGetPublishedFilesForUser.required_tags)
    pub required_tags: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMGetPublishedFilesForUser.excluded_tags)
    pub excluded_tags: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUCMGetPublishedFilesForUser.start_index)
    pub start_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMGetPublishedFilesForUser.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMGetPublishedFilesForUser {
    fn default() -> &'a CMsgClientUCMGetPublishedFilesForUser {
        <CMsgClientUCMGetPublishedFilesForUser as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMGetPublishedFilesForUser {
    pub fn new() -> CMsgClientUCMGetPublishedFilesForUser {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 creator_steam_id = 2;

    pub fn creator_steam_id(&self) -> u64 {
        self.creator_steam_id.unwrap_or(0)
    }

    pub fn clear_creator_steam_id(&mut self) {
        self.creator_steam_id = ::std::option::Option::None;
    }

    pub fn has_creator_steam_id(&self) -> bool {
        self.creator_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creator_steam_id(&mut self, v: u64) {
        self.creator_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 start_index = 5;

    pub fn start_index(&self) -> u32 {
        self.start_index.unwrap_or(0)
    }

    pub fn clear_start_index(&mut self) {
        self.start_index = ::std::option::Option::None;
    }

    pub fn has_start_index(&self) -> bool {
        self.start_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_index(&mut self, v: u32) {
        self.start_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientUCMGetPublishedFilesForUser| { &m.app_id },
            |m: &mut CMsgClientUCMGetPublishedFilesForUser| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "creator_steam_id",
            |m: &CMsgClientUCMGetPublishedFilesForUser| { &m.creator_steam_id },
            |m: &mut CMsgClientUCMGetPublishedFilesForUser| { &mut m.creator_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "required_tags",
            |m: &CMsgClientUCMGetPublishedFilesForUser| { &m.required_tags },
            |m: &mut CMsgClientUCMGetPublishedFilesForUser| { &mut m.required_tags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "excluded_tags",
            |m: &CMsgClientUCMGetPublishedFilesForUser| { &m.excluded_tags },
            |m: &mut CMsgClientUCMGetPublishedFilesForUser| { &mut m.excluded_tags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_index",
            |m: &CMsgClientUCMGetPublishedFilesForUser| { &m.start_index },
            |m: &mut CMsgClientUCMGetPublishedFilesForUser| { &mut m.start_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUCMGetPublishedFilesForUser>(
            "CMsgClientUCMGetPublishedFilesForUser",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUCMGetPublishedFilesForUser {
    const NAME: &'static str = "CMsgClientUCMGetPublishedFilesForUser";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.creator_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.required_tags.push(is.read_string()?);
                },
                34 => {
                    self.excluded_tags.push(is.read_string()?);
                },
                40 => {
                    self.start_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.creator_steam_id {
            my_size += 1 + 8;
        }
        for value in &self.required_tags {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.excluded_tags {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(v) = self.start_index {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.creator_steam_id {
            os.write_fixed64(2, v)?;
        }
        for v in &self.required_tags {
            os.write_string(3, &v)?;
        };
        for v in &self.excluded_tags {
            os.write_string(4, &v)?;
        };
        if let Some(v) = self.start_index {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMGetPublishedFilesForUser {
        CMsgClientUCMGetPublishedFilesForUser::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.creator_steam_id = ::std::option::Option::None;
        self.required_tags.clear();
        self.excluded_tags.clear();
        self.start_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMGetPublishedFilesForUser {
        static instance: CMsgClientUCMGetPublishedFilesForUser = CMsgClientUCMGetPublishedFilesForUser {
            app_id: ::std::option::Option::None,
            creator_steam_id: ::std::option::Option::None,
            required_tags: ::std::vec::Vec::new(),
            excluded_tags: ::std::vec::Vec::new(),
            start_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUCMGetPublishedFilesForUser {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUCMGetPublishedFilesForUser").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUCMGetPublishedFilesForUser {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMGetPublishedFilesForUser {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUCMGetPublishedFilesForUserResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMGetPublishedFilesForUserResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMGetPublishedFilesForUserResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUCMGetPublishedFilesForUserResponse.published_files)
    pub published_files: ::std::vec::Vec<cmsg_client_ucmget_published_files_for_user_response::PublishedFileId>,
    // @@protoc_insertion_point(field:CMsgClientUCMGetPublishedFilesForUserResponse.total_results)
    pub total_results: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMGetPublishedFilesForUserResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMGetPublishedFilesForUserResponse {
    fn default() -> &'a CMsgClientUCMGetPublishedFilesForUserResponse {
        <CMsgClientUCMGetPublishedFilesForUserResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMGetPublishedFilesForUserResponse {
    pub fn new() -> CMsgClientUCMGetPublishedFilesForUserResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 total_results = 3;

    pub fn total_results(&self) -> u32 {
        self.total_results.unwrap_or(0)
    }

    pub fn clear_total_results(&mut self) {
        self.total_results = ::std::option::Option::None;
    }

    pub fn has_total_results(&self) -> bool {
        self.total_results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_results(&mut self, v: u32) {
        self.total_results = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientUCMGetPublishedFilesForUserResponse| { &m.eresult },
            |m: &mut CMsgClientUCMGetPublishedFilesForUserResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "published_files",
            |m: &CMsgClientUCMGetPublishedFilesForUserResponse| { &m.published_files },
            |m: &mut CMsgClientUCMGetPublishedFilesForUserResponse| { &mut m.published_files },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_results",
            |m: &CMsgClientUCMGetPublishedFilesForUserResponse| { &m.total_results },
            |m: &mut CMsgClientUCMGetPublishedFilesForUserResponse| { &mut m.total_results },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUCMGetPublishedFilesForUserResponse>(
            "CMsgClientUCMGetPublishedFilesForUserResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUCMGetPublishedFilesForUserResponse {
    const NAME: &'static str = "CMsgClientUCMGetPublishedFilesForUserResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.published_files.push(is.read_message()?);
                },
                24 => {
                    self.total_results = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.published_files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.total_results {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.published_files {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.total_results {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMGetPublishedFilesForUserResponse {
        CMsgClientUCMGetPublishedFilesForUserResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.published_files.clear();
        self.total_results = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMGetPublishedFilesForUserResponse {
        static instance: CMsgClientUCMGetPublishedFilesForUserResponse = CMsgClientUCMGetPublishedFilesForUserResponse {
            eresult: ::std::option::Option::None,
            published_files: ::std::vec::Vec::new(),
            total_results: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUCMGetPublishedFilesForUserResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUCMGetPublishedFilesForUserResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUCMGetPublishedFilesForUserResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMGetPublishedFilesForUserResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientUCMGetPublishedFilesForUserResponse`
pub mod cmsg_client_ucmget_published_files_for_user_response {
    // @@protoc_insertion_point(message:CMsgClientUCMGetPublishedFilesForUserResponse.PublishedFileId)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PublishedFileId {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientUCMGetPublishedFilesForUserResponse.PublishedFileId.published_file_id)
        pub published_file_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientUCMGetPublishedFilesForUserResponse.PublishedFileId.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PublishedFileId {
        fn default() -> &'a PublishedFileId {
            <PublishedFileId as ::protobuf::Message>::default_instance()
        }
    }

    impl PublishedFileId {
        pub fn new() -> PublishedFileId {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "published_file_id",
                |m: &PublishedFileId| { &m.published_file_id },
                |m: &mut PublishedFileId| { &mut m.published_file_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PublishedFileId>(
                "CMsgClientUCMGetPublishedFilesForUserResponse.PublishedFileId",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PublishedFileId {
        const NAME: &'static str = "PublishedFileId";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PublishedFileId {
            PublishedFileId::new()
        }

        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PublishedFileId {
            static instance: PublishedFileId = PublishedFileId {
                published_file_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PublishedFileId {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientUCMGetPublishedFilesForUserResponse.PublishedFileId").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PublishedFileId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PublishedFileId {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientUCMSetUserPublishedFileAction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMSetUserPublishedFileAction {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMSetUserPublishedFileAction.published_file_id)
    pub published_file_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUCMSetUserPublishedFileAction.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMSetUserPublishedFileAction.action)
    pub action: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMSetUserPublishedFileAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMSetUserPublishedFileAction {
    fn default() -> &'a CMsgClientUCMSetUserPublishedFileAction {
        <CMsgClientUCMSetUserPublishedFileAction as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMSetUserPublishedFileAction {
    pub fn new() -> CMsgClientUCMSetUserPublishedFileAction {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;

    pub fn published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }

    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional int32 action = 3;

    pub fn action(&self) -> i32 {
        self.action.unwrap_or(0)
    }

    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: i32) {
        self.action = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "published_file_id",
            |m: &CMsgClientUCMSetUserPublishedFileAction| { &m.published_file_id },
            |m: &mut CMsgClientUCMSetUserPublishedFileAction| { &mut m.published_file_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientUCMSetUserPublishedFileAction| { &m.app_id },
            |m: &mut CMsgClientUCMSetUserPublishedFileAction| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "action",
            |m: &CMsgClientUCMSetUserPublishedFileAction| { &m.action },
            |m: &mut CMsgClientUCMSetUserPublishedFileAction| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUCMSetUserPublishedFileAction>(
            "CMsgClientUCMSetUserPublishedFileAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUCMSetUserPublishedFileAction {
    const NAME: &'static str = "CMsgClientUCMSetUserPublishedFileAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.action = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.action {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.action {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMSetUserPublishedFileAction {
        CMsgClientUCMSetUserPublishedFileAction::new()
    }

    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMSetUserPublishedFileAction {
        static instance: CMsgClientUCMSetUserPublishedFileAction = CMsgClientUCMSetUserPublishedFileAction {
            published_file_id: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            action: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUCMSetUserPublishedFileAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUCMSetUserPublishedFileAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUCMSetUserPublishedFileAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMSetUserPublishedFileAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUCMSetUserPublishedFileActionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMSetUserPublishedFileActionResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMSetUserPublishedFileActionResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMSetUserPublishedFileActionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMSetUserPublishedFileActionResponse {
    fn default() -> &'a CMsgClientUCMSetUserPublishedFileActionResponse {
        <CMsgClientUCMSetUserPublishedFileActionResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMSetUserPublishedFileActionResponse {
    pub fn new() -> CMsgClientUCMSetUserPublishedFileActionResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientUCMSetUserPublishedFileActionResponse| { &m.eresult },
            |m: &mut CMsgClientUCMSetUserPublishedFileActionResponse| { &mut m.eresult },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUCMSetUserPublishedFileActionResponse>(
            "CMsgClientUCMSetUserPublishedFileActionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUCMSetUserPublishedFileActionResponse {
    const NAME: &'static str = "CMsgClientUCMSetUserPublishedFileActionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMSetUserPublishedFileActionResponse {
        CMsgClientUCMSetUserPublishedFileActionResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMSetUserPublishedFileActionResponse {
        static instance: CMsgClientUCMSetUserPublishedFileActionResponse = CMsgClientUCMSetUserPublishedFileActionResponse {
            eresult: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUCMSetUserPublishedFileActionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUCMSetUserPublishedFileActionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUCMSetUserPublishedFileActionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMSetUserPublishedFileActionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUCMEnumeratePublishedFilesByUserAction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMEnumeratePublishedFilesByUserAction {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMEnumeratePublishedFilesByUserAction.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMEnumeratePublishedFilesByUserAction.start_index)
    pub start_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUCMEnumeratePublishedFilesByUserAction.action)
    pub action: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMEnumeratePublishedFilesByUserAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMEnumeratePublishedFilesByUserAction {
    fn default() -> &'a CMsgClientUCMEnumeratePublishedFilesByUserAction {
        <CMsgClientUCMEnumeratePublishedFilesByUserAction as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMEnumeratePublishedFilesByUserAction {
    pub fn new() -> CMsgClientUCMEnumeratePublishedFilesByUserAction {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 start_index = 2;

    pub fn start_index(&self) -> u32 {
        self.start_index.unwrap_or(0)
    }

    pub fn clear_start_index(&mut self) {
        self.start_index = ::std::option::Option::None;
    }

    pub fn has_start_index(&self) -> bool {
        self.start_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_index(&mut self, v: u32) {
        self.start_index = ::std::option::Option::Some(v);
    }

    // optional int32 action = 3;

    pub fn action(&self) -> i32 {
        self.action.unwrap_or(0)
    }

    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: i32) {
        self.action = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientUCMEnumeratePublishedFilesByUserAction| { &m.app_id },
            |m: &mut CMsgClientUCMEnumeratePublishedFilesByUserAction| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_index",
            |m: &CMsgClientUCMEnumeratePublishedFilesByUserAction| { &m.start_index },
            |m: &mut CMsgClientUCMEnumeratePublishedFilesByUserAction| { &mut m.start_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "action",
            |m: &CMsgClientUCMEnumeratePublishedFilesByUserAction| { &m.action },
            |m: &mut CMsgClientUCMEnumeratePublishedFilesByUserAction| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUCMEnumeratePublishedFilesByUserAction>(
            "CMsgClientUCMEnumeratePublishedFilesByUserAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUCMEnumeratePublishedFilesByUserAction {
    const NAME: &'static str = "CMsgClientUCMEnumeratePublishedFilesByUserAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.start_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.action = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.start_index {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.action {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.start_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.action {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMEnumeratePublishedFilesByUserAction {
        CMsgClientUCMEnumeratePublishedFilesByUserAction::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.start_index = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMEnumeratePublishedFilesByUserAction {
        static instance: CMsgClientUCMEnumeratePublishedFilesByUserAction = CMsgClientUCMEnumeratePublishedFilesByUserAction {
            app_id: ::std::option::Option::None,
            start_index: ::std::option::Option::None,
            action: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUCMEnumeratePublishedFilesByUserAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUCMEnumeratePublishedFilesByUserAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUCMEnumeratePublishedFilesByUserAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMEnumeratePublishedFilesByUserAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUCMEnumeratePublishedFilesByUserActionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.published_files)
    pub published_files: ::std::vec::Vec<cmsg_client_ucmenumerate_published_files_by_user_action_response::PublishedFileId>,
    // @@protoc_insertion_point(field:CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.total_results)
    pub total_results: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
    fn default() -> &'a CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
        <CMsgClientUCMEnumeratePublishedFilesByUserActionResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
    pub fn new() -> CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 total_results = 3;

    pub fn total_results(&self) -> u32 {
        self.total_results.unwrap_or(0)
    }

    pub fn clear_total_results(&mut self) {
        self.total_results = ::std::option::Option::None;
    }

    pub fn has_total_results(&self) -> bool {
        self.total_results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_results(&mut self, v: u32) {
        self.total_results = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientUCMEnumeratePublishedFilesByUserActionResponse| { &m.eresult },
            |m: &mut CMsgClientUCMEnumeratePublishedFilesByUserActionResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "published_files",
            |m: &CMsgClientUCMEnumeratePublishedFilesByUserActionResponse| { &m.published_files },
            |m: &mut CMsgClientUCMEnumeratePublishedFilesByUserActionResponse| { &mut m.published_files },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_results",
            |m: &CMsgClientUCMEnumeratePublishedFilesByUserActionResponse| { &m.total_results },
            |m: &mut CMsgClientUCMEnumeratePublishedFilesByUserActionResponse| { &mut m.total_results },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUCMEnumeratePublishedFilesByUserActionResponse>(
            "CMsgClientUCMEnumeratePublishedFilesByUserActionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
    const NAME: &'static str = "CMsgClientUCMEnumeratePublishedFilesByUserActionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.published_files.push(is.read_message()?);
                },
                24 => {
                    self.total_results = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.published_files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.total_results {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.published_files {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.total_results {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
        CMsgClientUCMEnumeratePublishedFilesByUserActionResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.published_files.clear();
        self.total_results = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
        static instance: CMsgClientUCMEnumeratePublishedFilesByUserActionResponse = CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
            eresult: ::std::option::Option::None,
            published_files: ::std::vec::Vec::new(),
            total_results: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUCMEnumeratePublishedFilesByUserActionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientUCMEnumeratePublishedFilesByUserActionResponse`
pub mod cmsg_client_ucmenumerate_published_files_by_user_action_response {
    // @@protoc_insertion_point(message:CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.PublishedFileId)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PublishedFileId {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.PublishedFileId.published_file_id)
        pub published_file_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.PublishedFileId.rtime_time_stamp)
        pub rtime_time_stamp: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.PublishedFileId.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PublishedFileId {
        fn default() -> &'a PublishedFileId {
            <PublishedFileId as ::protobuf::Message>::default_instance()
        }
    }

    impl PublishedFileId {
        pub fn new() -> PublishedFileId {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }

        // optional fixed32 rtime_time_stamp = 2;

        pub fn rtime_time_stamp(&self) -> u32 {
            self.rtime_time_stamp.unwrap_or(0u32)
        }

        pub fn clear_rtime_time_stamp(&mut self) {
            self.rtime_time_stamp = ::std::option::Option::None;
        }

        pub fn has_rtime_time_stamp(&self) -> bool {
            self.rtime_time_stamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rtime_time_stamp(&mut self, v: u32) {
            self.rtime_time_stamp = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "published_file_id",
                |m: &PublishedFileId| { &m.published_file_id },
                |m: &mut PublishedFileId| { &mut m.published_file_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rtime_time_stamp",
                |m: &PublishedFileId| { &m.rtime_time_stamp },
                |m: &mut PublishedFileId| { &mut m.rtime_time_stamp },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PublishedFileId>(
                "CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.PublishedFileId",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PublishedFileId {
        const NAME: &'static str = "PublishedFileId";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    21 => {
                        self.rtime_time_stamp = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.rtime_time_stamp {
                my_size += 1 + 4;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.rtime_time_stamp {
                os.write_fixed32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PublishedFileId {
            PublishedFileId::new()
        }

        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.rtime_time_stamp = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PublishedFileId {
            static instance: PublishedFileId = PublishedFileId {
                published_file_id: ::std::option::Option::None,
                rtime_time_stamp: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PublishedFileId {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.PublishedFileId").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PublishedFileId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PublishedFileId {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientScreenshotsChanged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientScreenshotsChanged {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientScreenshotsChanged.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientScreenshotsChanged {
    fn default() -> &'a CMsgClientScreenshotsChanged {
        <CMsgClientScreenshotsChanged as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientScreenshotsChanged {
    pub fn new() -> CMsgClientScreenshotsChanged {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientScreenshotsChanged>(
            "CMsgClientScreenshotsChanged",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientScreenshotsChanged {
    const NAME: &'static str = "CMsgClientScreenshotsChanged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientScreenshotsChanged {
        CMsgClientScreenshotsChanged::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientScreenshotsChanged {
        static instance: CMsgClientScreenshotsChanged = CMsgClientScreenshotsChanged {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientScreenshotsChanged {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientScreenshotsChanged").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientScreenshotsChanged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientScreenshotsChanged {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUpdateUserGameInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUpdateUserGameInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUpdateUserGameInfo.steamid_idgs)
    pub steamid_idgs: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUpdateUserGameInfo.gameid)
    pub gameid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUpdateUserGameInfo.game_ip)
    pub game_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateUserGameInfo.game_port)
    pub game_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateUserGameInfo.token)
    pub token: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUpdateUserGameInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUpdateUserGameInfo {
    fn default() -> &'a CMsgClientUpdateUserGameInfo {
        <CMsgClientUpdateUserGameInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUpdateUserGameInfo {
    pub fn new() -> CMsgClientUpdateUserGameInfo {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_idgs = 1;

    pub fn steamid_idgs(&self) -> u64 {
        self.steamid_idgs.unwrap_or(0)
    }

    pub fn clear_steamid_idgs(&mut self) {
        self.steamid_idgs = ::std::option::Option::None;
    }

    pub fn has_steamid_idgs(&self) -> bool {
        self.steamid_idgs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_idgs(&mut self, v: u64) {
        self.steamid_idgs = ::std::option::Option::Some(v);
    }

    // optional fixed64 gameid = 2;

    pub fn gameid(&self) -> u64 {
        self.gameid.unwrap_or(0)
    }

    pub fn clear_gameid(&mut self) {
        self.gameid = ::std::option::Option::None;
    }

    pub fn has_gameid(&self) -> bool {
        self.gameid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameid(&mut self, v: u64) {
        self.gameid = ::std::option::Option::Some(v);
    }

    // optional uint32 game_ip = 3;

    pub fn game_ip(&self) -> u32 {
        self.game_ip.unwrap_or(0)
    }

    pub fn clear_game_ip(&mut self) {
        self.game_ip = ::std::option::Option::None;
    }

    pub fn has_game_ip(&self) -> bool {
        self.game_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_ip(&mut self, v: u32) {
        self.game_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 game_port = 4;

    pub fn game_port(&self) -> u32 {
        self.game_port.unwrap_or(0)
    }

    pub fn clear_game_port(&mut self) {
        self.game_port = ::std::option::Option::None;
    }

    pub fn has_game_port(&self) -> bool {
        self.game_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_port(&mut self, v: u32) {
        self.game_port = ::std::option::Option::Some(v);
    }

    // optional bytes token = 5;

    pub fn token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.token.is_none() {
            self.token = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
        self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid_idgs",
            |m: &CMsgClientUpdateUserGameInfo| { &m.steamid_idgs },
            |m: &mut CMsgClientUpdateUserGameInfo| { &mut m.steamid_idgs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gameid",
            |m: &CMsgClientUpdateUserGameInfo| { &m.gameid },
            |m: &mut CMsgClientUpdateUserGameInfo| { &mut m.gameid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_ip",
            |m: &CMsgClientUpdateUserGameInfo| { &m.game_ip },
            |m: &mut CMsgClientUpdateUserGameInfo| { &mut m.game_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_port",
            |m: &CMsgClientUpdateUserGameInfo| { &m.game_port },
            |m: &mut CMsgClientUpdateUserGameInfo| { &mut m.game_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "token",
            |m: &CMsgClientUpdateUserGameInfo| { &m.token },
            |m: &mut CMsgClientUpdateUserGameInfo| { &mut m.token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUpdateUserGameInfo>(
            "CMsgClientUpdateUserGameInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUpdateUserGameInfo {
    const NAME: &'static str = "CMsgClientUpdateUserGameInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid_idgs = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.gameid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.game_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.game_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.token = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_idgs {
            my_size += 1 + 8;
        }
        if let Some(v) = self.gameid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.game_ip {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.game_port {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid_idgs {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.gameid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.game_ip {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_port {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.token.as_ref() {
            os.write_bytes(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUpdateUserGameInfo {
        CMsgClientUpdateUserGameInfo::new()
    }

    fn clear(&mut self) {
        self.steamid_idgs = ::std::option::Option::None;
        self.gameid = ::std::option::Option::None;
        self.game_ip = ::std::option::Option::None;
        self.game_port = ::std::option::Option::None;
        self.token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUpdateUserGameInfo {
        static instance: CMsgClientUpdateUserGameInfo = CMsgClientUpdateUserGameInfo {
            steamid_idgs: ::std::option::Option::None,
            gameid: ::std::option::Option::None,
            game_ip: ::std::option::Option::None,
            game_port: ::std::option::Option::None,
            token: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUpdateUserGameInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUpdateUserGameInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUpdateUserGameInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUpdateUserGameInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRichPresenceUpload)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRichPresenceUpload {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRichPresenceUpload.rich_presence_kv)
    pub rich_presence_kv: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientRichPresenceUpload.steamid_broadcast)
    pub steamid_broadcast: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRichPresenceUpload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRichPresenceUpload {
    fn default() -> &'a CMsgClientRichPresenceUpload {
        <CMsgClientRichPresenceUpload as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRichPresenceUpload {
    pub fn new() -> CMsgClientRichPresenceUpload {
        ::std::default::Default::default()
    }

    // optional bytes rich_presence_kv = 1;

    pub fn rich_presence_kv(&self) -> &[u8] {
        match self.rich_presence_kv.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_rich_presence_kv(&mut self) {
        self.rich_presence_kv = ::std::option::Option::None;
    }

    pub fn has_rich_presence_kv(&self) -> bool {
        self.rich_presence_kv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rich_presence_kv(&mut self, v: ::std::vec::Vec<u8>) {
        self.rich_presence_kv = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rich_presence_kv(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.rich_presence_kv.is_none() {
            self.rich_presence_kv = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.rich_presence_kv.as_mut().unwrap()
    }

    // Take field
    pub fn take_rich_presence_kv(&mut self) -> ::std::vec::Vec<u8> {
        self.rich_presence_kv.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rich_presence_kv",
            |m: &CMsgClientRichPresenceUpload| { &m.rich_presence_kv },
            |m: &mut CMsgClientRichPresenceUpload| { &mut m.rich_presence_kv },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "steamid_broadcast",
            |m: &CMsgClientRichPresenceUpload| { &m.steamid_broadcast },
            |m: &mut CMsgClientRichPresenceUpload| { &mut m.steamid_broadcast },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRichPresenceUpload>(
            "CMsgClientRichPresenceUpload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientRichPresenceUpload {
    const NAME: &'static str = "CMsgClientRichPresenceUpload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.rich_presence_kv = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    is.read_repeated_packed_fixed64_into(&mut self.steamid_broadcast)?;
                },
                17 => {
                    self.steamid_broadcast.push(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rich_presence_kv.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += 9 * self.steamid_broadcast.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.rich_presence_kv.as_ref() {
            os.write_bytes(1, v)?;
        }
        for v in &self.steamid_broadcast {
            os.write_fixed64(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRichPresenceUpload {
        CMsgClientRichPresenceUpload::new()
    }

    fn clear(&mut self) {
        self.rich_presence_kv = ::std::option::Option::None;
        self.steamid_broadcast.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRichPresenceUpload {
        static instance: CMsgClientRichPresenceUpload = CMsgClientRichPresenceUpload {
            rich_presence_kv: ::std::option::Option::None,
            steamid_broadcast: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientRichPresenceUpload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRichPresenceUpload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRichPresenceUpload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRichPresenceUpload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRichPresenceRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRichPresenceRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRichPresenceRequest.steamid_request)
    pub steamid_request: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRichPresenceRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRichPresenceRequest {
    fn default() -> &'a CMsgClientRichPresenceRequest {
        <CMsgClientRichPresenceRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRichPresenceRequest {
    pub fn new() -> CMsgClientRichPresenceRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "steamid_request",
            |m: &CMsgClientRichPresenceRequest| { &m.steamid_request },
            |m: &mut CMsgClientRichPresenceRequest| { &mut m.steamid_request },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRichPresenceRequest>(
            "CMsgClientRichPresenceRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientRichPresenceRequest {
    const NAME: &'static str = "CMsgClientRichPresenceRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_fixed64_into(&mut self.steamid_request)?;
                },
                9 => {
                    self.steamid_request.push(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 9 * self.steamid_request.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.steamid_request {
            os.write_fixed64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRichPresenceRequest {
        CMsgClientRichPresenceRequest::new()
    }

    fn clear(&mut self) {
        self.steamid_request.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRichPresenceRequest {
        static instance: CMsgClientRichPresenceRequest = CMsgClientRichPresenceRequest {
            steamid_request: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientRichPresenceRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRichPresenceRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRichPresenceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRichPresenceRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRichPresenceInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRichPresenceInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRichPresenceInfo.rich_presence)
    pub rich_presence: ::std::vec::Vec<cmsg_client_rich_presence_info::RichPresence>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRichPresenceInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRichPresenceInfo {
    fn default() -> &'a CMsgClientRichPresenceInfo {
        <CMsgClientRichPresenceInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRichPresenceInfo {
    pub fn new() -> CMsgClientRichPresenceInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rich_presence",
            |m: &CMsgClientRichPresenceInfo| { &m.rich_presence },
            |m: &mut CMsgClientRichPresenceInfo| { &mut m.rich_presence },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRichPresenceInfo>(
            "CMsgClientRichPresenceInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientRichPresenceInfo {
    const NAME: &'static str = "CMsgClientRichPresenceInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.rich_presence.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.rich_presence {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.rich_presence {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRichPresenceInfo {
        CMsgClientRichPresenceInfo::new()
    }

    fn clear(&mut self) {
        self.rich_presence.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRichPresenceInfo {
        static instance: CMsgClientRichPresenceInfo = CMsgClientRichPresenceInfo {
            rich_presence: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientRichPresenceInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRichPresenceInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRichPresenceInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRichPresenceInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientRichPresenceInfo`
pub mod cmsg_client_rich_presence_info {
    // @@protoc_insertion_point(message:CMsgClientRichPresenceInfo.RichPresence)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RichPresence {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientRichPresenceInfo.RichPresence.steamid_user)
        pub steamid_user: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientRichPresenceInfo.RichPresence.rich_presence_kv)
        pub rich_presence_kv: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientRichPresenceInfo.RichPresence.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RichPresence {
        fn default() -> &'a RichPresence {
            <RichPresence as ::protobuf::Message>::default_instance()
        }
    }

    impl RichPresence {
        pub fn new() -> RichPresence {
            ::std::default::Default::default()
        }

        // optional fixed64 steamid_user = 1;

        pub fn steamid_user(&self) -> u64 {
            self.steamid_user.unwrap_or(0)
        }

        pub fn clear_steamid_user(&mut self) {
            self.steamid_user = ::std::option::Option::None;
        }

        pub fn has_steamid_user(&self) -> bool {
            self.steamid_user.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid_user(&mut self, v: u64) {
            self.steamid_user = ::std::option::Option::Some(v);
        }

        // optional bytes rich_presence_kv = 2;

        pub fn rich_presence_kv(&self) -> &[u8] {
            match self.rich_presence_kv.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_rich_presence_kv(&mut self) {
            self.rich_presence_kv = ::std::option::Option::None;
        }

        pub fn has_rich_presence_kv(&self) -> bool {
            self.rich_presence_kv.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rich_presence_kv(&mut self, v: ::std::vec::Vec<u8>) {
            self.rich_presence_kv = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_rich_presence_kv(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.rich_presence_kv.is_none() {
                self.rich_presence_kv = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.rich_presence_kv.as_mut().unwrap()
        }

        // Take field
        pub fn take_rich_presence_kv(&mut self) -> ::std::vec::Vec<u8> {
            self.rich_presence_kv.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "steamid_user",
                |m: &RichPresence| { &m.steamid_user },
                |m: &mut RichPresence| { &mut m.steamid_user },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rich_presence_kv",
                |m: &RichPresence| { &m.rich_presence_kv },
                |m: &mut RichPresence| { &mut m.rich_presence_kv },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RichPresence>(
                "CMsgClientRichPresenceInfo.RichPresence",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RichPresence {
        const NAME: &'static str = "RichPresence";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steamid_user = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    18 => {
                        self.rich_presence_kv = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steamid_user {
                my_size += 1 + 8;
            }
            if let Some(v) = self.rich_presence_kv.as_ref() {
                my_size += ::protobuf::rt::bytes_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.steamid_user {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.rich_presence_kv.as_ref() {
                os.write_bytes(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RichPresence {
            RichPresence::new()
        }

        fn clear(&mut self) {
            self.steamid_user = ::std::option::Option::None;
            self.rich_presence_kv = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RichPresence {
            static instance: RichPresence = RichPresence {
                steamid_user: ::std::option::Option::None,
                rich_presence_kv: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RichPresence {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientRichPresenceInfo.RichPresence").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RichPresence {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RichPresence {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientCheckFileSignature)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientCheckFileSignature {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientCheckFileSignature.app_id)
    pub app_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientCheckFileSignature.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientCheckFileSignature {
    fn default() -> &'a CMsgClientCheckFileSignature {
        <CMsgClientCheckFileSignature as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientCheckFileSignature {
    pub fn new() -> CMsgClientCheckFileSignature {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientCheckFileSignature| { &m.app_id },
            |m: &mut CMsgClientCheckFileSignature| { &mut m.app_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientCheckFileSignature>(
            "CMsgClientCheckFileSignature",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientCheckFileSignature {
    const NAME: &'static str = "CMsgClientCheckFileSignature";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientCheckFileSignature {
        CMsgClientCheckFileSignature::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientCheckFileSignature {
        static instance: CMsgClientCheckFileSignature = CMsgClientCheckFileSignature {
            app_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientCheckFileSignature {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientCheckFileSignature").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientCheckFileSignature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientCheckFileSignature {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientCheckFileSignatureResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientCheckFileSignatureResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientCheckFileSignatureResponse.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientCheckFileSignatureResponse.pid)
    pub pid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientCheckFileSignatureResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientCheckFileSignatureResponse.filename)
    pub filename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientCheckFileSignatureResponse.esignatureresult)
    pub esignatureresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientCheckFileSignatureResponse.sha_file)
    pub sha_file: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientCheckFileSignatureResponse.signatureheader)
    pub signatureheader: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientCheckFileSignatureResponse.filesize)
    pub filesize: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientCheckFileSignatureResponse.getlasterror)
    pub getlasterror: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientCheckFileSignatureResponse.evalvesignaturecheckdetail)
    pub evalvesignaturecheckdetail: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientCheckFileSignatureResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientCheckFileSignatureResponse {
    fn default() -> &'a CMsgClientCheckFileSignatureResponse {
        <CMsgClientCheckFileSignatureResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientCheckFileSignatureResponse {
    pub fn new() -> CMsgClientCheckFileSignatureResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 pid = 2;

    pub fn pid(&self) -> u32 {
        self.pid.unwrap_or(0)
    }

    pub fn clear_pid(&mut self) {
        self.pid = ::std::option::Option::None;
    }

    pub fn has_pid(&self) -> bool {
        self.pid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pid(&mut self, v: u32) {
        self.pid = ::std::option::Option::Some(v);
    }

    // optional uint32 eresult = 3;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional string filename = 4;

    pub fn filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename = ::std::option::Option::None;
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 esignatureresult = 5;

    pub fn esignatureresult(&self) -> u32 {
        self.esignatureresult.unwrap_or(0)
    }

    pub fn clear_esignatureresult(&mut self) {
        self.esignatureresult = ::std::option::Option::None;
    }

    pub fn has_esignatureresult(&self) -> bool {
        self.esignatureresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_esignatureresult(&mut self, v: u32) {
        self.esignatureresult = ::std::option::Option::Some(v);
    }

    // optional bytes sha_file = 6;

    pub fn sha_file(&self) -> &[u8] {
        match self.sha_file.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sha_file(&mut self) {
        self.sha_file = ::std::option::Option::None;
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes signatureheader = 7;

    pub fn signatureheader(&self) -> &[u8] {
        match self.signatureheader.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_signatureheader(&mut self) {
        self.signatureheader = ::std::option::Option::None;
    }

    pub fn has_signatureheader(&self) -> bool {
        self.signatureheader.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signatureheader(&mut self, v: ::std::vec::Vec<u8>) {
        self.signatureheader = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signatureheader(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signatureheader.is_none() {
            self.signatureheader = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.signatureheader.as_mut().unwrap()
    }

    // Take field
    pub fn take_signatureheader(&mut self) -> ::std::vec::Vec<u8> {
        self.signatureheader.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 filesize = 8;

    pub fn filesize(&self) -> u32 {
        self.filesize.unwrap_or(0)
    }

    pub fn clear_filesize(&mut self) {
        self.filesize = ::std::option::Option::None;
    }

    pub fn has_filesize(&self) -> bool {
        self.filesize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesize(&mut self, v: u32) {
        self.filesize = ::std::option::Option::Some(v);
    }

    // optional uint32 getlasterror = 9;

    pub fn getlasterror(&self) -> u32 {
        self.getlasterror.unwrap_or(0)
    }

    pub fn clear_getlasterror(&mut self) {
        self.getlasterror = ::std::option::Option::None;
    }

    pub fn has_getlasterror(&self) -> bool {
        self.getlasterror.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getlasterror(&mut self, v: u32) {
        self.getlasterror = ::std::option::Option::Some(v);
    }

    // optional uint32 evalvesignaturecheckdetail = 10;

    pub fn evalvesignaturecheckdetail(&self) -> u32 {
        self.evalvesignaturecheckdetail.unwrap_or(0)
    }

    pub fn clear_evalvesignaturecheckdetail(&mut self) {
        self.evalvesignaturecheckdetail = ::std::option::Option::None;
    }

    pub fn has_evalvesignaturecheckdetail(&self) -> bool {
        self.evalvesignaturecheckdetail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_evalvesignaturecheckdetail(&mut self, v: u32) {
        self.evalvesignaturecheckdetail = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientCheckFileSignatureResponse| { &m.app_id },
            |m: &mut CMsgClientCheckFileSignatureResponse| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pid",
            |m: &CMsgClientCheckFileSignatureResponse| { &m.pid },
            |m: &mut CMsgClientCheckFileSignatureResponse| { &mut m.pid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientCheckFileSignatureResponse| { &m.eresult },
            |m: &mut CMsgClientCheckFileSignatureResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "filename",
            |m: &CMsgClientCheckFileSignatureResponse| { &m.filename },
            |m: &mut CMsgClientCheckFileSignatureResponse| { &mut m.filename },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "esignatureresult",
            |m: &CMsgClientCheckFileSignatureResponse| { &m.esignatureresult },
            |m: &mut CMsgClientCheckFileSignatureResponse| { &mut m.esignatureresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sha_file",
            |m: &CMsgClientCheckFileSignatureResponse| { &m.sha_file },
            |m: &mut CMsgClientCheckFileSignatureResponse| { &mut m.sha_file },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "signatureheader",
            |m: &CMsgClientCheckFileSignatureResponse| { &m.signatureheader },
            |m: &mut CMsgClientCheckFileSignatureResponse| { &mut m.signatureheader },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "filesize",
            |m: &CMsgClientCheckFileSignatureResponse| { &m.filesize },
            |m: &mut CMsgClientCheckFileSignatureResponse| { &mut m.filesize },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "getlasterror",
            |m: &CMsgClientCheckFileSignatureResponse| { &m.getlasterror },
            |m: &mut CMsgClientCheckFileSignatureResponse| { &mut m.getlasterror },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "evalvesignaturecheckdetail",
            |m: &CMsgClientCheckFileSignatureResponse| { &m.evalvesignaturecheckdetail },
            |m: &mut CMsgClientCheckFileSignatureResponse| { &mut m.evalvesignaturecheckdetail },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientCheckFileSignatureResponse>(
            "CMsgClientCheckFileSignatureResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientCheckFileSignatureResponse {
    const NAME: &'static str = "CMsgClientCheckFileSignatureResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.pid = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.filename = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.esignatureresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    self.sha_file = ::std::option::Option::Some(is.read_bytes()?);
                },
                58 => {
                    self.signatureheader = ::std::option::Option::Some(is.read_bytes()?);
                },
                64 => {
                    self.filesize = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.getlasterror = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.evalvesignaturecheckdetail = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.pid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.esignatureresult {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.sha_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.signatureheader.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.filesize {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.getlasterror {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.evalvesignaturecheckdetail {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.pid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.filename.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.esignatureresult {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.sha_file.as_ref() {
            os.write_bytes(6, v)?;
        }
        if let Some(v) = self.signatureheader.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.filesize {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.getlasterror {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.evalvesignaturecheckdetail {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientCheckFileSignatureResponse {
        CMsgClientCheckFileSignatureResponse::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.pid = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.filename = ::std::option::Option::None;
        self.esignatureresult = ::std::option::Option::None;
        self.sha_file = ::std::option::Option::None;
        self.signatureheader = ::std::option::Option::None;
        self.filesize = ::std::option::Option::None;
        self.getlasterror = ::std::option::Option::None;
        self.evalvesignaturecheckdetail = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientCheckFileSignatureResponse {
        static instance: CMsgClientCheckFileSignatureResponse = CMsgClientCheckFileSignatureResponse {
            app_id: ::std::option::Option::None,
            pid: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            filename: ::std::option::Option::None,
            esignatureresult: ::std::option::Option::None,
            sha_file: ::std::option::Option::None,
            signatureheader: ::std::option::Option::None,
            filesize: ::std::option::Option::None,
            getlasterror: ::std::option::Option::None,
            evalvesignaturecheckdetail: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientCheckFileSignatureResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientCheckFileSignatureResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientCheckFileSignatureResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientCheckFileSignatureResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientReadMachineAuth)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientReadMachineAuth {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientReadMachineAuth.filename)
    pub filename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientReadMachineAuth.offset)
    pub offset: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientReadMachineAuth.cubtoread)
    pub cubtoread: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientReadMachineAuth.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientReadMachineAuth {
    fn default() -> &'a CMsgClientReadMachineAuth {
        <CMsgClientReadMachineAuth as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientReadMachineAuth {
    pub fn new() -> CMsgClientReadMachineAuth {
        ::std::default::Default::default()
    }

    // optional string filename = 1;

    pub fn filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename = ::std::option::Option::None;
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 offset = 2;

    pub fn offset(&self) -> u32 {
        self.offset.unwrap_or(0)
    }

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u32) {
        self.offset = ::std::option::Option::Some(v);
    }

    // optional uint32 cubtoread = 3;

    pub fn cubtoread(&self) -> u32 {
        self.cubtoread.unwrap_or(0)
    }

    pub fn clear_cubtoread(&mut self) {
        self.cubtoread = ::std::option::Option::None;
    }

    pub fn has_cubtoread(&self) -> bool {
        self.cubtoread.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubtoread(&mut self, v: u32) {
        self.cubtoread = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "filename",
            |m: &CMsgClientReadMachineAuth| { &m.filename },
            |m: &mut CMsgClientReadMachineAuth| { &mut m.filename },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "offset",
            |m: &CMsgClientReadMachineAuth| { &m.offset },
            |m: &mut CMsgClientReadMachineAuth| { &mut m.offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cubtoread",
            |m: &CMsgClientReadMachineAuth| { &m.cubtoread },
            |m: &mut CMsgClientReadMachineAuth| { &mut m.cubtoread },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientReadMachineAuth>(
            "CMsgClientReadMachineAuth",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientReadMachineAuth {
    const NAME: &'static str = "CMsgClientReadMachineAuth";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.filename = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.offset = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.cubtoread = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.cubtoread {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.filename.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.cubtoread {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientReadMachineAuth {
        CMsgClientReadMachineAuth::new()
    }

    fn clear(&mut self) {
        self.filename = ::std::option::Option::None;
        self.offset = ::std::option::Option::None;
        self.cubtoread = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientReadMachineAuth {
        static instance: CMsgClientReadMachineAuth = CMsgClientReadMachineAuth {
            filename: ::std::option::Option::None,
            offset: ::std::option::Option::None,
            cubtoread: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientReadMachineAuth {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientReadMachineAuth").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientReadMachineAuth {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientReadMachineAuth {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientReadMachineAuthResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientReadMachineAuthResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientReadMachineAuthResponse.filename)
    pub filename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientReadMachineAuthResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientReadMachineAuthResponse.filesize)
    pub filesize: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientReadMachineAuthResponse.sha_file)
    pub sha_file: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientReadMachineAuthResponse.getlasterror)
    pub getlasterror: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientReadMachineAuthResponse.offset)
    pub offset: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientReadMachineAuthResponse.cubread)
    pub cubread: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientReadMachineAuthResponse.bytes_read)
    pub bytes_read: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientReadMachineAuthResponse.filename_sentry)
    pub filename_sentry: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientReadMachineAuthResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientReadMachineAuthResponse {
    fn default() -> &'a CMsgClientReadMachineAuthResponse {
        <CMsgClientReadMachineAuthResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientReadMachineAuthResponse {
    pub fn new() -> CMsgClientReadMachineAuthResponse {
        ::std::default::Default::default()
    }

    // optional string filename = 1;

    pub fn filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename = ::std::option::Option::None;
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 eresult = 2;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 filesize = 3;

    pub fn filesize(&self) -> u32 {
        self.filesize.unwrap_or(0)
    }

    pub fn clear_filesize(&mut self) {
        self.filesize = ::std::option::Option::None;
    }

    pub fn has_filesize(&self) -> bool {
        self.filesize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesize(&mut self, v: u32) {
        self.filesize = ::std::option::Option::Some(v);
    }

    // optional bytes sha_file = 4;

    pub fn sha_file(&self) -> &[u8] {
        match self.sha_file.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sha_file(&mut self) {
        self.sha_file = ::std::option::Option::None;
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 getlasterror = 5;

    pub fn getlasterror(&self) -> u32 {
        self.getlasterror.unwrap_or(0)
    }

    pub fn clear_getlasterror(&mut self) {
        self.getlasterror = ::std::option::Option::None;
    }

    pub fn has_getlasterror(&self) -> bool {
        self.getlasterror.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getlasterror(&mut self, v: u32) {
        self.getlasterror = ::std::option::Option::Some(v);
    }

    // optional uint32 offset = 6;

    pub fn offset(&self) -> u32 {
        self.offset.unwrap_or(0)
    }

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u32) {
        self.offset = ::std::option::Option::Some(v);
    }

    // optional uint32 cubread = 7;

    pub fn cubread(&self) -> u32 {
        self.cubread.unwrap_or(0)
    }

    pub fn clear_cubread(&mut self) {
        self.cubread = ::std::option::Option::None;
    }

    pub fn has_cubread(&self) -> bool {
        self.cubread.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubread(&mut self, v: u32) {
        self.cubread = ::std::option::Option::Some(v);
    }

    // optional bytes bytes_read = 8;

    pub fn bytes_read(&self) -> &[u8] {
        match self.bytes_read.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_bytes_read(&mut self) {
        self.bytes_read = ::std::option::Option::None;
    }

    pub fn has_bytes_read(&self) -> bool {
        self.bytes_read.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_read(&mut self, v: ::std::vec::Vec<u8>) {
        self.bytes_read = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bytes_read(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.bytes_read.is_none() {
            self.bytes_read = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.bytes_read.as_mut().unwrap()
    }

    // Take field
    pub fn take_bytes_read(&mut self) -> ::std::vec::Vec<u8> {
        self.bytes_read.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string filename_sentry = 9;

    pub fn filename_sentry(&self) -> &str {
        match self.filename_sentry.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename_sentry(&mut self) {
        self.filename_sentry = ::std::option::Option::None;
    }

    pub fn has_filename_sentry(&self) -> bool {
        self.filename_sentry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename_sentry(&mut self, v: ::std::string::String) {
        self.filename_sentry = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename_sentry(&mut self) -> &mut ::std::string::String {
        if self.filename_sentry.is_none() {
            self.filename_sentry = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filename_sentry.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename_sentry(&mut self) -> ::std::string::String {
        self.filename_sentry.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "filename",
            |m: &CMsgClientReadMachineAuthResponse| { &m.filename },
            |m: &mut CMsgClientReadMachineAuthResponse| { &mut m.filename },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientReadMachineAuthResponse| { &m.eresult },
            |m: &mut CMsgClientReadMachineAuthResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "filesize",
            |m: &CMsgClientReadMachineAuthResponse| { &m.filesize },
            |m: &mut CMsgClientReadMachineAuthResponse| { &mut m.filesize },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sha_file",
            |m: &CMsgClientReadMachineAuthResponse| { &m.sha_file },
            |m: &mut CMsgClientReadMachineAuthResponse| { &mut m.sha_file },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "getlasterror",
            |m: &CMsgClientReadMachineAuthResponse| { &m.getlasterror },
            |m: &mut CMsgClientReadMachineAuthResponse| { &mut m.getlasterror },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "offset",
            |m: &CMsgClientReadMachineAuthResponse| { &m.offset },
            |m: &mut CMsgClientReadMachineAuthResponse| { &mut m.offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cubread",
            |m: &CMsgClientReadMachineAuthResponse| { &m.cubread },
            |m: &mut CMsgClientReadMachineAuthResponse| { &mut m.cubread },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bytes_read",
            |m: &CMsgClientReadMachineAuthResponse| { &m.bytes_read },
            |m: &mut CMsgClientReadMachineAuthResponse| { &mut m.bytes_read },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "filename_sentry",
            |m: &CMsgClientReadMachineAuthResponse| { &m.filename_sentry },
            |m: &mut CMsgClientReadMachineAuthResponse| { &mut m.filename_sentry },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientReadMachineAuthResponse>(
            "CMsgClientReadMachineAuthResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientReadMachineAuthResponse {
    const NAME: &'static str = "CMsgClientReadMachineAuthResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.filename = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.filesize = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.sha_file = ::std::option::Option::Some(is.read_bytes()?);
                },
                40 => {
                    self.getlasterror = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.offset = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.cubread = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.bytes_read = ::std::option::Option::Some(is.read_bytes()?);
                },
                74 => {
                    self.filename_sentry = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.filesize {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.sha_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.getlasterror {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.cubread {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.bytes_read.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.filename_sentry.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.filename.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.filesize {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.sha_file.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.getlasterror {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.cubread {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.bytes_read.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.filename_sentry.as_ref() {
            os.write_string(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientReadMachineAuthResponse {
        CMsgClientReadMachineAuthResponse::new()
    }

    fn clear(&mut self) {
        self.filename = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.filesize = ::std::option::Option::None;
        self.sha_file = ::std::option::Option::None;
        self.getlasterror = ::std::option::Option::None;
        self.offset = ::std::option::Option::None;
        self.cubread = ::std::option::Option::None;
        self.bytes_read = ::std::option::Option::None;
        self.filename_sentry = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientReadMachineAuthResponse {
        static instance: CMsgClientReadMachineAuthResponse = CMsgClientReadMachineAuthResponse {
            filename: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            filesize: ::std::option::Option::None,
            sha_file: ::std::option::Option::None,
            getlasterror: ::std::option::Option::None,
            offset: ::std::option::Option::None,
            cubread: ::std::option::Option::None,
            bytes_read: ::std::option::Option::None,
            filename_sentry: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientReadMachineAuthResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientReadMachineAuthResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientReadMachineAuthResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientReadMachineAuthResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUpdateMachineAuth)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUpdateMachineAuth {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuth.filename)
    pub filename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuth.offset)
    pub offset: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuth.cubtowrite)
    pub cubtowrite: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuth.bytes)
    pub bytes: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuth.otp_type)
    pub otp_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuth.otp_identifier)
    pub otp_identifier: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuth.otp_sharedsecret)
    pub otp_sharedsecret: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuth.otp_timedrift)
    pub otp_timedrift: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUpdateMachineAuth.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUpdateMachineAuth {
    fn default() -> &'a CMsgClientUpdateMachineAuth {
        <CMsgClientUpdateMachineAuth as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUpdateMachineAuth {
    pub fn new() -> CMsgClientUpdateMachineAuth {
        ::std::default::Default::default()
    }

    // optional string filename = 1;

    pub fn filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename = ::std::option::Option::None;
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 offset = 2;

    pub fn offset(&self) -> u32 {
        self.offset.unwrap_or(0)
    }

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u32) {
        self.offset = ::std::option::Option::Some(v);
    }

    // optional uint32 cubtowrite = 3;

    pub fn cubtowrite(&self) -> u32 {
        self.cubtowrite.unwrap_or(0)
    }

    pub fn clear_cubtowrite(&mut self) {
        self.cubtowrite = ::std::option::Option::None;
    }

    pub fn has_cubtowrite(&self) -> bool {
        self.cubtowrite.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubtowrite(&mut self, v: u32) {
        self.cubtowrite = ::std::option::Option::Some(v);
    }

    // optional bytes bytes = 4;

    pub fn bytes(&self) -> &[u8] {
        match self.bytes.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_bytes(&mut self) {
        self.bytes = ::std::option::Option::None;
    }

    pub fn has_bytes(&self) -> bool {
        self.bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.bytes = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.bytes.is_none() {
            self.bytes = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.bytes.as_mut().unwrap()
    }

    // Take field
    pub fn take_bytes(&mut self) -> ::std::vec::Vec<u8> {
        self.bytes.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 otp_type = 5;

    pub fn otp_type(&self) -> u32 {
        self.otp_type.unwrap_or(0)
    }

    pub fn clear_otp_type(&mut self) {
        self.otp_type = ::std::option::Option::None;
    }

    pub fn has_otp_type(&self) -> bool {
        self.otp_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_type(&mut self, v: u32) {
        self.otp_type = ::std::option::Option::Some(v);
    }

    // optional string otp_identifier = 6;

    pub fn otp_identifier(&self) -> &str {
        match self.otp_identifier.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_otp_identifier(&mut self) {
        self.otp_identifier = ::std::option::Option::None;
    }

    pub fn has_otp_identifier(&self) -> bool {
        self.otp_identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_identifier(&mut self, v: ::std::string::String) {
        self.otp_identifier = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_otp_identifier(&mut self) -> &mut ::std::string::String {
        if self.otp_identifier.is_none() {
            self.otp_identifier = ::std::option::Option::Some(::std::string::String::new());
        }
        self.otp_identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_otp_identifier(&mut self) -> ::std::string::String {
        self.otp_identifier.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes otp_sharedsecret = 7;

    pub fn otp_sharedsecret(&self) -> &[u8] {
        match self.otp_sharedsecret.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_otp_sharedsecret(&mut self) {
        self.otp_sharedsecret = ::std::option::Option::None;
    }

    pub fn has_otp_sharedsecret(&self) -> bool {
        self.otp_sharedsecret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_sharedsecret(&mut self, v: ::std::vec::Vec<u8>) {
        self.otp_sharedsecret = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_otp_sharedsecret(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.otp_sharedsecret.is_none() {
            self.otp_sharedsecret = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.otp_sharedsecret.as_mut().unwrap()
    }

    // Take field
    pub fn take_otp_sharedsecret(&mut self) -> ::std::vec::Vec<u8> {
        self.otp_sharedsecret.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 otp_timedrift = 8;

    pub fn otp_timedrift(&self) -> u32 {
        self.otp_timedrift.unwrap_or(0)
    }

    pub fn clear_otp_timedrift(&mut self) {
        self.otp_timedrift = ::std::option::Option::None;
    }

    pub fn has_otp_timedrift(&self) -> bool {
        self.otp_timedrift.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_timedrift(&mut self, v: u32) {
        self.otp_timedrift = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "filename",
            |m: &CMsgClientUpdateMachineAuth| { &m.filename },
            |m: &mut CMsgClientUpdateMachineAuth| { &mut m.filename },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "offset",
            |m: &CMsgClientUpdateMachineAuth| { &m.offset },
            |m: &mut CMsgClientUpdateMachineAuth| { &mut m.offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cubtowrite",
            |m: &CMsgClientUpdateMachineAuth| { &m.cubtowrite },
            |m: &mut CMsgClientUpdateMachineAuth| { &mut m.cubtowrite },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bytes",
            |m: &CMsgClientUpdateMachineAuth| { &m.bytes },
            |m: &mut CMsgClientUpdateMachineAuth| { &mut m.bytes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "otp_type",
            |m: &CMsgClientUpdateMachineAuth| { &m.otp_type },
            |m: &mut CMsgClientUpdateMachineAuth| { &mut m.otp_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "otp_identifier",
            |m: &CMsgClientUpdateMachineAuth| { &m.otp_identifier },
            |m: &mut CMsgClientUpdateMachineAuth| { &mut m.otp_identifier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "otp_sharedsecret",
            |m: &CMsgClientUpdateMachineAuth| { &m.otp_sharedsecret },
            |m: &mut CMsgClientUpdateMachineAuth| { &mut m.otp_sharedsecret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "otp_timedrift",
            |m: &CMsgClientUpdateMachineAuth| { &m.otp_timedrift },
            |m: &mut CMsgClientUpdateMachineAuth| { &mut m.otp_timedrift },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUpdateMachineAuth>(
            "CMsgClientUpdateMachineAuth",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUpdateMachineAuth {
    const NAME: &'static str = "CMsgClientUpdateMachineAuth";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.filename = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.offset = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.cubtowrite = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.bytes = ::std::option::Option::Some(is.read_bytes()?);
                },
                40 => {
                    self.otp_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    self.otp_identifier = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.otp_sharedsecret = ::std::option::Option::Some(is.read_bytes()?);
                },
                64 => {
                    self.otp_timedrift = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.cubtowrite {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.bytes.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.otp_type {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.otp_identifier.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.otp_sharedsecret.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.otp_timedrift {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.filename.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.cubtowrite {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.bytes.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.otp_type {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.otp_identifier.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.otp_sharedsecret.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.otp_timedrift {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUpdateMachineAuth {
        CMsgClientUpdateMachineAuth::new()
    }

    fn clear(&mut self) {
        self.filename = ::std::option::Option::None;
        self.offset = ::std::option::Option::None;
        self.cubtowrite = ::std::option::Option::None;
        self.bytes = ::std::option::Option::None;
        self.otp_type = ::std::option::Option::None;
        self.otp_identifier = ::std::option::Option::None;
        self.otp_sharedsecret = ::std::option::Option::None;
        self.otp_timedrift = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUpdateMachineAuth {
        static instance: CMsgClientUpdateMachineAuth = CMsgClientUpdateMachineAuth {
            filename: ::std::option::Option::None,
            offset: ::std::option::Option::None,
            cubtowrite: ::std::option::Option::None,
            bytes: ::std::option::Option::None,
            otp_type: ::std::option::Option::None,
            otp_identifier: ::std::option::Option::None,
            otp_sharedsecret: ::std::option::Option::None,
            otp_timedrift: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUpdateMachineAuth {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUpdateMachineAuth").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUpdateMachineAuth {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUpdateMachineAuth {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUpdateMachineAuthResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUpdateMachineAuthResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuthResponse.filename)
    pub filename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuthResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuthResponse.filesize)
    pub filesize: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuthResponse.sha_file)
    pub sha_file: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuthResponse.getlasterror)
    pub getlasterror: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuthResponse.offset)
    pub offset: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuthResponse.cubwrote)
    pub cubwrote: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuthResponse.otp_type)
    pub otp_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuthResponse.otp_value)
    pub otp_value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateMachineAuthResponse.otp_identifier)
    pub otp_identifier: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUpdateMachineAuthResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUpdateMachineAuthResponse {
    fn default() -> &'a CMsgClientUpdateMachineAuthResponse {
        <CMsgClientUpdateMachineAuthResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUpdateMachineAuthResponse {
    pub fn new() -> CMsgClientUpdateMachineAuthResponse {
        ::std::default::Default::default()
    }

    // optional string filename = 1;

    pub fn filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename = ::std::option::Option::None;
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 eresult = 2;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 filesize = 3;

    pub fn filesize(&self) -> u32 {
        self.filesize.unwrap_or(0)
    }

    pub fn clear_filesize(&mut self) {
        self.filesize = ::std::option::Option::None;
    }

    pub fn has_filesize(&self) -> bool {
        self.filesize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesize(&mut self, v: u32) {
        self.filesize = ::std::option::Option::Some(v);
    }

    // optional bytes sha_file = 4;

    pub fn sha_file(&self) -> &[u8] {
        match self.sha_file.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sha_file(&mut self) {
        self.sha_file = ::std::option::Option::None;
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 getlasterror = 5;

    pub fn getlasterror(&self) -> u32 {
        self.getlasterror.unwrap_or(0)
    }

    pub fn clear_getlasterror(&mut self) {
        self.getlasterror = ::std::option::Option::None;
    }

    pub fn has_getlasterror(&self) -> bool {
        self.getlasterror.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getlasterror(&mut self, v: u32) {
        self.getlasterror = ::std::option::Option::Some(v);
    }

    // optional uint32 offset = 6;

    pub fn offset(&self) -> u32 {
        self.offset.unwrap_or(0)
    }

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u32) {
        self.offset = ::std::option::Option::Some(v);
    }

    // optional uint32 cubwrote = 7;

    pub fn cubwrote(&self) -> u32 {
        self.cubwrote.unwrap_or(0)
    }

    pub fn clear_cubwrote(&mut self) {
        self.cubwrote = ::std::option::Option::None;
    }

    pub fn has_cubwrote(&self) -> bool {
        self.cubwrote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubwrote(&mut self, v: u32) {
        self.cubwrote = ::std::option::Option::Some(v);
    }

    // optional int32 otp_type = 8;

    pub fn otp_type(&self) -> i32 {
        self.otp_type.unwrap_or(0)
    }

    pub fn clear_otp_type(&mut self) {
        self.otp_type = ::std::option::Option::None;
    }

    pub fn has_otp_type(&self) -> bool {
        self.otp_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_type(&mut self, v: i32) {
        self.otp_type = ::std::option::Option::Some(v);
    }

    // optional uint32 otp_value = 9;

    pub fn otp_value(&self) -> u32 {
        self.otp_value.unwrap_or(0)
    }

    pub fn clear_otp_value(&mut self) {
        self.otp_value = ::std::option::Option::None;
    }

    pub fn has_otp_value(&self) -> bool {
        self.otp_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_value(&mut self, v: u32) {
        self.otp_value = ::std::option::Option::Some(v);
    }

    // optional string otp_identifier = 10;

    pub fn otp_identifier(&self) -> &str {
        match self.otp_identifier.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_otp_identifier(&mut self) {
        self.otp_identifier = ::std::option::Option::None;
    }

    pub fn has_otp_identifier(&self) -> bool {
        self.otp_identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_identifier(&mut self, v: ::std::string::String) {
        self.otp_identifier = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_otp_identifier(&mut self) -> &mut ::std::string::String {
        if self.otp_identifier.is_none() {
            self.otp_identifier = ::std::option::Option::Some(::std::string::String::new());
        }
        self.otp_identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_otp_identifier(&mut self) -> ::std::string::String {
        self.otp_identifier.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "filename",
            |m: &CMsgClientUpdateMachineAuthResponse| { &m.filename },
            |m: &mut CMsgClientUpdateMachineAuthResponse| { &mut m.filename },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientUpdateMachineAuthResponse| { &m.eresult },
            |m: &mut CMsgClientUpdateMachineAuthResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "filesize",
            |m: &CMsgClientUpdateMachineAuthResponse| { &m.filesize },
            |m: &mut CMsgClientUpdateMachineAuthResponse| { &mut m.filesize },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sha_file",
            |m: &CMsgClientUpdateMachineAuthResponse| { &m.sha_file },
            |m: &mut CMsgClientUpdateMachineAuthResponse| { &mut m.sha_file },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "getlasterror",
            |m: &CMsgClientUpdateMachineAuthResponse| { &m.getlasterror },
            |m: &mut CMsgClientUpdateMachineAuthResponse| { &mut m.getlasterror },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "offset",
            |m: &CMsgClientUpdateMachineAuthResponse| { &m.offset },
            |m: &mut CMsgClientUpdateMachineAuthResponse| { &mut m.offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cubwrote",
            |m: &CMsgClientUpdateMachineAuthResponse| { &m.cubwrote },
            |m: &mut CMsgClientUpdateMachineAuthResponse| { &mut m.cubwrote },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "otp_type",
            |m: &CMsgClientUpdateMachineAuthResponse| { &m.otp_type },
            |m: &mut CMsgClientUpdateMachineAuthResponse| { &mut m.otp_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "otp_value",
            |m: &CMsgClientUpdateMachineAuthResponse| { &m.otp_value },
            |m: &mut CMsgClientUpdateMachineAuthResponse| { &mut m.otp_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "otp_identifier",
            |m: &CMsgClientUpdateMachineAuthResponse| { &m.otp_identifier },
            |m: &mut CMsgClientUpdateMachineAuthResponse| { &mut m.otp_identifier },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUpdateMachineAuthResponse>(
            "CMsgClientUpdateMachineAuthResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUpdateMachineAuthResponse {
    const NAME: &'static str = "CMsgClientUpdateMachineAuthResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.filename = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.filesize = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.sha_file = ::std::option::Option::Some(is.read_bytes()?);
                },
                40 => {
                    self.getlasterror = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.offset = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.cubwrote = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.otp_type = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.otp_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                82 => {
                    self.otp_identifier = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.filesize {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.sha_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.getlasterror {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.cubwrote {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.otp_type {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.otp_value {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.otp_identifier.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.filename.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.filesize {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.sha_file.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.getlasterror {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.cubwrote {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.otp_type {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.otp_value {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.otp_identifier.as_ref() {
            os.write_string(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUpdateMachineAuthResponse {
        CMsgClientUpdateMachineAuthResponse::new()
    }

    fn clear(&mut self) {
        self.filename = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.filesize = ::std::option::Option::None;
        self.sha_file = ::std::option::Option::None;
        self.getlasterror = ::std::option::Option::None;
        self.offset = ::std::option::Option::None;
        self.cubwrote = ::std::option::Option::None;
        self.otp_type = ::std::option::Option::None;
        self.otp_value = ::std::option::Option::None;
        self.otp_identifier = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUpdateMachineAuthResponse {
        static instance: CMsgClientUpdateMachineAuthResponse = CMsgClientUpdateMachineAuthResponse {
            filename: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            filesize: ::std::option::Option::None,
            sha_file: ::std::option::Option::None,
            getlasterror: ::std::option::Option::None,
            offset: ::std::option::Option::None,
            cubwrote: ::std::option::Option::None,
            otp_type: ::std::option::Option::None,
            otp_value: ::std::option::Option::None,
            otp_identifier: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUpdateMachineAuthResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUpdateMachineAuthResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUpdateMachineAuthResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUpdateMachineAuthResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRequestMachineAuth)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestMachineAuth {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRequestMachineAuth.filename)
    pub filename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientRequestMachineAuth.eresult_sentryfile)
    pub eresult_sentryfile: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRequestMachineAuth.filesize)
    pub filesize: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRequestMachineAuth.sha_sentryfile)
    pub sha_sentryfile: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientRequestMachineAuth.lock_account_action)
    pub lock_account_action: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientRequestMachineAuth.otp_type)
    pub otp_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRequestMachineAuth.otp_identifier)
    pub otp_identifier: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientRequestMachineAuth.otp_sharedsecret)
    pub otp_sharedsecret: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientRequestMachineAuth.otp_value)
    pub otp_value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRequestMachineAuth.machine_name)
    pub machine_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientRequestMachineAuth.machine_name_userchosen)
    pub machine_name_userchosen: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestMachineAuth.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestMachineAuth {
    fn default() -> &'a CMsgClientRequestMachineAuth {
        <CMsgClientRequestMachineAuth as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestMachineAuth {
    pub fn new() -> CMsgClientRequestMachineAuth {
        ::std::default::Default::default()
    }

    // optional string filename = 1;

    pub fn filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename = ::std::option::Option::None;
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 eresult_sentryfile = 2;

    pub fn eresult_sentryfile(&self) -> u32 {
        self.eresult_sentryfile.unwrap_or(0)
    }

    pub fn clear_eresult_sentryfile(&mut self) {
        self.eresult_sentryfile = ::std::option::Option::None;
    }

    pub fn has_eresult_sentryfile(&self) -> bool {
        self.eresult_sentryfile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult_sentryfile(&mut self, v: u32) {
        self.eresult_sentryfile = ::std::option::Option::Some(v);
    }

    // optional uint32 filesize = 3;

    pub fn filesize(&self) -> u32 {
        self.filesize.unwrap_or(0)
    }

    pub fn clear_filesize(&mut self) {
        self.filesize = ::std::option::Option::None;
    }

    pub fn has_filesize(&self) -> bool {
        self.filesize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesize(&mut self, v: u32) {
        self.filesize = ::std::option::Option::Some(v);
    }

    // optional bytes sha_sentryfile = 4;

    pub fn sha_sentryfile(&self) -> &[u8] {
        match self.sha_sentryfile.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sha_sentryfile(&mut self) {
        self.sha_sentryfile = ::std::option::Option::None;
    }

    pub fn has_sha_sentryfile(&self) -> bool {
        self.sha_sentryfile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_sentryfile(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_sentryfile = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_sentryfile(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha_sentryfile.is_none() {
            self.sha_sentryfile = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.sha_sentryfile.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_sentryfile(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_sentryfile.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 lock_account_action = 6;

    pub fn lock_account_action(&self) -> i32 {
        self.lock_account_action.unwrap_or(0)
    }

    pub fn clear_lock_account_action(&mut self) {
        self.lock_account_action = ::std::option::Option::None;
    }

    pub fn has_lock_account_action(&self) -> bool {
        self.lock_account_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lock_account_action(&mut self, v: i32) {
        self.lock_account_action = ::std::option::Option::Some(v);
    }

    // optional uint32 otp_type = 7;

    pub fn otp_type(&self) -> u32 {
        self.otp_type.unwrap_or(0)
    }

    pub fn clear_otp_type(&mut self) {
        self.otp_type = ::std::option::Option::None;
    }

    pub fn has_otp_type(&self) -> bool {
        self.otp_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_type(&mut self, v: u32) {
        self.otp_type = ::std::option::Option::Some(v);
    }

    // optional string otp_identifier = 8;

    pub fn otp_identifier(&self) -> &str {
        match self.otp_identifier.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_otp_identifier(&mut self) {
        self.otp_identifier = ::std::option::Option::None;
    }

    pub fn has_otp_identifier(&self) -> bool {
        self.otp_identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_identifier(&mut self, v: ::std::string::String) {
        self.otp_identifier = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_otp_identifier(&mut self) -> &mut ::std::string::String {
        if self.otp_identifier.is_none() {
            self.otp_identifier = ::std::option::Option::Some(::std::string::String::new());
        }
        self.otp_identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_otp_identifier(&mut self) -> ::std::string::String {
        self.otp_identifier.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes otp_sharedsecret = 9;

    pub fn otp_sharedsecret(&self) -> &[u8] {
        match self.otp_sharedsecret.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_otp_sharedsecret(&mut self) {
        self.otp_sharedsecret = ::std::option::Option::None;
    }

    pub fn has_otp_sharedsecret(&self) -> bool {
        self.otp_sharedsecret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_sharedsecret(&mut self, v: ::std::vec::Vec<u8>) {
        self.otp_sharedsecret = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_otp_sharedsecret(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.otp_sharedsecret.is_none() {
            self.otp_sharedsecret = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.otp_sharedsecret.as_mut().unwrap()
    }

    // Take field
    pub fn take_otp_sharedsecret(&mut self) -> ::std::vec::Vec<u8> {
        self.otp_sharedsecret.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 otp_value = 10;

    pub fn otp_value(&self) -> u32 {
        self.otp_value.unwrap_or(0)
    }

    pub fn clear_otp_value(&mut self) {
        self.otp_value = ::std::option::Option::None;
    }

    pub fn has_otp_value(&self) -> bool {
        self.otp_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_value(&mut self, v: u32) {
        self.otp_value = ::std::option::Option::Some(v);
    }

    // optional string machine_name = 11;

    pub fn machine_name(&self) -> &str {
        match self.machine_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_machine_name(&mut self) {
        self.machine_name = ::std::option::Option::None;
    }

    pub fn has_machine_name(&self) -> bool {
        self.machine_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machine_name(&mut self, v: ::std::string::String) {
        self.machine_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machine_name(&mut self) -> &mut ::std::string::String {
        if self.machine_name.is_none() {
            self.machine_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.machine_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_machine_name(&mut self) -> ::std::string::String {
        self.machine_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string machine_name_userchosen = 12;

    pub fn machine_name_userchosen(&self) -> &str {
        match self.machine_name_userchosen.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_machine_name_userchosen(&mut self) {
        self.machine_name_userchosen = ::std::option::Option::None;
    }

    pub fn has_machine_name_userchosen(&self) -> bool {
        self.machine_name_userchosen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machine_name_userchosen(&mut self, v: ::std::string::String) {
        self.machine_name_userchosen = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machine_name_userchosen(&mut self) -> &mut ::std::string::String {
        if self.machine_name_userchosen.is_none() {
            self.machine_name_userchosen = ::std::option::Option::Some(::std::string::String::new());
        }
        self.machine_name_userchosen.as_mut().unwrap()
    }

    // Take field
    pub fn take_machine_name_userchosen(&mut self) -> ::std::string::String {
        self.machine_name_userchosen.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "filename",
            |m: &CMsgClientRequestMachineAuth| { &m.filename },
            |m: &mut CMsgClientRequestMachineAuth| { &mut m.filename },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult_sentryfile",
            |m: &CMsgClientRequestMachineAuth| { &m.eresult_sentryfile },
            |m: &mut CMsgClientRequestMachineAuth| { &mut m.eresult_sentryfile },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "filesize",
            |m: &CMsgClientRequestMachineAuth| { &m.filesize },
            |m: &mut CMsgClientRequestMachineAuth| { &mut m.filesize },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sha_sentryfile",
            |m: &CMsgClientRequestMachineAuth| { &m.sha_sentryfile },
            |m: &mut CMsgClientRequestMachineAuth| { &mut m.sha_sentryfile },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lock_account_action",
            |m: &CMsgClientRequestMachineAuth| { &m.lock_account_action },
            |m: &mut CMsgClientRequestMachineAuth| { &mut m.lock_account_action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "otp_type",
            |m: &CMsgClientRequestMachineAuth| { &m.otp_type },
            |m: &mut CMsgClientRequestMachineAuth| { &mut m.otp_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "otp_identifier",
            |m: &CMsgClientRequestMachineAuth| { &m.otp_identifier },
            |m: &mut CMsgClientRequestMachineAuth| { &mut m.otp_identifier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "otp_sharedsecret",
            |m: &CMsgClientRequestMachineAuth| { &m.otp_sharedsecret },
            |m: &mut CMsgClientRequestMachineAuth| { &mut m.otp_sharedsecret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "otp_value",
            |m: &CMsgClientRequestMachineAuth| { &m.otp_value },
            |m: &mut CMsgClientRequestMachineAuth| { &mut m.otp_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "machine_name",
            |m: &CMsgClientRequestMachineAuth| { &m.machine_name },
            |m: &mut CMsgClientRequestMachineAuth| { &mut m.machine_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "machine_name_userchosen",
            |m: &CMsgClientRequestMachineAuth| { &m.machine_name_userchosen },
            |m: &mut CMsgClientRequestMachineAuth| { &mut m.machine_name_userchosen },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRequestMachineAuth>(
            "CMsgClientRequestMachineAuth",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientRequestMachineAuth {
    const NAME: &'static str = "CMsgClientRequestMachineAuth";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.filename = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.eresult_sentryfile = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.filesize = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.sha_sentryfile = ::std::option::Option::Some(is.read_bytes()?);
                },
                48 => {
                    self.lock_account_action = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.otp_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.otp_identifier = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.otp_sharedsecret = ::std::option::Option::Some(is.read_bytes()?);
                },
                80 => {
                    self.otp_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                90 => {
                    self.machine_name = ::std::option::Option::Some(is.read_string()?);
                },
                98 => {
                    self.machine_name_userchosen = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.eresult_sentryfile {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.filesize {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.sha_sentryfile.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.lock_account_action {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.otp_type {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.otp_identifier.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.otp_sharedsecret.as_ref() {
            my_size += ::protobuf::rt::bytes_size(9, &v);
        }
        if let Some(v) = self.otp_value {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.machine_name.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.machine_name_userchosen.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.filename.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.eresult_sentryfile {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.filesize {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.sha_sentryfile.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.lock_account_action {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.otp_type {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.otp_identifier.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.otp_sharedsecret.as_ref() {
            os.write_bytes(9, v)?;
        }
        if let Some(v) = self.otp_value {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.machine_name.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.machine_name_userchosen.as_ref() {
            os.write_string(12, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestMachineAuth {
        CMsgClientRequestMachineAuth::new()
    }

    fn clear(&mut self) {
        self.filename = ::std::option::Option::None;
        self.eresult_sentryfile = ::std::option::Option::None;
        self.filesize = ::std::option::Option::None;
        self.sha_sentryfile = ::std::option::Option::None;
        self.lock_account_action = ::std::option::Option::None;
        self.otp_type = ::std::option::Option::None;
        self.otp_identifier = ::std::option::Option::None;
        self.otp_sharedsecret = ::std::option::Option::None;
        self.otp_value = ::std::option::Option::None;
        self.machine_name = ::std::option::Option::None;
        self.machine_name_userchosen = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestMachineAuth {
        static instance: CMsgClientRequestMachineAuth = CMsgClientRequestMachineAuth {
            filename: ::std::option::Option::None,
            eresult_sentryfile: ::std::option::Option::None,
            filesize: ::std::option::Option::None,
            sha_sentryfile: ::std::option::Option::None,
            lock_account_action: ::std::option::Option::None,
            otp_type: ::std::option::Option::None,
            otp_identifier: ::std::option::Option::None,
            otp_sharedsecret: ::std::option::Option::None,
            otp_value: ::std::option::Option::None,
            machine_name: ::std::option::Option::None,
            machine_name_userchosen: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientRequestMachineAuth {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRequestMachineAuth").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRequestMachineAuth {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestMachineAuth {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRequestMachineAuthResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestMachineAuthResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRequestMachineAuthResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestMachineAuthResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestMachineAuthResponse {
    fn default() -> &'a CMsgClientRequestMachineAuthResponse {
        <CMsgClientRequestMachineAuthResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestMachineAuthResponse {
    pub fn new() -> CMsgClientRequestMachineAuthResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientRequestMachineAuthResponse| { &m.eresult },
            |m: &mut CMsgClientRequestMachineAuthResponse| { &mut m.eresult },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRequestMachineAuthResponse>(
            "CMsgClientRequestMachineAuthResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientRequestMachineAuthResponse {
    const NAME: &'static str = "CMsgClientRequestMachineAuthResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestMachineAuthResponse {
        CMsgClientRequestMachineAuthResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestMachineAuthResponse {
        static instance: CMsgClientRequestMachineAuthResponse = CMsgClientRequestMachineAuthResponse {
            eresult: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientRequestMachineAuthResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRequestMachineAuthResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRequestMachineAuthResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestMachineAuthResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRegisterKey)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRegisterKey {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRegisterKey.key)
    pub key: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRegisterKey.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRegisterKey {
    fn default() -> &'a CMsgClientRegisterKey {
        <CMsgClientRegisterKey as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRegisterKey {
    pub fn new() -> CMsgClientRegisterKey {
        ::std::default::Default::default()
    }

    // optional string key = 1;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &CMsgClientRegisterKey| { &m.key },
            |m: &mut CMsgClientRegisterKey| { &mut m.key },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRegisterKey>(
            "CMsgClientRegisterKey",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientRegisterKey {
    const NAME: &'static str = "CMsgClientRegisterKey";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRegisterKey {
        CMsgClientRegisterKey::new()
    }

    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRegisterKey {
        static instance: CMsgClientRegisterKey = CMsgClientRegisterKey {
            key: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientRegisterKey {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRegisterKey").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRegisterKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRegisterKey {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientPurchaseResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientPurchaseResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientPurchaseResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientPurchaseResponse.purchase_result_details)
    pub purchase_result_details: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientPurchaseResponse.purchase_receipt_info)
    pub purchase_receipt_info: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientPurchaseResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientPurchaseResponse {
    fn default() -> &'a CMsgClientPurchaseResponse {
        <CMsgClientPurchaseResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPurchaseResponse {
    pub fn new() -> CMsgClientPurchaseResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional int32 purchase_result_details = 2;

    pub fn purchase_result_details(&self) -> i32 {
        self.purchase_result_details.unwrap_or(0)
    }

    pub fn clear_purchase_result_details(&mut self) {
        self.purchase_result_details = ::std::option::Option::None;
    }

    pub fn has_purchase_result_details(&self) -> bool {
        self.purchase_result_details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_purchase_result_details(&mut self, v: i32) {
        self.purchase_result_details = ::std::option::Option::Some(v);
    }

    // optional bytes purchase_receipt_info = 3;

    pub fn purchase_receipt_info(&self) -> &[u8] {
        match self.purchase_receipt_info.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_purchase_receipt_info(&mut self) {
        self.purchase_receipt_info = ::std::option::Option::None;
    }

    pub fn has_purchase_receipt_info(&self) -> bool {
        self.purchase_receipt_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_purchase_receipt_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.purchase_receipt_info = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_purchase_receipt_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.purchase_receipt_info.is_none() {
            self.purchase_receipt_info = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.purchase_receipt_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_purchase_receipt_info(&mut self) -> ::std::vec::Vec<u8> {
        self.purchase_receipt_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientPurchaseResponse| { &m.eresult },
            |m: &mut CMsgClientPurchaseResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "purchase_result_details",
            |m: &CMsgClientPurchaseResponse| { &m.purchase_result_details },
            |m: &mut CMsgClientPurchaseResponse| { &mut m.purchase_result_details },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "purchase_receipt_info",
            |m: &CMsgClientPurchaseResponse| { &m.purchase_receipt_info },
            |m: &mut CMsgClientPurchaseResponse| { &mut m.purchase_receipt_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientPurchaseResponse>(
            "CMsgClientPurchaseResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientPurchaseResponse {
    const NAME: &'static str = "CMsgClientPurchaseResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.purchase_result_details = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.purchase_receipt_info = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.purchase_result_details {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.purchase_receipt_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.purchase_result_details {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.purchase_receipt_info.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientPurchaseResponse {
        CMsgClientPurchaseResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.purchase_result_details = ::std::option::Option::None;
        self.purchase_receipt_info = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientPurchaseResponse {
        static instance: CMsgClientPurchaseResponse = CMsgClientPurchaseResponse {
            eresult: ::std::option::Option::None,
            purchase_result_details: ::std::option::Option::None,
            purchase_receipt_info: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientPurchaseResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientPurchaseResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientPurchaseResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPurchaseResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientActivateOEMLicense)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientActivateOEMLicense {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientActivateOEMLicense.bios_manufacturer)
    pub bios_manufacturer: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientActivateOEMLicense.bios_serialnumber)
    pub bios_serialnumber: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientActivateOEMLicense.license_file)
    pub license_file: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientActivateOEMLicense.mainboard_manufacturer)
    pub mainboard_manufacturer: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientActivateOEMLicense.mainboard_product)
    pub mainboard_product: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientActivateOEMLicense.mainboard_serialnumber)
    pub mainboard_serialnumber: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientActivateOEMLicense.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientActivateOEMLicense {
    fn default() -> &'a CMsgClientActivateOEMLicense {
        <CMsgClientActivateOEMLicense as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientActivateOEMLicense {
    pub fn new() -> CMsgClientActivateOEMLicense {
        ::std::default::Default::default()
    }

    // optional string bios_manufacturer = 1;

    pub fn bios_manufacturer(&self) -> &str {
        match self.bios_manufacturer.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_bios_manufacturer(&mut self) {
        self.bios_manufacturer = ::std::option::Option::None;
    }

    pub fn has_bios_manufacturer(&self) -> bool {
        self.bios_manufacturer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bios_manufacturer(&mut self, v: ::std::string::String) {
        self.bios_manufacturer = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bios_manufacturer(&mut self) -> &mut ::std::string::String {
        if self.bios_manufacturer.is_none() {
            self.bios_manufacturer = ::std::option::Option::Some(::std::string::String::new());
        }
        self.bios_manufacturer.as_mut().unwrap()
    }

    // Take field
    pub fn take_bios_manufacturer(&mut self) -> ::std::string::String {
        self.bios_manufacturer.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string bios_serialnumber = 2;

    pub fn bios_serialnumber(&self) -> &str {
        match self.bios_serialnumber.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_bios_serialnumber(&mut self) {
        self.bios_serialnumber = ::std::option::Option::None;
    }

    pub fn has_bios_serialnumber(&self) -> bool {
        self.bios_serialnumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bios_serialnumber(&mut self, v: ::std::string::String) {
        self.bios_serialnumber = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bios_serialnumber(&mut self) -> &mut ::std::string::String {
        if self.bios_serialnumber.is_none() {
            self.bios_serialnumber = ::std::option::Option::Some(::std::string::String::new());
        }
        self.bios_serialnumber.as_mut().unwrap()
    }

    // Take field
    pub fn take_bios_serialnumber(&mut self) -> ::std::string::String {
        self.bios_serialnumber.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes license_file = 3;

    pub fn license_file(&self) -> &[u8] {
        match self.license_file.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_license_file(&mut self) {
        self.license_file = ::std::option::Option::None;
    }

    pub fn has_license_file(&self) -> bool {
        self.license_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_license_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.license_file = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_license_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.license_file.is_none() {
            self.license_file = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.license_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_license_file(&mut self) -> ::std::vec::Vec<u8> {
        self.license_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string mainboard_manufacturer = 4;

    pub fn mainboard_manufacturer(&self) -> &str {
        match self.mainboard_manufacturer.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mainboard_manufacturer(&mut self) {
        self.mainboard_manufacturer = ::std::option::Option::None;
    }

    pub fn has_mainboard_manufacturer(&self) -> bool {
        self.mainboard_manufacturer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mainboard_manufacturer(&mut self, v: ::std::string::String) {
        self.mainboard_manufacturer = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mainboard_manufacturer(&mut self) -> &mut ::std::string::String {
        if self.mainboard_manufacturer.is_none() {
            self.mainboard_manufacturer = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mainboard_manufacturer.as_mut().unwrap()
    }

    // Take field
    pub fn take_mainboard_manufacturer(&mut self) -> ::std::string::String {
        self.mainboard_manufacturer.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string mainboard_product = 5;

    pub fn mainboard_product(&self) -> &str {
        match self.mainboard_product.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mainboard_product(&mut self) {
        self.mainboard_product = ::std::option::Option::None;
    }

    pub fn has_mainboard_product(&self) -> bool {
        self.mainboard_product.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mainboard_product(&mut self, v: ::std::string::String) {
        self.mainboard_product = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mainboard_product(&mut self) -> &mut ::std::string::String {
        if self.mainboard_product.is_none() {
            self.mainboard_product = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mainboard_product.as_mut().unwrap()
    }

    // Take field
    pub fn take_mainboard_product(&mut self) -> ::std::string::String {
        self.mainboard_product.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string mainboard_serialnumber = 6;

    pub fn mainboard_serialnumber(&self) -> &str {
        match self.mainboard_serialnumber.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mainboard_serialnumber(&mut self) {
        self.mainboard_serialnumber = ::std::option::Option::None;
    }

    pub fn has_mainboard_serialnumber(&self) -> bool {
        self.mainboard_serialnumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mainboard_serialnumber(&mut self, v: ::std::string::String) {
        self.mainboard_serialnumber = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mainboard_serialnumber(&mut self) -> &mut ::std::string::String {
        if self.mainboard_serialnumber.is_none() {
            self.mainboard_serialnumber = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mainboard_serialnumber.as_mut().unwrap()
    }

    // Take field
    pub fn take_mainboard_serialnumber(&mut self) -> ::std::string::String {
        self.mainboard_serialnumber.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bios_manufacturer",
            |m: &CMsgClientActivateOEMLicense| { &m.bios_manufacturer },
            |m: &mut CMsgClientActivateOEMLicense| { &mut m.bios_manufacturer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bios_serialnumber",
            |m: &CMsgClientActivateOEMLicense| { &m.bios_serialnumber },
            |m: &mut CMsgClientActivateOEMLicense| { &mut m.bios_serialnumber },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "license_file",
            |m: &CMsgClientActivateOEMLicense| { &m.license_file },
            |m: &mut CMsgClientActivateOEMLicense| { &mut m.license_file },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mainboard_manufacturer",
            |m: &CMsgClientActivateOEMLicense| { &m.mainboard_manufacturer },
            |m: &mut CMsgClientActivateOEMLicense| { &mut m.mainboard_manufacturer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mainboard_product",
            |m: &CMsgClientActivateOEMLicense| { &m.mainboard_product },
            |m: &mut CMsgClientActivateOEMLicense| { &mut m.mainboard_product },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mainboard_serialnumber",
            |m: &CMsgClientActivateOEMLicense| { &m.mainboard_serialnumber },
            |m: &mut CMsgClientActivateOEMLicense| { &mut m.mainboard_serialnumber },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientActivateOEMLicense>(
            "CMsgClientActivateOEMLicense",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientActivateOEMLicense {
    const NAME: &'static str = "CMsgClientActivateOEMLicense";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.bios_manufacturer = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.bios_serialnumber = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.license_file = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    self.mainboard_manufacturer = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.mainboard_product = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.mainboard_serialnumber = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.bios_manufacturer.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.bios_serialnumber.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.license_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.mainboard_manufacturer.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.mainboard_product.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.mainboard_serialnumber.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.bios_manufacturer.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.bios_serialnumber.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.license_file.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.mainboard_manufacturer.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.mainboard_product.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.mainboard_serialnumber.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientActivateOEMLicense {
        CMsgClientActivateOEMLicense::new()
    }

    fn clear(&mut self) {
        self.bios_manufacturer = ::std::option::Option::None;
        self.bios_serialnumber = ::std::option::Option::None;
        self.license_file = ::std::option::Option::None;
        self.mainboard_manufacturer = ::std::option::Option::None;
        self.mainboard_product = ::std::option::Option::None;
        self.mainboard_serialnumber = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientActivateOEMLicense {
        static instance: CMsgClientActivateOEMLicense = CMsgClientActivateOEMLicense {
            bios_manufacturer: ::std::option::Option::None,
            bios_serialnumber: ::std::option::Option::None,
            license_file: ::std::option::Option::None,
            mainboard_manufacturer: ::std::option::Option::None,
            mainboard_product: ::std::option::Option::None,
            mainboard_serialnumber: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientActivateOEMLicense {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientActivateOEMLicense").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientActivateOEMLicense {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientActivateOEMLicense {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRegisterOEMMachine)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRegisterOEMMachine {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRegisterOEMMachine.oem_register_file)
    pub oem_register_file: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRegisterOEMMachine.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRegisterOEMMachine {
    fn default() -> &'a CMsgClientRegisterOEMMachine {
        <CMsgClientRegisterOEMMachine as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRegisterOEMMachine {
    pub fn new() -> CMsgClientRegisterOEMMachine {
        ::std::default::Default::default()
    }

    // optional bytes oem_register_file = 1;

    pub fn oem_register_file(&self) -> &[u8] {
        match self.oem_register_file.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_oem_register_file(&mut self) {
        self.oem_register_file = ::std::option::Option::None;
    }

    pub fn has_oem_register_file(&self) -> bool {
        self.oem_register_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_oem_register_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.oem_register_file = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oem_register_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.oem_register_file.is_none() {
            self.oem_register_file = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.oem_register_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_oem_register_file(&mut self) -> ::std::vec::Vec<u8> {
        self.oem_register_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "oem_register_file",
            |m: &CMsgClientRegisterOEMMachine| { &m.oem_register_file },
            |m: &mut CMsgClientRegisterOEMMachine| { &mut m.oem_register_file },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRegisterOEMMachine>(
            "CMsgClientRegisterOEMMachine",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientRegisterOEMMachine {
    const NAME: &'static str = "CMsgClientRegisterOEMMachine";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.oem_register_file = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.oem_register_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.oem_register_file.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRegisterOEMMachine {
        CMsgClientRegisterOEMMachine::new()
    }

    fn clear(&mut self) {
        self.oem_register_file = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRegisterOEMMachine {
        static instance: CMsgClientRegisterOEMMachine = CMsgClientRegisterOEMMachine {
            oem_register_file: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientRegisterOEMMachine {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRegisterOEMMachine").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRegisterOEMMachine {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRegisterOEMMachine {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRegisterOEMMachineResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRegisterOEMMachineResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRegisterOEMMachineResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRegisterOEMMachineResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRegisterOEMMachineResponse {
    fn default() -> &'a CMsgClientRegisterOEMMachineResponse {
        <CMsgClientRegisterOEMMachineResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRegisterOEMMachineResponse {
    pub fn new() -> CMsgClientRegisterOEMMachineResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientRegisterOEMMachineResponse| { &m.eresult },
            |m: &mut CMsgClientRegisterOEMMachineResponse| { &mut m.eresult },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRegisterOEMMachineResponse>(
            "CMsgClientRegisterOEMMachineResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientRegisterOEMMachineResponse {
    const NAME: &'static str = "CMsgClientRegisterOEMMachineResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRegisterOEMMachineResponse {
        CMsgClientRegisterOEMMachineResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRegisterOEMMachineResponse {
        static instance: CMsgClientRegisterOEMMachineResponse = CMsgClientRegisterOEMMachineResponse {
            eresult: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientRegisterOEMMachineResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRegisterOEMMachineResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRegisterOEMMachineResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRegisterOEMMachineResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientPurchaseWithMachineID)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientPurchaseWithMachineID {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientPurchaseWithMachineID.package_id)
    pub package_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientPurchaseWithMachineID.machine_info)
    pub machine_info: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientPurchaseWithMachineID.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientPurchaseWithMachineID {
    fn default() -> &'a CMsgClientPurchaseWithMachineID {
        <CMsgClientPurchaseWithMachineID as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPurchaseWithMachineID {
    pub fn new() -> CMsgClientPurchaseWithMachineID {
        ::std::default::Default::default()
    }

    // optional uint32 package_id = 1;

    pub fn package_id(&self) -> u32 {
        self.package_id.unwrap_or(0)
    }

    pub fn clear_package_id(&mut self) {
        self.package_id = ::std::option::Option::None;
    }

    pub fn has_package_id(&self) -> bool {
        self.package_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_package_id(&mut self, v: u32) {
        self.package_id = ::std::option::Option::Some(v);
    }

    // optional bytes machine_info = 2;

    pub fn machine_info(&self) -> &[u8] {
        match self.machine_info.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_machine_info(&mut self) {
        self.machine_info = ::std::option::Option::None;
    }

    pub fn has_machine_info(&self) -> bool {
        self.machine_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machine_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.machine_info = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machine_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.machine_info.is_none() {
            self.machine_info = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.machine_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_machine_info(&mut self) -> ::std::vec::Vec<u8> {
        self.machine_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "package_id",
            |m: &CMsgClientPurchaseWithMachineID| { &m.package_id },
            |m: &mut CMsgClientPurchaseWithMachineID| { &mut m.package_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "machine_info",
            |m: &CMsgClientPurchaseWithMachineID| { &m.machine_info },
            |m: &mut CMsgClientPurchaseWithMachineID| { &mut m.machine_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientPurchaseWithMachineID>(
            "CMsgClientPurchaseWithMachineID",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientPurchaseWithMachineID {
    const NAME: &'static str = "CMsgClientPurchaseWithMachineID";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.package_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.machine_info = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.package_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.machine_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.package_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.machine_info.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientPurchaseWithMachineID {
        CMsgClientPurchaseWithMachineID::new()
    }

    fn clear(&mut self) {
        self.package_id = ::std::option::Option::None;
        self.machine_info = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientPurchaseWithMachineID {
        static instance: CMsgClientPurchaseWithMachineID = CMsgClientPurchaseWithMachineID {
            package_id: ::std::option::Option::None,
            machine_info: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientPurchaseWithMachineID {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientPurchaseWithMachineID").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientPurchaseWithMachineID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPurchaseWithMachineID {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTrading_InitiateTradeRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTrading_InitiateTradeRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgTrading_InitiateTradeRequest.trade_request_id)
    pub trade_request_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTrading_InitiateTradeRequest.other_steamid)
    pub other_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgTrading_InitiateTradeRequest.other_name)
    pub other_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTrading_InitiateTradeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTrading_InitiateTradeRequest {
    fn default() -> &'a CMsgTrading_InitiateTradeRequest {
        <CMsgTrading_InitiateTradeRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTrading_InitiateTradeRequest {
    pub fn new() -> CMsgTrading_InitiateTradeRequest {
        ::std::default::Default::default()
    }

    // optional uint32 trade_request_id = 1;

    pub fn trade_request_id(&self) -> u32 {
        self.trade_request_id.unwrap_or(0)
    }

    pub fn clear_trade_request_id(&mut self) {
        self.trade_request_id = ::std::option::Option::None;
    }

    pub fn has_trade_request_id(&self) -> bool {
        self.trade_request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trade_request_id(&mut self, v: u32) {
        self.trade_request_id = ::std::option::Option::Some(v);
    }

    // optional uint64 other_steamid = 2;

    pub fn other_steamid(&self) -> u64 {
        self.other_steamid.unwrap_or(0)
    }

    pub fn clear_other_steamid(&mut self) {
        self.other_steamid = ::std::option::Option::None;
    }

    pub fn has_other_steamid(&self) -> bool {
        self.other_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_steamid(&mut self, v: u64) {
        self.other_steamid = ::std::option::Option::Some(v);
    }

    // optional string other_name = 3;

    pub fn other_name(&self) -> &str {
        match self.other_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_other_name(&mut self) {
        self.other_name = ::std::option::Option::None;
    }

    pub fn has_other_name(&self) -> bool {
        self.other_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_name(&mut self, v: ::std::string::String) {
        self.other_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_other_name(&mut self) -> &mut ::std::string::String {
        if self.other_name.is_none() {
            self.other_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.other_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_other_name(&mut self) -> ::std::string::String {
        self.other_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "trade_request_id",
            |m: &CMsgTrading_InitiateTradeRequest| { &m.trade_request_id },
            |m: &mut CMsgTrading_InitiateTradeRequest| { &mut m.trade_request_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "other_steamid",
            |m: &CMsgTrading_InitiateTradeRequest| { &m.other_steamid },
            |m: &mut CMsgTrading_InitiateTradeRequest| { &mut m.other_steamid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "other_name",
            |m: &CMsgTrading_InitiateTradeRequest| { &m.other_name },
            |m: &mut CMsgTrading_InitiateTradeRequest| { &mut m.other_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTrading_InitiateTradeRequest>(
            "CMsgTrading_InitiateTradeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTrading_InitiateTradeRequest {
    const NAME: &'static str = "CMsgTrading_InitiateTradeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.trade_request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.other_steamid = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.other_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.trade_request_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.other_steamid {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.other_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.trade_request_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.other_steamid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.other_name.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTrading_InitiateTradeRequest {
        CMsgTrading_InitiateTradeRequest::new()
    }

    fn clear(&mut self) {
        self.trade_request_id = ::std::option::Option::None;
        self.other_steamid = ::std::option::Option::None;
        self.other_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTrading_InitiateTradeRequest {
        static instance: CMsgTrading_InitiateTradeRequest = CMsgTrading_InitiateTradeRequest {
            trade_request_id: ::std::option::Option::None,
            other_steamid: ::std::option::Option::None,
            other_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTrading_InitiateTradeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTrading_InitiateTradeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTrading_InitiateTradeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTrading_InitiateTradeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTrading_InitiateTradeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTrading_InitiateTradeResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgTrading_InitiateTradeResponse.response)
    pub response: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTrading_InitiateTradeResponse.trade_request_id)
    pub trade_request_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTrading_InitiateTradeResponse.other_steamid)
    pub other_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgTrading_InitiateTradeResponse.steamguard_required_days)
    pub steamguard_required_days: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTrading_InitiateTradeResponse.new_device_cooldown_days)
    pub new_device_cooldown_days: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTrading_InitiateTradeResponse.default_password_reset_probation_days)
    pub default_password_reset_probation_days: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTrading_InitiateTradeResponse.password_reset_probation_days)
    pub password_reset_probation_days: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTrading_InitiateTradeResponse.default_email_change_probation_days)
    pub default_email_change_probation_days: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTrading_InitiateTradeResponse.email_change_probation_days)
    pub email_change_probation_days: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTrading_InitiateTradeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTrading_InitiateTradeResponse {
    fn default() -> &'a CMsgTrading_InitiateTradeResponse {
        <CMsgTrading_InitiateTradeResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTrading_InitiateTradeResponse {
    pub fn new() -> CMsgTrading_InitiateTradeResponse {
        ::std::default::Default::default()
    }

    // optional uint32 response = 1;

    pub fn response(&self) -> u32 {
        self.response.unwrap_or(0)
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: u32) {
        self.response = ::std::option::Option::Some(v);
    }

    // optional uint32 trade_request_id = 2;

    pub fn trade_request_id(&self) -> u32 {
        self.trade_request_id.unwrap_or(0)
    }

    pub fn clear_trade_request_id(&mut self) {
        self.trade_request_id = ::std::option::Option::None;
    }

    pub fn has_trade_request_id(&self) -> bool {
        self.trade_request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trade_request_id(&mut self, v: u32) {
        self.trade_request_id = ::std::option::Option::Some(v);
    }

    // optional uint64 other_steamid = 3;

    pub fn other_steamid(&self) -> u64 {
        self.other_steamid.unwrap_or(0)
    }

    pub fn clear_other_steamid(&mut self) {
        self.other_steamid = ::std::option::Option::None;
    }

    pub fn has_other_steamid(&self) -> bool {
        self.other_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_steamid(&mut self, v: u64) {
        self.other_steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 steamguard_required_days = 4;

    pub fn steamguard_required_days(&self) -> u32 {
        self.steamguard_required_days.unwrap_or(0)
    }

    pub fn clear_steamguard_required_days(&mut self) {
        self.steamguard_required_days = ::std::option::Option::None;
    }

    pub fn has_steamguard_required_days(&self) -> bool {
        self.steamguard_required_days.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamguard_required_days(&mut self, v: u32) {
        self.steamguard_required_days = ::std::option::Option::Some(v);
    }

    // optional uint32 new_device_cooldown_days = 5;

    pub fn new_device_cooldown_days(&self) -> u32 {
        self.new_device_cooldown_days.unwrap_or(0)
    }

    pub fn clear_new_device_cooldown_days(&mut self) {
        self.new_device_cooldown_days = ::std::option::Option::None;
    }

    pub fn has_new_device_cooldown_days(&self) -> bool {
        self.new_device_cooldown_days.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_device_cooldown_days(&mut self, v: u32) {
        self.new_device_cooldown_days = ::std::option::Option::Some(v);
    }

    // optional uint32 default_password_reset_probation_days = 6;

    pub fn default_password_reset_probation_days(&self) -> u32 {
        self.default_password_reset_probation_days.unwrap_or(0)
    }

    pub fn clear_default_password_reset_probation_days(&mut self) {
        self.default_password_reset_probation_days = ::std::option::Option::None;
    }

    pub fn has_default_password_reset_probation_days(&self) -> bool {
        self.default_password_reset_probation_days.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_password_reset_probation_days(&mut self, v: u32) {
        self.default_password_reset_probation_days = ::std::option::Option::Some(v);
    }

    // optional uint32 password_reset_probation_days = 7;

    pub fn password_reset_probation_days(&self) -> u32 {
        self.password_reset_probation_days.unwrap_or(0)
    }

    pub fn clear_password_reset_probation_days(&mut self) {
        self.password_reset_probation_days = ::std::option::Option::None;
    }

    pub fn has_password_reset_probation_days(&self) -> bool {
        self.password_reset_probation_days.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password_reset_probation_days(&mut self, v: u32) {
        self.password_reset_probation_days = ::std::option::Option::Some(v);
    }

    // optional uint32 default_email_change_probation_days = 8;

    pub fn default_email_change_probation_days(&self) -> u32 {
        self.default_email_change_probation_days.unwrap_or(0)
    }

    pub fn clear_default_email_change_probation_days(&mut self) {
        self.default_email_change_probation_days = ::std::option::Option::None;
    }

    pub fn has_default_email_change_probation_days(&self) -> bool {
        self.default_email_change_probation_days.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_email_change_probation_days(&mut self, v: u32) {
        self.default_email_change_probation_days = ::std::option::Option::Some(v);
    }

    // optional uint32 email_change_probation_days = 9;

    pub fn email_change_probation_days(&self) -> u32 {
        self.email_change_probation_days.unwrap_or(0)
    }

    pub fn clear_email_change_probation_days(&mut self) {
        self.email_change_probation_days = ::std::option::Option::None;
    }

    pub fn has_email_change_probation_days(&self) -> bool {
        self.email_change_probation_days.is_some()
    }

    // Param is passed by value, moved
    pub fn set_email_change_probation_days(&mut self, v: u32) {
        self.email_change_probation_days = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response",
            |m: &CMsgTrading_InitiateTradeResponse| { &m.response },
            |m: &mut CMsgTrading_InitiateTradeResponse| { &mut m.response },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "trade_request_id",
            |m: &CMsgTrading_InitiateTradeResponse| { &m.trade_request_id },
            |m: &mut CMsgTrading_InitiateTradeResponse| { &mut m.trade_request_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "other_steamid",
            |m: &CMsgTrading_InitiateTradeResponse| { &m.other_steamid },
            |m: &mut CMsgTrading_InitiateTradeResponse| { &mut m.other_steamid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamguard_required_days",
            |m: &CMsgTrading_InitiateTradeResponse| { &m.steamguard_required_days },
            |m: &mut CMsgTrading_InitiateTradeResponse| { &mut m.steamguard_required_days },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "new_device_cooldown_days",
            |m: &CMsgTrading_InitiateTradeResponse| { &m.new_device_cooldown_days },
            |m: &mut CMsgTrading_InitiateTradeResponse| { &mut m.new_device_cooldown_days },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "default_password_reset_probation_days",
            |m: &CMsgTrading_InitiateTradeResponse| { &m.default_password_reset_probation_days },
            |m: &mut CMsgTrading_InitiateTradeResponse| { &mut m.default_password_reset_probation_days },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "password_reset_probation_days",
            |m: &CMsgTrading_InitiateTradeResponse| { &m.password_reset_probation_days },
            |m: &mut CMsgTrading_InitiateTradeResponse| { &mut m.password_reset_probation_days },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "default_email_change_probation_days",
            |m: &CMsgTrading_InitiateTradeResponse| { &m.default_email_change_probation_days },
            |m: &mut CMsgTrading_InitiateTradeResponse| { &mut m.default_email_change_probation_days },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "email_change_probation_days",
            |m: &CMsgTrading_InitiateTradeResponse| { &m.email_change_probation_days },
            |m: &mut CMsgTrading_InitiateTradeResponse| { &mut m.email_change_probation_days },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTrading_InitiateTradeResponse>(
            "CMsgTrading_InitiateTradeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTrading_InitiateTradeResponse {
    const NAME: &'static str = "CMsgTrading_InitiateTradeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.trade_request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.other_steamid = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.steamguard_required_days = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.new_device_cooldown_days = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.default_password_reset_probation_days = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.password_reset_probation_days = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.default_email_change_probation_days = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.email_change_probation_days = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.trade_request_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.other_steamid {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.steamguard_required_days {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.new_device_cooldown_days {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.default_password_reset_probation_days {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.password_reset_probation_days {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.default_email_change_probation_days {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.email_change_probation_days {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.trade_request_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.other_steamid {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.steamguard_required_days {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.new_device_cooldown_days {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.default_password_reset_probation_days {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.password_reset_probation_days {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.default_email_change_probation_days {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.email_change_probation_days {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTrading_InitiateTradeResponse {
        CMsgTrading_InitiateTradeResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.trade_request_id = ::std::option::Option::None;
        self.other_steamid = ::std::option::Option::None;
        self.steamguard_required_days = ::std::option::Option::None;
        self.new_device_cooldown_days = ::std::option::Option::None;
        self.default_password_reset_probation_days = ::std::option::Option::None;
        self.password_reset_probation_days = ::std::option::Option::None;
        self.default_email_change_probation_days = ::std::option::Option::None;
        self.email_change_probation_days = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTrading_InitiateTradeResponse {
        static instance: CMsgTrading_InitiateTradeResponse = CMsgTrading_InitiateTradeResponse {
            response: ::std::option::Option::None,
            trade_request_id: ::std::option::Option::None,
            other_steamid: ::std::option::Option::None,
            steamguard_required_days: ::std::option::Option::None,
            new_device_cooldown_days: ::std::option::Option::None,
            default_password_reset_probation_days: ::std::option::Option::None,
            password_reset_probation_days: ::std::option::Option::None,
            default_email_change_probation_days: ::std::option::Option::None,
            email_change_probation_days: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTrading_InitiateTradeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTrading_InitiateTradeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTrading_InitiateTradeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTrading_InitiateTradeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTrading_CancelTradeRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTrading_CancelTradeRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgTrading_CancelTradeRequest.other_steamid)
    pub other_steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTrading_CancelTradeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTrading_CancelTradeRequest {
    fn default() -> &'a CMsgTrading_CancelTradeRequest {
        <CMsgTrading_CancelTradeRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTrading_CancelTradeRequest {
    pub fn new() -> CMsgTrading_CancelTradeRequest {
        ::std::default::Default::default()
    }

    // optional uint64 other_steamid = 1;

    pub fn other_steamid(&self) -> u64 {
        self.other_steamid.unwrap_or(0)
    }

    pub fn clear_other_steamid(&mut self) {
        self.other_steamid = ::std::option::Option::None;
    }

    pub fn has_other_steamid(&self) -> bool {
        self.other_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_steamid(&mut self, v: u64) {
        self.other_steamid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "other_steamid",
            |m: &CMsgTrading_CancelTradeRequest| { &m.other_steamid },
            |m: &mut CMsgTrading_CancelTradeRequest| { &mut m.other_steamid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTrading_CancelTradeRequest>(
            "CMsgTrading_CancelTradeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTrading_CancelTradeRequest {
    const NAME: &'static str = "CMsgTrading_CancelTradeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.other_steamid = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.other_steamid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.other_steamid {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTrading_CancelTradeRequest {
        CMsgTrading_CancelTradeRequest::new()
    }

    fn clear(&mut self) {
        self.other_steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTrading_CancelTradeRequest {
        static instance: CMsgTrading_CancelTradeRequest = CMsgTrading_CancelTradeRequest {
            other_steamid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTrading_CancelTradeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTrading_CancelTradeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTrading_CancelTradeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTrading_CancelTradeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTrading_StartSession)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTrading_StartSession {
    // message fields
    // @@protoc_insertion_point(field:CMsgTrading_StartSession.other_steamid)
    pub other_steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTrading_StartSession.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTrading_StartSession {
    fn default() -> &'a CMsgTrading_StartSession {
        <CMsgTrading_StartSession as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTrading_StartSession {
    pub fn new() -> CMsgTrading_StartSession {
        ::std::default::Default::default()
    }

    // optional uint64 other_steamid = 1;

    pub fn other_steamid(&self) -> u64 {
        self.other_steamid.unwrap_or(0)
    }

    pub fn clear_other_steamid(&mut self) {
        self.other_steamid = ::std::option::Option::None;
    }

    pub fn has_other_steamid(&self) -> bool {
        self.other_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_steamid(&mut self, v: u64) {
        self.other_steamid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "other_steamid",
            |m: &CMsgTrading_StartSession| { &m.other_steamid },
            |m: &mut CMsgTrading_StartSession| { &mut m.other_steamid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTrading_StartSession>(
            "CMsgTrading_StartSession",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTrading_StartSession {
    const NAME: &'static str = "CMsgTrading_StartSession";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.other_steamid = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.other_steamid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.other_steamid {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTrading_StartSession {
        CMsgTrading_StartSession::new()
    }

    fn clear(&mut self) {
        self.other_steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTrading_StartSession {
        static instance: CMsgTrading_StartSession = CMsgTrading_StartSession {
            other_steamid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTrading_StartSession {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTrading_StartSession").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTrading_StartSession {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTrading_StartSession {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientGetCDNAuthToken)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetCDNAuthToken {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetCDNAuthToken.depot_id)
    pub depot_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGetCDNAuthToken.host_name)
    pub host_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientGetCDNAuthToken.app_id)
    pub app_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetCDNAuthToken.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetCDNAuthToken {
    fn default() -> &'a CMsgClientGetCDNAuthToken {
        <CMsgClientGetCDNAuthToken as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetCDNAuthToken {
    pub fn new() -> CMsgClientGetCDNAuthToken {
        ::std::default::Default::default()
    }

    // optional uint32 depot_id = 1;

    pub fn depot_id(&self) -> u32 {
        self.depot_id.unwrap_or(0)
    }

    pub fn clear_depot_id(&mut self) {
        self.depot_id = ::std::option::Option::None;
    }

    pub fn has_depot_id(&self) -> bool {
        self.depot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_depot_id(&mut self, v: u32) {
        self.depot_id = ::std::option::Option::Some(v);
    }

    // optional string host_name = 2;

    pub fn host_name(&self) -> &str {
        match self.host_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_host_name(&mut self) {
        self.host_name = ::std::option::Option::None;
    }

    pub fn has_host_name(&self) -> bool {
        self.host_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_name(&mut self, v: ::std::string::String) {
        self.host_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host_name(&mut self) -> &mut ::std::string::String {
        if self.host_name.is_none() {
            self.host_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.host_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_host_name(&mut self) -> ::std::string::String {
        self.host_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 app_id = 3;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "depot_id",
            |m: &CMsgClientGetCDNAuthToken| { &m.depot_id },
            |m: &mut CMsgClientGetCDNAuthToken| { &mut m.depot_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "host_name",
            |m: &CMsgClientGetCDNAuthToken| { &m.host_name },
            |m: &mut CMsgClientGetCDNAuthToken| { &mut m.host_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientGetCDNAuthToken| { &m.app_id },
            |m: &mut CMsgClientGetCDNAuthToken| { &mut m.app_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientGetCDNAuthToken>(
            "CMsgClientGetCDNAuthToken",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientGetCDNAuthToken {
    const NAME: &'static str = "CMsgClientGetCDNAuthToken";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.depot_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.host_name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.depot_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.host_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.depot_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.host_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetCDNAuthToken {
        CMsgClientGetCDNAuthToken::new()
    }

    fn clear(&mut self) {
        self.depot_id = ::std::option::Option::None;
        self.host_name = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetCDNAuthToken {
        static instance: CMsgClientGetCDNAuthToken = CMsgClientGetCDNAuthToken {
            depot_id: ::std::option::Option::None,
            host_name: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientGetCDNAuthToken {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientGetCDNAuthToken").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientGetCDNAuthToken {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetCDNAuthToken {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientGetDepotDecryptionKey)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetDepotDecryptionKey {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetDepotDecryptionKey.depot_id)
    pub depot_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGetDepotDecryptionKey.app_id)
    pub app_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetDepotDecryptionKey.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetDepotDecryptionKey {
    fn default() -> &'a CMsgClientGetDepotDecryptionKey {
        <CMsgClientGetDepotDecryptionKey as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetDepotDecryptionKey {
    pub fn new() -> CMsgClientGetDepotDecryptionKey {
        ::std::default::Default::default()
    }

    // optional uint32 depot_id = 1;

    pub fn depot_id(&self) -> u32 {
        self.depot_id.unwrap_or(0)
    }

    pub fn clear_depot_id(&mut self) {
        self.depot_id = ::std::option::Option::None;
    }

    pub fn has_depot_id(&self) -> bool {
        self.depot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_depot_id(&mut self, v: u32) {
        self.depot_id = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "depot_id",
            |m: &CMsgClientGetDepotDecryptionKey| { &m.depot_id },
            |m: &mut CMsgClientGetDepotDecryptionKey| { &mut m.depot_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientGetDepotDecryptionKey| { &m.app_id },
            |m: &mut CMsgClientGetDepotDecryptionKey| { &mut m.app_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientGetDepotDecryptionKey>(
            "CMsgClientGetDepotDecryptionKey",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientGetDepotDecryptionKey {
    const NAME: &'static str = "CMsgClientGetDepotDecryptionKey";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.depot_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.depot_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.depot_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetDepotDecryptionKey {
        CMsgClientGetDepotDecryptionKey::new()
    }

    fn clear(&mut self) {
        self.depot_id = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetDepotDecryptionKey {
        static instance: CMsgClientGetDepotDecryptionKey = CMsgClientGetDepotDecryptionKey {
            depot_id: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientGetDepotDecryptionKey {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientGetDepotDecryptionKey").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientGetDepotDecryptionKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetDepotDecryptionKey {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientGetDepotDecryptionKeyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetDepotDecryptionKeyResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetDepotDecryptionKeyResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientGetDepotDecryptionKeyResponse.depot_id)
    pub depot_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGetDepotDecryptionKeyResponse.depot_encryption_key)
    pub depot_encryption_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetDepotDecryptionKeyResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetDepotDecryptionKeyResponse {
    fn default() -> &'a CMsgClientGetDepotDecryptionKeyResponse {
        <CMsgClientGetDepotDecryptionKeyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetDepotDecryptionKeyResponse {
    pub fn new() -> CMsgClientGetDepotDecryptionKeyResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 depot_id = 2;

    pub fn depot_id(&self) -> u32 {
        self.depot_id.unwrap_or(0)
    }

    pub fn clear_depot_id(&mut self) {
        self.depot_id = ::std::option::Option::None;
    }

    pub fn has_depot_id(&self) -> bool {
        self.depot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_depot_id(&mut self, v: u32) {
        self.depot_id = ::std::option::Option::Some(v);
    }

    // optional bytes depot_encryption_key = 3;

    pub fn depot_encryption_key(&self) -> &[u8] {
        match self.depot_encryption_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_depot_encryption_key(&mut self) {
        self.depot_encryption_key = ::std::option::Option::None;
    }

    pub fn has_depot_encryption_key(&self) -> bool {
        self.depot_encryption_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_depot_encryption_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.depot_encryption_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_depot_encryption_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.depot_encryption_key.is_none() {
            self.depot_encryption_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.depot_encryption_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_depot_encryption_key(&mut self) -> ::std::vec::Vec<u8> {
        self.depot_encryption_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientGetDepotDecryptionKeyResponse| { &m.eresult },
            |m: &mut CMsgClientGetDepotDecryptionKeyResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "depot_id",
            |m: &CMsgClientGetDepotDecryptionKeyResponse| { &m.depot_id },
            |m: &mut CMsgClientGetDepotDecryptionKeyResponse| { &mut m.depot_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "depot_encryption_key",
            |m: &CMsgClientGetDepotDecryptionKeyResponse| { &m.depot_encryption_key },
            |m: &mut CMsgClientGetDepotDecryptionKeyResponse| { &mut m.depot_encryption_key },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientGetDepotDecryptionKeyResponse>(
            "CMsgClientGetDepotDecryptionKeyResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientGetDepotDecryptionKeyResponse {
    const NAME: &'static str = "CMsgClientGetDepotDecryptionKeyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.depot_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.depot_encryption_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.depot_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.depot_encryption_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.depot_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.depot_encryption_key.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetDepotDecryptionKeyResponse {
        CMsgClientGetDepotDecryptionKeyResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.depot_id = ::std::option::Option::None;
        self.depot_encryption_key = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetDepotDecryptionKeyResponse {
        static instance: CMsgClientGetDepotDecryptionKeyResponse = CMsgClientGetDepotDecryptionKeyResponse {
            eresult: ::std::option::Option::None,
            depot_id: ::std::option::Option::None,
            depot_encryption_key: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientGetDepotDecryptionKeyResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientGetDepotDecryptionKeyResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientGetDepotDecryptionKeyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetDepotDecryptionKeyResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientCheckAppBetaPassword)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientCheckAppBetaPassword {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientCheckAppBetaPassword.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientCheckAppBetaPassword.betapassword)
    pub betapassword: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientCheckAppBetaPassword.language)
    pub language: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientCheckAppBetaPassword.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientCheckAppBetaPassword {
    fn default() -> &'a CMsgClientCheckAppBetaPassword {
        <CMsgClientCheckAppBetaPassword as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientCheckAppBetaPassword {
    pub fn new() -> CMsgClientCheckAppBetaPassword {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional string betapassword = 2;

    pub fn betapassword(&self) -> &str {
        match self.betapassword.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_betapassword(&mut self) {
        self.betapassword = ::std::option::Option::None;
    }

    pub fn has_betapassword(&self) -> bool {
        self.betapassword.is_some()
    }

    // Param is passed by value, moved
    pub fn set_betapassword(&mut self, v: ::std::string::String) {
        self.betapassword = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_betapassword(&mut self) -> &mut ::std::string::String {
        if self.betapassword.is_none() {
            self.betapassword = ::std::option::Option::Some(::std::string::String::new());
        }
        self.betapassword.as_mut().unwrap()
    }

    // Take field
    pub fn take_betapassword(&mut self) -> ::std::string::String {
        self.betapassword.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 language = 3;

    pub fn language(&self) -> i32 {
        self.language.unwrap_or(0)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientCheckAppBetaPassword| { &m.app_id },
            |m: &mut CMsgClientCheckAppBetaPassword| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "betapassword",
            |m: &CMsgClientCheckAppBetaPassword| { &m.betapassword },
            |m: &mut CMsgClientCheckAppBetaPassword| { &mut m.betapassword },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "language",
            |m: &CMsgClientCheckAppBetaPassword| { &m.language },
            |m: &mut CMsgClientCheckAppBetaPassword| { &mut m.language },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientCheckAppBetaPassword>(
            "CMsgClientCheckAppBetaPassword",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientCheckAppBetaPassword {
    const NAME: &'static str = "CMsgClientCheckAppBetaPassword";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.betapassword = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.language = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.betapassword.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.betapassword.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.language {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientCheckAppBetaPassword {
        CMsgClientCheckAppBetaPassword::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.betapassword = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientCheckAppBetaPassword {
        static instance: CMsgClientCheckAppBetaPassword = CMsgClientCheckAppBetaPassword {
            app_id: ::std::option::Option::None,
            betapassword: ::std::option::Option::None,
            language: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientCheckAppBetaPassword {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientCheckAppBetaPassword").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientCheckAppBetaPassword {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientCheckAppBetaPassword {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientCheckAppBetaPasswordResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientCheckAppBetaPasswordResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientCheckAppBetaPasswordResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientCheckAppBetaPasswordResponse.betapasswords)
    pub betapasswords: ::std::vec::Vec<cmsg_client_check_app_beta_password_response::BetaPassword>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientCheckAppBetaPasswordResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientCheckAppBetaPasswordResponse {
    fn default() -> &'a CMsgClientCheckAppBetaPasswordResponse {
        <CMsgClientCheckAppBetaPasswordResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientCheckAppBetaPasswordResponse {
    pub fn new() -> CMsgClientCheckAppBetaPasswordResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientCheckAppBetaPasswordResponse| { &m.eresult },
            |m: &mut CMsgClientCheckAppBetaPasswordResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "betapasswords",
            |m: &CMsgClientCheckAppBetaPasswordResponse| { &m.betapasswords },
            |m: &mut CMsgClientCheckAppBetaPasswordResponse| { &mut m.betapasswords },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientCheckAppBetaPasswordResponse>(
            "CMsgClientCheckAppBetaPasswordResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientCheckAppBetaPasswordResponse {
    const NAME: &'static str = "CMsgClientCheckAppBetaPasswordResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.betapasswords.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.betapasswords {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.betapasswords {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientCheckAppBetaPasswordResponse {
        CMsgClientCheckAppBetaPasswordResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.betapasswords.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientCheckAppBetaPasswordResponse {
        static instance: CMsgClientCheckAppBetaPasswordResponse = CMsgClientCheckAppBetaPasswordResponse {
            eresult: ::std::option::Option::None,
            betapasswords: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientCheckAppBetaPasswordResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientCheckAppBetaPasswordResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientCheckAppBetaPasswordResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientCheckAppBetaPasswordResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientCheckAppBetaPasswordResponse`
pub mod cmsg_client_check_app_beta_password_response {
    // @@protoc_insertion_point(message:CMsgClientCheckAppBetaPasswordResponse.BetaPassword)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BetaPassword {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientCheckAppBetaPasswordResponse.BetaPassword.betaname)
        pub betaname: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientCheckAppBetaPasswordResponse.BetaPassword.betapassword)
        pub betapassword: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientCheckAppBetaPasswordResponse.BetaPassword.betadescription)
        pub betadescription: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientCheckAppBetaPasswordResponse.BetaPassword.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BetaPassword {
        fn default() -> &'a BetaPassword {
            <BetaPassword as ::protobuf::Message>::default_instance()
        }
    }

    impl BetaPassword {
        pub fn new() -> BetaPassword {
            ::std::default::Default::default()
        }

        // optional string betaname = 1;

        pub fn betaname(&self) -> &str {
            match self.betaname.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_betaname(&mut self) {
            self.betaname = ::std::option::Option::None;
        }

        pub fn has_betaname(&self) -> bool {
            self.betaname.is_some()
        }

        // Param is passed by value, moved
        pub fn set_betaname(&mut self, v: ::std::string::String) {
            self.betaname = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_betaname(&mut self) -> &mut ::std::string::String {
            if self.betaname.is_none() {
                self.betaname = ::std::option::Option::Some(::std::string::String::new());
            }
            self.betaname.as_mut().unwrap()
        }

        // Take field
        pub fn take_betaname(&mut self) -> ::std::string::String {
            self.betaname.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string betapassword = 2;

        pub fn betapassword(&self) -> &str {
            match self.betapassword.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_betapassword(&mut self) {
            self.betapassword = ::std::option::Option::None;
        }

        pub fn has_betapassword(&self) -> bool {
            self.betapassword.is_some()
        }

        // Param is passed by value, moved
        pub fn set_betapassword(&mut self, v: ::std::string::String) {
            self.betapassword = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_betapassword(&mut self) -> &mut ::std::string::String {
            if self.betapassword.is_none() {
                self.betapassword = ::std::option::Option::Some(::std::string::String::new());
            }
            self.betapassword.as_mut().unwrap()
        }

        // Take field
        pub fn take_betapassword(&mut self) -> ::std::string::String {
            self.betapassword.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string betadescription = 3;

        pub fn betadescription(&self) -> &str {
            match self.betadescription.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_betadescription(&mut self) {
            self.betadescription = ::std::option::Option::None;
        }

        pub fn has_betadescription(&self) -> bool {
            self.betadescription.is_some()
        }

        // Param is passed by value, moved
        pub fn set_betadescription(&mut self, v: ::std::string::String) {
            self.betadescription = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_betadescription(&mut self) -> &mut ::std::string::String {
            if self.betadescription.is_none() {
                self.betadescription = ::std::option::Option::Some(::std::string::String::new());
            }
            self.betadescription.as_mut().unwrap()
        }

        // Take field
        pub fn take_betadescription(&mut self) -> ::std::string::String {
            self.betadescription.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "betaname",
                |m: &BetaPassword| { &m.betaname },
                |m: &mut BetaPassword| { &mut m.betaname },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "betapassword",
                |m: &BetaPassword| { &m.betapassword },
                |m: &mut BetaPassword| { &mut m.betapassword },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "betadescription",
                |m: &BetaPassword| { &m.betadescription },
                |m: &mut BetaPassword| { &mut m.betadescription },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BetaPassword>(
                "CMsgClientCheckAppBetaPasswordResponse.BetaPassword",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for BetaPassword {
        const NAME: &'static str = "BetaPassword";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.betaname = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.betapassword = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.betadescription = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.betaname.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.betapassword.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.betadescription.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.betaname.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.betapassword.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.betadescription.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BetaPassword {
            BetaPassword::new()
        }

        fn clear(&mut self) {
            self.betaname = ::std::option::Option::None;
            self.betapassword = ::std::option::Option::None;
            self.betadescription = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BetaPassword {
            static instance: BetaPassword = BetaPassword {
                betaname: ::std::option::Option::None,
                betapassword: ::std::option::Option::None,
                betadescription: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for BetaPassword {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientCheckAppBetaPasswordResponse.BetaPassword").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for BetaPassword {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for BetaPassword {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientUpdateAppJobReport)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUpdateAppJobReport {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUpdateAppJobReport.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateAppJobReport.depot_ids)
    pub depot_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateAppJobReport.app_state)
    pub app_state: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateAppJobReport.job_app_error)
    pub job_app_error: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateAppJobReport.error_details)
    pub error_details: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUpdateAppJobReport.job_duration)
    pub job_duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateAppJobReport.files_validation_failed)
    pub files_validation_failed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateAppJobReport.job_bytes_downloaded)
    pub job_bytes_downloaded: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUpdateAppJobReport.job_bytes_staged)
    pub job_bytes_staged: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUpdateAppJobReport.bytes_comitted)
    pub bytes_comitted: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUpdateAppJobReport.start_app_state)
    pub start_app_state: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUpdateAppJobReport.stats_machine_id)
    pub stats_machine_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUpdateAppJobReport.branch_name)
    pub branch_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUpdateAppJobReport.total_bytes_downloaded)
    pub total_bytes_downloaded: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUpdateAppJobReport.total_bytes_staged)
    pub total_bytes_staged: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUpdateAppJobReport.total_bytes_restored)
    pub total_bytes_restored: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUpdateAppJobReport.is_borrowed)
    pub is_borrowed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUpdateAppJobReport.is_free_weekend)
    pub is_free_weekend: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUpdateAppJobReport.total_bytes_legacy)
    pub total_bytes_legacy: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUpdateAppJobReport.total_bytes_patched)
    pub total_bytes_patched: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUpdateAppJobReport.total_bytes_saved)
    pub total_bytes_saved: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUpdateAppJobReport.cell_id)
    pub cell_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUpdateAppJobReport.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUpdateAppJobReport {
    fn default() -> &'a CMsgClientUpdateAppJobReport {
        <CMsgClientUpdateAppJobReport as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUpdateAppJobReport {
    pub fn new() -> CMsgClientUpdateAppJobReport {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 app_state = 3;

    pub fn app_state(&self) -> u32 {
        self.app_state.unwrap_or(0)
    }

    pub fn clear_app_state(&mut self) {
        self.app_state = ::std::option::Option::None;
    }

    pub fn has_app_state(&self) -> bool {
        self.app_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_state(&mut self, v: u32) {
        self.app_state = ::std::option::Option::Some(v);
    }

    // optional uint32 job_app_error = 4;

    pub fn job_app_error(&self) -> u32 {
        self.job_app_error.unwrap_or(0)
    }

    pub fn clear_job_app_error(&mut self) {
        self.job_app_error = ::std::option::Option::None;
    }

    pub fn has_job_app_error(&self) -> bool {
        self.job_app_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_job_app_error(&mut self, v: u32) {
        self.job_app_error = ::std::option::Option::Some(v);
    }

    // optional string error_details = 5;

    pub fn error_details(&self) -> &str {
        match self.error_details.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error_details(&mut self) {
        self.error_details = ::std::option::Option::None;
    }

    pub fn has_error_details(&self) -> bool {
        self.error_details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_details(&mut self, v: ::std::string::String) {
        self.error_details = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_details(&mut self) -> &mut ::std::string::String {
        if self.error_details.is_none() {
            self.error_details = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error_details.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_details(&mut self) -> ::std::string::String {
        self.error_details.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 job_duration = 6;

    pub fn job_duration(&self) -> u32 {
        self.job_duration.unwrap_or(0)
    }

    pub fn clear_job_duration(&mut self) {
        self.job_duration = ::std::option::Option::None;
    }

    pub fn has_job_duration(&self) -> bool {
        self.job_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_job_duration(&mut self, v: u32) {
        self.job_duration = ::std::option::Option::Some(v);
    }

    // optional uint32 files_validation_failed = 7;

    pub fn files_validation_failed(&self) -> u32 {
        self.files_validation_failed.unwrap_or(0)
    }

    pub fn clear_files_validation_failed(&mut self) {
        self.files_validation_failed = ::std::option::Option::None;
    }

    pub fn has_files_validation_failed(&self) -> bool {
        self.files_validation_failed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_files_validation_failed(&mut self, v: u32) {
        self.files_validation_failed = ::std::option::Option::Some(v);
    }

    // optional uint64 job_bytes_downloaded = 8;

    pub fn job_bytes_downloaded(&self) -> u64 {
        self.job_bytes_downloaded.unwrap_or(0)
    }

    pub fn clear_job_bytes_downloaded(&mut self) {
        self.job_bytes_downloaded = ::std::option::Option::None;
    }

    pub fn has_job_bytes_downloaded(&self) -> bool {
        self.job_bytes_downloaded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_job_bytes_downloaded(&mut self, v: u64) {
        self.job_bytes_downloaded = ::std::option::Option::Some(v);
    }

    // optional uint64 job_bytes_staged = 9;

    pub fn job_bytes_staged(&self) -> u64 {
        self.job_bytes_staged.unwrap_or(0)
    }

    pub fn clear_job_bytes_staged(&mut self) {
        self.job_bytes_staged = ::std::option::Option::None;
    }

    pub fn has_job_bytes_staged(&self) -> bool {
        self.job_bytes_staged.is_some()
    }

    // Param is passed by value, moved
    pub fn set_job_bytes_staged(&mut self, v: u64) {
        self.job_bytes_staged = ::std::option::Option::Some(v);
    }

    // optional uint64 bytes_comitted = 10;

    pub fn bytes_comitted(&self) -> u64 {
        self.bytes_comitted.unwrap_or(0)
    }

    pub fn clear_bytes_comitted(&mut self) {
        self.bytes_comitted = ::std::option::Option::None;
    }

    pub fn has_bytes_comitted(&self) -> bool {
        self.bytes_comitted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_comitted(&mut self, v: u64) {
        self.bytes_comitted = ::std::option::Option::Some(v);
    }

    // optional uint32 start_app_state = 11;

    pub fn start_app_state(&self) -> u32 {
        self.start_app_state.unwrap_or(0)
    }

    pub fn clear_start_app_state(&mut self) {
        self.start_app_state = ::std::option::Option::None;
    }

    pub fn has_start_app_state(&self) -> bool {
        self.start_app_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_app_state(&mut self, v: u32) {
        self.start_app_state = ::std::option::Option::Some(v);
    }

    // optional fixed64 stats_machine_id = 12;

    pub fn stats_machine_id(&self) -> u64 {
        self.stats_machine_id.unwrap_or(0)
    }

    pub fn clear_stats_machine_id(&mut self) {
        self.stats_machine_id = ::std::option::Option::None;
    }

    pub fn has_stats_machine_id(&self) -> bool {
        self.stats_machine_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats_machine_id(&mut self, v: u64) {
        self.stats_machine_id = ::std::option::Option::Some(v);
    }

    // optional string branch_name = 13;

    pub fn branch_name(&self) -> &str {
        match self.branch_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_branch_name(&mut self) {
        self.branch_name = ::std::option::Option::None;
    }

    pub fn has_branch_name(&self) -> bool {
        self.branch_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_branch_name(&mut self, v: ::std::string::String) {
        self.branch_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_branch_name(&mut self) -> &mut ::std::string::String {
        if self.branch_name.is_none() {
            self.branch_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.branch_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_branch_name(&mut self) -> ::std::string::String {
        self.branch_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 total_bytes_downloaded = 14;

    pub fn total_bytes_downloaded(&self) -> u64 {
        self.total_bytes_downloaded.unwrap_or(0)
    }

    pub fn clear_total_bytes_downloaded(&mut self) {
        self.total_bytes_downloaded = ::std::option::Option::None;
    }

    pub fn has_total_bytes_downloaded(&self) -> bool {
        self.total_bytes_downloaded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_bytes_downloaded(&mut self, v: u64) {
        self.total_bytes_downloaded = ::std::option::Option::Some(v);
    }

    // optional uint64 total_bytes_staged = 15;

    pub fn total_bytes_staged(&self) -> u64 {
        self.total_bytes_staged.unwrap_or(0)
    }

    pub fn clear_total_bytes_staged(&mut self) {
        self.total_bytes_staged = ::std::option::Option::None;
    }

    pub fn has_total_bytes_staged(&self) -> bool {
        self.total_bytes_staged.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_bytes_staged(&mut self, v: u64) {
        self.total_bytes_staged = ::std::option::Option::Some(v);
    }

    // optional uint64 total_bytes_restored = 16;

    pub fn total_bytes_restored(&self) -> u64 {
        self.total_bytes_restored.unwrap_or(0)
    }

    pub fn clear_total_bytes_restored(&mut self) {
        self.total_bytes_restored = ::std::option::Option::None;
    }

    pub fn has_total_bytes_restored(&self) -> bool {
        self.total_bytes_restored.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_bytes_restored(&mut self, v: u64) {
        self.total_bytes_restored = ::std::option::Option::Some(v);
    }

    // optional bool is_borrowed = 17;

    pub fn is_borrowed(&self) -> bool {
        self.is_borrowed.unwrap_or(false)
    }

    pub fn clear_is_borrowed(&mut self) {
        self.is_borrowed = ::std::option::Option::None;
    }

    pub fn has_is_borrowed(&self) -> bool {
        self.is_borrowed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_borrowed(&mut self, v: bool) {
        self.is_borrowed = ::std::option::Option::Some(v);
    }

    // optional bool is_free_weekend = 18;

    pub fn is_free_weekend(&self) -> bool {
        self.is_free_weekend.unwrap_or(false)
    }

    pub fn clear_is_free_weekend(&mut self) {
        self.is_free_weekend = ::std::option::Option::None;
    }

    pub fn has_is_free_weekend(&self) -> bool {
        self.is_free_weekend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_free_weekend(&mut self, v: bool) {
        self.is_free_weekend = ::std::option::Option::Some(v);
    }

    // optional uint64 total_bytes_legacy = 19;

    pub fn total_bytes_legacy(&self) -> u64 {
        self.total_bytes_legacy.unwrap_or(0)
    }

    pub fn clear_total_bytes_legacy(&mut self) {
        self.total_bytes_legacy = ::std::option::Option::None;
    }

    pub fn has_total_bytes_legacy(&self) -> bool {
        self.total_bytes_legacy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_bytes_legacy(&mut self, v: u64) {
        self.total_bytes_legacy = ::std::option::Option::Some(v);
    }

    // optional uint64 total_bytes_patched = 20;

    pub fn total_bytes_patched(&self) -> u64 {
        self.total_bytes_patched.unwrap_or(0)
    }

    pub fn clear_total_bytes_patched(&mut self) {
        self.total_bytes_patched = ::std::option::Option::None;
    }

    pub fn has_total_bytes_patched(&self) -> bool {
        self.total_bytes_patched.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_bytes_patched(&mut self, v: u64) {
        self.total_bytes_patched = ::std::option::Option::Some(v);
    }

    // optional uint64 total_bytes_saved = 21;

    pub fn total_bytes_saved(&self) -> u64 {
        self.total_bytes_saved.unwrap_or(0)
    }

    pub fn clear_total_bytes_saved(&mut self) {
        self.total_bytes_saved = ::std::option::Option::None;
    }

    pub fn has_total_bytes_saved(&self) -> bool {
        self.total_bytes_saved.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_bytes_saved(&mut self, v: u64) {
        self.total_bytes_saved = ::std::option::Option::Some(v);
    }

    // optional uint32 cell_id = 22;

    pub fn cell_id(&self) -> u32 {
        self.cell_id.unwrap_or(0)
    }

    pub fn clear_cell_id(&mut self) {
        self.cell_id = ::std::option::Option::None;
    }

    pub fn has_cell_id(&self) -> bool {
        self.cell_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id(&mut self, v: u32) {
        self.cell_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(22);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientUpdateAppJobReport| { &m.app_id },
            |m: &mut CMsgClientUpdateAppJobReport| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "depot_ids",
            |m: &CMsgClientUpdateAppJobReport| { &m.depot_ids },
            |m: &mut CMsgClientUpdateAppJobReport| { &mut m.depot_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_state",
            |m: &CMsgClientUpdateAppJobReport| { &m.app_state },
            |m: &mut CMsgClientUpdateAppJobReport| { &mut m.app_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "job_app_error",
            |m: &CMsgClientUpdateAppJobReport| { &m.job_app_error },
            |m: &mut CMsgClientUpdateAppJobReport| { &mut m.job_app_error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error_details",
            |m: &CMsgClientUpdateAppJobReport| { &m.error_details },
            |m: &mut CMsgClientUpdateAppJobReport| { &mut m.error_details },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "job_duration",
            |m: &CMsgClientUpdateAppJobReport| { &m.job_duration },
            |m: &mut CMsgClientUpdateAppJobReport| { &mut m.job_duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "files_validation_failed",
            |m: &CMsgClientUpdateAppJobReport| { &m.files_validation_failed },
            |m: &mut CMsgClientUpdateAppJobReport| { &mut m.files_validation_failed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "job_bytes_downloaded",
            |m: &CMsgClientUpdateAppJobReport| { &m.job_bytes_downloaded },
            |m: &mut CMsgClientUpdateAppJobReport| { &mut m.job_bytes_downloaded },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "job_bytes_staged",
            |m: &CMsgClientUpdateAppJobReport| { &m.job_bytes_staged },
            |m: &mut CMsgClientUpdateAppJobReport| { &mut m.job_bytes_staged },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bytes_comitted",
            |m: &CMsgClientUpdateAppJobReport| { &m.bytes_comitted },
            |m: &mut CMsgClientUpdateAppJobReport| { &mut m.bytes_comitted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_app_state",
            |m: &CMsgClientUpdateAppJobReport| { &m.start_app_state },
            |m: &mut CMsgClientUpdateAppJobReport| { &mut m.start_app_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stats_machine_id",
            |m: &CMsgClientUpdateAppJobReport| { &m.stats_machine_id },
            |m: &mut CMsgClientUpdateAppJobReport| { &mut m.stats_machine_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "branch_name",
            |m: &CMsgClientUpdateAppJobReport| { &m.branch_name },
            |m: &mut CMsgClientUpdateAppJobReport| { &mut m.branch_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_bytes_downloaded",
            |m: &CMsgClientUpdateAppJobReport| { &m.total_bytes_downloaded },
            |m: &mut CMsgClientUpdateAppJobReport| { &mut m.total_bytes_downloaded },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_bytes_staged",
            |m: &CMsgClientUpdateAppJobReport| { &m.total_bytes_staged },
            |m: &mut CMsgClientUpdateAppJobReport| { &mut m.total_bytes_staged },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_bytes_restored",
            |m: &CMsgClientUpdateAppJobReport| { &m.total_bytes_restored },
            |m: &mut CMsgClientUpdateAppJobReport| { &mut m.total_bytes_restored },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_borrowed",
            |m: &CMsgClientUpdateAppJobReport| { &m.is_borrowed },
            |m: &mut CMsgClientUpdateAppJobReport| { &mut m.is_borrowed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_free_weekend",
            |m: &CMsgClientUpdateAppJobReport| { &m.is_free_weekend },
            |m: &mut CMsgClientUpdateAppJobReport| { &mut m.is_free_weekend },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_bytes_legacy",
            |m: &CMsgClientUpdateAppJobReport| { &m.total_bytes_legacy },
            |m: &mut CMsgClientUpdateAppJobReport| { &mut m.total_bytes_legacy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_bytes_patched",
            |m: &CMsgClientUpdateAppJobReport| { &m.total_bytes_patched },
            |m: &mut CMsgClientUpdateAppJobReport| { &mut m.total_bytes_patched },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_bytes_saved",
            |m: &CMsgClientUpdateAppJobReport| { &m.total_bytes_saved },
            |m: &mut CMsgClientUpdateAppJobReport| { &mut m.total_bytes_saved },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cell_id",
            |m: &CMsgClientUpdateAppJobReport| { &m.cell_id },
            |m: &mut CMsgClientUpdateAppJobReport| { &mut m.cell_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUpdateAppJobReport>(
            "CMsgClientUpdateAppJobReport",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUpdateAppJobReport {
    const NAME: &'static str = "CMsgClientUpdateAppJobReport";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.depot_ids)?;
                },
                16 => {
                    self.depot_ids.push(is.read_uint32()?);
                },
                24 => {
                    self.app_state = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.job_app_error = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.error_details = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.job_duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.files_validation_failed = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.job_bytes_downloaded = ::std::option::Option::Some(is.read_uint64()?);
                },
                72 => {
                    self.job_bytes_staged = ::std::option::Option::Some(is.read_uint64()?);
                },
                80 => {
                    self.bytes_comitted = ::std::option::Option::Some(is.read_uint64()?);
                },
                88 => {
                    self.start_app_state = ::std::option::Option::Some(is.read_uint32()?);
                },
                97 => {
                    self.stats_machine_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                106 => {
                    self.branch_name = ::std::option::Option::Some(is.read_string()?);
                },
                112 => {
                    self.total_bytes_downloaded = ::std::option::Option::Some(is.read_uint64()?);
                },
                120 => {
                    self.total_bytes_staged = ::std::option::Option::Some(is.read_uint64()?);
                },
                128 => {
                    self.total_bytes_restored = ::std::option::Option::Some(is.read_uint64()?);
                },
                136 => {
                    self.is_borrowed = ::std::option::Option::Some(is.read_bool()?);
                },
                144 => {
                    self.is_free_weekend = ::std::option::Option::Some(is.read_bool()?);
                },
                152 => {
                    self.total_bytes_legacy = ::std::option::Option::Some(is.read_uint64()?);
                },
                160 => {
                    self.total_bytes_patched = ::std::option::Option::Some(is.read_uint64()?);
                },
                168 => {
                    self.total_bytes_saved = ::std::option::Option::Some(is.read_uint64()?);
                },
                176 => {
                    self.cell_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.depot_ids {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        if let Some(v) = self.app_state {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.job_app_error {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.error_details.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.job_duration {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.files_validation_failed {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.job_bytes_downloaded {
            my_size += ::protobuf::rt::uint64_size(8, v);
        }
        if let Some(v) = self.job_bytes_staged {
            my_size += ::protobuf::rt::uint64_size(9, v);
        }
        if let Some(v) = self.bytes_comitted {
            my_size += ::protobuf::rt::uint64_size(10, v);
        }
        if let Some(v) = self.start_app_state {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.stats_machine_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.branch_name.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.total_bytes_downloaded {
            my_size += ::protobuf::rt::uint64_size(14, v);
        }
        if let Some(v) = self.total_bytes_staged {
            my_size += ::protobuf::rt::uint64_size(15, v);
        }
        if let Some(v) = self.total_bytes_restored {
            my_size += ::protobuf::rt::uint64_size(16, v);
        }
        if let Some(v) = self.is_borrowed {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_free_weekend {
            my_size += 2 + 1;
        }
        if let Some(v) = self.total_bytes_legacy {
            my_size += ::protobuf::rt::uint64_size(19, v);
        }
        if let Some(v) = self.total_bytes_patched {
            my_size += ::protobuf::rt::uint64_size(20, v);
        }
        if let Some(v) = self.total_bytes_saved {
            my_size += ::protobuf::rt::uint64_size(21, v);
        }
        if let Some(v) = self.cell_id {
            my_size += ::protobuf::rt::uint32_size(22, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.depot_ids {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.app_state {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.job_app_error {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.error_details.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.job_duration {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.files_validation_failed {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.job_bytes_downloaded {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.job_bytes_staged {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.bytes_comitted {
            os.write_uint64(10, v)?;
        }
        if let Some(v) = self.start_app_state {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.stats_machine_id {
            os.write_fixed64(12, v)?;
        }
        if let Some(v) = self.branch_name.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.total_bytes_downloaded {
            os.write_uint64(14, v)?;
        }
        if let Some(v) = self.total_bytes_staged {
            os.write_uint64(15, v)?;
        }
        if let Some(v) = self.total_bytes_restored {
            os.write_uint64(16, v)?;
        }
        if let Some(v) = self.is_borrowed {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.is_free_weekend {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.total_bytes_legacy {
            os.write_uint64(19, v)?;
        }
        if let Some(v) = self.total_bytes_patched {
            os.write_uint64(20, v)?;
        }
        if let Some(v) = self.total_bytes_saved {
            os.write_uint64(21, v)?;
        }
        if let Some(v) = self.cell_id {
            os.write_uint32(22, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUpdateAppJobReport {
        CMsgClientUpdateAppJobReport::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.depot_ids.clear();
        self.app_state = ::std::option::Option::None;
        self.job_app_error = ::std::option::Option::None;
        self.error_details = ::std::option::Option::None;
        self.job_duration = ::std::option::Option::None;
        self.files_validation_failed = ::std::option::Option::None;
        self.job_bytes_downloaded = ::std::option::Option::None;
        self.job_bytes_staged = ::std::option::Option::None;
        self.bytes_comitted = ::std::option::Option::None;
        self.start_app_state = ::std::option::Option::None;
        self.stats_machine_id = ::std::option::Option::None;
        self.branch_name = ::std::option::Option::None;
        self.total_bytes_downloaded = ::std::option::Option::None;
        self.total_bytes_staged = ::std::option::Option::None;
        self.total_bytes_restored = ::std::option::Option::None;
        self.is_borrowed = ::std::option::Option::None;
        self.is_free_weekend = ::std::option::Option::None;
        self.total_bytes_legacy = ::std::option::Option::None;
        self.total_bytes_patched = ::std::option::Option::None;
        self.total_bytes_saved = ::std::option::Option::None;
        self.cell_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUpdateAppJobReport {
        static instance: CMsgClientUpdateAppJobReport = CMsgClientUpdateAppJobReport {
            app_id: ::std::option::Option::None,
            depot_ids: ::std::vec::Vec::new(),
            app_state: ::std::option::Option::None,
            job_app_error: ::std::option::Option::None,
            error_details: ::std::option::Option::None,
            job_duration: ::std::option::Option::None,
            files_validation_failed: ::std::option::Option::None,
            job_bytes_downloaded: ::std::option::Option::None,
            job_bytes_staged: ::std::option::Option::None,
            bytes_comitted: ::std::option::Option::None,
            start_app_state: ::std::option::Option::None,
            stats_machine_id: ::std::option::Option::None,
            branch_name: ::std::option::Option::None,
            total_bytes_downloaded: ::std::option::Option::None,
            total_bytes_staged: ::std::option::Option::None,
            total_bytes_restored: ::std::option::Option::None,
            is_borrowed: ::std::option::Option::None,
            is_free_weekend: ::std::option::Option::None,
            total_bytes_legacy: ::std::option::Option::None,
            total_bytes_patched: ::std::option::Option::None,
            total_bytes_saved: ::std::option::Option::None,
            cell_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUpdateAppJobReport {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUpdateAppJobReport").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUpdateAppJobReport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUpdateAppJobReport {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientDPContentStatsReport)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientDPContentStatsReport {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientDPContentStatsReport.stats_machine_id)
    pub stats_machine_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientDPContentStatsReport.country_code)
    pub country_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientDPContentStatsReport.os_type)
    pub os_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientDPContentStatsReport.language)
    pub language: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientDPContentStatsReport.num_install_folders)
    pub num_install_folders: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientDPContentStatsReport.num_installed_games)
    pub num_installed_games: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientDPContentStatsReport.size_installed_games)
    pub size_installed_games: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientDPContentStatsReport.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientDPContentStatsReport {
    fn default() -> &'a CMsgClientDPContentStatsReport {
        <CMsgClientDPContentStatsReport as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientDPContentStatsReport {
    pub fn new() -> CMsgClientDPContentStatsReport {
        ::std::default::Default::default()
    }

    // optional fixed64 stats_machine_id = 1;

    pub fn stats_machine_id(&self) -> u64 {
        self.stats_machine_id.unwrap_or(0)
    }

    pub fn clear_stats_machine_id(&mut self) {
        self.stats_machine_id = ::std::option::Option::None;
    }

    pub fn has_stats_machine_id(&self) -> bool {
        self.stats_machine_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats_machine_id(&mut self, v: u64) {
        self.stats_machine_id = ::std::option::Option::Some(v);
    }

    // optional string country_code = 2;

    pub fn country_code(&self) -> &str {
        match self.country_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country_code(&mut self) {
        self.country_code = ::std::option::Option::None;
    }

    pub fn has_country_code(&self) -> bool {
        self.country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_code(&mut self, v: ::std::string::String) {
        self.country_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
        if self.country_code.is_none() {
            self.country_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_code(&mut self) -> ::std::string::String {
        self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 os_type = 3;

    pub fn os_type(&self) -> i32 {
        self.os_type.unwrap_or(0)
    }

    pub fn clear_os_type(&mut self) {
        self.os_type = ::std::option::Option::None;
    }

    pub fn has_os_type(&self) -> bool {
        self.os_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os_type(&mut self, v: i32) {
        self.os_type = ::std::option::Option::Some(v);
    }

    // optional int32 language = 4;

    pub fn language(&self) -> i32 {
        self.language.unwrap_or(0)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }

    // optional uint32 num_install_folders = 5;

    pub fn num_install_folders(&self) -> u32 {
        self.num_install_folders.unwrap_or(0)
    }

    pub fn clear_num_install_folders(&mut self) {
        self.num_install_folders = ::std::option::Option::None;
    }

    pub fn has_num_install_folders(&self) -> bool {
        self.num_install_folders.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_install_folders(&mut self, v: u32) {
        self.num_install_folders = ::std::option::Option::Some(v);
    }

    // optional uint32 num_installed_games = 6;

    pub fn num_installed_games(&self) -> u32 {
        self.num_installed_games.unwrap_or(0)
    }

    pub fn clear_num_installed_games(&mut self) {
        self.num_installed_games = ::std::option::Option::None;
    }

    pub fn has_num_installed_games(&self) -> bool {
        self.num_installed_games.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_installed_games(&mut self, v: u32) {
        self.num_installed_games = ::std::option::Option::Some(v);
    }

    // optional uint64 size_installed_games = 7;

    pub fn size_installed_games(&self) -> u64 {
        self.size_installed_games.unwrap_or(0)
    }

    pub fn clear_size_installed_games(&mut self) {
        self.size_installed_games = ::std::option::Option::None;
    }

    pub fn has_size_installed_games(&self) -> bool {
        self.size_installed_games.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size_installed_games(&mut self, v: u64) {
        self.size_installed_games = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stats_machine_id",
            |m: &CMsgClientDPContentStatsReport| { &m.stats_machine_id },
            |m: &mut CMsgClientDPContentStatsReport| { &mut m.stats_machine_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "country_code",
            |m: &CMsgClientDPContentStatsReport| { &m.country_code },
            |m: &mut CMsgClientDPContentStatsReport| { &mut m.country_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "os_type",
            |m: &CMsgClientDPContentStatsReport| { &m.os_type },
            |m: &mut CMsgClientDPContentStatsReport| { &mut m.os_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "language",
            |m: &CMsgClientDPContentStatsReport| { &m.language },
            |m: &mut CMsgClientDPContentStatsReport| { &mut m.language },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_install_folders",
            |m: &CMsgClientDPContentStatsReport| { &m.num_install_folders },
            |m: &mut CMsgClientDPContentStatsReport| { &mut m.num_install_folders },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_installed_games",
            |m: &CMsgClientDPContentStatsReport| { &m.num_installed_games },
            |m: &mut CMsgClientDPContentStatsReport| { &mut m.num_installed_games },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "size_installed_games",
            |m: &CMsgClientDPContentStatsReport| { &m.size_installed_games },
            |m: &mut CMsgClientDPContentStatsReport| { &mut m.size_installed_games },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientDPContentStatsReport>(
            "CMsgClientDPContentStatsReport",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientDPContentStatsReport {
    const NAME: &'static str = "CMsgClientDPContentStatsReport";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.stats_machine_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.country_code = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.os_type = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.language = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.num_install_folders = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.num_installed_games = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.size_installed_games = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stats_machine_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.country_code.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.os_type {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.num_install_folders {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.num_installed_games {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.size_installed_games {
            my_size += ::protobuf::rt::uint64_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.stats_machine_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.country_code.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.os_type {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.language {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.num_install_folders {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.num_installed_games {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.size_installed_games {
            os.write_uint64(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientDPContentStatsReport {
        CMsgClientDPContentStatsReport::new()
    }

    fn clear(&mut self) {
        self.stats_machine_id = ::std::option::Option::None;
        self.country_code = ::std::option::Option::None;
        self.os_type = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.num_install_folders = ::std::option::Option::None;
        self.num_installed_games = ::std::option::Option::None;
        self.size_installed_games = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientDPContentStatsReport {
        static instance: CMsgClientDPContentStatsReport = CMsgClientDPContentStatsReport {
            stats_machine_id: ::std::option::Option::None,
            country_code: ::std::option::Option::None,
            os_type: ::std::option::Option::None,
            language: ::std::option::Option::None,
            num_install_folders: ::std::option::Option::None,
            num_installed_games: ::std::option::Option::None,
            size_installed_games: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientDPContentStatsReport {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientDPContentStatsReport").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientDPContentStatsReport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientDPContentStatsReport {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientGetCDNAuthTokenResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetCDNAuthTokenResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetCDNAuthTokenResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGetCDNAuthTokenResponse.token)
    pub token: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientGetCDNAuthTokenResponse.expiration_time)
    pub expiration_time: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetCDNAuthTokenResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetCDNAuthTokenResponse {
    fn default() -> &'a CMsgClientGetCDNAuthTokenResponse {
        <CMsgClientGetCDNAuthTokenResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetCDNAuthTokenResponse {
    pub fn new() -> CMsgClientGetCDNAuthTokenResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional string token = 2;

    pub fn token(&self) -> &str {
        match self.token.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::string::String) {
        self.token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::string::String {
        if self.token.is_none() {
            self.token = ::std::option::Option::Some(::std::string::String::new());
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::string::String {
        self.token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 expiration_time = 3;

    pub fn expiration_time(&self) -> u32 {
        self.expiration_time.unwrap_or(0)
    }

    pub fn clear_expiration_time(&mut self) {
        self.expiration_time = ::std::option::Option::None;
    }

    pub fn has_expiration_time(&self) -> bool {
        self.expiration_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration_time(&mut self, v: u32) {
        self.expiration_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientGetCDNAuthTokenResponse| { &m.eresult },
            |m: &mut CMsgClientGetCDNAuthTokenResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "token",
            |m: &CMsgClientGetCDNAuthTokenResponse| { &m.token },
            |m: &mut CMsgClientGetCDNAuthTokenResponse| { &mut m.token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expiration_time",
            |m: &CMsgClientGetCDNAuthTokenResponse| { &m.expiration_time },
            |m: &mut CMsgClientGetCDNAuthTokenResponse| { &mut m.expiration_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientGetCDNAuthTokenResponse>(
            "CMsgClientGetCDNAuthTokenResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientGetCDNAuthTokenResponse {
    const NAME: &'static str = "CMsgClientGetCDNAuthTokenResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.token = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.expiration_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.token.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.expiration_time {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.token.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.expiration_time {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetCDNAuthTokenResponse {
        CMsgClientGetCDNAuthTokenResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.token = ::std::option::Option::None;
        self.expiration_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetCDNAuthTokenResponse {
        static instance: CMsgClientGetCDNAuthTokenResponse = CMsgClientGetCDNAuthTokenResponse {
            eresult: ::std::option::Option::None,
            token: ::std::option::Option::None,
            expiration_time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientGetCDNAuthTokenResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientGetCDNAuthTokenResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientGetCDNAuthTokenResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetCDNAuthTokenResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgDownloadRateStatistics)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDownloadRateStatistics {
    // message fields
    // @@protoc_insertion_point(field:CMsgDownloadRateStatistics.cell_id)
    pub cell_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDownloadRateStatistics.stats)
    pub stats: ::std::vec::Vec<cmsg_download_rate_statistics::StatsInfo>,
    // @@protoc_insertion_point(field:CMsgDownloadRateStatistics.throttling_kbps)
    pub throttling_kbps: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDownloadRateStatistics.steam_realm)
    pub steam_realm: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDownloadRateStatistics.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDownloadRateStatistics {
    fn default() -> &'a CMsgDownloadRateStatistics {
        <CMsgDownloadRateStatistics as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDownloadRateStatistics {
    pub fn new() -> CMsgDownloadRateStatistics {
        ::std::default::Default::default()
    }

    // optional uint32 cell_id = 1;

    pub fn cell_id(&self) -> u32 {
        self.cell_id.unwrap_or(0)
    }

    pub fn clear_cell_id(&mut self) {
        self.cell_id = ::std::option::Option::None;
    }

    pub fn has_cell_id(&self) -> bool {
        self.cell_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id(&mut self, v: u32) {
        self.cell_id = ::std::option::Option::Some(v);
    }

    // optional uint32 throttling_kbps = 3;

    pub fn throttling_kbps(&self) -> u32 {
        self.throttling_kbps.unwrap_or(0)
    }

    pub fn clear_throttling_kbps(&mut self) {
        self.throttling_kbps = ::std::option::Option::None;
    }

    pub fn has_throttling_kbps(&self) -> bool {
        self.throttling_kbps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_throttling_kbps(&mut self, v: u32) {
        self.throttling_kbps = ::std::option::Option::Some(v);
    }

    // optional uint32 steam_realm = 4;

    pub fn steam_realm(&self) -> u32 {
        self.steam_realm.unwrap_or(0)
    }

    pub fn clear_steam_realm(&mut self) {
        self.steam_realm = ::std::option::Option::None;
    }

    pub fn has_steam_realm(&self) -> bool {
        self.steam_realm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_realm(&mut self, v: u32) {
        self.steam_realm = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cell_id",
            |m: &CMsgDownloadRateStatistics| { &m.cell_id },
            |m: &mut CMsgDownloadRateStatistics| { &mut m.cell_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stats",
            |m: &CMsgDownloadRateStatistics| { &m.stats },
            |m: &mut CMsgDownloadRateStatistics| { &mut m.stats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "throttling_kbps",
            |m: &CMsgDownloadRateStatistics| { &m.throttling_kbps },
            |m: &mut CMsgDownloadRateStatistics| { &mut m.throttling_kbps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_realm",
            |m: &CMsgDownloadRateStatistics| { &m.steam_realm },
            |m: &mut CMsgDownloadRateStatistics| { &mut m.steam_realm },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDownloadRateStatistics>(
            "CMsgDownloadRateStatistics",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDownloadRateStatistics {
    const NAME: &'static str = "CMsgDownloadRateStatistics";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cell_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.stats.push(is.read_message()?);
                },
                24 => {
                    self.throttling_kbps = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.steam_realm = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cell_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.throttling_kbps {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.steam_realm {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cell_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.stats {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.throttling_kbps {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.steam_realm {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDownloadRateStatistics {
        CMsgDownloadRateStatistics::new()
    }

    fn clear(&mut self) {
        self.cell_id = ::std::option::Option::None;
        self.stats.clear();
        self.throttling_kbps = ::std::option::Option::None;
        self.steam_realm = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDownloadRateStatistics {
        static instance: CMsgDownloadRateStatistics = CMsgDownloadRateStatistics {
            cell_id: ::std::option::Option::None,
            stats: ::std::vec::Vec::new(),
            throttling_kbps: ::std::option::Option::None,
            steam_realm: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDownloadRateStatistics {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDownloadRateStatistics").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDownloadRateStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDownloadRateStatistics {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgDownloadRateStatistics`
pub mod cmsg_download_rate_statistics {
    // @@protoc_insertion_point(message:CMsgDownloadRateStatistics.StatsInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct StatsInfo {
        // message fields
        // @@protoc_insertion_point(field:CMsgDownloadRateStatistics.StatsInfo.source_type)
        pub source_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDownloadRateStatistics.StatsInfo.source_id)
        pub source_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDownloadRateStatistics.StatsInfo.seconds)
        pub seconds: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDownloadRateStatistics.StatsInfo.bytes)
        pub bytes: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgDownloadRateStatistics.StatsInfo.host_name)
        pub host_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDownloadRateStatistics.StatsInfo.microseconds)
        pub microseconds: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgDownloadRateStatistics.StatsInfo.used_ipv6)
        pub used_ipv6: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgDownloadRateStatistics.StatsInfo.proxied)
        pub proxied: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDownloadRateStatistics.StatsInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a StatsInfo {
        fn default() -> &'a StatsInfo {
            <StatsInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl StatsInfo {
        pub fn new() -> StatsInfo {
            ::std::default::Default::default()
        }

        // optional uint32 source_type = 1;

        pub fn source_type(&self) -> u32 {
            self.source_type.unwrap_or(0)
        }

        pub fn clear_source_type(&mut self) {
            self.source_type = ::std::option::Option::None;
        }

        pub fn has_source_type(&self) -> bool {
            self.source_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_source_type(&mut self, v: u32) {
            self.source_type = ::std::option::Option::Some(v);
        }

        // optional uint32 source_id = 2;

        pub fn source_id(&self) -> u32 {
            self.source_id.unwrap_or(0)
        }

        pub fn clear_source_id(&mut self) {
            self.source_id = ::std::option::Option::None;
        }

        pub fn has_source_id(&self) -> bool {
            self.source_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_source_id(&mut self, v: u32) {
            self.source_id = ::std::option::Option::Some(v);
        }

        // optional uint32 seconds = 3;

        pub fn seconds(&self) -> u32 {
            self.seconds.unwrap_or(0)
        }

        pub fn clear_seconds(&mut self) {
            self.seconds = ::std::option::Option::None;
        }

        pub fn has_seconds(&self) -> bool {
            self.seconds.is_some()
        }

        // Param is passed by value, moved
        pub fn set_seconds(&mut self, v: u32) {
            self.seconds = ::std::option::Option::Some(v);
        }

        // optional uint64 bytes = 4;

        pub fn bytes(&self) -> u64 {
            self.bytes.unwrap_or(0)
        }

        pub fn clear_bytes(&mut self) {
            self.bytes = ::std::option::Option::None;
        }

        pub fn has_bytes(&self) -> bool {
            self.bytes.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bytes(&mut self, v: u64) {
            self.bytes = ::std::option::Option::Some(v);
        }

        // optional string host_name = 5;

        pub fn host_name(&self) -> &str {
            match self.host_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_host_name(&mut self) {
            self.host_name = ::std::option::Option::None;
        }

        pub fn has_host_name(&self) -> bool {
            self.host_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_host_name(&mut self, v: ::std::string::String) {
            self.host_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_host_name(&mut self) -> &mut ::std::string::String {
            if self.host_name.is_none() {
                self.host_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.host_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_host_name(&mut self) -> ::std::string::String {
            self.host_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint64 microseconds = 6;

        pub fn microseconds(&self) -> u64 {
            self.microseconds.unwrap_or(0)
        }

        pub fn clear_microseconds(&mut self) {
            self.microseconds = ::std::option::Option::None;
        }

        pub fn has_microseconds(&self) -> bool {
            self.microseconds.is_some()
        }

        // Param is passed by value, moved
        pub fn set_microseconds(&mut self, v: u64) {
            self.microseconds = ::std::option::Option::Some(v);
        }

        // optional bool used_ipv6 = 7;

        pub fn used_ipv6(&self) -> bool {
            self.used_ipv6.unwrap_or(false)
        }

        pub fn clear_used_ipv6(&mut self) {
            self.used_ipv6 = ::std::option::Option::None;
        }

        pub fn has_used_ipv6(&self) -> bool {
            self.used_ipv6.is_some()
        }

        // Param is passed by value, moved
        pub fn set_used_ipv6(&mut self, v: bool) {
            self.used_ipv6 = ::std::option::Option::Some(v);
        }

        // optional bool proxied = 8;

        pub fn proxied(&self) -> bool {
            self.proxied.unwrap_or(false)
        }

        pub fn clear_proxied(&mut self) {
            self.proxied = ::std::option::Option::None;
        }

        pub fn has_proxied(&self) -> bool {
            self.proxied.is_some()
        }

        // Param is passed by value, moved
        pub fn set_proxied(&mut self, v: bool) {
            self.proxied = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(8);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "source_type",
                |m: &StatsInfo| { &m.source_type },
                |m: &mut StatsInfo| { &mut m.source_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "source_id",
                |m: &StatsInfo| { &m.source_id },
                |m: &mut StatsInfo| { &mut m.source_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "seconds",
                |m: &StatsInfo| { &m.seconds },
                |m: &mut StatsInfo| { &mut m.seconds },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "bytes",
                |m: &StatsInfo| { &m.bytes },
                |m: &mut StatsInfo| { &mut m.bytes },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "host_name",
                |m: &StatsInfo| { &m.host_name },
                |m: &mut StatsInfo| { &mut m.host_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "microseconds",
                |m: &StatsInfo| { &m.microseconds },
                |m: &mut StatsInfo| { &mut m.microseconds },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "used_ipv6",
                |m: &StatsInfo| { &m.used_ipv6 },
                |m: &mut StatsInfo| { &mut m.used_ipv6 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "proxied",
                |m: &StatsInfo| { &m.proxied },
                |m: &mut StatsInfo| { &mut m.proxied },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatsInfo>(
                "CMsgDownloadRateStatistics.StatsInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for StatsInfo {
        const NAME: &'static str = "StatsInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.source_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.source_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.seconds = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.bytes = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    42 => {
                        self.host_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    48 => {
                        self.microseconds = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    56 => {
                        self.used_ipv6 = ::std::option::Option::Some(is.read_bool()?);
                    },
                    64 => {
                        self.proxied = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.source_type {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.source_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.seconds {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.bytes {
                my_size += ::protobuf::rt::uint64_size(4, v);
            }
            if let Some(v) = self.host_name.as_ref() {
                my_size += ::protobuf::rt::string_size(5, &v);
            }
            if let Some(v) = self.microseconds {
                my_size += ::protobuf::rt::uint64_size(6, v);
            }
            if let Some(v) = self.used_ipv6 {
                my_size += 1 + 1;
            }
            if let Some(v) = self.proxied {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.source_type {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.source_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.seconds {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.bytes {
                os.write_uint64(4, v)?;
            }
            if let Some(v) = self.host_name.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.microseconds {
                os.write_uint64(6, v)?;
            }
            if let Some(v) = self.used_ipv6 {
                os.write_bool(7, v)?;
            }
            if let Some(v) = self.proxied {
                os.write_bool(8, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> StatsInfo {
            StatsInfo::new()
        }

        fn clear(&mut self) {
            self.source_type = ::std::option::Option::None;
            self.source_id = ::std::option::Option::None;
            self.seconds = ::std::option::Option::None;
            self.bytes = ::std::option::Option::None;
            self.host_name = ::std::option::Option::None;
            self.microseconds = ::std::option::Option::None;
            self.used_ipv6 = ::std::option::Option::None;
            self.proxied = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static StatsInfo {
            static instance: StatsInfo = StatsInfo {
                source_type: ::std::option::Option::None,
                source_id: ::std::option::Option::None,
                seconds: ::std::option::Option::None,
                bytes: ::std::option::Option::None,
                host_name: ::std::option::Option::None,
                microseconds: ::std::option::Option::None,
                used_ipv6: ::std::option::Option::None,
                proxied: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for StatsInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDownloadRateStatistics.StatsInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for StatsInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for StatsInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientRequestAccountData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestAccountData {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRequestAccountData.account_or_email)
    pub account_or_email: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientRequestAccountData.action)
    pub action: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestAccountData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestAccountData {
    fn default() -> &'a CMsgClientRequestAccountData {
        <CMsgClientRequestAccountData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestAccountData {
    pub fn new() -> CMsgClientRequestAccountData {
        ::std::default::Default::default()
    }

    // optional string account_or_email = 1;

    pub fn account_or_email(&self) -> &str {
        match self.account_or_email.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_account_or_email(&mut self) {
        self.account_or_email = ::std::option::Option::None;
    }

    pub fn has_account_or_email(&self) -> bool {
        self.account_or_email.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_or_email(&mut self, v: ::std::string::String) {
        self.account_or_email = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_or_email(&mut self) -> &mut ::std::string::String {
        if self.account_or_email.is_none() {
            self.account_or_email = ::std::option::Option::Some(::std::string::String::new());
        }
        self.account_or_email.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_or_email(&mut self) -> ::std::string::String {
        self.account_or_email.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 action = 2;

    pub fn action(&self) -> u32 {
        self.action.unwrap_or(0)
    }

    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: u32) {
        self.action = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_or_email",
            |m: &CMsgClientRequestAccountData| { &m.account_or_email },
            |m: &mut CMsgClientRequestAccountData| { &mut m.account_or_email },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "action",
            |m: &CMsgClientRequestAccountData| { &m.action },
            |m: &mut CMsgClientRequestAccountData| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRequestAccountData>(
            "CMsgClientRequestAccountData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientRequestAccountData {
    const NAME: &'static str = "CMsgClientRequestAccountData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.account_or_email = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.action = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_or_email.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.action {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_or_email.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.action {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestAccountData {
        CMsgClientRequestAccountData::new()
    }

    fn clear(&mut self) {
        self.account_or_email = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestAccountData {
        static instance: CMsgClientRequestAccountData = CMsgClientRequestAccountData {
            account_or_email: ::std::option::Option::None,
            action: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientRequestAccountData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRequestAccountData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRequestAccountData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestAccountData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRequestAccountDataResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestAccountDataResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRequestAccountDataResponse.action)
    pub action: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRequestAccountDataResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRequestAccountDataResponse.account_name)
    pub account_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientRequestAccountDataResponse.ct_matches)
    pub ct_matches: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRequestAccountDataResponse.account_name_suggestion1)
    pub account_name_suggestion1: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientRequestAccountDataResponse.account_name_suggestion2)
    pub account_name_suggestion2: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientRequestAccountDataResponse.account_name_suggestion3)
    pub account_name_suggestion3: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestAccountDataResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestAccountDataResponse {
    fn default() -> &'a CMsgClientRequestAccountDataResponse {
        <CMsgClientRequestAccountDataResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestAccountDataResponse {
    pub fn new() -> CMsgClientRequestAccountDataResponse {
        ::std::default::Default::default()
    }

    // optional uint32 action = 1;

    pub fn action(&self) -> u32 {
        self.action.unwrap_or(0)
    }

    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: u32) {
        self.action = ::std::option::Option::Some(v);
    }

    // optional uint32 eresult = 2;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional string account_name = 3;

    pub fn account_name(&self) -> &str {
        match self.account_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_account_name(&mut self) {
        self.account_name = ::std::option::Option::None;
    }

    pub fn has_account_name(&self) -> bool {
        self.account_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_name(&mut self, v: ::std::string::String) {
        self.account_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_name(&mut self) -> &mut ::std::string::String {
        if self.account_name.is_none() {
            self.account_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.account_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_name(&mut self) -> ::std::string::String {
        self.account_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 ct_matches = 4;

    pub fn ct_matches(&self) -> u32 {
        self.ct_matches.unwrap_or(0)
    }

    pub fn clear_ct_matches(&mut self) {
        self.ct_matches = ::std::option::Option::None;
    }

    pub fn has_ct_matches(&self) -> bool {
        self.ct_matches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ct_matches(&mut self, v: u32) {
        self.ct_matches = ::std::option::Option::Some(v);
    }

    // optional string account_name_suggestion1 = 5;

    pub fn account_name_suggestion1(&self) -> &str {
        match self.account_name_suggestion1.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_account_name_suggestion1(&mut self) {
        self.account_name_suggestion1 = ::std::option::Option::None;
    }

    pub fn has_account_name_suggestion1(&self) -> bool {
        self.account_name_suggestion1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_name_suggestion1(&mut self, v: ::std::string::String) {
        self.account_name_suggestion1 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_name_suggestion1(&mut self) -> &mut ::std::string::String {
        if self.account_name_suggestion1.is_none() {
            self.account_name_suggestion1 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.account_name_suggestion1.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_name_suggestion1(&mut self) -> ::std::string::String {
        self.account_name_suggestion1.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string account_name_suggestion2 = 6;

    pub fn account_name_suggestion2(&self) -> &str {
        match self.account_name_suggestion2.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_account_name_suggestion2(&mut self) {
        self.account_name_suggestion2 = ::std::option::Option::None;
    }

    pub fn has_account_name_suggestion2(&self) -> bool {
        self.account_name_suggestion2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_name_suggestion2(&mut self, v: ::std::string::String) {
        self.account_name_suggestion2 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_name_suggestion2(&mut self) -> &mut ::std::string::String {
        if self.account_name_suggestion2.is_none() {
            self.account_name_suggestion2 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.account_name_suggestion2.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_name_suggestion2(&mut self) -> ::std::string::String {
        self.account_name_suggestion2.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string account_name_suggestion3 = 7;

    pub fn account_name_suggestion3(&self) -> &str {
        match self.account_name_suggestion3.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_account_name_suggestion3(&mut self) {
        self.account_name_suggestion3 = ::std::option::Option::None;
    }

    pub fn has_account_name_suggestion3(&self) -> bool {
        self.account_name_suggestion3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_name_suggestion3(&mut self, v: ::std::string::String) {
        self.account_name_suggestion3 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_name_suggestion3(&mut self) -> &mut ::std::string::String {
        if self.account_name_suggestion3.is_none() {
            self.account_name_suggestion3 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.account_name_suggestion3.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_name_suggestion3(&mut self) -> ::std::string::String {
        self.account_name_suggestion3.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "action",
            |m: &CMsgClientRequestAccountDataResponse| { &m.action },
            |m: &mut CMsgClientRequestAccountDataResponse| { &mut m.action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientRequestAccountDataResponse| { &m.eresult },
            |m: &mut CMsgClientRequestAccountDataResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_name",
            |m: &CMsgClientRequestAccountDataResponse| { &m.account_name },
            |m: &mut CMsgClientRequestAccountDataResponse| { &mut m.account_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ct_matches",
            |m: &CMsgClientRequestAccountDataResponse| { &m.ct_matches },
            |m: &mut CMsgClientRequestAccountDataResponse| { &mut m.ct_matches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_name_suggestion1",
            |m: &CMsgClientRequestAccountDataResponse| { &m.account_name_suggestion1 },
            |m: &mut CMsgClientRequestAccountDataResponse| { &mut m.account_name_suggestion1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_name_suggestion2",
            |m: &CMsgClientRequestAccountDataResponse| { &m.account_name_suggestion2 },
            |m: &mut CMsgClientRequestAccountDataResponse| { &mut m.account_name_suggestion2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_name_suggestion3",
            |m: &CMsgClientRequestAccountDataResponse| { &m.account_name_suggestion3 },
            |m: &mut CMsgClientRequestAccountDataResponse| { &mut m.account_name_suggestion3 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRequestAccountDataResponse>(
            "CMsgClientRequestAccountDataResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientRequestAccountDataResponse {
    const NAME: &'static str = "CMsgClientRequestAccountDataResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.action = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.account_name = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.ct_matches = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.account_name_suggestion1 = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.account_name_suggestion2 = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.account_name_suggestion3 = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.action {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.account_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.ct_matches {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.account_name_suggestion1.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.account_name_suggestion2.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.account_name_suggestion3.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.action {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.account_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.ct_matches {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.account_name_suggestion1.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.account_name_suggestion2.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.account_name_suggestion3.as_ref() {
            os.write_string(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestAccountDataResponse {
        CMsgClientRequestAccountDataResponse::new()
    }

    fn clear(&mut self) {
        self.action = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.account_name = ::std::option::Option::None;
        self.ct_matches = ::std::option::Option::None;
        self.account_name_suggestion1 = ::std::option::Option::None;
        self.account_name_suggestion2 = ::std::option::Option::None;
        self.account_name_suggestion3 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestAccountDataResponse {
        static instance: CMsgClientRequestAccountDataResponse = CMsgClientRequestAccountDataResponse {
            action: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            account_name: ::std::option::Option::None,
            ct_matches: ::std::option::Option::None,
            account_name_suggestion1: ::std::option::Option::None,
            account_name_suggestion2: ::std::option::Option::None,
            account_name_suggestion3: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientRequestAccountDataResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRequestAccountDataResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRequestAccountDataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestAccountDataResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUGSGetGlobalStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUGSGetGlobalStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUGSGetGlobalStats.gameid)
    pub gameid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUGSGetGlobalStats.history_days_requested)
    pub history_days_requested: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUGSGetGlobalStats.time_last_requested)
    pub time_last_requested: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUGSGetGlobalStats.first_day_cached)
    pub first_day_cached: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUGSGetGlobalStats.days_cached)
    pub days_cached: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUGSGetGlobalStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUGSGetGlobalStats {
    fn default() -> &'a CMsgClientUGSGetGlobalStats {
        <CMsgClientUGSGetGlobalStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUGSGetGlobalStats {
    pub fn new() -> CMsgClientUGSGetGlobalStats {
        ::std::default::Default::default()
    }

    // optional uint64 gameid = 1;

    pub fn gameid(&self) -> u64 {
        self.gameid.unwrap_or(0)
    }

    pub fn clear_gameid(&mut self) {
        self.gameid = ::std::option::Option::None;
    }

    pub fn has_gameid(&self) -> bool {
        self.gameid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameid(&mut self, v: u64) {
        self.gameid = ::std::option::Option::Some(v);
    }

    // optional uint32 history_days_requested = 2;

    pub fn history_days_requested(&self) -> u32 {
        self.history_days_requested.unwrap_or(0)
    }

    pub fn clear_history_days_requested(&mut self) {
        self.history_days_requested = ::std::option::Option::None;
    }

    pub fn has_history_days_requested(&self) -> bool {
        self.history_days_requested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_history_days_requested(&mut self, v: u32) {
        self.history_days_requested = ::std::option::Option::Some(v);
    }

    // optional fixed32 time_last_requested = 3;

    pub fn time_last_requested(&self) -> u32 {
        self.time_last_requested.unwrap_or(0)
    }

    pub fn clear_time_last_requested(&mut self) {
        self.time_last_requested = ::std::option::Option::None;
    }

    pub fn has_time_last_requested(&self) -> bool {
        self.time_last_requested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_last_requested(&mut self, v: u32) {
        self.time_last_requested = ::std::option::Option::Some(v);
    }

    // optional uint32 first_day_cached = 4;

    pub fn first_day_cached(&self) -> u32 {
        self.first_day_cached.unwrap_or(0)
    }

    pub fn clear_first_day_cached(&mut self) {
        self.first_day_cached = ::std::option::Option::None;
    }

    pub fn has_first_day_cached(&self) -> bool {
        self.first_day_cached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_day_cached(&mut self, v: u32) {
        self.first_day_cached = ::std::option::Option::Some(v);
    }

    // optional uint32 days_cached = 5;

    pub fn days_cached(&self) -> u32 {
        self.days_cached.unwrap_or(0)
    }

    pub fn clear_days_cached(&mut self) {
        self.days_cached = ::std::option::Option::None;
    }

    pub fn has_days_cached(&self) -> bool {
        self.days_cached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_days_cached(&mut self, v: u32) {
        self.days_cached = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gameid",
            |m: &CMsgClientUGSGetGlobalStats| { &m.gameid },
            |m: &mut CMsgClientUGSGetGlobalStats| { &mut m.gameid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "history_days_requested",
            |m: &CMsgClientUGSGetGlobalStats| { &m.history_days_requested },
            |m: &mut CMsgClientUGSGetGlobalStats| { &mut m.history_days_requested },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_last_requested",
            |m: &CMsgClientUGSGetGlobalStats| { &m.time_last_requested },
            |m: &mut CMsgClientUGSGetGlobalStats| { &mut m.time_last_requested },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "first_day_cached",
            |m: &CMsgClientUGSGetGlobalStats| { &m.first_day_cached },
            |m: &mut CMsgClientUGSGetGlobalStats| { &mut m.first_day_cached },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "days_cached",
            |m: &CMsgClientUGSGetGlobalStats| { &m.days_cached },
            |m: &mut CMsgClientUGSGetGlobalStats| { &mut m.days_cached },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUGSGetGlobalStats>(
            "CMsgClientUGSGetGlobalStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUGSGetGlobalStats {
    const NAME: &'static str = "CMsgClientUGSGetGlobalStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.gameid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.history_days_requested = ::std::option::Option::Some(is.read_uint32()?);
                },
                29 => {
                    self.time_last_requested = ::std::option::Option::Some(is.read_fixed32()?);
                },
                32 => {
                    self.first_day_cached = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.days_cached = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gameid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.history_days_requested {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.time_last_requested {
            my_size += 1 + 4;
        }
        if let Some(v) = self.first_day_cached {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.days_cached {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.gameid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.history_days_requested {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.time_last_requested {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.first_day_cached {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.days_cached {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUGSGetGlobalStats {
        CMsgClientUGSGetGlobalStats::new()
    }

    fn clear(&mut self) {
        self.gameid = ::std::option::Option::None;
        self.history_days_requested = ::std::option::Option::None;
        self.time_last_requested = ::std::option::Option::None;
        self.first_day_cached = ::std::option::Option::None;
        self.days_cached = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUGSGetGlobalStats {
        static instance: CMsgClientUGSGetGlobalStats = CMsgClientUGSGetGlobalStats {
            gameid: ::std::option::Option::None,
            history_days_requested: ::std::option::Option::None,
            time_last_requested: ::std::option::Option::None,
            first_day_cached: ::std::option::Option::None,
            days_cached: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUGSGetGlobalStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUGSGetGlobalStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUGSGetGlobalStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUGSGetGlobalStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUGSGetGlobalStatsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUGSGetGlobalStatsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUGSGetGlobalStatsResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUGSGetGlobalStatsResponse.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUGSGetGlobalStatsResponse.day_current)
    pub day_current: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUGSGetGlobalStatsResponse.days)
    pub days: ::std::vec::Vec<cmsg_client_ugsget_global_stats_response::Day>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUGSGetGlobalStatsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUGSGetGlobalStatsResponse {
    fn default() -> &'a CMsgClientUGSGetGlobalStatsResponse {
        <CMsgClientUGSGetGlobalStatsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUGSGetGlobalStatsResponse {
    pub fn new() -> CMsgClientUGSGetGlobalStatsResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional fixed32 timestamp = 2;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional int32 day_current = 3;

    pub fn day_current(&self) -> i32 {
        self.day_current.unwrap_or(0)
    }

    pub fn clear_day_current(&mut self) {
        self.day_current = ::std::option::Option::None;
    }

    pub fn has_day_current(&self) -> bool {
        self.day_current.is_some()
    }

    // Param is passed by value, moved
    pub fn set_day_current(&mut self, v: i32) {
        self.day_current = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientUGSGetGlobalStatsResponse| { &m.eresult },
            |m: &mut CMsgClientUGSGetGlobalStatsResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &CMsgClientUGSGetGlobalStatsResponse| { &m.timestamp },
            |m: &mut CMsgClientUGSGetGlobalStatsResponse| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "day_current",
            |m: &CMsgClientUGSGetGlobalStatsResponse| { &m.day_current },
            |m: &mut CMsgClientUGSGetGlobalStatsResponse| { &mut m.day_current },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "days",
            |m: &CMsgClientUGSGetGlobalStatsResponse| { &m.days },
            |m: &mut CMsgClientUGSGetGlobalStatsResponse| { &mut m.days },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUGSGetGlobalStatsResponse>(
            "CMsgClientUGSGetGlobalStatsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUGSGetGlobalStatsResponse {
    const NAME: &'static str = "CMsgClientUGSGetGlobalStatsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                21 => {
                    self.timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                24 => {
                    self.day_current = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.days.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.timestamp {
            my_size += 1 + 4;
        }
        if let Some(v) = self.day_current {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        for value in &self.days {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.day_current {
            os.write_int32(3, v)?;
        }
        for v in &self.days {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUGSGetGlobalStatsResponse {
        CMsgClientUGSGetGlobalStatsResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.day_current = ::std::option::Option::None;
        self.days.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUGSGetGlobalStatsResponse {
        static instance: CMsgClientUGSGetGlobalStatsResponse = CMsgClientUGSGetGlobalStatsResponse {
            eresult: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            day_current: ::std::option::Option::None,
            days: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUGSGetGlobalStatsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUGSGetGlobalStatsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUGSGetGlobalStatsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUGSGetGlobalStatsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientUGSGetGlobalStatsResponse`
pub mod cmsg_client_ugsget_global_stats_response {
    // @@protoc_insertion_point(message:CMsgClientUGSGetGlobalStatsResponse.Day)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Day {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientUGSGetGlobalStatsResponse.Day.day_id)
        pub day_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientUGSGetGlobalStatsResponse.Day.stats)
        pub stats: ::std::vec::Vec<day::Stat>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientUGSGetGlobalStatsResponse.Day.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Day {
        fn default() -> &'a Day {
            <Day as ::protobuf::Message>::default_instance()
        }
    }

    impl Day {
        pub fn new() -> Day {
            ::std::default::Default::default()
        }

        // optional uint32 day_id = 1;

        pub fn day_id(&self) -> u32 {
            self.day_id.unwrap_or(0)
        }

        pub fn clear_day_id(&mut self) {
            self.day_id = ::std::option::Option::None;
        }

        pub fn has_day_id(&self) -> bool {
            self.day_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_day_id(&mut self, v: u32) {
            self.day_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "day_id",
                |m: &Day| { &m.day_id },
                |m: &mut Day| { &mut m.day_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "stats",
                |m: &Day| { &m.stats },
                |m: &mut Day| { &mut m.stats },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Day>(
                "CMsgClientUGSGetGlobalStatsResponse.Day",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Day {
        const NAME: &'static str = "Day";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.day_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.stats.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.day_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.stats {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.day_id {
                os.write_uint32(1, v)?;
            }
            for v in &self.stats {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Day {
            Day::new()
        }

        fn clear(&mut self) {
            self.day_id = ::std::option::Option::None;
            self.stats.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Day {
            static instance: Day = Day {
                day_id: ::std::option::Option::None,
                stats: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Day {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientUGSGetGlobalStatsResponse.Day").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Day {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Day {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Day`
    pub mod day {
        // @@protoc_insertion_point(message:CMsgClientUGSGetGlobalStatsResponse.Day.Stat)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Stat {
            // message fields
            // @@protoc_insertion_point(field:CMsgClientUGSGetGlobalStatsResponse.Day.Stat.stat_id)
            pub stat_id: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CMsgClientUGSGetGlobalStatsResponse.Day.Stat.data)
            pub data: ::std::option::Option<i64>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgClientUGSGetGlobalStatsResponse.Day.Stat.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Stat {
            fn default() -> &'a Stat {
                <Stat as ::protobuf::Message>::default_instance()
            }
        }

        impl Stat {
            pub fn new() -> Stat {
                ::std::default::Default::default()
            }

            // optional int32 stat_id = 1;

            pub fn stat_id(&self) -> i32 {
                self.stat_id.unwrap_or(0)
            }

            pub fn clear_stat_id(&mut self) {
                self.stat_id = ::std::option::Option::None;
            }

            pub fn has_stat_id(&self) -> bool {
                self.stat_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_stat_id(&mut self, v: i32) {
                self.stat_id = ::std::option::Option::Some(v);
            }

            // optional int64 data = 2;

            pub fn data(&self) -> i64 {
                self.data.unwrap_or(0)
            }

            pub fn clear_data(&mut self) {
                self.data = ::std::option::Option::None;
            }

            pub fn has_data(&self) -> bool {
                self.data.is_some()
            }

            // Param is passed by value, moved
            pub fn set_data(&mut self, v: i64) {
                self.data = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "stat_id",
                    |m: &Stat| { &m.stat_id },
                    |m: &mut Stat| { &mut m.stat_id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "data",
                    |m: &Stat| { &m.data },
                    |m: &mut Stat| { &mut m.data },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Stat>(
                    "CMsgClientUGSGetGlobalStatsResponse.Day.Stat",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Stat {
            const NAME: &'static str = "Stat";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.stat_id = ::std::option::Option::Some(is.read_int32()?);
                        },
                        16 => {
                            self.data = ::std::option::Option::Some(is.read_int64()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.stat_id {
                    my_size += ::protobuf::rt::int32_size(1, v);
                }
                if let Some(v) = self.data {
                    my_size += ::protobuf::rt::int64_size(2, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.stat_id {
                    os.write_int32(1, v)?;
                }
                if let Some(v) = self.data {
                    os.write_int64(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Stat {
                Stat::new()
            }

            fn clear(&mut self) {
                self.stat_id = ::std::option::Option::None;
                self.data = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Stat {
                static instance: Stat = Stat {
                    stat_id: ::std::option::Option::None,
                    data: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Stat {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CMsgClientUGSGetGlobalStatsResponse.Day.Stat").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Stat {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Stat {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:CMsgGameServerData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameServerData {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameServerData.revision)
    pub revision: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerData.steam_id_gs)
    pub steam_id_gs: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGameServerData.query_port)
    pub query_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerData.game_port)
    pub game_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerData.spectator_port)
    pub spectator_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerData.server_name)
    pub server_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameServerData.game_description)
    pub game_description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameServerData.spectator_server_name)
    pub spectator_server_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameServerData.fake_ip)
    pub fake_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerData.sdr_login)
    pub sdr_login: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgGameServerData.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerData.gamedir)
    pub gamedir: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameServerData.version)
    pub version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameServerData.product)
    pub product: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameServerData.region)
    pub region: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameServerData.players)
    pub players: ::std::vec::Vec<cmsg_game_server_data::Player>,
    // @@protoc_insertion_point(field:CMsgGameServerData.max_players)
    pub max_players: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerData.bot_count)
    pub bot_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerData.password)
    pub password: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGameServerData.secure)
    pub secure: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGameServerData.dedicated)
    pub dedicated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGameServerData.os)
    pub os: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameServerData.game_data)
    pub game_data: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameServerData.game_type)
    pub game_type: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameServerData.map)
    pub map: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameServerData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerData {
    fn default() -> &'a CMsgGameServerData {
        <CMsgGameServerData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameServerData {
    pub fn new() -> CMsgGameServerData {
        ::std::default::Default::default()
    }

    // optional uint32 revision = 24;

    pub fn revision(&self) -> u32 {
        self.revision.unwrap_or(0)
    }

    pub fn clear_revision(&mut self) {
        self.revision = ::std::option::Option::None;
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: u32) {
        self.revision = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_gs = 1;

    pub fn steam_id_gs(&self) -> u64 {
        self.steam_id_gs.unwrap_or(0)
    }

    pub fn clear_steam_id_gs(&mut self) {
        self.steam_id_gs = ::std::option::Option::None;
    }

    pub fn has_steam_id_gs(&self) -> bool {
        self.steam_id_gs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_gs(&mut self, v: u64) {
        self.steam_id_gs = ::std::option::Option::Some(v);
    }

    // optional uint32 query_port = 3;

    pub fn query_port(&self) -> u32 {
        self.query_port.unwrap_or(0)
    }

    pub fn clear_query_port(&mut self) {
        self.query_port = ::std::option::Option::None;
    }

    pub fn has_query_port(&self) -> bool {
        self.query_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query_port(&mut self, v: u32) {
        self.query_port = ::std::option::Option::Some(v);
    }

    // optional uint32 game_port = 4;

    pub fn game_port(&self) -> u32 {
        self.game_port.unwrap_or(0)
    }

    pub fn clear_game_port(&mut self) {
        self.game_port = ::std::option::Option::None;
    }

    pub fn has_game_port(&self) -> bool {
        self.game_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_port(&mut self, v: u32) {
        self.game_port = ::std::option::Option::Some(v);
    }

    // optional uint32 spectator_port = 5;

    pub fn spectator_port(&self) -> u32 {
        self.spectator_port.unwrap_or(0)
    }

    pub fn clear_spectator_port(&mut self) {
        self.spectator_port = ::std::option::Option::None;
    }

    pub fn has_spectator_port(&self) -> bool {
        self.spectator_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spectator_port(&mut self, v: u32) {
        self.spectator_port = ::std::option::Option::Some(v);
    }

    // optional string server_name = 22;

    pub fn server_name(&self) -> &str {
        match self.server_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_server_name(&mut self) {
        self.server_name = ::std::option::Option::None;
    }

    pub fn has_server_name(&self) -> bool {
        self.server_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_name(&mut self, v: ::std::string::String) {
        self.server_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_name(&mut self) -> &mut ::std::string::String {
        if self.server_name.is_none() {
            self.server_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.server_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_name(&mut self) -> ::std::string::String {
        self.server_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string game_description = 29;

    pub fn game_description(&self) -> &str {
        match self.game_description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_description(&mut self) {
        self.game_description = ::std::option::Option::None;
    }

    pub fn has_game_description(&self) -> bool {
        self.game_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_description(&mut self, v: ::std::string::String) {
        self.game_description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_description(&mut self) -> &mut ::std::string::String {
        if self.game_description.is_none() {
            self.game_description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_description(&mut self) -> ::std::string::String {
        self.game_description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string spectator_server_name = 27;

    pub fn spectator_server_name(&self) -> &str {
        match self.spectator_server_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_spectator_server_name(&mut self) {
        self.spectator_server_name = ::std::option::Option::None;
    }

    pub fn has_spectator_server_name(&self) -> bool {
        self.spectator_server_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spectator_server_name(&mut self, v: ::std::string::String) {
        self.spectator_server_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spectator_server_name(&mut self) -> &mut ::std::string::String {
        if self.spectator_server_name.is_none() {
            self.spectator_server_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.spectator_server_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_spectator_server_name(&mut self) -> ::std::string::String {
        self.spectator_server_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed32 fake_ip = 28;

    pub fn fake_ip(&self) -> u32 {
        self.fake_ip.unwrap_or(0)
    }

    pub fn clear_fake_ip(&mut self) {
        self.fake_ip = ::std::option::Option::None;
    }

    pub fn has_fake_ip(&self) -> bool {
        self.fake_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fake_ip(&mut self, v: u32) {
        self.fake_ip = ::std::option::Option::Some(v);
    }

    // optional bytes sdr_login = 26;

    pub fn sdr_login(&self) -> &[u8] {
        match self.sdr_login.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sdr_login(&mut self) {
        self.sdr_login = ::std::option::Option::None;
    }

    pub fn has_sdr_login(&self) -> bool {
        self.sdr_login.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdr_login(&mut self, v: ::std::vec::Vec<u8>) {
        self.sdr_login = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sdr_login(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sdr_login.is_none() {
            self.sdr_login = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.sdr_login.as_mut().unwrap()
    }

    // Take field
    pub fn take_sdr_login(&mut self) -> ::std::vec::Vec<u8> {
        self.sdr_login.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 app_id = 6;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional string gamedir = 7;

    pub fn gamedir(&self) -> &str {
        match self.gamedir.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_gamedir(&mut self) {
        self.gamedir = ::std::option::Option::None;
    }

    pub fn has_gamedir(&self) -> bool {
        self.gamedir.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gamedir(&mut self, v: ::std::string::String) {
        self.gamedir = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gamedir(&mut self) -> &mut ::std::string::String {
        if self.gamedir.is_none() {
            self.gamedir = ::std::option::Option::Some(::std::string::String::new());
        }
        self.gamedir.as_mut().unwrap()
    }

    // Take field
    pub fn take_gamedir(&mut self) -> ::std::string::String {
        self.gamedir.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string version = 8;

    pub fn version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string product = 9;

    pub fn product(&self) -> &str {
        match self.product.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_product(&mut self) {
        self.product = ::std::option::Option::None;
    }

    pub fn has_product(&self) -> bool {
        self.product.is_some()
    }

    // Param is passed by value, moved
    pub fn set_product(&mut self, v: ::std::string::String) {
        self.product = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_product(&mut self) -> &mut ::std::string::String {
        if self.product.is_none() {
            self.product = ::std::option::Option::Some(::std::string::String::new());
        }
        self.product.as_mut().unwrap()
    }

    // Take field
    pub fn take_product(&mut self) -> ::std::string::String {
        self.product.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string region = 10;

    pub fn region(&self) -> &str {
        match self.region.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_region(&mut self) {
        self.region = ::std::option::Option::None;
    }

    pub fn has_region(&self) -> bool {
        self.region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region(&mut self, v: ::std::string::String) {
        self.region = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region(&mut self) -> &mut ::std::string::String {
        if self.region.is_none() {
            self.region = ::std::option::Option::Some(::std::string::String::new());
        }
        self.region.as_mut().unwrap()
    }

    // Take field
    pub fn take_region(&mut self) -> ::std::string::String {
        self.region.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 max_players = 12;

    pub fn max_players(&self) -> u32 {
        self.max_players.unwrap_or(0)
    }

    pub fn clear_max_players(&mut self) {
        self.max_players = ::std::option::Option::None;
    }

    pub fn has_max_players(&self) -> bool {
        self.max_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_players(&mut self, v: u32) {
        self.max_players = ::std::option::Option::Some(v);
    }

    // optional uint32 bot_count = 13;

    pub fn bot_count(&self) -> u32 {
        self.bot_count.unwrap_or(0)
    }

    pub fn clear_bot_count(&mut self) {
        self.bot_count = ::std::option::Option::None;
    }

    pub fn has_bot_count(&self) -> bool {
        self.bot_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bot_count(&mut self, v: u32) {
        self.bot_count = ::std::option::Option::Some(v);
    }

    // optional bool password = 14;

    pub fn password(&self) -> bool {
        self.password.unwrap_or(false)
    }

    pub fn clear_password(&mut self) {
        self.password = ::std::option::Option::None;
    }

    pub fn has_password(&self) -> bool {
        self.password.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: bool) {
        self.password = ::std::option::Option::Some(v);
    }

    // optional bool secure = 15;

    pub fn secure(&self) -> bool {
        self.secure.unwrap_or(false)
    }

    pub fn clear_secure(&mut self) {
        self.secure = ::std::option::Option::None;
    }

    pub fn has_secure(&self) -> bool {
        self.secure.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secure(&mut self, v: bool) {
        self.secure = ::std::option::Option::Some(v);
    }

    // optional bool dedicated = 16;

    pub fn dedicated(&self) -> bool {
        self.dedicated.unwrap_or(false)
    }

    pub fn clear_dedicated(&mut self) {
        self.dedicated = ::std::option::Option::None;
    }

    pub fn has_dedicated(&self) -> bool {
        self.dedicated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dedicated(&mut self, v: bool) {
        self.dedicated = ::std::option::Option::Some(v);
    }

    // optional string os = 17;

    pub fn os(&self) -> &str {
        match self.os.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_os(&mut self) {
        self.os = ::std::option::Option::None;
    }

    pub fn has_os(&self) -> bool {
        self.os.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os(&mut self, v: ::std::string::String) {
        self.os = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os(&mut self) -> &mut ::std::string::String {
        if self.os.is_none() {
            self.os = ::std::option::Option::Some(::std::string::String::new());
        }
        self.os.as_mut().unwrap()
    }

    // Take field
    pub fn take_os(&mut self) -> ::std::string::String {
        self.os.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string game_data = 18;

    pub fn game_data(&self) -> &str {
        match self.game_data.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_data(&mut self) {
        self.game_data = ::std::option::Option::None;
    }

    pub fn has_game_data(&self) -> bool {
        self.game_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_data(&mut self, v: ::std::string::String) {
        self.game_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_data(&mut self) -> &mut ::std::string::String {
        if self.game_data.is_none() {
            self.game_data = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_data(&mut self) -> ::std::string::String {
        self.game_data.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string game_type = 20;

    pub fn game_type(&self) -> &str {
        match self.game_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_type(&mut self) {
        self.game_type = ::std::option::Option::None;
    }

    pub fn has_game_type(&self) -> bool {
        self.game_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_type(&mut self, v: ::std::string::String) {
        self.game_type = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_type(&mut self) -> &mut ::std::string::String {
        if self.game_type.is_none() {
            self.game_type = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_type(&mut self) -> ::std::string::String {
        self.game_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string map = 21;

    pub fn map(&self) -> &str {
        match self.map.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_map(&mut self) {
        self.map = ::std::option::Option::None;
    }

    pub fn has_map(&self) -> bool {
        self.map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map(&mut self, v: ::std::string::String) {
        self.map = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map(&mut self) -> &mut ::std::string::String {
        if self.map.is_none() {
            self.map = ::std::option::Option::Some(::std::string::String::new());
        }
        self.map.as_mut().unwrap()
    }

    // Take field
    pub fn take_map(&mut self) -> ::std::string::String {
        self.map.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(25);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "revision",
            |m: &CMsgGameServerData| { &m.revision },
            |m: &mut CMsgGameServerData| { &mut m.revision },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_gs",
            |m: &CMsgGameServerData| { &m.steam_id_gs },
            |m: &mut CMsgGameServerData| { &mut m.steam_id_gs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "query_port",
            |m: &CMsgGameServerData| { &m.query_port },
            |m: &mut CMsgGameServerData| { &mut m.query_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_port",
            |m: &CMsgGameServerData| { &m.game_port },
            |m: &mut CMsgGameServerData| { &mut m.game_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "spectator_port",
            |m: &CMsgGameServerData| { &m.spectator_port },
            |m: &mut CMsgGameServerData| { &mut m.spectator_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_name",
            |m: &CMsgGameServerData| { &m.server_name },
            |m: &mut CMsgGameServerData| { &mut m.server_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_description",
            |m: &CMsgGameServerData| { &m.game_description },
            |m: &mut CMsgGameServerData| { &mut m.game_description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "spectator_server_name",
            |m: &CMsgGameServerData| { &m.spectator_server_name },
            |m: &mut CMsgGameServerData| { &mut m.spectator_server_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fake_ip",
            |m: &CMsgGameServerData| { &m.fake_ip },
            |m: &mut CMsgGameServerData| { &mut m.fake_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sdr_login",
            |m: &CMsgGameServerData| { &m.sdr_login },
            |m: &mut CMsgGameServerData| { &mut m.sdr_login },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgGameServerData| { &m.app_id },
            |m: &mut CMsgGameServerData| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gamedir",
            |m: &CMsgGameServerData| { &m.gamedir },
            |m: &mut CMsgGameServerData| { &mut m.gamedir },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgGameServerData| { &m.version },
            |m: &mut CMsgGameServerData| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "product",
            |m: &CMsgGameServerData| { &m.product },
            |m: &mut CMsgGameServerData| { &mut m.product },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "region",
            |m: &CMsgGameServerData| { &m.region },
            |m: &mut CMsgGameServerData| { &mut m.region },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "players",
            |m: &CMsgGameServerData| { &m.players },
            |m: &mut CMsgGameServerData| { &mut m.players },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_players",
            |m: &CMsgGameServerData| { &m.max_players },
            |m: &mut CMsgGameServerData| { &mut m.max_players },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bot_count",
            |m: &CMsgGameServerData| { &m.bot_count },
            |m: &mut CMsgGameServerData| { &mut m.bot_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "password",
            |m: &CMsgGameServerData| { &m.password },
            |m: &mut CMsgGameServerData| { &mut m.password },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "secure",
            |m: &CMsgGameServerData| { &m.secure },
            |m: &mut CMsgGameServerData| { &mut m.secure },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dedicated",
            |m: &CMsgGameServerData| { &m.dedicated },
            |m: &mut CMsgGameServerData| { &mut m.dedicated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "os",
            |m: &CMsgGameServerData| { &m.os },
            |m: &mut CMsgGameServerData| { &mut m.os },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_data",
            |m: &CMsgGameServerData| { &m.game_data },
            |m: &mut CMsgGameServerData| { &mut m.game_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_type",
            |m: &CMsgGameServerData| { &m.game_type },
            |m: &mut CMsgGameServerData| { &mut m.game_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map",
            |m: &CMsgGameServerData| { &m.map },
            |m: &mut CMsgGameServerData| { &mut m.map },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGameServerData>(
            "CMsgGameServerData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGameServerData {
    const NAME: &'static str = "CMsgGameServerData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                192 => {
                    self.revision = ::std::option::Option::Some(is.read_uint32()?);
                },
                9 => {
                    self.steam_id_gs = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.query_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.game_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.spectator_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                178 => {
                    self.server_name = ::std::option::Option::Some(is.read_string()?);
                },
                234 => {
                    self.game_description = ::std::option::Option::Some(is.read_string()?);
                },
                218 => {
                    self.spectator_server_name = ::std::option::Option::Some(is.read_string()?);
                },
                229 => {
                    self.fake_ip = ::std::option::Option::Some(is.read_fixed32()?);
                },
                210 => {
                    self.sdr_login = ::std::option::Option::Some(is.read_bytes()?);
                },
                48 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.gamedir = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.version = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.product = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.region = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    self.players.push(is.read_message()?);
                },
                96 => {
                    self.max_players = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.bot_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.password = ::std::option::Option::Some(is.read_bool()?);
                },
                120 => {
                    self.secure = ::std::option::Option::Some(is.read_bool()?);
                },
                128 => {
                    self.dedicated = ::std::option::Option::Some(is.read_bool()?);
                },
                138 => {
                    self.os = ::std::option::Option::Some(is.read_string()?);
                },
                146 => {
                    self.game_data = ::std::option::Option::Some(is.read_string()?);
                },
                162 => {
                    self.game_type = ::std::option::Option::Some(is.read_string()?);
                },
                170 => {
                    self.map = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.revision {
            my_size += ::protobuf::rt::uint32_size(24, v);
        }
        if let Some(v) = self.steam_id_gs {
            my_size += 1 + 8;
        }
        if let Some(v) = self.query_port {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.game_port {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.spectator_port {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.server_name.as_ref() {
            my_size += ::protobuf::rt::string_size(22, &v);
        }
        if let Some(v) = self.game_description.as_ref() {
            my_size += ::protobuf::rt::string_size(29, &v);
        }
        if let Some(v) = self.spectator_server_name.as_ref() {
            my_size += ::protobuf::rt::string_size(27, &v);
        }
        if let Some(v) = self.fake_ip {
            my_size += 2 + 4;
        }
        if let Some(v) = self.sdr_login.as_ref() {
            my_size += ::protobuf::rt::bytes_size(26, &v);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.gamedir.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.product.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.region.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.max_players {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.bot_count {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.password {
            my_size += 1 + 1;
        }
        if let Some(v) = self.secure {
            my_size += 1 + 1;
        }
        if let Some(v) = self.dedicated {
            my_size += 2 + 1;
        }
        if let Some(v) = self.os.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        if let Some(v) = self.game_data.as_ref() {
            my_size += ::protobuf::rt::string_size(18, &v);
        }
        if let Some(v) = self.game_type.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        if let Some(v) = self.map.as_ref() {
            my_size += ::protobuf::rt::string_size(21, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.revision {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.steam_id_gs {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.query_port {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_port {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.spectator_port {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.server_name.as_ref() {
            os.write_string(22, v)?;
        }
        if let Some(v) = self.game_description.as_ref() {
            os.write_string(29, v)?;
        }
        if let Some(v) = self.spectator_server_name.as_ref() {
            os.write_string(27, v)?;
        }
        if let Some(v) = self.fake_ip {
            os.write_fixed32(28, v)?;
        }
        if let Some(v) = self.sdr_login.as_ref() {
            os.write_bytes(26, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.gamedir.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.version.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.product.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.region.as_ref() {
            os.write_string(10, v)?;
        }
        for v in &self.players {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        if let Some(v) = self.max_players {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.bot_count {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.password {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.secure {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.dedicated {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.os.as_ref() {
            os.write_string(17, v)?;
        }
        if let Some(v) = self.game_data.as_ref() {
            os.write_string(18, v)?;
        }
        if let Some(v) = self.game_type.as_ref() {
            os.write_string(20, v)?;
        }
        if let Some(v) = self.map.as_ref() {
            os.write_string(21, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameServerData {
        CMsgGameServerData::new()
    }

    fn clear(&mut self) {
        self.revision = ::std::option::Option::None;
        self.steam_id_gs = ::std::option::Option::None;
        self.query_port = ::std::option::Option::None;
        self.game_port = ::std::option::Option::None;
        self.spectator_port = ::std::option::Option::None;
        self.server_name = ::std::option::Option::None;
        self.game_description = ::std::option::Option::None;
        self.spectator_server_name = ::std::option::Option::None;
        self.fake_ip = ::std::option::Option::None;
        self.sdr_login = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.gamedir = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.product = ::std::option::Option::None;
        self.region = ::std::option::Option::None;
        self.players.clear();
        self.max_players = ::std::option::Option::None;
        self.bot_count = ::std::option::Option::None;
        self.password = ::std::option::Option::None;
        self.secure = ::std::option::Option::None;
        self.dedicated = ::std::option::Option::None;
        self.os = ::std::option::Option::None;
        self.game_data = ::std::option::Option::None;
        self.game_type = ::std::option::Option::None;
        self.map = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameServerData {
        static instance: CMsgGameServerData = CMsgGameServerData {
            revision: ::std::option::Option::None,
            steam_id_gs: ::std::option::Option::None,
            query_port: ::std::option::Option::None,
            game_port: ::std::option::Option::None,
            spectator_port: ::std::option::Option::None,
            server_name: ::std::option::Option::None,
            game_description: ::std::option::Option::None,
            spectator_server_name: ::std::option::Option::None,
            fake_ip: ::std::option::Option::None,
            sdr_login: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            gamedir: ::std::option::Option::None,
            version: ::std::option::Option::None,
            product: ::std::option::Option::None,
            region: ::std::option::Option::None,
            players: ::std::vec::Vec::new(),
            max_players: ::std::option::Option::None,
            bot_count: ::std::option::Option::None,
            password: ::std::option::Option::None,
            secure: ::std::option::Option::None,
            dedicated: ::std::option::Option::None,
            os: ::std::option::Option::None,
            game_data: ::std::option::Option::None,
            game_type: ::std::option::Option::None,
            map: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGameServerData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGameServerData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGameServerData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameServerData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGameServerData`
pub mod cmsg_game_server_data {
    // @@protoc_insertion_point(message:CMsgGameServerData.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:CMsgGameServerData.Player.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGameServerData.Player.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional fixed64 steam_id = 1;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "steam_id",
                |m: &Player| { &m.steam_id },
                |m: &mut Player| { &mut m.steam_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Player>(
                "CMsgGameServerData.Player",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.steam_id {
                os.write_fixed64(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                steam_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Player {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGameServerData.Player").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Player {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Player {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgGameServerRemove)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameServerRemove {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameServerRemove.legacy_steam_id_gs)
    pub legacy_steam_id_gs: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGameServerRemove.legacy_query_port)
    pub legacy_query_port: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameServerRemove.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerRemove {
    fn default() -> &'a CMsgGameServerRemove {
        <CMsgGameServerRemove as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameServerRemove {
    pub fn new() -> CMsgGameServerRemove {
        ::std::default::Default::default()
    }

    // optional fixed64 legacy_steam_id_gs = 1;

    pub fn legacy_steam_id_gs(&self) -> u64 {
        self.legacy_steam_id_gs.unwrap_or(0)
    }

    pub fn clear_legacy_steam_id_gs(&mut self) {
        self.legacy_steam_id_gs = ::std::option::Option::None;
    }

    pub fn has_legacy_steam_id_gs(&self) -> bool {
        self.legacy_steam_id_gs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_steam_id_gs(&mut self, v: u64) {
        self.legacy_steam_id_gs = ::std::option::Option::Some(v);
    }

    // optional uint32 legacy_query_port = 3;

    pub fn legacy_query_port(&self) -> u32 {
        self.legacy_query_port.unwrap_or(0)
    }

    pub fn clear_legacy_query_port(&mut self) {
        self.legacy_query_port = ::std::option::Option::None;
    }

    pub fn has_legacy_query_port(&self) -> bool {
        self.legacy_query_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_query_port(&mut self, v: u32) {
        self.legacy_query_port = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "legacy_steam_id_gs",
            |m: &CMsgGameServerRemove| { &m.legacy_steam_id_gs },
            |m: &mut CMsgGameServerRemove| { &mut m.legacy_steam_id_gs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "legacy_query_port",
            |m: &CMsgGameServerRemove| { &m.legacy_query_port },
            |m: &mut CMsgGameServerRemove| { &mut m.legacy_query_port },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGameServerRemove>(
            "CMsgGameServerRemove",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGameServerRemove {
    const NAME: &'static str = "CMsgGameServerRemove";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.legacy_steam_id_gs = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.legacy_query_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.legacy_steam_id_gs {
            my_size += 1 + 8;
        }
        if let Some(v) = self.legacy_query_port {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.legacy_steam_id_gs {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.legacy_query_port {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameServerRemove {
        CMsgGameServerRemove::new()
    }

    fn clear(&mut self) {
        self.legacy_steam_id_gs = ::std::option::Option::None;
        self.legacy_query_port = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameServerRemove {
        static instance: CMsgGameServerRemove = CMsgGameServerRemove {
            legacy_steam_id_gs: ::std::option::Option::None,
            legacy_query_port: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGameServerRemove {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGameServerRemove").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGameServerRemove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameServerRemove {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientGMSServerQuery)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGMSServerQuery {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGMSServerQuery.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGMSServerQuery.geo_location_ip)
    pub geo_location_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGMSServerQuery.region_code)
    pub region_code: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGMSServerQuery.filter_text)
    pub filter_text: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientGMSServerQuery.max_servers)
    pub max_servers: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGMSServerQuery.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGMSServerQuery {
    fn default() -> &'a CMsgClientGMSServerQuery {
        <CMsgClientGMSServerQuery as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGMSServerQuery {
    pub fn new() -> CMsgClientGMSServerQuery {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 geo_location_ip = 2;

    pub fn geo_location_ip(&self) -> u32 {
        self.geo_location_ip.unwrap_or(0)
    }

    pub fn clear_geo_location_ip(&mut self) {
        self.geo_location_ip = ::std::option::Option::None;
    }

    pub fn has_geo_location_ip(&self) -> bool {
        self.geo_location_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_geo_location_ip(&mut self, v: u32) {
        self.geo_location_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 region_code = 3;

    pub fn region_code(&self) -> u32 {
        self.region_code.unwrap_or(0)
    }

    pub fn clear_region_code(&mut self) {
        self.region_code = ::std::option::Option::None;
    }

    pub fn has_region_code(&self) -> bool {
        self.region_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_code(&mut self, v: u32) {
        self.region_code = ::std::option::Option::Some(v);
    }

    // optional string filter_text = 4;

    pub fn filter_text(&self) -> &str {
        match self.filter_text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filter_text(&mut self) {
        self.filter_text = ::std::option::Option::None;
    }

    pub fn has_filter_text(&self) -> bool {
        self.filter_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter_text(&mut self, v: ::std::string::String) {
        self.filter_text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter_text(&mut self) -> &mut ::std::string::String {
        if self.filter_text.is_none() {
            self.filter_text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filter_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_filter_text(&mut self) -> ::std::string::String {
        self.filter_text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 max_servers = 5;

    pub fn max_servers(&self) -> u32 {
        self.max_servers.unwrap_or(0)
    }

    pub fn clear_max_servers(&mut self) {
        self.max_servers = ::std::option::Option::None;
    }

    pub fn has_max_servers(&self) -> bool {
        self.max_servers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_servers(&mut self, v: u32) {
        self.max_servers = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientGMSServerQuery| { &m.app_id },
            |m: &mut CMsgClientGMSServerQuery| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "geo_location_ip",
            |m: &CMsgClientGMSServerQuery| { &m.geo_location_ip },
            |m: &mut CMsgClientGMSServerQuery| { &mut m.geo_location_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "region_code",
            |m: &CMsgClientGMSServerQuery| { &m.region_code },
            |m: &mut CMsgClientGMSServerQuery| { &mut m.region_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "filter_text",
            |m: &CMsgClientGMSServerQuery| { &m.filter_text },
            |m: &mut CMsgClientGMSServerQuery| { &mut m.filter_text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_servers",
            |m: &CMsgClientGMSServerQuery| { &m.max_servers },
            |m: &mut CMsgClientGMSServerQuery| { &mut m.max_servers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientGMSServerQuery>(
            "CMsgClientGMSServerQuery",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientGMSServerQuery {
    const NAME: &'static str = "CMsgClientGMSServerQuery";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.geo_location_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.region_code = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.filter_text = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.max_servers = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.geo_location_ip {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.region_code {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.filter_text.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.max_servers {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.geo_location_ip {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.region_code {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.filter_text.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.max_servers {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGMSServerQuery {
        CMsgClientGMSServerQuery::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.geo_location_ip = ::std::option::Option::None;
        self.region_code = ::std::option::Option::None;
        self.filter_text = ::std::option::Option::None;
        self.max_servers = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGMSServerQuery {
        static instance: CMsgClientGMSServerQuery = CMsgClientGMSServerQuery {
            app_id: ::std::option::Option::None,
            geo_location_ip: ::std::option::Option::None,
            region_code: ::std::option::Option::None,
            filter_text: ::std::option::Option::None,
            max_servers: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientGMSServerQuery {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientGMSServerQuery").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientGMSServerQuery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGMSServerQuery {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGMSClientServerQueryResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGMSClientServerQueryResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.servers)
    pub servers: ::std::vec::Vec<cmsg_gmsclient_server_query_response::Server>,
    // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.error)
    pub error: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGMSClientServerQueryResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGMSClientServerQueryResponse {
    fn default() -> &'a CMsgGMSClientServerQueryResponse {
        <CMsgGMSClientServerQueryResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGMSClientServerQueryResponse {
    pub fn new() -> CMsgGMSClientServerQueryResponse {
        ::std::default::Default::default()
    }

    // optional string error = 2;

    pub fn error(&self) -> &str {
        match self.error.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        if self.error.is_none() {
            self.error = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        self.error.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "servers",
            |m: &CMsgGMSClientServerQueryResponse| { &m.servers },
            |m: &mut CMsgGMSClientServerQueryResponse| { &mut m.servers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error",
            |m: &CMsgGMSClientServerQueryResponse| { &m.error },
            |m: &mut CMsgGMSClientServerQueryResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGMSClientServerQueryResponse>(
            "CMsgGMSClientServerQueryResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGMSClientServerQueryResponse {
    const NAME: &'static str = "CMsgGMSClientServerQueryResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.servers.push(is.read_message()?);
                },
                18 => {
                    self.error = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.servers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.error.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.servers {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.error.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGMSClientServerQueryResponse {
        CMsgGMSClientServerQueryResponse::new()
    }

    fn clear(&mut self) {
        self.servers.clear();
        self.error = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGMSClientServerQueryResponse {
        static instance: CMsgGMSClientServerQueryResponse = CMsgGMSClientServerQueryResponse {
            servers: ::std::vec::Vec::new(),
            error: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGMSClientServerQueryResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGMSClientServerQueryResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGMSClientServerQueryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGMSClientServerQueryResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGMSClientServerQueryResponse`
pub mod cmsg_gmsclient_server_query_response {
    // @@protoc_insertion_point(message:CMsgGMSClientServerQueryResponse.Server)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Server {
        // message fields
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.deprecated_server_ip)
        pub deprecated_server_ip: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.query_port)
        pub query_port: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.auth_players)
        pub auth_players: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGMSClientServerQueryResponse.Server.server_ip)
        pub server_ip: ::protobuf::MessageField<super::super::steammessages_base::CMsgIPAddress>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGMSClientServerQueryResponse.Server.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Server {
        fn default() -> &'a Server {
            <Server as ::protobuf::Message>::default_instance()
        }
    }

    impl Server {
        pub fn new() -> Server {
            ::std::default::Default::default()
        }

        // optional uint32 deprecated_server_ip = 1;

        pub fn deprecated_server_ip(&self) -> u32 {
            self.deprecated_server_ip.unwrap_or(0)
        }

        pub fn clear_deprecated_server_ip(&mut self) {
            self.deprecated_server_ip = ::std::option::Option::None;
        }

        pub fn has_deprecated_server_ip(&self) -> bool {
            self.deprecated_server_ip.is_some()
        }

        // Param is passed by value, moved
        pub fn set_deprecated_server_ip(&mut self, v: u32) {
            self.deprecated_server_ip = ::std::option::Option::Some(v);
        }

        // optional uint32 query_port = 2;

        pub fn query_port(&self) -> u32 {
            self.query_port.unwrap_or(0)
        }

        pub fn clear_query_port(&mut self) {
            self.query_port = ::std::option::Option::None;
        }

        pub fn has_query_port(&self) -> bool {
            self.query_port.is_some()
        }

        // Param is passed by value, moved
        pub fn set_query_port(&mut self, v: u32) {
            self.query_port = ::std::option::Option::Some(v);
        }

        // optional uint32 auth_players = 3;

        pub fn auth_players(&self) -> u32 {
            self.auth_players.unwrap_or(0)
        }

        pub fn clear_auth_players(&mut self) {
            self.auth_players = ::std::option::Option::None;
        }

        pub fn has_auth_players(&self) -> bool {
            self.auth_players.is_some()
        }

        // Param is passed by value, moved
        pub fn set_auth_players(&mut self, v: u32) {
            self.auth_players = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "deprecated_server_ip",
                |m: &Server| { &m.deprecated_server_ip },
                |m: &mut Server| { &mut m.deprecated_server_ip },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "query_port",
                |m: &Server| { &m.query_port },
                |m: &mut Server| { &mut m.query_port },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "auth_players",
                |m: &Server| { &m.auth_players },
                |m: &mut Server| { &mut m.auth_players },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::steammessages_base::CMsgIPAddress>(
                "server_ip",
                |m: &Server| { &m.server_ip },
                |m: &mut Server| { &mut m.server_ip },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Server>(
                "CMsgGMSClientServerQueryResponse.Server",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Server {
        const NAME: &'static str = "Server";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.deprecated_server_ip = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.query_port = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.auth_players = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    34 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.server_ip)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.deprecated_server_ip {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.query_port {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.auth_players {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.server_ip.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.deprecated_server_ip {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.query_port {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.auth_players {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.server_ip.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Server {
            Server::new()
        }

        fn clear(&mut self) {
            self.deprecated_server_ip = ::std::option::Option::None;
            self.query_port = ::std::option::Option::None;
            self.auth_players = ::std::option::Option::None;
            self.server_ip.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Server {
            static instance: Server = Server {
                deprecated_server_ip: ::std::option::Option::None,
                query_port: ::std::option::Option::None,
                auth_players: ::std::option::Option::None,
                server_ip: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Server {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGMSClientServerQueryResponse.Server").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Server {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Server {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgGameServerOutOfDate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameServerOutOfDate {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameServerOutOfDate.steam_id_gs)
    pub steam_id_gs: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGameServerOutOfDate.reject)
    pub reject: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGameServerOutOfDate.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameServerOutOfDate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerOutOfDate {
    fn default() -> &'a CMsgGameServerOutOfDate {
        <CMsgGameServerOutOfDate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameServerOutOfDate {
    pub fn new() -> CMsgGameServerOutOfDate {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_gs = 1;

    pub fn steam_id_gs(&self) -> u64 {
        self.steam_id_gs.unwrap_or(0)
    }

    pub fn clear_steam_id_gs(&mut self) {
        self.steam_id_gs = ::std::option::Option::None;
    }

    pub fn has_steam_id_gs(&self) -> bool {
        self.steam_id_gs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_gs(&mut self, v: u64) {
        self.steam_id_gs = ::std::option::Option::Some(v);
    }

    // optional bool reject = 2;

    pub fn reject(&self) -> bool {
        self.reject.unwrap_or(false)
    }

    pub fn clear_reject(&mut self) {
        self.reject = ::std::option::Option::None;
    }

    pub fn has_reject(&self) -> bool {
        self.reject.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reject(&mut self, v: bool) {
        self.reject = ::std::option::Option::Some(v);
    }

    // optional string message = 3;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_gs",
            |m: &CMsgGameServerOutOfDate| { &m.steam_id_gs },
            |m: &mut CMsgGameServerOutOfDate| { &mut m.steam_id_gs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reject",
            |m: &CMsgGameServerOutOfDate| { &m.reject },
            |m: &mut CMsgGameServerOutOfDate| { &mut m.reject },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &CMsgGameServerOutOfDate| { &m.message },
            |m: &mut CMsgGameServerOutOfDate| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGameServerOutOfDate>(
            "CMsgGameServerOutOfDate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGameServerOutOfDate {
    const NAME: &'static str = "CMsgGameServerOutOfDate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id_gs = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.reject = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_gs {
            my_size += 1 + 8;
        }
        if let Some(v) = self.reject {
            my_size += 1 + 1;
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id_gs {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.reject {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameServerOutOfDate {
        CMsgGameServerOutOfDate::new()
    }

    fn clear(&mut self) {
        self.steam_id_gs = ::std::option::Option::None;
        self.reject = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameServerOutOfDate {
        static instance: CMsgGameServerOutOfDate = CMsgGameServerOutOfDate {
            steam_id_gs: ::std::option::Option::None,
            reject: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGameServerOutOfDate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGameServerOutOfDate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGameServerOutOfDate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameServerOutOfDate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRedeemGuestPass)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRedeemGuestPass {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRedeemGuestPass.guest_pass_id)
    pub guest_pass_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRedeemGuestPass.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRedeemGuestPass {
    fn default() -> &'a CMsgClientRedeemGuestPass {
        <CMsgClientRedeemGuestPass as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRedeemGuestPass {
    pub fn new() -> CMsgClientRedeemGuestPass {
        ::std::default::Default::default()
    }

    // optional fixed64 guest_pass_id = 1;

    pub fn guest_pass_id(&self) -> u64 {
        self.guest_pass_id.unwrap_or(0)
    }

    pub fn clear_guest_pass_id(&mut self) {
        self.guest_pass_id = ::std::option::Option::None;
    }

    pub fn has_guest_pass_id(&self) -> bool {
        self.guest_pass_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guest_pass_id(&mut self, v: u64) {
        self.guest_pass_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guest_pass_id",
            |m: &CMsgClientRedeemGuestPass| { &m.guest_pass_id },
            |m: &mut CMsgClientRedeemGuestPass| { &mut m.guest_pass_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRedeemGuestPass>(
            "CMsgClientRedeemGuestPass",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientRedeemGuestPass {
    const NAME: &'static str = "CMsgClientRedeemGuestPass";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.guest_pass_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guest_pass_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guest_pass_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRedeemGuestPass {
        CMsgClientRedeemGuestPass::new()
    }

    fn clear(&mut self) {
        self.guest_pass_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRedeemGuestPass {
        static instance: CMsgClientRedeemGuestPass = CMsgClientRedeemGuestPass {
            guest_pass_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientRedeemGuestPass {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRedeemGuestPass").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRedeemGuestPass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRedeemGuestPass {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRedeemGuestPassResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRedeemGuestPassResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRedeemGuestPassResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRedeemGuestPassResponse.package_id)
    pub package_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRedeemGuestPassResponse.must_own_appid)
    pub must_own_appid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRedeemGuestPassResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRedeemGuestPassResponse {
    fn default() -> &'a CMsgClientRedeemGuestPassResponse {
        <CMsgClientRedeemGuestPassResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRedeemGuestPassResponse {
    pub fn new() -> CMsgClientRedeemGuestPassResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 package_id = 2;

    pub fn package_id(&self) -> u32 {
        self.package_id.unwrap_or(0)
    }

    pub fn clear_package_id(&mut self) {
        self.package_id = ::std::option::Option::None;
    }

    pub fn has_package_id(&self) -> bool {
        self.package_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_package_id(&mut self, v: u32) {
        self.package_id = ::std::option::Option::Some(v);
    }

    // optional uint32 must_own_appid = 3;

    pub fn must_own_appid(&self) -> u32 {
        self.must_own_appid.unwrap_or(0)
    }

    pub fn clear_must_own_appid(&mut self) {
        self.must_own_appid = ::std::option::Option::None;
    }

    pub fn has_must_own_appid(&self) -> bool {
        self.must_own_appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_must_own_appid(&mut self, v: u32) {
        self.must_own_appid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientRedeemGuestPassResponse| { &m.eresult },
            |m: &mut CMsgClientRedeemGuestPassResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "package_id",
            |m: &CMsgClientRedeemGuestPassResponse| { &m.package_id },
            |m: &mut CMsgClientRedeemGuestPassResponse| { &mut m.package_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "must_own_appid",
            |m: &CMsgClientRedeemGuestPassResponse| { &m.must_own_appid },
            |m: &mut CMsgClientRedeemGuestPassResponse| { &mut m.must_own_appid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRedeemGuestPassResponse>(
            "CMsgClientRedeemGuestPassResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientRedeemGuestPassResponse {
    const NAME: &'static str = "CMsgClientRedeemGuestPassResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.package_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.must_own_appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.package_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.must_own_appid {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.package_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.must_own_appid {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRedeemGuestPassResponse {
        CMsgClientRedeemGuestPassResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.package_id = ::std::option::Option::None;
        self.must_own_appid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRedeemGuestPassResponse {
        static instance: CMsgClientRedeemGuestPassResponse = CMsgClientRedeemGuestPassResponse {
            eresult: ::std::option::Option::None,
            package_id: ::std::option::Option::None,
            must_own_appid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientRedeemGuestPassResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRedeemGuestPassResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRedeemGuestPassResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRedeemGuestPassResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientGetClanActivityCounts)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetClanActivityCounts {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetClanActivityCounts.steamid_clans)
    pub steamid_clans: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetClanActivityCounts.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetClanActivityCounts {
    fn default() -> &'a CMsgClientGetClanActivityCounts {
        <CMsgClientGetClanActivityCounts as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetClanActivityCounts {
    pub fn new() -> CMsgClientGetClanActivityCounts {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "steamid_clans",
            |m: &CMsgClientGetClanActivityCounts| { &m.steamid_clans },
            |m: &mut CMsgClientGetClanActivityCounts| { &mut m.steamid_clans },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientGetClanActivityCounts>(
            "CMsgClientGetClanActivityCounts",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientGetClanActivityCounts {
    const NAME: &'static str = "CMsgClientGetClanActivityCounts";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.steamid_clans)?;
                },
                8 => {
                    self.steamid_clans.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.steamid_clans {
            my_size += ::protobuf::rt::uint64_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.steamid_clans {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetClanActivityCounts {
        CMsgClientGetClanActivityCounts::new()
    }

    fn clear(&mut self) {
        self.steamid_clans.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetClanActivityCounts {
        static instance: CMsgClientGetClanActivityCounts = CMsgClientGetClanActivityCounts {
            steamid_clans: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientGetClanActivityCounts {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientGetClanActivityCounts").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientGetClanActivityCounts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetClanActivityCounts {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientGetClanActivityCountsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetClanActivityCountsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetClanActivityCountsResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetClanActivityCountsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetClanActivityCountsResponse {
    fn default() -> &'a CMsgClientGetClanActivityCountsResponse {
        <CMsgClientGetClanActivityCountsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetClanActivityCountsResponse {
    pub fn new() -> CMsgClientGetClanActivityCountsResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientGetClanActivityCountsResponse| { &m.eresult },
            |m: &mut CMsgClientGetClanActivityCountsResponse| { &mut m.eresult },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientGetClanActivityCountsResponse>(
            "CMsgClientGetClanActivityCountsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientGetClanActivityCountsResponse {
    const NAME: &'static str = "CMsgClientGetClanActivityCountsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetClanActivityCountsResponse {
        CMsgClientGetClanActivityCountsResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetClanActivityCountsResponse {
        static instance: CMsgClientGetClanActivityCountsResponse = CMsgClientGetClanActivityCountsResponse {
            eresult: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientGetClanActivityCountsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientGetClanActivityCountsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientGetClanActivityCountsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetClanActivityCountsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientOGSReportString)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientOGSReportString {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientOGSReportString.accumulated)
    pub accumulated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientOGSReportString.sessionid)
    pub sessionid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientOGSReportString.severity)
    pub severity: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientOGSReportString.formatter)
    pub formatter: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientOGSReportString.varargs)
    pub varargs: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientOGSReportString.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientOGSReportString {
    fn default() -> &'a CMsgClientOGSReportString {
        <CMsgClientOGSReportString as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientOGSReportString {
    pub fn new() -> CMsgClientOGSReportString {
        ::std::default::Default::default()
    }

    // optional bool accumulated = 1;

    pub fn accumulated(&self) -> bool {
        self.accumulated.unwrap_or(false)
    }

    pub fn clear_accumulated(&mut self) {
        self.accumulated = ::std::option::Option::None;
    }

    pub fn has_accumulated(&self) -> bool {
        self.accumulated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accumulated(&mut self, v: bool) {
        self.accumulated = ::std::option::Option::Some(v);
    }

    // optional uint64 sessionid = 2;

    pub fn sessionid(&self) -> u64 {
        self.sessionid.unwrap_or(0)
    }

    pub fn clear_sessionid(&mut self) {
        self.sessionid = ::std::option::Option::None;
    }

    pub fn has_sessionid(&self) -> bool {
        self.sessionid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sessionid(&mut self, v: u64) {
        self.sessionid = ::std::option::Option::Some(v);
    }

    // optional int32 severity = 3;

    pub fn severity(&self) -> i32 {
        self.severity.unwrap_or(0)
    }

    pub fn clear_severity(&mut self) {
        self.severity = ::std::option::Option::None;
    }

    pub fn has_severity(&self) -> bool {
        self.severity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_severity(&mut self, v: i32) {
        self.severity = ::std::option::Option::Some(v);
    }

    // optional string formatter = 4;

    pub fn formatter(&self) -> &str {
        match self.formatter.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_formatter(&mut self) {
        self.formatter = ::std::option::Option::None;
    }

    pub fn has_formatter(&self) -> bool {
        self.formatter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_formatter(&mut self, v: ::std::string::String) {
        self.formatter = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_formatter(&mut self) -> &mut ::std::string::String {
        if self.formatter.is_none() {
            self.formatter = ::std::option::Option::Some(::std::string::String::new());
        }
        self.formatter.as_mut().unwrap()
    }

    // Take field
    pub fn take_formatter(&mut self) -> ::std::string::String {
        self.formatter.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes varargs = 5;

    pub fn varargs(&self) -> &[u8] {
        match self.varargs.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_varargs(&mut self) {
        self.varargs = ::std::option::Option::None;
    }

    pub fn has_varargs(&self) -> bool {
        self.varargs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_varargs(&mut self, v: ::std::vec::Vec<u8>) {
        self.varargs = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_varargs(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.varargs.is_none() {
            self.varargs = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.varargs.as_mut().unwrap()
    }

    // Take field
    pub fn take_varargs(&mut self) -> ::std::vec::Vec<u8> {
        self.varargs.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accumulated",
            |m: &CMsgClientOGSReportString| { &m.accumulated },
            |m: &mut CMsgClientOGSReportString| { &mut m.accumulated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sessionid",
            |m: &CMsgClientOGSReportString| { &m.sessionid },
            |m: &mut CMsgClientOGSReportString| { &mut m.sessionid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "severity",
            |m: &CMsgClientOGSReportString| { &m.severity },
            |m: &mut CMsgClientOGSReportString| { &mut m.severity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "formatter",
            |m: &CMsgClientOGSReportString| { &m.formatter },
            |m: &mut CMsgClientOGSReportString| { &mut m.formatter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "varargs",
            |m: &CMsgClientOGSReportString| { &m.varargs },
            |m: &mut CMsgClientOGSReportString| { &mut m.varargs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientOGSReportString>(
            "CMsgClientOGSReportString",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientOGSReportString {
    const NAME: &'static str = "CMsgClientOGSReportString";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.accumulated = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.sessionid = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.severity = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.formatter = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.varargs = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.accumulated {
            my_size += 1 + 1;
        }
        if let Some(v) = self.sessionid {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.severity {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.formatter.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.varargs.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.accumulated {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.sessionid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.severity {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.formatter.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.varargs.as_ref() {
            os.write_bytes(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientOGSReportString {
        CMsgClientOGSReportString::new()
    }

    fn clear(&mut self) {
        self.accumulated = ::std::option::Option::None;
        self.sessionid = ::std::option::Option::None;
        self.severity = ::std::option::Option::None;
        self.formatter = ::std::option::Option::None;
        self.varargs = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientOGSReportString {
        static instance: CMsgClientOGSReportString = CMsgClientOGSReportString {
            accumulated: ::std::option::Option::None,
            sessionid: ::std::option::Option::None,
            severity: ::std::option::Option::None,
            formatter: ::std::option::Option::None,
            varargs: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientOGSReportString {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientOGSReportString").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientOGSReportString {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientOGSReportString {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientOGSReportBug)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientOGSReportBug {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientOGSReportBug.sessionid)
    pub sessionid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientOGSReportBug.bugtext)
    pub bugtext: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientOGSReportBug.screenshot)
    pub screenshot: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientOGSReportBug.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientOGSReportBug {
    fn default() -> &'a CMsgClientOGSReportBug {
        <CMsgClientOGSReportBug as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientOGSReportBug {
    pub fn new() -> CMsgClientOGSReportBug {
        ::std::default::Default::default()
    }

    // optional uint64 sessionid = 1;

    pub fn sessionid(&self) -> u64 {
        self.sessionid.unwrap_or(0)
    }

    pub fn clear_sessionid(&mut self) {
        self.sessionid = ::std::option::Option::None;
    }

    pub fn has_sessionid(&self) -> bool {
        self.sessionid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sessionid(&mut self, v: u64) {
        self.sessionid = ::std::option::Option::Some(v);
    }

    // optional string bugtext = 2;

    pub fn bugtext(&self) -> &str {
        match self.bugtext.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_bugtext(&mut self) {
        self.bugtext = ::std::option::Option::None;
    }

    pub fn has_bugtext(&self) -> bool {
        self.bugtext.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bugtext(&mut self, v: ::std::string::String) {
        self.bugtext = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bugtext(&mut self) -> &mut ::std::string::String {
        if self.bugtext.is_none() {
            self.bugtext = ::std::option::Option::Some(::std::string::String::new());
        }
        self.bugtext.as_mut().unwrap()
    }

    // Take field
    pub fn take_bugtext(&mut self) -> ::std::string::String {
        self.bugtext.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes screenshot = 3;

    pub fn screenshot(&self) -> &[u8] {
        match self.screenshot.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_screenshot(&mut self) {
        self.screenshot = ::std::option::Option::None;
    }

    pub fn has_screenshot(&self) -> bool {
        self.screenshot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screenshot(&mut self, v: ::std::vec::Vec<u8>) {
        self.screenshot = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_screenshot(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.screenshot.is_none() {
            self.screenshot = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.screenshot.as_mut().unwrap()
    }

    // Take field
    pub fn take_screenshot(&mut self) -> ::std::vec::Vec<u8> {
        self.screenshot.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sessionid",
            |m: &CMsgClientOGSReportBug| { &m.sessionid },
            |m: &mut CMsgClientOGSReportBug| { &mut m.sessionid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bugtext",
            |m: &CMsgClientOGSReportBug| { &m.bugtext },
            |m: &mut CMsgClientOGSReportBug| { &mut m.bugtext },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "screenshot",
            |m: &CMsgClientOGSReportBug| { &m.screenshot },
            |m: &mut CMsgClientOGSReportBug| { &mut m.screenshot },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientOGSReportBug>(
            "CMsgClientOGSReportBug",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientOGSReportBug {
    const NAME: &'static str = "CMsgClientOGSReportBug";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sessionid = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.bugtext = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.screenshot = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sessionid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.bugtext.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.screenshot.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.sessionid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.bugtext.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.screenshot.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientOGSReportBug {
        CMsgClientOGSReportBug::new()
    }

    fn clear(&mut self) {
        self.sessionid = ::std::option::Option::None;
        self.bugtext = ::std::option::Option::None;
        self.screenshot = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientOGSReportBug {
        static instance: CMsgClientOGSReportBug = CMsgClientOGSReportBug {
            sessionid: ::std::option::Option::None,
            bugtext: ::std::option::Option::None,
            screenshot: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientOGSReportBug {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientOGSReportBug").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientOGSReportBug {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientOGSReportBug {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGSAssociateWithClan)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGSAssociateWithClan {
    // message fields
    // @@protoc_insertion_point(field:CMsgGSAssociateWithClan.steam_id_clan)
    pub steam_id_clan: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGSAssociateWithClan.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGSAssociateWithClan {
    fn default() -> &'a CMsgGSAssociateWithClan {
        <CMsgGSAssociateWithClan as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSAssociateWithClan {
    pub fn new() -> CMsgGSAssociateWithClan {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_clan = 1;

    pub fn steam_id_clan(&self) -> u64 {
        self.steam_id_clan.unwrap_or(0)
    }

    pub fn clear_steam_id_clan(&mut self) {
        self.steam_id_clan = ::std::option::Option::None;
    }

    pub fn has_steam_id_clan(&self) -> bool {
        self.steam_id_clan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_clan(&mut self, v: u64) {
        self.steam_id_clan = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_clan",
            |m: &CMsgGSAssociateWithClan| { &m.steam_id_clan },
            |m: &mut CMsgGSAssociateWithClan| { &mut m.steam_id_clan },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGSAssociateWithClan>(
            "CMsgGSAssociateWithClan",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGSAssociateWithClan {
    const NAME: &'static str = "CMsgGSAssociateWithClan";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id_clan = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_clan {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id_clan {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGSAssociateWithClan {
        CMsgGSAssociateWithClan::new()
    }

    fn clear(&mut self) {
        self.steam_id_clan = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGSAssociateWithClan {
        static instance: CMsgGSAssociateWithClan = CMsgGSAssociateWithClan {
            steam_id_clan: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGSAssociateWithClan {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGSAssociateWithClan").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGSAssociateWithClan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGSAssociateWithClan {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGSAssociateWithClanResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGSAssociateWithClanResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGSAssociateWithClanResponse.steam_id_clan)
    pub steam_id_clan: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGSAssociateWithClanResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGSAssociateWithClanResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGSAssociateWithClanResponse {
    fn default() -> &'a CMsgGSAssociateWithClanResponse {
        <CMsgGSAssociateWithClanResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSAssociateWithClanResponse {
    pub fn new() -> CMsgGSAssociateWithClanResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_clan = 1;

    pub fn steam_id_clan(&self) -> u64 {
        self.steam_id_clan.unwrap_or(0)
    }

    pub fn clear_steam_id_clan(&mut self) {
        self.steam_id_clan = ::std::option::Option::None;
    }

    pub fn has_steam_id_clan(&self) -> bool {
        self.steam_id_clan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_clan(&mut self, v: u64) {
        self.steam_id_clan = ::std::option::Option::Some(v);
    }

    // optional uint32 eresult = 2;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_clan",
            |m: &CMsgGSAssociateWithClanResponse| { &m.steam_id_clan },
            |m: &mut CMsgGSAssociateWithClanResponse| { &mut m.steam_id_clan },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgGSAssociateWithClanResponse| { &m.eresult },
            |m: &mut CMsgGSAssociateWithClanResponse| { &mut m.eresult },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGSAssociateWithClanResponse>(
            "CMsgGSAssociateWithClanResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGSAssociateWithClanResponse {
    const NAME: &'static str = "CMsgGSAssociateWithClanResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id_clan = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_clan {
            my_size += 1 + 8;
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id_clan {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGSAssociateWithClanResponse {
        CMsgGSAssociateWithClanResponse::new()
    }

    fn clear(&mut self) {
        self.steam_id_clan = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGSAssociateWithClanResponse {
        static instance: CMsgGSAssociateWithClanResponse = CMsgGSAssociateWithClanResponse {
            steam_id_clan: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGSAssociateWithClanResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGSAssociateWithClanResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGSAssociateWithClanResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGSAssociateWithClanResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGSComputeNewPlayerCompatibility)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGSComputeNewPlayerCompatibility {
    // message fields
    // @@protoc_insertion_point(field:CMsgGSComputeNewPlayerCompatibility.steam_id_candidate)
    pub steam_id_candidate: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGSComputeNewPlayerCompatibility.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGSComputeNewPlayerCompatibility {
    fn default() -> &'a CMsgGSComputeNewPlayerCompatibility {
        <CMsgGSComputeNewPlayerCompatibility as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSComputeNewPlayerCompatibility {
    pub fn new() -> CMsgGSComputeNewPlayerCompatibility {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_candidate = 1;

    pub fn steam_id_candidate(&self) -> u64 {
        self.steam_id_candidate.unwrap_or(0)
    }

    pub fn clear_steam_id_candidate(&mut self) {
        self.steam_id_candidate = ::std::option::Option::None;
    }

    pub fn has_steam_id_candidate(&self) -> bool {
        self.steam_id_candidate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_candidate(&mut self, v: u64) {
        self.steam_id_candidate = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_candidate",
            |m: &CMsgGSComputeNewPlayerCompatibility| { &m.steam_id_candidate },
            |m: &mut CMsgGSComputeNewPlayerCompatibility| { &mut m.steam_id_candidate },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGSComputeNewPlayerCompatibility>(
            "CMsgGSComputeNewPlayerCompatibility",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGSComputeNewPlayerCompatibility {
    const NAME: &'static str = "CMsgGSComputeNewPlayerCompatibility";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id_candidate = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_candidate {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id_candidate {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGSComputeNewPlayerCompatibility {
        CMsgGSComputeNewPlayerCompatibility::new()
    }

    fn clear(&mut self) {
        self.steam_id_candidate = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGSComputeNewPlayerCompatibility {
        static instance: CMsgGSComputeNewPlayerCompatibility = CMsgGSComputeNewPlayerCompatibility {
            steam_id_candidate: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGSComputeNewPlayerCompatibility {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGSComputeNewPlayerCompatibility").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGSComputeNewPlayerCompatibility {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGSComputeNewPlayerCompatibility {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGSComputeNewPlayerCompatibilityResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGSComputeNewPlayerCompatibilityResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGSComputeNewPlayerCompatibilityResponse.steam_id_candidate)
    pub steam_id_candidate: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGSComputeNewPlayerCompatibilityResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGSComputeNewPlayerCompatibilityResponse.is_clan_member)
    pub is_clan_member: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGSComputeNewPlayerCompatibilityResponse.ct_dont_like_you)
    pub ct_dont_like_you: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGSComputeNewPlayerCompatibilityResponse.ct_you_dont_like)
    pub ct_you_dont_like: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGSComputeNewPlayerCompatibilityResponse.ct_clanmembers_dont_like_you)
    pub ct_clanmembers_dont_like_you: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGSComputeNewPlayerCompatibilityResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGSComputeNewPlayerCompatibilityResponse {
    fn default() -> &'a CMsgGSComputeNewPlayerCompatibilityResponse {
        <CMsgGSComputeNewPlayerCompatibilityResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSComputeNewPlayerCompatibilityResponse {
    pub fn new() -> CMsgGSComputeNewPlayerCompatibilityResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_candidate = 1;

    pub fn steam_id_candidate(&self) -> u64 {
        self.steam_id_candidate.unwrap_or(0)
    }

    pub fn clear_steam_id_candidate(&mut self) {
        self.steam_id_candidate = ::std::option::Option::None;
    }

    pub fn has_steam_id_candidate(&self) -> bool {
        self.steam_id_candidate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_candidate(&mut self, v: u64) {
        self.steam_id_candidate = ::std::option::Option::Some(v);
    }

    // optional uint32 eresult = 2;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional bool is_clan_member = 3;

    pub fn is_clan_member(&self) -> bool {
        self.is_clan_member.unwrap_or(false)
    }

    pub fn clear_is_clan_member(&mut self) {
        self.is_clan_member = ::std::option::Option::None;
    }

    pub fn has_is_clan_member(&self) -> bool {
        self.is_clan_member.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_clan_member(&mut self, v: bool) {
        self.is_clan_member = ::std::option::Option::Some(v);
    }

    // optional int32 ct_dont_like_you = 4;

    pub fn ct_dont_like_you(&self) -> i32 {
        self.ct_dont_like_you.unwrap_or(0)
    }

    pub fn clear_ct_dont_like_you(&mut self) {
        self.ct_dont_like_you = ::std::option::Option::None;
    }

    pub fn has_ct_dont_like_you(&self) -> bool {
        self.ct_dont_like_you.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ct_dont_like_you(&mut self, v: i32) {
        self.ct_dont_like_you = ::std::option::Option::Some(v);
    }

    // optional int32 ct_you_dont_like = 5;

    pub fn ct_you_dont_like(&self) -> i32 {
        self.ct_you_dont_like.unwrap_or(0)
    }

    pub fn clear_ct_you_dont_like(&mut self) {
        self.ct_you_dont_like = ::std::option::Option::None;
    }

    pub fn has_ct_you_dont_like(&self) -> bool {
        self.ct_you_dont_like.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ct_you_dont_like(&mut self, v: i32) {
        self.ct_you_dont_like = ::std::option::Option::Some(v);
    }

    // optional int32 ct_clanmembers_dont_like_you = 6;

    pub fn ct_clanmembers_dont_like_you(&self) -> i32 {
        self.ct_clanmembers_dont_like_you.unwrap_or(0)
    }

    pub fn clear_ct_clanmembers_dont_like_you(&mut self) {
        self.ct_clanmembers_dont_like_you = ::std::option::Option::None;
    }

    pub fn has_ct_clanmembers_dont_like_you(&self) -> bool {
        self.ct_clanmembers_dont_like_you.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ct_clanmembers_dont_like_you(&mut self, v: i32) {
        self.ct_clanmembers_dont_like_you = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_candidate",
            |m: &CMsgGSComputeNewPlayerCompatibilityResponse| { &m.steam_id_candidate },
            |m: &mut CMsgGSComputeNewPlayerCompatibilityResponse| { &mut m.steam_id_candidate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgGSComputeNewPlayerCompatibilityResponse| { &m.eresult },
            |m: &mut CMsgGSComputeNewPlayerCompatibilityResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_clan_member",
            |m: &CMsgGSComputeNewPlayerCompatibilityResponse| { &m.is_clan_member },
            |m: &mut CMsgGSComputeNewPlayerCompatibilityResponse| { &mut m.is_clan_member },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ct_dont_like_you",
            |m: &CMsgGSComputeNewPlayerCompatibilityResponse| { &m.ct_dont_like_you },
            |m: &mut CMsgGSComputeNewPlayerCompatibilityResponse| { &mut m.ct_dont_like_you },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ct_you_dont_like",
            |m: &CMsgGSComputeNewPlayerCompatibilityResponse| { &m.ct_you_dont_like },
            |m: &mut CMsgGSComputeNewPlayerCompatibilityResponse| { &mut m.ct_you_dont_like },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ct_clanmembers_dont_like_you",
            |m: &CMsgGSComputeNewPlayerCompatibilityResponse| { &m.ct_clanmembers_dont_like_you },
            |m: &mut CMsgGSComputeNewPlayerCompatibilityResponse| { &mut m.ct_clanmembers_dont_like_you },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGSComputeNewPlayerCompatibilityResponse>(
            "CMsgGSComputeNewPlayerCompatibilityResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGSComputeNewPlayerCompatibilityResponse {
    const NAME: &'static str = "CMsgGSComputeNewPlayerCompatibilityResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id_candidate = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.is_clan_member = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.ct_dont_like_you = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.ct_you_dont_like = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.ct_clanmembers_dont_like_you = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_candidate {
            my_size += 1 + 8;
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.is_clan_member {
            my_size += 1 + 1;
        }
        if let Some(v) = self.ct_dont_like_you {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.ct_you_dont_like {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.ct_clanmembers_dont_like_you {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id_candidate {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.is_clan_member {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.ct_dont_like_you {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.ct_you_dont_like {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.ct_clanmembers_dont_like_you {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGSComputeNewPlayerCompatibilityResponse {
        CMsgGSComputeNewPlayerCompatibilityResponse::new()
    }

    fn clear(&mut self) {
        self.steam_id_candidate = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.is_clan_member = ::std::option::Option::None;
        self.ct_dont_like_you = ::std::option::Option::None;
        self.ct_you_dont_like = ::std::option::Option::None;
        self.ct_clanmembers_dont_like_you = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGSComputeNewPlayerCompatibilityResponse {
        static instance: CMsgGSComputeNewPlayerCompatibilityResponse = CMsgGSComputeNewPlayerCompatibilityResponse {
            steam_id_candidate: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            is_clan_member: ::std::option::Option::None,
            ct_dont_like_you: ::std::option::Option::None,
            ct_you_dont_like: ::std::option::Option::None,
            ct_clanmembers_dont_like_you: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGSComputeNewPlayerCompatibilityResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGSComputeNewPlayerCompatibilityResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGSComputeNewPlayerCompatibilityResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGSComputeNewPlayerCompatibilityResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientSentLogs)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientSentLogs {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientSentLogs.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientSentLogs {
    fn default() -> &'a CMsgClientSentLogs {
        <CMsgClientSentLogs as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientSentLogs {
    pub fn new() -> CMsgClientSentLogs {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientSentLogs>(
            "CMsgClientSentLogs",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientSentLogs {
    const NAME: &'static str = "CMsgClientSentLogs";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientSentLogs {
        CMsgClientSentLogs::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientSentLogs {
        static instance: CMsgClientSentLogs = CMsgClientSentLogs {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientSentLogs {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientSentLogs").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientSentLogs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientSentLogs {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCClient)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCClient {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCClient.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCClient.msgtype)
    pub msgtype: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCClient.payload)
    pub payload: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgGCClient.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCClient.gcname)
    pub gcname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCClient.ip)
    pub ip: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCClient.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCClient {
    fn default() -> &'a CMsgGCClient {
        <CMsgGCClient as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCClient {
    pub fn new() -> CMsgGCClient {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 msgtype = 2;

    pub fn msgtype(&self) -> u32 {
        self.msgtype.unwrap_or(0)
    }

    pub fn clear_msgtype(&mut self) {
        self.msgtype = ::std::option::Option::None;
    }

    pub fn has_msgtype(&self) -> bool {
        self.msgtype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msgtype(&mut self, v: u32) {
        self.msgtype = ::std::option::Option::Some(v);
    }

    // optional bytes payload = 3;

    pub fn payload(&self) -> &[u8] {
        match self.payload.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_payload(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.payload.is_none() {
            self.payload = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        self.payload.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed64 steamid = 4;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional string gcname = 5;

    pub fn gcname(&self) -> &str {
        match self.gcname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_gcname(&mut self) {
        self.gcname = ::std::option::Option::None;
    }

    pub fn has_gcname(&self) -> bool {
        self.gcname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gcname(&mut self, v: ::std::string::String) {
        self.gcname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gcname(&mut self) -> &mut ::std::string::String {
        if self.gcname.is_none() {
            self.gcname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.gcname.as_mut().unwrap()
    }

    // Take field
    pub fn take_gcname(&mut self) -> ::std::string::String {
        self.gcname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 ip = 6;

    pub fn ip(&self) -> u32 {
        self.ip.unwrap_or(0)
    }

    pub fn clear_ip(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: u32) {
        self.ip = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CMsgGCClient| { &m.appid },
            |m: &mut CMsgGCClient| { &mut m.appid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msgtype",
            |m: &CMsgGCClient| { &m.msgtype },
            |m: &mut CMsgGCClient| { &mut m.msgtype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payload",
            |m: &CMsgGCClient| { &m.payload },
            |m: &mut CMsgGCClient| { &mut m.payload },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CMsgGCClient| { &m.steamid },
            |m: &mut CMsgGCClient| { &mut m.steamid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gcname",
            |m: &CMsgGCClient| { &m.gcname },
            |m: &mut CMsgGCClient| { &mut m.gcname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ip",
            |m: &CMsgGCClient| { &m.ip },
            |m: &mut CMsgGCClient| { &mut m.ip },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCClient>(
            "CMsgGCClient",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCClient {
    const NAME: &'static str = "CMsgGCClient";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.msgtype = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.payload = ::std::option::Option::Some(is.read_bytes()?);
                },
                33 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                42 => {
                    self.gcname = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.msgtype {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.payload.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.gcname.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.ip {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.msgtype {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.payload.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.gcname.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.ip {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCClient {
        CMsgGCClient::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.msgtype = ::std::option::Option::None;
        self.payload = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.gcname = ::std::option::Option::None;
        self.ip = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCClient {
        static instance: CMsgGCClient = CMsgGCClient {
            appid: ::std::option::Option::None,
            msgtype: ::std::option::Option::None,
            payload: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            gcname: ::std::option::Option::None,
            ip: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCClient {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCClient").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCClient {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRequestFreeLicense)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestFreeLicense {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRequestFreeLicense.appids)
    pub appids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestFreeLicense.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestFreeLicense {
    fn default() -> &'a CMsgClientRequestFreeLicense {
        <CMsgClientRequestFreeLicense as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestFreeLicense {
    pub fn new() -> CMsgClientRequestFreeLicense {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "appids",
            |m: &CMsgClientRequestFreeLicense| { &m.appids },
            |m: &mut CMsgClientRequestFreeLicense| { &mut m.appids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRequestFreeLicense>(
            "CMsgClientRequestFreeLicense",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientRequestFreeLicense {
    const NAME: &'static str = "CMsgClientRequestFreeLicense";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.appids)?;
                },
                16 => {
                    self.appids.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.appids {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.appids {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestFreeLicense {
        CMsgClientRequestFreeLicense::new()
    }

    fn clear(&mut self) {
        self.appids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestFreeLicense {
        static instance: CMsgClientRequestFreeLicense = CMsgClientRequestFreeLicense {
            appids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientRequestFreeLicense {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRequestFreeLicense").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRequestFreeLicense {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestFreeLicense {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRequestFreeLicenseResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestFreeLicenseResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRequestFreeLicenseResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRequestFreeLicenseResponse.granted_packageids)
    pub granted_packageids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgClientRequestFreeLicenseResponse.granted_appids)
    pub granted_appids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestFreeLicenseResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestFreeLicenseResponse {
    fn default() -> &'a CMsgClientRequestFreeLicenseResponse {
        <CMsgClientRequestFreeLicenseResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestFreeLicenseResponse {
    pub fn new() -> CMsgClientRequestFreeLicenseResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientRequestFreeLicenseResponse| { &m.eresult },
            |m: &mut CMsgClientRequestFreeLicenseResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "granted_packageids",
            |m: &CMsgClientRequestFreeLicenseResponse| { &m.granted_packageids },
            |m: &mut CMsgClientRequestFreeLicenseResponse| { &mut m.granted_packageids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "granted_appids",
            |m: &CMsgClientRequestFreeLicenseResponse| { &m.granted_appids },
            |m: &mut CMsgClientRequestFreeLicenseResponse| { &mut m.granted_appids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRequestFreeLicenseResponse>(
            "CMsgClientRequestFreeLicenseResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientRequestFreeLicenseResponse {
    const NAME: &'static str = "CMsgClientRequestFreeLicenseResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.granted_packageids)?;
                },
                16 => {
                    self.granted_packageids.push(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.granted_appids)?;
                },
                24 => {
                    self.granted_appids.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.granted_packageids {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        for value in &self.granted_appids {
            my_size += ::protobuf::rt::uint32_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        for v in &self.granted_packageids {
            os.write_uint32(2, *v)?;
        };
        for v in &self.granted_appids {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestFreeLicenseResponse {
        CMsgClientRequestFreeLicenseResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.granted_packageids.clear();
        self.granted_appids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestFreeLicenseResponse {
        static instance: CMsgClientRequestFreeLicenseResponse = CMsgClientRequestFreeLicenseResponse {
            eresult: ::std::option::Option::None,
            granted_packageids: ::std::vec::Vec::new(),
            granted_appids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientRequestFreeLicenseResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRequestFreeLicenseResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRequestFreeLicenseResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestFreeLicenseResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgDRMDownloadRequestWithCrashData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDRMDownloadRequestWithCrashData {
    // message fields
    // @@protoc_insertion_point(field:CMsgDRMDownloadRequestWithCrashData.download_flags)
    pub download_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadRequestWithCrashData.download_types_known)
    pub download_types_known: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadRequestWithCrashData.guid_drm)
    pub guid_drm: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadRequestWithCrashData.guid_split)
    pub guid_split: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadRequestWithCrashData.guid_merge)
    pub guid_merge: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadRequestWithCrashData.module_name)
    pub module_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadRequestWithCrashData.module_path)
    pub module_path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadRequestWithCrashData.crash_data)
    pub crash_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDRMDownloadRequestWithCrashData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDRMDownloadRequestWithCrashData {
    fn default() -> &'a CMsgDRMDownloadRequestWithCrashData {
        <CMsgDRMDownloadRequestWithCrashData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDRMDownloadRequestWithCrashData {
    pub fn new() -> CMsgDRMDownloadRequestWithCrashData {
        ::std::default::Default::default()
    }

    // optional uint32 download_flags = 1;

    pub fn download_flags(&self) -> u32 {
        self.download_flags.unwrap_or(0)
    }

    pub fn clear_download_flags(&mut self) {
        self.download_flags = ::std::option::Option::None;
    }

    pub fn has_download_flags(&self) -> bool {
        self.download_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_flags(&mut self, v: u32) {
        self.download_flags = ::std::option::Option::Some(v);
    }

    // optional uint32 download_types_known = 2;

    pub fn download_types_known(&self) -> u32 {
        self.download_types_known.unwrap_or(0)
    }

    pub fn clear_download_types_known(&mut self) {
        self.download_types_known = ::std::option::Option::None;
    }

    pub fn has_download_types_known(&self) -> bool {
        self.download_types_known.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_types_known(&mut self, v: u32) {
        self.download_types_known = ::std::option::Option::Some(v);
    }

    // optional bytes guid_drm = 3;

    pub fn guid_drm(&self) -> &[u8] {
        match self.guid_drm.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_guid_drm(&mut self) {
        self.guid_drm = ::std::option::Option::None;
    }

    pub fn has_guid_drm(&self) -> bool {
        self.guid_drm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guid_drm(&mut self, v: ::std::vec::Vec<u8>) {
        self.guid_drm = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guid_drm(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.guid_drm.is_none() {
            self.guid_drm = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.guid_drm.as_mut().unwrap()
    }

    // Take field
    pub fn take_guid_drm(&mut self) -> ::std::vec::Vec<u8> {
        self.guid_drm.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes guid_split = 4;

    pub fn guid_split(&self) -> &[u8] {
        match self.guid_split.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_guid_split(&mut self) {
        self.guid_split = ::std::option::Option::None;
    }

    pub fn has_guid_split(&self) -> bool {
        self.guid_split.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guid_split(&mut self, v: ::std::vec::Vec<u8>) {
        self.guid_split = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guid_split(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.guid_split.is_none() {
            self.guid_split = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.guid_split.as_mut().unwrap()
    }

    // Take field
    pub fn take_guid_split(&mut self) -> ::std::vec::Vec<u8> {
        self.guid_split.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes guid_merge = 5;

    pub fn guid_merge(&self) -> &[u8] {
        match self.guid_merge.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_guid_merge(&mut self) {
        self.guid_merge = ::std::option::Option::None;
    }

    pub fn has_guid_merge(&self) -> bool {
        self.guid_merge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guid_merge(&mut self, v: ::std::vec::Vec<u8>) {
        self.guid_merge = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guid_merge(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.guid_merge.is_none() {
            self.guid_merge = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.guid_merge.as_mut().unwrap()
    }

    // Take field
    pub fn take_guid_merge(&mut self) -> ::std::vec::Vec<u8> {
        self.guid_merge.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string module_name = 6;

    pub fn module_name(&self) -> &str {
        match self.module_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_module_name(&mut self) {
        self.module_name = ::std::option::Option::None;
    }

    pub fn has_module_name(&self) -> bool {
        self.module_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_name(&mut self, v: ::std::string::String) {
        self.module_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_name(&mut self) -> &mut ::std::string::String {
        if self.module_name.is_none() {
            self.module_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.module_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_module_name(&mut self) -> ::std::string::String {
        self.module_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string module_path = 7;

    pub fn module_path(&self) -> &str {
        match self.module_path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_module_path(&mut self) {
        self.module_path = ::std::option::Option::None;
    }

    pub fn has_module_path(&self) -> bool {
        self.module_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_path(&mut self, v: ::std::string::String) {
        self.module_path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_path(&mut self) -> &mut ::std::string::String {
        if self.module_path.is_none() {
            self.module_path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.module_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_module_path(&mut self) -> ::std::string::String {
        self.module_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes crash_data = 8;

    pub fn crash_data(&self) -> &[u8] {
        match self.crash_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_crash_data(&mut self) {
        self.crash_data = ::std::option::Option::None;
    }

    pub fn has_crash_data(&self) -> bool {
        self.crash_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crash_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.crash_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_crash_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.crash_data.is_none() {
            self.crash_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.crash_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_crash_data(&mut self) -> ::std::vec::Vec<u8> {
        self.crash_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "download_flags",
            |m: &CMsgDRMDownloadRequestWithCrashData| { &m.download_flags },
            |m: &mut CMsgDRMDownloadRequestWithCrashData| { &mut m.download_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "download_types_known",
            |m: &CMsgDRMDownloadRequestWithCrashData| { &m.download_types_known },
            |m: &mut CMsgDRMDownloadRequestWithCrashData| { &mut m.download_types_known },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guid_drm",
            |m: &CMsgDRMDownloadRequestWithCrashData| { &m.guid_drm },
            |m: &mut CMsgDRMDownloadRequestWithCrashData| { &mut m.guid_drm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guid_split",
            |m: &CMsgDRMDownloadRequestWithCrashData| { &m.guid_split },
            |m: &mut CMsgDRMDownloadRequestWithCrashData| { &mut m.guid_split },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guid_merge",
            |m: &CMsgDRMDownloadRequestWithCrashData| { &m.guid_merge },
            |m: &mut CMsgDRMDownloadRequestWithCrashData| { &mut m.guid_merge },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "module_name",
            |m: &CMsgDRMDownloadRequestWithCrashData| { &m.module_name },
            |m: &mut CMsgDRMDownloadRequestWithCrashData| { &mut m.module_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "module_path",
            |m: &CMsgDRMDownloadRequestWithCrashData| { &m.module_path },
            |m: &mut CMsgDRMDownloadRequestWithCrashData| { &mut m.module_path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "crash_data",
            |m: &CMsgDRMDownloadRequestWithCrashData| { &m.crash_data },
            |m: &mut CMsgDRMDownloadRequestWithCrashData| { &mut m.crash_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDRMDownloadRequestWithCrashData>(
            "CMsgDRMDownloadRequestWithCrashData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDRMDownloadRequestWithCrashData {
    const NAME: &'static str = "CMsgDRMDownloadRequestWithCrashData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.download_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.download_types_known = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.guid_drm = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    self.guid_split = ::std::option::Option::Some(is.read_bytes()?);
                },
                42 => {
                    self.guid_merge = ::std::option::Option::Some(is.read_bytes()?);
                },
                50 => {
                    self.module_name = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.module_path = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.crash_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.download_flags {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.download_types_known {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.guid_drm.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.guid_split.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.guid_merge.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.module_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.module_path.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.crash_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.download_flags {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.download_types_known {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.guid_drm.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.guid_split.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.guid_merge.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.module_name.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.module_path.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.crash_data.as_ref() {
            os.write_bytes(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDRMDownloadRequestWithCrashData {
        CMsgDRMDownloadRequestWithCrashData::new()
    }

    fn clear(&mut self) {
        self.download_flags = ::std::option::Option::None;
        self.download_types_known = ::std::option::Option::None;
        self.guid_drm = ::std::option::Option::None;
        self.guid_split = ::std::option::Option::None;
        self.guid_merge = ::std::option::Option::None;
        self.module_name = ::std::option::Option::None;
        self.module_path = ::std::option::Option::None;
        self.crash_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDRMDownloadRequestWithCrashData {
        static instance: CMsgDRMDownloadRequestWithCrashData = CMsgDRMDownloadRequestWithCrashData {
            download_flags: ::std::option::Option::None,
            download_types_known: ::std::option::Option::None,
            guid_drm: ::std::option::Option::None,
            guid_split: ::std::option::Option::None,
            guid_merge: ::std::option::Option::None,
            module_name: ::std::option::Option::None,
            module_path: ::std::option::Option::None,
            crash_data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDRMDownloadRequestWithCrashData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDRMDownloadRequestWithCrashData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDRMDownloadRequestWithCrashData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDRMDownloadRequestWithCrashData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgDRMDownloadResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDRMDownloadResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgDRMDownloadResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadResponse.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadResponse.blob_download_type)
    pub blob_download_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadResponse.merge_guid)
    pub merge_guid: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadResponse.download_file_dfs_ip)
    pub download_file_dfs_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadResponse.download_file_dfs_port)
    pub download_file_dfs_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadResponse.download_file_url)
    pub download_file_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgDRMDownloadResponse.module_path)
    pub module_path: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDRMDownloadResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDRMDownloadResponse {
    fn default() -> &'a CMsgDRMDownloadResponse {
        <CMsgDRMDownloadResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDRMDownloadResponse {
    pub fn new() -> CMsgDRMDownloadResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 blob_download_type = 3;

    pub fn blob_download_type(&self) -> u32 {
        self.blob_download_type.unwrap_or(0)
    }

    pub fn clear_blob_download_type(&mut self) {
        self.blob_download_type = ::std::option::Option::None;
    }

    pub fn has_blob_download_type(&self) -> bool {
        self.blob_download_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blob_download_type(&mut self, v: u32) {
        self.blob_download_type = ::std::option::Option::Some(v);
    }

    // optional bytes merge_guid = 4;

    pub fn merge_guid(&self) -> &[u8] {
        match self.merge_guid.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_merge_guid(&mut self) {
        self.merge_guid = ::std::option::Option::None;
    }

    pub fn has_merge_guid(&self) -> bool {
        self.merge_guid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_merge_guid(&mut self, v: ::std::vec::Vec<u8>) {
        self.merge_guid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_merge_guid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.merge_guid.is_none() {
            self.merge_guid = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.merge_guid.as_mut().unwrap()
    }

    // Take field
    pub fn take_merge_guid(&mut self) -> ::std::vec::Vec<u8> {
        self.merge_guid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 download_file_dfs_ip = 5;

    pub fn download_file_dfs_ip(&self) -> u32 {
        self.download_file_dfs_ip.unwrap_or(0)
    }

    pub fn clear_download_file_dfs_ip(&mut self) {
        self.download_file_dfs_ip = ::std::option::Option::None;
    }

    pub fn has_download_file_dfs_ip(&self) -> bool {
        self.download_file_dfs_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_file_dfs_ip(&mut self, v: u32) {
        self.download_file_dfs_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 download_file_dfs_port = 6;

    pub fn download_file_dfs_port(&self) -> u32 {
        self.download_file_dfs_port.unwrap_or(0)
    }

    pub fn clear_download_file_dfs_port(&mut self) {
        self.download_file_dfs_port = ::std::option::Option::None;
    }

    pub fn has_download_file_dfs_port(&self) -> bool {
        self.download_file_dfs_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_file_dfs_port(&mut self, v: u32) {
        self.download_file_dfs_port = ::std::option::Option::Some(v);
    }

    // optional string download_file_url = 7;

    pub fn download_file_url(&self) -> &str {
        match self.download_file_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_download_file_url(&mut self) {
        self.download_file_url = ::std::option::Option::None;
    }

    pub fn has_download_file_url(&self) -> bool {
        self.download_file_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_file_url(&mut self, v: ::std::string::String) {
        self.download_file_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_download_file_url(&mut self) -> &mut ::std::string::String {
        if self.download_file_url.is_none() {
            self.download_file_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.download_file_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_download_file_url(&mut self) -> ::std::string::String {
        self.download_file_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string module_path = 8;

    pub fn module_path(&self) -> &str {
        match self.module_path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_module_path(&mut self) {
        self.module_path = ::std::option::Option::None;
    }

    pub fn has_module_path(&self) -> bool {
        self.module_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_path(&mut self, v: ::std::string::String) {
        self.module_path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_path(&mut self) -> &mut ::std::string::String {
        if self.module_path.is_none() {
            self.module_path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.module_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_module_path(&mut self) -> ::std::string::String {
        self.module_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgDRMDownloadResponse| { &m.eresult },
            |m: &mut CMsgDRMDownloadResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgDRMDownloadResponse| { &m.app_id },
            |m: &mut CMsgDRMDownloadResponse| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "blob_download_type",
            |m: &CMsgDRMDownloadResponse| { &m.blob_download_type },
            |m: &mut CMsgDRMDownloadResponse| { &mut m.blob_download_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "merge_guid",
            |m: &CMsgDRMDownloadResponse| { &m.merge_guid },
            |m: &mut CMsgDRMDownloadResponse| { &mut m.merge_guid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "download_file_dfs_ip",
            |m: &CMsgDRMDownloadResponse| { &m.download_file_dfs_ip },
            |m: &mut CMsgDRMDownloadResponse| { &mut m.download_file_dfs_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "download_file_dfs_port",
            |m: &CMsgDRMDownloadResponse| { &m.download_file_dfs_port },
            |m: &mut CMsgDRMDownloadResponse| { &mut m.download_file_dfs_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "download_file_url",
            |m: &CMsgDRMDownloadResponse| { &m.download_file_url },
            |m: &mut CMsgDRMDownloadResponse| { &mut m.download_file_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "module_path",
            |m: &CMsgDRMDownloadResponse| { &m.module_path },
            |m: &mut CMsgDRMDownloadResponse| { &mut m.module_path },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDRMDownloadResponse>(
            "CMsgDRMDownloadResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDRMDownloadResponse {
    const NAME: &'static str = "CMsgDRMDownloadResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.blob_download_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.merge_guid = ::std::option::Option::Some(is.read_bytes()?);
                },
                40 => {
                    self.download_file_dfs_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.download_file_dfs_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.download_file_url = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.module_path = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.blob_download_type {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.merge_guid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.download_file_dfs_ip {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.download_file_dfs_port {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.download_file_url.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.module_path.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.blob_download_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.merge_guid.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.download_file_dfs_ip {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.download_file_dfs_port {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.download_file_url.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.module_path.as_ref() {
            os.write_string(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDRMDownloadResponse {
        CMsgDRMDownloadResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.blob_download_type = ::std::option::Option::None;
        self.merge_guid = ::std::option::Option::None;
        self.download_file_dfs_ip = ::std::option::Option::None;
        self.download_file_dfs_port = ::std::option::Option::None;
        self.download_file_url = ::std::option::Option::None;
        self.module_path = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDRMDownloadResponse {
        static instance: CMsgDRMDownloadResponse = CMsgDRMDownloadResponse {
            eresult: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            blob_download_type: ::std::option::Option::None,
            merge_guid: ::std::option::Option::None,
            download_file_dfs_ip: ::std::option::Option::None,
            download_file_dfs_port: ::std::option::Option::None,
            download_file_url: ::std::option::Option::None,
            module_path: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDRMDownloadResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDRMDownloadResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDRMDownloadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDRMDownloadResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgDRMFinalResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDRMFinalResult {
    // message fields
    // @@protoc_insertion_point(field:CMsgDRMFinalResult.eResult)
    pub eResult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDRMFinalResult.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDRMFinalResult.blob_download_type)
    pub blob_download_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDRMFinalResult.error_detail)
    pub error_detail: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDRMFinalResult.merge_guid)
    pub merge_guid: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgDRMFinalResult.download_file_dfs_ip)
    pub download_file_dfs_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDRMFinalResult.download_file_dfs_port)
    pub download_file_dfs_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDRMFinalResult.download_file_url)
    pub download_file_url: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDRMFinalResult.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDRMFinalResult {
    fn default() -> &'a CMsgDRMFinalResult {
        <CMsgDRMFinalResult as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDRMFinalResult {
    pub fn new() -> CMsgDRMFinalResult {
        ::std::default::Default::default()
    }

    // optional uint32 eResult = 1;

    pub fn eResult(&self) -> u32 {
        self.eResult.unwrap_or(2u32)
    }

    pub fn clear_eResult(&mut self) {
        self.eResult = ::std::option::Option::None;
    }

    pub fn has_eResult(&self) -> bool {
        self.eResult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eResult(&mut self, v: u32) {
        self.eResult = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 blob_download_type = 3;

    pub fn blob_download_type(&self) -> u32 {
        self.blob_download_type.unwrap_or(0)
    }

    pub fn clear_blob_download_type(&mut self) {
        self.blob_download_type = ::std::option::Option::None;
    }

    pub fn has_blob_download_type(&self) -> bool {
        self.blob_download_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blob_download_type(&mut self, v: u32) {
        self.blob_download_type = ::std::option::Option::Some(v);
    }

    // optional uint32 error_detail = 4;

    pub fn error_detail(&self) -> u32 {
        self.error_detail.unwrap_or(0)
    }

    pub fn clear_error_detail(&mut self) {
        self.error_detail = ::std::option::Option::None;
    }

    pub fn has_error_detail(&self) -> bool {
        self.error_detail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_detail(&mut self, v: u32) {
        self.error_detail = ::std::option::Option::Some(v);
    }

    // optional bytes merge_guid = 5;

    pub fn merge_guid(&self) -> &[u8] {
        match self.merge_guid.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_merge_guid(&mut self) {
        self.merge_guid = ::std::option::Option::None;
    }

    pub fn has_merge_guid(&self) -> bool {
        self.merge_guid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_merge_guid(&mut self, v: ::std::vec::Vec<u8>) {
        self.merge_guid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_merge_guid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.merge_guid.is_none() {
            self.merge_guid = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.merge_guid.as_mut().unwrap()
    }

    // Take field
    pub fn take_merge_guid(&mut self) -> ::std::vec::Vec<u8> {
        self.merge_guid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 download_file_dfs_ip = 6;

    pub fn download_file_dfs_ip(&self) -> u32 {
        self.download_file_dfs_ip.unwrap_or(0)
    }

    pub fn clear_download_file_dfs_ip(&mut self) {
        self.download_file_dfs_ip = ::std::option::Option::None;
    }

    pub fn has_download_file_dfs_ip(&self) -> bool {
        self.download_file_dfs_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_file_dfs_ip(&mut self, v: u32) {
        self.download_file_dfs_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 download_file_dfs_port = 7;

    pub fn download_file_dfs_port(&self) -> u32 {
        self.download_file_dfs_port.unwrap_or(0)
    }

    pub fn clear_download_file_dfs_port(&mut self) {
        self.download_file_dfs_port = ::std::option::Option::None;
    }

    pub fn has_download_file_dfs_port(&self) -> bool {
        self.download_file_dfs_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_file_dfs_port(&mut self, v: u32) {
        self.download_file_dfs_port = ::std::option::Option::Some(v);
    }

    // optional string download_file_url = 8;

    pub fn download_file_url(&self) -> &str {
        match self.download_file_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_download_file_url(&mut self) {
        self.download_file_url = ::std::option::Option::None;
    }

    pub fn has_download_file_url(&self) -> bool {
        self.download_file_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_file_url(&mut self, v: ::std::string::String) {
        self.download_file_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_download_file_url(&mut self) -> &mut ::std::string::String {
        if self.download_file_url.is_none() {
            self.download_file_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.download_file_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_download_file_url(&mut self) -> ::std::string::String {
        self.download_file_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eResult",
            |m: &CMsgDRMFinalResult| { &m.eResult },
            |m: &mut CMsgDRMFinalResult| { &mut m.eResult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgDRMFinalResult| { &m.app_id },
            |m: &mut CMsgDRMFinalResult| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "blob_download_type",
            |m: &CMsgDRMFinalResult| { &m.blob_download_type },
            |m: &mut CMsgDRMFinalResult| { &mut m.blob_download_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error_detail",
            |m: &CMsgDRMFinalResult| { &m.error_detail },
            |m: &mut CMsgDRMFinalResult| { &mut m.error_detail },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "merge_guid",
            |m: &CMsgDRMFinalResult| { &m.merge_guid },
            |m: &mut CMsgDRMFinalResult| { &mut m.merge_guid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "download_file_dfs_ip",
            |m: &CMsgDRMFinalResult| { &m.download_file_dfs_ip },
            |m: &mut CMsgDRMFinalResult| { &mut m.download_file_dfs_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "download_file_dfs_port",
            |m: &CMsgDRMFinalResult| { &m.download_file_dfs_port },
            |m: &mut CMsgDRMFinalResult| { &mut m.download_file_dfs_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "download_file_url",
            |m: &CMsgDRMFinalResult| { &m.download_file_url },
            |m: &mut CMsgDRMFinalResult| { &mut m.download_file_url },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDRMFinalResult>(
            "CMsgDRMFinalResult",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDRMFinalResult {
    const NAME: &'static str = "CMsgDRMFinalResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eResult = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.blob_download_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.error_detail = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.merge_guid = ::std::option::Option::Some(is.read_bytes()?);
                },
                48 => {
                    self.download_file_dfs_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.download_file_dfs_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.download_file_url = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eResult {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.blob_download_type {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.error_detail {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.merge_guid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.download_file_dfs_ip {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.download_file_dfs_port {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.download_file_url.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eResult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.blob_download_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.error_detail {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.merge_guid.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.download_file_dfs_ip {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.download_file_dfs_port {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.download_file_url.as_ref() {
            os.write_string(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDRMFinalResult {
        CMsgDRMFinalResult::new()
    }

    fn clear(&mut self) {
        self.eResult = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.blob_download_type = ::std::option::Option::None;
        self.error_detail = ::std::option::Option::None;
        self.merge_guid = ::std::option::Option::None;
        self.download_file_dfs_ip = ::std::option::Option::None;
        self.download_file_dfs_port = ::std::option::Option::None;
        self.download_file_url = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDRMFinalResult {
        static instance: CMsgDRMFinalResult = CMsgDRMFinalResult {
            eResult: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            blob_download_type: ::std::option::Option::None,
            error_detail: ::std::option::Option::None,
            merge_guid: ::std::option::Option::None,
            download_file_dfs_ip: ::std::option::Option::None,
            download_file_dfs_port: ::std::option::Option::None,
            download_file_url: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDRMFinalResult {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDRMFinalResult").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDRMFinalResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDRMFinalResult {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientDPCheckSpecialSurvey)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientDPCheckSpecialSurvey {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientDPCheckSpecialSurvey.survey_id)
    pub survey_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientDPCheckSpecialSurvey.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientDPCheckSpecialSurvey {
    fn default() -> &'a CMsgClientDPCheckSpecialSurvey {
        <CMsgClientDPCheckSpecialSurvey as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientDPCheckSpecialSurvey {
    pub fn new() -> CMsgClientDPCheckSpecialSurvey {
        ::std::default::Default::default()
    }

    // optional uint32 survey_id = 1;

    pub fn survey_id(&self) -> u32 {
        self.survey_id.unwrap_or(0)
    }

    pub fn clear_survey_id(&mut self) {
        self.survey_id = ::std::option::Option::None;
    }

    pub fn has_survey_id(&self) -> bool {
        self.survey_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_survey_id(&mut self, v: u32) {
        self.survey_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "survey_id",
            |m: &CMsgClientDPCheckSpecialSurvey| { &m.survey_id },
            |m: &mut CMsgClientDPCheckSpecialSurvey| { &mut m.survey_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientDPCheckSpecialSurvey>(
            "CMsgClientDPCheckSpecialSurvey",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientDPCheckSpecialSurvey {
    const NAME: &'static str = "CMsgClientDPCheckSpecialSurvey";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.survey_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.survey_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.survey_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientDPCheckSpecialSurvey {
        CMsgClientDPCheckSpecialSurvey::new()
    }

    fn clear(&mut self) {
        self.survey_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientDPCheckSpecialSurvey {
        static instance: CMsgClientDPCheckSpecialSurvey = CMsgClientDPCheckSpecialSurvey {
            survey_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientDPCheckSpecialSurvey {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientDPCheckSpecialSurvey").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientDPCheckSpecialSurvey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientDPCheckSpecialSurvey {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientDPCheckSpecialSurveyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientDPCheckSpecialSurveyResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientDPCheckSpecialSurveyResponse.eResult)
    pub eResult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientDPCheckSpecialSurveyResponse.state)
    pub state: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientDPCheckSpecialSurveyResponse.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientDPCheckSpecialSurveyResponse.custom_url)
    pub custom_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientDPCheckSpecialSurveyResponse.include_software)
    pub include_software: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientDPCheckSpecialSurveyResponse.token)
    pub token: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientDPCheckSpecialSurveyResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientDPCheckSpecialSurveyResponse {
    fn default() -> &'a CMsgClientDPCheckSpecialSurveyResponse {
        <CMsgClientDPCheckSpecialSurveyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientDPCheckSpecialSurveyResponse {
    pub fn new() -> CMsgClientDPCheckSpecialSurveyResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eResult = 1;

    pub fn eResult(&self) -> u32 {
        self.eResult.unwrap_or(2u32)
    }

    pub fn clear_eResult(&mut self) {
        self.eResult = ::std::option::Option::None;
    }

    pub fn has_eResult(&self) -> bool {
        self.eResult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eResult(&mut self, v: u32) {
        self.eResult = ::std::option::Option::Some(v);
    }

    // optional uint32 state = 2;

    pub fn state(&self) -> u32 {
        self.state.unwrap_or(0)
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: u32) {
        self.state = ::std::option::Option::Some(v);
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string custom_url = 4;

    pub fn custom_url(&self) -> &str {
        match self.custom_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_custom_url(&mut self) {
        self.custom_url = ::std::option::Option::None;
    }

    pub fn has_custom_url(&self) -> bool {
        self.custom_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_url(&mut self, v: ::std::string::String) {
        self.custom_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_url(&mut self) -> &mut ::std::string::String {
        if self.custom_url.is_none() {
            self.custom_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.custom_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_url(&mut self) -> ::std::string::String {
        self.custom_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool include_software = 5;

    pub fn include_software(&self) -> bool {
        self.include_software.unwrap_or(false)
    }

    pub fn clear_include_software(&mut self) {
        self.include_software = ::std::option::Option::None;
    }

    pub fn has_include_software(&self) -> bool {
        self.include_software.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_software(&mut self, v: bool) {
        self.include_software = ::std::option::Option::Some(v);
    }

    // optional bytes token = 6;

    pub fn token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.token.is_none() {
            self.token = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
        self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eResult",
            |m: &CMsgClientDPCheckSpecialSurveyResponse| { &m.eResult },
            |m: &mut CMsgClientDPCheckSpecialSurveyResponse| { &mut m.eResult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "state",
            |m: &CMsgClientDPCheckSpecialSurveyResponse| { &m.state },
            |m: &mut CMsgClientDPCheckSpecialSurveyResponse| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgClientDPCheckSpecialSurveyResponse| { &m.name },
            |m: &mut CMsgClientDPCheckSpecialSurveyResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_url",
            |m: &CMsgClientDPCheckSpecialSurveyResponse| { &m.custom_url },
            |m: &mut CMsgClientDPCheckSpecialSurveyResponse| { &mut m.custom_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "include_software",
            |m: &CMsgClientDPCheckSpecialSurveyResponse| { &m.include_software },
            |m: &mut CMsgClientDPCheckSpecialSurveyResponse| { &mut m.include_software },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "token",
            |m: &CMsgClientDPCheckSpecialSurveyResponse| { &m.token },
            |m: &mut CMsgClientDPCheckSpecialSurveyResponse| { &mut m.token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientDPCheckSpecialSurveyResponse>(
            "CMsgClientDPCheckSpecialSurveyResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientDPCheckSpecialSurveyResponse {
    const NAME: &'static str = "CMsgClientDPCheckSpecialSurveyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eResult = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.state = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.custom_url = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.include_software = ::std::option::Option::Some(is.read_bool()?);
                },
                50 => {
                    self.token = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eResult {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.custom_url.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.include_software {
            my_size += 1 + 1;
        }
        if let Some(v) = self.token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eResult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.state {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.custom_url.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.include_software {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.token.as_ref() {
            os.write_bytes(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientDPCheckSpecialSurveyResponse {
        CMsgClientDPCheckSpecialSurveyResponse::new()
    }

    fn clear(&mut self) {
        self.eResult = ::std::option::Option::None;
        self.state = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.custom_url = ::std::option::Option::None;
        self.include_software = ::std::option::Option::None;
        self.token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientDPCheckSpecialSurveyResponse {
        static instance: CMsgClientDPCheckSpecialSurveyResponse = CMsgClientDPCheckSpecialSurveyResponse {
            eResult: ::std::option::Option::None,
            state: ::std::option::Option::None,
            name: ::std::option::Option::None,
            custom_url: ::std::option::Option::None,
            include_software: ::std::option::Option::None,
            token: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientDPCheckSpecialSurveyResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientDPCheckSpecialSurveyResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientDPCheckSpecialSurveyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientDPCheckSpecialSurveyResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientDPSendSpecialSurveyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientDPSendSpecialSurveyResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientDPSendSpecialSurveyResponse.survey_id)
    pub survey_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientDPSendSpecialSurveyResponse.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientDPSendSpecialSurveyResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientDPSendSpecialSurveyResponse {
    fn default() -> &'a CMsgClientDPSendSpecialSurveyResponse {
        <CMsgClientDPSendSpecialSurveyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientDPSendSpecialSurveyResponse {
    pub fn new() -> CMsgClientDPSendSpecialSurveyResponse {
        ::std::default::Default::default()
    }

    // optional uint32 survey_id = 1;

    pub fn survey_id(&self) -> u32 {
        self.survey_id.unwrap_or(0)
    }

    pub fn clear_survey_id(&mut self) {
        self.survey_id = ::std::option::Option::None;
    }

    pub fn has_survey_id(&self) -> bool {
        self.survey_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_survey_id(&mut self, v: u32) {
        self.survey_id = ::std::option::Option::Some(v);
    }

    // optional bytes data = 2;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "survey_id",
            |m: &CMsgClientDPSendSpecialSurveyResponse| { &m.survey_id },
            |m: &mut CMsgClientDPSendSpecialSurveyResponse| { &mut m.survey_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &CMsgClientDPSendSpecialSurveyResponse| { &m.data },
            |m: &mut CMsgClientDPSendSpecialSurveyResponse| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientDPSendSpecialSurveyResponse>(
            "CMsgClientDPSendSpecialSurveyResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientDPSendSpecialSurveyResponse {
    const NAME: &'static str = "CMsgClientDPSendSpecialSurveyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.survey_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.survey_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.survey_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientDPSendSpecialSurveyResponse {
        CMsgClientDPSendSpecialSurveyResponse::new()
    }

    fn clear(&mut self) {
        self.survey_id = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientDPSendSpecialSurveyResponse {
        static instance: CMsgClientDPSendSpecialSurveyResponse = CMsgClientDPSendSpecialSurveyResponse {
            survey_id: ::std::option::Option::None,
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientDPSendSpecialSurveyResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientDPSendSpecialSurveyResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientDPSendSpecialSurveyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientDPSendSpecialSurveyResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientDPSendSpecialSurveyResponseReply)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientDPSendSpecialSurveyResponseReply {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientDPSendSpecialSurveyResponseReply.eResult)
    pub eResult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientDPSendSpecialSurveyResponseReply.token)
    pub token: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientDPSendSpecialSurveyResponseReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientDPSendSpecialSurveyResponseReply {
    fn default() -> &'a CMsgClientDPSendSpecialSurveyResponseReply {
        <CMsgClientDPSendSpecialSurveyResponseReply as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientDPSendSpecialSurveyResponseReply {
    pub fn new() -> CMsgClientDPSendSpecialSurveyResponseReply {
        ::std::default::Default::default()
    }

    // optional uint32 eResult = 1;

    pub fn eResult(&self) -> u32 {
        self.eResult.unwrap_or(2u32)
    }

    pub fn clear_eResult(&mut self) {
        self.eResult = ::std::option::Option::None;
    }

    pub fn has_eResult(&self) -> bool {
        self.eResult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eResult(&mut self, v: u32) {
        self.eResult = ::std::option::Option::Some(v);
    }

    // optional bytes token = 2;

    pub fn token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.token.is_none() {
            self.token = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
        self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eResult",
            |m: &CMsgClientDPSendSpecialSurveyResponseReply| { &m.eResult },
            |m: &mut CMsgClientDPSendSpecialSurveyResponseReply| { &mut m.eResult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "token",
            |m: &CMsgClientDPSendSpecialSurveyResponseReply| { &m.token },
            |m: &mut CMsgClientDPSendSpecialSurveyResponseReply| { &mut m.token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientDPSendSpecialSurveyResponseReply>(
            "CMsgClientDPSendSpecialSurveyResponseReply",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientDPSendSpecialSurveyResponseReply {
    const NAME: &'static str = "CMsgClientDPSendSpecialSurveyResponseReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eResult = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.token = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eResult {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eResult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.token.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientDPSendSpecialSurveyResponseReply {
        CMsgClientDPSendSpecialSurveyResponseReply::new()
    }

    fn clear(&mut self) {
        self.eResult = ::std::option::Option::None;
        self.token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientDPSendSpecialSurveyResponseReply {
        static instance: CMsgClientDPSendSpecialSurveyResponseReply = CMsgClientDPSendSpecialSurveyResponseReply {
            eResult: ::std::option::Option::None,
            token: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientDPSendSpecialSurveyResponseReply {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientDPSendSpecialSurveyResponseReply").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientDPSendSpecialSurveyResponseReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientDPSendSpecialSurveyResponseReply {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRequestForgottenPasswordEmail)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestForgottenPasswordEmail {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRequestForgottenPasswordEmail.account_name)
    pub account_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientRequestForgottenPasswordEmail.password_tried)
    pub password_tried: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestForgottenPasswordEmail.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestForgottenPasswordEmail {
    fn default() -> &'a CMsgClientRequestForgottenPasswordEmail {
        <CMsgClientRequestForgottenPasswordEmail as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestForgottenPasswordEmail {
    pub fn new() -> CMsgClientRequestForgottenPasswordEmail {
        ::std::default::Default::default()
    }

    // optional string account_name = 1;

    pub fn account_name(&self) -> &str {
        match self.account_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_account_name(&mut self) {
        self.account_name = ::std::option::Option::None;
    }

    pub fn has_account_name(&self) -> bool {
        self.account_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_name(&mut self, v: ::std::string::String) {
        self.account_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_name(&mut self) -> &mut ::std::string::String {
        if self.account_name.is_none() {
            self.account_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.account_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_name(&mut self) -> ::std::string::String {
        self.account_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string password_tried = 2;

    pub fn password_tried(&self) -> &str {
        match self.password_tried.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_password_tried(&mut self) {
        self.password_tried = ::std::option::Option::None;
    }

    pub fn has_password_tried(&self) -> bool {
        self.password_tried.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password_tried(&mut self, v: ::std::string::String) {
        self.password_tried = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password_tried(&mut self) -> &mut ::std::string::String {
        if self.password_tried.is_none() {
            self.password_tried = ::std::option::Option::Some(::std::string::String::new());
        }
        self.password_tried.as_mut().unwrap()
    }

    // Take field
    pub fn take_password_tried(&mut self) -> ::std::string::String {
        self.password_tried.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_name",
            |m: &CMsgClientRequestForgottenPasswordEmail| { &m.account_name },
            |m: &mut CMsgClientRequestForgottenPasswordEmail| { &mut m.account_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "password_tried",
            |m: &CMsgClientRequestForgottenPasswordEmail| { &m.password_tried },
            |m: &mut CMsgClientRequestForgottenPasswordEmail| { &mut m.password_tried },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRequestForgottenPasswordEmail>(
            "CMsgClientRequestForgottenPasswordEmail",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientRequestForgottenPasswordEmail {
    const NAME: &'static str = "CMsgClientRequestForgottenPasswordEmail";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.account_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.password_tried = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.password_tried.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.password_tried.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestForgottenPasswordEmail {
        CMsgClientRequestForgottenPasswordEmail::new()
    }

    fn clear(&mut self) {
        self.account_name = ::std::option::Option::None;
        self.password_tried = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestForgottenPasswordEmail {
        static instance: CMsgClientRequestForgottenPasswordEmail = CMsgClientRequestForgottenPasswordEmail {
            account_name: ::std::option::Option::None,
            password_tried: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientRequestForgottenPasswordEmail {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRequestForgottenPasswordEmail").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRequestForgottenPasswordEmail {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestForgottenPasswordEmail {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRequestForgottenPasswordEmailResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestForgottenPasswordEmailResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRequestForgottenPasswordEmailResponse.eResult)
    pub eResult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRequestForgottenPasswordEmailResponse.use_secret_question)
    pub use_secret_question: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestForgottenPasswordEmailResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestForgottenPasswordEmailResponse {
    fn default() -> &'a CMsgClientRequestForgottenPasswordEmailResponse {
        <CMsgClientRequestForgottenPasswordEmailResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestForgottenPasswordEmailResponse {
    pub fn new() -> CMsgClientRequestForgottenPasswordEmailResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eResult = 1;

    pub fn eResult(&self) -> u32 {
        self.eResult.unwrap_or(0)
    }

    pub fn clear_eResult(&mut self) {
        self.eResult = ::std::option::Option::None;
    }

    pub fn has_eResult(&self) -> bool {
        self.eResult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eResult(&mut self, v: u32) {
        self.eResult = ::std::option::Option::Some(v);
    }

    // optional bool use_secret_question = 2;

    pub fn use_secret_question(&self) -> bool {
        self.use_secret_question.unwrap_or(false)
    }

    pub fn clear_use_secret_question(&mut self) {
        self.use_secret_question = ::std::option::Option::None;
    }

    pub fn has_use_secret_question(&self) -> bool {
        self.use_secret_question.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_secret_question(&mut self, v: bool) {
        self.use_secret_question = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eResult",
            |m: &CMsgClientRequestForgottenPasswordEmailResponse| { &m.eResult },
            |m: &mut CMsgClientRequestForgottenPasswordEmailResponse| { &mut m.eResult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "use_secret_question",
            |m: &CMsgClientRequestForgottenPasswordEmailResponse| { &m.use_secret_question },
            |m: &mut CMsgClientRequestForgottenPasswordEmailResponse| { &mut m.use_secret_question },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRequestForgottenPasswordEmailResponse>(
            "CMsgClientRequestForgottenPasswordEmailResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientRequestForgottenPasswordEmailResponse {
    const NAME: &'static str = "CMsgClientRequestForgottenPasswordEmailResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eResult = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.use_secret_question = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eResult {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.use_secret_question {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eResult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.use_secret_question {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestForgottenPasswordEmailResponse {
        CMsgClientRequestForgottenPasswordEmailResponse::new()
    }

    fn clear(&mut self) {
        self.eResult = ::std::option::Option::None;
        self.use_secret_question = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestForgottenPasswordEmailResponse {
        static instance: CMsgClientRequestForgottenPasswordEmailResponse = CMsgClientRequestForgottenPasswordEmailResponse {
            eResult: ::std::option::Option::None,
            use_secret_question: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientRequestForgottenPasswordEmailResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRequestForgottenPasswordEmailResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRequestForgottenPasswordEmailResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestForgottenPasswordEmailResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientItemAnnouncements)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientItemAnnouncements {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientItemAnnouncements.count_new_items)
    pub count_new_items: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientItemAnnouncements.unseen_items)
    pub unseen_items: ::std::vec::Vec<cmsg_client_item_announcements::UnseenItem>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientItemAnnouncements.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientItemAnnouncements {
    fn default() -> &'a CMsgClientItemAnnouncements {
        <CMsgClientItemAnnouncements as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientItemAnnouncements {
    pub fn new() -> CMsgClientItemAnnouncements {
        ::std::default::Default::default()
    }

    // optional uint32 count_new_items = 1;

    pub fn count_new_items(&self) -> u32 {
        self.count_new_items.unwrap_or(0)
    }

    pub fn clear_count_new_items(&mut self) {
        self.count_new_items = ::std::option::Option::None;
    }

    pub fn has_count_new_items(&self) -> bool {
        self.count_new_items.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count_new_items(&mut self, v: u32) {
        self.count_new_items = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "count_new_items",
            |m: &CMsgClientItemAnnouncements| { &m.count_new_items },
            |m: &mut CMsgClientItemAnnouncements| { &mut m.count_new_items },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "unseen_items",
            |m: &CMsgClientItemAnnouncements| { &m.unseen_items },
            |m: &mut CMsgClientItemAnnouncements| { &mut m.unseen_items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientItemAnnouncements>(
            "CMsgClientItemAnnouncements",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientItemAnnouncements {
    const NAME: &'static str = "CMsgClientItemAnnouncements";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.count_new_items = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.unseen_items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.count_new_items {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.unseen_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.count_new_items {
            os.write_uint32(1, v)?;
        }
        for v in &self.unseen_items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientItemAnnouncements {
        CMsgClientItemAnnouncements::new()
    }

    fn clear(&mut self) {
        self.count_new_items = ::std::option::Option::None;
        self.unseen_items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientItemAnnouncements {
        static instance: CMsgClientItemAnnouncements = CMsgClientItemAnnouncements {
            count_new_items: ::std::option::Option::None,
            unseen_items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientItemAnnouncements {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientItemAnnouncements").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientItemAnnouncements {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientItemAnnouncements {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientItemAnnouncements`
pub mod cmsg_client_item_announcements {
    // @@protoc_insertion_point(message:CMsgClientItemAnnouncements.UnseenItem)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UnseenItem {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientItemAnnouncements.UnseenItem.appid)
        pub appid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientItemAnnouncements.UnseenItem.context_id)
        pub context_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientItemAnnouncements.UnseenItem.asset_id)
        pub asset_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientItemAnnouncements.UnseenItem.amount)
        pub amount: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientItemAnnouncements.UnseenItem.rtime32_gained)
        pub rtime32_gained: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientItemAnnouncements.UnseenItem.source_appid)
        pub source_appid: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientItemAnnouncements.UnseenItem.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UnseenItem {
        fn default() -> &'a UnseenItem {
            <UnseenItem as ::protobuf::Message>::default_instance()
        }
    }

    impl UnseenItem {
        pub fn new() -> UnseenItem {
            ::std::default::Default::default()
        }

        // optional uint32 appid = 1;

        pub fn appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional uint64 context_id = 2;

        pub fn context_id(&self) -> u64 {
            self.context_id.unwrap_or(0)
        }

        pub fn clear_context_id(&mut self) {
            self.context_id = ::std::option::Option::None;
        }

        pub fn has_context_id(&self) -> bool {
            self.context_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_context_id(&mut self, v: u64) {
            self.context_id = ::std::option::Option::Some(v);
        }

        // optional uint64 asset_id = 3;

        pub fn asset_id(&self) -> u64 {
            self.asset_id.unwrap_or(0)
        }

        pub fn clear_asset_id(&mut self) {
            self.asset_id = ::std::option::Option::None;
        }

        pub fn has_asset_id(&self) -> bool {
            self.asset_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_asset_id(&mut self, v: u64) {
            self.asset_id = ::std::option::Option::Some(v);
        }

        // optional uint64 amount = 4;

        pub fn amount(&self) -> u64 {
            self.amount.unwrap_or(0)
        }

        pub fn clear_amount(&mut self) {
            self.amount = ::std::option::Option::None;
        }

        pub fn has_amount(&self) -> bool {
            self.amount.is_some()
        }

        // Param is passed by value, moved
        pub fn set_amount(&mut self, v: u64) {
            self.amount = ::std::option::Option::Some(v);
        }

        // optional fixed32 rtime32_gained = 5;

        pub fn rtime32_gained(&self) -> u32 {
            self.rtime32_gained.unwrap_or(0)
        }

        pub fn clear_rtime32_gained(&mut self) {
            self.rtime32_gained = ::std::option::Option::None;
        }

        pub fn has_rtime32_gained(&self) -> bool {
            self.rtime32_gained.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rtime32_gained(&mut self, v: u32) {
            self.rtime32_gained = ::std::option::Option::Some(v);
        }

        // optional uint32 source_appid = 6;

        pub fn source_appid(&self) -> u32 {
            self.source_appid.unwrap_or(0)
        }

        pub fn clear_source_appid(&mut self) {
            self.source_appid = ::std::option::Option::None;
        }

        pub fn has_source_appid(&self) -> bool {
            self.source_appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_source_appid(&mut self, v: u32) {
            self.source_appid = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "appid",
                |m: &UnseenItem| { &m.appid },
                |m: &mut UnseenItem| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "context_id",
                |m: &UnseenItem| { &m.context_id },
                |m: &mut UnseenItem| { &mut m.context_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "asset_id",
                |m: &UnseenItem| { &m.asset_id },
                |m: &mut UnseenItem| { &mut m.asset_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "amount",
                |m: &UnseenItem| { &m.amount },
                |m: &mut UnseenItem| { &mut m.amount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rtime32_gained",
                |m: &UnseenItem| { &m.rtime32_gained },
                |m: &mut UnseenItem| { &mut m.rtime32_gained },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "source_appid",
                |m: &UnseenItem| { &m.source_appid },
                |m: &mut UnseenItem| { &mut m.source_appid },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UnseenItem>(
                "CMsgClientItemAnnouncements.UnseenItem",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for UnseenItem {
        const NAME: &'static str = "UnseenItem";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.context_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    24 => {
                        self.asset_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    32 => {
                        self.amount = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    45 => {
                        self.rtime32_gained = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    48 => {
                        self.source_appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.appid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.context_id {
                my_size += ::protobuf::rt::uint64_size(2, v);
            }
            if let Some(v) = self.asset_id {
                my_size += ::protobuf::rt::uint64_size(3, v);
            }
            if let Some(v) = self.amount {
                my_size += ::protobuf::rt::uint64_size(4, v);
            }
            if let Some(v) = self.rtime32_gained {
                my_size += 1 + 4;
            }
            if let Some(v) = self.source_appid {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.appid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.context_id {
                os.write_uint64(2, v)?;
            }
            if let Some(v) = self.asset_id {
                os.write_uint64(3, v)?;
            }
            if let Some(v) = self.amount {
                os.write_uint64(4, v)?;
            }
            if let Some(v) = self.rtime32_gained {
                os.write_fixed32(5, v)?;
            }
            if let Some(v) = self.source_appid {
                os.write_uint32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UnseenItem {
            UnseenItem::new()
        }

        fn clear(&mut self) {
            self.appid = ::std::option::Option::None;
            self.context_id = ::std::option::Option::None;
            self.asset_id = ::std::option::Option::None;
            self.amount = ::std::option::Option::None;
            self.rtime32_gained = ::std::option::Option::None;
            self.source_appid = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UnseenItem {
            static instance: UnseenItem = UnseenItem {
                appid: ::std::option::Option::None,
                context_id: ::std::option::Option::None,
                asset_id: ::std::option::Option::None,
                amount: ::std::option::Option::None,
                rtime32_gained: ::std::option::Option::None,
                source_appid: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for UnseenItem {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientItemAnnouncements.UnseenItem").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for UnseenItem {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for UnseenItem {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientRequestItemAnnouncements)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestItemAnnouncements {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestItemAnnouncements.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestItemAnnouncements {
    fn default() -> &'a CMsgClientRequestItemAnnouncements {
        <CMsgClientRequestItemAnnouncements as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestItemAnnouncements {
    pub fn new() -> CMsgClientRequestItemAnnouncements {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRequestItemAnnouncements>(
            "CMsgClientRequestItemAnnouncements",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientRequestItemAnnouncements {
    const NAME: &'static str = "CMsgClientRequestItemAnnouncements";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestItemAnnouncements {
        CMsgClientRequestItemAnnouncements::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestItemAnnouncements {
        static instance: CMsgClientRequestItemAnnouncements = CMsgClientRequestItemAnnouncements {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientRequestItemAnnouncements {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRequestItemAnnouncements").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRequestItemAnnouncements {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestItemAnnouncements {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUserNotifications)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUserNotifications {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUserNotifications.notifications)
    pub notifications: ::std::vec::Vec<cmsg_client_user_notifications::Notification>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUserNotifications.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUserNotifications {
    fn default() -> &'a CMsgClientUserNotifications {
        <CMsgClientUserNotifications as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUserNotifications {
    pub fn new() -> CMsgClientUserNotifications {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "notifications",
            |m: &CMsgClientUserNotifications| { &m.notifications },
            |m: &mut CMsgClientUserNotifications| { &mut m.notifications },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUserNotifications>(
            "CMsgClientUserNotifications",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUserNotifications {
    const NAME: &'static str = "CMsgClientUserNotifications";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.notifications.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.notifications {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.notifications {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUserNotifications {
        CMsgClientUserNotifications::new()
    }

    fn clear(&mut self) {
        self.notifications.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUserNotifications {
        static instance: CMsgClientUserNotifications = CMsgClientUserNotifications {
            notifications: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUserNotifications {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUserNotifications").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUserNotifications {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUserNotifications {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientUserNotifications`
pub mod cmsg_client_user_notifications {
    // @@protoc_insertion_point(message:CMsgClientUserNotifications.Notification)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Notification {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientUserNotifications.Notification.user_notification_type)
        pub user_notification_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientUserNotifications.Notification.count)
        pub count: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientUserNotifications.Notification.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Notification {
        fn default() -> &'a Notification {
            <Notification as ::protobuf::Message>::default_instance()
        }
    }

    impl Notification {
        pub fn new() -> Notification {
            ::std::default::Default::default()
        }

        // optional uint32 user_notification_type = 1;

        pub fn user_notification_type(&self) -> u32 {
            self.user_notification_type.unwrap_or(0)
        }

        pub fn clear_user_notification_type(&mut self) {
            self.user_notification_type = ::std::option::Option::None;
        }

        pub fn has_user_notification_type(&self) -> bool {
            self.user_notification_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_user_notification_type(&mut self, v: u32) {
            self.user_notification_type = ::std::option::Option::Some(v);
        }

        // optional uint32 count = 2;

        pub fn count(&self) -> u32 {
            self.count.unwrap_or(0)
        }

        pub fn clear_count(&mut self) {
            self.count = ::std::option::Option::None;
        }

        pub fn has_count(&self) -> bool {
            self.count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_count(&mut self, v: u32) {
            self.count = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "user_notification_type",
                |m: &Notification| { &m.user_notification_type },
                |m: &mut Notification| { &mut m.user_notification_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "count",
                |m: &Notification| { &m.count },
                |m: &mut Notification| { &mut m.count },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Notification>(
                "CMsgClientUserNotifications.Notification",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Notification {
        const NAME: &'static str = "Notification";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.user_notification_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.user_notification_type {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.count {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.user_notification_type {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.count {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Notification {
            Notification::new()
        }

        fn clear(&mut self) {
            self.user_notification_type = ::std::option::Option::None;
            self.count = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Notification {
            static instance: Notification = Notification {
                user_notification_type: ::std::option::Option::None,
                count: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Notification {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientUserNotifications.Notification").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Notification {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Notification {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientCommentNotifications)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientCommentNotifications {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientCommentNotifications.count_new_comments)
    pub count_new_comments: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientCommentNotifications.count_new_comments_owner)
    pub count_new_comments_owner: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientCommentNotifications.count_new_comments_subscriptions)
    pub count_new_comments_subscriptions: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientCommentNotifications.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientCommentNotifications {
    fn default() -> &'a CMsgClientCommentNotifications {
        <CMsgClientCommentNotifications as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientCommentNotifications {
    pub fn new() -> CMsgClientCommentNotifications {
        ::std::default::Default::default()
    }

    // optional uint32 count_new_comments = 1;

    pub fn count_new_comments(&self) -> u32 {
        self.count_new_comments.unwrap_or(0)
    }

    pub fn clear_count_new_comments(&mut self) {
        self.count_new_comments = ::std::option::Option::None;
    }

    pub fn has_count_new_comments(&self) -> bool {
        self.count_new_comments.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count_new_comments(&mut self, v: u32) {
        self.count_new_comments = ::std::option::Option::Some(v);
    }

    // optional uint32 count_new_comments_owner = 2;

    pub fn count_new_comments_owner(&self) -> u32 {
        self.count_new_comments_owner.unwrap_or(0)
    }

    pub fn clear_count_new_comments_owner(&mut self) {
        self.count_new_comments_owner = ::std::option::Option::None;
    }

    pub fn has_count_new_comments_owner(&self) -> bool {
        self.count_new_comments_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count_new_comments_owner(&mut self, v: u32) {
        self.count_new_comments_owner = ::std::option::Option::Some(v);
    }

    // optional uint32 count_new_comments_subscriptions = 3;

    pub fn count_new_comments_subscriptions(&self) -> u32 {
        self.count_new_comments_subscriptions.unwrap_or(0)
    }

    pub fn clear_count_new_comments_subscriptions(&mut self) {
        self.count_new_comments_subscriptions = ::std::option::Option::None;
    }

    pub fn has_count_new_comments_subscriptions(&self) -> bool {
        self.count_new_comments_subscriptions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count_new_comments_subscriptions(&mut self, v: u32) {
        self.count_new_comments_subscriptions = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "count_new_comments",
            |m: &CMsgClientCommentNotifications| { &m.count_new_comments },
            |m: &mut CMsgClientCommentNotifications| { &mut m.count_new_comments },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "count_new_comments_owner",
            |m: &CMsgClientCommentNotifications| { &m.count_new_comments_owner },
            |m: &mut CMsgClientCommentNotifications| { &mut m.count_new_comments_owner },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "count_new_comments_subscriptions",
            |m: &CMsgClientCommentNotifications| { &m.count_new_comments_subscriptions },
            |m: &mut CMsgClientCommentNotifications| { &mut m.count_new_comments_subscriptions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientCommentNotifications>(
            "CMsgClientCommentNotifications",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientCommentNotifications {
    const NAME: &'static str = "CMsgClientCommentNotifications";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.count_new_comments = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.count_new_comments_owner = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.count_new_comments_subscriptions = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.count_new_comments {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.count_new_comments_owner {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.count_new_comments_subscriptions {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.count_new_comments {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.count_new_comments_owner {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.count_new_comments_subscriptions {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientCommentNotifications {
        CMsgClientCommentNotifications::new()
    }

    fn clear(&mut self) {
        self.count_new_comments = ::std::option::Option::None;
        self.count_new_comments_owner = ::std::option::Option::None;
        self.count_new_comments_subscriptions = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientCommentNotifications {
        static instance: CMsgClientCommentNotifications = CMsgClientCommentNotifications {
            count_new_comments: ::std::option::Option::None,
            count_new_comments_owner: ::std::option::Option::None,
            count_new_comments_subscriptions: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientCommentNotifications {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientCommentNotifications").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientCommentNotifications {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientCommentNotifications {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRequestCommentNotifications)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestCommentNotifications {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestCommentNotifications.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestCommentNotifications {
    fn default() -> &'a CMsgClientRequestCommentNotifications {
        <CMsgClientRequestCommentNotifications as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestCommentNotifications {
    pub fn new() -> CMsgClientRequestCommentNotifications {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRequestCommentNotifications>(
            "CMsgClientRequestCommentNotifications",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientRequestCommentNotifications {
    const NAME: &'static str = "CMsgClientRequestCommentNotifications";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestCommentNotifications {
        CMsgClientRequestCommentNotifications::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestCommentNotifications {
        static instance: CMsgClientRequestCommentNotifications = CMsgClientRequestCommentNotifications {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientRequestCommentNotifications {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRequestCommentNotifications").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRequestCommentNotifications {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestCommentNotifications {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientOfflineMessageNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientOfflineMessageNotification {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientOfflineMessageNotification.offline_messages)
    pub offline_messages: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientOfflineMessageNotification.friends_with_offline_messages)
    pub friends_with_offline_messages: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientOfflineMessageNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientOfflineMessageNotification {
    fn default() -> &'a CMsgClientOfflineMessageNotification {
        <CMsgClientOfflineMessageNotification as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientOfflineMessageNotification {
    pub fn new() -> CMsgClientOfflineMessageNotification {
        ::std::default::Default::default()
    }

    // optional uint32 offline_messages = 1;

    pub fn offline_messages(&self) -> u32 {
        self.offline_messages.unwrap_or(0)
    }

    pub fn clear_offline_messages(&mut self) {
        self.offline_messages = ::std::option::Option::None;
    }

    pub fn has_offline_messages(&self) -> bool {
        self.offline_messages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offline_messages(&mut self, v: u32) {
        self.offline_messages = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "offline_messages",
            |m: &CMsgClientOfflineMessageNotification| { &m.offline_messages },
            |m: &mut CMsgClientOfflineMessageNotification| { &mut m.offline_messages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "friends_with_offline_messages",
            |m: &CMsgClientOfflineMessageNotification| { &m.friends_with_offline_messages },
            |m: &mut CMsgClientOfflineMessageNotification| { &mut m.friends_with_offline_messages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientOfflineMessageNotification>(
            "CMsgClientOfflineMessageNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientOfflineMessageNotification {
    const NAME: &'static str = "CMsgClientOfflineMessageNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.offline_messages = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.friends_with_offline_messages)?;
                },
                16 => {
                    self.friends_with_offline_messages.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.offline_messages {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.friends_with_offline_messages {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.offline_messages {
            os.write_uint32(1, v)?;
        }
        for v in &self.friends_with_offline_messages {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientOfflineMessageNotification {
        CMsgClientOfflineMessageNotification::new()
    }

    fn clear(&mut self) {
        self.offline_messages = ::std::option::Option::None;
        self.friends_with_offline_messages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientOfflineMessageNotification {
        static instance: CMsgClientOfflineMessageNotification = CMsgClientOfflineMessageNotification {
            offline_messages: ::std::option::Option::None,
            friends_with_offline_messages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientOfflineMessageNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientOfflineMessageNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientOfflineMessageNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientOfflineMessageNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRequestOfflineMessageCount)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestOfflineMessageCount {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestOfflineMessageCount.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestOfflineMessageCount {
    fn default() -> &'a CMsgClientRequestOfflineMessageCount {
        <CMsgClientRequestOfflineMessageCount as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestOfflineMessageCount {
    pub fn new() -> CMsgClientRequestOfflineMessageCount {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRequestOfflineMessageCount>(
            "CMsgClientRequestOfflineMessageCount",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientRequestOfflineMessageCount {
    const NAME: &'static str = "CMsgClientRequestOfflineMessageCount";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestOfflineMessageCount {
        CMsgClientRequestOfflineMessageCount::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestOfflineMessageCount {
        static instance: CMsgClientRequestOfflineMessageCount = CMsgClientRequestOfflineMessageCount {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientRequestOfflineMessageCount {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRequestOfflineMessageCount").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRequestOfflineMessageCount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestOfflineMessageCount {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientChatGetFriendMessageHistory)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientChatGetFriendMessageHistory {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientChatGetFriendMessageHistory.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientChatGetFriendMessageHistory.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientChatGetFriendMessageHistory {
    fn default() -> &'a CMsgClientChatGetFriendMessageHistory {
        <CMsgClientChatGetFriendMessageHistory as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientChatGetFriendMessageHistory {
    pub fn new() -> CMsgClientChatGetFriendMessageHistory {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CMsgClientChatGetFriendMessageHistory| { &m.steamid },
            |m: &mut CMsgClientChatGetFriendMessageHistory| { &mut m.steamid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientChatGetFriendMessageHistory>(
            "CMsgClientChatGetFriendMessageHistory",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientChatGetFriendMessageHistory {
    const NAME: &'static str = "CMsgClientChatGetFriendMessageHistory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientChatGetFriendMessageHistory {
        CMsgClientChatGetFriendMessageHistory::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientChatGetFriendMessageHistory {
        static instance: CMsgClientChatGetFriendMessageHistory = CMsgClientChatGetFriendMessageHistory {
            steamid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientChatGetFriendMessageHistory {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientChatGetFriendMessageHistory").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientChatGetFriendMessageHistory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientChatGetFriendMessageHistory {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientChatGetFriendMessageHistoryResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientChatGetFriendMessageHistoryResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientChatGetFriendMessageHistoryResponse.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientChatGetFriendMessageHistoryResponse.success)
    pub success: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientChatGetFriendMessageHistoryResponse.messages)
    pub messages: ::std::vec::Vec<cmsg_client_chat_get_friend_message_history_response::FriendMessage>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientChatGetFriendMessageHistoryResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientChatGetFriendMessageHistoryResponse {
    fn default() -> &'a CMsgClientChatGetFriendMessageHistoryResponse {
        <CMsgClientChatGetFriendMessageHistoryResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientChatGetFriendMessageHistoryResponse {
    pub fn new() -> CMsgClientChatGetFriendMessageHistoryResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 success = 2;

    pub fn success(&self) -> u32 {
        self.success.unwrap_or(0)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: u32) {
        self.success = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CMsgClientChatGetFriendMessageHistoryResponse| { &m.steamid },
            |m: &mut CMsgClientChatGetFriendMessageHistoryResponse| { &mut m.steamid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "success",
            |m: &CMsgClientChatGetFriendMessageHistoryResponse| { &m.success },
            |m: &mut CMsgClientChatGetFriendMessageHistoryResponse| { &mut m.success },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "messages",
            |m: &CMsgClientChatGetFriendMessageHistoryResponse| { &m.messages },
            |m: &mut CMsgClientChatGetFriendMessageHistoryResponse| { &mut m.messages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientChatGetFriendMessageHistoryResponse>(
            "CMsgClientChatGetFriendMessageHistoryResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientChatGetFriendMessageHistoryResponse {
    const NAME: &'static str = "CMsgClientChatGetFriendMessageHistoryResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.success = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.messages.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.success {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.success {
            os.write_uint32(2, v)?;
        }
        for v in &self.messages {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientChatGetFriendMessageHistoryResponse {
        CMsgClientChatGetFriendMessageHistoryResponse::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.success = ::std::option::Option::None;
        self.messages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientChatGetFriendMessageHistoryResponse {
        static instance: CMsgClientChatGetFriendMessageHistoryResponse = CMsgClientChatGetFriendMessageHistoryResponse {
            steamid: ::std::option::Option::None,
            success: ::std::option::Option::None,
            messages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientChatGetFriendMessageHistoryResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientChatGetFriendMessageHistoryResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientChatGetFriendMessageHistoryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientChatGetFriendMessageHistoryResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientChatGetFriendMessageHistoryResponse`
pub mod cmsg_client_chat_get_friend_message_history_response {
    // @@protoc_insertion_point(message:CMsgClientChatGetFriendMessageHistoryResponse.FriendMessage)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FriendMessage {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientChatGetFriendMessageHistoryResponse.FriendMessage.accountid)
        pub accountid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientChatGetFriendMessageHistoryResponse.FriendMessage.timestamp)
        pub timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientChatGetFriendMessageHistoryResponse.FriendMessage.message)
        pub message: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientChatGetFriendMessageHistoryResponse.FriendMessage.unread)
        pub unread: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientChatGetFriendMessageHistoryResponse.FriendMessage.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FriendMessage {
        fn default() -> &'a FriendMessage {
            <FriendMessage as ::protobuf::Message>::default_instance()
        }
    }

    impl FriendMessage {
        pub fn new() -> FriendMessage {
            ::std::default::Default::default()
        }

        // optional uint32 accountid = 1;

        pub fn accountid(&self) -> u32 {
            self.accountid.unwrap_or(0)
        }

        pub fn clear_accountid(&mut self) {
            self.accountid = ::std::option::Option::None;
        }

        pub fn has_accountid(&self) -> bool {
            self.accountid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_accountid(&mut self, v: u32) {
            self.accountid = ::std::option::Option::Some(v);
        }

        // optional uint32 timestamp = 2;

        pub fn timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        // optional string message = 3;

        pub fn message(&self) -> &str {
            match self.message.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_message(&mut self) {
            self.message = ::std::option::Option::None;
        }

        pub fn has_message(&self) -> bool {
            self.message.is_some()
        }

        // Param is passed by value, moved
        pub fn set_message(&mut self, v: ::std::string::String) {
            self.message = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_message(&mut self) -> &mut ::std::string::String {
            if self.message.is_none() {
                self.message = ::std::option::Option::Some(::std::string::String::new());
            }
            self.message.as_mut().unwrap()
        }

        // Take field
        pub fn take_message(&mut self) -> ::std::string::String {
            self.message.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool unread = 4;

        pub fn unread(&self) -> bool {
            self.unread.unwrap_or(false)
        }

        pub fn clear_unread(&mut self) {
            self.unread = ::std::option::Option::None;
        }

        pub fn has_unread(&self) -> bool {
            self.unread.is_some()
        }

        // Param is passed by value, moved
        pub fn set_unread(&mut self, v: bool) {
            self.unread = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "accountid",
                |m: &FriendMessage| { &m.accountid },
                |m: &mut FriendMessage| { &mut m.accountid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "timestamp",
                |m: &FriendMessage| { &m.timestamp },
                |m: &mut FriendMessage| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "message",
                |m: &FriendMessage| { &m.message },
                |m: &mut FriendMessage| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "unread",
                |m: &FriendMessage| { &m.unread },
                |m: &mut FriendMessage| { &mut m.unread },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendMessage>(
                "CMsgClientChatGetFriendMessageHistoryResponse.FriendMessage",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for FriendMessage {
        const NAME: &'static str = "FriendMessage";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.message = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.unread = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.accountid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.timestamp {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.message.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.unread {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.accountid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.timestamp {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.message.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.unread {
                os.write_bool(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FriendMessage {
            FriendMessage::new()
        }

        fn clear(&mut self) {
            self.accountid = ::std::option::Option::None;
            self.timestamp = ::std::option::Option::None;
            self.message = ::std::option::Option::None;
            self.unread = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FriendMessage {
            static instance: FriendMessage = FriendMessage {
                accountid: ::std::option::Option::None,
                timestamp: ::std::option::Option::None,
                message: ::std::option::Option::None,
                unread: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for FriendMessage {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientChatGetFriendMessageHistoryResponse.FriendMessage").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for FriendMessage {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for FriendMessage {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientChatGetFriendMessageHistoryForOfflineMessages)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientChatGetFriendMessageHistoryForOfflineMessages.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
    fn default() -> &'a CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
        <CMsgClientChatGetFriendMessageHistoryForOfflineMessages as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
    pub fn new() -> CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientChatGetFriendMessageHistoryForOfflineMessages>(
            "CMsgClientChatGetFriendMessageHistoryForOfflineMessages",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
    const NAME: &'static str = "CMsgClientChatGetFriendMessageHistoryForOfflineMessages";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
        CMsgClientChatGetFriendMessageHistoryForOfflineMessages::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
        static instance: CMsgClientChatGetFriendMessageHistoryForOfflineMessages = CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientChatGetFriendMessageHistoryForOfflineMessages").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientFSGetFriendsSteamLevels)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientFSGetFriendsSteamLevels {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientFSGetFriendsSteamLevels.accountids)
    pub accountids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientFSGetFriendsSteamLevels.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientFSGetFriendsSteamLevels {
    fn default() -> &'a CMsgClientFSGetFriendsSteamLevels {
        <CMsgClientFSGetFriendsSteamLevels as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientFSGetFriendsSteamLevels {
    pub fn new() -> CMsgClientFSGetFriendsSteamLevels {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "accountids",
            |m: &CMsgClientFSGetFriendsSteamLevels| { &m.accountids },
            |m: &mut CMsgClientFSGetFriendsSteamLevels| { &mut m.accountids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientFSGetFriendsSteamLevels>(
            "CMsgClientFSGetFriendsSteamLevels",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientFSGetFriendsSteamLevels {
    const NAME: &'static str = "CMsgClientFSGetFriendsSteamLevels";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.accountids)?;
                },
                8 => {
                    self.accountids.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.accountids {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.accountids {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientFSGetFriendsSteamLevels {
        CMsgClientFSGetFriendsSteamLevels::new()
    }

    fn clear(&mut self) {
        self.accountids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientFSGetFriendsSteamLevels {
        static instance: CMsgClientFSGetFriendsSteamLevels = CMsgClientFSGetFriendsSteamLevels {
            accountids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientFSGetFriendsSteamLevels {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientFSGetFriendsSteamLevels").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientFSGetFriendsSteamLevels {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientFSGetFriendsSteamLevels {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientFSGetFriendsSteamLevelsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientFSGetFriendsSteamLevelsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientFSGetFriendsSteamLevelsResponse.friends)
    pub friends: ::std::vec::Vec<cmsg_client_fsget_friends_steam_levels_response::Friend>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientFSGetFriendsSteamLevelsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientFSGetFriendsSteamLevelsResponse {
    fn default() -> &'a CMsgClientFSGetFriendsSteamLevelsResponse {
        <CMsgClientFSGetFriendsSteamLevelsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientFSGetFriendsSteamLevelsResponse {
    pub fn new() -> CMsgClientFSGetFriendsSteamLevelsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "friends",
            |m: &CMsgClientFSGetFriendsSteamLevelsResponse| { &m.friends },
            |m: &mut CMsgClientFSGetFriendsSteamLevelsResponse| { &mut m.friends },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientFSGetFriendsSteamLevelsResponse>(
            "CMsgClientFSGetFriendsSteamLevelsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientFSGetFriendsSteamLevelsResponse {
    const NAME: &'static str = "CMsgClientFSGetFriendsSteamLevelsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.friends.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.friends {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.friends {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientFSGetFriendsSteamLevelsResponse {
        CMsgClientFSGetFriendsSteamLevelsResponse::new()
    }

    fn clear(&mut self) {
        self.friends.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientFSGetFriendsSteamLevelsResponse {
        static instance: CMsgClientFSGetFriendsSteamLevelsResponse = CMsgClientFSGetFriendsSteamLevelsResponse {
            friends: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientFSGetFriendsSteamLevelsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientFSGetFriendsSteamLevelsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientFSGetFriendsSteamLevelsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientFSGetFriendsSteamLevelsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientFSGetFriendsSteamLevelsResponse`
pub mod cmsg_client_fsget_friends_steam_levels_response {
    // @@protoc_insertion_point(message:CMsgClientFSGetFriendsSteamLevelsResponse.Friend)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Friend {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientFSGetFriendsSteamLevelsResponse.Friend.accountid)
        pub accountid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientFSGetFriendsSteamLevelsResponse.Friend.level)
        pub level: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientFSGetFriendsSteamLevelsResponse.Friend.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Friend {
        fn default() -> &'a Friend {
            <Friend as ::protobuf::Message>::default_instance()
        }
    }

    impl Friend {
        pub fn new() -> Friend {
            ::std::default::Default::default()
        }

        // optional uint32 accountid = 1;

        pub fn accountid(&self) -> u32 {
            self.accountid.unwrap_or(0)
        }

        pub fn clear_accountid(&mut self) {
            self.accountid = ::std::option::Option::None;
        }

        pub fn has_accountid(&self) -> bool {
            self.accountid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_accountid(&mut self, v: u32) {
            self.accountid = ::std::option::Option::Some(v);
        }

        // optional uint32 level = 2;

        pub fn level(&self) -> u32 {
            self.level.unwrap_or(0)
        }

        pub fn clear_level(&mut self) {
            self.level = ::std::option::Option::None;
        }

        pub fn has_level(&self) -> bool {
            self.level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_level(&mut self, v: u32) {
            self.level = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "accountid",
                |m: &Friend| { &m.accountid },
                |m: &mut Friend| { &mut m.accountid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "level",
                |m: &Friend| { &m.level },
                |m: &mut Friend| { &mut m.level },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Friend>(
                "CMsgClientFSGetFriendsSteamLevelsResponse.Friend",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Friend {
        const NAME: &'static str = "Friend";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.level = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.accountid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.level {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.accountid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.level {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Friend {
            Friend::new()
        }

        fn clear(&mut self) {
            self.accountid = ::std::option::Option::None;
            self.level = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Friend {
            static instance: Friend = Friend {
                accountid: ::std::option::Option::None,
                level: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Friend {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientFSGetFriendsSteamLevelsResponse.Friend").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Friend {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Friend {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientEmailAddrInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientEmailAddrInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientEmailAddrInfo.email_address)
    pub email_address: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientEmailAddrInfo.email_is_validated)
    pub email_is_validated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientEmailAddrInfo.email_validation_changed)
    pub email_validation_changed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientEmailAddrInfo.credential_change_requires_code)
    pub credential_change_requires_code: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientEmailAddrInfo.password_or_secretqa_change_requires_code)
    pub password_or_secretqa_change_requires_code: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientEmailAddrInfo.remind_user_about_email)
    pub remind_user_about_email: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientEmailAddrInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientEmailAddrInfo {
    fn default() -> &'a CMsgClientEmailAddrInfo {
        <CMsgClientEmailAddrInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientEmailAddrInfo {
    pub fn new() -> CMsgClientEmailAddrInfo {
        ::std::default::Default::default()
    }

    // optional string email_address = 1;

    pub fn email_address(&self) -> &str {
        match self.email_address.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_email_address(&mut self) {
        self.email_address = ::std::option::Option::None;
    }

    pub fn has_email_address(&self) -> bool {
        self.email_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_email_address(&mut self, v: ::std::string::String) {
        self.email_address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_email_address(&mut self) -> &mut ::std::string::String {
        if self.email_address.is_none() {
            self.email_address = ::std::option::Option::Some(::std::string::String::new());
        }
        self.email_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_email_address(&mut self) -> ::std::string::String {
        self.email_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool email_is_validated = 2;

    pub fn email_is_validated(&self) -> bool {
        self.email_is_validated.unwrap_or(false)
    }

    pub fn clear_email_is_validated(&mut self) {
        self.email_is_validated = ::std::option::Option::None;
    }

    pub fn has_email_is_validated(&self) -> bool {
        self.email_is_validated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_email_is_validated(&mut self, v: bool) {
        self.email_is_validated = ::std::option::Option::Some(v);
    }

    // optional bool email_validation_changed = 3;

    pub fn email_validation_changed(&self) -> bool {
        self.email_validation_changed.unwrap_or(false)
    }

    pub fn clear_email_validation_changed(&mut self) {
        self.email_validation_changed = ::std::option::Option::None;
    }

    pub fn has_email_validation_changed(&self) -> bool {
        self.email_validation_changed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_email_validation_changed(&mut self, v: bool) {
        self.email_validation_changed = ::std::option::Option::Some(v);
    }

    // optional bool credential_change_requires_code = 4;

    pub fn credential_change_requires_code(&self) -> bool {
        self.credential_change_requires_code.unwrap_or(false)
    }

    pub fn clear_credential_change_requires_code(&mut self) {
        self.credential_change_requires_code = ::std::option::Option::None;
    }

    pub fn has_credential_change_requires_code(&self) -> bool {
        self.credential_change_requires_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_credential_change_requires_code(&mut self, v: bool) {
        self.credential_change_requires_code = ::std::option::Option::Some(v);
    }

    // optional bool password_or_secretqa_change_requires_code = 5;

    pub fn password_or_secretqa_change_requires_code(&self) -> bool {
        self.password_or_secretqa_change_requires_code.unwrap_or(false)
    }

    pub fn clear_password_or_secretqa_change_requires_code(&mut self) {
        self.password_or_secretqa_change_requires_code = ::std::option::Option::None;
    }

    pub fn has_password_or_secretqa_change_requires_code(&self) -> bool {
        self.password_or_secretqa_change_requires_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password_or_secretqa_change_requires_code(&mut self, v: bool) {
        self.password_or_secretqa_change_requires_code = ::std::option::Option::Some(v);
    }

    // optional bool remind_user_about_email = 6;

    pub fn remind_user_about_email(&self) -> bool {
        self.remind_user_about_email.unwrap_or(false)
    }

    pub fn clear_remind_user_about_email(&mut self) {
        self.remind_user_about_email = ::std::option::Option::None;
    }

    pub fn has_remind_user_about_email(&self) -> bool {
        self.remind_user_about_email.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remind_user_about_email(&mut self, v: bool) {
        self.remind_user_about_email = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "email_address",
            |m: &CMsgClientEmailAddrInfo| { &m.email_address },
            |m: &mut CMsgClientEmailAddrInfo| { &mut m.email_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "email_is_validated",
            |m: &CMsgClientEmailAddrInfo| { &m.email_is_validated },
            |m: &mut CMsgClientEmailAddrInfo| { &mut m.email_is_validated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "email_validation_changed",
            |m: &CMsgClientEmailAddrInfo| { &m.email_validation_changed },
            |m: &mut CMsgClientEmailAddrInfo| { &mut m.email_validation_changed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "credential_change_requires_code",
            |m: &CMsgClientEmailAddrInfo| { &m.credential_change_requires_code },
            |m: &mut CMsgClientEmailAddrInfo| { &mut m.credential_change_requires_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "password_or_secretqa_change_requires_code",
            |m: &CMsgClientEmailAddrInfo| { &m.password_or_secretqa_change_requires_code },
            |m: &mut CMsgClientEmailAddrInfo| { &mut m.password_or_secretqa_change_requires_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "remind_user_about_email",
            |m: &CMsgClientEmailAddrInfo| { &m.remind_user_about_email },
            |m: &mut CMsgClientEmailAddrInfo| { &mut m.remind_user_about_email },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientEmailAddrInfo>(
            "CMsgClientEmailAddrInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientEmailAddrInfo {
    const NAME: &'static str = "CMsgClientEmailAddrInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.email_address = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.email_is_validated = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.email_validation_changed = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.credential_change_requires_code = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.password_or_secretqa_change_requires_code = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.remind_user_about_email = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.email_address.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.email_is_validated {
            my_size += 1 + 1;
        }
        if let Some(v) = self.email_validation_changed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.credential_change_requires_code {
            my_size += 1 + 1;
        }
        if let Some(v) = self.password_or_secretqa_change_requires_code {
            my_size += 1 + 1;
        }
        if let Some(v) = self.remind_user_about_email {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.email_address.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.email_is_validated {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.email_validation_changed {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.credential_change_requires_code {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.password_or_secretqa_change_requires_code {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.remind_user_about_email {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientEmailAddrInfo {
        CMsgClientEmailAddrInfo::new()
    }

    fn clear(&mut self) {
        self.email_address = ::std::option::Option::None;
        self.email_is_validated = ::std::option::Option::None;
        self.email_validation_changed = ::std::option::Option::None;
        self.credential_change_requires_code = ::std::option::Option::None;
        self.password_or_secretqa_change_requires_code = ::std::option::Option::None;
        self.remind_user_about_email = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientEmailAddrInfo {
        static instance: CMsgClientEmailAddrInfo = CMsgClientEmailAddrInfo {
            email_address: ::std::option::Option::None,
            email_is_validated: ::std::option::Option::None,
            email_validation_changed: ::std::option::Option::None,
            credential_change_requires_code: ::std::option::Option::None,
            password_or_secretqa_change_requires_code: ::std::option::Option::None,
            remind_user_about_email: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientEmailAddrInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientEmailAddrInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientEmailAddrInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientEmailAddrInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgCREItemVoteSummary)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCREItemVoteSummary {
    // message fields
    // @@protoc_insertion_point(field:CMsgCREItemVoteSummary.published_file_ids)
    pub published_file_ids: ::std::vec::Vec<cmsg_creitem_vote_summary::PublishedFileId>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCREItemVoteSummary.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCREItemVoteSummary {
    fn default() -> &'a CMsgCREItemVoteSummary {
        <CMsgCREItemVoteSummary as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCREItemVoteSummary {
    pub fn new() -> CMsgCREItemVoteSummary {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "published_file_ids",
            |m: &CMsgCREItemVoteSummary| { &m.published_file_ids },
            |m: &mut CMsgCREItemVoteSummary| { &mut m.published_file_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCREItemVoteSummary>(
            "CMsgCREItemVoteSummary",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgCREItemVoteSummary {
    const NAME: &'static str = "CMsgCREItemVoteSummary";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.published_file_ids.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.published_file_ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.published_file_ids {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCREItemVoteSummary {
        CMsgCREItemVoteSummary::new()
    }

    fn clear(&mut self) {
        self.published_file_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCREItemVoteSummary {
        static instance: CMsgCREItemVoteSummary = CMsgCREItemVoteSummary {
            published_file_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgCREItemVoteSummary {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCREItemVoteSummary").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCREItemVoteSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCREItemVoteSummary {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgCREItemVoteSummary`
pub mod cmsg_creitem_vote_summary {
    // @@protoc_insertion_point(message:CMsgCREItemVoteSummary.PublishedFileId)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PublishedFileId {
        // message fields
        // @@protoc_insertion_point(field:CMsgCREItemVoteSummary.PublishedFileId.published_file_id)
        pub published_file_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgCREItemVoteSummary.PublishedFileId.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PublishedFileId {
        fn default() -> &'a PublishedFileId {
            <PublishedFileId as ::protobuf::Message>::default_instance()
        }
    }

    impl PublishedFileId {
        pub fn new() -> PublishedFileId {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "published_file_id",
                |m: &PublishedFileId| { &m.published_file_id },
                |m: &mut PublishedFileId| { &mut m.published_file_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PublishedFileId>(
                "CMsgCREItemVoteSummary.PublishedFileId",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PublishedFileId {
        const NAME: &'static str = "PublishedFileId";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PublishedFileId {
            PublishedFileId::new()
        }

        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PublishedFileId {
            static instance: PublishedFileId = PublishedFileId {
                published_file_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PublishedFileId {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgCREItemVoteSummary.PublishedFileId").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PublishedFileId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PublishedFileId {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgCREItemVoteSummaryResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCREItemVoteSummaryResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgCREItemVoteSummaryResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgCREItemVoteSummaryResponse.item_vote_summaries)
    pub item_vote_summaries: ::std::vec::Vec<cmsg_creitem_vote_summary_response::ItemVoteSummary>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCREItemVoteSummaryResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCREItemVoteSummaryResponse {
    fn default() -> &'a CMsgCREItemVoteSummaryResponse {
        <CMsgCREItemVoteSummaryResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCREItemVoteSummaryResponse {
    pub fn new() -> CMsgCREItemVoteSummaryResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgCREItemVoteSummaryResponse| { &m.eresult },
            |m: &mut CMsgCREItemVoteSummaryResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "item_vote_summaries",
            |m: &CMsgCREItemVoteSummaryResponse| { &m.item_vote_summaries },
            |m: &mut CMsgCREItemVoteSummaryResponse| { &mut m.item_vote_summaries },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCREItemVoteSummaryResponse>(
            "CMsgCREItemVoteSummaryResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgCREItemVoteSummaryResponse {
    const NAME: &'static str = "CMsgCREItemVoteSummaryResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.item_vote_summaries.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.item_vote_summaries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.item_vote_summaries {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCREItemVoteSummaryResponse {
        CMsgCREItemVoteSummaryResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.item_vote_summaries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCREItemVoteSummaryResponse {
        static instance: CMsgCREItemVoteSummaryResponse = CMsgCREItemVoteSummaryResponse {
            eresult: ::std::option::Option::None,
            item_vote_summaries: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgCREItemVoteSummaryResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCREItemVoteSummaryResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCREItemVoteSummaryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCREItemVoteSummaryResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgCREItemVoteSummaryResponse`
pub mod cmsg_creitem_vote_summary_response {
    // @@protoc_insertion_point(message:CMsgCREItemVoteSummaryResponse.ItemVoteSummary)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ItemVoteSummary {
        // message fields
        // @@protoc_insertion_point(field:CMsgCREItemVoteSummaryResponse.ItemVoteSummary.published_file_id)
        pub published_file_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgCREItemVoteSummaryResponse.ItemVoteSummary.votes_for)
        pub votes_for: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgCREItemVoteSummaryResponse.ItemVoteSummary.votes_against)
        pub votes_against: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgCREItemVoteSummaryResponse.ItemVoteSummary.reports)
        pub reports: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgCREItemVoteSummaryResponse.ItemVoteSummary.score)
        pub score: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgCREItemVoteSummaryResponse.ItemVoteSummary.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ItemVoteSummary {
        fn default() -> &'a ItemVoteSummary {
            <ItemVoteSummary as ::protobuf::Message>::default_instance()
        }
    }

    impl ItemVoteSummary {
        pub fn new() -> ItemVoteSummary {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }

        // optional int32 votes_for = 2;

        pub fn votes_for(&self) -> i32 {
            self.votes_for.unwrap_or(0)
        }

        pub fn clear_votes_for(&mut self) {
            self.votes_for = ::std::option::Option::None;
        }

        pub fn has_votes_for(&self) -> bool {
            self.votes_for.is_some()
        }

        // Param is passed by value, moved
        pub fn set_votes_for(&mut self, v: i32) {
            self.votes_for = ::std::option::Option::Some(v);
        }

        // optional int32 votes_against = 3;

        pub fn votes_against(&self) -> i32 {
            self.votes_against.unwrap_or(0)
        }

        pub fn clear_votes_against(&mut self) {
            self.votes_against = ::std::option::Option::None;
        }

        pub fn has_votes_against(&self) -> bool {
            self.votes_against.is_some()
        }

        // Param is passed by value, moved
        pub fn set_votes_against(&mut self, v: i32) {
            self.votes_against = ::std::option::Option::Some(v);
        }

        // optional int32 reports = 4;

        pub fn reports(&self) -> i32 {
            self.reports.unwrap_or(0)
        }

        pub fn clear_reports(&mut self) {
            self.reports = ::std::option::Option::None;
        }

        pub fn has_reports(&self) -> bool {
            self.reports.is_some()
        }

        // Param is passed by value, moved
        pub fn set_reports(&mut self, v: i32) {
            self.reports = ::std::option::Option::Some(v);
        }

        // optional float score = 5;

        pub fn score(&self) -> f32 {
            self.score.unwrap_or(0.)
        }

        pub fn clear_score(&mut self) {
            self.score = ::std::option::Option::None;
        }

        pub fn has_score(&self) -> bool {
            self.score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score(&mut self, v: f32) {
            self.score = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "published_file_id",
                |m: &ItemVoteSummary| { &m.published_file_id },
                |m: &mut ItemVoteSummary| { &mut m.published_file_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "votes_for",
                |m: &ItemVoteSummary| { &m.votes_for },
                |m: &mut ItemVoteSummary| { &mut m.votes_for },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "votes_against",
                |m: &ItemVoteSummary| { &m.votes_against },
                |m: &mut ItemVoteSummary| { &mut m.votes_against },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "reports",
                |m: &ItemVoteSummary| { &m.reports },
                |m: &mut ItemVoteSummary| { &mut m.reports },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "score",
                |m: &ItemVoteSummary| { &m.score },
                |m: &mut ItemVoteSummary| { &mut m.score },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ItemVoteSummary>(
                "CMsgCREItemVoteSummaryResponse.ItemVoteSummary",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ItemVoteSummary {
        const NAME: &'static str = "ItemVoteSummary";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.votes_for = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.votes_against = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.reports = ::std::option::Option::Some(is.read_int32()?);
                    },
                    45 => {
                        self.score = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.votes_for {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.votes_against {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.reports {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.score {
                my_size += 1 + 4;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.votes_for {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.votes_against {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.reports {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.score {
                os.write_float(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ItemVoteSummary {
            ItemVoteSummary::new()
        }

        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.votes_for = ::std::option::Option::None;
            self.votes_against = ::std::option::Option::None;
            self.reports = ::std::option::Option::None;
            self.score = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ItemVoteSummary {
            static instance: ItemVoteSummary = ItemVoteSummary {
                published_file_id: ::std::option::Option::None,
                votes_for: ::std::option::Option::None,
                votes_against: ::std::option::Option::None,
                reports: ::std::option::Option::None,
                score: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ItemVoteSummary {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgCREItemVoteSummaryResponse.ItemVoteSummary").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ItemVoteSummary {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ItemVoteSummary {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgCREUpdateUserPublishedItemVote)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCREUpdateUserPublishedItemVote {
    // message fields
    // @@protoc_insertion_point(field:CMsgCREUpdateUserPublishedItemVote.published_file_id)
    pub published_file_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgCREUpdateUserPublishedItemVote.vote_up)
    pub vote_up: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCREUpdateUserPublishedItemVote.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCREUpdateUserPublishedItemVote {
    fn default() -> &'a CMsgCREUpdateUserPublishedItemVote {
        <CMsgCREUpdateUserPublishedItemVote as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCREUpdateUserPublishedItemVote {
    pub fn new() -> CMsgCREUpdateUserPublishedItemVote {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;

    pub fn published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }

    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional bool vote_up = 2;

    pub fn vote_up(&self) -> bool {
        self.vote_up.unwrap_or(false)
    }

    pub fn clear_vote_up(&mut self) {
        self.vote_up = ::std::option::Option::None;
    }

    pub fn has_vote_up(&self) -> bool {
        self.vote_up.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote_up(&mut self, v: bool) {
        self.vote_up = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "published_file_id",
            |m: &CMsgCREUpdateUserPublishedItemVote| { &m.published_file_id },
            |m: &mut CMsgCREUpdateUserPublishedItemVote| { &mut m.published_file_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vote_up",
            |m: &CMsgCREUpdateUserPublishedItemVote| { &m.vote_up },
            |m: &mut CMsgCREUpdateUserPublishedItemVote| { &mut m.vote_up },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCREUpdateUserPublishedItemVote>(
            "CMsgCREUpdateUserPublishedItemVote",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgCREUpdateUserPublishedItemVote {
    const NAME: &'static str = "CMsgCREUpdateUserPublishedItemVote";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.vote_up = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.vote_up {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.vote_up {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCREUpdateUserPublishedItemVote {
        CMsgCREUpdateUserPublishedItemVote::new()
    }

    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.vote_up = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCREUpdateUserPublishedItemVote {
        static instance: CMsgCREUpdateUserPublishedItemVote = CMsgCREUpdateUserPublishedItemVote {
            published_file_id: ::std::option::Option::None,
            vote_up: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgCREUpdateUserPublishedItemVote {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCREUpdateUserPublishedItemVote").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCREUpdateUserPublishedItemVote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCREUpdateUserPublishedItemVote {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgCREUpdateUserPublishedItemVoteResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCREUpdateUserPublishedItemVoteResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgCREUpdateUserPublishedItemVoteResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCREUpdateUserPublishedItemVoteResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCREUpdateUserPublishedItemVoteResponse {
    fn default() -> &'a CMsgCREUpdateUserPublishedItemVoteResponse {
        <CMsgCREUpdateUserPublishedItemVoteResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCREUpdateUserPublishedItemVoteResponse {
    pub fn new() -> CMsgCREUpdateUserPublishedItemVoteResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgCREUpdateUserPublishedItemVoteResponse| { &m.eresult },
            |m: &mut CMsgCREUpdateUserPublishedItemVoteResponse| { &mut m.eresult },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCREUpdateUserPublishedItemVoteResponse>(
            "CMsgCREUpdateUserPublishedItemVoteResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgCREUpdateUserPublishedItemVoteResponse {
    const NAME: &'static str = "CMsgCREUpdateUserPublishedItemVoteResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCREUpdateUserPublishedItemVoteResponse {
        CMsgCREUpdateUserPublishedItemVoteResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCREUpdateUserPublishedItemVoteResponse {
        static instance: CMsgCREUpdateUserPublishedItemVoteResponse = CMsgCREUpdateUserPublishedItemVoteResponse {
            eresult: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgCREUpdateUserPublishedItemVoteResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCREUpdateUserPublishedItemVoteResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCREUpdateUserPublishedItemVoteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCREUpdateUserPublishedItemVoteResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgCREGetUserPublishedItemVoteDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCREGetUserPublishedItemVoteDetails {
    // message fields
    // @@protoc_insertion_point(field:CMsgCREGetUserPublishedItemVoteDetails.published_file_ids)
    pub published_file_ids: ::std::vec::Vec<cmsg_creget_user_published_item_vote_details::PublishedFileId>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCREGetUserPublishedItemVoteDetails.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCREGetUserPublishedItemVoteDetails {
    fn default() -> &'a CMsgCREGetUserPublishedItemVoteDetails {
        <CMsgCREGetUserPublishedItemVoteDetails as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCREGetUserPublishedItemVoteDetails {
    pub fn new() -> CMsgCREGetUserPublishedItemVoteDetails {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "published_file_ids",
            |m: &CMsgCREGetUserPublishedItemVoteDetails| { &m.published_file_ids },
            |m: &mut CMsgCREGetUserPublishedItemVoteDetails| { &mut m.published_file_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCREGetUserPublishedItemVoteDetails>(
            "CMsgCREGetUserPublishedItemVoteDetails",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgCREGetUserPublishedItemVoteDetails {
    const NAME: &'static str = "CMsgCREGetUserPublishedItemVoteDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.published_file_ids.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.published_file_ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.published_file_ids {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCREGetUserPublishedItemVoteDetails {
        CMsgCREGetUserPublishedItemVoteDetails::new()
    }

    fn clear(&mut self) {
        self.published_file_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCREGetUserPublishedItemVoteDetails {
        static instance: CMsgCREGetUserPublishedItemVoteDetails = CMsgCREGetUserPublishedItemVoteDetails {
            published_file_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgCREGetUserPublishedItemVoteDetails {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCREGetUserPublishedItemVoteDetails").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCREGetUserPublishedItemVoteDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCREGetUserPublishedItemVoteDetails {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgCREGetUserPublishedItemVoteDetails`
pub mod cmsg_creget_user_published_item_vote_details {
    // @@protoc_insertion_point(message:CMsgCREGetUserPublishedItemVoteDetails.PublishedFileId)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PublishedFileId {
        // message fields
        // @@protoc_insertion_point(field:CMsgCREGetUserPublishedItemVoteDetails.PublishedFileId.published_file_id)
        pub published_file_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgCREGetUserPublishedItemVoteDetails.PublishedFileId.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PublishedFileId {
        fn default() -> &'a PublishedFileId {
            <PublishedFileId as ::protobuf::Message>::default_instance()
        }
    }

    impl PublishedFileId {
        pub fn new() -> PublishedFileId {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "published_file_id",
                |m: &PublishedFileId| { &m.published_file_id },
                |m: &mut PublishedFileId| { &mut m.published_file_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PublishedFileId>(
                "CMsgCREGetUserPublishedItemVoteDetails.PublishedFileId",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PublishedFileId {
        const NAME: &'static str = "PublishedFileId";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PublishedFileId {
            PublishedFileId::new()
        }

        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PublishedFileId {
            static instance: PublishedFileId = PublishedFileId {
                published_file_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PublishedFileId {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgCREGetUserPublishedItemVoteDetails.PublishedFileId").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PublishedFileId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PublishedFileId {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgCREGetUserPublishedItemVoteDetailsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCREGetUserPublishedItemVoteDetailsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgCREGetUserPublishedItemVoteDetailsResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgCREGetUserPublishedItemVoteDetailsResponse.user_item_vote_details)
    pub user_item_vote_details: ::std::vec::Vec<cmsg_creget_user_published_item_vote_details_response::UserItemVoteDetail>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCREGetUserPublishedItemVoteDetailsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCREGetUserPublishedItemVoteDetailsResponse {
    fn default() -> &'a CMsgCREGetUserPublishedItemVoteDetailsResponse {
        <CMsgCREGetUserPublishedItemVoteDetailsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCREGetUserPublishedItemVoteDetailsResponse {
    pub fn new() -> CMsgCREGetUserPublishedItemVoteDetailsResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgCREGetUserPublishedItemVoteDetailsResponse| { &m.eresult },
            |m: &mut CMsgCREGetUserPublishedItemVoteDetailsResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "user_item_vote_details",
            |m: &CMsgCREGetUserPublishedItemVoteDetailsResponse| { &m.user_item_vote_details },
            |m: &mut CMsgCREGetUserPublishedItemVoteDetailsResponse| { &mut m.user_item_vote_details },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCREGetUserPublishedItemVoteDetailsResponse>(
            "CMsgCREGetUserPublishedItemVoteDetailsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgCREGetUserPublishedItemVoteDetailsResponse {
    const NAME: &'static str = "CMsgCREGetUserPublishedItemVoteDetailsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.user_item_vote_details.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.user_item_vote_details {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.user_item_vote_details {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCREGetUserPublishedItemVoteDetailsResponse {
        CMsgCREGetUserPublishedItemVoteDetailsResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.user_item_vote_details.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCREGetUserPublishedItemVoteDetailsResponse {
        static instance: CMsgCREGetUserPublishedItemVoteDetailsResponse = CMsgCREGetUserPublishedItemVoteDetailsResponse {
            eresult: ::std::option::Option::None,
            user_item_vote_details: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgCREGetUserPublishedItemVoteDetailsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCREGetUserPublishedItemVoteDetailsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCREGetUserPublishedItemVoteDetailsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCREGetUserPublishedItemVoteDetailsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgCREGetUserPublishedItemVoteDetailsResponse`
pub mod cmsg_creget_user_published_item_vote_details_response {
    // @@protoc_insertion_point(message:CMsgCREGetUserPublishedItemVoteDetailsResponse.UserItemVoteDetail)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UserItemVoteDetail {
        // message fields
        // @@protoc_insertion_point(field:CMsgCREGetUserPublishedItemVoteDetailsResponse.UserItemVoteDetail.published_file_id)
        pub published_file_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgCREGetUserPublishedItemVoteDetailsResponse.UserItemVoteDetail.vote)
        pub vote: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgCREGetUserPublishedItemVoteDetailsResponse.UserItemVoteDetail.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UserItemVoteDetail {
        fn default() -> &'a UserItemVoteDetail {
            <UserItemVoteDetail as ::protobuf::Message>::default_instance()
        }
    }

    impl UserItemVoteDetail {
        pub fn new() -> UserItemVoteDetail {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }

        // optional int32 vote = 2;

        pub fn vote(&self) -> i32 {
            self.vote.unwrap_or(0i32)
        }

        pub fn clear_vote(&mut self) {
            self.vote = ::std::option::Option::None;
        }

        pub fn has_vote(&self) -> bool {
            self.vote.is_some()
        }

        // Param is passed by value, moved
        pub fn set_vote(&mut self, v: i32) {
            self.vote = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "published_file_id",
                |m: &UserItemVoteDetail| { &m.published_file_id },
                |m: &mut UserItemVoteDetail| { &mut m.published_file_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "vote",
                |m: &UserItemVoteDetail| { &m.vote },
                |m: &mut UserItemVoteDetail| { &mut m.vote },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserItemVoteDetail>(
                "CMsgCREGetUserPublishedItemVoteDetailsResponse.UserItemVoteDetail",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for UserItemVoteDetail {
        const NAME: &'static str = "UserItemVoteDetail";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.vote = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.vote {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.vote {
                os.write_int32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UserItemVoteDetail {
            UserItemVoteDetail::new()
        }

        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.vote = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UserItemVoteDetail {
            static instance: UserItemVoteDetail = UserItemVoteDetail {
                published_file_id: ::std::option::Option::None,
                vote: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for UserItemVoteDetail {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgCREGetUserPublishedItemVoteDetailsResponse.UserItemVoteDetail").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for UserItemVoteDetail {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for UserItemVoteDetail {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgGameServerPingSample)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameServerPingSample {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameServerPingSample.my_ip)
    pub my_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerPingSample.gs_app_id)
    pub gs_app_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGameServerPingSample.gs_samples)
    pub gs_samples: ::std::vec::Vec<cmsg_game_server_ping_sample::Sample>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameServerPingSample.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerPingSample {
    fn default() -> &'a CMsgGameServerPingSample {
        <CMsgGameServerPingSample as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameServerPingSample {
    pub fn new() -> CMsgGameServerPingSample {
        ::std::default::Default::default()
    }

    // optional fixed32 my_ip = 1;

    pub fn my_ip(&self) -> u32 {
        self.my_ip.unwrap_or(0)
    }

    pub fn clear_my_ip(&mut self) {
        self.my_ip = ::std::option::Option::None;
    }

    pub fn has_my_ip(&self) -> bool {
        self.my_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_my_ip(&mut self, v: u32) {
        self.my_ip = ::std::option::Option::Some(v);
    }

    // optional int32 gs_app_id = 2;

    pub fn gs_app_id(&self) -> i32 {
        self.gs_app_id.unwrap_or(0)
    }

    pub fn clear_gs_app_id(&mut self) {
        self.gs_app_id = ::std::option::Option::None;
    }

    pub fn has_gs_app_id(&self) -> bool {
        self.gs_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gs_app_id(&mut self, v: i32) {
        self.gs_app_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "my_ip",
            |m: &CMsgGameServerPingSample| { &m.my_ip },
            |m: &mut CMsgGameServerPingSample| { &mut m.my_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gs_app_id",
            |m: &CMsgGameServerPingSample| { &m.gs_app_id },
            |m: &mut CMsgGameServerPingSample| { &mut m.gs_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "gs_samples",
            |m: &CMsgGameServerPingSample| { &m.gs_samples },
            |m: &mut CMsgGameServerPingSample| { &mut m.gs_samples },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGameServerPingSample>(
            "CMsgGameServerPingSample",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGameServerPingSample {
    const NAME: &'static str = "CMsgGameServerPingSample";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.my_ip = ::std::option::Option::Some(is.read_fixed32()?);
                },
                16 => {
                    self.gs_app_id = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.gs_samples.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.my_ip {
            my_size += 1 + 4;
        }
        if let Some(v) = self.gs_app_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        for value in &self.gs_samples {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.my_ip {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.gs_app_id {
            os.write_int32(2, v)?;
        }
        for v in &self.gs_samples {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameServerPingSample {
        CMsgGameServerPingSample::new()
    }

    fn clear(&mut self) {
        self.my_ip = ::std::option::Option::None;
        self.gs_app_id = ::std::option::Option::None;
        self.gs_samples.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameServerPingSample {
        static instance: CMsgGameServerPingSample = CMsgGameServerPingSample {
            my_ip: ::std::option::Option::None,
            gs_app_id: ::std::option::Option::None,
            gs_samples: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGameServerPingSample {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGameServerPingSample").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGameServerPingSample {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameServerPingSample {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGameServerPingSample`
pub mod cmsg_game_server_ping_sample {
    // @@protoc_insertion_point(message:CMsgGameServerPingSample.Sample)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Sample {
        // message fields
        // @@protoc_insertion_point(field:CMsgGameServerPingSample.Sample.ip)
        pub ip: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGameServerPingSample.Sample.avg_ping_ms)
        pub avg_ping_ms: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGameServerPingSample.Sample.stddev_ping_ms_x10)
        pub stddev_ping_ms_x10: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGameServerPingSample.Sample.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Sample {
        fn default() -> &'a Sample {
            <Sample as ::protobuf::Message>::default_instance()
        }
    }

    impl Sample {
        pub fn new() -> Sample {
            ::std::default::Default::default()
        }

        // optional fixed32 ip = 1;

        pub fn ip(&self) -> u32 {
            self.ip.unwrap_or(0)
        }

        pub fn clear_ip(&mut self) {
            self.ip = ::std::option::Option::None;
        }

        pub fn has_ip(&self) -> bool {
            self.ip.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ip(&mut self, v: u32) {
            self.ip = ::std::option::Option::Some(v);
        }

        // optional uint32 avg_ping_ms = 2;

        pub fn avg_ping_ms(&self) -> u32 {
            self.avg_ping_ms.unwrap_or(0)
        }

        pub fn clear_avg_ping_ms(&mut self) {
            self.avg_ping_ms = ::std::option::Option::None;
        }

        pub fn has_avg_ping_ms(&self) -> bool {
            self.avg_ping_ms.is_some()
        }

        // Param is passed by value, moved
        pub fn set_avg_ping_ms(&mut self, v: u32) {
            self.avg_ping_ms = ::std::option::Option::Some(v);
        }

        // optional uint32 stddev_ping_ms_x10 = 3;

        pub fn stddev_ping_ms_x10(&self) -> u32 {
            self.stddev_ping_ms_x10.unwrap_or(0)
        }

        pub fn clear_stddev_ping_ms_x10(&mut self) {
            self.stddev_ping_ms_x10 = ::std::option::Option::None;
        }

        pub fn has_stddev_ping_ms_x10(&self) -> bool {
            self.stddev_ping_ms_x10.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stddev_ping_ms_x10(&mut self, v: u32) {
            self.stddev_ping_ms_x10 = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ip",
                |m: &Sample| { &m.ip },
                |m: &mut Sample| { &mut m.ip },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "avg_ping_ms",
                |m: &Sample| { &m.avg_ping_ms },
                |m: &mut Sample| { &mut m.avg_ping_ms },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "stddev_ping_ms_x10",
                |m: &Sample| { &m.stddev_ping_ms_x10 },
                |m: &mut Sample| { &mut m.stddev_ping_ms_x10 },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Sample>(
                "CMsgGameServerPingSample.Sample",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Sample {
        const NAME: &'static str = "Sample";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.ip = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    16 => {
                        self.avg_ping_ms = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.stddev_ping_ms_x10 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.ip {
                my_size += 1 + 4;
            }
            if let Some(v) = self.avg_ping_ms {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.stddev_ping_ms_x10 {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.ip {
                os.write_fixed32(1, v)?;
            }
            if let Some(v) = self.avg_ping_ms {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.stddev_ping_ms_x10 {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Sample {
            Sample::new()
        }

        fn clear(&mut self) {
            self.ip = ::std::option::Option::None;
            self.avg_ping_ms = ::std::option::Option::None;
            self.stddev_ping_ms_x10 = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Sample {
            static instance: Sample = Sample {
                ip: ::std::option::Option::None,
                avg_ping_ms: ::std::option::Option::None,
                stddev_ping_ms_x10: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Sample {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGameServerPingSample.Sample").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Sample {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Sample {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgFSGetFollowerCount)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFSGetFollowerCount {
    // message fields
    // @@protoc_insertion_point(field:CMsgFSGetFollowerCount.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFSGetFollowerCount.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFSGetFollowerCount {
    fn default() -> &'a CMsgFSGetFollowerCount {
        <CMsgFSGetFollowerCount as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFSGetFollowerCount {
    pub fn new() -> CMsgFSGetFollowerCount {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id",
            |m: &CMsgFSGetFollowerCount| { &m.steam_id },
            |m: &mut CMsgFSGetFollowerCount| { &mut m.steam_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgFSGetFollowerCount>(
            "CMsgFSGetFollowerCount",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgFSGetFollowerCount {
    const NAME: &'static str = "CMsgFSGetFollowerCount";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFSGetFollowerCount {
        CMsgFSGetFollowerCount::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFSGetFollowerCount {
        static instance: CMsgFSGetFollowerCount = CMsgFSGetFollowerCount {
            steam_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgFSGetFollowerCount {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgFSGetFollowerCount").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgFSGetFollowerCount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFSGetFollowerCount {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgFSGetFollowerCountResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFSGetFollowerCountResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgFSGetFollowerCountResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgFSGetFollowerCountResponse.count)
    pub count: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFSGetFollowerCountResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFSGetFollowerCountResponse {
    fn default() -> &'a CMsgFSGetFollowerCountResponse {
        <CMsgFSGetFollowerCountResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFSGetFollowerCountResponse {
    pub fn new() -> CMsgFSGetFollowerCountResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional int32 count = 2;

    pub fn count(&self) -> i32 {
        self.count.unwrap_or(0i32)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgFSGetFollowerCountResponse| { &m.eresult },
            |m: &mut CMsgFSGetFollowerCountResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "count",
            |m: &CMsgFSGetFollowerCountResponse| { &m.count },
            |m: &mut CMsgFSGetFollowerCountResponse| { &mut m.count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgFSGetFollowerCountResponse>(
            "CMsgFSGetFollowerCountResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgFSGetFollowerCountResponse {
    const NAME: &'static str = "CMsgFSGetFollowerCountResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.count = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.count {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFSGetFollowerCountResponse {
        CMsgFSGetFollowerCountResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFSGetFollowerCountResponse {
        static instance: CMsgFSGetFollowerCountResponse = CMsgFSGetFollowerCountResponse {
            eresult: ::std::option::Option::None,
            count: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgFSGetFollowerCountResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgFSGetFollowerCountResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgFSGetFollowerCountResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFSGetFollowerCountResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgFSGetIsFollowing)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFSGetIsFollowing {
    // message fields
    // @@protoc_insertion_point(field:CMsgFSGetIsFollowing.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFSGetIsFollowing.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFSGetIsFollowing {
    fn default() -> &'a CMsgFSGetIsFollowing {
        <CMsgFSGetIsFollowing as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFSGetIsFollowing {
    pub fn new() -> CMsgFSGetIsFollowing {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id",
            |m: &CMsgFSGetIsFollowing| { &m.steam_id },
            |m: &mut CMsgFSGetIsFollowing| { &mut m.steam_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgFSGetIsFollowing>(
            "CMsgFSGetIsFollowing",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgFSGetIsFollowing {
    const NAME: &'static str = "CMsgFSGetIsFollowing";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFSGetIsFollowing {
        CMsgFSGetIsFollowing::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFSGetIsFollowing {
        static instance: CMsgFSGetIsFollowing = CMsgFSGetIsFollowing {
            steam_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgFSGetIsFollowing {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgFSGetIsFollowing").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgFSGetIsFollowing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFSGetIsFollowing {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgFSGetIsFollowingResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFSGetIsFollowingResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgFSGetIsFollowingResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgFSGetIsFollowingResponse.is_following)
    pub is_following: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFSGetIsFollowingResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFSGetIsFollowingResponse {
    fn default() -> &'a CMsgFSGetIsFollowingResponse {
        <CMsgFSGetIsFollowingResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFSGetIsFollowingResponse {
    pub fn new() -> CMsgFSGetIsFollowingResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional bool is_following = 2;

    pub fn is_following(&self) -> bool {
        self.is_following.unwrap_or(false)
    }

    pub fn clear_is_following(&mut self) {
        self.is_following = ::std::option::Option::None;
    }

    pub fn has_is_following(&self) -> bool {
        self.is_following.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_following(&mut self, v: bool) {
        self.is_following = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgFSGetIsFollowingResponse| { &m.eresult },
            |m: &mut CMsgFSGetIsFollowingResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_following",
            |m: &CMsgFSGetIsFollowingResponse| { &m.is_following },
            |m: &mut CMsgFSGetIsFollowingResponse| { &mut m.is_following },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgFSGetIsFollowingResponse>(
            "CMsgFSGetIsFollowingResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgFSGetIsFollowingResponse {
    const NAME: &'static str = "CMsgFSGetIsFollowingResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.is_following = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.is_following {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.is_following {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFSGetIsFollowingResponse {
        CMsgFSGetIsFollowingResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.is_following = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFSGetIsFollowingResponse {
        static instance: CMsgFSGetIsFollowingResponse = CMsgFSGetIsFollowingResponse {
            eresult: ::std::option::Option::None,
            is_following: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgFSGetIsFollowingResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgFSGetIsFollowingResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgFSGetIsFollowingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFSGetIsFollowingResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgFSEnumerateFollowingList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFSEnumerateFollowingList {
    // message fields
    // @@protoc_insertion_point(field:CMsgFSEnumerateFollowingList.start_index)
    pub start_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFSEnumerateFollowingList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFSEnumerateFollowingList {
    fn default() -> &'a CMsgFSEnumerateFollowingList {
        <CMsgFSEnumerateFollowingList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFSEnumerateFollowingList {
    pub fn new() -> CMsgFSEnumerateFollowingList {
        ::std::default::Default::default()
    }

    // optional uint32 start_index = 1;

    pub fn start_index(&self) -> u32 {
        self.start_index.unwrap_or(0)
    }

    pub fn clear_start_index(&mut self) {
        self.start_index = ::std::option::Option::None;
    }

    pub fn has_start_index(&self) -> bool {
        self.start_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_index(&mut self, v: u32) {
        self.start_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_index",
            |m: &CMsgFSEnumerateFollowingList| { &m.start_index },
            |m: &mut CMsgFSEnumerateFollowingList| { &mut m.start_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgFSEnumerateFollowingList>(
            "CMsgFSEnumerateFollowingList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgFSEnumerateFollowingList {
    const NAME: &'static str = "CMsgFSEnumerateFollowingList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.start_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.start_index {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.start_index {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFSEnumerateFollowingList {
        CMsgFSEnumerateFollowingList::new()
    }

    fn clear(&mut self) {
        self.start_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFSEnumerateFollowingList {
        static instance: CMsgFSEnumerateFollowingList = CMsgFSEnumerateFollowingList {
            start_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgFSEnumerateFollowingList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgFSEnumerateFollowingList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgFSEnumerateFollowingList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFSEnumerateFollowingList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgFSEnumerateFollowingListResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFSEnumerateFollowingListResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgFSEnumerateFollowingListResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgFSEnumerateFollowingListResponse.total_results)
    pub total_results: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgFSEnumerateFollowingListResponse.steam_ids)
    pub steam_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFSEnumerateFollowingListResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFSEnumerateFollowingListResponse {
    fn default() -> &'a CMsgFSEnumerateFollowingListResponse {
        <CMsgFSEnumerateFollowingListResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFSEnumerateFollowingListResponse {
    pub fn new() -> CMsgFSEnumerateFollowingListResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional int32 total_results = 2;

    pub fn total_results(&self) -> i32 {
        self.total_results.unwrap_or(0)
    }

    pub fn clear_total_results(&mut self) {
        self.total_results = ::std::option::Option::None;
    }

    pub fn has_total_results(&self) -> bool {
        self.total_results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_results(&mut self, v: i32) {
        self.total_results = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgFSEnumerateFollowingListResponse| { &m.eresult },
            |m: &mut CMsgFSEnumerateFollowingListResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_results",
            |m: &CMsgFSEnumerateFollowingListResponse| { &m.total_results },
            |m: &mut CMsgFSEnumerateFollowingListResponse| { &mut m.total_results },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "steam_ids",
            |m: &CMsgFSEnumerateFollowingListResponse| { &m.steam_ids },
            |m: &mut CMsgFSEnumerateFollowingListResponse| { &mut m.steam_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgFSEnumerateFollowingListResponse>(
            "CMsgFSEnumerateFollowingListResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgFSEnumerateFollowingListResponse {
    const NAME: &'static str = "CMsgFSEnumerateFollowingListResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.total_results = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    is.read_repeated_packed_fixed64_into(&mut self.steam_ids)?;
                },
                25 => {
                    self.steam_ids.push(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.total_results {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += 9 * self.steam_ids.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.total_results {
            os.write_int32(2, v)?;
        }
        for v in &self.steam_ids {
            os.write_fixed64(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFSEnumerateFollowingListResponse {
        CMsgFSEnumerateFollowingListResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.total_results = ::std::option::Option::None;
        self.steam_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFSEnumerateFollowingListResponse {
        static instance: CMsgFSEnumerateFollowingListResponse = CMsgFSEnumerateFollowingListResponse {
            eresult: ::std::option::Option::None,
            total_results: ::std::option::Option::None,
            steam_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgFSEnumerateFollowingListResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgFSEnumerateFollowingListResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgFSEnumerateFollowingListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFSEnumerateFollowingListResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgDPGetNumberOfCurrentPlayers)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDPGetNumberOfCurrentPlayers {
    // message fields
    // @@protoc_insertion_point(field:CMsgDPGetNumberOfCurrentPlayers.appid)
    pub appid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDPGetNumberOfCurrentPlayers.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDPGetNumberOfCurrentPlayers {
    fn default() -> &'a CMsgDPGetNumberOfCurrentPlayers {
        <CMsgDPGetNumberOfCurrentPlayers as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDPGetNumberOfCurrentPlayers {
    pub fn new() -> CMsgDPGetNumberOfCurrentPlayers {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CMsgDPGetNumberOfCurrentPlayers| { &m.appid },
            |m: &mut CMsgDPGetNumberOfCurrentPlayers| { &mut m.appid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDPGetNumberOfCurrentPlayers>(
            "CMsgDPGetNumberOfCurrentPlayers",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDPGetNumberOfCurrentPlayers {
    const NAME: &'static str = "CMsgDPGetNumberOfCurrentPlayers";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDPGetNumberOfCurrentPlayers {
        CMsgDPGetNumberOfCurrentPlayers::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDPGetNumberOfCurrentPlayers {
        static instance: CMsgDPGetNumberOfCurrentPlayers = CMsgDPGetNumberOfCurrentPlayers {
            appid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDPGetNumberOfCurrentPlayers {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDPGetNumberOfCurrentPlayers").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDPGetNumberOfCurrentPlayers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDPGetNumberOfCurrentPlayers {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgDPGetNumberOfCurrentPlayersResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDPGetNumberOfCurrentPlayersResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgDPGetNumberOfCurrentPlayersResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgDPGetNumberOfCurrentPlayersResponse.player_count)
    pub player_count: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDPGetNumberOfCurrentPlayersResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDPGetNumberOfCurrentPlayersResponse {
    fn default() -> &'a CMsgDPGetNumberOfCurrentPlayersResponse {
        <CMsgDPGetNumberOfCurrentPlayersResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDPGetNumberOfCurrentPlayersResponse {
    pub fn new() -> CMsgDPGetNumberOfCurrentPlayersResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional int32 player_count = 2;

    pub fn player_count(&self) -> i32 {
        self.player_count.unwrap_or(0)
    }

    pub fn clear_player_count(&mut self) {
        self.player_count = ::std::option::Option::None;
    }

    pub fn has_player_count(&self) -> bool {
        self.player_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_count(&mut self, v: i32) {
        self.player_count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgDPGetNumberOfCurrentPlayersResponse| { &m.eresult },
            |m: &mut CMsgDPGetNumberOfCurrentPlayersResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_count",
            |m: &CMsgDPGetNumberOfCurrentPlayersResponse| { &m.player_count },
            |m: &mut CMsgDPGetNumberOfCurrentPlayersResponse| { &mut m.player_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDPGetNumberOfCurrentPlayersResponse>(
            "CMsgDPGetNumberOfCurrentPlayersResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDPGetNumberOfCurrentPlayersResponse {
    const NAME: &'static str = "CMsgDPGetNumberOfCurrentPlayersResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.player_count = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.player_count {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.player_count {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDPGetNumberOfCurrentPlayersResponse {
        CMsgDPGetNumberOfCurrentPlayersResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.player_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDPGetNumberOfCurrentPlayersResponse {
        static instance: CMsgDPGetNumberOfCurrentPlayersResponse = CMsgDPGetNumberOfCurrentPlayersResponse {
            eresult: ::std::option::Option::None,
            player_count: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDPGetNumberOfCurrentPlayersResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDPGetNumberOfCurrentPlayersResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDPGetNumberOfCurrentPlayersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDPGetNumberOfCurrentPlayersResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientFriendUserStatusPublished)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientFriendUserStatusPublished {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientFriendUserStatusPublished.friend_steamid)
    pub friend_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientFriendUserStatusPublished.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientFriendUserStatusPublished.status_text)
    pub status_text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientFriendUserStatusPublished.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientFriendUserStatusPublished {
    fn default() -> &'a CMsgClientFriendUserStatusPublished {
        <CMsgClientFriendUserStatusPublished as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientFriendUserStatusPublished {
    pub fn new() -> CMsgClientFriendUserStatusPublished {
        ::std::default::Default::default()
    }

    // optional fixed64 friend_steamid = 1;

    pub fn friend_steamid(&self) -> u64 {
        self.friend_steamid.unwrap_or(0)
    }

    pub fn clear_friend_steamid(&mut self) {
        self.friend_steamid = ::std::option::Option::None;
    }

    pub fn has_friend_steamid(&self) -> bool {
        self.friend_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friend_steamid(&mut self, v: u64) {
        self.friend_steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 2;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string status_text = 3;

    pub fn status_text(&self) -> &str {
        match self.status_text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_status_text(&mut self) {
        self.status_text = ::std::option::Option::None;
    }

    pub fn has_status_text(&self) -> bool {
        self.status_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_text(&mut self, v: ::std::string::String) {
        self.status_text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status_text(&mut self) -> &mut ::std::string::String {
        if self.status_text.is_none() {
            self.status_text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.status_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_status_text(&mut self) -> ::std::string::String {
        self.status_text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "friend_steamid",
            |m: &CMsgClientFriendUserStatusPublished| { &m.friend_steamid },
            |m: &mut CMsgClientFriendUserStatusPublished| { &mut m.friend_steamid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CMsgClientFriendUserStatusPublished| { &m.appid },
            |m: &mut CMsgClientFriendUserStatusPublished| { &mut m.appid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status_text",
            |m: &CMsgClientFriendUserStatusPublished| { &m.status_text },
            |m: &mut CMsgClientFriendUserStatusPublished| { &mut m.status_text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientFriendUserStatusPublished>(
            "CMsgClientFriendUserStatusPublished",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientFriendUserStatusPublished {
    const NAME: &'static str = "CMsgClientFriendUserStatusPublished";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.friend_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.status_text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.friend_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.status_text.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.friend_steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.status_text.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientFriendUserStatusPublished {
        CMsgClientFriendUserStatusPublished::new()
    }

    fn clear(&mut self) {
        self.friend_steamid = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.status_text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientFriendUserStatusPublished {
        static instance: CMsgClientFriendUserStatusPublished = CMsgClientFriendUserStatusPublished {
            friend_steamid: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            status_text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientFriendUserStatusPublished {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientFriendUserStatusPublished").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientFriendUserStatusPublished {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientFriendUserStatusPublished {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientServiceMethodLegacy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientServiceMethodLegacy {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientServiceMethodLegacy.method_name)
    pub method_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientServiceMethodLegacy.serialized_method)
    pub serialized_method: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientServiceMethodLegacy.is_notification)
    pub is_notification: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientServiceMethodLegacy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientServiceMethodLegacy {
    fn default() -> &'a CMsgClientServiceMethodLegacy {
        <CMsgClientServiceMethodLegacy as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientServiceMethodLegacy {
    pub fn new() -> CMsgClientServiceMethodLegacy {
        ::std::default::Default::default()
    }

    // optional string method_name = 1;

    pub fn method_name(&self) -> &str {
        match self.method_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_method_name(&mut self) {
        self.method_name = ::std::option::Option::None;
    }

    pub fn has_method_name(&self) -> bool {
        self.method_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_method_name(&mut self, v: ::std::string::String) {
        self.method_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_method_name(&mut self) -> &mut ::std::string::String {
        if self.method_name.is_none() {
            self.method_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.method_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_method_name(&mut self) -> ::std::string::String {
        self.method_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes serialized_method = 2;

    pub fn serialized_method(&self) -> &[u8] {
        match self.serialized_method.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_serialized_method(&mut self) {
        self.serialized_method = ::std::option::Option::None;
    }

    pub fn has_serialized_method(&self) -> bool {
        self.serialized_method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serialized_method(&mut self, v: ::std::vec::Vec<u8>) {
        self.serialized_method = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serialized_method(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.serialized_method.is_none() {
            self.serialized_method = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.serialized_method.as_mut().unwrap()
    }

    // Take field
    pub fn take_serialized_method(&mut self) -> ::std::vec::Vec<u8> {
        self.serialized_method.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool is_notification = 3;

    pub fn is_notification(&self) -> bool {
        self.is_notification.unwrap_or(false)
    }

    pub fn clear_is_notification(&mut self) {
        self.is_notification = ::std::option::Option::None;
    }

    pub fn has_is_notification(&self) -> bool {
        self.is_notification.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_notification(&mut self, v: bool) {
        self.is_notification = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "method_name",
            |m: &CMsgClientServiceMethodLegacy| { &m.method_name },
            |m: &mut CMsgClientServiceMethodLegacy| { &mut m.method_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serialized_method",
            |m: &CMsgClientServiceMethodLegacy| { &m.serialized_method },
            |m: &mut CMsgClientServiceMethodLegacy| { &mut m.serialized_method },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_notification",
            |m: &CMsgClientServiceMethodLegacy| { &m.is_notification },
            |m: &mut CMsgClientServiceMethodLegacy| { &mut m.is_notification },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientServiceMethodLegacy>(
            "CMsgClientServiceMethodLegacy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientServiceMethodLegacy {
    const NAME: &'static str = "CMsgClientServiceMethodLegacy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.method_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.serialized_method = ::std::option::Option::Some(is.read_bytes()?);
                },
                24 => {
                    self.is_notification = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.method_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.serialized_method.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.is_notification {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.method_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.serialized_method.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.is_notification {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientServiceMethodLegacy {
        CMsgClientServiceMethodLegacy::new()
    }

    fn clear(&mut self) {
        self.method_name = ::std::option::Option::None;
        self.serialized_method = ::std::option::Option::None;
        self.is_notification = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientServiceMethodLegacy {
        static instance: CMsgClientServiceMethodLegacy = CMsgClientServiceMethodLegacy {
            method_name: ::std::option::Option::None,
            serialized_method: ::std::option::Option::None,
            is_notification: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientServiceMethodLegacy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientServiceMethodLegacy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientServiceMethodLegacy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientServiceMethodLegacy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientServiceMethodLegacyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientServiceMethodLegacyResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientServiceMethodLegacyResponse.method_name)
    pub method_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientServiceMethodLegacyResponse.serialized_method_response)
    pub serialized_method_response: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientServiceMethodLegacyResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientServiceMethodLegacyResponse {
    fn default() -> &'a CMsgClientServiceMethodLegacyResponse {
        <CMsgClientServiceMethodLegacyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientServiceMethodLegacyResponse {
    pub fn new() -> CMsgClientServiceMethodLegacyResponse {
        ::std::default::Default::default()
    }

    // optional string method_name = 1;

    pub fn method_name(&self) -> &str {
        match self.method_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_method_name(&mut self) {
        self.method_name = ::std::option::Option::None;
    }

    pub fn has_method_name(&self) -> bool {
        self.method_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_method_name(&mut self, v: ::std::string::String) {
        self.method_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_method_name(&mut self) -> &mut ::std::string::String {
        if self.method_name.is_none() {
            self.method_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.method_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_method_name(&mut self) -> ::std::string::String {
        self.method_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes serialized_method_response = 2;

    pub fn serialized_method_response(&self) -> &[u8] {
        match self.serialized_method_response.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_serialized_method_response(&mut self) {
        self.serialized_method_response = ::std::option::Option::None;
    }

    pub fn has_serialized_method_response(&self) -> bool {
        self.serialized_method_response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serialized_method_response(&mut self, v: ::std::vec::Vec<u8>) {
        self.serialized_method_response = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serialized_method_response(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.serialized_method_response.is_none() {
            self.serialized_method_response = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.serialized_method_response.as_mut().unwrap()
    }

    // Take field
    pub fn take_serialized_method_response(&mut self) -> ::std::vec::Vec<u8> {
        self.serialized_method_response.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "method_name",
            |m: &CMsgClientServiceMethodLegacyResponse| { &m.method_name },
            |m: &mut CMsgClientServiceMethodLegacyResponse| { &mut m.method_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serialized_method_response",
            |m: &CMsgClientServiceMethodLegacyResponse| { &m.serialized_method_response },
            |m: &mut CMsgClientServiceMethodLegacyResponse| { &mut m.serialized_method_response },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientServiceMethodLegacyResponse>(
            "CMsgClientServiceMethodLegacyResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientServiceMethodLegacyResponse {
    const NAME: &'static str = "CMsgClientServiceMethodLegacyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.method_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.serialized_method_response = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.method_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.serialized_method_response.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.method_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.serialized_method_response.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientServiceMethodLegacyResponse {
        CMsgClientServiceMethodLegacyResponse::new()
    }

    fn clear(&mut self) {
        self.method_name = ::std::option::Option::None;
        self.serialized_method_response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientServiceMethodLegacyResponse {
        static instance: CMsgClientServiceMethodLegacyResponse = CMsgClientServiceMethodLegacyResponse {
            method_name: ::std::option::Option::None,
            serialized_method_response: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientServiceMethodLegacyResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientServiceMethodLegacyResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientServiceMethodLegacyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientServiceMethodLegacyResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUIMode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUIMode {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUIMode.uimode)
    pub uimode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUIMode.chat_mode)
    pub chat_mode: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUIMode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUIMode {
    fn default() -> &'a CMsgClientUIMode {
        <CMsgClientUIMode as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUIMode {
    pub fn new() -> CMsgClientUIMode {
        ::std::default::Default::default()
    }

    // optional uint32 uimode = 1;

    pub fn uimode(&self) -> u32 {
        self.uimode.unwrap_or(0)
    }

    pub fn clear_uimode(&mut self) {
        self.uimode = ::std::option::Option::None;
    }

    pub fn has_uimode(&self) -> bool {
        self.uimode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uimode(&mut self, v: u32) {
        self.uimode = ::std::option::Option::Some(v);
    }

    // optional uint32 chat_mode = 2;

    pub fn chat_mode(&self) -> u32 {
        self.chat_mode.unwrap_or(0)
    }

    pub fn clear_chat_mode(&mut self) {
        self.chat_mode = ::std::option::Option::None;
    }

    pub fn has_chat_mode(&self) -> bool {
        self.chat_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_mode(&mut self, v: u32) {
        self.chat_mode = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uimode",
            |m: &CMsgClientUIMode| { &m.uimode },
            |m: &mut CMsgClientUIMode| { &mut m.uimode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_mode",
            |m: &CMsgClientUIMode| { &m.chat_mode },
            |m: &mut CMsgClientUIMode| { &mut m.chat_mode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUIMode>(
            "CMsgClientUIMode",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUIMode {
    const NAME: &'static str = "CMsgClientUIMode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.uimode = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.chat_mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.uimode {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.chat_mode {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.uimode {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.chat_mode {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUIMode {
        CMsgClientUIMode::new()
    }

    fn clear(&mut self) {
        self.uimode = ::std::option::Option::None;
        self.chat_mode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUIMode {
        static instance: CMsgClientUIMode = CMsgClientUIMode {
            uimode: ::std::option::Option::None,
            chat_mode: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUIMode {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUIMode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUIMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUIMode {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientVanityURLChangedNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientVanityURLChangedNotification {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientVanityURLChangedNotification.vanity_url)
    pub vanity_url: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientVanityURLChangedNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientVanityURLChangedNotification {
    fn default() -> &'a CMsgClientVanityURLChangedNotification {
        <CMsgClientVanityURLChangedNotification as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientVanityURLChangedNotification {
    pub fn new() -> CMsgClientVanityURLChangedNotification {
        ::std::default::Default::default()
    }

    // optional string vanity_url = 1;

    pub fn vanity_url(&self) -> &str {
        match self.vanity_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_vanity_url(&mut self) {
        self.vanity_url = ::std::option::Option::None;
    }

    pub fn has_vanity_url(&self) -> bool {
        self.vanity_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vanity_url(&mut self, v: ::std::string::String) {
        self.vanity_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vanity_url(&mut self) -> &mut ::std::string::String {
        if self.vanity_url.is_none() {
            self.vanity_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.vanity_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_vanity_url(&mut self) -> ::std::string::String {
        self.vanity_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vanity_url",
            |m: &CMsgClientVanityURLChangedNotification| { &m.vanity_url },
            |m: &mut CMsgClientVanityURLChangedNotification| { &mut m.vanity_url },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientVanityURLChangedNotification>(
            "CMsgClientVanityURLChangedNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientVanityURLChangedNotification {
    const NAME: &'static str = "CMsgClientVanityURLChangedNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.vanity_url = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.vanity_url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.vanity_url.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientVanityURLChangedNotification {
        CMsgClientVanityURLChangedNotification::new()
    }

    fn clear(&mut self) {
        self.vanity_url = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientVanityURLChangedNotification {
        static instance: CMsgClientVanityURLChangedNotification = CMsgClientVanityURLChangedNotification {
            vanity_url: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientVanityURLChangedNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientVanityURLChangedNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientVanityURLChangedNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientVanityURLChangedNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientAuthorizeLocalDeviceRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientAuthorizeLocalDeviceRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientAuthorizeLocalDeviceRequest.device_description)
    pub device_description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientAuthorizeLocalDeviceRequest.owner_account_id)
    pub owner_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientAuthorizeLocalDeviceRequest.local_device_token)
    pub local_device_token: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientAuthorizeLocalDeviceRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientAuthorizeLocalDeviceRequest {
    fn default() -> &'a CMsgClientAuthorizeLocalDeviceRequest {
        <CMsgClientAuthorizeLocalDeviceRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAuthorizeLocalDeviceRequest {
    pub fn new() -> CMsgClientAuthorizeLocalDeviceRequest {
        ::std::default::Default::default()
    }

    // optional string device_description = 1;

    pub fn device_description(&self) -> &str {
        match self.device_description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_device_description(&mut self) {
        self.device_description = ::std::option::Option::None;
    }

    pub fn has_device_description(&self) -> bool {
        self.device_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_description(&mut self, v: ::std::string::String) {
        self.device_description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_description(&mut self) -> &mut ::std::string::String {
        if self.device_description.is_none() {
            self.device_description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.device_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_description(&mut self) -> ::std::string::String {
        self.device_description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 owner_account_id = 2;

    pub fn owner_account_id(&self) -> u32 {
        self.owner_account_id.unwrap_or(0)
    }

    pub fn clear_owner_account_id(&mut self) {
        self.owner_account_id = ::std::option::Option::None;
    }

    pub fn has_owner_account_id(&self) -> bool {
        self.owner_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_account_id(&mut self, v: u32) {
        self.owner_account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 local_device_token = 3;

    pub fn local_device_token(&self) -> u64 {
        self.local_device_token.unwrap_or(0)
    }

    pub fn clear_local_device_token(&mut self) {
        self.local_device_token = ::std::option::Option::None;
    }

    pub fn has_local_device_token(&self) -> bool {
        self.local_device_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_device_token(&mut self, v: u64) {
        self.local_device_token = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "device_description",
            |m: &CMsgClientAuthorizeLocalDeviceRequest| { &m.device_description },
            |m: &mut CMsgClientAuthorizeLocalDeviceRequest| { &mut m.device_description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "owner_account_id",
            |m: &CMsgClientAuthorizeLocalDeviceRequest| { &m.owner_account_id },
            |m: &mut CMsgClientAuthorizeLocalDeviceRequest| { &mut m.owner_account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "local_device_token",
            |m: &CMsgClientAuthorizeLocalDeviceRequest| { &m.local_device_token },
            |m: &mut CMsgClientAuthorizeLocalDeviceRequest| { &mut m.local_device_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientAuthorizeLocalDeviceRequest>(
            "CMsgClientAuthorizeLocalDeviceRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientAuthorizeLocalDeviceRequest {
    const NAME: &'static str = "CMsgClientAuthorizeLocalDeviceRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.device_description = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.owner_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.local_device_token = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.device_description.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.owner_account_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.local_device_token {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.device_description.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.owner_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.local_device_token {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientAuthorizeLocalDeviceRequest {
        CMsgClientAuthorizeLocalDeviceRequest::new()
    }

    fn clear(&mut self) {
        self.device_description = ::std::option::Option::None;
        self.owner_account_id = ::std::option::Option::None;
        self.local_device_token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientAuthorizeLocalDeviceRequest {
        static instance: CMsgClientAuthorizeLocalDeviceRequest = CMsgClientAuthorizeLocalDeviceRequest {
            device_description: ::std::option::Option::None,
            owner_account_id: ::std::option::Option::None,
            local_device_token: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientAuthorizeLocalDeviceRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientAuthorizeLocalDeviceRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientAuthorizeLocalDeviceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAuthorizeLocalDeviceRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientAuthorizeLocalDevice)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientAuthorizeLocalDevice {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientAuthorizeLocalDevice.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientAuthorizeLocalDevice.owner_account_id)
    pub owner_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientAuthorizeLocalDevice.authed_device_token)
    pub authed_device_token: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientAuthorizeLocalDevice.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientAuthorizeLocalDevice {
    fn default() -> &'a CMsgClientAuthorizeLocalDevice {
        <CMsgClientAuthorizeLocalDevice as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAuthorizeLocalDevice {
    pub fn new() -> CMsgClientAuthorizeLocalDevice {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 owner_account_id = 2;

    pub fn owner_account_id(&self) -> u32 {
        self.owner_account_id.unwrap_or(0)
    }

    pub fn clear_owner_account_id(&mut self) {
        self.owner_account_id = ::std::option::Option::None;
    }

    pub fn has_owner_account_id(&self) -> bool {
        self.owner_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_account_id(&mut self, v: u32) {
        self.owner_account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 authed_device_token = 3;

    pub fn authed_device_token(&self) -> u64 {
        self.authed_device_token.unwrap_or(0)
    }

    pub fn clear_authed_device_token(&mut self) {
        self.authed_device_token = ::std::option::Option::None;
    }

    pub fn has_authed_device_token(&self) -> bool {
        self.authed_device_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authed_device_token(&mut self, v: u64) {
        self.authed_device_token = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientAuthorizeLocalDevice| { &m.eresult },
            |m: &mut CMsgClientAuthorizeLocalDevice| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "owner_account_id",
            |m: &CMsgClientAuthorizeLocalDevice| { &m.owner_account_id },
            |m: &mut CMsgClientAuthorizeLocalDevice| { &mut m.owner_account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "authed_device_token",
            |m: &CMsgClientAuthorizeLocalDevice| { &m.authed_device_token },
            |m: &mut CMsgClientAuthorizeLocalDevice| { &mut m.authed_device_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientAuthorizeLocalDevice>(
            "CMsgClientAuthorizeLocalDevice",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientAuthorizeLocalDevice {
    const NAME: &'static str = "CMsgClientAuthorizeLocalDevice";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.owner_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.authed_device_token = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.owner_account_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.authed_device_token {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.owner_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.authed_device_token {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientAuthorizeLocalDevice {
        CMsgClientAuthorizeLocalDevice::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.owner_account_id = ::std::option::Option::None;
        self.authed_device_token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientAuthorizeLocalDevice {
        static instance: CMsgClientAuthorizeLocalDevice = CMsgClientAuthorizeLocalDevice {
            eresult: ::std::option::Option::None,
            owner_account_id: ::std::option::Option::None,
            authed_device_token: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientAuthorizeLocalDevice {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientAuthorizeLocalDevice").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientAuthorizeLocalDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAuthorizeLocalDevice {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientAuthorizeLocalDeviceNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientAuthorizeLocalDeviceNotification {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientAuthorizeLocalDeviceNotification.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientAuthorizeLocalDeviceNotification.owner_account_id)
    pub owner_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientAuthorizeLocalDeviceNotification.local_device_token)
    pub local_device_token: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientAuthorizeLocalDeviceNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientAuthorizeLocalDeviceNotification {
    fn default() -> &'a CMsgClientAuthorizeLocalDeviceNotification {
        <CMsgClientAuthorizeLocalDeviceNotification as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAuthorizeLocalDeviceNotification {
    pub fn new() -> CMsgClientAuthorizeLocalDeviceNotification {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 owner_account_id = 2;

    pub fn owner_account_id(&self) -> u32 {
        self.owner_account_id.unwrap_or(0)
    }

    pub fn clear_owner_account_id(&mut self) {
        self.owner_account_id = ::std::option::Option::None;
    }

    pub fn has_owner_account_id(&self) -> bool {
        self.owner_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_account_id(&mut self, v: u32) {
        self.owner_account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 local_device_token = 3;

    pub fn local_device_token(&self) -> u64 {
        self.local_device_token.unwrap_or(0)
    }

    pub fn clear_local_device_token(&mut self) {
        self.local_device_token = ::std::option::Option::None;
    }

    pub fn has_local_device_token(&self) -> bool {
        self.local_device_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_device_token(&mut self, v: u64) {
        self.local_device_token = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientAuthorizeLocalDeviceNotification| { &m.eresult },
            |m: &mut CMsgClientAuthorizeLocalDeviceNotification| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "owner_account_id",
            |m: &CMsgClientAuthorizeLocalDeviceNotification| { &m.owner_account_id },
            |m: &mut CMsgClientAuthorizeLocalDeviceNotification| { &mut m.owner_account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "local_device_token",
            |m: &CMsgClientAuthorizeLocalDeviceNotification| { &m.local_device_token },
            |m: &mut CMsgClientAuthorizeLocalDeviceNotification| { &mut m.local_device_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientAuthorizeLocalDeviceNotification>(
            "CMsgClientAuthorizeLocalDeviceNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientAuthorizeLocalDeviceNotification {
    const NAME: &'static str = "CMsgClientAuthorizeLocalDeviceNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.owner_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.local_device_token = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.owner_account_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.local_device_token {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.owner_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.local_device_token {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientAuthorizeLocalDeviceNotification {
        CMsgClientAuthorizeLocalDeviceNotification::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.owner_account_id = ::std::option::Option::None;
        self.local_device_token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientAuthorizeLocalDeviceNotification {
        static instance: CMsgClientAuthorizeLocalDeviceNotification = CMsgClientAuthorizeLocalDeviceNotification {
            eresult: ::std::option::Option::None,
            owner_account_id: ::std::option::Option::None,
            local_device_token: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientAuthorizeLocalDeviceNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientAuthorizeLocalDeviceNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientAuthorizeLocalDeviceNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAuthorizeLocalDeviceNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientDeauthorizeDeviceRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientDeauthorizeDeviceRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientDeauthorizeDeviceRequest.deauthorization_account_id)
    pub deauthorization_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientDeauthorizeDeviceRequest.deauthorization_device_token)
    pub deauthorization_device_token: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientDeauthorizeDeviceRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientDeauthorizeDeviceRequest {
    fn default() -> &'a CMsgClientDeauthorizeDeviceRequest {
        <CMsgClientDeauthorizeDeviceRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientDeauthorizeDeviceRequest {
    pub fn new() -> CMsgClientDeauthorizeDeviceRequest {
        ::std::default::Default::default()
    }

    // optional uint32 deauthorization_account_id = 1;

    pub fn deauthorization_account_id(&self) -> u32 {
        self.deauthorization_account_id.unwrap_or(0)
    }

    pub fn clear_deauthorization_account_id(&mut self) {
        self.deauthorization_account_id = ::std::option::Option::None;
    }

    pub fn has_deauthorization_account_id(&self) -> bool {
        self.deauthorization_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deauthorization_account_id(&mut self, v: u32) {
        self.deauthorization_account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 deauthorization_device_token = 2;

    pub fn deauthorization_device_token(&self) -> u64 {
        self.deauthorization_device_token.unwrap_or(0)
    }

    pub fn clear_deauthorization_device_token(&mut self) {
        self.deauthorization_device_token = ::std::option::Option::None;
    }

    pub fn has_deauthorization_device_token(&self) -> bool {
        self.deauthorization_device_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deauthorization_device_token(&mut self, v: u64) {
        self.deauthorization_device_token = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deauthorization_account_id",
            |m: &CMsgClientDeauthorizeDeviceRequest| { &m.deauthorization_account_id },
            |m: &mut CMsgClientDeauthorizeDeviceRequest| { &mut m.deauthorization_account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deauthorization_device_token",
            |m: &CMsgClientDeauthorizeDeviceRequest| { &m.deauthorization_device_token },
            |m: &mut CMsgClientDeauthorizeDeviceRequest| { &mut m.deauthorization_device_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientDeauthorizeDeviceRequest>(
            "CMsgClientDeauthorizeDeviceRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientDeauthorizeDeviceRequest {
    const NAME: &'static str = "CMsgClientDeauthorizeDeviceRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.deauthorization_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.deauthorization_device_token = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.deauthorization_account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.deauthorization_device_token {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.deauthorization_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.deauthorization_device_token {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientDeauthorizeDeviceRequest {
        CMsgClientDeauthorizeDeviceRequest::new()
    }

    fn clear(&mut self) {
        self.deauthorization_account_id = ::std::option::Option::None;
        self.deauthorization_device_token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientDeauthorizeDeviceRequest {
        static instance: CMsgClientDeauthorizeDeviceRequest = CMsgClientDeauthorizeDeviceRequest {
            deauthorization_account_id: ::std::option::Option::None,
            deauthorization_device_token: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientDeauthorizeDeviceRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientDeauthorizeDeviceRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientDeauthorizeDeviceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientDeauthorizeDeviceRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientDeauthorizeDevice)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientDeauthorizeDevice {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientDeauthorizeDevice.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientDeauthorizeDevice.deauthorization_account_id)
    pub deauthorization_account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientDeauthorizeDevice.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientDeauthorizeDevice {
    fn default() -> &'a CMsgClientDeauthorizeDevice {
        <CMsgClientDeauthorizeDevice as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientDeauthorizeDevice {
    pub fn new() -> CMsgClientDeauthorizeDevice {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 deauthorization_account_id = 2;

    pub fn deauthorization_account_id(&self) -> u32 {
        self.deauthorization_account_id.unwrap_or(0)
    }

    pub fn clear_deauthorization_account_id(&mut self) {
        self.deauthorization_account_id = ::std::option::Option::None;
    }

    pub fn has_deauthorization_account_id(&self) -> bool {
        self.deauthorization_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deauthorization_account_id(&mut self, v: u32) {
        self.deauthorization_account_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientDeauthorizeDevice| { &m.eresult },
            |m: &mut CMsgClientDeauthorizeDevice| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deauthorization_account_id",
            |m: &CMsgClientDeauthorizeDevice| { &m.deauthorization_account_id },
            |m: &mut CMsgClientDeauthorizeDevice| { &mut m.deauthorization_account_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientDeauthorizeDevice>(
            "CMsgClientDeauthorizeDevice",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientDeauthorizeDevice {
    const NAME: &'static str = "CMsgClientDeauthorizeDevice";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.deauthorization_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.deauthorization_account_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.deauthorization_account_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientDeauthorizeDevice {
        CMsgClientDeauthorizeDevice::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.deauthorization_account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientDeauthorizeDevice {
        static instance: CMsgClientDeauthorizeDevice = CMsgClientDeauthorizeDevice {
            eresult: ::std::option::Option::None,
            deauthorization_account_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientDeauthorizeDevice {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientDeauthorizeDevice").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientDeauthorizeDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientDeauthorizeDevice {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUseLocalDeviceAuthorizations)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUseLocalDeviceAuthorizations {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUseLocalDeviceAuthorizations.authorization_account_id)
    pub authorization_account_id: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgClientUseLocalDeviceAuthorizations.device_tokens)
    pub device_tokens: ::std::vec::Vec<cmsg_client_use_local_device_authorizations::DeviceToken>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUseLocalDeviceAuthorizations.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUseLocalDeviceAuthorizations {
    fn default() -> &'a CMsgClientUseLocalDeviceAuthorizations {
        <CMsgClientUseLocalDeviceAuthorizations as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUseLocalDeviceAuthorizations {
    pub fn new() -> CMsgClientUseLocalDeviceAuthorizations {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "authorization_account_id",
            |m: &CMsgClientUseLocalDeviceAuthorizations| { &m.authorization_account_id },
            |m: &mut CMsgClientUseLocalDeviceAuthorizations| { &mut m.authorization_account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "device_tokens",
            |m: &CMsgClientUseLocalDeviceAuthorizations| { &m.device_tokens },
            |m: &mut CMsgClientUseLocalDeviceAuthorizations| { &mut m.device_tokens },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUseLocalDeviceAuthorizations>(
            "CMsgClientUseLocalDeviceAuthorizations",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUseLocalDeviceAuthorizations {
    const NAME: &'static str = "CMsgClientUseLocalDeviceAuthorizations";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.authorization_account_id)?;
                },
                8 => {
                    self.authorization_account_id.push(is.read_uint32()?);
                },
                18 => {
                    self.device_tokens.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.authorization_account_id {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        for value in &self.device_tokens {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.authorization_account_id {
            os.write_uint32(1, *v)?;
        };
        for v in &self.device_tokens {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUseLocalDeviceAuthorizations {
        CMsgClientUseLocalDeviceAuthorizations::new()
    }

    fn clear(&mut self) {
        self.authorization_account_id.clear();
        self.device_tokens.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUseLocalDeviceAuthorizations {
        static instance: CMsgClientUseLocalDeviceAuthorizations = CMsgClientUseLocalDeviceAuthorizations {
            authorization_account_id: ::std::vec::Vec::new(),
            device_tokens: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUseLocalDeviceAuthorizations {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUseLocalDeviceAuthorizations").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUseLocalDeviceAuthorizations {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUseLocalDeviceAuthorizations {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientUseLocalDeviceAuthorizations`
pub mod cmsg_client_use_local_device_authorizations {
    // @@protoc_insertion_point(message:CMsgClientUseLocalDeviceAuthorizations.DeviceToken)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DeviceToken {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientUseLocalDeviceAuthorizations.DeviceToken.owner_account_id)
        pub owner_account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientUseLocalDeviceAuthorizations.DeviceToken.token_id)
        pub token_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientUseLocalDeviceAuthorizations.DeviceToken.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DeviceToken {
        fn default() -> &'a DeviceToken {
            <DeviceToken as ::protobuf::Message>::default_instance()
        }
    }

    impl DeviceToken {
        pub fn new() -> DeviceToken {
            ::std::default::Default::default()
        }

        // optional uint32 owner_account_id = 1;

        pub fn owner_account_id(&self) -> u32 {
            self.owner_account_id.unwrap_or(0)
        }

        pub fn clear_owner_account_id(&mut self) {
            self.owner_account_id = ::std::option::Option::None;
        }

        pub fn has_owner_account_id(&self) -> bool {
            self.owner_account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_owner_account_id(&mut self, v: u32) {
            self.owner_account_id = ::std::option::Option::Some(v);
        }

        // optional uint64 token_id = 2;

        pub fn token_id(&self) -> u64 {
            self.token_id.unwrap_or(0)
        }

        pub fn clear_token_id(&mut self) {
            self.token_id = ::std::option::Option::None;
        }

        pub fn has_token_id(&self) -> bool {
            self.token_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_token_id(&mut self, v: u64) {
            self.token_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "owner_account_id",
                |m: &DeviceToken| { &m.owner_account_id },
                |m: &mut DeviceToken| { &mut m.owner_account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "token_id",
                |m: &DeviceToken| { &m.token_id },
                |m: &mut DeviceToken| { &mut m.token_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceToken>(
                "CMsgClientUseLocalDeviceAuthorizations.DeviceToken",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for DeviceToken {
        const NAME: &'static str = "DeviceToken";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.owner_account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.token_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.owner_account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.token_id {
                my_size += ::protobuf::rt::uint64_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.owner_account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.token_id {
                os.write_uint64(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DeviceToken {
            DeviceToken::new()
        }

        fn clear(&mut self) {
            self.owner_account_id = ::std::option::Option::None;
            self.token_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DeviceToken {
            static instance: DeviceToken = DeviceToken {
                owner_account_id: ::std::option::Option::None,
                token_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for DeviceToken {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientUseLocalDeviceAuthorizations.DeviceToken").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DeviceToken {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for DeviceToken {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientGetAuthorizedDevices)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetAuthorizedDevices {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetAuthorizedDevices.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetAuthorizedDevices {
    fn default() -> &'a CMsgClientGetAuthorizedDevices {
        <CMsgClientGetAuthorizedDevices as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetAuthorizedDevices {
    pub fn new() -> CMsgClientGetAuthorizedDevices {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientGetAuthorizedDevices>(
            "CMsgClientGetAuthorizedDevices",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientGetAuthorizedDevices {
    const NAME: &'static str = "CMsgClientGetAuthorizedDevices";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetAuthorizedDevices {
        CMsgClientGetAuthorizedDevices::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetAuthorizedDevices {
        static instance: CMsgClientGetAuthorizedDevices = CMsgClientGetAuthorizedDevices {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientGetAuthorizedDevices {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientGetAuthorizedDevices").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientGetAuthorizedDevices {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetAuthorizedDevices {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientGetAuthorizedDevicesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetAuthorizedDevicesResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetAuthorizedDevicesResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientGetAuthorizedDevicesResponse.authorized_device)
    pub authorized_device: ::std::vec::Vec<cmsg_client_get_authorized_devices_response::AuthorizedDevice>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetAuthorizedDevicesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetAuthorizedDevicesResponse {
    fn default() -> &'a CMsgClientGetAuthorizedDevicesResponse {
        <CMsgClientGetAuthorizedDevicesResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetAuthorizedDevicesResponse {
    pub fn new() -> CMsgClientGetAuthorizedDevicesResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientGetAuthorizedDevicesResponse| { &m.eresult },
            |m: &mut CMsgClientGetAuthorizedDevicesResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "authorized_device",
            |m: &CMsgClientGetAuthorizedDevicesResponse| { &m.authorized_device },
            |m: &mut CMsgClientGetAuthorizedDevicesResponse| { &mut m.authorized_device },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientGetAuthorizedDevicesResponse>(
            "CMsgClientGetAuthorizedDevicesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientGetAuthorizedDevicesResponse {
    const NAME: &'static str = "CMsgClientGetAuthorizedDevicesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.authorized_device.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.authorized_device {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.authorized_device {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetAuthorizedDevicesResponse {
        CMsgClientGetAuthorizedDevicesResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.authorized_device.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetAuthorizedDevicesResponse {
        static instance: CMsgClientGetAuthorizedDevicesResponse = CMsgClientGetAuthorizedDevicesResponse {
            eresult: ::std::option::Option::None,
            authorized_device: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientGetAuthorizedDevicesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientGetAuthorizedDevicesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientGetAuthorizedDevicesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetAuthorizedDevicesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientGetAuthorizedDevicesResponse`
pub mod cmsg_client_get_authorized_devices_response {
    // @@protoc_insertion_point(message:CMsgClientGetAuthorizedDevicesResponse.AuthorizedDevice)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AuthorizedDevice {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientGetAuthorizedDevicesResponse.AuthorizedDevice.auth_device_token)
        pub auth_device_token: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientGetAuthorizedDevicesResponse.AuthorizedDevice.device_name)
        pub device_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientGetAuthorizedDevicesResponse.AuthorizedDevice.last_access_time)
        pub last_access_time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGetAuthorizedDevicesResponse.AuthorizedDevice.borrower_id)
        pub borrower_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGetAuthorizedDevicesResponse.AuthorizedDevice.is_pending)
        pub is_pending: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientGetAuthorizedDevicesResponse.AuthorizedDevice.app_played)
        pub app_played: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientGetAuthorizedDevicesResponse.AuthorizedDevice.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AuthorizedDevice {
        fn default() -> &'a AuthorizedDevice {
            <AuthorizedDevice as ::protobuf::Message>::default_instance()
        }
    }

    impl AuthorizedDevice {
        pub fn new() -> AuthorizedDevice {
            ::std::default::Default::default()
        }

        // optional uint64 auth_device_token = 1;

        pub fn auth_device_token(&self) -> u64 {
            self.auth_device_token.unwrap_or(0)
        }

        pub fn clear_auth_device_token(&mut self) {
            self.auth_device_token = ::std::option::Option::None;
        }

        pub fn has_auth_device_token(&self) -> bool {
            self.auth_device_token.is_some()
        }

        // Param is passed by value, moved
        pub fn set_auth_device_token(&mut self, v: u64) {
            self.auth_device_token = ::std::option::Option::Some(v);
        }

        // optional string device_name = 2;

        pub fn device_name(&self) -> &str {
            match self.device_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_device_name(&mut self) {
            self.device_name = ::std::option::Option::None;
        }

        pub fn has_device_name(&self) -> bool {
            self.device_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device_name(&mut self, v: ::std::string::String) {
            self.device_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_device_name(&mut self) -> &mut ::std::string::String {
            if self.device_name.is_none() {
                self.device_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.device_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_device_name(&mut self) -> ::std::string::String {
            self.device_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 last_access_time = 3;

        pub fn last_access_time(&self) -> u32 {
            self.last_access_time.unwrap_or(0)
        }

        pub fn clear_last_access_time(&mut self) {
            self.last_access_time = ::std::option::Option::None;
        }

        pub fn has_last_access_time(&self) -> bool {
            self.last_access_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_last_access_time(&mut self, v: u32) {
            self.last_access_time = ::std::option::Option::Some(v);
        }

        // optional uint32 borrower_id = 4;

        pub fn borrower_id(&self) -> u32 {
            self.borrower_id.unwrap_or(0)
        }

        pub fn clear_borrower_id(&mut self) {
            self.borrower_id = ::std::option::Option::None;
        }

        pub fn has_borrower_id(&self) -> bool {
            self.borrower_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_borrower_id(&mut self, v: u32) {
            self.borrower_id = ::std::option::Option::Some(v);
        }

        // optional bool is_pending = 5;

        pub fn is_pending(&self) -> bool {
            self.is_pending.unwrap_or(false)
        }

        pub fn clear_is_pending(&mut self) {
            self.is_pending = ::std::option::Option::None;
        }

        pub fn has_is_pending(&self) -> bool {
            self.is_pending.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_pending(&mut self, v: bool) {
            self.is_pending = ::std::option::Option::Some(v);
        }

        // optional uint32 app_played = 6;

        pub fn app_played(&self) -> u32 {
            self.app_played.unwrap_or(0)
        }

        pub fn clear_app_played(&mut self) {
            self.app_played = ::std::option::Option::None;
        }

        pub fn has_app_played(&self) -> bool {
            self.app_played.is_some()
        }

        // Param is passed by value, moved
        pub fn set_app_played(&mut self, v: u32) {
            self.app_played = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "auth_device_token",
                |m: &AuthorizedDevice| { &m.auth_device_token },
                |m: &mut AuthorizedDevice| { &mut m.auth_device_token },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "device_name",
                |m: &AuthorizedDevice| { &m.device_name },
                |m: &mut AuthorizedDevice| { &mut m.device_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "last_access_time",
                |m: &AuthorizedDevice| { &m.last_access_time },
                |m: &mut AuthorizedDevice| { &mut m.last_access_time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "borrower_id",
                |m: &AuthorizedDevice| { &m.borrower_id },
                |m: &mut AuthorizedDevice| { &mut m.borrower_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_pending",
                |m: &AuthorizedDevice| { &m.is_pending },
                |m: &mut AuthorizedDevice| { &mut m.is_pending },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "app_played",
                |m: &AuthorizedDevice| { &m.app_played },
                |m: &mut AuthorizedDevice| { &mut m.app_played },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AuthorizedDevice>(
                "CMsgClientGetAuthorizedDevicesResponse.AuthorizedDevice",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AuthorizedDevice {
        const NAME: &'static str = "AuthorizedDevice";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.auth_device_token = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    18 => {
                        self.device_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.last_access_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.borrower_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.is_pending = ::std::option::Option::Some(is.read_bool()?);
                    },
                    48 => {
                        self.app_played = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.auth_device_token {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.device_name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.last_access_time {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.borrower_id {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.is_pending {
                my_size += 1 + 1;
            }
            if let Some(v) = self.app_played {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.auth_device_token {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.device_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.last_access_time {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.borrower_id {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.is_pending {
                os.write_bool(5, v)?;
            }
            if let Some(v) = self.app_played {
                os.write_uint32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AuthorizedDevice {
            AuthorizedDevice::new()
        }

        fn clear(&mut self) {
            self.auth_device_token = ::std::option::Option::None;
            self.device_name = ::std::option::Option::None;
            self.last_access_time = ::std::option::Option::None;
            self.borrower_id = ::std::option::Option::None;
            self.is_pending = ::std::option::Option::None;
            self.app_played = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AuthorizedDevice {
            static instance: AuthorizedDevice = AuthorizedDevice {
                auth_device_token: ::std::option::Option::None,
                device_name: ::std::option::Option::None,
                last_access_time: ::std::option::Option::None,
                borrower_id: ::std::option::Option::None,
                is_pending: ::std::option::Option::None,
                app_played: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AuthorizedDevice {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientGetAuthorizedDevicesResponse.AuthorizedDevice").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AuthorizedDevice {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AuthorizedDevice {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientSharedLibraryLockStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientSharedLibraryLockStatus {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientSharedLibraryLockStatus.locked_library)
    pub locked_library: ::std::vec::Vec<cmsg_client_shared_library_lock_status::LockedLibrary>,
    // @@protoc_insertion_point(field:CMsgClientSharedLibraryLockStatus.own_library_locked_by)
    pub own_library_locked_by: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientSharedLibraryLockStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientSharedLibraryLockStatus {
    fn default() -> &'a CMsgClientSharedLibraryLockStatus {
        <CMsgClientSharedLibraryLockStatus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientSharedLibraryLockStatus {
    pub fn new() -> CMsgClientSharedLibraryLockStatus {
        ::std::default::Default::default()
    }

    // optional uint32 own_library_locked_by = 2;

    pub fn own_library_locked_by(&self) -> u32 {
        self.own_library_locked_by.unwrap_or(0)
    }

    pub fn clear_own_library_locked_by(&mut self) {
        self.own_library_locked_by = ::std::option::Option::None;
    }

    pub fn has_own_library_locked_by(&self) -> bool {
        self.own_library_locked_by.is_some()
    }

    // Param is passed by value, moved
    pub fn set_own_library_locked_by(&mut self, v: u32) {
        self.own_library_locked_by = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "locked_library",
            |m: &CMsgClientSharedLibraryLockStatus| { &m.locked_library },
            |m: &mut CMsgClientSharedLibraryLockStatus| { &mut m.locked_library },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "own_library_locked_by",
            |m: &CMsgClientSharedLibraryLockStatus| { &m.own_library_locked_by },
            |m: &mut CMsgClientSharedLibraryLockStatus| { &mut m.own_library_locked_by },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientSharedLibraryLockStatus>(
            "CMsgClientSharedLibraryLockStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientSharedLibraryLockStatus {
    const NAME: &'static str = "CMsgClientSharedLibraryLockStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.locked_library.push(is.read_message()?);
                },
                16 => {
                    self.own_library_locked_by = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.locked_library {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.own_library_locked_by {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.locked_library {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.own_library_locked_by {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientSharedLibraryLockStatus {
        CMsgClientSharedLibraryLockStatus::new()
    }

    fn clear(&mut self) {
        self.locked_library.clear();
        self.own_library_locked_by = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientSharedLibraryLockStatus {
        static instance: CMsgClientSharedLibraryLockStatus = CMsgClientSharedLibraryLockStatus {
            locked_library: ::std::vec::Vec::new(),
            own_library_locked_by: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientSharedLibraryLockStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientSharedLibraryLockStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientSharedLibraryLockStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientSharedLibraryLockStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientSharedLibraryLockStatus`
pub mod cmsg_client_shared_library_lock_status {
    // @@protoc_insertion_point(message:CMsgClientSharedLibraryLockStatus.LockedLibrary)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LockedLibrary {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientSharedLibraryLockStatus.LockedLibrary.owner_id)
        pub owner_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientSharedLibraryLockStatus.LockedLibrary.locked_by)
        pub locked_by: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientSharedLibraryLockStatus.LockedLibrary.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LockedLibrary {
        fn default() -> &'a LockedLibrary {
            <LockedLibrary as ::protobuf::Message>::default_instance()
        }
    }

    impl LockedLibrary {
        pub fn new() -> LockedLibrary {
            ::std::default::Default::default()
        }

        // optional uint32 owner_id = 1;

        pub fn owner_id(&self) -> u32 {
            self.owner_id.unwrap_or(0)
        }

        pub fn clear_owner_id(&mut self) {
            self.owner_id = ::std::option::Option::None;
        }

        pub fn has_owner_id(&self) -> bool {
            self.owner_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_owner_id(&mut self, v: u32) {
            self.owner_id = ::std::option::Option::Some(v);
        }

        // optional uint32 locked_by = 2;

        pub fn locked_by(&self) -> u32 {
            self.locked_by.unwrap_or(0)
        }

        pub fn clear_locked_by(&mut self) {
            self.locked_by = ::std::option::Option::None;
        }

        pub fn has_locked_by(&self) -> bool {
            self.locked_by.is_some()
        }

        // Param is passed by value, moved
        pub fn set_locked_by(&mut self, v: u32) {
            self.locked_by = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "owner_id",
                |m: &LockedLibrary| { &m.owner_id },
                |m: &mut LockedLibrary| { &mut m.owner_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "locked_by",
                |m: &LockedLibrary| { &m.locked_by },
                |m: &mut LockedLibrary| { &mut m.locked_by },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LockedLibrary>(
                "CMsgClientSharedLibraryLockStatus.LockedLibrary",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for LockedLibrary {
        const NAME: &'static str = "LockedLibrary";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.owner_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.locked_by = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.owner_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.locked_by {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.owner_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.locked_by {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LockedLibrary {
            LockedLibrary::new()
        }

        fn clear(&mut self) {
            self.owner_id = ::std::option::Option::None;
            self.locked_by = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LockedLibrary {
            static instance: LockedLibrary = LockedLibrary {
                owner_id: ::std::option::Option::None,
                locked_by: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for LockedLibrary {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientSharedLibraryLockStatus.LockedLibrary").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for LockedLibrary {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for LockedLibrary {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientSharedLibraryStopPlaying)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientSharedLibraryStopPlaying {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientSharedLibraryStopPlaying.seconds_left)
    pub seconds_left: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientSharedLibraryStopPlaying.stop_apps)
    pub stop_apps: ::std::vec::Vec<cmsg_client_shared_library_stop_playing::StopApp>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientSharedLibraryStopPlaying.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientSharedLibraryStopPlaying {
    fn default() -> &'a CMsgClientSharedLibraryStopPlaying {
        <CMsgClientSharedLibraryStopPlaying as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientSharedLibraryStopPlaying {
    pub fn new() -> CMsgClientSharedLibraryStopPlaying {
        ::std::default::Default::default()
    }

    // optional int32 seconds_left = 1;

    pub fn seconds_left(&self) -> i32 {
        self.seconds_left.unwrap_or(0)
    }

    pub fn clear_seconds_left(&mut self) {
        self.seconds_left = ::std::option::Option::None;
    }

    pub fn has_seconds_left(&self) -> bool {
        self.seconds_left.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_left(&mut self, v: i32) {
        self.seconds_left = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seconds_left",
            |m: &CMsgClientSharedLibraryStopPlaying| { &m.seconds_left },
            |m: &mut CMsgClientSharedLibraryStopPlaying| { &mut m.seconds_left },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stop_apps",
            |m: &CMsgClientSharedLibraryStopPlaying| { &m.stop_apps },
            |m: &mut CMsgClientSharedLibraryStopPlaying| { &mut m.stop_apps },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientSharedLibraryStopPlaying>(
            "CMsgClientSharedLibraryStopPlaying",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientSharedLibraryStopPlaying {
    const NAME: &'static str = "CMsgClientSharedLibraryStopPlaying";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.seconds_left = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.stop_apps.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.seconds_left {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.stop_apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.seconds_left {
            os.write_int32(1, v)?;
        }
        for v in &self.stop_apps {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientSharedLibraryStopPlaying {
        CMsgClientSharedLibraryStopPlaying::new()
    }

    fn clear(&mut self) {
        self.seconds_left = ::std::option::Option::None;
        self.stop_apps.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientSharedLibraryStopPlaying {
        static instance: CMsgClientSharedLibraryStopPlaying = CMsgClientSharedLibraryStopPlaying {
            seconds_left: ::std::option::Option::None,
            stop_apps: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientSharedLibraryStopPlaying {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientSharedLibraryStopPlaying").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientSharedLibraryStopPlaying {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientSharedLibraryStopPlaying {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientSharedLibraryStopPlaying`
pub mod cmsg_client_shared_library_stop_playing {
    // @@protoc_insertion_point(message:CMsgClientSharedLibraryStopPlaying.StopApp)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct StopApp {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientSharedLibraryStopPlaying.StopApp.app_id)
        pub app_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientSharedLibraryStopPlaying.StopApp.owner_id)
        pub owner_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientSharedLibraryStopPlaying.StopApp.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a StopApp {
        fn default() -> &'a StopApp {
            <StopApp as ::protobuf::Message>::default_instance()
        }
    }

    impl StopApp {
        pub fn new() -> StopApp {
            ::std::default::Default::default()
        }

        // optional uint32 app_id = 1;

        pub fn app_id(&self) -> u32 {
            self.app_id.unwrap_or(0)
        }

        pub fn clear_app_id(&mut self) {
            self.app_id = ::std::option::Option::None;
        }

        pub fn has_app_id(&self) -> bool {
            self.app_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_app_id(&mut self, v: u32) {
            self.app_id = ::std::option::Option::Some(v);
        }

        // optional uint32 owner_id = 2;

        pub fn owner_id(&self) -> u32 {
            self.owner_id.unwrap_or(0)
        }

        pub fn clear_owner_id(&mut self) {
            self.owner_id = ::std::option::Option::None;
        }

        pub fn has_owner_id(&self) -> bool {
            self.owner_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_owner_id(&mut self, v: u32) {
            self.owner_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "app_id",
                |m: &StopApp| { &m.app_id },
                |m: &mut StopApp| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "owner_id",
                |m: &StopApp| { &m.owner_id },
                |m: &mut StopApp| { &mut m.owner_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StopApp>(
                "CMsgClientSharedLibraryStopPlaying.StopApp",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for StopApp {
        const NAME: &'static str = "StopApp";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.owner_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.app_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.owner_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.app_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.owner_id {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> StopApp {
            StopApp::new()
        }

        fn clear(&mut self) {
            self.app_id = ::std::option::Option::None;
            self.owner_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static StopApp {
            static instance: StopApp = StopApp {
                app_id: ::std::option::Option::None,
                owner_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for StopApp {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientSharedLibraryStopPlaying.StopApp").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for StopApp {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for StopApp {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientServiceCall)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientServiceCall {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientServiceCall.sysid_routing)
    pub sysid_routing: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientServiceCall.call_handle)
    pub call_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCall.module_crc)
    pub module_crc: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCall.module_hash)
    pub module_hash: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientServiceCall.function_id)
    pub function_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCall.cub_output_max)
    pub cub_output_max: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCall.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCall.callparameter)
    pub callparameter: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientServiceCall.ping_only)
    pub ping_only: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientServiceCall.max_outstanding_calls)
    pub max_outstanding_calls: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientServiceCall.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientServiceCall {
    fn default() -> &'a CMsgClientServiceCall {
        <CMsgClientServiceCall as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientServiceCall {
    pub fn new() -> CMsgClientServiceCall {
        ::std::default::Default::default()
    }

    // optional bytes sysid_routing = 1;

    pub fn sysid_routing(&self) -> &[u8] {
        match self.sysid_routing.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sysid_routing(&mut self) {
        self.sysid_routing = ::std::option::Option::None;
    }

    pub fn has_sysid_routing(&self) -> bool {
        self.sysid_routing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sysid_routing(&mut self, v: ::std::vec::Vec<u8>) {
        self.sysid_routing = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sysid_routing(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sysid_routing.is_none() {
            self.sysid_routing = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.sysid_routing.as_mut().unwrap()
    }

    // Take field
    pub fn take_sysid_routing(&mut self) -> ::std::vec::Vec<u8> {
        self.sysid_routing.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 call_handle = 2;

    pub fn call_handle(&self) -> u32 {
        self.call_handle.unwrap_or(0)
    }

    pub fn clear_call_handle(&mut self) {
        self.call_handle = ::std::option::Option::None;
    }

    pub fn has_call_handle(&self) -> bool {
        self.call_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_call_handle(&mut self, v: u32) {
        self.call_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 module_crc = 3;

    pub fn module_crc(&self) -> u32 {
        self.module_crc.unwrap_or(0)
    }

    pub fn clear_module_crc(&mut self) {
        self.module_crc = ::std::option::Option::None;
    }

    pub fn has_module_crc(&self) -> bool {
        self.module_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_crc(&mut self, v: u32) {
        self.module_crc = ::std::option::Option::Some(v);
    }

    // optional bytes module_hash = 4;

    pub fn module_hash(&self) -> &[u8] {
        match self.module_hash.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_module_hash(&mut self) {
        self.module_hash = ::std::option::Option::None;
    }

    pub fn has_module_hash(&self) -> bool {
        self.module_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.module_hash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.module_hash.is_none() {
            self.module_hash = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.module_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_module_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.module_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 function_id = 5;

    pub fn function_id(&self) -> u32 {
        self.function_id.unwrap_or(0)
    }

    pub fn clear_function_id(&mut self) {
        self.function_id = ::std::option::Option::None;
    }

    pub fn has_function_id(&self) -> bool {
        self.function_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_function_id(&mut self, v: u32) {
        self.function_id = ::std::option::Option::Some(v);
    }

    // optional uint32 cub_output_max = 6;

    pub fn cub_output_max(&self) -> u32 {
        self.cub_output_max.unwrap_or(0)
    }

    pub fn clear_cub_output_max(&mut self) {
        self.cub_output_max = ::std::option::Option::None;
    }

    pub fn has_cub_output_max(&self) -> bool {
        self.cub_output_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cub_output_max(&mut self, v: u32) {
        self.cub_output_max = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 7;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional bytes callparameter = 8;

    pub fn callparameter(&self) -> &[u8] {
        match self.callparameter.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_callparameter(&mut self) {
        self.callparameter = ::std::option::Option::None;
    }

    pub fn has_callparameter(&self) -> bool {
        self.callparameter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_callparameter(&mut self, v: ::std::vec::Vec<u8>) {
        self.callparameter = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_callparameter(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.callparameter.is_none() {
            self.callparameter = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.callparameter.as_mut().unwrap()
    }

    // Take field
    pub fn take_callparameter(&mut self) -> ::std::vec::Vec<u8> {
        self.callparameter.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool ping_only = 9;

    pub fn ping_only(&self) -> bool {
        self.ping_only.unwrap_or(false)
    }

    pub fn clear_ping_only(&mut self) {
        self.ping_only = ::std::option::Option::None;
    }

    pub fn has_ping_only(&self) -> bool {
        self.ping_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_only(&mut self, v: bool) {
        self.ping_only = ::std::option::Option::Some(v);
    }

    // optional uint32 max_outstanding_calls = 10;

    pub fn max_outstanding_calls(&self) -> u32 {
        self.max_outstanding_calls.unwrap_or(0)
    }

    pub fn clear_max_outstanding_calls(&mut self) {
        self.max_outstanding_calls = ::std::option::Option::None;
    }

    pub fn has_max_outstanding_calls(&self) -> bool {
        self.max_outstanding_calls.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_outstanding_calls(&mut self, v: u32) {
        self.max_outstanding_calls = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sysid_routing",
            |m: &CMsgClientServiceCall| { &m.sysid_routing },
            |m: &mut CMsgClientServiceCall| { &mut m.sysid_routing },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "call_handle",
            |m: &CMsgClientServiceCall| { &m.call_handle },
            |m: &mut CMsgClientServiceCall| { &mut m.call_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "module_crc",
            |m: &CMsgClientServiceCall| { &m.module_crc },
            |m: &mut CMsgClientServiceCall| { &mut m.module_crc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "module_hash",
            |m: &CMsgClientServiceCall| { &m.module_hash },
            |m: &mut CMsgClientServiceCall| { &mut m.module_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "function_id",
            |m: &CMsgClientServiceCall| { &m.function_id },
            |m: &mut CMsgClientServiceCall| { &mut m.function_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cub_output_max",
            |m: &CMsgClientServiceCall| { &m.cub_output_max },
            |m: &mut CMsgClientServiceCall| { &mut m.cub_output_max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CMsgClientServiceCall| { &m.flags },
            |m: &mut CMsgClientServiceCall| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "callparameter",
            |m: &CMsgClientServiceCall| { &m.callparameter },
            |m: &mut CMsgClientServiceCall| { &mut m.callparameter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ping_only",
            |m: &CMsgClientServiceCall| { &m.ping_only },
            |m: &mut CMsgClientServiceCall| { &mut m.ping_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_outstanding_calls",
            |m: &CMsgClientServiceCall| { &m.max_outstanding_calls },
            |m: &mut CMsgClientServiceCall| { &mut m.max_outstanding_calls },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientServiceCall>(
            "CMsgClientServiceCall",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientServiceCall {
    const NAME: &'static str = "CMsgClientServiceCall";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.sysid_routing = ::std::option::Option::Some(is.read_bytes()?);
                },
                16 => {
                    self.call_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.module_crc = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.module_hash = ::std::option::Option::Some(is.read_bytes()?);
                },
                40 => {
                    self.function_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.cub_output_max = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.callparameter = ::std::option::Option::Some(is.read_bytes()?);
                },
                72 => {
                    self.ping_only = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.max_outstanding_calls = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sysid_routing.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.call_handle {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.module_crc {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.module_hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.function_id {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.cub_output_max {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.callparameter.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.ping_only {
            my_size += 1 + 1;
        }
        if let Some(v) = self.max_outstanding_calls {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.sysid_routing.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.call_handle {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.module_crc {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.module_hash.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.function_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.cub_output_max {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.callparameter.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.ping_only {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.max_outstanding_calls {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientServiceCall {
        CMsgClientServiceCall::new()
    }

    fn clear(&mut self) {
        self.sysid_routing = ::std::option::Option::None;
        self.call_handle = ::std::option::Option::None;
        self.module_crc = ::std::option::Option::None;
        self.module_hash = ::std::option::Option::None;
        self.function_id = ::std::option::Option::None;
        self.cub_output_max = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.callparameter = ::std::option::Option::None;
        self.ping_only = ::std::option::Option::None;
        self.max_outstanding_calls = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientServiceCall {
        static instance: CMsgClientServiceCall = CMsgClientServiceCall {
            sysid_routing: ::std::option::Option::None,
            call_handle: ::std::option::Option::None,
            module_crc: ::std::option::Option::None,
            module_hash: ::std::option::Option::None,
            function_id: ::std::option::Option::None,
            cub_output_max: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            callparameter: ::std::option::Option::None,
            ping_only: ::std::option::Option::None,
            max_outstanding_calls: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientServiceCall {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientServiceCall").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientServiceCall {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientServiceCall {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientServiceModule)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientServiceModule {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientServiceModule.module_crc)
    pub module_crc: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceModule.module_hash)
    pub module_hash: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientServiceModule.module_content)
    pub module_content: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientServiceModule.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientServiceModule {
    fn default() -> &'a CMsgClientServiceModule {
        <CMsgClientServiceModule as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientServiceModule {
    pub fn new() -> CMsgClientServiceModule {
        ::std::default::Default::default()
    }

    // optional uint32 module_crc = 1;

    pub fn module_crc(&self) -> u32 {
        self.module_crc.unwrap_or(0)
    }

    pub fn clear_module_crc(&mut self) {
        self.module_crc = ::std::option::Option::None;
    }

    pub fn has_module_crc(&self) -> bool {
        self.module_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_crc(&mut self, v: u32) {
        self.module_crc = ::std::option::Option::Some(v);
    }

    // optional bytes module_hash = 2;

    pub fn module_hash(&self) -> &[u8] {
        match self.module_hash.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_module_hash(&mut self) {
        self.module_hash = ::std::option::Option::None;
    }

    pub fn has_module_hash(&self) -> bool {
        self.module_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.module_hash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.module_hash.is_none() {
            self.module_hash = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.module_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_module_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.module_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes module_content = 3;

    pub fn module_content(&self) -> &[u8] {
        match self.module_content.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_module_content(&mut self) {
        self.module_content = ::std::option::Option::None;
    }

    pub fn has_module_content(&self) -> bool {
        self.module_content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_content(&mut self, v: ::std::vec::Vec<u8>) {
        self.module_content = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_content(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.module_content.is_none() {
            self.module_content = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.module_content.as_mut().unwrap()
    }

    // Take field
    pub fn take_module_content(&mut self) -> ::std::vec::Vec<u8> {
        self.module_content.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "module_crc",
            |m: &CMsgClientServiceModule| { &m.module_crc },
            |m: &mut CMsgClientServiceModule| { &mut m.module_crc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "module_hash",
            |m: &CMsgClientServiceModule| { &m.module_hash },
            |m: &mut CMsgClientServiceModule| { &mut m.module_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "module_content",
            |m: &CMsgClientServiceModule| { &m.module_content },
            |m: &mut CMsgClientServiceModule| { &mut m.module_content },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientServiceModule>(
            "CMsgClientServiceModule",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientServiceModule {
    const NAME: &'static str = "CMsgClientServiceModule";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.module_crc = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.module_hash = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.module_content = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.module_crc {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.module_hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.module_content.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.module_crc {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.module_hash.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.module_content.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientServiceModule {
        CMsgClientServiceModule::new()
    }

    fn clear(&mut self) {
        self.module_crc = ::std::option::Option::None;
        self.module_hash = ::std::option::Option::None;
        self.module_content = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientServiceModule {
        static instance: CMsgClientServiceModule = CMsgClientServiceModule {
            module_crc: ::std::option::Option::None,
            module_hash: ::std::option::Option::None,
            module_content: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientServiceModule {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientServiceModule").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientServiceModule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientServiceModule {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientServiceCallResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientServiceCallResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.sysid_routing)
    pub sysid_routing: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.call_handle)
    pub call_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.module_crc)
    pub module_crc: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.module_hash)
    pub module_hash: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.ecallresult)
    pub ecallresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.result_content)
    pub result_content: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.os_version_info)
    pub os_version_info: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.system_info)
    pub system_info: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.load_address)
    pub load_address: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.exception_record)
    pub exception_record: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.portable_os_version_info)
    pub portable_os_version_info: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.portable_system_info)
    pub portable_system_info: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.was_converted)
    pub was_converted: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.internal_result)
    pub internal_result: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.current_count)
    pub current_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.last_call_handle)
    pub last_call_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.last_call_module_crc)
    pub last_call_module_crc: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.last_call_sysid_routing)
    pub last_call_sysid_routing: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.last_ecallresult)
    pub last_ecallresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.last_callissue_delta)
    pub last_callissue_delta: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientServiceCallResponse.last_callcomplete_delta)
    pub last_callcomplete_delta: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientServiceCallResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientServiceCallResponse {
    fn default() -> &'a CMsgClientServiceCallResponse {
        <CMsgClientServiceCallResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientServiceCallResponse {
    pub fn new() -> CMsgClientServiceCallResponse {
        ::std::default::Default::default()
    }

    // optional bytes sysid_routing = 1;

    pub fn sysid_routing(&self) -> &[u8] {
        match self.sysid_routing.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sysid_routing(&mut self) {
        self.sysid_routing = ::std::option::Option::None;
    }

    pub fn has_sysid_routing(&self) -> bool {
        self.sysid_routing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sysid_routing(&mut self, v: ::std::vec::Vec<u8>) {
        self.sysid_routing = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sysid_routing(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sysid_routing.is_none() {
            self.sysid_routing = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.sysid_routing.as_mut().unwrap()
    }

    // Take field
    pub fn take_sysid_routing(&mut self) -> ::std::vec::Vec<u8> {
        self.sysid_routing.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 call_handle = 2;

    pub fn call_handle(&self) -> u32 {
        self.call_handle.unwrap_or(0)
    }

    pub fn clear_call_handle(&mut self) {
        self.call_handle = ::std::option::Option::None;
    }

    pub fn has_call_handle(&self) -> bool {
        self.call_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_call_handle(&mut self, v: u32) {
        self.call_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 module_crc = 3;

    pub fn module_crc(&self) -> u32 {
        self.module_crc.unwrap_or(0)
    }

    pub fn clear_module_crc(&mut self) {
        self.module_crc = ::std::option::Option::None;
    }

    pub fn has_module_crc(&self) -> bool {
        self.module_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_crc(&mut self, v: u32) {
        self.module_crc = ::std::option::Option::Some(v);
    }

    // optional bytes module_hash = 4;

    pub fn module_hash(&self) -> &[u8] {
        match self.module_hash.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_module_hash(&mut self) {
        self.module_hash = ::std::option::Option::None;
    }

    pub fn has_module_hash(&self) -> bool {
        self.module_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.module_hash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.module_hash.is_none() {
            self.module_hash = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.module_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_module_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.module_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 ecallresult = 5;

    pub fn ecallresult(&self) -> u32 {
        self.ecallresult.unwrap_or(0)
    }

    pub fn clear_ecallresult(&mut self) {
        self.ecallresult = ::std::option::Option::None;
    }

    pub fn has_ecallresult(&self) -> bool {
        self.ecallresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ecallresult(&mut self, v: u32) {
        self.ecallresult = ::std::option::Option::Some(v);
    }

    // optional bytes result_content = 6;

    pub fn result_content(&self) -> &[u8] {
        match self.result_content.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_result_content(&mut self) {
        self.result_content = ::std::option::Option::None;
    }

    pub fn has_result_content(&self) -> bool {
        self.result_content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result_content(&mut self, v: ::std::vec::Vec<u8>) {
        self.result_content = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result_content(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.result_content.is_none() {
            self.result_content = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.result_content.as_mut().unwrap()
    }

    // Take field
    pub fn take_result_content(&mut self) -> ::std::vec::Vec<u8> {
        self.result_content.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes os_version_info = 7;

    pub fn os_version_info(&self) -> &[u8] {
        match self.os_version_info.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_os_version_info(&mut self) {
        self.os_version_info = ::std::option::Option::None;
    }

    pub fn has_os_version_info(&self) -> bool {
        self.os_version_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os_version_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.os_version_info = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os_version_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.os_version_info.is_none() {
            self.os_version_info = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.os_version_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_os_version_info(&mut self) -> ::std::vec::Vec<u8> {
        self.os_version_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes system_info = 8;

    pub fn system_info(&self) -> &[u8] {
        match self.system_info.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_system_info(&mut self) {
        self.system_info = ::std::option::Option::None;
    }

    pub fn has_system_info(&self) -> bool {
        self.system_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_system_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.system_info = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_system_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.system_info.is_none() {
            self.system_info = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.system_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_system_info(&mut self) -> ::std::vec::Vec<u8> {
        self.system_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed64 load_address = 9;

    pub fn load_address(&self) -> u64 {
        self.load_address.unwrap_or(0)
    }

    pub fn clear_load_address(&mut self) {
        self.load_address = ::std::option::Option::None;
    }

    pub fn has_load_address(&self) -> bool {
        self.load_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_load_address(&mut self, v: u64) {
        self.load_address = ::std::option::Option::Some(v);
    }

    // optional bytes exception_record = 10;

    pub fn exception_record(&self) -> &[u8] {
        match self.exception_record.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_exception_record(&mut self) {
        self.exception_record = ::std::option::Option::None;
    }

    pub fn has_exception_record(&self) -> bool {
        self.exception_record.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exception_record(&mut self, v: ::std::vec::Vec<u8>) {
        self.exception_record = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exception_record(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.exception_record.is_none() {
            self.exception_record = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.exception_record.as_mut().unwrap()
    }

    // Take field
    pub fn take_exception_record(&mut self) -> ::std::vec::Vec<u8> {
        self.exception_record.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes portable_os_version_info = 11;

    pub fn portable_os_version_info(&self) -> &[u8] {
        match self.portable_os_version_info.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_portable_os_version_info(&mut self) {
        self.portable_os_version_info = ::std::option::Option::None;
    }

    pub fn has_portable_os_version_info(&self) -> bool {
        self.portable_os_version_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_portable_os_version_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.portable_os_version_info = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_portable_os_version_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.portable_os_version_info.is_none() {
            self.portable_os_version_info = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.portable_os_version_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_portable_os_version_info(&mut self) -> ::std::vec::Vec<u8> {
        self.portable_os_version_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes portable_system_info = 12;

    pub fn portable_system_info(&self) -> &[u8] {
        match self.portable_system_info.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_portable_system_info(&mut self) {
        self.portable_system_info = ::std::option::Option::None;
    }

    pub fn has_portable_system_info(&self) -> bool {
        self.portable_system_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_portable_system_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.portable_system_info = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_portable_system_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.portable_system_info.is_none() {
            self.portable_system_info = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.portable_system_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_portable_system_info(&mut self) -> ::std::vec::Vec<u8> {
        self.portable_system_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool was_converted = 13;

    pub fn was_converted(&self) -> bool {
        self.was_converted.unwrap_or(false)
    }

    pub fn clear_was_converted(&mut self) {
        self.was_converted = ::std::option::Option::None;
    }

    pub fn has_was_converted(&self) -> bool {
        self.was_converted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_was_converted(&mut self, v: bool) {
        self.was_converted = ::std::option::Option::Some(v);
    }

    // optional uint32 internal_result = 14;

    pub fn internal_result(&self) -> u32 {
        self.internal_result.unwrap_or(0)
    }

    pub fn clear_internal_result(&mut self) {
        self.internal_result = ::std::option::Option::None;
    }

    pub fn has_internal_result(&self) -> bool {
        self.internal_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_internal_result(&mut self, v: u32) {
        self.internal_result = ::std::option::Option::Some(v);
    }

    // optional uint32 current_count = 15;

    pub fn current_count(&self) -> u32 {
        self.current_count.unwrap_or(0)
    }

    pub fn clear_current_count(&mut self) {
        self.current_count = ::std::option::Option::None;
    }

    pub fn has_current_count(&self) -> bool {
        self.current_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_count(&mut self, v: u32) {
        self.current_count = ::std::option::Option::Some(v);
    }

    // optional uint32 last_call_handle = 16;

    pub fn last_call_handle(&self) -> u32 {
        self.last_call_handle.unwrap_or(0)
    }

    pub fn clear_last_call_handle(&mut self) {
        self.last_call_handle = ::std::option::Option::None;
    }

    pub fn has_last_call_handle(&self) -> bool {
        self.last_call_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_call_handle(&mut self, v: u32) {
        self.last_call_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 last_call_module_crc = 17;

    pub fn last_call_module_crc(&self) -> u32 {
        self.last_call_module_crc.unwrap_or(0)
    }

    pub fn clear_last_call_module_crc(&mut self) {
        self.last_call_module_crc = ::std::option::Option::None;
    }

    pub fn has_last_call_module_crc(&self) -> bool {
        self.last_call_module_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_call_module_crc(&mut self, v: u32) {
        self.last_call_module_crc = ::std::option::Option::Some(v);
    }

    // optional bytes last_call_sysid_routing = 18;

    pub fn last_call_sysid_routing(&self) -> &[u8] {
        match self.last_call_sysid_routing.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_last_call_sysid_routing(&mut self) {
        self.last_call_sysid_routing = ::std::option::Option::None;
    }

    pub fn has_last_call_sysid_routing(&self) -> bool {
        self.last_call_sysid_routing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_call_sysid_routing(&mut self, v: ::std::vec::Vec<u8>) {
        self.last_call_sysid_routing = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_call_sysid_routing(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.last_call_sysid_routing.is_none() {
            self.last_call_sysid_routing = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.last_call_sysid_routing.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_call_sysid_routing(&mut self) -> ::std::vec::Vec<u8> {
        self.last_call_sysid_routing.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 last_ecallresult = 19;

    pub fn last_ecallresult(&self) -> u32 {
        self.last_ecallresult.unwrap_or(0)
    }

    pub fn clear_last_ecallresult(&mut self) {
        self.last_ecallresult = ::std::option::Option::None;
    }

    pub fn has_last_ecallresult(&self) -> bool {
        self.last_ecallresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_ecallresult(&mut self, v: u32) {
        self.last_ecallresult = ::std::option::Option::Some(v);
    }

    // optional uint32 last_callissue_delta = 20;

    pub fn last_callissue_delta(&self) -> u32 {
        self.last_callissue_delta.unwrap_or(0)
    }

    pub fn clear_last_callissue_delta(&mut self) {
        self.last_callissue_delta = ::std::option::Option::None;
    }

    pub fn has_last_callissue_delta(&self) -> bool {
        self.last_callissue_delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_callissue_delta(&mut self, v: u32) {
        self.last_callissue_delta = ::std::option::Option::Some(v);
    }

    // optional uint32 last_callcomplete_delta = 21;

    pub fn last_callcomplete_delta(&self) -> u32 {
        self.last_callcomplete_delta.unwrap_or(0)
    }

    pub fn clear_last_callcomplete_delta(&mut self) {
        self.last_callcomplete_delta = ::std::option::Option::None;
    }

    pub fn has_last_callcomplete_delta(&self) -> bool {
        self.last_callcomplete_delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_callcomplete_delta(&mut self, v: u32) {
        self.last_callcomplete_delta = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(21);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sysid_routing",
            |m: &CMsgClientServiceCallResponse| { &m.sysid_routing },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.sysid_routing },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "call_handle",
            |m: &CMsgClientServiceCallResponse| { &m.call_handle },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.call_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "module_crc",
            |m: &CMsgClientServiceCallResponse| { &m.module_crc },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.module_crc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "module_hash",
            |m: &CMsgClientServiceCallResponse| { &m.module_hash },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.module_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ecallresult",
            |m: &CMsgClientServiceCallResponse| { &m.ecallresult },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.ecallresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result_content",
            |m: &CMsgClientServiceCallResponse| { &m.result_content },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.result_content },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "os_version_info",
            |m: &CMsgClientServiceCallResponse| { &m.os_version_info },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.os_version_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "system_info",
            |m: &CMsgClientServiceCallResponse| { &m.system_info },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.system_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "load_address",
            |m: &CMsgClientServiceCallResponse| { &m.load_address },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.load_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "exception_record",
            |m: &CMsgClientServiceCallResponse| { &m.exception_record },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.exception_record },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "portable_os_version_info",
            |m: &CMsgClientServiceCallResponse| { &m.portable_os_version_info },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.portable_os_version_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "portable_system_info",
            |m: &CMsgClientServiceCallResponse| { &m.portable_system_info },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.portable_system_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "was_converted",
            |m: &CMsgClientServiceCallResponse| { &m.was_converted },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.was_converted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "internal_result",
            |m: &CMsgClientServiceCallResponse| { &m.internal_result },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.internal_result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "current_count",
            |m: &CMsgClientServiceCallResponse| { &m.current_count },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.current_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_call_handle",
            |m: &CMsgClientServiceCallResponse| { &m.last_call_handle },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.last_call_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_call_module_crc",
            |m: &CMsgClientServiceCallResponse| { &m.last_call_module_crc },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.last_call_module_crc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_call_sysid_routing",
            |m: &CMsgClientServiceCallResponse| { &m.last_call_sysid_routing },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.last_call_sysid_routing },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_ecallresult",
            |m: &CMsgClientServiceCallResponse| { &m.last_ecallresult },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.last_ecallresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_callissue_delta",
            |m: &CMsgClientServiceCallResponse| { &m.last_callissue_delta },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.last_callissue_delta },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_callcomplete_delta",
            |m: &CMsgClientServiceCallResponse| { &m.last_callcomplete_delta },
            |m: &mut CMsgClientServiceCallResponse| { &mut m.last_callcomplete_delta },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientServiceCallResponse>(
            "CMsgClientServiceCallResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientServiceCallResponse {
    const NAME: &'static str = "CMsgClientServiceCallResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.sysid_routing = ::std::option::Option::Some(is.read_bytes()?);
                },
                16 => {
                    self.call_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.module_crc = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.module_hash = ::std::option::Option::Some(is.read_bytes()?);
                },
                40 => {
                    self.ecallresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    self.result_content = ::std::option::Option::Some(is.read_bytes()?);
                },
                58 => {
                    self.os_version_info = ::std::option::Option::Some(is.read_bytes()?);
                },
                66 => {
                    self.system_info = ::std::option::Option::Some(is.read_bytes()?);
                },
                73 => {
                    self.load_address = ::std::option::Option::Some(is.read_fixed64()?);
                },
                82 => {
                    self.exception_record = ::std::option::Option::Some(is.read_bytes()?);
                },
                90 => {
                    self.portable_os_version_info = ::std::option::Option::Some(is.read_bytes()?);
                },
                98 => {
                    self.portable_system_info = ::std::option::Option::Some(is.read_bytes()?);
                },
                104 => {
                    self.was_converted = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.internal_result = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.current_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.last_call_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.last_call_module_crc = ::std::option::Option::Some(is.read_uint32()?);
                },
                146 => {
                    self.last_call_sysid_routing = ::std::option::Option::Some(is.read_bytes()?);
                },
                152 => {
                    self.last_ecallresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.last_callissue_delta = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.last_callcomplete_delta = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sysid_routing.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.call_handle {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.module_crc {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.module_hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.ecallresult {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.result_content.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.os_version_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.system_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.load_address {
            my_size += 1 + 8;
        }
        if let Some(v) = self.exception_record.as_ref() {
            my_size += ::protobuf::rt::bytes_size(10, &v);
        }
        if let Some(v) = self.portable_os_version_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(11, &v);
        }
        if let Some(v) = self.portable_system_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(12, &v);
        }
        if let Some(v) = self.was_converted {
            my_size += 1 + 1;
        }
        if let Some(v) = self.internal_result {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.current_count {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.last_call_handle {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.last_call_module_crc {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.last_call_sysid_routing.as_ref() {
            my_size += ::protobuf::rt::bytes_size(18, &v);
        }
        if let Some(v) = self.last_ecallresult {
            my_size += ::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.last_callissue_delta {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.last_callcomplete_delta {
            my_size += ::protobuf::rt::uint32_size(21, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.sysid_routing.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.call_handle {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.module_crc {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.module_hash.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.ecallresult {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.result_content.as_ref() {
            os.write_bytes(6, v)?;
        }
        if let Some(v) = self.os_version_info.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.system_info.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.load_address {
            os.write_fixed64(9, v)?;
        }
        if let Some(v) = self.exception_record.as_ref() {
            os.write_bytes(10, v)?;
        }
        if let Some(v) = self.portable_os_version_info.as_ref() {
            os.write_bytes(11, v)?;
        }
        if let Some(v) = self.portable_system_info.as_ref() {
            os.write_bytes(12, v)?;
        }
        if let Some(v) = self.was_converted {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.internal_result {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.current_count {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.last_call_handle {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.last_call_module_crc {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.last_call_sysid_routing.as_ref() {
            os.write_bytes(18, v)?;
        }
        if let Some(v) = self.last_ecallresult {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.last_callissue_delta {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.last_callcomplete_delta {
            os.write_uint32(21, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientServiceCallResponse {
        CMsgClientServiceCallResponse::new()
    }

    fn clear(&mut self) {
        self.sysid_routing = ::std::option::Option::None;
        self.call_handle = ::std::option::Option::None;
        self.module_crc = ::std::option::Option::None;
        self.module_hash = ::std::option::Option::None;
        self.ecallresult = ::std::option::Option::None;
        self.result_content = ::std::option::Option::None;
        self.os_version_info = ::std::option::Option::None;
        self.system_info = ::std::option::Option::None;
        self.load_address = ::std::option::Option::None;
        self.exception_record = ::std::option::Option::None;
        self.portable_os_version_info = ::std::option::Option::None;
        self.portable_system_info = ::std::option::Option::None;
        self.was_converted = ::std::option::Option::None;
        self.internal_result = ::std::option::Option::None;
        self.current_count = ::std::option::Option::None;
        self.last_call_handle = ::std::option::Option::None;
        self.last_call_module_crc = ::std::option::Option::None;
        self.last_call_sysid_routing = ::std::option::Option::None;
        self.last_ecallresult = ::std::option::Option::None;
        self.last_callissue_delta = ::std::option::Option::None;
        self.last_callcomplete_delta = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientServiceCallResponse {
        static instance: CMsgClientServiceCallResponse = CMsgClientServiceCallResponse {
            sysid_routing: ::std::option::Option::None,
            call_handle: ::std::option::Option::None,
            module_crc: ::std::option::Option::None,
            module_hash: ::std::option::Option::None,
            ecallresult: ::std::option::Option::None,
            result_content: ::std::option::Option::None,
            os_version_info: ::std::option::Option::None,
            system_info: ::std::option::Option::None,
            load_address: ::std::option::Option::None,
            exception_record: ::std::option::Option::None,
            portable_os_version_info: ::std::option::Option::None,
            portable_system_info: ::std::option::Option::None,
            was_converted: ::std::option::Option::None,
            internal_result: ::std::option::Option::None,
            current_count: ::std::option::Option::None,
            last_call_handle: ::std::option::Option::None,
            last_call_module_crc: ::std::option::Option::None,
            last_call_sysid_routing: ::std::option::Option::None,
            last_ecallresult: ::std::option::Option::None,
            last_callissue_delta: ::std::option::Option::None,
            last_callcomplete_delta: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientServiceCallResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientServiceCallResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientServiceCallResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientServiceCallResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgAMUnlockStreaming)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAMUnlockStreaming {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAMUnlockStreaming.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAMUnlockStreaming {
    fn default() -> &'a CMsgAMUnlockStreaming {
        <CMsgAMUnlockStreaming as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAMUnlockStreaming {
    pub fn new() -> CMsgAMUnlockStreaming {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAMUnlockStreaming>(
            "CMsgAMUnlockStreaming",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgAMUnlockStreaming {
    const NAME: &'static str = "CMsgAMUnlockStreaming";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAMUnlockStreaming {
        CMsgAMUnlockStreaming::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAMUnlockStreaming {
        static instance: CMsgAMUnlockStreaming = CMsgAMUnlockStreaming {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgAMUnlockStreaming {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAMUnlockStreaming").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAMUnlockStreaming {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAMUnlockStreaming {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgAMUnlockStreamingResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAMUnlockStreamingResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgAMUnlockStreamingResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgAMUnlockStreamingResponse.encryption_key)
    pub encryption_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAMUnlockStreamingResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAMUnlockStreamingResponse {
    fn default() -> &'a CMsgAMUnlockStreamingResponse {
        <CMsgAMUnlockStreamingResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAMUnlockStreamingResponse {
    pub fn new() -> CMsgAMUnlockStreamingResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional bytes encryption_key = 2;

    pub fn encryption_key(&self) -> &[u8] {
        match self.encryption_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_encryption_key(&mut self) {
        self.encryption_key = ::std::option::Option::None;
    }

    pub fn has_encryption_key(&self) -> bool {
        self.encryption_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryption_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.encryption_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encryption_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.encryption_key.is_none() {
            self.encryption_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.encryption_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_encryption_key(&mut self) -> ::std::vec::Vec<u8> {
        self.encryption_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgAMUnlockStreamingResponse| { &m.eresult },
            |m: &mut CMsgAMUnlockStreamingResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "encryption_key",
            |m: &CMsgAMUnlockStreamingResponse| { &m.encryption_key },
            |m: &mut CMsgAMUnlockStreamingResponse| { &mut m.encryption_key },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAMUnlockStreamingResponse>(
            "CMsgAMUnlockStreamingResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgAMUnlockStreamingResponse {
    const NAME: &'static str = "CMsgAMUnlockStreamingResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.encryption_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.encryption_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.encryption_key.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAMUnlockStreamingResponse {
        CMsgAMUnlockStreamingResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.encryption_key = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAMUnlockStreamingResponse {
        static instance: CMsgAMUnlockStreamingResponse = CMsgAMUnlockStreamingResponse {
            eresult: ::std::option::Option::None,
            encryption_key: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgAMUnlockStreamingResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAMUnlockStreamingResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAMUnlockStreamingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAMUnlockStreamingResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgAMUnlockHEVC)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAMUnlockHEVC {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAMUnlockHEVC.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAMUnlockHEVC {
    fn default() -> &'a CMsgAMUnlockHEVC {
        <CMsgAMUnlockHEVC as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAMUnlockHEVC {
    pub fn new() -> CMsgAMUnlockHEVC {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAMUnlockHEVC>(
            "CMsgAMUnlockHEVC",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgAMUnlockHEVC {
    const NAME: &'static str = "CMsgAMUnlockHEVC";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAMUnlockHEVC {
        CMsgAMUnlockHEVC::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAMUnlockHEVC {
        static instance: CMsgAMUnlockHEVC = CMsgAMUnlockHEVC {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgAMUnlockHEVC {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAMUnlockHEVC").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAMUnlockHEVC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAMUnlockHEVC {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgAMUnlockHEVCResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAMUnlockHEVCResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgAMUnlockHEVCResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAMUnlockHEVCResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAMUnlockHEVCResponse {
    fn default() -> &'a CMsgAMUnlockHEVCResponse {
        <CMsgAMUnlockHEVCResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAMUnlockHEVCResponse {
    pub fn new() -> CMsgAMUnlockHEVCResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgAMUnlockHEVCResponse| { &m.eresult },
            |m: &mut CMsgAMUnlockHEVCResponse| { &mut m.eresult },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAMUnlockHEVCResponse>(
            "CMsgAMUnlockHEVCResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgAMUnlockHEVCResponse {
    const NAME: &'static str = "CMsgAMUnlockHEVCResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAMUnlockHEVCResponse {
        CMsgAMUnlockHEVCResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAMUnlockHEVCResponse {
        static instance: CMsgAMUnlockHEVCResponse = CMsgAMUnlockHEVCResponse {
            eresult: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgAMUnlockHEVCResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAMUnlockHEVCResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAMUnlockHEVCResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAMUnlockHEVCResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientPlayingSessionState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientPlayingSessionState {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientPlayingSessionState.playing_blocked)
    pub playing_blocked: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientPlayingSessionState.playing_app)
    pub playing_app: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientPlayingSessionState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientPlayingSessionState {
    fn default() -> &'a CMsgClientPlayingSessionState {
        <CMsgClientPlayingSessionState as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPlayingSessionState {
    pub fn new() -> CMsgClientPlayingSessionState {
        ::std::default::Default::default()
    }

    // optional bool playing_blocked = 2;

    pub fn playing_blocked(&self) -> bool {
        self.playing_blocked.unwrap_or(false)
    }

    pub fn clear_playing_blocked(&mut self) {
        self.playing_blocked = ::std::option::Option::None;
    }

    pub fn has_playing_blocked(&self) -> bool {
        self.playing_blocked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playing_blocked(&mut self, v: bool) {
        self.playing_blocked = ::std::option::Option::Some(v);
    }

    // optional uint32 playing_app = 3;

    pub fn playing_app(&self) -> u32 {
        self.playing_app.unwrap_or(0)
    }

    pub fn clear_playing_app(&mut self) {
        self.playing_app = ::std::option::Option::None;
    }

    pub fn has_playing_app(&self) -> bool {
        self.playing_app.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playing_app(&mut self, v: u32) {
        self.playing_app = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "playing_blocked",
            |m: &CMsgClientPlayingSessionState| { &m.playing_blocked },
            |m: &mut CMsgClientPlayingSessionState| { &mut m.playing_blocked },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "playing_app",
            |m: &CMsgClientPlayingSessionState| { &m.playing_app },
            |m: &mut CMsgClientPlayingSessionState| { &mut m.playing_app },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientPlayingSessionState>(
            "CMsgClientPlayingSessionState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientPlayingSessionState {
    const NAME: &'static str = "CMsgClientPlayingSessionState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.playing_blocked = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.playing_app = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.playing_blocked {
            my_size += 1 + 1;
        }
        if let Some(v) = self.playing_app {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.playing_blocked {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.playing_app {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientPlayingSessionState {
        CMsgClientPlayingSessionState::new()
    }

    fn clear(&mut self) {
        self.playing_blocked = ::std::option::Option::None;
        self.playing_app = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientPlayingSessionState {
        static instance: CMsgClientPlayingSessionState = CMsgClientPlayingSessionState {
            playing_blocked: ::std::option::Option::None,
            playing_app: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientPlayingSessionState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientPlayingSessionState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientPlayingSessionState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPlayingSessionState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientKickPlayingSession)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientKickPlayingSession {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientKickPlayingSession.only_stop_game)
    pub only_stop_game: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientKickPlayingSession.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientKickPlayingSession {
    fn default() -> &'a CMsgClientKickPlayingSession {
        <CMsgClientKickPlayingSession as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientKickPlayingSession {
    pub fn new() -> CMsgClientKickPlayingSession {
        ::std::default::Default::default()
    }

    // optional bool only_stop_game = 1;

    pub fn only_stop_game(&self) -> bool {
        self.only_stop_game.unwrap_or(false)
    }

    pub fn clear_only_stop_game(&mut self) {
        self.only_stop_game = ::std::option::Option::None;
    }

    pub fn has_only_stop_game(&self) -> bool {
        self.only_stop_game.is_some()
    }

    // Param is passed by value, moved
    pub fn set_only_stop_game(&mut self, v: bool) {
        self.only_stop_game = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "only_stop_game",
            |m: &CMsgClientKickPlayingSession| { &m.only_stop_game },
            |m: &mut CMsgClientKickPlayingSession| { &mut m.only_stop_game },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientKickPlayingSession>(
            "CMsgClientKickPlayingSession",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientKickPlayingSession {
    const NAME: &'static str = "CMsgClientKickPlayingSession";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.only_stop_game = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.only_stop_game {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.only_stop_game {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientKickPlayingSession {
        CMsgClientKickPlayingSession::new()
    }

    fn clear(&mut self) {
        self.only_stop_game = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientKickPlayingSession {
        static instance: CMsgClientKickPlayingSession = CMsgClientKickPlayingSession {
            only_stop_game: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientKickPlayingSession {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientKickPlayingSession").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientKickPlayingSession {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientKickPlayingSession {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientVoiceCallPreAuthorize)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientVoiceCallPreAuthorize {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientVoiceCallPreAuthorize.caller_steamid)
    pub caller_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientVoiceCallPreAuthorize.receiver_steamid)
    pub receiver_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientVoiceCallPreAuthorize.caller_id)
    pub caller_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientVoiceCallPreAuthorize.hangup)
    pub hangup: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientVoiceCallPreAuthorize.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientVoiceCallPreAuthorize {
    fn default() -> &'a CMsgClientVoiceCallPreAuthorize {
        <CMsgClientVoiceCallPreAuthorize as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientVoiceCallPreAuthorize {
    pub fn new() -> CMsgClientVoiceCallPreAuthorize {
        ::std::default::Default::default()
    }

    // optional fixed64 caller_steamid = 1;

    pub fn caller_steamid(&self) -> u64 {
        self.caller_steamid.unwrap_or(0)
    }

    pub fn clear_caller_steamid(&mut self) {
        self.caller_steamid = ::std::option::Option::None;
    }

    pub fn has_caller_steamid(&self) -> bool {
        self.caller_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caller_steamid(&mut self, v: u64) {
        self.caller_steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 receiver_steamid = 2;

    pub fn receiver_steamid(&self) -> u64 {
        self.receiver_steamid.unwrap_or(0)
    }

    pub fn clear_receiver_steamid(&mut self) {
        self.receiver_steamid = ::std::option::Option::None;
    }

    pub fn has_receiver_steamid(&self) -> bool {
        self.receiver_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiver_steamid(&mut self, v: u64) {
        self.receiver_steamid = ::std::option::Option::Some(v);
    }

    // optional int32 caller_id = 3;

    pub fn caller_id(&self) -> i32 {
        self.caller_id.unwrap_or(0)
    }

    pub fn clear_caller_id(&mut self) {
        self.caller_id = ::std::option::Option::None;
    }

    pub fn has_caller_id(&self) -> bool {
        self.caller_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caller_id(&mut self, v: i32) {
        self.caller_id = ::std::option::Option::Some(v);
    }

    // optional bool hangup = 4;

    pub fn hangup(&self) -> bool {
        self.hangup.unwrap_or(false)
    }

    pub fn clear_hangup(&mut self) {
        self.hangup = ::std::option::Option::None;
    }

    pub fn has_hangup(&self) -> bool {
        self.hangup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hangup(&mut self, v: bool) {
        self.hangup = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caller_steamid",
            |m: &CMsgClientVoiceCallPreAuthorize| { &m.caller_steamid },
            |m: &mut CMsgClientVoiceCallPreAuthorize| { &mut m.caller_steamid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "receiver_steamid",
            |m: &CMsgClientVoiceCallPreAuthorize| { &m.receiver_steamid },
            |m: &mut CMsgClientVoiceCallPreAuthorize| { &mut m.receiver_steamid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caller_id",
            |m: &CMsgClientVoiceCallPreAuthorize| { &m.caller_id },
            |m: &mut CMsgClientVoiceCallPreAuthorize| { &mut m.caller_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hangup",
            |m: &CMsgClientVoiceCallPreAuthorize| { &m.hangup },
            |m: &mut CMsgClientVoiceCallPreAuthorize| { &mut m.hangup },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientVoiceCallPreAuthorize>(
            "CMsgClientVoiceCallPreAuthorize",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientVoiceCallPreAuthorize {
    const NAME: &'static str = "CMsgClientVoiceCallPreAuthorize";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.caller_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.receiver_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.caller_id = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.hangup = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.caller_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.receiver_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.caller_id {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.hangup {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.caller_steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.receiver_steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.caller_id {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.hangup {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientVoiceCallPreAuthorize {
        CMsgClientVoiceCallPreAuthorize::new()
    }

    fn clear(&mut self) {
        self.caller_steamid = ::std::option::Option::None;
        self.receiver_steamid = ::std::option::Option::None;
        self.caller_id = ::std::option::Option::None;
        self.hangup = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientVoiceCallPreAuthorize {
        static instance: CMsgClientVoiceCallPreAuthorize = CMsgClientVoiceCallPreAuthorize {
            caller_steamid: ::std::option::Option::None,
            receiver_steamid: ::std::option::Option::None,
            caller_id: ::std::option::Option::None,
            hangup: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientVoiceCallPreAuthorize {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientVoiceCallPreAuthorize").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientVoiceCallPreAuthorize {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientVoiceCallPreAuthorize {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientVoiceCallPreAuthorizeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientVoiceCallPreAuthorizeResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientVoiceCallPreAuthorizeResponse.caller_steamid)
    pub caller_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientVoiceCallPreAuthorizeResponse.receiver_steamid)
    pub receiver_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientVoiceCallPreAuthorizeResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientVoiceCallPreAuthorizeResponse.caller_id)
    pub caller_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientVoiceCallPreAuthorizeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientVoiceCallPreAuthorizeResponse {
    fn default() -> &'a CMsgClientVoiceCallPreAuthorizeResponse {
        <CMsgClientVoiceCallPreAuthorizeResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientVoiceCallPreAuthorizeResponse {
    pub fn new() -> CMsgClientVoiceCallPreAuthorizeResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 caller_steamid = 1;

    pub fn caller_steamid(&self) -> u64 {
        self.caller_steamid.unwrap_or(0)
    }

    pub fn clear_caller_steamid(&mut self) {
        self.caller_steamid = ::std::option::Option::None;
    }

    pub fn has_caller_steamid(&self) -> bool {
        self.caller_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caller_steamid(&mut self, v: u64) {
        self.caller_steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 receiver_steamid = 2;

    pub fn receiver_steamid(&self) -> u64 {
        self.receiver_steamid.unwrap_or(0)
    }

    pub fn clear_receiver_steamid(&mut self) {
        self.receiver_steamid = ::std::option::Option::None;
    }

    pub fn has_receiver_steamid(&self) -> bool {
        self.receiver_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiver_steamid(&mut self, v: u64) {
        self.receiver_steamid = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 3;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional int32 caller_id = 4;

    pub fn caller_id(&self) -> i32 {
        self.caller_id.unwrap_or(0)
    }

    pub fn clear_caller_id(&mut self) {
        self.caller_id = ::std::option::Option::None;
    }

    pub fn has_caller_id(&self) -> bool {
        self.caller_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caller_id(&mut self, v: i32) {
        self.caller_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caller_steamid",
            |m: &CMsgClientVoiceCallPreAuthorizeResponse| { &m.caller_steamid },
            |m: &mut CMsgClientVoiceCallPreAuthorizeResponse| { &mut m.caller_steamid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "receiver_steamid",
            |m: &CMsgClientVoiceCallPreAuthorizeResponse| { &m.receiver_steamid },
            |m: &mut CMsgClientVoiceCallPreAuthorizeResponse| { &mut m.receiver_steamid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientVoiceCallPreAuthorizeResponse| { &m.eresult },
            |m: &mut CMsgClientVoiceCallPreAuthorizeResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caller_id",
            |m: &CMsgClientVoiceCallPreAuthorizeResponse| { &m.caller_id },
            |m: &mut CMsgClientVoiceCallPreAuthorizeResponse| { &mut m.caller_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientVoiceCallPreAuthorizeResponse>(
            "CMsgClientVoiceCallPreAuthorizeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientVoiceCallPreAuthorizeResponse {
    const NAME: &'static str = "CMsgClientVoiceCallPreAuthorizeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.caller_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.receiver_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.caller_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.caller_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.receiver_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.caller_id {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.caller_steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.receiver_steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.caller_id {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientVoiceCallPreAuthorizeResponse {
        CMsgClientVoiceCallPreAuthorizeResponse::new()
    }

    fn clear(&mut self) {
        self.caller_steamid = ::std::option::Option::None;
        self.receiver_steamid = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.caller_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientVoiceCallPreAuthorizeResponse {
        static instance: CMsgClientVoiceCallPreAuthorizeResponse = CMsgClientVoiceCallPreAuthorizeResponse {
            caller_steamid: ::std::option::Option::None,
            receiver_steamid: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            caller_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientVoiceCallPreAuthorizeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientVoiceCallPreAuthorizeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientVoiceCallPreAuthorizeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientVoiceCallPreAuthorizeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgBadgeCraftedNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBadgeCraftedNotification {
    // message fields
    // @@protoc_insertion_point(field:CMsgBadgeCraftedNotification.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBadgeCraftedNotification.badge_level)
    pub badge_level: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBadgeCraftedNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBadgeCraftedNotification {
    fn default() -> &'a CMsgBadgeCraftedNotification {
        <CMsgBadgeCraftedNotification as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBadgeCraftedNotification {
    pub fn new() -> CMsgBadgeCraftedNotification {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 badge_level = 2;

    pub fn badge_level(&self) -> u32 {
        self.badge_level.unwrap_or(0)
    }

    pub fn clear_badge_level(&mut self) {
        self.badge_level = ::std::option::Option::None;
    }

    pub fn has_badge_level(&self) -> bool {
        self.badge_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_badge_level(&mut self, v: u32) {
        self.badge_level = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CMsgBadgeCraftedNotification| { &m.appid },
            |m: &mut CMsgBadgeCraftedNotification| { &mut m.appid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "badge_level",
            |m: &CMsgBadgeCraftedNotification| { &m.badge_level },
            |m: &mut CMsgBadgeCraftedNotification| { &mut m.badge_level },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBadgeCraftedNotification>(
            "CMsgBadgeCraftedNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgBadgeCraftedNotification {
    const NAME: &'static str = "CMsgBadgeCraftedNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.badge_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.badge_level {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.badge_level {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBadgeCraftedNotification {
        CMsgBadgeCraftedNotification::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.badge_level = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBadgeCraftedNotification {
        static instance: CMsgBadgeCraftedNotification = CMsgBadgeCraftedNotification {
            appid: ::std::option::Option::None,
            badge_level: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgBadgeCraftedNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBadgeCraftedNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBadgeCraftedNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBadgeCraftedNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\"steammessages_clientserver_2.proto\x1a\x18steammessages_base.proto\"\
    \xb6\x04\n\x1aCMsgClientUCMAddScreenshot\x12\x14\n\x05appid\x18\x01\x20\
    \x01(\rR\x05appid\x12\x1a\n\x08filename\x18\x02\x20\x01(\tR\x08filename\
    \x12\x1c\n\tthumbname\x18\x03\x20\x01(\tR\tthumbname\x12\x1f\n\x0bvr_fil\
    ename\x18\x0e\x20\x01(\tR\nvrFilename\x12'\n\x0frtime32_created\x18\x04\
    \x20\x01(\x07R\x0ertime32Created\x12\x14\n\x05width\x18\x05\x20\x01(\rR\
    \x05width\x12\x16\n\x06height\x18\x06\x20\x01(\rR\x06height\x12\x20\n\
    \x0bpermissions\x18\x07\x20\x01(\rR\x0bpermissions\x12\x18\n\x07caption\
    \x18\x08\x20\x01(\tR\x07caption\x12#\n\rshortcut_name\x18\t\x20\x01(\tR\
    \x0cshortcutName\x121\n\x03tag\x18\n\x20\x03(\x0b2\x1f.CMsgClientUCMAddS\
    creenshot.TagR\x03tag\x12%\n\x0etagged_steamid\x18\x0b\x20\x03(\x06R\rta\
    ggedSteamid\x12\x1f\n\x0bspoiler_tag\x18\x0c\x20\x01(\x08R\nspoilerTag\
    \x125\n\x16tagged_publishedfileid\x18\r\x20\x03(\x04R\x15taggedPublished\
    fileid\x1a=\n\x03Tag\x12\x19\n\x08tag_name\x18\x01\x20\x01(\tR\x07tagNam\
    e\x12\x1b\n\ttag_value\x18\x02\x20\x01(\tR\x08tagValue\"{\n\"CMsgClientU\
    CMAddScreenshotResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\
    \x07eresult\x128\n\x0cscreenshotid\x18\x02\x20\x01(\x06:\x14184467440737\
    09551615R\x0cscreenshotid\"Y\n\x1dCMsgClientUCMDeleteScreenshot\x128\n\
    \x0cscreenshotid\x18\x01\x20\x01(\x06:\x1418446744073709551615R\x0cscree\
    nshotid\"D\n%CMsgClientUCMDeleteScreenshotResponse\x12\x1b\n\x07eresult\
    \x18\x01\x20\x01(\x05:\x012R\x07eresult\"\x83\x04\n\x18CMsgClientUCMPubl\
    ishFile\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12\x1b\n\tfile\
    _name\x18\x02\x20\x01(\tR\x08fileName\x12*\n\x11preview_file_name\x18\
    \x03\x20\x01(\tR\x0fpreviewFileName\x12&\n\x0fconsumer_app_id\x18\x04\
    \x20\x01(\rR\rconsumerAppId\x12\x14\n\x05title\x18\x05\x20\x01(\tR\x05ti\
    tle\x12\x20\n\x0bdescription\x18\x06\x20\x01(\tR\x0bdescription\x12\x12\
    \n\x04tags\x18\x08\x20\x03(\tR\x04tags\x12#\n\rworkshop_file\x18\t\x20\
    \x01(\x08R\x0cworkshopFile\x12\x1e\n\nvisibility\x18\n\x20\x01(\x05R\nvi\
    sibility\x12\x1b\n\tfile_type\x18\x0b\x20\x01(\rR\x08fileType\x12\x10\n\
    \x03url\x18\x0c\x20\x01(\tR\x03url\x12%\n\x0evideo_provider\x18\r\x20\
    \x01(\rR\rvideoProvider\x12,\n\x12video_account_name\x18\x0e\x20\x01(\tR\
    \x10videoAccountName\x12)\n\x10video_identifier\x18\x0f\x20\x01(\tR\x0fv\
    ideoIdentifier\x12\x1f\n\x0bin_progress\x18\x10\x20\x01(\x08R\ninProgres\
    s\"\xe2\x01\n\x20CMsgClientUCMPublishFileResponse\x12\x1b\n\x07eresult\
    \x18\x01\x20\x01(\x05:\x012R\x07eresult\x12@\n\x11published_file_id\x18\
    \x02\x20\x01(\x06:\x1418446744073709551615R\x0fpublishedFileId\x12_\n)ne\
    eds_workshop_legal_agreement_acceptance\x18\x03\x20\x01(\x08:\x05falseR%\
    needsWorkshopLegalAgreementAcceptance\"\x84\x0b\n\x20CMsgClientUCMUpdate\
    PublishedFile\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12*\n\
    \x11published_file_id\x18\x02\x20\x01(\x06R\x0fpublishedFileId\x12\x1b\n\
    \tfile_name\x18\x03\x20\x01(\tR\x08fileName\x12*\n\x11preview_file_name\
    \x18\x04\x20\x01(\tR\x0fpreviewFileName\x12\x14\n\x05title\x18\x05\x20\
    \x01(\tR\x05title\x12\x20\n\x0bdescription\x18\x06\x20\x01(\tR\x0bdescri\
    ption\x12\x12\n\x04tags\x18\x07\x20\x03(\tR\x04tags\x12\x1e\n\nvisibilit\
    y\x18\x08\x20\x01(\x05R\nvisibility\x12\x1f\n\x0bupdate_file\x18\t\x20\
    \x01(\x08R\nupdateFile\x12.\n\x13update_preview_file\x18\n\x20\x01(\x08R\
    \x11updatePreviewFile\x12!\n\x0cupdate_title\x18\x0b\x20\x01(\x08R\x0bup\
    dateTitle\x12-\n\x12update_description\x18\x0c\x20\x01(\x08R\x11updateDe\
    scription\x12\x1f\n\x0bupdate_tags\x18\r\x20\x01(\x08R\nupdateTags\x12+\
    \n\x11update_visibility\x18\x0e\x20\x01(\x08R\x10updateVisibility\x12-\n\
    \x12change_description\x18\x0f\x20\x01(\tR\x11changeDescription\x12\x1d\
    \n\nupdate_url\x18\x10\x20\x01(\x08R\tupdateUrl\x12\x10\n\x03url\x18\x11\
    \x20\x01(\tR\x03url\x126\n\x17update_content_manifest\x18\x12\x20\x01(\
    \x08R\x15updateContentManifest\x12)\n\x10content_manifest\x18\x13\x20\
    \x01(\x06R\x0fcontentManifest\x12\x1a\n\x08metadata\x18\x14\x20\x01(\tR\
    \x08metadata\x12'\n\x0fupdate_metadata\x18\x15\x20\x01(\x08R\x0eupdateMe\
    tadata\x12\x1d\n\x08language\x18\x16\x20\x01(\x05:\x010R\x08language\x12\
    %\n\x0eremoved_kvtags\x18\x17\x20\x03(\tR\rremovedKvtags\x12E\n\x06kvtag\
    s\x18\x18\x20\x03(\x0b2-.CMsgClientUCMUpdatePublishedFile.KeyValueTagR\
    \x06kvtags\x12O\n\x08previews\x18\x19\x20\x03(\x0b23.CMsgClientUCMUpdate\
    PublishedFile.AdditionalPreviewR\x08previews\x12,\n\x12previews_to_remov\
    e\x18\x1a\x20\x03(\x05R\x10previewsToRemove\x12*\n\x11clear_in_progress\
    \x18\x1b\x20\x01(\x08R\x0fclearInProgress\x12*\n\x11remove_all_kvtags\
    \x18\x1c\x20\x01(\x08R\x0fremoveAllKvtags\x1a5\n\x0bKeyValueTag\x12\x10\
    \n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\
    \tR\x05value\x1a\xd3\x01\n\x11AdditionalPreview\x12,\n\x12original_file_\
    name\x18\x01\x20\x01(\tR\x10originalFileName\x12,\n\x12internal_file_nam\
    e\x18\x02\x20\x01(\tR\x10internalFileName\x12\x18\n\x07videoid\x18\x03\
    \x20\x01(\tR\x07videoid\x12!\n\x0cpreview_type\x18\x04\x20\x01(\rR\x0bpr\
    eviewType\x12%\n\x0cupdate_index\x18\x05\x20\x01(\x05:\x02-1R\x0bupdateI\
    ndex\"\xa8\x01\n(CMsgClientUCMUpdatePublishedFileResponse\x12\x1b\n\x07e\
    result\x18\x01\x20\x01(\x05:\x012R\x07eresult\x12_\n)needs_workshop_lega\
    l_agreement_acceptance\x18\x02\x20\x01(\x08:\x05falseR%needsWorkshopLega\
    lAgreementAcceptance\"e\n\x20CMsgClientUCMDeletePublishedFile\x12*\n\x11\
    published_file_id\x18\x01\x20\x01(\x06R\x0fpublishedFileId\x12\x15\n\x06\
    app_id\x18\x02\x20\x01(\rR\x05appId\"G\n(CMsgClientUCMDeletePublishedFil\
    eResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\"\
    \x81\x01\n(CMsgClientUCMEnumerateUserPublishedFiles\x12\x15\n\x06app_id\
    \x18\x01\x20\x01(\rR\x05appId\x12\x1f\n\x0bstart_index\x18\x02\x20\x01(\
    \rR\nstartIndex\x12\x1d\n\nsort_order\x18\x03\x20\x01(\rR\tsortOrder\"\
    \x9f\x02\n0CMsgClientUCMEnumerateUserPublishedFilesResponse\x12\x1b\n\
    \x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\x12j\n\x0fpublished_f\
    iles\x18\x02\x20\x03(\x0b2A.CMsgClientUCMEnumerateUserPublishedFilesResp\
    onse.PublishedFileIdR\x0epublishedFiles\x12#\n\rtotal_results\x18\x03\
    \x20\x01(\rR\x0ctotalResults\x1a=\n\x0fPublishedFileId\x12*\n\x11publish\
    ed_file_id\x18\x01\x20\x01(\x06R\x0fpublishedFileId\"\xce\x01\n)CMsgClie\
    ntUCMEnumerateUserSubscribedFiles\x12\x15\n\x06app_id\x18\x01\x20\x01(\r\
    R\x05appId\x12\x1f\n\x0bstart_index\x18\x02\x20\x01(\rR\nstartIndex\x12\
    \x1e\n\tlist_type\x18\x03\x20\x01(\r:\x011R\x08listType\x12/\n\x12matchi\
    ng_file_type\x18\x04\x20\x01(\r:\x010R\x10matchingFileType\x12\x18\n\x05\
    count\x18\x05\x20\x01(\r:\x0250R\x05count\"\xd5\x02\n1CMsgClientUCMEnume\
    rateUserSubscribedFilesResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\
    \x05:\x012R\x07eresult\x12m\n\x10subscribed_files\x18\x02\x20\x03(\x0b2B\
    .CMsgClientUCMEnumerateUserSubscribedFilesResponse.PublishedFileIdR\x0fs\
    ubscribedFiles\x12#\n\rtotal_results\x18\x03\x20\x01(\rR\x0ctotalResults\
    \x1ao\n\x0fPublishedFileId\x12*\n\x11published_file_id\x18\x01\x20\x01(\
    \x06R\x0fpublishedFileId\x120\n\x12rtime32_subscribed\x18\x02\x20\x01(\
    \x07:\x010R\x11rtime32Subscribed\"\xbb\x01\n4CMsgClientUCMEnumerateUserS\
    ubscribedFilesWithUpdates\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05app\
    Id\x12\x1f\n\x0bstart_index\x18\x02\x20\x01(\rR\nstartIndex\x12\x1d\n\ns\
    tart_time\x18\x03\x20\x01(\x07R\tstartTime\x12,\n\x10desired_revision\
    \x18\x04\x20\x01(\r:\x010R\x0fdesiredRevision\"\xa0\x04\n<CMsgClientUCME\
    numerateUserSubscribedFilesWithUpdatesResponse\x12\x1b\n\x07eresult\x18\
    \x01\x20\x01(\x05:\x012R\x07eresult\x12x\n\x10subscribed_files\x18\x02\
    \x20\x03(\x0b2M.CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResp\
    onse.PublishedFileIdR\x0fsubscribedFiles\x12#\n\rtotal_results\x18\x03\
    \x20\x01(\rR\x0ctotalResults\x1a\xa3\x02\n\x0fPublishedFileId\x12*\n\x11\
    published_file_id\x18\x01\x20\x01(\x06R\x0fpublishedFileId\x120\n\x12rti\
    me32_subscribed\x18\x02\x20\x01(\x07:\x010R\x11rtime32Subscribed\x12\x14\
    \n\x05appid\x18\x03\x20\x01(\rR\x05appid\x12#\n\rfile_hcontent\x18\x04\
    \x20\x01(\x06R\x0cfileHcontent\x12\x1b\n\tfile_size\x18\x05\x20\x01(\rR\
    \x08fileSize\x120\n\x14rtime32_last_updated\x18\x06\x20\x01(\x07R\x12rti\
    me32LastUpdated\x12(\n\x10is_depot_content\x18\x07\x20\x01(\x08R\x0eisDe\
    potContent\"\x88\x02\n!CMsgClientUCMPublishedFileUpdated\x12*\n\x11publi\
    shed_file_id\x18\x01\x20\x01(\x06R\x0fpublishedFileId\x12\x15\n\x06app_i\
    d\x18\x02\x20\x01(\rR\x05appId\x12!\n\x0ctime_updated\x18\x03\x20\x01(\r\
    R\x0btimeUpdated\x12\x1a\n\x08hcontent\x18\x04\x20\x01(\x06R\x08hcontent\
    \x12\x1b\n\tfile_size\x18\x05\x20\x01(\x07R\x08fileSize\x12(\n\x10is_dep\
    ot_content\x18\x06\x20\x01(\x08R\x0eisDepotContent\x12\x1a\n\x08revision\
    \x18\x07\x20\x01(\rR\x08revision\"\x93\x01\n$CMsgClientWorkshopItemChang\
    esRequest\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12*\n\x11las\
    t_time_updated\x18\x02\x20\x01(\rR\x0flastTimeUpdated\x12(\n\x10num_item\
    s_needed\x18\x03\x20\x01(\rR\x0enumItemsNeeded\"\xca\x02\n%CMsgClientWor\
    kshopItemChangesResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012\
    R\x07eresult\x12\x1f\n\x0bupdate_time\x18\x02\x20\x01(\rR\nupdateTime\
    \x12^\n\x0eworkshop_items\x18\x05\x20\x03(\x0b27.CMsgClientWorkshopItemC\
    hangesResponse.WorkshopItemInfoR\rworkshopItems\x1a\x82\x01\n\x10Worksho\
    pItemInfo\x12*\n\x11published_file_id\x18\x01\x20\x01(\x06R\x0fpublished\
    FileId\x12!\n\x0ctime_updated\x18\x02\x20\x01(\rR\x0btimeUpdated\x12\x1f\
    \n\x0bmanifest_id\x18\x03\x20\x01(\x06R\nmanifestId\"\x9d\x02\n!CMsgClie\
    ntWorkshopItemInfoRequest\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05app\
    Id\x12*\n\x11last_time_updated\x18\x02\x20\x01(\rR\x0flastTimeUpdated\
    \x12V\n\x0eworkshop_items\x18\x03\x20\x03(\x0b2/.CMsgClientWorkshopItemI\
    nfoRequest.WorkshopItemR\rworkshopItems\x1a]\n\x0cWorkshopItem\x12*\n\
    \x11published_file_id\x18\x01\x20\x01(\x06R\x0fpublishedFileId\x12!\n\
    \x0ctime_updated\x18\x02\x20\x01(\rR\x0btimeUpdated\"\x86\x03\n\"CMsgCli\
    entWorkshopItemInfoResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\
    \x012R\x07eresult\x12\x1f\n\x0bupdate_time\x18\x02\x20\x01(\rR\nupdateTi\
    me\x12[\n\x0eworkshop_items\x18\x03\x20\x03(\x0b24.CMsgClientWorkshopIte\
    mInfoResponse.WorkshopItemInfoR\rworkshopItems\x12#\n\rprivate_items\x18\
    \x04\x20\x03(\x06R\x0cprivateItems\x1a\x9f\x01\n\x10WorkshopItemInfo\x12\
    *\n\x11published_file_id\x18\x01\x20\x01(\x06R\x0fpublishedFileId\x12!\n\
    \x0ctime_updated\x18\x02\x20\x01(\rR\x0btimeUpdated\x12\x1f\n\x0bmanifes\
    t_id\x18\x03\x20\x01(\x06R\nmanifestId\x12\x1b\n\tis_legacy\x18\x04\x20\
    \x01(\x08R\x08isLegacy\"\xd3\x01\n%CMsgClientUCMGetPublishedFilesForUser\
    \x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12(\n\x10creator_stea\
    m_id\x18\x02\x20\x01(\x06R\x0ecreatorSteamId\x12#\n\rrequired_tags\x18\
    \x03\x20\x03(\tR\x0crequiredTags\x12#\n\rexcluded_tags\x18\x04\x20\x03(\
    \tR\x0cexcludedTags\x12\x1f\n\x0bstart_index\x18\x05\x20\x01(\rR\nstartI\
    ndex\"\x99\x02\n-CMsgClientUCMGetPublishedFilesForUserResponse\x12\x1b\n\
    \x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\x12g\n\x0fpublished_f\
    iles\x18\x02\x20\x03(\x0b2>.CMsgClientUCMGetPublishedFilesForUserRespons\
    e.PublishedFileIdR\x0epublishedFiles\x12#\n\rtotal_results\x18\x03\x20\
    \x01(\rR\x0ctotalResults\x1a=\n\x0fPublishedFileId\x12*\n\x11published_f\
    ile_id\x18\x01\x20\x01(\x06R\x0fpublishedFileId\"\x84\x01\n'CMsgClientUC\
    MSetUserPublishedFileAction\x12*\n\x11published_file_id\x18\x01\x20\x01(\
    \x06R\x0fpublishedFileId\x12\x15\n\x06app_id\x18\x02\x20\x01(\rR\x05appI\
    d\x12\x16\n\x06action\x18\x03\x20\x01(\x05R\x06action\"N\n/CMsgClientUCM\
    SetUserPublishedFileActionResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\
    \x05:\x012R\x07eresult\"\x82\x01\n0CMsgClientUCMEnumeratePublishedFilesB\
    yUserAction\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12\x1f\n\
    \x0bstart_index\x18\x02\x20\x01(\rR\nstartIndex\x12\x16\n\x06action\x18\
    \x03\x20\x01(\x05R\x06action\"\xdc\x02\n8CMsgClientUCMEnumeratePublished\
    FilesByUserActionResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x01\
    2R\x07eresult\x12r\n\x0fpublished_files\x18\x02\x20\x03(\x0b2I.CMsgClien\
    tUCMEnumeratePublishedFilesByUserActionResponse.PublishedFileIdR\x0epubl\
    ishedFiles\x12#\n\rtotal_results\x18\x03\x20\x01(\rR\x0ctotalResults\x1a\
    j\n\x0fPublishedFileId\x12*\n\x11published_file_id\x18\x01\x20\x01(\x06R\
    \x0fpublishedFileId\x12+\n\x10rtime_time_stamp\x18\x02\x20\x01(\x07:\x01\
    0R\x0ertimeTimeStamp\"\x1e\n\x1cCMsgClientScreenshotsChanged\"\xa5\x01\n\
    \x1cCMsgClientUpdateUserGameInfo\x12!\n\x0csteamid_idgs\x18\x01\x20\x01(\
    \x06R\x0bsteamidIdgs\x12\x16\n\x06gameid\x18\x02\x20\x01(\x06R\x06gameid\
    \x12\x17\n\x07game_ip\x18\x03\x20\x01(\rR\x06gameIp\x12\x1b\n\tgame_port\
    \x18\x04\x20\x01(\rR\x08gamePort\x12\x14\n\x05token\x18\x05\x20\x01(\x0c\
    R\x05token\"u\n\x1cCMsgClientRichPresenceUpload\x12(\n\x10rich_presence_\
    kv\x18\x01\x20\x01(\x0cR\x0erichPresenceKv\x12+\n\x11steamid_broadcast\
    \x18\x02\x20\x03(\x06R\x10steamidBroadcast\"H\n\x1dCMsgClientRichPresenc\
    eRequest\x12'\n\x0fsteamid_request\x18\x01\x20\x03(\x06R\x0esteamidReque\
    st\"\xc8\x01\n\x1aCMsgClientRichPresenceInfo\x12M\n\rrich_presence\x18\
    \x01\x20\x03(\x0b2(.CMsgClientRichPresenceInfo.RichPresenceR\x0crichPres\
    ence\x1a[\n\x0cRichPresence\x12!\n\x0csteamid_user\x18\x01\x20\x01(\x06R\
    \x0bsteamidUser\x12(\n\x10rich_presence_kv\x18\x02\x20\x01(\x0cR\x0erich\
    PresenceKv\"5\n\x1cCMsgClientCheckFileSignature\x12\x15\n\x06app_id\x18\
    \x01\x20\x01(\rR\x05appId\"\xf6\x02\n$CMsgClientCheckFileSignatureRespon\
    se\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12\x10\n\x03pid\x18\
    \x02\x20\x01(\rR\x03pid\x12\x18\n\x07eresult\x18\x03\x20\x01(\rR\x07eres\
    ult\x12\x1a\n\x08filename\x18\x04\x20\x01(\tR\x08filename\x12*\n\x10esig\
    natureresult\x18\x05\x20\x01(\rR\x10esignatureresult\x12\x19\n\x08sha_fi\
    le\x18\x06\x20\x01(\x0cR\x07shaFile\x12(\n\x0fsignatureheader\x18\x07\
    \x20\x01(\x0cR\x0fsignatureheader\x12\x1a\n\x08filesize\x18\x08\x20\x01(\
    \rR\x08filesize\x12\"\n\x0cgetlasterror\x18\t\x20\x01(\rR\x0cgetlasterro\
    r\x12>\n\x1aevalvesignaturecheckdetail\x18\n\x20\x01(\rR\x1aevalvesignat\
    urecheckdetail\"m\n\x19CMsgClientReadMachineAuth\x12\x1a\n\x08filename\
    \x18\x01\x20\x01(\tR\x08filename\x12\x16\n\x06offset\x18\x02\x20\x01(\rR\
    \x06offset\x12\x1c\n\tcubtoread\x18\x03\x20\x01(\rR\tcubtoread\"\xae\x02\
    \n!CMsgClientReadMachineAuthResponse\x12\x1a\n\x08filename\x18\x01\x20\
    \x01(\tR\x08filename\x12\x18\n\x07eresult\x18\x02\x20\x01(\rR\x07eresult\
    \x12\x1a\n\x08filesize\x18\x03\x20\x01(\rR\x08filesize\x12\x19\n\x08sha_\
    file\x18\x04\x20\x01(\x0cR\x07shaFile\x12\"\n\x0cgetlasterror\x18\x05\
    \x20\x01(\rR\x0cgetlasterror\x12\x16\n\x06offset\x18\x06\x20\x01(\rR\x06\
    offset\x12\x18\n\x07cubread\x18\x07\x20\x01(\rR\x07cubread\x12\x1d\n\nby\
    tes_read\x18\x08\x20\x01(\x0cR\tbytesRead\x12'\n\x0ffilename_sentry\x18\
    \t\x20\x01(\tR\x0efilenameSentry\"\x99\x02\n\x1bCMsgClientUpdateMachineA\
    uth\x12\x1a\n\x08filename\x18\x01\x20\x01(\tR\x08filename\x12\x16\n\x06o\
    ffset\x18\x02\x20\x01(\rR\x06offset\x12\x1e\n\ncubtowrite\x18\x03\x20\
    \x01(\rR\ncubtowrite\x12\x14\n\x05bytes\x18\x04\x20\x01(\x0cR\x05bytes\
    \x12\x19\n\x08otp_type\x18\x05\x20\x01(\rR\x07otpType\x12%\n\x0eotp_iden\
    tifier\x18\x06\x20\x01(\tR\rotpIdentifier\x12)\n\x10otp_sharedsecret\x18\
    \x07\x20\x01(\x0cR\x0fotpSharedsecret\x12#\n\rotp_timedrift\x18\x08\x20\
    \x01(\rR\x0cotpTimedrift\"\xc9\x02\n#CMsgClientUpdateMachineAuthResponse\
    \x12\x1a\n\x08filename\x18\x01\x20\x01(\tR\x08filename\x12\x18\n\x07eres\
    ult\x18\x02\x20\x01(\rR\x07eresult\x12\x1a\n\x08filesize\x18\x03\x20\x01\
    (\rR\x08filesize\x12\x19\n\x08sha_file\x18\x04\x20\x01(\x0cR\x07shaFile\
    \x12\"\n\x0cgetlasterror\x18\x05\x20\x01(\rR\x0cgetlasterror\x12\x16\n\
    \x06offset\x18\x06\x20\x01(\rR\x06offset\x12\x1a\n\x08cubwrote\x18\x07\
    \x20\x01(\rR\x08cubwrote\x12\x19\n\x08otp_type\x18\x08\x20\x01(\x05R\x07\
    otpType\x12\x1b\n\totp_value\x18\t\x20\x01(\rR\x08otpValue\x12%\n\x0eotp\
    _identifier\x18\n\x20\x01(\tR\rotpIdentifier\"\xc1\x03\n\x1cCMsgClientRe\
    questMachineAuth\x12\x1a\n\x08filename\x18\x01\x20\x01(\tR\x08filename\
    \x12-\n\x12eresult_sentryfile\x18\x02\x20\x01(\rR\x11eresultSentryfile\
    \x12\x1a\n\x08filesize\x18\x03\x20\x01(\rR\x08filesize\x12%\n\x0esha_sen\
    tryfile\x18\x04\x20\x01(\x0cR\rshaSentryfile\x12.\n\x13lock_account_acti\
    on\x18\x06\x20\x01(\x05R\x11lockAccountAction\x12\x19\n\x08otp_type\x18\
    \x07\x20\x01(\rR\x07otpType\x12%\n\x0eotp_identifier\x18\x08\x20\x01(\tR\
    \rotpIdentifier\x12)\n\x10otp_sharedsecret\x18\t\x20\x01(\x0cR\x0fotpSha\
    redsecret\x12\x1b\n\totp_value\x18\n\x20\x01(\rR\x08otpValue\x12!\n\x0cm\
    achine_name\x18\x0b\x20\x01(\tR\x0bmachineName\x126\n\x17machine_name_us\
    erchosen\x18\x0c\x20\x01(\tR\x15machineNameUserchosen\"@\n$CMsgClientReq\
    uestMachineAuthResponse\x12\x18\n\x07eresult\x18\x01\x20\x01(\rR\x07eres\
    ult\")\n\x15CMsgClientRegisterKey\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\"\xa5\x01\n\x1aCMsgClientPurchaseResponse\x12\x1b\n\x07eresult\
    \x18\x01\x20\x01(\x05:\x012R\x07eresult\x126\n\x17purchase_result_detail\
    s\x18\x02\x20\x01(\x05R\x15purchaseResultDetails\x122\n\x15purchase_rece\
    ipt_info\x18\x03\x20\x01(\x0cR\x13purchaseReceiptInfo\"\xb6\x02\n\x1cCMs\
    gClientActivateOEMLicense\x12+\n\x11bios_manufacturer\x18\x01\x20\x01(\t\
    R\x10biosManufacturer\x12+\n\x11bios_serialnumber\x18\x02\x20\x01(\tR\
    \x10biosSerialnumber\x12!\n\x0clicense_file\x18\x03\x20\x01(\x0cR\x0blic\
    enseFile\x125\n\x16mainboard_manufacturer\x18\x04\x20\x01(\tR\x15mainboa\
    rdManufacturer\x12+\n\x11mainboard_product\x18\x05\x20\x01(\tR\x10mainbo\
    ardProduct\x125\n\x16mainboard_serialnumber\x18\x06\x20\x01(\tR\x15mainb\
    oardSerialnumber\"J\n\x1cCMsgClientRegisterOEMMachine\x12*\n\x11oem_regi\
    ster_file\x18\x01\x20\x01(\x0cR\x0foemRegisterFile\"@\n$CMsgClientRegist\
    erOEMMachineResponse\x12\x18\n\x07eresult\x18\x01\x20\x01(\rR\x07eresult\
    \"c\n\x1fCMsgClientPurchaseWithMachineID\x12\x1d\n\npackage_id\x18\x01\
    \x20\x01(\rR\tpackageId\x12!\n\x0cmachine_info\x18\x02\x20\x01(\x0cR\x0b\
    machineInfo\"\x90\x01\n\x20CMsgTrading_InitiateTradeRequest\x12(\n\x10tr\
    ade_request_id\x18\x01\x20\x01(\rR\x0etradeRequestId\x12#\n\rother_steam\
    id\x18\x02\x20\x01(\x04R\x0cotherSteamid\x12\x1d\n\nother_name\x18\x03\
    \x20\x01(\tR\totherName\"\xa3\x04\n!CMsgTrading_InitiateTradeResponse\
    \x12\x1a\n\x08response\x18\x01\x20\x01(\rR\x08response\x12(\n\x10trade_r\
    equest_id\x18\x02\x20\x01(\rR\x0etradeRequestId\x12#\n\rother_steamid\
    \x18\x03\x20\x01(\x04R\x0cotherSteamid\x128\n\x18steamguard_required_day\
    s\x18\x04\x20\x01(\rR\x16steamguardRequiredDays\x127\n\x18new_device_coo\
    ldown_days\x18\x05\x20\x01(\rR\x15newDeviceCooldownDays\x12P\n%default_p\
    assword_reset_probation_days\x18\x06\x20\x01(\rR!defaultPasswordResetPro\
    bationDays\x12A\n\x1dpassword_reset_probation_days\x18\x07\x20\x01(\rR\
    \x1apasswordResetProbationDays\x12L\n#default_email_change_probation_day\
    s\x18\x08\x20\x01(\rR\x1fdefaultEmailChangeProbationDays\x12=\n\x1bemail\
    _change_probation_days\x18\t\x20\x01(\rR\x18emailChangeProbationDays\"E\
    \n\x1eCMsgTrading_CancelTradeRequest\x12#\n\rother_steamid\x18\x01\x20\
    \x01(\x04R\x0cotherSteamid\"?\n\x18CMsgTrading_StartSession\x12#\n\rothe\
    r_steamid\x18\x01\x20\x01(\x04R\x0cotherSteamid\"j\n\x19CMsgClientGetCDN\
    AuthToken\x12\x19\n\x08depot_id\x18\x01\x20\x01(\rR\x07depotId\x12\x1b\n\
    \thost_name\x18\x02\x20\x01(\tR\x08hostName\x12\x15\n\x06app_id\x18\x03\
    \x20\x01(\rR\x05appId\"S\n\x1fCMsgClientGetDepotDecryptionKey\x12\x19\n\
    \x08depot_id\x18\x01\x20\x01(\rR\x07depotId\x12\x15\n\x06app_id\x18\x02\
    \x20\x01(\rR\x05appId\"\x93\x01\n'CMsgClientGetDepotDecryptionKeyRespons\
    e\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\x12\x19\n\
    \x08depot_id\x18\x02\x20\x01(\rR\x07depotId\x120\n\x14depot_encryption_k\
    ey\x18\x03\x20\x01(\x0cR\x12depotEncryptionKey\"w\n\x1eCMsgClientCheckAp\
    pBetaPassword\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12\"\n\
    \x0cbetapassword\x18\x02\x20\x01(\tR\x0cbetapassword\x12\x1a\n\x08langua\
    ge\x18\x03\x20\x01(\x05R\x08language\"\x9b\x02\n&CMsgClientCheckAppBetaP\
    asswordResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eres\
    ult\x12Z\n\rbetapasswords\x18\x04\x20\x03(\x0b24.CMsgClientCheckAppBetaP\
    asswordResponse.BetaPasswordR\rbetapasswords\x1ax\n\x0cBetaPassword\x12\
    \x1a\n\x08betaname\x18\x01\x20\x01(\tR\x08betaname\x12\"\n\x0cbetapasswo\
    rd\x18\x02\x20\x01(\tR\x0cbetapassword\x12(\n\x0fbetadescription\x18\x03\
    \x20\x01(\tR\x0fbetadescription\"\x8b\x07\n\x1cCMsgClientUpdateAppJobRep\
    ort\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12\x1b\n\tdepot_id\
    s\x18\x02\x20\x03(\rR\x08depotIds\x12\x1b\n\tapp_state\x18\x03\x20\x01(\
    \rR\x08appState\x12\"\n\rjob_app_error\x18\x04\x20\x01(\rR\x0bjobAppErro\
    r\x12#\n\rerror_details\x18\x05\x20\x01(\tR\x0cerrorDetails\x12!\n\x0cjo\
    b_duration\x18\x06\x20\x01(\rR\x0bjobDuration\x126\n\x17files_validation\
    _failed\x18\x07\x20\x01(\rR\x15filesValidationFailed\x120\n\x14job_bytes\
    _downloaded\x18\x08\x20\x01(\x04R\x12jobBytesDownloaded\x12(\n\x10job_by\
    tes_staged\x18\t\x20\x01(\x04R\x0ejobBytesStaged\x12%\n\x0ebytes_comitte\
    d\x18\n\x20\x01(\x04R\rbytesComitted\x12&\n\x0fstart_app_state\x18\x0b\
    \x20\x01(\rR\rstartAppState\x12(\n\x10stats_machine_id\x18\x0c\x20\x01(\
    \x06R\x0estatsMachineId\x12\x1f\n\x0bbranch_name\x18\r\x20\x01(\tR\nbran\
    chName\x124\n\x16total_bytes_downloaded\x18\x0e\x20\x01(\x04R\x14totalBy\
    tesDownloaded\x12,\n\x12total_bytes_staged\x18\x0f\x20\x01(\x04R\x10tota\
    lBytesStaged\x120\n\x14total_bytes_restored\x18\x10\x20\x01(\x04R\x12tot\
    alBytesRestored\x12\x1f\n\x0bis_borrowed\x18\x11\x20\x01(\x08R\nisBorrow\
    ed\x12&\n\x0fis_free_weekend\x18\x12\x20\x01(\x08R\risFreeWeekend\x12,\n\
    \x12total_bytes_legacy\x18\x13\x20\x01(\x04R\x10totalBytesLegacy\x12.\n\
    \x13total_bytes_patched\x18\x14\x20\x01(\x04R\x11totalBytesPatched\x12*\
    \n\x11total_bytes_saved\x18\x15\x20\x01(\x04R\x0ftotalBytesSaved\x12\x17\
    \n\x07cell_id\x18\x16\x20\x01(\rR\x06cellId\"\xb4\x02\n\x1eCMsgClientDPC\
    ontentStatsReport\x12(\n\x10stats_machine_id\x18\x01\x20\x01(\x06R\x0est\
    atsMachineId\x12!\n\x0ccountry_code\x18\x02\x20\x01(\tR\x0bcountryCode\
    \x12\x17\n\x07os_type\x18\x03\x20\x01(\x05R\x06osType\x12\x1a\n\x08langu\
    age\x18\x04\x20\x01(\x05R\x08language\x12.\n\x13num_install_folders\x18\
    \x05\x20\x01(\rR\x11numInstallFolders\x12.\n\x13num_installed_games\x18\
    \x06\x20\x01(\rR\x11numInstalledGames\x120\n\x14size_installed_games\x18\
    \x07\x20\x01(\x04R\x12sizeInstalledGames\"\x7f\n!CMsgClientGetCDNAuthTok\
    enResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\r:\x012R\x07eresult\x12\
    \x14\n\x05token\x18\x02\x20\x01(\tR\x05token\x12'\n\x0fexpiration_time\
    \x18\x03\x20\x01(\rR\x0eexpirationTime\"\xb0\x03\n\x1aCMsgDownloadRateSt\
    atistics\x12\x17\n\x07cell_id\x18\x01\x20\x01(\rR\x06cellId\x12;\n\x05st\
    ats\x18\x02\x20\x03(\x0b2%.CMsgDownloadRateStatistics.StatsInfoR\x05stat\
    s\x12'\n\x0fthrottling_kbps\x18\x03\x20\x01(\rR\x0ethrottlingKbps\x12\
    \x1f\n\x0bsteam_realm\x18\x04\x20\x01(\rR\nsteamRealm\x1a\xf1\x01\n\tSta\
    tsInfo\x12\x1f\n\x0bsource_type\x18\x01\x20\x01(\rR\nsourceType\x12\x1b\
    \n\tsource_id\x18\x02\x20\x01(\rR\x08sourceId\x12\x18\n\x07seconds\x18\
    \x03\x20\x01(\rR\x07seconds\x12\x14\n\x05bytes\x18\x04\x20\x01(\x04R\x05\
    bytes\x12\x1b\n\thost_name\x18\x05\x20\x01(\tR\x08hostName\x12\"\n\x0cmi\
    croseconds\x18\x06\x20\x01(\x04R\x0cmicroseconds\x12\x1b\n\tused_ipv6\
    \x18\x07\x20\x01(\x08R\x08usedIpv6\x12\x18\n\x07proxied\x18\x08\x20\x01(\
    \x08R\x07proxied\"`\n\x1cCMsgClientRequestAccountData\x12(\n\x10account_\
    or_email\x18\x01\x20\x01(\tR\x0eaccountOrEmail\x12\x16\n\x06action\x18\
    \x02\x20\x01(\rR\x06action\"\xc8\x02\n$CMsgClientRequestAccountDataRespo\
    nse\x12\x16\n\x06action\x18\x01\x20\x01(\rR\x06action\x12\x18\n\x07eresu\
    lt\x18\x02\x20\x01(\rR\x07eresult\x12!\n\x0caccount_name\x18\x03\x20\x01\
    (\tR\x0baccountName\x12\x1d\n\nct_matches\x18\x04\x20\x01(\rR\tctMatches\
    \x128\n\x18account_name_suggestion1\x18\x05\x20\x01(\tR\x16accountNameSu\
    ggestion1\x128\n\x18account_name_suggestion2\x18\x06\x20\x01(\tR\x16acco\
    untNameSuggestion2\x128\n\x18account_name_suggestion3\x18\x07\x20\x01(\t\
    R\x16accountNameSuggestion3\"\xe6\x01\n\x1bCMsgClientUGSGetGlobalStats\
    \x12\x16\n\x06gameid\x18\x01\x20\x01(\x04R\x06gameid\x124\n\x16history_d\
    ays_requested\x18\x02\x20\x01(\rR\x14historyDaysRequested\x12.\n\x13time\
    _last_requested\x18\x03\x20\x01(\x07R\x11timeLastRequested\x12(\n\x10fir\
    st_day_cached\x18\x04\x20\x01(\rR\x0efirstDayCached\x12\x1f\n\x0bdays_ca\
    ched\x18\x05\x20\x01(\rR\ndaysCached\"\xd8\x02\n#CMsgClientUGSGetGlobalS\
    tatsResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\
    \x12\x1c\n\ttimestamp\x18\x02\x20\x01(\x07R\ttimestamp\x12\x1f\n\x0bday_\
    current\x18\x03\x20\x01(\x05R\ndayCurrent\x12<\n\x04days\x18\x04\x20\x03\
    (\x0b2(.CMsgClientUGSGetGlobalStatsResponse.DayR\x04days\x1a\x96\x01\n\
    \x03Day\x12\x15\n\x06day_id\x18\x01\x20\x01(\rR\x05dayId\x12C\n\x05stats\
    \x18\x02\x20\x03(\x0b2-.CMsgClientUGSGetGlobalStatsResponse.Day.StatR\
    \x05stats\x1a3\n\x04Stat\x12\x17\n\x07stat_id\x18\x01\x20\x01(\x05R\x06s\
    tatId\x12\x12\n\x04data\x18\x02\x20\x01(\x03R\x04data\"\xad\x06\n\x12CMs\
    gGameServerData\x12\x1a\n\x08revision\x18\x18\x20\x01(\rR\x08revision\
    \x12\x1e\n\x0bsteam_id_gs\x18\x01\x20\x01(\x06R\tsteamIdGs\x12\x1d\n\nqu\
    ery_port\x18\x03\x20\x01(\rR\tqueryPort\x12\x1b\n\tgame_port\x18\x04\x20\
    \x01(\rR\x08gamePort\x12%\n\x0espectator_port\x18\x05\x20\x01(\rR\rspect\
    atorPort\x12\x1f\n\x0bserver_name\x18\x16\x20\x01(\tR\nserverName\x12)\n\
    \x10game_description\x18\x1d\x20\x01(\tR\x0fgameDescription\x122\n\x15sp\
    ectator_server_name\x18\x1b\x20\x01(\tR\x13spectatorServerName\x12\x17\n\
    \x07fake_ip\x18\x1c\x20\x01(\x07R\x06fakeIp\x12\x1b\n\tsdr_login\x18\x1a\
    \x20\x01(\x0cR\x08sdrLogin\x12\x15\n\x06app_id\x18\x06\x20\x01(\rR\x05ap\
    pId\x12\x18\n\x07gamedir\x18\x07\x20\x01(\tR\x07gamedir\x12\x18\n\x07ver\
    sion\x18\x08\x20\x01(\tR\x07version\x12\x18\n\x07product\x18\t\x20\x01(\
    \tR\x07product\x12\x16\n\x06region\x18\n\x20\x01(\tR\x06region\x124\n\
    \x07players\x18\x0b\x20\x03(\x0b2\x1a.CMsgGameServerData.PlayerR\x07play\
    ers\x12\x1f\n\x0bmax_players\x18\x0c\x20\x01(\rR\nmaxPlayers\x12\x1b\n\t\
    bot_count\x18\r\x20\x01(\rR\x08botCount\x12\x1a\n\x08password\x18\x0e\
    \x20\x01(\x08R\x08password\x12\x16\n\x06secure\x18\x0f\x20\x01(\x08R\x06\
    secure\x12\x1c\n\tdedicated\x18\x10\x20\x01(\x08R\tdedicated\x12\x0e\n\
    \x02os\x18\x11\x20\x01(\tR\x02os\x12\x1b\n\tgame_data\x18\x12\x20\x01(\t\
    R\x08gameData\x12\x1b\n\tgame_type\x18\x14\x20\x01(\tR\x08gameType\x12\
    \x10\n\x03map\x18\x15\x20\x01(\tR\x03map\x1a#\n\x06Player\x12\x19\n\x08s\
    team_id\x18\x01\x20\x01(\x06R\x07steamId\"o\n\x14CMsgGameServerRemove\
    \x12+\n\x12legacy_steam_id_gs\x18\x01\x20\x01(\x06R\x0flegacySteamIdGs\
    \x12*\n\x11legacy_query_port\x18\x03\x20\x01(\rR\x0flegacyQueryPort\"\
    \xbc\x01\n\x18CMsgClientGMSServerQuery\x12\x15\n\x06app_id\x18\x01\x20\
    \x01(\rR\x05appId\x12&\n\x0fgeo_location_ip\x18\x02\x20\x01(\rR\rgeoLoca\
    tionIp\x12\x1f\n\x0bregion_code\x18\x03\x20\x01(\rR\nregionCode\x12\x1f\
    \n\x0bfilter_text\x18\x04\x20\x01(\tR\nfilterText\x12\x1f\n\x0bmax_serve\
    rs\x18\x05\x20\x01(\rR\nmaxServers\"\xa8\x02\n\x20CMsgGMSClientServerQue\
    ryResponse\x12B\n\x07servers\x18\x01\x20\x03(\x0b2(.CMsgGMSClientServerQ\
    ueryResponse.ServerR\x07servers\x12\x14\n\x05error\x18\x02\x20\x01(\tR\
    \x05error\x1a\xa9\x01\n\x06Server\x120\n\x14deprecated_server_ip\x18\x01\
    \x20\x01(\rR\x12deprecatedServerIp\x12\x1d\n\nquery_port\x18\x02\x20\x01\
    (\rR\tqueryPort\x12!\n\x0cauth_players\x18\x03\x20\x01(\rR\x0bauthPlayer\
    s\x12+\n\tserver_ip\x18\x04\x20\x01(\x0b2\x0e.CMsgIPAddressR\x08serverIp\
    \"k\n\x17CMsgGameServerOutOfDate\x12\x1e\n\x0bsteam_id_gs\x18\x01\x20\
    \x01(\x06R\tsteamIdGs\x12\x16\n\x06reject\x18\x02\x20\x01(\x08R\x06rejec\
    t\x12\x18\n\x07message\x18\x03\x20\x01(\tR\x07message\"?\n\x19CMsgClient\
    RedeemGuestPass\x12\"\n\rguest_pass_id\x18\x01\x20\x01(\x06R\x0bguestPas\
    sId\"\x85\x01\n!CMsgClientRedeemGuestPassResponse\x12\x1b\n\x07eresult\
    \x18\x01\x20\x01(\r:\x012R\x07eresult\x12\x1d\n\npackage_id\x18\x02\x20\
    \x01(\rR\tpackageId\x12$\n\x0emust_own_appid\x18\x03\x20\x01(\rR\x0cmust\
    OwnAppid\"F\n\x1fCMsgClientGetClanActivityCounts\x12#\n\rsteamid_clans\
    \x18\x01\x20\x03(\x04R\x0csteamidClans\"F\n'CMsgClientGetClanActivityCou\
    ntsResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\r:\x012R\x07eresult\"\
    \xaf\x01\n\x19CMsgClientOGSReportString\x12\x20\n\x0baccumulated\x18\x01\
    \x20\x01(\x08R\x0baccumulated\x12\x1c\n\tsessionid\x18\x02\x20\x01(\x04R\
    \tsessionid\x12\x1a\n\x08severity\x18\x03\x20\x01(\x05R\x08severity\x12\
    \x1c\n\tformatter\x18\x04\x20\x01(\tR\tformatter\x12\x18\n\x07varargs\
    \x18\x05\x20\x01(\x0cR\x07varargs\"p\n\x16CMsgClientOGSReportBug\x12\x1c\
    \n\tsessionid\x18\x01\x20\x01(\x04R\tsessionid\x12\x18\n\x07bugtext\x18\
    \x02\x20\x01(\tR\x07bugtext\x12\x1e\n\nscreenshot\x18\x03\x20\x01(\x0cR\
    \nscreenshot\"=\n\x17CMsgGSAssociateWithClan\x12\"\n\rsteam_id_clan\x18\
    \x01\x20\x01(\x06R\x0bsteamIdClan\"b\n\x1fCMsgGSAssociateWithClanRespons\
    e\x12\"\n\rsteam_id_clan\x18\x01\x20\x01(\x06R\x0bsteamIdClan\x12\x1b\n\
    \x07eresult\x18\x02\x20\x01(\r:\x012R\x07eresult\"S\n#CMsgGSComputeNewPl\
    ayerCompatibility\x12,\n\x12steam_id_candidate\x18\x01\x20\x01(\x06R\x10\
    steamIdCandidate\"\xb0\x02\n+CMsgGSComputeNewPlayerCompatibilityResponse\
    \x12,\n\x12steam_id_candidate\x18\x01\x20\x01(\x06R\x10steamIdCandidate\
    \x12\x1b\n\x07eresult\x18\x02\x20\x01(\r:\x012R\x07eresult\x12$\n\x0eis_\
    clan_member\x18\x03\x20\x01(\x08R\x0cisClanMember\x12'\n\x10ct_dont_like\
    _you\x18\x04\x20\x01(\x05R\rctDontLikeYou\x12'\n\x10ct_you_dont_like\x18\
    \x05\x20\x01(\x05R\rctYouDontLike\x12>\n\x1cct_clanmembers_dont_like_you\
    \x18\x06\x20\x01(\x05R\x18ctClanmembersDontLikeYou\"\x14\n\x12CMsgClient\
    SentLogs\"\x9a\x01\n\x0cCMsgGCClient\x12\x14\n\x05appid\x18\x01\x20\x01(\
    \rR\x05appid\x12\x18\n\x07msgtype\x18\x02\x20\x01(\rR\x07msgtype\x12\x18\
    \n\x07payload\x18\x03\x20\x01(\x0cR\x07payload\x12\x18\n\x07steamid\x18\
    \x04\x20\x01(\x06R\x07steamid\x12\x16\n\x06gcname\x18\x05\x20\x01(\tR\
    \x06gcname\x12\x0e\n\x02ip\x18\x06\x20\x01(\rR\x02ip\"6\n\x1cCMsgClientR\
    equestFreeLicense\x12\x16\n\x06appids\x18\x02\x20\x03(\rR\x06appids\"\
    \x99\x01\n$CMsgClientRequestFreeLicenseResponse\x12\x1b\n\x07eresult\x18\
    \x01\x20\x01(\r:\x012R\x07eresult\x12-\n\x12granted_packageids\x18\x02\
    \x20\x03(\rR\x11grantedPackageids\x12%\n\x0egranted_appids\x18\x03\x20\
    \x03(\rR\rgrantedAppids\"\xb8\x02\n#CMsgDRMDownloadRequestWithCrashData\
    \x12%\n\x0edownload_flags\x18\x01\x20\x01(\rR\rdownloadFlags\x120\n\x14d\
    ownload_types_known\x18\x02\x20\x01(\rR\x12downloadTypesKnown\x12\x19\n\
    \x08guid_drm\x18\x03\x20\x01(\x0cR\x07guidDrm\x12\x1d\n\nguid_split\x18\
    \x04\x20\x01(\x0cR\tguidSplit\x12\x1d\n\nguid_merge\x18\x05\x20\x01(\x0c\
    R\tguidMerge\x12\x1f\n\x0bmodule_name\x18\x06\x20\x01(\tR\nmoduleName\
    \x12\x1f\n\x0bmodule_path\x18\x07\x20\x01(\tR\nmodulePath\x12\x1d\n\ncra\
    sh_data\x18\x08\x20\x01(\x0cR\tcrashData\"\xcd\x02\n\x17CMsgDRMDownloadR\
    esponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\r:\x012R\x07eresult\x12\
    \x15\n\x06app_id\x18\x02\x20\x01(\rR\x05appId\x12,\n\x12blob_download_ty\
    pe\x18\x03\x20\x01(\rR\x10blobDownloadType\x12\x1d\n\nmerge_guid\x18\x04\
    \x20\x01(\x0cR\tmergeGuid\x12/\n\x14download_file_dfs_ip\x18\x05\x20\x01\
    (\rR\x11downloadFileDfsIp\x123\n\x16download_file_dfs_port\x18\x06\x20\
    \x01(\rR\x13downloadFileDfsPort\x12*\n\x11download_file_url\x18\x07\x20\
    \x01(\tR\x0fdownloadFileUrl\x12\x1f\n\x0bmodule_path\x18\x08\x20\x01(\tR\
    \nmodulePath\"\xca\x02\n\x12CMsgDRMFinalResult\x12\x1b\n\x07eResult\x18\
    \x01\x20\x01(\r:\x012R\x07eResult\x12\x15\n\x06app_id\x18\x02\x20\x01(\r\
    R\x05appId\x12,\n\x12blob_download_type\x18\x03\x20\x01(\rR\x10blobDownl\
    oadType\x12!\n\x0cerror_detail\x18\x04\x20\x01(\rR\x0berrorDetail\x12\
    \x1d\n\nmerge_guid\x18\x05\x20\x01(\x0cR\tmergeGuid\x12/\n\x14download_f\
    ile_dfs_ip\x18\x06\x20\x01(\rR\x11downloadFileDfsIp\x123\n\x16download_f\
    ile_dfs_port\x18\x07\x20\x01(\rR\x13downloadFileDfsPort\x12*\n\x11downlo\
    ad_file_url\x18\x08\x20\x01(\tR\x0fdownloadFileUrl\"=\n\x1eCMsgClientDPC\
    heckSpecialSurvey\x12\x1b\n\tsurvey_id\x18\x01\x20\x01(\rR\x08surveyId\"\
    \xcf\x01\n&CMsgClientDPCheckSpecialSurveyResponse\x12\x1b\n\x07eResult\
    \x18\x01\x20\x01(\r:\x012R\x07eResult\x12\x14\n\x05state\x18\x02\x20\x01\
    (\rR\x05state\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x1d\n\nc\
    ustom_url\x18\x04\x20\x01(\tR\tcustomUrl\x12)\n\x10include_software\x18\
    \x05\x20\x01(\x08R\x0fincludeSoftware\x12\x14\n\x05token\x18\x06\x20\x01\
    (\x0cR\x05token\"X\n%CMsgClientDPSendSpecialSurveyResponse\x12\x1b\n\tsu\
    rvey_id\x18\x01\x20\x01(\rR\x08surveyId\x12\x12\n\x04data\x18\x02\x20\
    \x01(\x0cR\x04data\"_\n*CMsgClientDPSendSpecialSurveyResponseReply\x12\
    \x1b\n\x07eResult\x18\x01\x20\x01(\r:\x012R\x07eResult\x12\x14\n\x05toke\
    n\x18\x02\x20\x01(\x0cR\x05token\"s\n'CMsgClientRequestForgottenPassword\
    Email\x12!\n\x0caccount_name\x18\x01\x20\x01(\tR\x0baccountName\x12%\n\
    \x0epassword_tried\x18\x02\x20\x01(\tR\rpasswordTried\"{\n/CMsgClientReq\
    uestForgottenPasswordEmailResponse\x12\x18\n\x07eResult\x18\x01\x20\x01(\
    \rR\x07eResult\x12.\n\x13use_secret_question\x18\x02\x20\x01(\x08R\x11us\
    eSecretQuestion\"\xd2\x02\n\x1bCMsgClientItemAnnouncements\x12&\n\x0fcou\
    nt_new_items\x18\x01\x20\x01(\rR\rcountNewItems\x12J\n\x0cunseen_items\
    \x18\x02\x20\x03(\x0b2'.CMsgClientItemAnnouncements.UnseenItemR\x0bunsee\
    nItems\x1a\xbe\x01\n\nUnseenItem\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\
    \x05appid\x12\x1d\n\ncontext_id\x18\x02\x20\x01(\x04R\tcontextId\x12\x19\
    \n\x08asset_id\x18\x03\x20\x01(\x04R\x07assetId\x12\x16\n\x06amount\x18\
    \x04\x20\x01(\x04R\x06amount\x12%\n\x0ertime32_gained\x18\x05\x20\x01(\
    \x07R\rrtime32Gained\x12!\n\x0csource_appid\x18\x06\x20\x01(\rR\x0bsourc\
    eAppid\"$\n\"CMsgClientRequestItemAnnouncements\"\xca\x01\n\x1bCMsgClien\
    tUserNotifications\x12O\n\rnotifications\x18\x01\x20\x03(\x0b2).CMsgClie\
    ntUserNotifications.NotificationR\rnotifications\x1aZ\n\x0cNotification\
    \x124\n\x16user_notification_type\x18\x01\x20\x01(\rR\x14userNotificatio\
    nType\x12\x14\n\x05count\x18\x02\x20\x01(\rR\x05count\"\xd0\x01\n\x1eCMs\
    gClientCommentNotifications\x12,\n\x12count_new_comments\x18\x01\x20\x01\
    (\rR\x10countNewComments\x127\n\x18count_new_comments_owner\x18\x02\x20\
    \x01(\rR\x15countNewCommentsOwner\x12G\n\x20count_new_comments_subscript\
    ions\x18\x03\x20\x01(\rR\x1dcountNewCommentsSubscriptions\"'\n%CMsgClien\
    tRequestCommentNotifications\"\x94\x01\n$CMsgClientOfflineMessageNotific\
    ation\x12)\n\x10offline_messages\x18\x01\x20\x01(\rR\x0fofflineMessages\
    \x12A\n\x1dfriends_with_offline_messages\x18\x02\x20\x03(\rR\x1afriendsW\
    ithOfflineMessages\"&\n$CMsgClientRequestOfflineMessageCount\"A\n%CMsgCl\
    ientChatGetFriendMessageHistory\x12\x18\n\x07steamid\x18\x01\x20\x01(\
    \x06R\x07steamid\"\xbc\x02\n-CMsgClientChatGetFriendMessageHistoryRespon\
    se\x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07steamid\x12\x18\n\x07su\
    ccess\x18\x02\x20\x01(\rR\x07success\x12X\n\x08messages\x18\x03\x20\x03(\
    \x0b2<.CMsgClientChatGetFriendMessageHistoryResponse.FriendMessageR\x08m\
    essages\x1a}\n\rFriendMessage\x12\x1c\n\taccountid\x18\x01\x20\x01(\rR\t\
    accountid\x12\x1c\n\ttimestamp\x18\x02\x20\x01(\rR\ttimestamp\x12\x18\n\
    \x07message\x18\x03\x20\x01(\tR\x07message\x12\x16\n\x06unread\x18\x04\
    \x20\x01(\x08R\x06unread\"9\n7CMsgClientChatGetFriendMessageHistoryForOf\
    flineMessages\"C\n!CMsgClientFSGetFriendsSteamLevels\x12\x1e\n\naccounti\
    ds\x18\x01\x20\x03(\rR\naccountids\"\xb6\x01\n)CMsgClientFSGetFriendsSte\
    amLevelsResponse\x12K\n\x07friends\x18\x01\x20\x03(\x0b21.CMsgClientFSGe\
    tFriendsSteamLevelsResponse.FriendR\x07friends\x1a<\n\x06Friend\x12\x1c\
    \n\taccountid\x18\x01\x20\x01(\rR\taccountid\x12\x14\n\x05level\x18\x02\
    \x20\x01(\rR\x05level\"\xfd\x02\n\x17CMsgClientEmailAddrInfo\x12#\n\rema\
    il_address\x18\x01\x20\x01(\tR\x0cemailAddress\x12,\n\x12email_is_valida\
    ted\x18\x02\x20\x01(\x08R\x10emailIsValidated\x128\n\x18email_validation\
    _changed\x18\x03\x20\x01(\x08R\x16emailValidationChanged\x12E\n\x1fcrede\
    ntial_change_requires_code\x18\x04\x20\x01(\x08R\x1ccredentialChangeRequ\
    iresCode\x12W\n)password_or_secretqa_change_requires_code\x18\x05\x20\
    \x01(\x08R$passwordOrSecretqaChangeRequiresCode\x125\n\x17remind_user_ab\
    out_email\x18\x06\x20\x01(\x08R\x14remindUserAboutEmail\"\xae\x01\n\x16C\
    MsgCREItemVoteSummary\x12U\n\x12published_file_ids\x18\x01\x20\x03(\x0b2\
    '.CMsgCREItemVoteSummary.PublishedFileIdR\x10publishedFileIds\x1a=\n\x0f\
    PublishedFileId\x12*\n\x11published_file_id\x18\x01\x20\x01(\x06R\x0fpub\
    lishedFileId\"\xd0\x02\n\x1eCMsgCREItemVoteSummaryResponse\x12\x1b\n\x07\
    eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\x12_\n\x13item_vote_summa\
    ries\x18\x02\x20\x03(\x0b2/.CMsgCREItemVoteSummaryResponse.ItemVoteSumma\
    ryR\x11itemVoteSummaries\x1a\xaf\x01\n\x0fItemVoteSummary\x12*\n\x11publ\
    ished_file_id\x18\x01\x20\x01(\x06R\x0fpublishedFileId\x12\x1b\n\tvotes_\
    for\x18\x02\x20\x01(\x05R\x08votesFor\x12#\n\rvotes_against\x18\x03\x20\
    \x01(\x05R\x0cvotesAgainst\x12\x18\n\x07reports\x18\x04\x20\x01(\x05R\
    \x07reports\x12\x14\n\x05score\x18\x05\x20\x01(\x02R\x05score\"i\n\"CMsg\
    CREUpdateUserPublishedItemVote\x12*\n\x11published_file_id\x18\x01\x20\
    \x01(\x06R\x0fpublishedFileId\x12\x17\n\x07vote_up\x18\x02\x20\x01(\x08R\
    \x06voteUp\"I\n*CMsgCREUpdateUserPublishedItemVoteResponse\x12\x1b\n\x07\
    eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\"\xce\x01\n&CMsgCREGetUse\
    rPublishedItemVoteDetails\x12e\n\x12published_file_ids\x18\x01\x20\x03(\
    \x0b27.CMsgCREGetUserPublishedItemVoteDetails.PublishedFileIdR\x10publis\
    hedFileIds\x1a=\n\x0fPublishedFileId\x12*\n\x11published_file_id\x18\x01\
    \x20\x01(\x06R\x0fpublishedFileId\"\x9f\x02\n.CMsgCREGetUserPublishedIte\
    mVoteDetailsResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\
    \x07eresult\x12w\n\x16user_item_vote_details\x18\x02\x20\x03(\x0b2B.CMsg\
    CREGetUserPublishedItemVoteDetailsResponse.UserItemVoteDetailR\x13userIt\
    emVoteDetails\x1aW\n\x12UserItemVoteDetail\x12*\n\x11published_file_id\
    \x18\x01\x20\x01(\x06R\x0fpublishedFileId\x12\x15\n\x04vote\x18\x02\x20\
    \x01(\x05:\x010R\x04vote\"\xf3\x01\n\x18CMsgGameServerPingSample\x12\x13\
    \n\x05my_ip\x18\x01\x20\x01(\x07R\x04myIp\x12\x1a\n\tgs_app_id\x18\x02\
    \x20\x01(\x05R\x07gsAppId\x12?\n\ngs_samples\x18\x03\x20\x03(\x0b2\x20.C\
    MsgGameServerPingSample.SampleR\tgsSamples\x1ae\n\x06Sample\x12\x0e\n\
    \x02ip\x18\x01\x20\x01(\x07R\x02ip\x12\x1e\n\x0bavg_ping_ms\x18\x02\x20\
    \x01(\rR\tavgPingMs\x12+\n\x12stddev_ping_ms_x10\x18\x03\x20\x01(\rR\x0f\
    stddevPingMsX10\"3\n\x16CMsgFSGetFollowerCount\x12\x19\n\x08steam_id\x18\
    \x01\x20\x01(\x06R\x07steamId\"V\n\x1eCMsgFSGetFollowerCountResponse\x12\
    \x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\x12\x17\n\x05co\
    unt\x18\x02\x20\x01(\x05:\x010R\x05count\"1\n\x14CMsgFSGetIsFollowing\
    \x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\"e\n\x1cCMsgFSGe\
    tIsFollowingResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\
    \x07eresult\x12(\n\x0cis_following\x18\x02\x20\x01(\x08:\x05falseR\x0bis\
    Following\"?\n\x1cCMsgFSEnumerateFollowingList\x12\x1f\n\x0bstart_index\
    \x18\x01\x20\x01(\rR\nstartIndex\"\x85\x01\n$CMsgFSEnumerateFollowingLis\
    tResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\
    \x12#\n\rtotal_results\x18\x02\x20\x01(\x05R\x0ctotalResults\x12\x1b\n\t\
    steam_ids\x18\x03\x20\x03(\x06R\x08steamIds\"7\n\x1fCMsgDPGetNumberOfCur\
    rentPlayers\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\"i\n'CMsgDPG\
    etNumberOfCurrentPlayersResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\
    \x05:\x012R\x07eresult\x12!\n\x0cplayer_count\x18\x02\x20\x01(\x05R\x0bp\
    layerCount\"\x83\x01\n#CMsgClientFriendUserStatusPublished\x12%\n\x0efri\
    end_steamid\x18\x01\x20\x01(\x06R\rfriendSteamid\x12\x14\n\x05appid\x18\
    \x02\x20\x01(\rR\x05appid\x12\x1f\n\x0bstatus_text\x18\x03\x20\x01(\tR\n\
    statusText\"\x96\x01\n\x1dCMsgClientServiceMethodLegacy\x12\x1f\n\x0bmet\
    hod_name\x18\x01\x20\x01(\tR\nmethodName\x12+\n\x11serialized_method\x18\
    \x02\x20\x01(\x0cR\x10serializedMethod\x12'\n\x0fis_notification\x18\x03\
    \x20\x01(\x08R\x0eisNotification\"\x86\x01\n%CMsgClientServiceMethodLega\
    cyResponse\x12\x1f\n\x0bmethod_name\x18\x01\x20\x01(\tR\nmethodName\x12<\
    \n\x1aserialized_method_response\x18\x02\x20\x01(\x0cR\x18serializedMeth\
    odResponse\"G\n\x10CMsgClientUIMode\x12\x16\n\x06uimode\x18\x01\x20\x01(\
    \rR\x06uimode\x12\x1b\n\tchat_mode\x18\x02\x20\x01(\rR\x08chatMode\"G\n&\
    CMsgClientVanityURLChangedNotification\x12\x1d\n\nvanity_url\x18\x01\x20\
    \x01(\tR\tvanityUrl\"\xae\x01\n%CMsgClientAuthorizeLocalDeviceRequest\
    \x12-\n\x12device_description\x18\x01\x20\x01(\tR\x11deviceDescription\
    \x12(\n\x10owner_account_id\x18\x02\x20\x01(\rR\x0eownerAccountId\x12,\n\
    \x12local_device_token\x18\x03\x20\x01(\x04R\x10localDeviceToken\"\x97\
    \x01\n\x1eCMsgClientAuthorizeLocalDevice\x12\x1b\n\x07eresult\x18\x01\
    \x20\x01(\x05:\x012R\x07eresult\x12(\n\x10owner_account_id\x18\x02\x20\
    \x01(\rR\x0eownerAccountId\x12.\n\x13authed_device_token\x18\x03\x20\x01\
    (\x04R\x11authedDeviceToken\"\xa1\x01\n*CMsgClientAuthorizeLocalDeviceNo\
    tification\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\
    \x12(\n\x10owner_account_id\x18\x02\x20\x01(\rR\x0eownerAccountId\x12,\n\
    \x12local_device_token\x18\x03\x20\x01(\x04R\x10localDeviceToken\"\xa4\
    \x01\n\"CMsgClientDeauthorizeDeviceRequest\x12<\n\x1adeauthorization_acc\
    ount_id\x18\x01\x20\x01(\rR\x18deauthorizationAccountId\x12@\n\x1cdeauth\
    orization_device_token\x18\x02\x20\x01(\x04R\x1adeauthorizationDeviceTok\
    en\"x\n\x1bCMsgClientDeauthorizeDevice\x12\x1b\n\x07eresult\x18\x01\x20\
    \x01(\x05:\x012R\x07eresult\x12<\n\x1adeauthorization_account_id\x18\x02\
    \x20\x01(\rR\x18deauthorizationAccountId\"\x90\x02\n&CMsgClientUseLocalD\
    eviceAuthorizations\x128\n\x18authorization_account_id\x18\x01\x20\x03(\
    \rR\x16authorizationAccountId\x12X\n\rdevice_tokens\x18\x02\x20\x03(\x0b\
    23.CMsgClientUseLocalDeviceAuthorizations.DeviceTokenR\x0cdeviceTokens\
    \x1aR\n\x0bDeviceToken\x12(\n\x10owner_account_id\x18\x01\x20\x01(\rR\
    \x0eownerAccountId\x12\x19\n\x08token_id\x18\x02\x20\x01(\x04R\x07tokenI\
    d\"\x20\n\x1eCMsgClientGetAuthorizedDevices\"\x97\x03\n&CMsgClientGetAut\
    horizedDevicesResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\
    \x07eresult\x12e\n\x11authorized_device\x18\x02\x20\x03(\x0b28.CMsgClien\
    tGetAuthorizedDevicesResponse.AuthorizedDeviceR\x10authorizedDevice\x1a\
    \xe8\x01\n\x10AuthorizedDevice\x12*\n\x11auth_device_token\x18\x01\x20\
    \x01(\x04R\x0fauthDeviceToken\x12\x1f\n\x0bdevice_name\x18\x02\x20\x01(\
    \tR\ndeviceName\x12(\n\x10last_access_time\x18\x03\x20\x01(\rR\x0elastAc\
    cessTime\x12\x1f\n\x0bborrower_id\x18\x04\x20\x01(\rR\nborrowerId\x12\
    \x1d\n\nis_pending\x18\x05\x20\x01(\x08R\tisPending\x12\x1d\n\napp_playe\
    d\x18\x06\x20\x01(\rR\tappPlayed\"\xf8\x01\n!CMsgClientSharedLibraryLock\
    Status\x12W\n\x0elocked_library\x18\x01\x20\x03(\x0b20.CMsgClientSharedL\
    ibraryLockStatus.LockedLibraryR\rlockedLibrary\x121\n\x15own_library_loc\
    ked_by\x18\x02\x20\x01(\rR\x12ownLibraryLockedBy\x1aG\n\rLockedLibrary\
    \x12\x19\n\x08owner_id\x18\x01\x20\x01(\rR\x07ownerId\x12\x1b\n\tlocked_\
    by\x18\x02\x20\x01(\rR\x08lockedBy\"\xce\x01\n\"CMsgClientSharedLibraryS\
    topPlaying\x12!\n\x0cseconds_left\x18\x01\x20\x01(\x05R\x0bsecondsLeft\
    \x12H\n\tstop_apps\x18\x02\x20\x03(\x0b2+.CMsgClientSharedLibraryStopPla\
    ying.StopAppR\x08stopApps\x1a;\n\x07StopApp\x12\x15\n\x06app_id\x18\x01\
    \x20\x01(\rR\x05appId\x12\x19\n\x08owner_id\x18\x02\x20\x01(\rR\x07owner\
    Id\"\xf1\x02\n\x15CMsgClientServiceCall\x12#\n\rsysid_routing\x18\x01\
    \x20\x01(\x0cR\x0csysidRouting\x12\x1f\n\x0bcall_handle\x18\x02\x20\x01(\
    \rR\ncallHandle\x12\x1d\n\nmodule_crc\x18\x03\x20\x01(\rR\tmoduleCrc\x12\
    \x1f\n\x0bmodule_hash\x18\x04\x20\x01(\x0cR\nmoduleHash\x12\x1f\n\x0bfun\
    ction_id\x18\x05\x20\x01(\rR\nfunctionId\x12$\n\x0ecub_output_max\x18\
    \x06\x20\x01(\rR\x0ccubOutputMax\x12\x14\n\x05flags\x18\x07\x20\x01(\rR\
    \x05flags\x12$\n\rcallparameter\x18\x08\x20\x01(\x0cR\rcallparameter\x12\
    \x1b\n\tping_only\x18\t\x20\x01(\x08R\x08pingOnly\x122\n\x15max_outstand\
    ing_calls\x18\n\x20\x01(\rR\x13maxOutstandingCalls\"\x80\x01\n\x17CMsgCl\
    ientServiceModule\x12\x1d\n\nmodule_crc\x18\x01\x20\x01(\rR\tmoduleCrc\
    \x12\x1f\n\x0bmodule_hash\x18\x02\x20\x01(\x0cR\nmoduleHash\x12%\n\x0emo\
    dule_content\x18\x03\x20\x01(\x0cR\rmoduleContent\"\x8a\x07\n\x1dCMsgCli\
    entServiceCallResponse\x12#\n\rsysid_routing\x18\x01\x20\x01(\x0cR\x0csy\
    sidRouting\x12\x1f\n\x0bcall_handle\x18\x02\x20\x01(\rR\ncallHandle\x12\
    \x1d\n\nmodule_crc\x18\x03\x20\x01(\rR\tmoduleCrc\x12\x1f\n\x0bmodule_ha\
    sh\x18\x04\x20\x01(\x0cR\nmoduleHash\x12\x20\n\x0becallresult\x18\x05\
    \x20\x01(\rR\x0becallresult\x12%\n\x0eresult_content\x18\x06\x20\x01(\
    \x0cR\rresultContent\x12&\n\x0fos_version_info\x18\x07\x20\x01(\x0cR\ros\
    VersionInfo\x12\x1f\n\x0bsystem_info\x18\x08\x20\x01(\x0cR\nsystemInfo\
    \x12!\n\x0cload_address\x18\t\x20\x01(\x06R\x0bloadAddress\x12)\n\x10exc\
    eption_record\x18\n\x20\x01(\x0cR\x0fexceptionRecord\x127\n\x18portable_\
    os_version_info\x18\x0b\x20\x01(\x0cR\x15portableOsVersionInfo\x120\n\
    \x14portable_system_info\x18\x0c\x20\x01(\x0cR\x12portableSystemInfo\x12\
    #\n\rwas_converted\x18\r\x20\x01(\x08R\x0cwasConverted\x12'\n\x0finterna\
    l_result\x18\x0e\x20\x01(\rR\x0einternalResult\x12#\n\rcurrent_count\x18\
    \x0f\x20\x01(\rR\x0ccurrentCount\x12(\n\x10last_call_handle\x18\x10\x20\
    \x01(\rR\x0elastCallHandle\x12/\n\x14last_call_module_crc\x18\x11\x20\
    \x01(\rR\x11lastCallModuleCrc\x125\n\x17last_call_sysid_routing\x18\x12\
    \x20\x01(\x0cR\x14lastCallSysidRouting\x12)\n\x10last_ecallresult\x18\
    \x13\x20\x01(\rR\x0flastEcallresult\x120\n\x14last_callissue_delta\x18\
    \x14\x20\x01(\rR\x12lastCallissueDelta\x126\n\x17last_callcomplete_delta\
    \x18\x15\x20\x01(\rR\x15lastCallcompleteDelta\"\x17\n\x15CMsgAMUnlockStr\
    eaming\"c\n\x1dCMsgAMUnlockStreamingResponse\x12\x1b\n\x07eresult\x18\
    \x01\x20\x01(\x05:\x012R\x07eresult\x12%\n\x0eencryption_key\x18\x02\x20\
    \x01(\x0cR\rencryptionKey\"\x12\n\x10CMsgAMUnlockHEVC\"7\n\x18CMsgAMUnlo\
    ckHEVCResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresu\
    lt\"i\n\x1dCMsgClientPlayingSessionState\x12'\n\x0fplaying_blocked\x18\
    \x02\x20\x01(\x08R\x0eplayingBlocked\x12\x1f\n\x0bplaying_app\x18\x03\
    \x20\x01(\rR\nplayingApp\"D\n\x1cCMsgClientKickPlayingSession\x12$\n\x0e\
    only_stop_game\x18\x01\x20\x01(\x08R\x0conlyStopGame\"\xa8\x01\n\x1fCMsg\
    ClientVoiceCallPreAuthorize\x12%\n\x0ecaller_steamid\x18\x01\x20\x01(\
    \x06R\rcallerSteamid\x12)\n\x10receiver_steamid\x18\x02\x20\x01(\x06R\
    \x0freceiverSteamid\x12\x1b\n\tcaller_id\x18\x03\x20\x01(\x05R\x08caller\
    Id\x12\x16\n\x06hangup\x18\x04\x20\x01(\x08R\x06hangup\"\xb5\x01\n'CMsgC\
    lientVoiceCallPreAuthorizeResponse\x12%\n\x0ecaller_steamid\x18\x01\x20\
    \x01(\x06R\rcallerSteamid\x12)\n\x10receiver_steamid\x18\x02\x20\x01(\
    \x06R\x0freceiverSteamid\x12\x1b\n\x07eresult\x18\x03\x20\x01(\x05:\x012\
    R\x07eresult\x12\x1b\n\tcaller_id\x18\x04\x20\x01(\x05R\x08callerId\"U\n\
    \x1cCMsgBadgeCraftedNotification\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\
    \x05appid\x12\x1f\n\x0bbadge_level\x18\x02\x20\x01(\rR\nbadgeLevelB\x05H\
    \x01\x80\x01\0J\xe4\x9d\x03\n\x07\x12\x05\0\0\xfb\x08\x01\n\t\n\x02\x03\
    \0\x12\x03\0\0\"\n\x08\n\x01\x08\x12\x03\x02\0\x1c\n\t\n\x02\x08\t\x12\
    \x03\x02\0\x1c\n\x08\n\x01\x08\x12\x03\x03\0#\n\t\n\x02\x08\x10\x12\x03\
    \x03\0#\n\n\n\x02\x04\0\x12\x04\x05\0\x19\x01\n\n\n\x03\x04\0\x01\x12\
    \x03\x05\x08\"\n\x0c\n\x04\x04\0\x03\0\x12\x04\x06\x08\t\t\n\x0c\n\x05\
    \x04\0\x03\0\x01\x12\x03\x06\x10\x13\n\r\n\x06\x04\0\x03\0\x02\0\x12\x03\
    \x07\x10-\n\x0e\n\x07\x04\0\x03\0\x02\0\x04\x12\x03\x07\x10\x18\n\x0e\n\
    \x07\x04\0\x03\0\x02\0\x05\x12\x03\x07\x19\x1f\n\x0e\n\x07\x04\0\x03\0\
    \x02\0\x01\x12\x03\x07\x20(\n\x0e\n\x07\x04\0\x03\0\x02\0\x03\x12\x03\
    \x07+,\n\r\n\x06\x04\0\x03\0\x02\x01\x12\x03\x08\x10.\n\x0e\n\x07\x04\0\
    \x03\0\x02\x01\x04\x12\x03\x08\x10\x18\n\x0e\n\x07\x04\0\x03\0\x02\x01\
    \x05\x12\x03\x08\x19\x1f\n\x0e\n\x07\x04\0\x03\0\x02\x01\x01\x12\x03\x08\
    \x20)\n\x0e\n\x07\x04\0\x03\0\x02\x01\x03\x12\x03\x08,-\n\x0b\n\x04\x04\
    \0\x02\0\x12\x03\x0b\x08\"\n\x0c\n\x05\x04\0\x02\0\x04\x12\x03\x0b\x08\
    \x10\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x0b\x11\x17\n\x0c\n\x05\x04\0\
    \x02\0\x01\x12\x03\x0b\x18\x1d\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x0b\
    \x20!\n\x0b\n\x04\x04\0\x02\x01\x12\x03\x0c\x08%\n\x0c\n\x05\x04\0\x02\
    \x01\x04\x12\x03\x0c\x08\x10\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03\x0c\
    \x11\x17\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x0c\x18\x20\n\x0c\n\x05\
    \x04\0\x02\x01\x03\x12\x03\x0c#$\n\x0b\n\x04\x04\0\x02\x02\x12\x03\r\x08\
    &\n\x0c\n\x05\x04\0\x02\x02\x04\x12\x03\r\x08\x10\n\x0c\n\x05\x04\0\x02\
    \x02\x05\x12\x03\r\x11\x17\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\r\x18!\
    \n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03\r$%\n\x0b\n\x04\x04\0\x02\x03\x12\
    \x03\x0e\x08)\n\x0c\n\x05\x04\0\x02\x03\x04\x12\x03\x0e\x08\x10\n\x0c\n\
    \x05\x04\0\x02\x03\x05\x12\x03\x0e\x11\x17\n\x0c\n\x05\x04\0\x02\x03\x01\
    \x12\x03\x0e\x18#\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03\x0e&(\n\x0b\n\
    \x04\x04\0\x02\x04\x12\x03\x0f\x08-\n\x0c\n\x05\x04\0\x02\x04\x04\x12\
    \x03\x0f\x08\x10\n\x0c\n\x05\x04\0\x02\x04\x05\x12\x03\x0f\x11\x18\n\x0c\
    \n\x05\x04\0\x02\x04\x01\x12\x03\x0f\x19(\n\x0c\n\x05\x04\0\x02\x04\x03\
    \x12\x03\x0f+,\n\x0b\n\x04\x04\0\x02\x05\x12\x03\x10\x08\"\n\x0c\n\x05\
    \x04\0\x02\x05\x04\x12\x03\x10\x08\x10\n\x0c\n\x05\x04\0\x02\x05\x05\x12\
    \x03\x10\x11\x17\n\x0c\n\x05\x04\0\x02\x05\x01\x12\x03\x10\x18\x1d\n\x0c\
    \n\x05\x04\0\x02\x05\x03\x12\x03\x10\x20!\n\x0b\n\x04\x04\0\x02\x06\x12\
    \x03\x11\x08#\n\x0c\n\x05\x04\0\x02\x06\x04\x12\x03\x11\x08\x10\n\x0c\n\
    \x05\x04\0\x02\x06\x05\x12\x03\x11\x11\x17\n\x0c\n\x05\x04\0\x02\x06\x01\
    \x12\x03\x11\x18\x1e\n\x0c\n\x05\x04\0\x02\x06\x03\x12\x03\x11!\"\n\x0b\
    \n\x04\x04\0\x02\x07\x12\x03\x12\x08(\n\x0c\n\x05\x04\0\x02\x07\x04\x12\
    \x03\x12\x08\x10\n\x0c\n\x05\x04\0\x02\x07\x05\x12\x03\x12\x11\x17\n\x0c\
    \n\x05\x04\0\x02\x07\x01\x12\x03\x12\x18#\n\x0c\n\x05\x04\0\x02\x07\x03\
    \x12\x03\x12&'\n\x0b\n\x04\x04\0\x02\x08\x12\x03\x13\x08$\n\x0c\n\x05\
    \x04\0\x02\x08\x04\x12\x03\x13\x08\x10\n\x0c\n\x05\x04\0\x02\x08\x05\x12\
    \x03\x13\x11\x17\n\x0c\n\x05\x04\0\x02\x08\x01\x12\x03\x13\x18\x1f\n\x0c\
    \n\x05\x04\0\x02\x08\x03\x12\x03\x13\"#\n\x0b\n\x04\x04\0\x02\t\x12\x03\
    \x14\x08*\n\x0c\n\x05\x04\0\x02\t\x04\x12\x03\x14\x08\x10\n\x0c\n\x05\
    \x04\0\x02\t\x05\x12\x03\x14\x11\x17\n\x0c\n\x05\x04\0\x02\t\x01\x12\x03\
    \x14\x18%\n\x0c\n\x05\x04\0\x02\t\x03\x12\x03\x14()\n\x0b\n\x04\x04\0\
    \x02\n\x12\x03\x15\x08:\n\x0c\n\x05\x04\0\x02\n\x04\x12\x03\x15\x08\x10\
    \n\x0c\n\x05\x04\0\x02\n\x06\x12\x03\x15\x110\n\x0c\n\x05\x04\0\x02\n\
    \x01\x12\x03\x1514\n\x0c\n\x05\x04\0\x02\n\x03\x12\x03\x1579\n\x0b\n\x04\
    \x04\0\x02\x0b\x12\x03\x16\x08-\n\x0c\n\x05\x04\0\x02\x0b\x04\x12\x03\
    \x16\x08\x10\n\x0c\n\x05\x04\0\x02\x0b\x05\x12\x03\x16\x11\x18\n\x0c\n\
    \x05\x04\0\x02\x0b\x01\x12\x03\x16\x19'\n\x0c\n\x05\x04\0\x02\x0b\x03\
    \x12\x03\x16*,\n\x0b\n\x04\x04\0\x02\x0c\x12\x03\x17\x08'\n\x0c\n\x05\
    \x04\0\x02\x0c\x04\x12\x03\x17\x08\x10\n\x0c\n\x05\x04\0\x02\x0c\x05\x12\
    \x03\x17\x11\x15\n\x0c\n\x05\x04\0\x02\x0c\x01\x12\x03\x17\x16!\n\x0c\n\
    \x05\x04\0\x02\x0c\x03\x12\x03\x17$&\n\x0b\n\x04\x04\0\x02\r\x12\x03\x18\
    \x084\n\x0c\n\x05\x04\0\x02\r\x04\x12\x03\x18\x08\x10\n\x0c\n\x05\x04\0\
    \x02\r\x05\x12\x03\x18\x11\x17\n\x0c\n\x05\x04\0\x02\r\x01\x12\x03\x18\
    \x18.\n\x0c\n\x05\x04\0\x02\r\x03\x12\x03\x1813\n\n\n\x02\x04\x01\x12\
    \x04\x1b\0\x1e\x01\n\n\n\x03\x04\x01\x01\x12\x03\x1b\x08*\n\x0b\n\x04\
    \x04\x01\x02\0\x12\x03\x1c\x081\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03\
    \x1c\x08\x10\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03\x1c\x11\x16\n\x0c\n\
    \x05\x04\x01\x02\0\x01\x12\x03\x1c\x17\x1e\n\x0c\n\x05\x04\x01\x02\0\x03\
    \x12\x03\x1c!\"\n\x0c\n\x05\x04\x01\x02\0\x08\x12\x03\x1c#0\n\x0c\n\x05\
    \x04\x01\x02\0\x07\x12\x03\x1c./\n\x0b\n\x04\x04\x01\x02\x01\x12\x03\x1d\
    \x08K\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\x03\x1d\x08\x10\n\x0c\n\x05\
    \x04\x01\x02\x01\x05\x12\x03\x1d\x11\x18\n\x0c\n\x05\x04\x01\x02\x01\x01\
    \x12\x03\x1d\x19%\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03\x1d()\n\x0c\n\
    \x05\x04\x01\x02\x01\x08\x12\x03\x1d*J\n\x0c\n\x05\x04\x01\x02\x01\x07\
    \x12\x03\x1d5I\n\n\n\x02\x04\x02\x12\x04\x20\0\"\x01\n\n\n\x03\x04\x02\
    \x01\x12\x03\x20\x08%\n\x0b\n\x04\x04\x02\x02\0\x12\x03!\x08K\n\x0c\n\
    \x05\x04\x02\x02\0\x04\x12\x03!\x08\x10\n\x0c\n\x05\x04\x02\x02\0\x05\
    \x12\x03!\x11\x18\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03!\x19%\n\x0c\n\
    \x05\x04\x02\x02\0\x03\x12\x03!()\n\x0c\n\x05\x04\x02\x02\0\x08\x12\x03!\
    *J\n\x0c\n\x05\x04\x02\x02\0\x07\x12\x03!5I\n\n\n\x02\x04\x03\x12\x04$\0\
    &\x01\n\n\n\x03\x04\x03\x01\x12\x03$\x08-\n\x0b\n\x04\x04\x03\x02\0\x12\
    \x03%\x081\n\x0c\n\x05\x04\x03\x02\0\x04\x12\x03%\x08\x10\n\x0c\n\x05\
    \x04\x03\x02\0\x05\x12\x03%\x11\x16\n\x0c\n\x05\x04\x03\x02\0\x01\x12\
    \x03%\x17\x1e\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03%!\"\n\x0c\n\x05\x04\
    \x03\x02\0\x08\x12\x03%#0\n\x0c\n\x05\x04\x03\x02\0\x07\x12\x03%./\n\n\n\
    \x02\x04\x04\x12\x04(\08\x01\n\n\n\x03\x04\x04\x01\x12\x03(\x08\x20\n\
    \x0b\n\x04\x04\x04\x02\0\x12\x03)\x08#\n\x0c\n\x05\x04\x04\x02\0\x04\x12\
    \x03)\x08\x10\n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03)\x11\x17\n\x0c\n\x05\
    \x04\x04\x02\0\x01\x12\x03)\x18\x1e\n\x0c\n\x05\x04\x04\x02\0\x03\x12\
    \x03)!\"\n\x0b\n\x04\x04\x04\x02\x01\x12\x03*\x08&\n\x0c\n\x05\x04\x04\
    \x02\x01\x04\x12\x03*\x08\x10\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\x03*\
    \x11\x17\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03*\x18!\n\x0c\n\x05\x04\
    \x04\x02\x01\x03\x12\x03*$%\n\x0b\n\x04\x04\x04\x02\x02\x12\x03+\x08.\n\
    \x0c\n\x05\x04\x04\x02\x02\x04\x12\x03+\x08\x10\n\x0c\n\x05\x04\x04\x02\
    \x02\x05\x12\x03+\x11\x17\n\x0c\n\x05\x04\x04\x02\x02\x01\x12\x03+\x18)\
    \n\x0c\n\x05\x04\x04\x02\x02\x03\x12\x03+,-\n\x0b\n\x04\x04\x04\x02\x03\
    \x12\x03,\x08,\n\x0c\n\x05\x04\x04\x02\x03\x04\x12\x03,\x08\x10\n\x0c\n\
    \x05\x04\x04\x02\x03\x05\x12\x03,\x11\x17\n\x0c\n\x05\x04\x04\x02\x03\
    \x01\x12\x03,\x18'\n\x0c\n\x05\x04\x04\x02\x03\x03\x12\x03,*+\n\x0b\n\
    \x04\x04\x04\x02\x04\x12\x03-\x08\"\n\x0c\n\x05\x04\x04\x02\x04\x04\x12\
    \x03-\x08\x10\n\x0c\n\x05\x04\x04\x02\x04\x05\x12\x03-\x11\x17\n\x0c\n\
    \x05\x04\x04\x02\x04\x01\x12\x03-\x18\x1d\n\x0c\n\x05\x04\x04\x02\x04\
    \x03\x12\x03-\x20!\n\x0b\n\x04\x04\x04\x02\x05\x12\x03.\x08(\n\x0c\n\x05\
    \x04\x04\x02\x05\x04\x12\x03.\x08\x10\n\x0c\n\x05\x04\x04\x02\x05\x05\
    \x12\x03.\x11\x17\n\x0c\n\x05\x04\x04\x02\x05\x01\x12\x03.\x18#\n\x0c\n\
    \x05\x04\x04\x02\x05\x03\x12\x03.&'\n\x0b\n\x04\x04\x04\x02\x06\x12\x03/\
    \x08!\n\x0c\n\x05\x04\x04\x02\x06\x04\x12\x03/\x08\x10\n\x0c\n\x05\x04\
    \x04\x02\x06\x05\x12\x03/\x11\x17\n\x0c\n\x05\x04\x04\x02\x06\x01\x12\
    \x03/\x18\x1c\n\x0c\n\x05\x04\x04\x02\x06\x03\x12\x03/\x1f\x20\n\x0b\n\
    \x04\x04\x04\x02\x07\x12\x030\x08(\n\x0c\n\x05\x04\x04\x02\x07\x04\x12\
    \x030\x08\x10\n\x0c\n\x05\x04\x04\x02\x07\x05\x12\x030\x11\x15\n\x0c\n\
    \x05\x04\x04\x02\x07\x01\x12\x030\x16#\n\x0c\n\x05\x04\x04\x02\x07\x03\
    \x12\x030&'\n\x0b\n\x04\x04\x04\x02\x08\x12\x031\x08'\n\x0c\n\x05\x04\
    \x04\x02\x08\x04\x12\x031\x08\x10\n\x0c\n\x05\x04\x04\x02\x08\x05\x12\
    \x031\x11\x16\n\x0c\n\x05\x04\x04\x02\x08\x01\x12\x031\x17!\n\x0c\n\x05\
    \x04\x04\x02\x08\x03\x12\x031$&\n\x0b\n\x04\x04\x04\x02\t\x12\x032\x08'\
    \n\x0c\n\x05\x04\x04\x02\t\x04\x12\x032\x08\x10\n\x0c\n\x05\x04\x04\x02\
    \t\x05\x12\x032\x11\x17\n\x0c\n\x05\x04\x04\x02\t\x01\x12\x032\x18!\n\
    \x0c\n\x05\x04\x04\x02\t\x03\x12\x032$&\n\x0b\n\x04\x04\x04\x02\n\x12\
    \x033\x08!\n\x0c\n\x05\x04\x04\x02\n\x04\x12\x033\x08\x10\n\x0c\n\x05\
    \x04\x04\x02\n\x05\x12\x033\x11\x17\n\x0c\n\x05\x04\x04\x02\n\x01\x12\
    \x033\x18\x1b\n\x0c\n\x05\x04\x04\x02\n\x03\x12\x033\x1e\x20\n\x0b\n\x04\
    \x04\x04\x02\x0b\x12\x034\x08,\n\x0c\n\x05\x04\x04\x02\x0b\x04\x12\x034\
    \x08\x10\n\x0c\n\x05\x04\x04\x02\x0b\x05\x12\x034\x11\x17\n\x0c\n\x05\
    \x04\x04\x02\x0b\x01\x12\x034\x18&\n\x0c\n\x05\x04\x04\x02\x0b\x03\x12\
    \x034)+\n\x0b\n\x04\x04\x04\x02\x0c\x12\x035\x080\n\x0c\n\x05\x04\x04\
    \x02\x0c\x04\x12\x035\x08\x10\n\x0c\n\x05\x04\x04\x02\x0c\x05\x12\x035\
    \x11\x17\n\x0c\n\x05\x04\x04\x02\x0c\x01\x12\x035\x18*\n\x0c\n\x05\x04\
    \x04\x02\x0c\x03\x12\x035-/\n\x0b\n\x04\x04\x04\x02\r\x12\x036\x08.\n\
    \x0c\n\x05\x04\x04\x02\r\x04\x12\x036\x08\x10\n\x0c\n\x05\x04\x04\x02\r\
    \x05\x12\x036\x11\x17\n\x0c\n\x05\x04\x04\x02\r\x01\x12\x036\x18(\n\x0c\
    \n\x05\x04\x04\x02\r\x03\x12\x036+-\n\x0b\n\x04\x04\x04\x02\x0e\x12\x037\
    \x08'\n\x0c\n\x05\x04\x04\x02\x0e\x04\x12\x037\x08\x10\n\x0c\n\x05\x04\
    \x04\x02\x0e\x05\x12\x037\x11\x15\n\x0c\n\x05\x04\x04\x02\x0e\x01\x12\
    \x037\x16!\n\x0c\n\x05\x04\x04\x02\x0e\x03\x12\x037$&\n\n\n\x02\x04\x05\
    \x12\x04:\0>\x01\n\n\n\x03\x04\x05\x01\x12\x03:\x08(\n\x0b\n\x04\x04\x05\
    \x02\0\x12\x03;\x081\n\x0c\n\x05\x04\x05\x02\0\x04\x12\x03;\x08\x10\n\
    \x0c\n\x05\x04\x05\x02\0\x05\x12\x03;\x11\x16\n\x0c\n\x05\x04\x05\x02\0\
    \x01\x12\x03;\x17\x1e\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03;!\"\n\x0c\n\
    \x05\x04\x05\x02\0\x08\x12\x03;#0\n\x0c\n\x05\x04\x05\x02\0\x07\x12\x03;\
    ./\n\x0b\n\x04\x04\x05\x02\x01\x12\x03<\x08P\n\x0c\n\x05\x04\x05\x02\x01\
    \x04\x12\x03<\x08\x10\n\x0c\n\x05\x04\x05\x02\x01\x05\x12\x03<\x11\x18\n\
    \x0c\n\x05\x04\x05\x02\x01\x01\x12\x03<\x19*\n\x0c\n\x05\x04\x05\x02\x01\
    \x03\x12\x03<-.\n\x0c\n\x05\x04\x05\x02\x01\x08\x12\x03</O\n\x0c\n\x05\
    \x04\x05\x02\x01\x07\x12\x03<:N\n\x0b\n\x04\x04\x05\x02\x02\x12\x03=\x08\
    V\n\x0c\n\x05\x04\x05\x02\x02\x04\x12\x03=\x08\x10\n\x0c\n\x05\x04\x05\
    \x02\x02\x05\x12\x03=\x11\x15\n\x0c\n\x05\x04\x05\x02\x02\x01\x12\x03=\
    \x16?\n\x0c\n\x05\x04\x05\x02\x02\x03\x12\x03=BC\n\x0c\n\x05\x04\x05\x02\
    \x02\x08\x12\x03=DU\n\x0c\n\x05\x04\x05\x02\x02\x07\x12\x03=OT\n\n\n\x02\
    \x04\x06\x12\x04@\0j\x01\n\n\n\x03\x04\x06\x01\x12\x03@\x08(\n\x0c\n\x04\
    \x04\x06\x03\0\x12\x04A\x08D\t\n\x0c\n\x05\x04\x06\x03\0\x01\x12\x03A\
    \x10\x1b\n\r\n\x06\x04\x06\x03\0\x02\0\x12\x03B\x10(\n\x0e\n\x07\x04\x06\
    \x03\0\x02\0\x04\x12\x03B\x10\x18\n\x0e\n\x07\x04\x06\x03\0\x02\0\x05\
    \x12\x03B\x19\x1f\n\x0e\n\x07\x04\x06\x03\0\x02\0\x01\x12\x03B\x20#\n\
    \x0e\n\x07\x04\x06\x03\0\x02\0\x03\x12\x03B&'\n\r\n\x06\x04\x06\x03\0\
    \x02\x01\x12\x03C\x10*\n\x0e\n\x07\x04\x06\x03\0\x02\x01\x04\x12\x03C\
    \x10\x18\n\x0e\n\x07\x04\x06\x03\0\x02\x01\x05\x12\x03C\x19\x1f\n\x0e\n\
    \x07\x04\x06\x03\0\x02\x01\x01\x12\x03C\x20%\n\x0e\n\x07\x04\x06\x03\0\
    \x02\x01\x03\x12\x03C()\n\x0c\n\x04\x04\x06\x03\x01\x12\x04F\x08L\t\n\
    \x0c\n\x05\x04\x06\x03\x01\x01\x12\x03F\x10!\n\r\n\x06\x04\x06\x03\x01\
    \x02\0\x12\x03G\x107\n\x0e\n\x07\x04\x06\x03\x01\x02\0\x04\x12\x03G\x10\
    \x18\n\x0e\n\x07\x04\x06\x03\x01\x02\0\x05\x12\x03G\x19\x1f\n\x0e\n\x07\
    \x04\x06\x03\x01\x02\0\x01\x12\x03G\x202\n\x0e\n\x07\x04\x06\x03\x01\x02\
    \0\x03\x12\x03G56\n\r\n\x06\x04\x06\x03\x01\x02\x01\x12\x03H\x107\n\x0e\
    \n\x07\x04\x06\x03\x01\x02\x01\x04\x12\x03H\x10\x18\n\x0e\n\x07\x04\x06\
    \x03\x01\x02\x01\x05\x12\x03H\x19\x1f\n\x0e\n\x07\x04\x06\x03\x01\x02\
    \x01\x01\x12\x03H\x202\n\x0e\n\x07\x04\x06\x03\x01\x02\x01\x03\x12\x03H5\
    6\n\r\n\x06\x04\x06\x03\x01\x02\x02\x12\x03I\x10,\n\x0e\n\x07\x04\x06\
    \x03\x01\x02\x02\x04\x12\x03I\x10\x18\n\x0e\n\x07\x04\x06\x03\x01\x02\
    \x02\x05\x12\x03I\x19\x1f\n\x0e\n\x07\x04\x06\x03\x01\x02\x02\x01\x12\
    \x03I\x20'\n\x0e\n\x07\x04\x06\x03\x01\x02\x02\x03\x12\x03I*+\n\r\n\x06\
    \x04\x06\x03\x01\x02\x03\x12\x03J\x101\n\x0e\n\x07\x04\x06\x03\x01\x02\
    \x03\x04\x12\x03J\x10\x18\n\x0e\n\x07\x04\x06\x03\x01\x02\x03\x05\x12\
    \x03J\x19\x1f\n\x0e\n\x07\x04\x06\x03\x01\x02\x03\x01\x12\x03J\x20,\n\
    \x0e\n\x07\x04\x06\x03\x01\x02\x03\x03\x12\x03J/0\n\r\n\x06\x04\x06\x03\
    \x01\x02\x04\x12\x03K\x10?\n\x0e\n\x07\x04\x06\x03\x01\x02\x04\x04\x12\
    \x03K\x10\x18\n\x0e\n\x07\x04\x06\x03\x01\x02\x04\x05\x12\x03K\x19\x1e\n\
    \x0e\n\x07\x04\x06\x03\x01\x02\x04\x01\x12\x03K\x1f+\n\x0e\n\x07\x04\x06\
    \x03\x01\x02\x04\x03\x12\x03K./\n\x0e\n\x07\x04\x06\x03\x01\x02\x04\x08\
    \x12\x03K0>\n\x0e\n\x07\x04\x06\x03\x01\x02\x04\x07\x12\x03K;=\n\x0b\n\
    \x04\x04\x06\x02\0\x12\x03N\x08#\n\x0c\n\x05\x04\x06\x02\0\x04\x12\x03N\
    \x08\x10\n\x0c\n\x05\x04\x06\x02\0\x05\x12\x03N\x11\x17\n\x0c\n\x05\x04\
    \x06\x02\0\x01\x12\x03N\x18\x1e\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03N!\
    \"\n\x0b\n\x04\x04\x06\x02\x01\x12\x03O\x08/\n\x0c\n\x05\x04\x06\x02\x01\
    \x04\x12\x03O\x08\x10\n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x03O\x11\x18\n\
    \x0c\n\x05\x04\x06\x02\x01\x01\x12\x03O\x19*\n\x0c\n\x05\x04\x06\x02\x01\
    \x03\x12\x03O-.\n\x0b\n\x04\x04\x06\x02\x02\x12\x03P\x08&\n\x0c\n\x05\
    \x04\x06\x02\x02\x04\x12\x03P\x08\x10\n\x0c\n\x05\x04\x06\x02\x02\x05\
    \x12\x03P\x11\x17\n\x0c\n\x05\x04\x06\x02\x02\x01\x12\x03P\x18!\n\x0c\n\
    \x05\x04\x06\x02\x02\x03\x12\x03P$%\n\x0b\n\x04\x04\x06\x02\x03\x12\x03Q\
    \x08.\n\x0c\n\x05\x04\x06\x02\x03\x04\x12\x03Q\x08\x10\n\x0c\n\x05\x04\
    \x06\x02\x03\x05\x12\x03Q\x11\x17\n\x0c\n\x05\x04\x06\x02\x03\x01\x12\
    \x03Q\x18)\n\x0c\n\x05\x04\x06\x02\x03\x03\x12\x03Q,-\n\x0b\n\x04\x04\
    \x06\x02\x04\x12\x03R\x08\"\n\x0c\n\x05\x04\x06\x02\x04\x04\x12\x03R\x08\
    \x10\n\x0c\n\x05\x04\x06\x02\x04\x05\x12\x03R\x11\x17\n\x0c\n\x05\x04\
    \x06\x02\x04\x01\x12\x03R\x18\x1d\n\x0c\n\x05\x04\x06\x02\x04\x03\x12\
    \x03R\x20!\n\x0b\n\x04\x04\x06\x02\x05\x12\x03S\x08(\n\x0c\n\x05\x04\x06\
    \x02\x05\x04\x12\x03S\x08\x10\n\x0c\n\x05\x04\x06\x02\x05\x05\x12\x03S\
    \x11\x17\n\x0c\n\x05\x04\x06\x02\x05\x01\x12\x03S\x18#\n\x0c\n\x05\x04\
    \x06\x02\x05\x03\x12\x03S&'\n\x0b\n\x04\x04\x06\x02\x06\x12\x03T\x08!\n\
    \x0c\n\x05\x04\x06\x02\x06\x04\x12\x03T\x08\x10\n\x0c\n\x05\x04\x06\x02\
    \x06\x05\x12\x03T\x11\x17\n\x0c\n\x05\x04\x06\x02\x06\x01\x12\x03T\x18\
    \x1c\n\x0c\n\x05\x04\x06\x02\x06\x03\x12\x03T\x1f\x20\n\x0b\n\x04\x04\
    \x06\x02\x07\x12\x03U\x08&\n\x0c\n\x05\x04\x06\x02\x07\x04\x12\x03U\x08\
    \x10\n\x0c\n\x05\x04\x06\x02\x07\x05\x12\x03U\x11\x16\n\x0c\n\x05\x04\
    \x06\x02\x07\x01\x12\x03U\x17!\n\x0c\n\x05\x04\x06\x02\x07\x03\x12\x03U$\
    %\n\x0b\n\x04\x04\x06\x02\x08\x12\x03V\x08&\n\x0c\n\x05\x04\x06\x02\x08\
    \x04\x12\x03V\x08\x10\n\x0c\n\x05\x04\x06\x02\x08\x05\x12\x03V\x11\x15\n\
    \x0c\n\x05\x04\x06\x02\x08\x01\x12\x03V\x16!\n\x0c\n\x05\x04\x06\x02\x08\
    \x03\x12\x03V$%\n\x0b\n\x04\x04\x06\x02\t\x12\x03W\x08/\n\x0c\n\x05\x04\
    \x06\x02\t\x04\x12\x03W\x08\x10\n\x0c\n\x05\x04\x06\x02\t\x05\x12\x03W\
    \x11\x15\n\x0c\n\x05\x04\x06\x02\t\x01\x12\x03W\x16)\n\x0c\n\x05\x04\x06\
    \x02\t\x03\x12\x03W,.\n\x0b\n\x04\x04\x06\x02\n\x12\x03X\x08(\n\x0c\n\
    \x05\x04\x06\x02\n\x04\x12\x03X\x08\x10\n\x0c\n\x05\x04\x06\x02\n\x05\
    \x12\x03X\x11\x15\n\x0c\n\x05\x04\x06\x02\n\x01\x12\x03X\x16\"\n\x0c\n\
    \x05\x04\x06\x02\n\x03\x12\x03X%'\n\x0b\n\x04\x04\x06\x02\x0b\x12\x03Y\
    \x08.\n\x0c\n\x05\x04\x06\x02\x0b\x04\x12\x03Y\x08\x10\n\x0c\n\x05\x04\
    \x06\x02\x0b\x05\x12\x03Y\x11\x15\n\x0c\n\x05\x04\x06\x02\x0b\x01\x12\
    \x03Y\x16(\n\x0c\n\x05\x04\x06\x02\x0b\x03\x12\x03Y+-\n\x0b\n\x04\x04\
    \x06\x02\x0c\x12\x03Z\x08'\n\x0c\n\x05\x04\x06\x02\x0c\x04\x12\x03Z\x08\
    \x10\n\x0c\n\x05\x04\x06\x02\x0c\x05\x12\x03Z\x11\x15\n\x0c\n\x05\x04\
    \x06\x02\x0c\x01\x12\x03Z\x16!\n\x0c\n\x05\x04\x06\x02\x0c\x03\x12\x03Z$\
    &\n\x0b\n\x04\x04\x06\x02\r\x12\x03[\x08-\n\x0c\n\x05\x04\x06\x02\r\x04\
    \x12\x03[\x08\x10\n\x0c\n\x05\x04\x06\x02\r\x05\x12\x03[\x11\x15\n\x0c\n\
    \x05\x04\x06\x02\r\x01\x12\x03[\x16'\n\x0c\n\x05\x04\x06\x02\r\x03\x12\
    \x03[*,\n\x0b\n\x04\x04\x06\x02\x0e\x12\x03\\\x080\n\x0c\n\x05\x04\x06\
    \x02\x0e\x04\x12\x03\\\x08\x10\n\x0c\n\x05\x04\x06\x02\x0e\x05\x12\x03\\\
    \x11\x17\n\x0c\n\x05\x04\x06\x02\x0e\x01\x12\x03\\\x18*\n\x0c\n\x05\x04\
    \x06\x02\x0e\x03\x12\x03\\-/\n\x0b\n\x04\x04\x06\x02\x0f\x12\x03]\x08&\n\
    \x0c\n\x05\x04\x06\x02\x0f\x04\x12\x03]\x08\x10\n\x0c\n\x05\x04\x06\x02\
    \x0f\x05\x12\x03]\x11\x15\n\x0c\n\x05\x04\x06\x02\x0f\x01\x12\x03]\x16\
    \x20\n\x0c\n\x05\x04\x06\x02\x0f\x03\x12\x03]#%\n\x0b\n\x04\x04\x06\x02\
    \x10\x12\x03^\x08!\n\x0c\n\x05\x04\x06\x02\x10\x04\x12\x03^\x08\x10\n\
    \x0c\n\x05\x04\x06\x02\x10\x05\x12\x03^\x11\x17\n\x0c\n\x05\x04\x06\x02\
    \x10\x01\x12\x03^\x18\x1b\n\x0c\n\x05\x04\x06\x02\x10\x03\x12\x03^\x1e\
    \x20\n\x0b\n\x04\x04\x06\x02\x11\x12\x03_\x083\n\x0c\n\x05\x04\x06\x02\
    \x11\x04\x12\x03_\x08\x10\n\x0c\n\x05\x04\x06\x02\x11\x05\x12\x03_\x11\
    \x15\n\x0c\n\x05\x04\x06\x02\x11\x01\x12\x03_\x16-\n\x0c\n\x05\x04\x06\
    \x02\x11\x03\x12\x03_02\n\x0b\n\x04\x04\x06\x02\x12\x12\x03`\x08/\n\x0c\
    \n\x05\x04\x06\x02\x12\x04\x12\x03`\x08\x10\n\x0c\n\x05\x04\x06\x02\x12\
    \x05\x12\x03`\x11\x18\n\x0c\n\x05\x04\x06\x02\x12\x01\x12\x03`\x19)\n\
    \x0c\n\x05\x04\x06\x02\x12\x03\x12\x03`,.\n\x0b\n\x04\x04\x06\x02\x13\
    \x12\x03a\x08&\n\x0c\n\x05\x04\x06\x02\x13\x04\x12\x03a\x08\x10\n\x0c\n\
    \x05\x04\x06\x02\x13\x05\x12\x03a\x11\x17\n\x0c\n\x05\x04\x06\x02\x13\
    \x01\x12\x03a\x18\x20\n\x0c\n\x05\x04\x06\x02\x13\x03\x12\x03a#%\n\x0b\n\
    \x04\x04\x06\x02\x14\x12\x03b\x08+\n\x0c\n\x05\x04\x06\x02\x14\x04\x12\
    \x03b\x08\x10\n\x0c\n\x05\x04\x06\x02\x14\x05\x12\x03b\x11\x15\n\x0c\n\
    \x05\x04\x06\x02\x14\x01\x12\x03b\x16%\n\x0c\n\x05\x04\x06\x02\x14\x03\
    \x12\x03b(*\n\x0b\n\x04\x04\x06\x02\x15\x12\x03c\x083\n\x0c\n\x05\x04\
    \x06\x02\x15\x04\x12\x03c\x08\x10\n\x0c\n\x05\x04\x06\x02\x15\x05\x12\
    \x03c\x11\x16\n\x0c\n\x05\x04\x06\x02\x15\x01\x12\x03c\x17\x1f\n\x0c\n\
    \x05\x04\x06\x02\x15\x03\x12\x03c\"$\n\x0c\n\x05\x04\x06\x02\x15\x08\x12\
    \x03c%2\n\x0c\n\x05\x04\x06\x02\x15\x07\x12\x03c01\n\x0b\n\x04\x04\x06\
    \x02\x16\x12\x03d\x08,\n\x0c\n\x05\x04\x06\x02\x16\x04\x12\x03d\x08\x10\
    \n\x0c\n\x05\x04\x06\x02\x16\x05\x12\x03d\x11\x17\n\x0c\n\x05\x04\x06\
    \x02\x16\x01\x12\x03d\x18&\n\x0c\n\x05\x04\x06\x02\x16\x03\x12\x03d)+\n\
    \x0b\n\x04\x04\x06\x02\x17\x12\x03e\x08K\n\x0c\n\x05\x04\x06\x02\x17\x04\
    \x12\x03e\x08\x10\n\x0c\n\x05\x04\x06\x02\x17\x06\x12\x03e\x11>\n\x0c\n\
    \x05\x04\x06\x02\x17\x01\x12\x03e?E\n\x0c\n\x05\x04\x06\x02\x17\x03\x12\
    \x03eHJ\n\x0b\n\x04\x04\x06\x02\x18\x12\x03f\x08S\n\x0c\n\x05\x04\x06\
    \x02\x18\x04\x12\x03f\x08\x10\n\x0c\n\x05\x04\x06\x02\x18\x06\x12\x03f\
    \x11D\n\x0c\n\x05\x04\x06\x02\x18\x01\x12\x03fEM\n\x0c\n\x05\x04\x06\x02\
    \x18\x03\x12\x03fPR\n\x0b\n\x04\x04\x06\x02\x19\x12\x03g\x08/\n\x0c\n\
    \x05\x04\x06\x02\x19\x04\x12\x03g\x08\x10\n\x0c\n\x05\x04\x06\x02\x19\
    \x05\x12\x03g\x11\x16\n\x0c\n\x05\x04\x06\x02\x19\x01\x12\x03g\x17)\n\
    \x0c\n\x05\x04\x06\x02\x19\x03\x12\x03g,.\n\x0b\n\x04\x04\x06\x02\x1a\
    \x12\x03h\x08-\n\x0c\n\x05\x04\x06\x02\x1a\x04\x12\x03h\x08\x10\n\x0c\n\
    \x05\x04\x06\x02\x1a\x05\x12\x03h\x11\x15\n\x0c\n\x05\x04\x06\x02\x1a\
    \x01\x12\x03h\x16'\n\x0c\n\x05\x04\x06\x02\x1a\x03\x12\x03h*,\n\x0b\n\
    \x04\x04\x06\x02\x1b\x12\x03i\x08-\n\x0c\n\x05\x04\x06\x02\x1b\x04\x12\
    \x03i\x08\x10\n\x0c\n\x05\x04\x06\x02\x1b\x05\x12\x03i\x11\x15\n\x0c\n\
    \x05\x04\x06\x02\x1b\x01\x12\x03i\x16'\n\x0c\n\x05\x04\x06\x02\x1b\x03\
    \x12\x03i*,\n\n\n\x02\x04\x07\x12\x04l\0o\x01\n\n\n\x03\x04\x07\x01\x12\
    \x03l\x080\n\x0b\n\x04\x04\x07\x02\0\x12\x03m\x081\n\x0c\n\x05\x04\x07\
    \x02\0\x04\x12\x03m\x08\x10\n\x0c\n\x05\x04\x07\x02\0\x05\x12\x03m\x11\
    \x16\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03m\x17\x1e\n\x0c\n\x05\x04\x07\
    \x02\0\x03\x12\x03m!\"\n\x0c\n\x05\x04\x07\x02\0\x08\x12\x03m#0\n\x0c\n\
    \x05\x04\x07\x02\0\x07\x12\x03m./\n\x0b\n\x04\x04\x07\x02\x01\x12\x03n\
    \x08V\n\x0c\n\x05\x04\x07\x02\x01\x04\x12\x03n\x08\x10\n\x0c\n\x05\x04\
    \x07\x02\x01\x05\x12\x03n\x11\x15\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\
    \x03n\x16?\n\x0c\n\x05\x04\x07\x02\x01\x03\x12\x03nBC\n\x0c\n\x05\x04\
    \x07\x02\x01\x08\x12\x03nDU\n\x0c\n\x05\x04\x07\x02\x01\x07\x12\x03nOT\n\
    \n\n\x02\x04\x08\x12\x04q\0t\x01\n\n\n\x03\x04\x08\x01\x12\x03q\x08(\n\
    \x0b\n\x04\x04\x08\x02\0\x12\x03r\x08/\n\x0c\n\x05\x04\x08\x02\0\x04\x12\
    \x03r\x08\x10\n\x0c\n\x05\x04\x08\x02\0\x05\x12\x03r\x11\x18\n\x0c\n\x05\
    \x04\x08\x02\0\x01\x12\x03r\x19*\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03r-\
    .\n\x0b\n\x04\x04\x08\x02\x01\x12\x03s\x08#\n\x0c\n\x05\x04\x08\x02\x01\
    \x04\x12\x03s\x08\x10\n\x0c\n\x05\x04\x08\x02\x01\x05\x12\x03s\x11\x17\n\
    \x0c\n\x05\x04\x08\x02\x01\x01\x12\x03s\x18\x1e\n\x0c\n\x05\x04\x08\x02\
    \x01\x03\x12\x03s!\"\n\n\n\x02\x04\t\x12\x04v\0x\x01\n\n\n\x03\x04\t\x01\
    \x12\x03v\x080\n\x0b\n\x04\x04\t\x02\0\x12\x03w\x081\n\x0c\n\x05\x04\t\
    \x02\0\x04\x12\x03w\x08\x10\n\x0c\n\x05\x04\t\x02\0\x05\x12\x03w\x11\x16\
    \n\x0c\n\x05\x04\t\x02\0\x01\x12\x03w\x17\x1e\n\x0c\n\x05\x04\t\x02\0\
    \x03\x12\x03w!\"\n\x0c\n\x05\x04\t\x02\0\x08\x12\x03w#0\n\x0c\n\x05\x04\
    \t\x02\0\x07\x12\x03w./\n\n\n\x02\x04\n\x12\x04z\0~\x01\n\n\n\x03\x04\n\
    \x01\x12\x03z\x080\n\x0b\n\x04\x04\n\x02\0\x12\x03{\x08#\n\x0c\n\x05\x04\
    \n\x02\0\x04\x12\x03{\x08\x10\n\x0c\n\x05\x04\n\x02\0\x05\x12\x03{\x11\
    \x17\n\x0c\n\x05\x04\n\x02\0\x01\x12\x03{\x18\x1e\n\x0c\n\x05\x04\n\x02\
    \0\x03\x12\x03{!\"\n\x0b\n\x04\x04\n\x02\x01\x12\x03|\x08(\n\x0c\n\x05\
    \x04\n\x02\x01\x04\x12\x03|\x08\x10\n\x0c\n\x05\x04\n\x02\x01\x05\x12\
    \x03|\x11\x17\n\x0c\n\x05\x04\n\x02\x01\x01\x12\x03|\x18#\n\x0c\n\x05\
    \x04\n\x02\x01\x03\x12\x03|&'\n\x0b\n\x04\x04\n\x02\x02\x12\x03}\x08'\n\
    \x0c\n\x05\x04\n\x02\x02\x04\x12\x03}\x08\x10\n\x0c\n\x05\x04\n\x02\x02\
    \x05\x12\x03}\x11\x17\n\x0c\n\x05\x04\n\x02\x02\x01\x12\x03}\x18\"\n\x0c\
    \n\x05\x04\n\x02\x02\x03\x12\x03}%&\n\x0c\n\x02\x04\x0b\x12\x06\x80\x01\
    \0\x88\x01\x01\n\x0b\n\x03\x04\x0b\x01\x12\x04\x80\x01\x088\n\x0e\n\x04\
    \x04\x0b\x03\0\x12\x06\x81\x01\x08\x83\x01\t\n\r\n\x05\x04\x0b\x03\0\x01\
    \x12\x04\x81\x01\x10\x1f\n\x0e\n\x06\x04\x0b\x03\0\x02\0\x12\x04\x82\x01\
    \x107\n\x0f\n\x07\x04\x0b\x03\0\x02\0\x04\x12\x04\x82\x01\x10\x18\n\x0f\
    \n\x07\x04\x0b\x03\0\x02\0\x05\x12\x04\x82\x01\x19\x20\n\x0f\n\x07\x04\
    \x0b\x03\0\x02\0\x01\x12\x04\x82\x01!2\n\x0f\n\x07\x04\x0b\x03\0\x02\0\
    \x03\x12\x04\x82\x0156\n\x0c\n\x04\x04\x0b\x02\0\x12\x04\x85\x01\x081\n\
    \r\n\x05\x04\x0b\x02\0\x04\x12\x04\x85\x01\x08\x10\n\r\n\x05\x04\x0b\x02\
    \0\x05\x12\x04\x85\x01\x11\x16\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\x85\
    \x01\x17\x1e\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\x85\x01!\"\n\r\n\x05\
    \x04\x0b\x02\0\x08\x12\x04\x85\x01#0\n\r\n\x05\x04\x0b\x02\0\x07\x12\x04\
    \x85\x01./\n\x0c\n\x04\x04\x0b\x02\x01\x12\x04\x86\x01\x08g\n\r\n\x05\
    \x04\x0b\x02\x01\x04\x12\x04\x86\x01\x08\x10\n\r\n\x05\x04\x0b\x02\x01\
    \x06\x12\x04\x86\x01\x11R\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\x86\x01S\
    b\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\x86\x01ef\n\x0c\n\x04\x04\x0b\
    \x02\x02\x12\x04\x87\x01\x08*\n\r\n\x05\x04\x0b\x02\x02\x04\x12\x04\x87\
    \x01\x08\x10\n\r\n\x05\x04\x0b\x02\x02\x05\x12\x04\x87\x01\x11\x17\n\r\n\
    \x05\x04\x0b\x02\x02\x01\x12\x04\x87\x01\x18%\n\r\n\x05\x04\x0b\x02\x02\
    \x03\x12\x04\x87\x01()\n\x0c\n\x02\x04\x0c\x12\x06\x8a\x01\0\x90\x01\x01\
    \n\x0b\n\x03\x04\x0c\x01\x12\x04\x8a\x01\x081\n\x0c\n\x04\x04\x0c\x02\0\
    \x12\x04\x8b\x01\x08#\n\r\n\x05\x04\x0c\x02\0\x04\x12\x04\x8b\x01\x08\
    \x10\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\x8b\x01\x11\x17\n\r\n\x05\x04\
    \x0c\x02\0\x01\x12\x04\x8b\x01\x18\x1e\n\r\n\x05\x04\x0c\x02\0\x03\x12\
    \x04\x8b\x01!\"\n\x0c\n\x04\x04\x0c\x02\x01\x12\x04\x8c\x01\x08(\n\r\n\
    \x05\x04\x0c\x02\x01\x04\x12\x04\x8c\x01\x08\x10\n\r\n\x05\x04\x0c\x02\
    \x01\x05\x12\x04\x8c\x01\x11\x17\n\r\n\x05\x04\x0c\x02\x01\x01\x12\x04\
    \x8c\x01\x18#\n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\x8c\x01&'\n\x0c\n\
    \x04\x04\x0c\x02\x02\x12\x04\x8d\x01\x084\n\r\n\x05\x04\x0c\x02\x02\x04\
    \x12\x04\x8d\x01\x08\x10\n\r\n\x05\x04\x0c\x02\x02\x05\x12\x04\x8d\x01\
    \x11\x17\n\r\n\x05\x04\x0c\x02\x02\x01\x12\x04\x8d\x01\x18!\n\r\n\x05\
    \x04\x0c\x02\x02\x03\x12\x04\x8d\x01$%\n\r\n\x05\x04\x0c\x02\x02\x08\x12\
    \x04\x8d\x01&3\n\r\n\x05\x04\x0c\x02\x02\x07\x12\x04\x8d\x0112\n\x0c\n\
    \x04\x04\x0c\x02\x03\x12\x04\x8e\x01\x08=\n\r\n\x05\x04\x0c\x02\x03\x04\
    \x12\x04\x8e\x01\x08\x10\n\r\n\x05\x04\x0c\x02\x03\x05\x12\x04\x8e\x01\
    \x11\x17\n\r\n\x05\x04\x0c\x02\x03\x01\x12\x04\x8e\x01\x18*\n\r\n\x05\
    \x04\x0c\x02\x03\x03\x12\x04\x8e\x01-.\n\r\n\x05\x04\x0c\x02\x03\x08\x12\
    \x04\x8e\x01/<\n\r\n\x05\x04\x0c\x02\x03\x07\x12\x04\x8e\x01:;\n\x0c\n\
    \x04\x04\x0c\x02\x04\x12\x04\x8f\x01\x081\n\r\n\x05\x04\x0c\x02\x04\x04\
    \x12\x04\x8f\x01\x08\x10\n\r\n\x05\x04\x0c\x02\x04\x05\x12\x04\x8f\x01\
    \x11\x17\n\r\n\x05\x04\x0c\x02\x04\x01\x12\x04\x8f\x01\x18\x1d\n\r\n\x05\
    \x04\x0c\x02\x04\x03\x12\x04\x8f\x01\x20!\n\r\n\x05\x04\x0c\x02\x04\x08\
    \x12\x04\x8f\x01\"0\n\r\n\x05\x04\x0c\x02\x04\x07\x12\x04\x8f\x01-/\n\
    \x0c\n\x02\x04\r\x12\x06\x92\x01\0\x9b\x01\x01\n\x0b\n\x03\x04\r\x01\x12\
    \x04\x92\x01\x089\n\x0e\n\x04\x04\r\x03\0\x12\x06\x93\x01\x08\x96\x01\t\
    \n\r\n\x05\x04\r\x03\0\x01\x12\x04\x93\x01\x10\x1f\n\x0e\n\x06\x04\r\x03\
    \0\x02\0\x12\x04\x94\x01\x107\n\x0f\n\x07\x04\r\x03\0\x02\0\x04\x12\x04\
    \x94\x01\x10\x18\n\x0f\n\x07\x04\r\x03\0\x02\0\x05\x12\x04\x94\x01\x19\
    \x20\n\x0f\n\x07\x04\r\x03\0\x02\0\x01\x12\x04\x94\x01!2\n\x0f\n\x07\x04\
    \r\x03\0\x02\0\x03\x12\x04\x94\x0156\n\x0e\n\x06\x04\r\x03\0\x02\x01\x12\
    \x04\x95\x01\x10F\n\x0f\n\x07\x04\r\x03\0\x02\x01\x04\x12\x04\x95\x01\
    \x10\x18\n\x0f\n\x07\x04\r\x03\0\x02\x01\x05\x12\x04\x95\x01\x19\x20\n\
    \x0f\n\x07\x04\r\x03\0\x02\x01\x01\x12\x04\x95\x01!3\n\x0f\n\x07\x04\r\
    \x03\0\x02\x01\x03\x12\x04\x95\x0167\n\x0f\n\x07\x04\r\x03\0\x02\x01\x08\
    \x12\x04\x95\x018E\n\x0f\n\x07\x04\r\x03\0\x02\x01\x07\x12\x04\x95\x01CD\
    \n\x0c\n\x04\x04\r\x02\0\x12\x04\x98\x01\x081\n\r\n\x05\x04\r\x02\0\x04\
    \x12\x04\x98\x01\x08\x10\n\r\n\x05\x04\r\x02\0\x05\x12\x04\x98\x01\x11\
    \x16\n\r\n\x05\x04\r\x02\0\x01\x12\x04\x98\x01\x17\x1e\n\r\n\x05\x04\r\
    \x02\0\x03\x12\x04\x98\x01!\"\n\r\n\x05\x04\r\x02\0\x08\x12\x04\x98\x01#\
    0\n\r\n\x05\x04\r\x02\0\x07\x12\x04\x98\x01./\n\x0c\n\x04\x04\r\x02\x01\
    \x12\x04\x99\x01\x08i\n\r\n\x05\x04\r\x02\x01\x04\x12\x04\x99\x01\x08\
    \x10\n\r\n\x05\x04\r\x02\x01\x06\x12\x04\x99\x01\x11S\n\r\n\x05\x04\r\
    \x02\x01\x01\x12\x04\x99\x01Td\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\x99\
    \x01gh\n\x0c\n\x04\x04\r\x02\x02\x12\x04\x9a\x01\x08*\n\r\n\x05\x04\r\
    \x02\x02\x04\x12\x04\x9a\x01\x08\x10\n\r\n\x05\x04\r\x02\x02\x05\x12\x04\
    \x9a\x01\x11\x17\n\r\n\x05\x04\r\x02\x02\x01\x12\x04\x9a\x01\x18%\n\r\n\
    \x05\x04\r\x02\x02\x03\x12\x04\x9a\x01()\n\x0c\n\x02\x04\x0e\x12\x06\x9d\
    \x01\0\xa2\x01\x01\n\x0b\n\x03\x04\x0e\x01\x12\x04\x9d\x01\x08<\n\x0c\n\
    \x04\x04\x0e\x02\0\x12\x04\x9e\x01\x08#\n\r\n\x05\x04\x0e\x02\0\x04\x12\
    \x04\x9e\x01\x08\x10\n\r\n\x05\x04\x0e\x02\0\x05\x12\x04\x9e\x01\x11\x17\
    \n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\x9e\x01\x18\x1e\n\r\n\x05\x04\x0e\
    \x02\0\x03\x12\x04\x9e\x01!\"\n\x0c\n\x04\x04\x0e\x02\x01\x12\x04\x9f\
    \x01\x08(\n\r\n\x05\x04\x0e\x02\x01\x04\x12\x04\x9f\x01\x08\x10\n\r\n\
    \x05\x04\x0e\x02\x01\x05\x12\x04\x9f\x01\x11\x17\n\r\n\x05\x04\x0e\x02\
    \x01\x01\x12\x04\x9f\x01\x18#\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\x9f\
    \x01&'\n\x0c\n\x04\x04\x0e\x02\x02\x12\x04\xa0\x01\x08(\n\r\n\x05\x04\
    \x0e\x02\x02\x04\x12\x04\xa0\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x02\x05\
    \x12\x04\xa0\x01\x11\x18\n\r\n\x05\x04\x0e\x02\x02\x01\x12\x04\xa0\x01\
    \x19#\n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\xa0\x01&'\n\x0c\n\x04\x04\
    \x0e\x02\x03\x12\x04\xa1\x01\x08;\n\r\n\x05\x04\x0e\x02\x03\x04\x12\x04\
    \xa1\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x03\x05\x12\x04\xa1\x01\x11\x17\n\
    \r\n\x05\x04\x0e\x02\x03\x01\x12\x04\xa1\x01\x18(\n\r\n\x05\x04\x0e\x02\
    \x03\x03\x12\x04\xa1\x01+,\n\r\n\x05\x04\x0e\x02\x03\x08\x12\x04\xa1\x01\
    -:\n\r\n\x05\x04\x0e\x02\x03\x07\x12\x04\xa1\x0189\n\x0c\n\x02\x04\x0f\
    \x12\x06\xa4\x01\0\xb2\x01\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\xa4\x01\
    \x08D\n\x0e\n\x04\x04\x0f\x03\0\x12\x06\xa5\x01\x08\xad\x01\t\n\r\n\x05\
    \x04\x0f\x03\0\x01\x12\x04\xa5\x01\x10\x1f\n\x0e\n\x06\x04\x0f\x03\0\x02\
    \0\x12\x04\xa6\x01\x107\n\x0f\n\x07\x04\x0f\x03\0\x02\0\x04\x12\x04\xa6\
    \x01\x10\x18\n\x0f\n\x07\x04\x0f\x03\0\x02\0\x05\x12\x04\xa6\x01\x19\x20\
    \n\x0f\n\x07\x04\x0f\x03\0\x02\0\x01\x12\x04\xa6\x01!2\n\x0f\n\x07\x04\
    \x0f\x03\0\x02\0\x03\x12\x04\xa6\x0156\n\x0e\n\x06\x04\x0f\x03\0\x02\x01\
    \x12\x04\xa7\x01\x10F\n\x0f\n\x07\x04\x0f\x03\0\x02\x01\x04\x12\x04\xa7\
    \x01\x10\x18\n\x0f\n\x07\x04\x0f\x03\0\x02\x01\x05\x12\x04\xa7\x01\x19\
    \x20\n\x0f\n\x07\x04\x0f\x03\0\x02\x01\x01\x12\x04\xa7\x01!3\n\x0f\n\x07\
    \x04\x0f\x03\0\x02\x01\x03\x12\x04\xa7\x0167\n\x0f\n\x07\x04\x0f\x03\0\
    \x02\x01\x08\x12\x04\xa7\x018E\n\x0f\n\x07\x04\x0f\x03\0\x02\x01\x07\x12\
    \x04\xa7\x01CD\n\x0e\n\x06\x04\x0f\x03\0\x02\x02\x12\x04\xa8\x01\x10*\n\
    \x0f\n\x07\x04\x0f\x03\0\x02\x02\x04\x12\x04\xa8\x01\x10\x18\n\x0f\n\x07\
    \x04\x0f\x03\0\x02\x02\x05\x12\x04\xa8\x01\x19\x1f\n\x0f\n\x07\x04\x0f\
    \x03\0\x02\x02\x01\x12\x04\xa8\x01\x20%\n\x0f\n\x07\x04\x0f\x03\0\x02\
    \x02\x03\x12\x04\xa8\x01()\n\x0e\n\x06\x04\x0f\x03\0\x02\x03\x12\x04\xa9\
    \x01\x103\n\x0f\n\x07\x04\x0f\x03\0\x02\x03\x04\x12\x04\xa9\x01\x10\x18\
    \n\x0f\n\x07\x04\x0f\x03\0\x02\x03\x05\x12\x04\xa9\x01\x19\x20\n\x0f\n\
    \x07\x04\x0f\x03\0\x02\x03\x01\x12\x04\xa9\x01!.\n\x0f\n\x07\x04\x0f\x03\
    \0\x02\x03\x03\x12\x04\xa9\x0112\n\x0e\n\x06\x04\x0f\x03\0\x02\x04\x12\
    \x04\xaa\x01\x10.\n\x0f\n\x07\x04\x0f\x03\0\x02\x04\x04\x12\x04\xaa\x01\
    \x10\x18\n\x0f\n\x07\x04\x0f\x03\0\x02\x04\x05\x12\x04\xaa\x01\x19\x1f\n\
    \x0f\n\x07\x04\x0f\x03\0\x02\x04\x01\x12\x04\xaa\x01\x20)\n\x0f\n\x07\
    \x04\x0f\x03\0\x02\x04\x03\x12\x04\xaa\x01,-\n\x0e\n\x06\x04\x0f\x03\0\
    \x02\x05\x12\x04\xab\x01\x10:\n\x0f\n\x07\x04\x0f\x03\0\x02\x05\x04\x12\
    \x04\xab\x01\x10\x18\n\x0f\n\x07\x04\x0f\x03\0\x02\x05\x05\x12\x04\xab\
    \x01\x19\x20\n\x0f\n\x07\x04\x0f\x03\0\x02\x05\x01\x12\x04\xab\x01!5\n\
    \x0f\n\x07\x04\x0f\x03\0\x02\x05\x03\x12\x04\xab\x0189\n\x0e\n\x06\x04\
    \x0f\x03\0\x02\x06\x12\x04\xac\x01\x103\n\x0f\n\x07\x04\x0f\x03\0\x02\
    \x06\x04\x12\x04\xac\x01\x10\x18\n\x0f\n\x07\x04\x0f\x03\0\x02\x06\x05\
    \x12\x04\xac\x01\x19\x1d\n\x0f\n\x07\x04\x0f\x03\0\x02\x06\x01\x12\x04\
    \xac\x01\x1e.\n\x0f\n\x07\x04\x0f\x03\0\x02\x06\x03\x12\x04\xac\x0112\n\
    \x0c\n\x04\x04\x0f\x02\0\x12\x04\xaf\x01\x081\n\r\n\x05\x04\x0f\x02\0\
    \x04\x12\x04\xaf\x01\x08\x10\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\xaf\x01\
    \x11\x16\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xaf\x01\x17\x1e\n\r\n\x05\
    \x04\x0f\x02\0\x03\x12\x04\xaf\x01!\"\n\r\n\x05\x04\x0f\x02\0\x08\x12\
    \x04\xaf\x01#0\n\r\n\x05\x04\x0f\x02\0\x07\x12\x04\xaf\x01./\n\x0c\n\x04\
    \x04\x0f\x02\x01\x12\x04\xb0\x01\x08t\n\r\n\x05\x04\x0f\x02\x01\x04\x12\
    \x04\xb0\x01\x08\x10\n\r\n\x05\x04\x0f\x02\x01\x06\x12\x04\xb0\x01\x11^\
    \n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\xb0\x01_o\n\r\n\x05\x04\x0f\x02\
    \x01\x03\x12\x04\xb0\x01rs\n\x0c\n\x04\x04\x0f\x02\x02\x12\x04\xb1\x01\
    \x08*\n\r\n\x05\x04\x0f\x02\x02\x04\x12\x04\xb1\x01\x08\x10\n\r\n\x05\
    \x04\x0f\x02\x02\x05\x12\x04\xb1\x01\x11\x17\n\r\n\x05\x04\x0f\x02\x02\
    \x01\x12\x04\xb1\x01\x18%\n\r\n\x05\x04\x0f\x02\x02\x03\x12\x04\xb1\x01(\
    )\n\x0c\n\x02\x04\x10\x12\x06\xb4\x01\0\xbc\x01\x01\n\x0b\n\x03\x04\x10\
    \x01\x12\x04\xb4\x01\x08)\n\x0c\n\x04\x04\x10\x02\0\x12\x04\xb5\x01\x08/\
    \n\r\n\x05\x04\x10\x02\0\x04\x12\x04\xb5\x01\x08\x10\n\r\n\x05\x04\x10\
    \x02\0\x05\x12\x04\xb5\x01\x11\x18\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\
    \xb5\x01\x19*\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xb5\x01-.\n\x0c\n\x04\
    \x04\x10\x02\x01\x12\x04\xb6\x01\x08#\n\r\n\x05\x04\x10\x02\x01\x04\x12\
    \x04\xb6\x01\x08\x10\n\r\n\x05\x04\x10\x02\x01\x05\x12\x04\xb6\x01\x11\
    \x17\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\xb6\x01\x18\x1e\n\r\n\x05\x04\
    \x10\x02\x01\x03\x12\x04\xb6\x01!\"\n\x0c\n\x04\x04\x10\x02\x02\x12\x04\
    \xb7\x01\x08)\n\r\n\x05\x04\x10\x02\x02\x04\x12\x04\xb7\x01\x08\x10\n\r\
    \n\x05\x04\x10\x02\x02\x05\x12\x04\xb7\x01\x11\x17\n\r\n\x05\x04\x10\x02\
    \x02\x01\x12\x04\xb7\x01\x18$\n\r\n\x05\x04\x10\x02\x02\x03\x12\x04\xb7\
    \x01'(\n\x0c\n\x04\x04\x10\x02\x03\x12\x04\xb8\x01\x08&\n\r\n\x05\x04\
    \x10\x02\x03\x04\x12\x04\xb8\x01\x08\x10\n\r\n\x05\x04\x10\x02\x03\x05\
    \x12\x04\xb8\x01\x11\x18\n\r\n\x05\x04\x10\x02\x03\x01\x12\x04\xb8\x01\
    \x19!\n\r\n\x05\x04\x10\x02\x03\x03\x12\x04\xb8\x01$%\n\x0c\n\x04\x04\
    \x10\x02\x04\x12\x04\xb9\x01\x08'\n\r\n\x05\x04\x10\x02\x04\x04\x12\x04\
    \xb9\x01\x08\x10\n\r\n\x05\x04\x10\x02\x04\x05\x12\x04\xb9\x01\x11\x18\n\
    \r\n\x05\x04\x10\x02\x04\x01\x12\x04\xb9\x01\x19\"\n\r\n\x05\x04\x10\x02\
    \x04\x03\x12\x04\xb9\x01%&\n\x0c\n\x04\x04\x10\x02\x05\x12\x04\xba\x01\
    \x08+\n\r\n\x05\x04\x10\x02\x05\x04\x12\x04\xba\x01\x08\x10\n\r\n\x05\
    \x04\x10\x02\x05\x05\x12\x04\xba\x01\x11\x15\n\r\n\x05\x04\x10\x02\x05\
    \x01\x12\x04\xba\x01\x16&\n\r\n\x05\x04\x10\x02\x05\x03\x12\x04\xba\x01)\
    *\n\x0c\n\x04\x04\x10\x02\x06\x12\x04\xbb\x01\x08%\n\r\n\x05\x04\x10\x02\
    \x06\x04\x12\x04\xbb\x01\x08\x10\n\r\n\x05\x04\x10\x02\x06\x05\x12\x04\
    \xbb\x01\x11\x17\n\r\n\x05\x04\x10\x02\x06\x01\x12\x04\xbb\x01\x18\x20\n\
    \r\n\x05\x04\x10\x02\x06\x03\x12\x04\xbb\x01#$\n\x0c\n\x02\x04\x11\x12\
    \x06\xbe\x01\0\xc2\x01\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\xbe\x01\x08,\
    \n\x0c\n\x04\x04\x11\x02\0\x12\x04\xbf\x01\x08#\n\r\n\x05\x04\x11\x02\0\
    \x04\x12\x04\xbf\x01\x08\x10\n\r\n\x05\x04\x11\x02\0\x05\x12\x04\xbf\x01\
    \x11\x17\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xbf\x01\x18\x1e\n\r\n\x05\
    \x04\x11\x02\0\x03\x12\x04\xbf\x01!\"\n\x0c\n\x04\x04\x11\x02\x01\x12\
    \x04\xc0\x01\x08.\n\r\n\x05\x04\x11\x02\x01\x04\x12\x04\xc0\x01\x08\x10\
    \n\r\n\x05\x04\x11\x02\x01\x05\x12\x04\xc0\x01\x11\x17\n\r\n\x05\x04\x11\
    \x02\x01\x01\x12\x04\xc0\x01\x18)\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\
    \xc0\x01,-\n\x0c\n\x04\x04\x11\x02\x02\x12\x04\xc1\x01\x08-\n\r\n\x05\
    \x04\x11\x02\x02\x04\x12\x04\xc1\x01\x08\x10\n\r\n\x05\x04\x11\x02\x02\
    \x05\x12\x04\xc1\x01\x11\x17\n\r\n\x05\x04\x11\x02\x02\x01\x12\x04\xc1\
    \x01\x18(\n\r\n\x05\x04\x11\x02\x02\x03\x12\x04\xc1\x01+,\n\x0c\n\x02\
    \x04\x12\x12\x06\xc4\x01\0\xce\x01\x01\n\x0b\n\x03\x04\x12\x01\x12\x04\
    \xc4\x01\x08-\n\x0e\n\x04\x04\x12\x03\0\x12\x06\xc5\x01\x08\xc9\x01\t\n\
    \r\n\x05\x04\x12\x03\0\x01\x12\x04\xc5\x01\x10\x20\n\x0e\n\x06\x04\x12\
    \x03\0\x02\0\x12\x04\xc6\x01\x107\n\x0f\n\x07\x04\x12\x03\0\x02\0\x04\
    \x12\x04\xc6\x01\x10\x18\n\x0f\n\x07\x04\x12\x03\0\x02\0\x05\x12\x04\xc6\
    \x01\x19\x20\n\x0f\n\x07\x04\x12\x03\0\x02\0\x01\x12\x04\xc6\x01!2\n\x0f\
    \n\x07\x04\x12\x03\0\x02\0\x03\x12\x04\xc6\x0156\n\x0e\n\x06\x04\x12\x03\
    \0\x02\x01\x12\x04\xc7\x01\x101\n\x0f\n\x07\x04\x12\x03\0\x02\x01\x04\
    \x12\x04\xc7\x01\x10\x18\n\x0f\n\x07\x04\x12\x03\0\x02\x01\x05\x12\x04\
    \xc7\x01\x19\x1f\n\x0f\n\x07\x04\x12\x03\0\x02\x01\x01\x12\x04\xc7\x01\
    \x20,\n\x0f\n\x07\x04\x12\x03\0\x02\x01\x03\x12\x04\xc7\x01/0\n\x0e\n\
    \x06\x04\x12\x03\0\x02\x02\x12\x04\xc8\x01\x101\n\x0f\n\x07\x04\x12\x03\
    \0\x02\x02\x04\x12\x04\xc8\x01\x10\x18\n\x0f\n\x07\x04\x12\x03\0\x02\x02\
    \x05\x12\x04\xc8\x01\x19\x20\n\x0f\n\x07\x04\x12\x03\0\x02\x02\x01\x12\
    \x04\xc8\x01!,\n\x0f\n\x07\x04\x12\x03\0\x02\x02\x03\x12\x04\xc8\x01/0\n\
    \x0c\n\x04\x04\x12\x02\0\x12\x04\xcb\x01\x081\n\r\n\x05\x04\x12\x02\0\
    \x04\x12\x04\xcb\x01\x08\x10\n\r\n\x05\x04\x12\x02\0\x05\x12\x04\xcb\x01\
    \x11\x16\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xcb\x01\x17\x1e\n\r\n\x05\
    \x04\x12\x02\0\x03\x12\x04\xcb\x01!\"\n\r\n\x05\x04\x12\x02\0\x08\x12\
    \x04\xcb\x01#0\n\r\n\x05\x04\x12\x02\0\x07\x12\x04\xcb\x01./\n\x0c\n\x04\
    \x04\x12\x02\x01\x12\x04\xcc\x01\x08(\n\r\n\x05\x04\x12\x02\x01\x04\x12\
    \x04\xcc\x01\x08\x10\n\r\n\x05\x04\x12\x02\x01\x05\x12\x04\xcc\x01\x11\
    \x17\n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\xcc\x01\x18#\n\r\n\x05\x04\
    \x12\x02\x01\x03\x12\x04\xcc\x01&'\n\x0c\n\x04\x04\x12\x02\x02\x12\x04\
    \xcd\x01\x08\\\n\r\n\x05\x04\x12\x02\x02\x04\x12\x04\xcd\x01\x08\x10\n\r\
    \n\x05\x04\x12\x02\x02\x06\x12\x04\xcd\x01\x11H\n\r\n\x05\x04\x12\x02\
    \x02\x01\x12\x04\xcd\x01IW\n\r\n\x05\x04\x12\x02\x02\x03\x12\x04\xcd\x01\
    Z[\n\x0c\n\x02\x04\x13\x12\x06\xd0\x01\0\xd9\x01\x01\n\x0b\n\x03\x04\x13\
    \x01\x12\x04\xd0\x01\x08)\n\x0e\n\x04\x04\x13\x03\0\x12\x06\xd1\x01\x08\
    \xd4\x01\t\n\r\n\x05\x04\x13\x03\0\x01\x12\x04\xd1\x01\x10\x1c\n\x0e\n\
    \x06\x04\x13\x03\0\x02\0\x12\x04\xd2\x01\x107\n\x0f\n\x07\x04\x13\x03\0\
    \x02\0\x04\x12\x04\xd2\x01\x10\x18\n\x0f\n\x07\x04\x13\x03\0\x02\0\x05\
    \x12\x04\xd2\x01\x19\x20\n\x0f\n\x07\x04\x13\x03\0\x02\0\x01\x12\x04\xd2\
    \x01!2\n\x0f\n\x07\x04\x13\x03\0\x02\0\x03\x12\x04\xd2\x0156\n\x0e\n\x06\
    \x04\x13\x03\0\x02\x01\x12\x04\xd3\x01\x101\n\x0f\n\x07\x04\x13\x03\0\
    \x02\x01\x04\x12\x04\xd3\x01\x10\x18\n\x0f\n\x07\x04\x13\x03\0\x02\x01\
    \x05\x12\x04\xd3\x01\x19\x1f\n\x0f\n\x07\x04\x13\x03\0\x02\x01\x01\x12\
    \x04\xd3\x01\x20,\n\x0f\n\x07\x04\x13\x03\0\x02\x01\x03\x12\x04\xd3\x01/\
    0\n\x0c\n\x04\x04\x13\x02\0\x12\x04\xd6\x01\x08#\n\r\n\x05\x04\x13\x02\0\
    \x04\x12\x04\xd6\x01\x08\x10\n\r\n\x05\x04\x13\x02\0\x05\x12\x04\xd6\x01\
    \x11\x17\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\xd6\x01\x18\x1e\n\r\n\x05\
    \x04\x13\x02\0\x03\x12\x04\xd6\x01!\"\n\x0c\n\x04\x04\x13\x02\x01\x12\
    \x04\xd7\x01\x08.\n\r\n\x05\x04\x13\x02\x01\x04\x12\x04\xd7\x01\x08\x10\
    \n\r\n\x05\x04\x13\x02\x01\x05\x12\x04\xd7\x01\x11\x17\n\r\n\x05\x04\x13\
    \x02\x01\x01\x12\x04\xd7\x01\x18)\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\
    \xd7\x01,-\n\x0c\n\x04\x04\x13\x02\x02\x12\x04\xd8\x01\x08T\n\r\n\x05\
    \x04\x13\x02\x02\x04\x12\x04\xd8\x01\x08\x10\n\r\n\x05\x04\x13\x02\x02\
    \x06\x12\x04\xd8\x01\x11@\n\r\n\x05\x04\x13\x02\x02\x01\x12\x04\xd8\x01A\
    O\n\r\n\x05\x04\x13\x02\x02\x03\x12\x04\xd8\x01RS\n\x0c\n\x02\x04\x14\
    \x12\x06\xdb\x01\0\xe7\x01\x01\n\x0b\n\x03\x04\x14\x01\x12\x04\xdb\x01\
    \x08*\n\x0e\n\x04\x04\x14\x03\0\x12\x06\xdc\x01\x08\xe1\x01\t\n\r\n\x05\
    \x04\x14\x03\0\x01\x12\x04\xdc\x01\x10\x20\n\x0e\n\x06\x04\x14\x03\0\x02\
    \0\x12\x04\xdd\x01\x107\n\x0f\n\x07\x04\x14\x03\0\x02\0\x04\x12\x04\xdd\
    \x01\x10\x18\n\x0f\n\x07\x04\x14\x03\0\x02\0\x05\x12\x04\xdd\x01\x19\x20\
    \n\x0f\n\x07\x04\x14\x03\0\x02\0\x01\x12\x04\xdd\x01!2\n\x0f\n\x07\x04\
    \x14\x03\0\x02\0\x03\x12\x04\xdd\x0156\n\x0e\n\x06\x04\x14\x03\0\x02\x01\
    \x12\x04\xde\x01\x101\n\x0f\n\x07\x04\x14\x03\0\x02\x01\x04\x12\x04\xde\
    \x01\x10\x18\n\x0f\n\x07\x04\x14\x03\0\x02\x01\x05\x12\x04\xde\x01\x19\
    \x1f\n\x0f\n\x07\x04\x14\x03\0\x02\x01\x01\x12\x04\xde\x01\x20,\n\x0f\n\
    \x07\x04\x14\x03\0\x02\x01\x03\x12\x04\xde\x01/0\n\x0e\n\x06\x04\x14\x03\
    \0\x02\x02\x12\x04\xdf\x01\x101\n\x0f\n\x07\x04\x14\x03\0\x02\x02\x04\
    \x12\x04\xdf\x01\x10\x18\n\x0f\n\x07\x04\x14\x03\0\x02\x02\x05\x12\x04\
    \xdf\x01\x19\x20\n\x0f\n\x07\x04\x14\x03\0\x02\x02\x01\x12\x04\xdf\x01!,\
    \n\x0f\n\x07\x04\x14\x03\0\x02\x02\x03\x12\x04\xdf\x01/0\n\x0e\n\x06\x04\
    \x14\x03\0\x02\x03\x12\x04\xe0\x01\x10,\n\x0f\n\x07\x04\x14\x03\0\x02\
    \x03\x04\x12\x04\xe0\x01\x10\x18\n\x0f\n\x07\x04\x14\x03\0\x02\x03\x05\
    \x12\x04\xe0\x01\x19\x1d\n\x0f\n\x07\x04\x14\x03\0\x02\x03\x01\x12\x04\
    \xe0\x01\x1e'\n\x0f\n\x07\x04\x14\x03\0\x02\x03\x03\x12\x04\xe0\x01*+\n\
    \x0c\n\x04\x04\x14\x02\0\x12\x04\xe3\x01\x081\n\r\n\x05\x04\x14\x02\0\
    \x04\x12\x04\xe3\x01\x08\x10\n\r\n\x05\x04\x14\x02\0\x05\x12\x04\xe3\x01\
    \x11\x16\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\xe3\x01\x17\x1e\n\r\n\x05\
    \x04\x14\x02\0\x03\x12\x04\xe3\x01!\"\n\r\n\x05\x04\x14\x02\0\x08\x12\
    \x04\xe3\x01#0\n\r\n\x05\x04\x14\x02\0\x07\x12\x04\xe3\x01./\n\x0c\n\x04\
    \x04\x14\x02\x01\x12\x04\xe4\x01\x08(\n\r\n\x05\x04\x14\x02\x01\x04\x12\
    \x04\xe4\x01\x08\x10\n\r\n\x05\x04\x14\x02\x01\x05\x12\x04\xe4\x01\x11\
    \x17\n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\xe4\x01\x18#\n\r\n\x05\x04\
    \x14\x02\x01\x03\x12\x04\xe4\x01&'\n\x0c\n\x04\x04\x14\x02\x02\x12\x04\
    \xe5\x01\x08Y\n\r\n\x05\x04\x14\x02\x02\x04\x12\x04\xe5\x01\x08\x10\n\r\
    \n\x05\x04\x14\x02\x02\x06\x12\x04\xe5\x01\x11E\n\r\n\x05\x04\x14\x02\
    \x02\x01\x12\x04\xe5\x01FT\n\r\n\x05\x04\x14\x02\x02\x03\x12\x04\xe5\x01\
    WX\n\x0c\n\x04\x04\x14\x02\x03\x12\x04\xe6\x01\x08+\n\r\n\x05\x04\x14\
    \x02\x03\x04\x12\x04\xe6\x01\x08\x10\n\r\n\x05\x04\x14\x02\x03\x05\x12\
    \x04\xe6\x01\x11\x18\n\r\n\x05\x04\x14\x02\x03\x01\x12\x04\xe6\x01\x19&\
    \n\r\n\x05\x04\x14\x02\x03\x03\x12\x04\xe6\x01)*\n\x0c\n\x02\x04\x15\x12\
    \x06\xe9\x01\0\xef\x01\x01\n\x0b\n\x03\x04\x15\x01\x12\x04\xe9\x01\x08-\
    \n\x0c\n\x04\x04\x15\x02\0\x12\x04\xea\x01\x08#\n\r\n\x05\x04\x15\x02\0\
    \x04\x12\x04\xea\x01\x08\x10\n\r\n\x05\x04\x15\x02\0\x05\x12\x04\xea\x01\
    \x11\x17\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\xea\x01\x18\x1e\n\r\n\x05\
    \x04\x15\x02\0\x03\x12\x04\xea\x01!\"\n\x0c\n\x04\x04\x15\x02\x01\x12\
    \x04\xeb\x01\x08.\n\r\n\x05\x04\x15\x02\x01\x04\x12\x04\xeb\x01\x08\x10\
    \n\r\n\x05\x04\x15\x02\x01\x05\x12\x04\xeb\x01\x11\x18\n\r\n\x05\x04\x15\
    \x02\x01\x01\x12\x04\xeb\x01\x19)\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\
    \xeb\x01,-\n\x0c\n\x04\x04\x15\x02\x02\x12\x04\xec\x01\x08*\n\r\n\x05\
    \x04\x15\x02\x02\x04\x12\x04\xec\x01\x08\x10\n\r\n\x05\x04\x15\x02\x02\
    \x05\x12\x04\xec\x01\x11\x17\n\r\n\x05\x04\x15\x02\x02\x01\x12\x04\xec\
    \x01\x18%\n\r\n\x05\x04\x15\x02\x02\x03\x12\x04\xec\x01()\n\x0c\n\x04\
    \x04\x15\x02\x03\x12\x04\xed\x01\x08*\n\r\n\x05\x04\x15\x02\x03\x04\x12\
    \x04\xed\x01\x08\x10\n\r\n\x05\x04\x15\x02\x03\x05\x12\x04\xed\x01\x11\
    \x17\n\r\n\x05\x04\x15\x02\x03\x01\x12\x04\xed\x01\x18%\n\r\n\x05\x04\
    \x15\x02\x03\x03\x12\x04\xed\x01()\n\x0c\n\x04\x04\x15\x02\x04\x12\x04\
    \xee\x01\x08(\n\r\n\x05\x04\x15\x02\x04\x04\x12\x04\xee\x01\x08\x10\n\r\
    \n\x05\x04\x15\x02\x04\x05\x12\x04\xee\x01\x11\x17\n\r\n\x05\x04\x15\x02\
    \x04\x01\x12\x04\xee\x01\x18#\n\r\n\x05\x04\x15\x02\x04\x03\x12\x04\xee\
    \x01&'\n\x0c\n\x02\x04\x16\x12\x06\xf1\x01\0\xf9\x01\x01\n\x0b\n\x03\x04\
    \x16\x01\x12\x04\xf1\x01\x085\n\x0e\n\x04\x04\x16\x03\0\x12\x06\xf2\x01\
    \x08\xf4\x01\t\n\r\n\x05\x04\x16\x03\0\x01\x12\x04\xf2\x01\x10\x1f\n\x0e\
    \n\x06\x04\x16\x03\0\x02\0\x12\x04\xf3\x01\x107\n\x0f\n\x07\x04\x16\x03\
    \0\x02\0\x04\x12\x04\xf3\x01\x10\x18\n\x0f\n\x07\x04\x16\x03\0\x02\0\x05\
    \x12\x04\xf3\x01\x19\x20\n\x0f\n\x07\x04\x16\x03\0\x02\0\x01\x12\x04\xf3\
    \x01!2\n\x0f\n\x07\x04\x16\x03\0\x02\0\x03\x12\x04\xf3\x0156\n\x0c\n\x04\
    \x04\x16\x02\0\x12\x04\xf6\x01\x081\n\r\n\x05\x04\x16\x02\0\x04\x12\x04\
    \xf6\x01\x08\x10\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\xf6\x01\x11\x16\n\r\
    \n\x05\x04\x16\x02\0\x01\x12\x04\xf6\x01\x17\x1e\n\r\n\x05\x04\x16\x02\0\
    \x03\x12\x04\xf6\x01!\"\n\r\n\x05\x04\x16\x02\0\x08\x12\x04\xf6\x01#0\n\
    \r\n\x05\x04\x16\x02\0\x07\x12\x04\xf6\x01./\n\x0c\n\x04\x04\x16\x02\x01\
    \x12\x04\xf7\x01\x08d\n\r\n\x05\x04\x16\x02\x01\x04\x12\x04\xf7\x01\x08\
    \x10\n\r\n\x05\x04\x16\x02\x01\x06\x12\x04\xf7\x01\x11O\n\r\n\x05\x04\
    \x16\x02\x01\x01\x12\x04\xf7\x01P_\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\
    \xf7\x01bc\n\x0c\n\x04\x04\x16\x02\x02\x12\x04\xf8\x01\x08*\n\r\n\x05\
    \x04\x16\x02\x02\x04\x12\x04\xf8\x01\x08\x10\n\r\n\x05\x04\x16\x02\x02\
    \x05\x12\x04\xf8\x01\x11\x17\n\r\n\x05\x04\x16\x02\x02\x01\x12\x04\xf8\
    \x01\x18%\n\r\n\x05\x04\x16\x02\x02\x03\x12\x04\xf8\x01()\n\x0c\n\x02\
    \x04\x17\x12\x06\xfb\x01\0\xff\x01\x01\n\x0b\n\x03\x04\x17\x01\x12\x04\
    \xfb\x01\x08/\n\x0c\n\x04\x04\x17\x02\0\x12\x04\xfc\x01\x08/\n\r\n\x05\
    \x04\x17\x02\0\x04\x12\x04\xfc\x01\x08\x10\n\r\n\x05\x04\x17\x02\0\x05\
    \x12\x04\xfc\x01\x11\x18\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xfc\x01\x19\
    *\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\xfc\x01-.\n\x0c\n\x04\x04\x17\x02\
    \x01\x12\x04\xfd\x01\x08#\n\r\n\x05\x04\x17\x02\x01\x04\x12\x04\xfd\x01\
    \x08\x10\n\r\n\x05\x04\x17\x02\x01\x05\x12\x04\xfd\x01\x11\x17\n\r\n\x05\
    \x04\x17\x02\x01\x01\x12\x04\xfd\x01\x18\x1e\n\r\n\x05\x04\x17\x02\x01\
    \x03\x12\x04\xfd\x01!\"\n\x0c\n\x04\x04\x17\x02\x02\x12\x04\xfe\x01\x08\
    \"\n\r\n\x05\x04\x17\x02\x02\x04\x12\x04\xfe\x01\x08\x10\n\r\n\x05\x04\
    \x17\x02\x02\x05\x12\x04\xfe\x01\x11\x16\n\r\n\x05\x04\x17\x02\x02\x01\
    \x12\x04\xfe\x01\x17\x1d\n\r\n\x05\x04\x17\x02\x02\x03\x12\x04\xfe\x01\
    \x20!\n\x0c\n\x02\x04\x18\x12\x06\x81\x02\0\x83\x02\x01\n\x0b\n\x03\x04\
    \x18\x01\x12\x04\x81\x02\x087\n\x0c\n\x04\x04\x18\x02\0\x12\x04\x82\x02\
    \x081\n\r\n\x05\x04\x18\x02\0\x04\x12\x04\x82\x02\x08\x10\n\r\n\x05\x04\
    \x18\x02\0\x05\x12\x04\x82\x02\x11\x16\n\r\n\x05\x04\x18\x02\0\x01\x12\
    \x04\x82\x02\x17\x1e\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\x82\x02!\"\n\r\
    \n\x05\x04\x18\x02\0\x08\x12\x04\x82\x02#0\n\r\n\x05\x04\x18\x02\0\x07\
    \x12\x04\x82\x02./\n\x0c\n\x02\x04\x19\x12\x06\x85\x02\0\x89\x02\x01\n\
    \x0b\n\x03\x04\x19\x01\x12\x04\x85\x02\x088\n\x0c\n\x04\x04\x19\x02\0\
    \x12\x04\x86\x02\x08#\n\r\n\x05\x04\x19\x02\0\x04\x12\x04\x86\x02\x08\
    \x10\n\r\n\x05\x04\x19\x02\0\x05\x12\x04\x86\x02\x11\x17\n\r\n\x05\x04\
    \x19\x02\0\x01\x12\x04\x86\x02\x18\x1e\n\r\n\x05\x04\x19\x02\0\x03\x12\
    \x04\x86\x02!\"\n\x0c\n\x04\x04\x19\x02\x01\x12\x04\x87\x02\x08(\n\r\n\
    \x05\x04\x19\x02\x01\x04\x12\x04\x87\x02\x08\x10\n\r\n\x05\x04\x19\x02\
    \x01\x05\x12\x04\x87\x02\x11\x17\n\r\n\x05\x04\x19\x02\x01\x01\x12\x04\
    \x87\x02\x18#\n\r\n\x05\x04\x19\x02\x01\x03\x12\x04\x87\x02&'\n\x0c\n\
    \x04\x04\x19\x02\x02\x12\x04\x88\x02\x08\"\n\r\n\x05\x04\x19\x02\x02\x04\
    \x12\x04\x88\x02\x08\x10\n\r\n\x05\x04\x19\x02\x02\x05\x12\x04\x88\x02\
    \x11\x16\n\r\n\x05\x04\x19\x02\x02\x01\x12\x04\x88\x02\x17\x1d\n\r\n\x05\
    \x04\x19\x02\x02\x03\x12\x04\x88\x02\x20!\n\x0c\n\x02\x04\x1a\x12\x06\
    \x8b\x02\0\x94\x02\x01\n\x0b\n\x03\x04\x1a\x01\x12\x04\x8b\x02\x08@\n\
    \x0e\n\x04\x04\x1a\x03\0\x12\x06\x8c\x02\x08\x8f\x02\t\n\r\n\x05\x04\x1a\
    \x03\0\x01\x12\x04\x8c\x02\x10\x1f\n\x0e\n\x06\x04\x1a\x03\0\x02\0\x12\
    \x04\x8d\x02\x107\n\x0f\n\x07\x04\x1a\x03\0\x02\0\x04\x12\x04\x8d\x02\
    \x10\x18\n\x0f\n\x07\x04\x1a\x03\0\x02\0\x05\x12\x04\x8d\x02\x19\x20\n\
    \x0f\n\x07\x04\x1a\x03\0\x02\0\x01\x12\x04\x8d\x02!2\n\x0f\n\x07\x04\x1a\
    \x03\0\x02\0\x03\x12\x04\x8d\x0256\n\x0e\n\x06\x04\x1a\x03\0\x02\x01\x12\
    \x04\x8e\x02\x10D\n\x0f\n\x07\x04\x1a\x03\0\x02\x01\x04\x12\x04\x8e\x02\
    \x10\x18\n\x0f\n\x07\x04\x1a\x03\0\x02\x01\x05\x12\x04\x8e\x02\x19\x20\n\
    \x0f\n\x07\x04\x1a\x03\0\x02\x01\x01\x12\x04\x8e\x02!1\n\x0f\n\x07\x04\
    \x1a\x03\0\x02\x01\x03\x12\x04\x8e\x0245\n\x0f\n\x07\x04\x1a\x03\0\x02\
    \x01\x08\x12\x04\x8e\x026C\n\x0f\n\x07\x04\x1a\x03\0\x02\x01\x07\x12\x04\
    \x8e\x02AB\n\x0c\n\x04\x04\x1a\x02\0\x12\x04\x91\x02\x081\n\r\n\x05\x04\
    \x1a\x02\0\x04\x12\x04\x91\x02\x08\x10\n\r\n\x05\x04\x1a\x02\0\x05\x12\
    \x04\x91\x02\x11\x16\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\x91\x02\x17\x1e\
    \n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\x91\x02!\"\n\r\n\x05\x04\x1a\x02\0\
    \x08\x12\x04\x91\x02#0\n\r\n\x05\x04\x1a\x02\0\x07\x12\x04\x91\x02./\n\
    \x0c\n\x04\x04\x1a\x02\x01\x12\x04\x92\x02\x08o\n\r\n\x05\x04\x1a\x02\
    \x01\x04\x12\x04\x92\x02\x08\x10\n\r\n\x05\x04\x1a\x02\x01\x06\x12\x04\
    \x92\x02\x11Z\n\r\n\x05\x04\x1a\x02\x01\x01\x12\x04\x92\x02[j\n\r\n\x05\
    \x04\x1a\x02\x01\x03\x12\x04\x92\x02mn\n\x0c\n\x04\x04\x1a\x02\x02\x12\
    \x04\x93\x02\x08*\n\r\n\x05\x04\x1a\x02\x02\x04\x12\x04\x93\x02\x08\x10\
    \n\r\n\x05\x04\x1a\x02\x02\x05\x12\x04\x93\x02\x11\x17\n\r\n\x05\x04\x1a\
    \x02\x02\x01\x12\x04\x93\x02\x18%\n\r\n\x05\x04\x1a\x02\x02\x03\x12\x04\
    \x93\x02()\n\x0c\n\x02\x04\x1b\x12\x06\x96\x02\0\x97\x02\x01\n\x0b\n\x03\
    \x04\x1b\x01\x12\x04\x96\x02\x08$\n\x0c\n\x02\x04\x1c\x12\x06\x99\x02\0\
    \x9f\x02\x01\n\x0b\n\x03\x04\x1c\x01\x12\x04\x99\x02\x08$\n\x0c\n\x04\
    \x04\x1c\x02\0\x12\x04\x9a\x02\x08*\n\r\n\x05\x04\x1c\x02\0\x04\x12\x04\
    \x9a\x02\x08\x10\n\r\n\x05\x04\x1c\x02\0\x05\x12\x04\x9a\x02\x11\x18\n\r\
    \n\x05\x04\x1c\x02\0\x01\x12\x04\x9a\x02\x19%\n\r\n\x05\x04\x1c\x02\0\
    \x03\x12\x04\x9a\x02()\n\x0c\n\x04\x04\x1c\x02\x01\x12\x04\x9b\x02\x08$\
    \n\r\n\x05\x04\x1c\x02\x01\x04\x12\x04\x9b\x02\x08\x10\n\r\n\x05\x04\x1c\
    \x02\x01\x05\x12\x04\x9b\x02\x11\x18\n\r\n\x05\x04\x1c\x02\x01\x01\x12\
    \x04\x9b\x02\x19\x1f\n\r\n\x05\x04\x1c\x02\x01\x03\x12\x04\x9b\x02\"#\n\
    \x0c\n\x04\x04\x1c\x02\x02\x12\x04\x9c\x02\x08$\n\r\n\x05\x04\x1c\x02\
    \x02\x04\x12\x04\x9c\x02\x08\x10\n\r\n\x05\x04\x1c\x02\x02\x05\x12\x04\
    \x9c\x02\x11\x17\n\r\n\x05\x04\x1c\x02\x02\x01\x12\x04\x9c\x02\x18\x1f\n\
    \r\n\x05\x04\x1c\x02\x02\x03\x12\x04\x9c\x02\"#\n\x0c\n\x04\x04\x1c\x02\
    \x03\x12\x04\x9d\x02\x08&\n\r\n\x05\x04\x1c\x02\x03\x04\x12\x04\x9d\x02\
    \x08\x10\n\r\n\x05\x04\x1c\x02\x03\x05\x12\x04\x9d\x02\x11\x17\n\r\n\x05\
    \x04\x1c\x02\x03\x01\x12\x04\x9d\x02\x18!\n\r\n\x05\x04\x1c\x02\x03\x03\
    \x12\x04\x9d\x02$%\n\x0c\n\x04\x04\x1c\x02\x04\x12\x04\x9e\x02\x08!\n\r\
    \n\x05\x04\x1c\x02\x04\x04\x12\x04\x9e\x02\x08\x10\n\r\n\x05\x04\x1c\x02\
    \x04\x05\x12\x04\x9e\x02\x11\x16\n\r\n\x05\x04\x1c\x02\x04\x01\x12\x04\
    \x9e\x02\x17\x1c\n\r\n\x05\x04\x1c\x02\x04\x03\x12\x04\x9e\x02\x1f\x20\n\
    \x0c\n\x02\x04\x1d\x12\x06\xa1\x02\0\xa4\x02\x01\n\x0b\n\x03\x04\x1d\x01\
    \x12\x04\xa1\x02\x08$\n\x0c\n\x04\x04\x1d\x02\0\x12\x04\xa2\x02\x08,\n\r\
    \n\x05\x04\x1d\x02\0\x04\x12\x04\xa2\x02\x08\x10\n\r\n\x05\x04\x1d\x02\0\
    \x05\x12\x04\xa2\x02\x11\x16\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\xa2\x02\
    \x17'\n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\xa2\x02*+\n\x0c\n\x04\x04\x1d\
    \x02\x01\x12\x04\xa3\x02\x08/\n\r\n\x05\x04\x1d\x02\x01\x04\x12\x04\xa3\
    \x02\x08\x10\n\r\n\x05\x04\x1d\x02\x01\x05\x12\x04\xa3\x02\x11\x18\n\r\n\
    \x05\x04\x1d\x02\x01\x01\x12\x04\xa3\x02\x19*\n\r\n\x05\x04\x1d\x02\x01\
    \x03\x12\x04\xa3\x02-.\n\x0c\n\x02\x04\x1e\x12\x06\xa6\x02\0\xa8\x02\x01\
    \n\x0b\n\x03\x04\x1e\x01\x12\x04\xa6\x02\x08%\n\x0c\n\x04\x04\x1e\x02\0\
    \x12\x04\xa7\x02\x08-\n\r\n\x05\x04\x1e\x02\0\x04\x12\x04\xa7\x02\x08\
    \x10\n\r\n\x05\x04\x1e\x02\0\x05\x12\x04\xa7\x02\x11\x18\n\r\n\x05\x04\
    \x1e\x02\0\x01\x12\x04\xa7\x02\x19(\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\
    \xa7\x02+,\n\x0c\n\x02\x04\x1f\x12\x06\xaa\x02\0\xb1\x02\x01\n\x0b\n\x03\
    \x04\x1f\x01\x12\x04\xaa\x02\x08\"\n\x0e\n\x04\x04\x1f\x03\0\x12\x06\xab\
    \x02\x08\xae\x02\t\n\r\n\x05\x04\x1f\x03\0\x01\x12\x04\xab\x02\x10\x1c\n\
    \x0e\n\x06\x04\x1f\x03\0\x02\0\x12\x04\xac\x02\x102\n\x0f\n\x07\x04\x1f\
    \x03\0\x02\0\x04\x12\x04\xac\x02\x10\x18\n\x0f\n\x07\x04\x1f\x03\0\x02\0\
    \x05\x12\x04\xac\x02\x19\x20\n\x0f\n\x07\x04\x1f\x03\0\x02\0\x01\x12\x04\
    \xac\x02!-\n\x0f\n\x07\x04\x1f\x03\0\x02\0\x03\x12\x04\xac\x0201\n\x0e\n\
    \x06\x04\x1f\x03\0\x02\x01\x12\x04\xad\x02\x104\n\x0f\n\x07\x04\x1f\x03\
    \0\x02\x01\x04\x12\x04\xad\x02\x10\x18\n\x0f\n\x07\x04\x1f\x03\0\x02\x01\
    \x05\x12\x04\xad\x02\x19\x1e\n\x0f\n\x07\x04\x1f\x03\0\x02\x01\x01\x12\
    \x04\xad\x02\x1f/\n\x0f\n\x07\x04\x1f\x03\0\x02\x01\x03\x12\x04\xad\x022\
    3\n\x0c\n\x04\x04\x1f\x02\0\x12\x04\xb0\x02\x08L\n\r\n\x05\x04\x1f\x02\0\
    \x04\x12\x04\xb0\x02\x08\x10\n\r\n\x05\x04\x1f\x02\0\x06\x12\x04\xb0\x02\
    \x119\n\r\n\x05\x04\x1f\x02\0\x01\x12\x04\xb0\x02:G\n\r\n\x05\x04\x1f\
    \x02\0\x03\x12\x04\xb0\x02JK\n\x0c\n\x02\x04\x20\x12\x06\xb3\x02\0\xb5\
    \x02\x01\n\x0b\n\x03\x04\x20\x01\x12\x04\xb3\x02\x08$\n\x0c\n\x04\x04\
    \x20\x02\0\x12\x04\xb4\x02\x08#\n\r\n\x05\x04\x20\x02\0\x04\x12\x04\xb4\
    \x02\x08\x10\n\r\n\x05\x04\x20\x02\0\x05\x12\x04\xb4\x02\x11\x17\n\r\n\
    \x05\x04\x20\x02\0\x01\x12\x04\xb4\x02\x18\x1e\n\r\n\x05\x04\x20\x02\0\
    \x03\x12\x04\xb4\x02!\"\n\x0c\n\x02\x04!\x12\x06\xb7\x02\0\xc2\x02\x01\n\
    \x0b\n\x03\x04!\x01\x12\x04\xb7\x02\x08,\n\x0c\n\x04\x04!\x02\0\x12\x04\
    \xb8\x02\x08#\n\r\n\x05\x04!\x02\0\x04\x12\x04\xb8\x02\x08\x10\n\r\n\x05\
    \x04!\x02\0\x05\x12\x04\xb8\x02\x11\x17\n\r\n\x05\x04!\x02\0\x01\x12\x04\
    \xb8\x02\x18\x1e\n\r\n\x05\x04!\x02\0\x03\x12\x04\xb8\x02!\"\n\x0c\n\x04\
    \x04!\x02\x01\x12\x04\xb9\x02\x08\x20\n\r\n\x05\x04!\x02\x01\x04\x12\x04\
    \xb9\x02\x08\x10\n\r\n\x05\x04!\x02\x01\x05\x12\x04\xb9\x02\x11\x17\n\r\
    \n\x05\x04!\x02\x01\x01\x12\x04\xb9\x02\x18\x1b\n\r\n\x05\x04!\x02\x01\
    \x03\x12\x04\xb9\x02\x1e\x1f\n\x0c\n\x04\x04!\x02\x02\x12\x04\xba\x02\
    \x08$\n\r\n\x05\x04!\x02\x02\x04\x12\x04\xba\x02\x08\x10\n\r\n\x05\x04!\
    \x02\x02\x05\x12\x04\xba\x02\x11\x17\n\r\n\x05\x04!\x02\x02\x01\x12\x04\
    \xba\x02\x18\x1f\n\r\n\x05\x04!\x02\x02\x03\x12\x04\xba\x02\"#\n\x0c\n\
    \x04\x04!\x02\x03\x12\x04\xbb\x02\x08%\n\r\n\x05\x04!\x02\x03\x04\x12\
    \x04\xbb\x02\x08\x10\n\r\n\x05\x04!\x02\x03\x05\x12\x04\xbb\x02\x11\x17\
    \n\r\n\x05\x04!\x02\x03\x01\x12\x04\xbb\x02\x18\x20\n\r\n\x05\x04!\x02\
    \x03\x03\x12\x04\xbb\x02#$\n\x0c\n\x04\x04!\x02\x04\x12\x04\xbc\x02\x08-\
    \n\r\n\x05\x04!\x02\x04\x04\x12\x04\xbc\x02\x08\x10\n\r\n\x05\x04!\x02\
    \x04\x05\x12\x04\xbc\x02\x11\x17\n\r\n\x05\x04!\x02\x04\x01\x12\x04\xbc\
    \x02\x18(\n\r\n\x05\x04!\x02\x04\x03\x12\x04\xbc\x02+,\n\x0c\n\x04\x04!\
    \x02\x05\x12\x04\xbd\x02\x08$\n\r\n\x05\x04!\x02\x05\x04\x12\x04\xbd\x02\
    \x08\x10\n\r\n\x05\x04!\x02\x05\x05\x12\x04\xbd\x02\x11\x16\n\r\n\x05\
    \x04!\x02\x05\x01\x12\x04\xbd\x02\x17\x1f\n\r\n\x05\x04!\x02\x05\x03\x12\
    \x04\xbd\x02\"#\n\x0c\n\x04\x04!\x02\x06\x12\x04\xbe\x02\x08+\n\r\n\x05\
    \x04!\x02\x06\x04\x12\x04\xbe\x02\x08\x10\n\r\n\x05\x04!\x02\x06\x05\x12\
    \x04\xbe\x02\x11\x16\n\r\n\x05\x04!\x02\x06\x01\x12\x04\xbe\x02\x17&\n\r\
    \n\x05\x04!\x02\x06\x03\x12\x04\xbe\x02)*\n\x0c\n\x04\x04!\x02\x07\x12\
    \x04\xbf\x02\x08%\n\r\n\x05\x04!\x02\x07\x04\x12\x04\xbf\x02\x08\x10\n\r\
    \n\x05\x04!\x02\x07\x05\x12\x04\xbf\x02\x11\x17\n\r\n\x05\x04!\x02\x07\
    \x01\x12\x04\xbf\x02\x18\x20\n\r\n\x05\x04!\x02\x07\x03\x12\x04\xbf\x02#\
    $\n\x0c\n\x04\x04!\x02\x08\x12\x04\xc0\x02\x08)\n\r\n\x05\x04!\x02\x08\
    \x04\x12\x04\xc0\x02\x08\x10\n\r\n\x05\x04!\x02\x08\x05\x12\x04\xc0\x02\
    \x11\x17\n\r\n\x05\x04!\x02\x08\x01\x12\x04\xc0\x02\x18$\n\r\n\x05\x04!\
    \x02\x08\x03\x12\x04\xc0\x02'(\n\x0c\n\x04\x04!\x02\t\x12\x04\xc1\x02\
    \x088\n\r\n\x05\x04!\x02\t\x04\x12\x04\xc1\x02\x08\x10\n\r\n\x05\x04!\
    \x02\t\x05\x12\x04\xc1\x02\x11\x17\n\r\n\x05\x04!\x02\t\x01\x12\x04\xc1\
    \x02\x182\n\r\n\x05\x04!\x02\t\x03\x12\x04\xc1\x0257\n\x0c\n\x02\x04\"\
    \x12\x06\xc4\x02\0\xc8\x02\x01\n\x0b\n\x03\x04\"\x01\x12\x04\xc4\x02\x08\
    !\n\x0c\n\x04\x04\"\x02\0\x12\x04\xc5\x02\x08%\n\r\n\x05\x04\"\x02\0\x04\
    \x12\x04\xc5\x02\x08\x10\n\r\n\x05\x04\"\x02\0\x05\x12\x04\xc5\x02\x11\
    \x17\n\r\n\x05\x04\"\x02\0\x01\x12\x04\xc5\x02\x18\x20\n\r\n\x05\x04\"\
    \x02\0\x03\x12\x04\xc5\x02#$\n\x0c\n\x04\x04\"\x02\x01\x12\x04\xc6\x02\
    \x08#\n\r\n\x05\x04\"\x02\x01\x04\x12\x04\xc6\x02\x08\x10\n\r\n\x05\x04\
    \"\x02\x01\x05\x12\x04\xc6\x02\x11\x17\n\r\n\x05\x04\"\x02\x01\x01\x12\
    \x04\xc6\x02\x18\x1e\n\r\n\x05\x04\"\x02\x01\x03\x12\x04\xc6\x02!\"\n\
    \x0c\n\x04\x04\"\x02\x02\x12\x04\xc7\x02\x08&\n\r\n\x05\x04\"\x02\x02\
    \x04\x12\x04\xc7\x02\x08\x10\n\r\n\x05\x04\"\x02\x02\x05\x12\x04\xc7\x02\
    \x11\x17\n\r\n\x05\x04\"\x02\x02\x01\x12\x04\xc7\x02\x18!\n\r\n\x05\x04\
    \"\x02\x02\x03\x12\x04\xc7\x02$%\n\x0c\n\x02\x04#\x12\x06\xca\x02\0\xd4\
    \x02\x01\n\x0b\n\x03\x04#\x01\x12\x04\xca\x02\x08)\n\x0c\n\x04\x04#\x02\
    \0\x12\x04\xcb\x02\x08%\n\r\n\x05\x04#\x02\0\x04\x12\x04\xcb\x02\x08\x10\
    \n\r\n\x05\x04#\x02\0\x05\x12\x04\xcb\x02\x11\x17\n\r\n\x05\x04#\x02\0\
    \x01\x12\x04\xcb\x02\x18\x20\n\r\n\x05\x04#\x02\0\x03\x12\x04\xcb\x02#$\
    \n\x0c\n\x04\x04#\x02\x01\x12\x04\xcc\x02\x08$\n\r\n\x05\x04#\x02\x01\
    \x04\x12\x04\xcc\x02\x08\x10\n\r\n\x05\x04#\x02\x01\x05\x12\x04\xcc\x02\
    \x11\x17\n\r\n\x05\x04#\x02\x01\x01\x12\x04\xcc\x02\x18\x1f\n\r\n\x05\
    \x04#\x02\x01\x03\x12\x04\xcc\x02\"#\n\x0c\n\x04\x04#\x02\x02\x12\x04\
    \xcd\x02\x08%\n\r\n\x05\x04#\x02\x02\x04\x12\x04\xcd\x02\x08\x10\n\r\n\
    \x05\x04#\x02\x02\x05\x12\x04\xcd\x02\x11\x17\n\r\n\x05\x04#\x02\x02\x01\
    \x12\x04\xcd\x02\x18\x20\n\r\n\x05\x04#\x02\x02\x03\x12\x04\xcd\x02#$\n\
    \x0c\n\x04\x04#\x02\x03\x12\x04\xce\x02\x08$\n\r\n\x05\x04#\x02\x03\x04\
    \x12\x04\xce\x02\x08\x10\n\r\n\x05\x04#\x02\x03\x05\x12\x04\xce\x02\x11\
    \x16\n\r\n\x05\x04#\x02\x03\x01\x12\x04\xce\x02\x17\x1f\n\r\n\x05\x04#\
    \x02\x03\x03\x12\x04\xce\x02\"#\n\x0c\n\x04\x04#\x02\x04\x12\x04\xcf\x02\
    \x08)\n\r\n\x05\x04#\x02\x04\x04\x12\x04\xcf\x02\x08\x10\n\r\n\x05\x04#\
    \x02\x04\x05\x12\x04\xcf\x02\x11\x17\n\r\n\x05\x04#\x02\x04\x01\x12\x04\
    \xcf\x02\x18$\n\r\n\x05\x04#\x02\x04\x03\x12\x04\xcf\x02'(\n\x0c\n\x04\
    \x04#\x02\x05\x12\x04\xd0\x02\x08#\n\r\n\x05\x04#\x02\x05\x04\x12\x04\
    \xd0\x02\x08\x10\n\r\n\x05\x04#\x02\x05\x05\x12\x04\xd0\x02\x11\x17\n\r\
    \n\x05\x04#\x02\x05\x01\x12\x04\xd0\x02\x18\x1e\n\r\n\x05\x04#\x02\x05\
    \x03\x12\x04\xd0\x02!\"\n\x0c\n\x04\x04#\x02\x06\x12\x04\xd1\x02\x08$\n\
    \r\n\x05\x04#\x02\x06\x04\x12\x04\xd1\x02\x08\x10\n\r\n\x05\x04#\x02\x06\
    \x05\x12\x04\xd1\x02\x11\x17\n\r\n\x05\x04#\x02\x06\x01\x12\x04\xd1\x02\
    \x18\x1f\n\r\n\x05\x04#\x02\x06\x03\x12\x04\xd1\x02\"#\n\x0c\n\x04\x04#\
    \x02\x07\x12\x04\xd2\x02\x08&\n\r\n\x05\x04#\x02\x07\x04\x12\x04\xd2\x02\
    \x08\x10\n\r\n\x05\x04#\x02\x07\x05\x12\x04\xd2\x02\x11\x16\n\r\n\x05\
    \x04#\x02\x07\x01\x12\x04\xd2\x02\x17!\n\r\n\x05\x04#\x02\x07\x03\x12\
    \x04\xd2\x02$%\n\x0c\n\x04\x04#\x02\x08\x12\x04\xd3\x02\x08,\n\r\n\x05\
    \x04#\x02\x08\x04\x12\x04\xd3\x02\x08\x10\n\r\n\x05\x04#\x02\x08\x05\x12\
    \x04\xd3\x02\x11\x17\n\r\n\x05\x04#\x02\x08\x01\x12\x04\xd3\x02\x18'\n\r\
    \n\x05\x04#\x02\x08\x03\x12\x04\xd3\x02*+\n\x0c\n\x02\x04$\x12\x06\xd6\
    \x02\0\xdf\x02\x01\n\x0b\n\x03\x04$\x01\x12\x04\xd6\x02\x08#\n\x0c\n\x04\
    \x04$\x02\0\x12\x04\xd7\x02\x08%\n\r\n\x05\x04$\x02\0\x04\x12\x04\xd7\
    \x02\x08\x10\n\r\n\x05\x04$\x02\0\x05\x12\x04\xd7\x02\x11\x17\n\r\n\x05\
    \x04$\x02\0\x01\x12\x04\xd7\x02\x18\x20\n\r\n\x05\x04$\x02\0\x03\x12\x04\
    \xd7\x02#$\n\x0c\n\x04\x04$\x02\x01\x12\x04\xd8\x02\x08#\n\r\n\x05\x04$\
    \x02\x01\x04\x12\x04\xd8\x02\x08\x10\n\r\n\x05\x04$\x02\x01\x05\x12\x04\
    \xd8\x02\x11\x17\n\r\n\x05\x04$\x02\x01\x01\x12\x04\xd8\x02\x18\x1e\n\r\
    \n\x05\x04$\x02\x01\x03\x12\x04\xd8\x02!\"\n\x0c\n\x04\x04$\x02\x02\x12\
    \x04\xd9\x02\x08'\n\r\n\x05\x04$\x02\x02\x04\x12\x04\xd9\x02\x08\x10\n\r\
    \n\x05\x04$\x02\x02\x05\x12\x04\xd9\x02\x11\x17\n\r\n\x05\x04$\x02\x02\
    \x01\x12\x04\xd9\x02\x18\"\n\r\n\x05\x04$\x02\x02\x03\x12\x04\xd9\x02%&\
    \n\x0c\n\x04\x04$\x02\x03\x12\x04\xda\x02\x08!\n\r\n\x05\x04$\x02\x03\
    \x04\x12\x04\xda\x02\x08\x10\n\r\n\x05\x04$\x02\x03\x05\x12\x04\xda\x02\
    \x11\x16\n\r\n\x05\x04$\x02\x03\x01\x12\x04\xda\x02\x17\x1c\n\r\n\x05\
    \x04$\x02\x03\x03\x12\x04\xda\x02\x1f\x20\n\x0c\n\x04\x04$\x02\x04\x12\
    \x04\xdb\x02\x08%\n\r\n\x05\x04$\x02\x04\x04\x12\x04\xdb\x02\x08\x10\n\r\
    \n\x05\x04$\x02\x04\x05\x12\x04\xdb\x02\x11\x17\n\r\n\x05\x04$\x02\x04\
    \x01\x12\x04\xdb\x02\x18\x20\n\r\n\x05\x04$\x02\x04\x03\x12\x04\xdb\x02#\
    $\n\x0c\n\x04\x04$\x02\x05\x12\x04\xdc\x02\x08+\n\r\n\x05\x04$\x02\x05\
    \x04\x12\x04\xdc\x02\x08\x10\n\r\n\x05\x04$\x02\x05\x05\x12\x04\xdc\x02\
    \x11\x17\n\r\n\x05\x04$\x02\x05\x01\x12\x04\xdc\x02\x18&\n\r\n\x05\x04$\
    \x02\x05\x03\x12\x04\xdc\x02)*\n\x0c\n\x04\x04$\x02\x06\x12\x04\xdd\x02\
    \x08,\n\r\n\x05\x04$\x02\x06\x04\x12\x04\xdd\x02\x08\x10\n\r\n\x05\x04$\
    \x02\x06\x05\x12\x04\xdd\x02\x11\x16\n\r\n\x05\x04$\x02\x06\x01\x12\x04\
    \xdd\x02\x17'\n\r\n\x05\x04$\x02\x06\x03\x12\x04\xdd\x02*+\n\x0c\n\x04\
    \x04$\x02\x07\x12\x04\xde\x02\x08*\n\r\n\x05\x04$\x02\x07\x04\x12\x04\
    \xde\x02\x08\x10\n\r\n\x05\x04$\x02\x07\x05\x12\x04\xde\x02\x11\x17\n\r\
    \n\x05\x04$\x02\x07\x01\x12\x04\xde\x02\x18%\n\r\n\x05\x04$\x02\x07\x03\
    \x12\x04\xde\x02()\n\x0c\n\x02\x04%\x12\x06\xe1\x02\0\xec\x02\x01\n\x0b\
    \n\x03\x04%\x01\x12\x04\xe1\x02\x08+\n\x0c\n\x04\x04%\x02\0\x12\x04\xe2\
    \x02\x08%\n\r\n\x05\x04%\x02\0\x04\x12\x04\xe2\x02\x08\x10\n\r\n\x05\x04\
    %\x02\0\x05\x12\x04\xe2\x02\x11\x17\n\r\n\x05\x04%\x02\0\x01\x12\x04\xe2\
    \x02\x18\x20\n\r\n\x05\x04%\x02\0\x03\x12\x04\xe2\x02#$\n\x0c\n\x04\x04%\
    \x02\x01\x12\x04\xe3\x02\x08$\n\r\n\x05\x04%\x02\x01\x04\x12\x04\xe3\x02\
    \x08\x10\n\r\n\x05\x04%\x02\x01\x05\x12\x04\xe3\x02\x11\x17\n\r\n\x05\
    \x04%\x02\x01\x01\x12\x04\xe3\x02\x18\x1f\n\r\n\x05\x04%\x02\x01\x03\x12\
    \x04\xe3\x02\"#\n\x0c\n\x04\x04%\x02\x02\x12\x04\xe4\x02\x08%\n\r\n\x05\
    \x04%\x02\x02\x04\x12\x04\xe4\x02\x08\x10\n\r\n\x05\x04%\x02\x02\x05\x12\
    \x04\xe4\x02\x11\x17\n\r\n\x05\x04%\x02\x02\x01\x12\x04\xe4\x02\x18\x20\
    \n\r\n\x05\x04%\x02\x02\x03\x12\x04\xe4\x02#$\n\x0c\n\x04\x04%\x02\x03\
    \x12\x04\xe5\x02\x08$\n\r\n\x05\x04%\x02\x03\x04\x12\x04\xe5\x02\x08\x10\
    \n\r\n\x05\x04%\x02\x03\x05\x12\x04\xe5\x02\x11\x16\n\r\n\x05\x04%\x02\
    \x03\x01\x12\x04\xe5\x02\x17\x1f\n\r\n\x05\x04%\x02\x03\x03\x12\x04\xe5\
    \x02\"#\n\x0c\n\x04\x04%\x02\x04\x12\x04\xe6\x02\x08)\n\r\n\x05\x04%\x02\
    \x04\x04\x12\x04\xe6\x02\x08\x10\n\r\n\x05\x04%\x02\x04\x05\x12\x04\xe6\
    \x02\x11\x17\n\r\n\x05\x04%\x02\x04\x01\x12\x04\xe6\x02\x18$\n\r\n\x05\
    \x04%\x02\x04\x03\x12\x04\xe6\x02'(\n\x0c\n\x04\x04%\x02\x05\x12\x04\xe7\
    \x02\x08#\n\r\n\x05\x04%\x02\x05\x04\x12\x04\xe7\x02\x08\x10\n\r\n\x05\
    \x04%\x02\x05\x05\x12\x04\xe7\x02\x11\x17\n\r\n\x05\x04%\x02\x05\x01\x12\
    \x04\xe7\x02\x18\x1e\n\r\n\x05\x04%\x02\x05\x03\x12\x04\xe7\x02!\"\n\x0c\
    \n\x04\x04%\x02\x06\x12\x04\xe8\x02\x08%\n\r\n\x05\x04%\x02\x06\x04\x12\
    \x04\xe8\x02\x08\x10\n\r\n\x05\x04%\x02\x06\x05\x12\x04\xe8\x02\x11\x17\
    \n\r\n\x05\x04%\x02\x06\x01\x12\x04\xe8\x02\x18\x20\n\r\n\x05\x04%\x02\
    \x06\x03\x12\x04\xe8\x02#$\n\x0c\n\x04\x04%\x02\x07\x12\x04\xe9\x02\x08$\
    \n\r\n\x05\x04%\x02\x07\x04\x12\x04\xe9\x02\x08\x10\n\r\n\x05\x04%\x02\
    \x07\x05\x12\x04\xe9\x02\x11\x16\n\r\n\x05\x04%\x02\x07\x01\x12\x04\xe9\
    \x02\x17\x1f\n\r\n\x05\x04%\x02\x07\x03\x12\x04\xe9\x02\"#\n\x0c\n\x04\
    \x04%\x02\x08\x12\x04\xea\x02\x08&\n\r\n\x05\x04%\x02\x08\x04\x12\x04\
    \xea\x02\x08\x10\n\r\n\x05\x04%\x02\x08\x05\x12\x04\xea\x02\x11\x17\n\r\
    \n\x05\x04%\x02\x08\x01\x12\x04\xea\x02\x18!\n\r\n\x05\x04%\x02\x08\x03\
    \x12\x04\xea\x02$%\n\x0c\n\x04\x04%\x02\t\x12\x04\xeb\x02\x08,\n\r\n\x05\
    \x04%\x02\t\x04\x12\x04\xeb\x02\x08\x10\n\r\n\x05\x04%\x02\t\x05\x12\x04\
    \xeb\x02\x11\x17\n\r\n\x05\x04%\x02\t\x01\x12\x04\xeb\x02\x18&\n\r\n\x05\
    \x04%\x02\t\x03\x12\x04\xeb\x02)+\n\x0c\n\x02\x04&\x12\x06\xee\x02\0\xfa\
    \x02\x01\n\x0b\n\x03\x04&\x01\x12\x04\xee\x02\x08$\n\x0c\n\x04\x04&\x02\
    \0\x12\x04\xef\x02\x08%\n\r\n\x05\x04&\x02\0\x04\x12\x04\xef\x02\x08\x10\
    \n\r\n\x05\x04&\x02\0\x05\x12\x04\xef\x02\x11\x17\n\r\n\x05\x04&\x02\0\
    \x01\x12\x04\xef\x02\x18\x20\n\r\n\x05\x04&\x02\0\x03\x12\x04\xef\x02#$\
    \n\x0c\n\x04\x04&\x02\x01\x12\x04\xf0\x02\x08/\n\r\n\x05\x04&\x02\x01\
    \x04\x12\x04\xf0\x02\x08\x10\n\r\n\x05\x04&\x02\x01\x05\x12\x04\xf0\x02\
    \x11\x17\n\r\n\x05\x04&\x02\x01\x01\x12\x04\xf0\x02\x18*\n\r\n\x05\x04&\
    \x02\x01\x03\x12\x04\xf0\x02-.\n\x0c\n\x04\x04&\x02\x02\x12\x04\xf1\x02\
    \x08%\n\r\n\x05\x04&\x02\x02\x04\x12\x04\xf1\x02\x08\x10\n\r\n\x05\x04&\
    \x02\x02\x05\x12\x04\xf1\x02\x11\x17\n\r\n\x05\x04&\x02\x02\x01\x12\x04\
    \xf1\x02\x18\x20\n\r\n\x05\x04&\x02\x02\x03\x12\x04\xf1\x02#$\n\x0c\n\
    \x04\x04&\x02\x03\x12\x04\xf2\x02\x08*\n\r\n\x05\x04&\x02\x03\x04\x12\
    \x04\xf2\x02\x08\x10\n\r\n\x05\x04&\x02\x03\x05\x12\x04\xf2\x02\x11\x16\
    \n\r\n\x05\x04&\x02\x03\x01\x12\x04\xf2\x02\x17%\n\r\n\x05\x04&\x02\x03\
    \x03\x12\x04\xf2\x02()\n\x0c\n\x04\x04&\x02\x04\x12\x04\xf3\x02\x08/\n\r\
    \n\x05\x04&\x02\x04\x04\x12\x04\xf3\x02\x08\x10\n\r\n\x05\x04&\x02\x04\
    \x05\x12\x04\xf3\x02\x11\x16\n\r\n\x05\x04&\x02\x04\x01\x12\x04\xf3\x02\
    \x17*\n\r\n\x05\x04&\x02\x04\x03\x12\x04\xf3\x02-.\n\x0c\n\x04\x04&\x02\
    \x05\x12\x04\xf4\x02\x08%\n\r\n\x05\x04&\x02\x05\x04\x12\x04\xf4\x02\x08\
    \x10\n\r\n\x05\x04&\x02\x05\x05\x12\x04\xf4\x02\x11\x17\n\r\n\x05\x04&\
    \x02\x05\x01\x12\x04\xf4\x02\x18\x20\n\r\n\x05\x04&\x02\x05\x03\x12\x04\
    \xf4\x02#$\n\x0c\n\x04\x04&\x02\x06\x12\x04\xf5\x02\x08+\n\r\n\x05\x04&\
    \x02\x06\x04\x12\x04\xf5\x02\x08\x10\n\r\n\x05\x04&\x02\x06\x05\x12\x04\
    \xf5\x02\x11\x17\n\r\n\x05\x04&\x02\x06\x01\x12\x04\xf5\x02\x18&\n\r\n\
    \x05\x04&\x02\x06\x03\x12\x04\xf5\x02)*\n\x0c\n\x04\x04&\x02\x07\x12\x04\
    \xf6\x02\x08,\n\r\n\x05\x04&\x02\x07\x04\x12\x04\xf6\x02\x08\x10\n\r\n\
    \x05\x04&\x02\x07\x05\x12\x04\xf6\x02\x11\x16\n\r\n\x05\x04&\x02\x07\x01\
    \x12\x04\xf6\x02\x17'\n\r\n\x05\x04&\x02\x07\x03\x12\x04\xf6\x02*+\n\x0c\
    \n\x04\x04&\x02\x08\x12\x04\xf7\x02\x08'\n\r\n\x05\x04&\x02\x08\x04\x12\
    \x04\xf7\x02\x08\x10\n\r\n\x05\x04&\x02\x08\x05\x12\x04\xf7\x02\x11\x17\
    \n\r\n\x05\x04&\x02\x08\x01\x12\x04\xf7\x02\x18!\n\r\n\x05\x04&\x02\x08\
    \x03\x12\x04\xf7\x02$&\n\x0c\n\x04\x04&\x02\t\x12\x04\xf8\x02\x08*\n\r\n\
    \x05\x04&\x02\t\x04\x12\x04\xf8\x02\x08\x10\n\r\n\x05\x04&\x02\t\x05\x12\
    \x04\xf8\x02\x11\x17\n\r\n\x05\x04&\x02\t\x01\x12\x04\xf8\x02\x18$\n\r\n\
    \x05\x04&\x02\t\x03\x12\x04\xf8\x02')\n\x0c\n\x04\x04&\x02\n\x12\x04\xf9\
    \x02\x085\n\r\n\x05\x04&\x02\n\x04\x12\x04\xf9\x02\x08\x10\n\r\n\x05\x04\
    &\x02\n\x05\x12\x04\xf9\x02\x11\x17\n\r\n\x05\x04&\x02\n\x01\x12\x04\xf9\
    \x02\x18/\n\r\n\x05\x04&\x02\n\x03\x12\x04\xf9\x0224\n\x0c\n\x02\x04'\
    \x12\x06\xfc\x02\0\xfe\x02\x01\n\x0b\n\x03\x04'\x01\x12\x04\xfc\x02\x08,\
    \n\x0c\n\x04\x04'\x02\0\x12\x04\xfd\x02\x08$\n\r\n\x05\x04'\x02\0\x04\
    \x12\x04\xfd\x02\x08\x10\n\r\n\x05\x04'\x02\0\x05\x12\x04\xfd\x02\x11\
    \x17\n\r\n\x05\x04'\x02\0\x01\x12\x04\xfd\x02\x18\x1f\n\r\n\x05\x04'\x02\
    \0\x03\x12\x04\xfd\x02\"#\n\x0c\n\x02\x04(\x12\x06\x80\x03\0\x82\x03\x01\
    \n\x0b\n\x03\x04(\x01\x12\x04\x80\x03\x08\x1d\n\x0c\n\x04\x04(\x02\0\x12\
    \x04\x81\x03\x08\x20\n\r\n\x05\x04(\x02\0\x04\x12\x04\x81\x03\x08\x10\n\
    \r\n\x05\x04(\x02\0\x05\x12\x04\x81\x03\x11\x17\n\r\n\x05\x04(\x02\0\x01\
    \x12\x04\x81\x03\x18\x1b\n\r\n\x05\x04(\x02\0\x03\x12\x04\x81\x03\x1e\
    \x1f\n\x0c\n\x02\x04)\x12\x06\x84\x03\0\x88\x03\x01\n\x0b\n\x03\x04)\x01\
    \x12\x04\x84\x03\x08\"\n\x0c\n\x04\x04)\x02\0\x12\x04\x85\x03\x081\n\r\n\
    \x05\x04)\x02\0\x04\x12\x04\x85\x03\x08\x10\n\r\n\x05\x04)\x02\0\x05\x12\
    \x04\x85\x03\x11\x16\n\r\n\x05\x04)\x02\0\x01\x12\x04\x85\x03\x17\x1e\n\
    \r\n\x05\x04)\x02\0\x03\x12\x04\x85\x03!\"\n\r\n\x05\x04)\x02\0\x08\x12\
    \x04\x85\x03#0\n\r\n\x05\x04)\x02\0\x07\x12\x04\x85\x03./\n\x0c\n\x04\
    \x04)\x02\x01\x12\x04\x86\x03\x083\n\r\n\x05\x04)\x02\x01\x04\x12\x04\
    \x86\x03\x08\x10\n\r\n\x05\x04)\x02\x01\x05\x12\x04\x86\x03\x11\x16\n\r\
    \n\x05\x04)\x02\x01\x01\x12\x04\x86\x03\x17.\n\r\n\x05\x04)\x02\x01\x03\
    \x12\x04\x86\x0312\n\x0c\n\x04\x04)\x02\x02\x12\x04\x87\x03\x081\n\r\n\
    \x05\x04)\x02\x02\x04\x12\x04\x87\x03\x08\x10\n\r\n\x05\x04)\x02\x02\x05\
    \x12\x04\x87\x03\x11\x16\n\r\n\x05\x04)\x02\x02\x01\x12\x04\x87\x03\x17,\
    \n\r\n\x05\x04)\x02\x02\x03\x12\x04\x87\x03/0\n\x0c\n\x02\x04*\x12\x06\
    \x8a\x03\0\x91\x03\x01\n\x0b\n\x03\x04*\x01\x12\x04\x8a\x03\x08$\n\x0c\n\
    \x04\x04*\x02\0\x12\x04\x8b\x03\x08.\n\r\n\x05\x04*\x02\0\x04\x12\x04\
    \x8b\x03\x08\x10\n\r\n\x05\x04*\x02\0\x05\x12\x04\x8b\x03\x11\x17\n\r\n\
    \x05\x04*\x02\0\x01\x12\x04\x8b\x03\x18)\n\r\n\x05\x04*\x02\0\x03\x12\
    \x04\x8b\x03,-\n\x0c\n\x04\x04*\x02\x01\x12\x04\x8c\x03\x08.\n\r\n\x05\
    \x04*\x02\x01\x04\x12\x04\x8c\x03\x08\x10\n\r\n\x05\x04*\x02\x01\x05\x12\
    \x04\x8c\x03\x11\x17\n\r\n\x05\x04*\x02\x01\x01\x12\x04\x8c\x03\x18)\n\r\
    \n\x05\x04*\x02\x01\x03\x12\x04\x8c\x03,-\n\x0c\n\x04\x04*\x02\x02\x12\
    \x04\x8d\x03\x08(\n\r\n\x05\x04*\x02\x02\x04\x12\x04\x8d\x03\x08\x10\n\r\
    \n\x05\x04*\x02\x02\x05\x12\x04\x8d\x03\x11\x16\n\r\n\x05\x04*\x02\x02\
    \x01\x12\x04\x8d\x03\x17#\n\r\n\x05\x04*\x02\x02\x03\x12\x04\x8d\x03&'\n\
    \x0c\n\x04\x04*\x02\x03\x12\x04\x8e\x03\x083\n\r\n\x05\x04*\x02\x03\x04\
    \x12\x04\x8e\x03\x08\x10\n\r\n\x05\x04*\x02\x03\x05\x12\x04\x8e\x03\x11\
    \x17\n\r\n\x05\x04*\x02\x03\x01\x12\x04\x8e\x03\x18.\n\r\n\x05\x04*\x02\
    \x03\x03\x12\x04\x8e\x0312\n\x0c\n\x04\x04*\x02\x04\x12\x04\x8f\x03\x08.\
    \n\r\n\x05\x04*\x02\x04\x04\x12\x04\x8f\x03\x08\x10\n\r\n\x05\x04*\x02\
    \x04\x05\x12\x04\x8f\x03\x11\x17\n\r\n\x05\x04*\x02\x04\x01\x12\x04\x8f\
    \x03\x18)\n\r\n\x05\x04*\x02\x04\x03\x12\x04\x8f\x03,-\n\x0c\n\x04\x04*\
    \x02\x05\x12\x04\x90\x03\x083\n\r\n\x05\x04*\x02\x05\x04\x12\x04\x90\x03\
    \x08\x10\n\r\n\x05\x04*\x02\x05\x05\x12\x04\x90\x03\x11\x17\n\r\n\x05\
    \x04*\x02\x05\x01\x12\x04\x90\x03\x18.\n\r\n\x05\x04*\x02\x05\x03\x12\
    \x04\x90\x0312\n\x0c\n\x02\x04+\x12\x06\x93\x03\0\x95\x03\x01\n\x0b\n\
    \x03\x04+\x01\x12\x04\x93\x03\x08$\n\x0c\n\x04\x04+\x02\0\x12\x04\x94\
    \x03\x08-\n\r\n\x05\x04+\x02\0\x04\x12\x04\x94\x03\x08\x10\n\r\n\x05\x04\
    +\x02\0\x05\x12\x04\x94\x03\x11\x16\n\r\n\x05\x04+\x02\0\x01\x12\x04\x94\
    \x03\x17(\n\r\n\x05\x04+\x02\0\x03\x12\x04\x94\x03+,\n\x0c\n\x02\x04,\
    \x12\x06\x97\x03\0\x99\x03\x01\n\x0b\n\x03\x04,\x01\x12\x04\x97\x03\x08,\
    \n\x0c\n\x04\x04,\x02\0\x12\x04\x98\x03\x08$\n\r\n\x05\x04,\x02\0\x04\
    \x12\x04\x98\x03\x08\x10\n\r\n\x05\x04,\x02\0\x05\x12\x04\x98\x03\x11\
    \x17\n\r\n\x05\x04,\x02\0\x01\x12\x04\x98\x03\x18\x1f\n\r\n\x05\x04,\x02\
    \0\x03\x12\x04\x98\x03\"#\n\x0c\n\x02\x04-\x12\x06\x9b\x03\0\x9e\x03\x01\
    \n\x0b\n\x03\x04-\x01\x12\x04\x9b\x03\x08'\n\x0c\n\x04\x04-\x02\0\x12\
    \x04\x9c\x03\x08'\n\r\n\x05\x04-\x02\0\x04\x12\x04\x9c\x03\x08\x10\n\r\n\
    \x05\x04-\x02\0\x05\x12\x04\x9c\x03\x11\x17\n\r\n\x05\x04-\x02\0\x01\x12\
    \x04\x9c\x03\x18\"\n\r\n\x05\x04-\x02\0\x03\x12\x04\x9c\x03%&\n\x0c\n\
    \x04\x04-\x02\x01\x12\x04\x9d\x03\x08(\n\r\n\x05\x04-\x02\x01\x04\x12\
    \x04\x9d\x03\x08\x10\n\r\n\x05\x04-\x02\x01\x05\x12\x04\x9d\x03\x11\x16\
    \n\r\n\x05\x04-\x02\x01\x01\x12\x04\x9d\x03\x17#\n\r\n\x05\x04-\x02\x01\
    \x03\x12\x04\x9d\x03&'\n\x0c\n\x02\x04.\x12\x06\xa0\x03\0\xa4\x03\x01\n\
    \x0b\n\x03\x04.\x01\x12\x04\xa0\x03\x08(\n\x0c\n\x04\x04.\x02\0\x12\x04\
    \xa1\x03\x08-\n\r\n\x05\x04.\x02\0\x04\x12\x04\xa1\x03\x08\x10\n\r\n\x05\
    \x04.\x02\0\x05\x12\x04\xa1\x03\x11\x17\n\r\n\x05\x04.\x02\0\x01\x12\x04\
    \xa1\x03\x18(\n\r\n\x05\x04.\x02\0\x03\x12\x04\xa1\x03+,\n\x0c\n\x04\x04\
    .\x02\x01\x12\x04\xa2\x03\x08*\n\r\n\x05\x04.\x02\x01\x04\x12\x04\xa2\
    \x03\x08\x10\n\r\n\x05\x04.\x02\x01\x05\x12\x04\xa2\x03\x11\x17\n\r\n\
    \x05\x04.\x02\x01\x01\x12\x04\xa2\x03\x18%\n\r\n\x05\x04.\x02\x01\x03\
    \x12\x04\xa2\x03()\n\x0c\n\x04\x04.\x02\x02\x12\x04\xa3\x03\x08'\n\r\n\
    \x05\x04.\x02\x02\x04\x12\x04\xa3\x03\x08\x10\n\r\n\x05\x04.\x02\x02\x05\
    \x12\x04\xa3\x03\x11\x17\n\r\n\x05\x04.\x02\x02\x01\x12\x04\xa3\x03\x18\
    \"\n\r\n\x05\x04.\x02\x02\x03\x12\x04\xa3\x03%&\n\x0c\n\x02\x04/\x12\x06\
    \xa6\x03\0\xb0\x03\x01\n\x0b\n\x03\x04/\x01\x12\x04\xa6\x03\x08)\n\x0c\n\
    \x04\x04/\x02\0\x12\x04\xa7\x03\x08%\n\r\n\x05\x04/\x02\0\x04\x12\x04\
    \xa7\x03\x08\x10\n\r\n\x05\x04/\x02\0\x05\x12\x04\xa7\x03\x11\x17\n\r\n\
    \x05\x04/\x02\0\x01\x12\x04\xa7\x03\x18\x20\n\r\n\x05\x04/\x02\0\x03\x12\
    \x04\xa7\x03#$\n\x0c\n\x04\x04/\x02\x01\x12\x04\xa8\x03\x08-\n\r\n\x05\
    \x04/\x02\x01\x04\x12\x04\xa8\x03\x08\x10\n\r\n\x05\x04/\x02\x01\x05\x12\
    \x04\xa8\x03\x11\x17\n\r\n\x05\x04/\x02\x01\x01\x12\x04\xa8\x03\x18(\n\r\
    \n\x05\x04/\x02\x01\x03\x12\x04\xa8\x03+,\n\x0c\n\x04\x04/\x02\x02\x12\
    \x04\xa9\x03\x08*\n\r\n\x05\x04/\x02\x02\x04\x12\x04\xa9\x03\x08\x10\n\r\
    \n\x05\x04/\x02\x02\x05\x12\x04\xa9\x03\x11\x17\n\r\n\x05\x04/\x02\x02\
    \x01\x12\x04\xa9\x03\x18%\n\r\n\x05\x04/\x02\x02\x03\x12\x04\xa9\x03()\n\
    \x0c\n\x04\x04/\x02\x03\x12\x04\xaa\x03\x085\n\r\n\x05\x04/\x02\x03\x04\
    \x12\x04\xaa\x03\x08\x10\n\r\n\x05\x04/\x02\x03\x05\x12\x04\xaa\x03\x11\
    \x17\n\r\n\x05\x04/\x02\x03\x01\x12\x04\xaa\x03\x180\n\r\n\x05\x04/\x02\
    \x03\x03\x12\x04\xaa\x0334\n\x0c\n\x04\x04/\x02\x04\x12\x04\xab\x03\x085\
    \n\r\n\x05\x04/\x02\x04\x04\x12\x04\xab\x03\x08\x10\n\r\n\x05\x04/\x02\
    \x04\x05\x12\x04\xab\x03\x11\x17\n\r\n\x05\x04/\x02\x04\x01\x12\x04\xab\
    \x03\x180\n\r\n\x05\x04/\x02\x04\x03\x12\x04\xab\x0334\n\x0c\n\x04\x04/\
    \x02\x05\x12\x04\xac\x03\x08B\n\r\n\x05\x04/\x02\x05\x04\x12\x04\xac\x03\
    \x08\x10\n\r\n\x05\x04/\x02\x05\x05\x12\x04\xac\x03\x11\x17\n\r\n\x05\
    \x04/\x02\x05\x01\x12\x04\xac\x03\x18=\n\r\n\x05\x04/\x02\x05\x03\x12\
    \x04\xac\x03@A\n\x0c\n\x04\x04/\x02\x06\x12\x04\xad\x03\x08:\n\r\n\x05\
    \x04/\x02\x06\x04\x12\x04\xad\x03\x08\x10\n\r\n\x05\x04/\x02\x06\x05\x12\
    \x04\xad\x03\x11\x17\n\r\n\x05\x04/\x02\x06\x01\x12\x04\xad\x03\x185\n\r\
    \n\x05\x04/\x02\x06\x03\x12\x04\xad\x0389\n\x0c\n\x04\x04/\x02\x07\x12\
    \x04\xae\x03\x08@\n\r\n\x05\x04/\x02\x07\x04\x12\x04\xae\x03\x08\x10\n\r\
    \n\x05\x04/\x02\x07\x05\x12\x04\xae\x03\x11\x17\n\r\n\x05\x04/\x02\x07\
    \x01\x12\x04\xae\x03\x18;\n\r\n\x05\x04/\x02\x07\x03\x12\x04\xae\x03>?\n\
    \x0c\n\x04\x04/\x02\x08\x12\x04\xaf\x03\x088\n\r\n\x05\x04/\x02\x08\x04\
    \x12\x04\xaf\x03\x08\x10\n\r\n\x05\x04/\x02\x08\x05\x12\x04\xaf\x03\x11\
    \x17\n\r\n\x05\x04/\x02\x08\x01\x12\x04\xaf\x03\x183\n\r\n\x05\x04/\x02\
    \x08\x03\x12\x04\xaf\x0367\n\x0c\n\x02\x040\x12\x06\xb2\x03\0\xb4\x03\
    \x01\n\x0b\n\x03\x040\x01\x12\x04\xb2\x03\x08&\n\x0c\n\x04\x040\x02\0\
    \x12\x04\xb3\x03\x08*\n\r\n\x05\x040\x02\0\x04\x12\x04\xb3\x03\x08\x10\n\
    \r\n\x05\x040\x02\0\x05\x12\x04\xb3\x03\x11\x17\n\r\n\x05\x040\x02\0\x01\
    \x12\x04\xb3\x03\x18%\n\r\n\x05\x040\x02\0\x03\x12\x04\xb3\x03()\n\x0c\n\
    \x02\x041\x12\x06\xb6\x03\0\xb8\x03\x01\n\x0b\n\x03\x041\x01\x12\x04\xb6\
    \x03\x08\x20\n\x0c\n\x04\x041\x02\0\x12\x04\xb7\x03\x08*\n\r\n\x05\x041\
    \x02\0\x04\x12\x04\xb7\x03\x08\x10\n\r\n\x05\x041\x02\0\x05\x12\x04\xb7\
    \x03\x11\x17\n\r\n\x05\x041\x02\0\x01\x12\x04\xb7\x03\x18%\n\r\n\x05\x04\
    1\x02\0\x03\x12\x04\xb7\x03()\n\x0c\n\x02\x042\x12\x06\xba\x03\0\xbe\x03\
    \x01\n\x0b\n\x03\x042\x01\x12\x04\xba\x03\x08!\n\x0c\n\x04\x042\x02\0\
    \x12\x04\xbb\x03\x08%\n\r\n\x05\x042\x02\0\x04\x12\x04\xbb\x03\x08\x10\n\
    \r\n\x05\x042\x02\0\x05\x12\x04\xbb\x03\x11\x17\n\r\n\x05\x042\x02\0\x01\
    \x12\x04\xbb\x03\x18\x20\n\r\n\x05\x042\x02\0\x03\x12\x04\xbb\x03#$\n\
    \x0c\n\x04\x042\x02\x01\x12\x04\xbc\x03\x08&\n\r\n\x05\x042\x02\x01\x04\
    \x12\x04\xbc\x03\x08\x10\n\r\n\x05\x042\x02\x01\x05\x12\x04\xbc\x03\x11\
    \x17\n\r\n\x05\x042\x02\x01\x01\x12\x04\xbc\x03\x18!\n\r\n\x05\x042\x02\
    \x01\x03\x12\x04\xbc\x03$%\n\x0c\n\x04\x042\x02\x02\x12\x04\xbd\x03\x08#\
    \n\r\n\x05\x042\x02\x02\x04\x12\x04\xbd\x03\x08\x10\n\r\n\x05\x042\x02\
    \x02\x05\x12\x04\xbd\x03\x11\x17\n\r\n\x05\x042\x02\x02\x01\x12\x04\xbd\
    \x03\x18\x1e\n\r\n\x05\x042\x02\x02\x03\x12\x04\xbd\x03!\"\n\x0c\n\x02\
    \x043\x12\x06\xc0\x03\0\xc3\x03\x01\n\x0b\n\x03\x043\x01\x12\x04\xc0\x03\
    \x08'\n\x0c\n\x04\x043\x02\0\x12\x04\xc1\x03\x08%\n\r\n\x05\x043\x02\0\
    \x04\x12\x04\xc1\x03\x08\x10\n\r\n\x05\x043\x02\0\x05\x12\x04\xc1\x03\
    \x11\x17\n\r\n\x05\x043\x02\0\x01\x12\x04\xc1\x03\x18\x20\n\r\n\x05\x043\
    \x02\0\x03\x12\x04\xc1\x03#$\n\x0c\n\x04\x043\x02\x01\x12\x04\xc2\x03\
    \x08#\n\r\n\x05\x043\x02\x01\x04\x12\x04\xc2\x03\x08\x10\n\r\n\x05\x043\
    \x02\x01\x05\x12\x04\xc2\x03\x11\x17\n\r\n\x05\x043\x02\x01\x01\x12\x04\
    \xc2\x03\x18\x1e\n\r\n\x05\x043\x02\x01\x03\x12\x04\xc2\x03!\"\n\x0c\n\
    \x02\x044\x12\x06\xc5\x03\0\xc9\x03\x01\n\x0b\n\x03\x044\x01\x12\x04\xc5\
    \x03\x08/\n\x0c\n\x04\x044\x02\0\x12\x04\xc6\x03\x081\n\r\n\x05\x044\x02\
    \0\x04\x12\x04\xc6\x03\x08\x10\n\r\n\x05\x044\x02\0\x05\x12\x04\xc6\x03\
    \x11\x16\n\r\n\x05\x044\x02\0\x01\x12\x04\xc6\x03\x17\x1e\n\r\n\x05\x044\
    \x02\0\x03\x12\x04\xc6\x03!\"\n\r\n\x05\x044\x02\0\x08\x12\x04\xc6\x03#0\
    \n\r\n\x05\x044\x02\0\x07\x12\x04\xc6\x03./\n\x0c\n\x04\x044\x02\x01\x12\
    \x04\xc7\x03\x08%\n\r\n\x05\x044\x02\x01\x04\x12\x04\xc7\x03\x08\x10\n\r\
    \n\x05\x044\x02\x01\x05\x12\x04\xc7\x03\x11\x17\n\r\n\x05\x044\x02\x01\
    \x01\x12\x04\xc7\x03\x18\x20\n\r\n\x05\x044\x02\x01\x03\x12\x04\xc7\x03#\
    $\n\x0c\n\x04\x044\x02\x02\x12\x04\xc8\x03\x080\n\r\n\x05\x044\x02\x02\
    \x04\x12\x04\xc8\x03\x08\x10\n\r\n\x05\x044\x02\x02\x05\x12\x04\xc8\x03\
    \x11\x16\n\r\n\x05\x044\x02\x02\x01\x12\x04\xc8\x03\x17+\n\r\n\x05\x044\
    \x02\x02\x03\x12\x04\xc8\x03./\n\x0c\n\x02\x045\x12\x06\xcb\x03\0\xcf\
    \x03\x01\n\x0b\n\x03\x045\x01\x12\x04\xcb\x03\x08&\n\x0c\n\x04\x045\x02\
    \0\x12\x04\xcc\x03\x08#\n\r\n\x05\x045\x02\0\x04\x12\x04\xcc\x03\x08\x10\
    \n\r\n\x05\x045\x02\0\x05\x12\x04\xcc\x03\x11\x17\n\r\n\x05\x045\x02\0\
    \x01\x12\x04\xcc\x03\x18\x1e\n\r\n\x05\x045\x02\0\x03\x12\x04\xcc\x03!\"\
    \n\x0c\n\x04\x045\x02\x01\x12\x04\xcd\x03\x08)\n\r\n\x05\x045\x02\x01\
    \x04\x12\x04\xcd\x03\x08\x10\n\r\n\x05\x045\x02\x01\x05\x12\x04\xcd\x03\
    \x11\x17\n\r\n\x05\x045\x02\x01\x01\x12\x04\xcd\x03\x18$\n\r\n\x05\x045\
    \x02\x01\x03\x12\x04\xcd\x03'(\n\x0c\n\x04\x045\x02\x02\x12\x04\xce\x03\
    \x08$\n\r\n\x05\x045\x02\x02\x04\x12\x04\xce\x03\x08\x10\n\r\n\x05\x045\
    \x02\x02\x05\x12\x04\xce\x03\x11\x16\n\r\n\x05\x045\x02\x02\x01\x12\x04\
    \xce\x03\x17\x1f\n\r\n\x05\x045\x02\x02\x03\x12\x04\xce\x03\"#\n\x0c\n\
    \x02\x046\x12\x06\xd1\x03\0\xda\x03\x01\n\x0b\n\x03\x046\x01\x12\x04\xd1\
    \x03\x08.\n\x0e\n\x04\x046\x03\0\x12\x06\xd2\x03\x08\xd6\x03\t\n\r\n\x05\
    \x046\x03\0\x01\x12\x04\xd2\x03\x10\x1c\n\x0e\n\x06\x046\x03\0\x02\0\x12\
    \x04\xd3\x03\x10-\n\x0f\n\x07\x046\x03\0\x02\0\x04\x12\x04\xd3\x03\x10\
    \x18\n\x0f\n\x07\x046\x03\0\x02\0\x05\x12\x04\xd3\x03\x19\x1f\n\x0f\n\
    \x07\x046\x03\0\x02\0\x01\x12\x04\xd3\x03\x20(\n\x0f\n\x07\x046\x03\0\
    \x02\0\x03\x12\x04\xd3\x03+,\n\x0e\n\x06\x046\x03\0\x02\x01\x12\x04\xd4\
    \x03\x101\n\x0f\n\x07\x046\x03\0\x02\x01\x04\x12\x04\xd4\x03\x10\x18\n\
    \x0f\n\x07\x046\x03\0\x02\x01\x05\x12\x04\xd4\x03\x19\x1f\n\x0f\n\x07\
    \x046\x03\0\x02\x01\x01\x12\x04\xd4\x03\x20,\n\x0f\n\x07\x046\x03\0\x02\
    \x01\x03\x12\x04\xd4\x03/0\n\x0e\n\x06\x046\x03\0\x02\x02\x12\x04\xd5\
    \x03\x104\n\x0f\n\x07\x046\x03\0\x02\x02\x04\x12\x04\xd5\x03\x10\x18\n\
    \x0f\n\x07\x046\x03\0\x02\x02\x05\x12\x04\xd5\x03\x19\x1f\n\x0f\n\x07\
    \x046\x03\0\x02\x02\x01\x12\x04\xd5\x03\x20/\n\x0f\n\x07\x046\x03\0\x02\
    \x02\x03\x12\x04\xd5\x0323\n\x0c\n\x04\x046\x02\0\x12\x04\xd8\x03\x081\n\
    \r\n\x05\x046\x02\0\x04\x12\x04\xd8\x03\x08\x10\n\r\n\x05\x046\x02\0\x05\
    \x12\x04\xd8\x03\x11\x16\n\r\n\x05\x046\x02\0\x01\x12\x04\xd8\x03\x17\
    \x1e\n\r\n\x05\x046\x02\0\x03\x12\x04\xd8\x03!\"\n\r\n\x05\x046\x02\0\
    \x08\x12\x04\xd8\x03#0\n\r\n\x05\x046\x02\0\x07\x12\x04\xd8\x03./\n\x0c\
    \n\x04\x046\x02\x01\x12\x04\xd9\x03\x08X\n\r\n\x05\x046\x02\x01\x04\x12\
    \x04\xd9\x03\x08\x10\n\r\n\x05\x046\x02\x01\x06\x12\x04\xd9\x03\x11E\n\r\
    \n\x05\x046\x02\x01\x01\x12\x04\xd9\x03FS\n\r\n\x05\x046\x02\x01\x03\x12\
    \x04\xd9\x03VW\n\x0c\n\x02\x047\x12\x06\xdc\x03\0\xf3\x03\x01\n\x0b\n\
    \x03\x047\x01\x12\x04\xdc\x03\x08$\n\x0c\n\x04\x047\x02\0\x12\x04\xdd\
    \x03\x08#\n\r\n\x05\x047\x02\0\x04\x12\x04\xdd\x03\x08\x10\n\r\n\x05\x04\
    7\x02\0\x05\x12\x04\xdd\x03\x11\x17\n\r\n\x05\x047\x02\0\x01\x12\x04\xdd\
    \x03\x18\x1e\n\r\n\x05\x047\x02\0\x03\x12\x04\xdd\x03!\"\n\x0c\n\x04\x04\
    7\x02\x01\x12\x04\xde\x03\x08&\n\r\n\x05\x047\x02\x01\x04\x12\x04\xde\
    \x03\x08\x10\n\r\n\x05\x047\x02\x01\x05\x12\x04\xde\x03\x11\x17\n\r\n\
    \x05\x047\x02\x01\x01\x12\x04\xde\x03\x18!\n\r\n\x05\x047\x02\x01\x03\
    \x12\x04\xde\x03$%\n\x0c\n\x04\x047\x02\x02\x12\x04\xdf\x03\x08&\n\r\n\
    \x05\x047\x02\x02\x04\x12\x04\xdf\x03\x08\x10\n\r\n\x05\x047\x02\x02\x05\
    \x12\x04\xdf\x03\x11\x17\n\r\n\x05\x047\x02\x02\x01\x12\x04\xdf\x03\x18!\
    \n\r\n\x05\x047\x02\x02\x03\x12\x04\xdf\x03$%\n\x0c\n\x04\x047\x02\x03\
    \x12\x04\xe0\x03\x08*\n\r\n\x05\x047\x02\x03\x04\x12\x04\xe0\x03\x08\x10\
    \n\r\n\x05\x047\x02\x03\x05\x12\x04\xe0\x03\x11\x17\n\r\n\x05\x047\x02\
    \x03\x01\x12\x04\xe0\x03\x18%\n\r\n\x05\x047\x02\x03\x03\x12\x04\xe0\x03\
    ()\n\x0c\n\x04\x047\x02\x04\x12\x04\xe1\x03\x08*\n\r\n\x05\x047\x02\x04\
    \x04\x12\x04\xe1\x03\x08\x10\n\r\n\x05\x047\x02\x04\x05\x12\x04\xe1\x03\
    \x11\x17\n\r\n\x05\x047\x02\x04\x01\x12\x04\xe1\x03\x18%\n\r\n\x05\x047\
    \x02\x04\x03\x12\x04\xe1\x03()\n\x0c\n\x04\x047\x02\x05\x12\x04\xe2\x03\
    \x08)\n\r\n\x05\x047\x02\x05\x04\x12\x04\xe2\x03\x08\x10\n\r\n\x05\x047\
    \x02\x05\x05\x12\x04\xe2\x03\x11\x17\n\r\n\x05\x047\x02\x05\x01\x12\x04\
    \xe2\x03\x18$\n\r\n\x05\x047\x02\x05\x03\x12\x04\xe2\x03'(\n\x0c\n\x04\
    \x047\x02\x06\x12\x04\xe3\x03\x084\n\r\n\x05\x047\x02\x06\x04\x12\x04\
    \xe3\x03\x08\x10\n\r\n\x05\x047\x02\x06\x05\x12\x04\xe3\x03\x11\x17\n\r\
    \n\x05\x047\x02\x06\x01\x12\x04\xe3\x03\x18/\n\r\n\x05\x047\x02\x06\x03\
    \x12\x04\xe3\x0323\n\x0c\n\x04\x047\x02\x07\x12\x04\xe4\x03\x081\n\r\n\
    \x05\x047\x02\x07\x04\x12\x04\xe4\x03\x08\x10\n\r\n\x05\x047\x02\x07\x05\
    \x12\x04\xe4\x03\x11\x17\n\r\n\x05\x047\x02\x07\x01\x12\x04\xe4\x03\x18,\
    \n\r\n\x05\x047\x02\x07\x03\x12\x04\xe4\x03/0\n\x0c\n\x04\x047\x02\x08\
    \x12\x04\xe5\x03\x08-\n\r\n\x05\x047\x02\x08\x04\x12\x04\xe5\x03\x08\x10\
    \n\r\n\x05\x047\x02\x08\x05\x12\x04\xe5\x03\x11\x17\n\r\n\x05\x047\x02\
    \x08\x01\x12\x04\xe5\x03\x18(\n\r\n\x05\x047\x02\x08\x03\x12\x04\xe5\x03\
    +,\n\x0c\n\x04\x047\x02\t\x12\x04\xe6\x03\x08,\n\r\n\x05\x047\x02\t\x04\
    \x12\x04\xe6\x03\x08\x10\n\r\n\x05\x047\x02\t\x05\x12\x04\xe6\x03\x11\
    \x17\n\r\n\x05\x047\x02\t\x01\x12\x04\xe6\x03\x18&\n\r\n\x05\x047\x02\t\
    \x03\x12\x04\xe6\x03)+\n\x0c\n\x04\x047\x02\n\x12\x04\xe7\x03\x08-\n\r\n\
    \x05\x047\x02\n\x04\x12\x04\xe7\x03\x08\x10\n\r\n\x05\x047\x02\n\x05\x12\
    \x04\xe7\x03\x11\x17\n\r\n\x05\x047\x02\n\x01\x12\x04\xe7\x03\x18'\n\r\n\
    \x05\x047\x02\n\x03\x12\x04\xe7\x03*,\n\x0c\n\x04\x047\x02\x0b\x12\x04\
    \xe8\x03\x08/\n\r\n\x05\x047\x02\x0b\x04\x12\x04\xe8\x03\x08\x10\n\r\n\
    \x05\x047\x02\x0b\x05\x12\x04\xe8\x03\x11\x18\n\r\n\x05\x047\x02\x0b\x01\
    \x12\x04\xe8\x03\x19)\n\r\n\x05\x047\x02\x0b\x03\x12\x04\xe8\x03,.\n\x0c\
    \n\x04\x047\x02\x0c\x12\x04\xe9\x03\x08)\n\r\n\x05\x047\x02\x0c\x04\x12\
    \x04\xe9\x03\x08\x10\n\r\n\x05\x047\x02\x0c\x05\x12\x04\xe9\x03\x11\x17\
    \n\r\n\x05\x047\x02\x0c\x01\x12\x04\xe9\x03\x18#\n\r\n\x05\x047\x02\x0c\
    \x03\x12\x04\xe9\x03&(\n\x0c\n\x04\x047\x02\r\x12\x04\xea\x03\x084\n\r\n\
    \x05\x047\x02\r\x04\x12\x04\xea\x03\x08\x10\n\r\n\x05\x047\x02\r\x05\x12\
    \x04\xea\x03\x11\x17\n\r\n\x05\x047\x02\r\x01\x12\x04\xea\x03\x18.\n\r\n\
    \x05\x047\x02\r\x03\x12\x04\xea\x0313\n\x0c\n\x04\x047\x02\x0e\x12\x04\
    \xeb\x03\x080\n\r\n\x05\x047\x02\x0e\x04\x12\x04\xeb\x03\x08\x10\n\r\n\
    \x05\x047\x02\x0e\x05\x12\x04\xeb\x03\x11\x17\n\r\n\x05\x047\x02\x0e\x01\
    \x12\x04\xeb\x03\x18*\n\r\n\x05\x047\x02\x0e\x03\x12\x04\xeb\x03-/\n\x0c\
    \n\x04\x047\x02\x0f\x12\x04\xec\x03\x082\n\r\n\x05\x047\x02\x0f\x04\x12\
    \x04\xec\x03\x08\x10\n\r\n\x05\x047\x02\x0f\x05\x12\x04\xec\x03\x11\x17\
    \n\r\n\x05\x047\x02\x0f\x01\x12\x04\xec\x03\x18,\n\r\n\x05\x047\x02\x0f\
    \x03\x12\x04\xec\x03/1\n\x0c\n\x04\x047\x02\x10\x12\x04\xed\x03\x08'\n\r\
    \n\x05\x047\x02\x10\x04\x12\x04\xed\x03\x08\x10\n\r\n\x05\x047\x02\x10\
    \x05\x12\x04\xed\x03\x11\x15\n\r\n\x05\x047\x02\x10\x01\x12\x04\xed\x03\
    \x16!\n\r\n\x05\x047\x02\x10\x03\x12\x04\xed\x03$&\n\x0c\n\x04\x047\x02\
    \x11\x12\x04\xee\x03\x08+\n\r\n\x05\x047\x02\x11\x04\x12\x04\xee\x03\x08\
    \x10\n\r\n\x05\x047\x02\x11\x05\x12\x04\xee\x03\x11\x15\n\r\n\x05\x047\
    \x02\x11\x01\x12\x04\xee\x03\x16%\n\r\n\x05\x047\x02\x11\x03\x12\x04\xee\
    \x03(*\n\x0c\n\x04\x047\x02\x12\x12\x04\xef\x03\x080\n\r\n\x05\x047\x02\
    \x12\x04\x12\x04\xef\x03\x08\x10\n\r\n\x05\x047\x02\x12\x05\x12\x04\xef\
    \x03\x11\x17\n\r\n\x05\x047\x02\x12\x01\x12\x04\xef\x03\x18*\n\r\n\x05\
    \x047\x02\x12\x03\x12\x04\xef\x03-/\n\x0c\n\x04\x047\x02\x13\x12\x04\xf0\
    \x03\x081\n\r\n\x05\x047\x02\x13\x04\x12\x04\xf0\x03\x08\x10\n\r\n\x05\
    \x047\x02\x13\x05\x12\x04\xf0\x03\x11\x17\n\r\n\x05\x047\x02\x13\x01\x12\
    \x04\xf0\x03\x18+\n\r\n\x05\x047\x02\x13\x03\x12\x04\xf0\x03.0\n\x0c\n\
    \x04\x047\x02\x14\x12\x04\xf1\x03\x08/\n\r\n\x05\x047\x02\x14\x04\x12\
    \x04\xf1\x03\x08\x10\n\r\n\x05\x047\x02\x14\x05\x12\x04\xf1\x03\x11\x17\
    \n\r\n\x05\x047\x02\x14\x01\x12\x04\xf1\x03\x18)\n\r\n\x05\x047\x02\x14\
    \x03\x12\x04\xf1\x03,.\n\x0c\n\x04\x047\x02\x15\x12\x04\xf2\x03\x08%\n\r\
    \n\x05\x047\x02\x15\x04\x12\x04\xf2\x03\x08\x10\n\r\n\x05\x047\x02\x15\
    \x05\x12\x04\xf2\x03\x11\x17\n\r\n\x05\x047\x02\x15\x01\x12\x04\xf2\x03\
    \x18\x1f\n\r\n\x05\x047\x02\x15\x03\x12\x04\xf2\x03\"$\n\x0c\n\x02\x048\
    \x12\x06\xf5\x03\0\xfd\x03\x01\n\x0b\n\x03\x048\x01\x12\x04\xf5\x03\x08&\
    \n\x0c\n\x04\x048\x02\0\x12\x04\xf6\x03\x08.\n\r\n\x05\x048\x02\0\x04\
    \x12\x04\xf6\x03\x08\x10\n\r\n\x05\x048\x02\0\x05\x12\x04\xf6\x03\x11\
    \x18\n\r\n\x05\x048\x02\0\x01\x12\x04\xf6\x03\x19)\n\r\n\x05\x048\x02\0\
    \x03\x12\x04\xf6\x03,-\n\x0c\n\x04\x048\x02\x01\x12\x04\xf7\x03\x08)\n\r\
    \n\x05\x048\x02\x01\x04\x12\x04\xf7\x03\x08\x10\n\r\n\x05\x048\x02\x01\
    \x05\x12\x04\xf7\x03\x11\x17\n\r\n\x05\x048\x02\x01\x01\x12\x04\xf7\x03\
    \x18$\n\r\n\x05\x048\x02\x01\x03\x12\x04\xf7\x03'(\n\x0c\n\x04\x048\x02\
    \x02\x12\x04\xf8\x03\x08#\n\r\n\x05\x048\x02\x02\x04\x12\x04\xf8\x03\x08\
    \x10\n\r\n\x05\x048\x02\x02\x05\x12\x04\xf8\x03\x11\x16\n\r\n\x05\x048\
    \x02\x02\x01\x12\x04\xf8\x03\x17\x1e\n\r\n\x05\x048\x02\x02\x03\x12\x04\
    \xf8\x03!\"\n\x0c\n\x04\x048\x02\x03\x12\x04\xf9\x03\x08$\n\r\n\x05\x048\
    \x02\x03\x04\x12\x04\xf9\x03\x08\x10\n\r\n\x05\x048\x02\x03\x05\x12\x04\
    \xf9\x03\x11\x16\n\r\n\x05\x048\x02\x03\x01\x12\x04\xf9\x03\x17\x1f\n\r\
    \n\x05\x048\x02\x03\x03\x12\x04\xf9\x03\"#\n\x0c\n\x04\x048\x02\x04\x12\
    \x04\xfa\x03\x080\n\r\n\x05\x048\x02\x04\x04\x12\x04\xfa\x03\x08\x10\n\r\
    \n\x05\x048\x02\x04\x05\x12\x04\xfa\x03\x11\x17\n\r\n\x05\x048\x02\x04\
    \x01\x12\x04\xfa\x03\x18+\n\r\n\x05\x048\x02\x04\x03\x12\x04\xfa\x03./\n\
    \x0c\n\x04\x048\x02\x05\x12\x04\xfb\x03\x080\n\r\n\x05\x048\x02\x05\x04\
    \x12\x04\xfb\x03\x08\x10\n\r\n\x05\x048\x02\x05\x05\x12\x04\xfb\x03\x11\
    \x17\n\r\n\x05\x048\x02\x05\x01\x12\x04\xfb\x03\x18+\n\r\n\x05\x048\x02\
    \x05\x03\x12\x04\xfb\x03./\n\x0c\n\x04\x048\x02\x06\x12\x04\xfc\x03\x081\
    \n\r\n\x05\x048\x02\x06\x04\x12\x04\xfc\x03\x08\x10\n\r\n\x05\x048\x02\
    \x06\x05\x12\x04\xfc\x03\x11\x17\n\r\n\x05\x048\x02\x06\x01\x12\x04\xfc\
    \x03\x18,\n\r\n\x05\x048\x02\x06\x03\x12\x04\xfc\x03/0\n\x0c\n\x02\x049\
    \x12\x06\xff\x03\0\x83\x04\x01\n\x0b\n\x03\x049\x01\x12\x04\xff\x03\x08)\
    \n\x0c\n\x04\x049\x02\0\x12\x04\x80\x04\x082\n\r\n\x05\x049\x02\0\x04\
    \x12\x04\x80\x04\x08\x10\n\r\n\x05\x049\x02\0\x05\x12\x04\x80\x04\x11\
    \x17\n\r\n\x05\x049\x02\0\x01\x12\x04\x80\x04\x18\x1f\n\r\n\x05\x049\x02\
    \0\x03\x12\x04\x80\x04\"#\n\r\n\x05\x049\x02\0\x08\x12\x04\x80\x04$1\n\r\
    \n\x05\x049\x02\0\x07\x12\x04\x80\x04/0\n\x0c\n\x04\x049\x02\x01\x12\x04\
    \x81\x04\x08\"\n\r\n\x05\x049\x02\x01\x04\x12\x04\x81\x04\x08\x10\n\r\n\
    \x05\x049\x02\x01\x05\x12\x04\x81\x04\x11\x17\n\r\n\x05\x049\x02\x01\x01\
    \x12\x04\x81\x04\x18\x1d\n\r\n\x05\x049\x02\x01\x03\x12\x04\x81\x04\x20!\
    \n\x0c\n\x04\x049\x02\x02\x12\x04\x82\x04\x08,\n\r\n\x05\x049\x02\x02\
    \x04\x12\x04\x82\x04\x08\x10\n\r\n\x05\x049\x02\x02\x05\x12\x04\x82\x04\
    \x11\x17\n\r\n\x05\x049\x02\x02\x01\x12\x04\x82\x04\x18'\n\r\n\x05\x049\
    \x02\x02\x03\x12\x04\x82\x04*+\n\x0c\n\x02\x04:\x12\x06\x85\x04\0\x95\
    \x04\x01\n\x0b\n\x03\x04:\x01\x12\x04\x85\x04\x08\"\n\x0e\n\x04\x04:\x03\
    \0\x12\x06\x86\x04\x08\x8f\x04\t\n\r\n\x05\x04:\x03\0\x01\x12\x04\x86\
    \x04\x10\x19\n\x0e\n\x06\x04:\x03\0\x02\0\x12\x04\x87\x04\x100\n\x0f\n\
    \x07\x04:\x03\0\x02\0\x04\x12\x04\x87\x04\x10\x18\n\x0f\n\x07\x04:\x03\0\
    \x02\0\x05\x12\x04\x87\x04\x19\x1f\n\x0f\n\x07\x04:\x03\0\x02\0\x01\x12\
    \x04\x87\x04\x20+\n\x0f\n\x07\x04:\x03\0\x02\0\x03\x12\x04\x87\x04./\n\
    \x0e\n\x06\x04:\x03\0\x02\x01\x12\x04\x88\x04\x10.\n\x0f\n\x07\x04:\x03\
    \0\x02\x01\x04\x12\x04\x88\x04\x10\x18\n\x0f\n\x07\x04:\x03\0\x02\x01\
    \x05\x12\x04\x88\x04\x19\x1f\n\x0f\n\x07\x04:\x03\0\x02\x01\x01\x12\x04\
    \x88\x04\x20)\n\x0f\n\x07\x04:\x03\0\x02\x01\x03\x12\x04\x88\x04,-\n\x0e\
    \n\x06\x04:\x03\0\x02\x02\x12\x04\x89\x04\x10,\n\x0f\n\x07\x04:\x03\0\
    \x02\x02\x04\x12\x04\x89\x04\x10\x18\n\x0f\n\x07\x04:\x03\0\x02\x02\x05\
    \x12\x04\x89\x04\x19\x1f\n\x0f\n\x07\x04:\x03\0\x02\x02\x01\x12\x04\x89\
    \x04\x20'\n\x0f\n\x07\x04:\x03\0\x02\x02\x03\x12\x04\x89\x04*+\n\x0e\n\
    \x06\x04:\x03\0\x02\x03\x12\x04\x8a\x04\x10*\n\x0f\n\x07\x04:\x03\0\x02\
    \x03\x04\x12\x04\x8a\x04\x10\x18\n\x0f\n\x07\x04:\x03\0\x02\x03\x05\x12\
    \x04\x8a\x04\x19\x1f\n\x0f\n\x07\x04:\x03\0\x02\x03\x01\x12\x04\x8a\x04\
    \x20%\n\x0f\n\x07\x04:\x03\0\x02\x03\x03\x12\x04\x8a\x04()\n\x0e\n\x06\
    \x04:\x03\0\x02\x04\x12\x04\x8b\x04\x10.\n\x0f\n\x07\x04:\x03\0\x02\x04\
    \x04\x12\x04\x8b\x04\x10\x18\n\x0f\n\x07\x04:\x03\0\x02\x04\x05\x12\x04\
    \x8b\x04\x19\x1f\n\x0f\n\x07\x04:\x03\0\x02\x04\x01\x12\x04\x8b\x04\x20)\
    \n\x0f\n\x07\x04:\x03\0\x02\x04\x03\x12\x04\x8b\x04,-\n\x0e\n\x06\x04:\
    \x03\0\x02\x05\x12\x04\x8c\x04\x101\n\x0f\n\x07\x04:\x03\0\x02\x05\x04\
    \x12\x04\x8c\x04\x10\x18\n\x0f\n\x07\x04:\x03\0\x02\x05\x05\x12\x04\x8c\
    \x04\x19\x1f\n\x0f\n\x07\x04:\x03\0\x02\x05\x01\x12\x04\x8c\x04\x20,\n\
    \x0f\n\x07\x04:\x03\0\x02\x05\x03\x12\x04\x8c\x04/0\n\x0e\n\x06\x04:\x03\
    \0\x02\x06\x12\x04\x8d\x04\x10,\n\x0f\n\x07\x04:\x03\0\x02\x06\x04\x12\
    \x04\x8d\x04\x10\x18\n\x0f\n\x07\x04:\x03\0\x02\x06\x05\x12\x04\x8d\x04\
    \x19\x1d\n\x0f\n\x07\x04:\x03\0\x02\x06\x01\x12\x04\x8d\x04\x1e'\n\x0f\n\
    \x07\x04:\x03\0\x02\x06\x03\x12\x04\x8d\x04*+\n\x0e\n\x06\x04:\x03\0\x02\
    \x07\x12\x04\x8e\x04\x10*\n\x0f\n\x07\x04:\x03\0\x02\x07\x04\x12\x04\x8e\
    \x04\x10\x18\n\x0f\n\x07\x04:\x03\0\x02\x07\x05\x12\x04\x8e\x04\x19\x1d\
    \n\x0f\n\x07\x04:\x03\0\x02\x07\x01\x12\x04\x8e\x04\x1e%\n\x0f\n\x07\x04\
    :\x03\0\x02\x07\x03\x12\x04\x8e\x04()\n\x0c\n\x04\x04:\x02\0\x12\x04\x91\
    \x04\x08$\n\r\n\x05\x04:\x02\0\x04\x12\x04\x91\x04\x08\x10\n\r\n\x05\x04\
    :\x02\0\x05\x12\x04\x91\x04\x11\x17\n\r\n\x05\x04:\x02\0\x01\x12\x04\x91\
    \x04\x18\x1f\n\r\n\x05\x04:\x02\0\x03\x12\x04\x91\x04\"#\n\x0c\n\x04\x04\
    :\x02\x01\x12\x04\x92\x04\x08A\n\r\n\x05\x04:\x02\x01\x04\x12\x04\x92\
    \x04\x08\x10\n\r\n\x05\x04:\x02\x01\x06\x12\x04\x92\x04\x116\n\r\n\x05\
    \x04:\x02\x01\x01\x12\x04\x92\x047<\n\r\n\x05\x04:\x02\x01\x03\x12\x04\
    \x92\x04?@\n\x0c\n\x04\x04:\x02\x02\x12\x04\x93\x04\x08,\n\r\n\x05\x04:\
    \x02\x02\x04\x12\x04\x93\x04\x08\x10\n\r\n\x05\x04:\x02\x02\x05\x12\x04\
    \x93\x04\x11\x17\n\r\n\x05\x04:\x02\x02\x01\x12\x04\x93\x04\x18'\n\r\n\
    \x05\x04:\x02\x02\x03\x12\x04\x93\x04*+\n\x0c\n\x04\x04:\x02\x03\x12\x04\
    \x94\x04\x08(\n\r\n\x05\x04:\x02\x03\x04\x12\x04\x94\x04\x08\x10\n\r\n\
    \x05\x04:\x02\x03\x05\x12\x04\x94\x04\x11\x17\n\r\n\x05\x04:\x02\x03\x01\
    \x12\x04\x94\x04\x18#\n\r\n\x05\x04:\x02\x03\x03\x12\x04\x94\x04&'\n\x0c\
    \n\x02\x04;\x12\x06\x97\x04\0\x9a\x04\x01\n\x0b\n\x03\x04;\x01\x12\x04\
    \x97\x04\x08$\n\x0c\n\x04\x04;\x02\0\x12\x04\x98\x04\x08-\n\r\n\x05\x04;\
    \x02\0\x04\x12\x04\x98\x04\x08\x10\n\r\n\x05\x04;\x02\0\x05\x12\x04\x98\
    \x04\x11\x17\n\r\n\x05\x04;\x02\0\x01\x12\x04\x98\x04\x18(\n\r\n\x05\x04\
    ;\x02\0\x03\x12\x04\x98\x04+,\n\x0c\n\x04\x04;\x02\x01\x12\x04\x99\x04\
    \x08#\n\r\n\x05\x04;\x02\x01\x04\x12\x04\x99\x04\x08\x10\n\r\n\x05\x04;\
    \x02\x01\x05\x12\x04\x99\x04\x11\x17\n\r\n\x05\x04;\x02\x01\x01\x12\x04\
    \x99\x04\x18\x1e\n\r\n\x05\x04;\x02\x01\x03\x12\x04\x99\x04!\"\n\x0c\n\
    \x02\x04<\x12\x06\x9c\x04\0\xa4\x04\x01\n\x0b\n\x03\x04<\x01\x12\x04\x9c\
    \x04\x08,\n\x0c\n\x04\x04<\x02\0\x12\x04\x9d\x04\x08#\n\r\n\x05\x04<\x02\
    \0\x04\x12\x04\x9d\x04\x08\x10\n\r\n\x05\x04<\x02\0\x05\x12\x04\x9d\x04\
    \x11\x17\n\r\n\x05\x04<\x02\0\x01\x12\x04\x9d\x04\x18\x1e\n\r\n\x05\x04<\
    \x02\0\x03\x12\x04\x9d\x04!\"\n\x0c\n\x04\x04<\x02\x01\x12\x04\x9e\x04\
    \x08$\n\r\n\x05\x04<\x02\x01\x04\x12\x04\x9e\x04\x08\x10\n\r\n\x05\x04<\
    \x02\x01\x05\x12\x04\x9e\x04\x11\x17\n\r\n\x05\x04<\x02\x01\x01\x12\x04\
    \x9e\x04\x18\x1f\n\r\n\x05\x04<\x02\x01\x03\x12\x04\x9e\x04\"#\n\x0c\n\
    \x04\x04<\x02\x02\x12\x04\x9f\x04\x08)\n\r\n\x05\x04<\x02\x02\x04\x12\
    \x04\x9f\x04\x08\x10\n\r\n\x05\x04<\x02\x02\x05\x12\x04\x9f\x04\x11\x17\
    \n\r\n\x05\x04<\x02\x02\x01\x12\x04\x9f\x04\x18$\n\r\n\x05\x04<\x02\x02\
    \x03\x12\x04\x9f\x04'(\n\x0c\n\x04\x04<\x02\x03\x12\x04\xa0\x04\x08'\n\r\
    \n\x05\x04<\x02\x03\x04\x12\x04\xa0\x04\x08\x10\n\r\n\x05\x04<\x02\x03\
    \x05\x12\x04\xa0\x04\x11\x17\n\r\n\x05\x04<\x02\x03\x01\x12\x04\xa0\x04\
    \x18\"\n\r\n\x05\x04<\x02\x03\x03\x12\x04\xa0\x04%&\n\x0c\n\x04\x04<\x02\
    \x04\x12\x04\xa1\x04\x085\n\r\n\x05\x04<\x02\x04\x04\x12\x04\xa1\x04\x08\
    \x10\n\r\n\x05\x04<\x02\x04\x05\x12\x04\xa1\x04\x11\x17\n\r\n\x05\x04<\
    \x02\x04\x01\x12\x04\xa1\x04\x180\n\r\n\x05\x04<\x02\x04\x03\x12\x04\xa1\
    \x0434\n\x0c\n\x04\x04<\x02\x05\x12\x04\xa2\x04\x085\n\r\n\x05\x04<\x02\
    \x05\x04\x12\x04\xa2\x04\x08\x10\n\r\n\x05\x04<\x02\x05\x05\x12\x04\xa2\
    \x04\x11\x17\n\r\n\x05\x04<\x02\x05\x01\x12\x04\xa2\x04\x180\n\r\n\x05\
    \x04<\x02\x05\x03\x12\x04\xa2\x0434\n\x0c\n\x04\x04<\x02\x06\x12\x04\xa3\
    \x04\x085\n\r\n\x05\x04<\x02\x06\x04\x12\x04\xa3\x04\x08\x10\n\r\n\x05\
    \x04<\x02\x06\x05\x12\x04\xa3\x04\x11\x17\n\r\n\x05\x04<\x02\x06\x01\x12\
    \x04\xa3\x04\x180\n\r\n\x05\x04<\x02\x06\x03\x12\x04\xa3\x0434\n\x0c\n\
    \x02\x04=\x12\x06\xa6\x04\0\xac\x04\x01\n\x0b\n\x03\x04=\x01\x12\x04\xa6\
    \x04\x08#\n\x0c\n\x04\x04=\x02\0\x12\x04\xa7\x04\x08#\n\r\n\x05\x04=\x02\
    \0\x04\x12\x04\xa7\x04\x08\x10\n\r\n\x05\x04=\x02\0\x05\x12\x04\xa7\x04\
    \x11\x17\n\r\n\x05\x04=\x02\0\x01\x12\x04\xa7\x04\x18\x1e\n\r\n\x05\x04=\
    \x02\0\x03\x12\x04\xa7\x04!\"\n\x0c\n\x04\x04=\x02\x01\x12\x04\xa8\x04\
    \x083\n\r\n\x05\x04=\x02\x01\x04\x12\x04\xa8\x04\x08\x10\n\r\n\x05\x04=\
    \x02\x01\x05\x12\x04\xa8\x04\x11\x17\n\r\n\x05\x04=\x02\x01\x01\x12\x04\
    \xa8\x04\x18.\n\r\n\x05\x04=\x02\x01\x03\x12\x04\xa8\x0412\n\x0c\n\x04\
    \x04=\x02\x02\x12\x04\xa9\x04\x081\n\r\n\x05\x04=\x02\x02\x04\x12\x04\
    \xa9\x04\x08\x10\n\r\n\x05\x04=\x02\x02\x05\x12\x04\xa9\x04\x11\x18\n\r\
    \n\x05\x04=\x02\x02\x01\x12\x04\xa9\x04\x19,\n\r\n\x05\x04=\x02\x02\x03\
    \x12\x04\xa9\x04/0\n\x0c\n\x04\x04=\x02\x03\x12\x04\xaa\x04\x08-\n\r\n\
    \x05\x04=\x02\x03\x04\x12\x04\xaa\x04\x08\x10\n\r\n\x05\x04=\x02\x03\x05\
    \x12\x04\xaa\x04\x11\x17\n\r\n\x05\x04=\x02\x03\x01\x12\x04\xaa\x04\x18(\
    \n\r\n\x05\x04=\x02\x03\x03\x12\x04\xaa\x04+,\n\x0c\n\x04\x04=\x02\x04\
    \x12\x04\xab\x04\x08(\n\r\n\x05\x04=\x02\x04\x04\x12\x04\xab\x04\x08\x10\
    \n\r\n\x05\x04=\x02\x04\x05\x12\x04\xab\x04\x11\x17\n\r\n\x05\x04=\x02\
    \x04\x01\x12\x04\xab\x04\x18#\n\r\n\x05\x04=\x02\x04\x03\x12\x04\xab\x04\
    &'\n\x0c\n\x02\x04>\x12\x06\xae\x04\0\xbd\x04\x01\n\x0b\n\x03\x04>\x01\
    \x12\x04\xae\x04\x08+\n\x0e\n\x04\x04>\x03\0\x12\x06\xaf\x04\x08\xb7\x04\
    \t\n\r\n\x05\x04>\x03\0\x01\x12\x04\xaf\x04\x10\x13\n\x10\n\x06\x04>\x03\
    \0\x03\0\x12\x06\xb0\x04\x10\xb3\x04\x11\n\x0f\n\x07\x04>\x03\0\x03\0\
    \x01\x12\x04\xb0\x04\x18\x1c\n\x10\n\x08\x04>\x03\0\x03\0\x02\0\x12\x04\
    \xb1\x04\x183\n\x11\n\t\x04>\x03\0\x03\0\x02\0\x04\x12\x04\xb1\x04\x18\
    \x20\n\x11\n\t\x04>\x03\0\x03\0\x02\0\x05\x12\x04\xb1\x04!&\n\x11\n\t\
    \x04>\x03\0\x03\0\x02\0\x01\x12\x04\xb1\x04'.\n\x11\n\t\x04>\x03\0\x03\0\
    \x02\0\x03\x12\x04\xb1\x0412\n\x10\n\x08\x04>\x03\0\x03\0\x02\x01\x12\
    \x04\xb2\x04\x180\n\x11\n\t\x04>\x03\0\x03\0\x02\x01\x04\x12\x04\xb2\x04\
    \x18\x20\n\x11\n\t\x04>\x03\0\x03\0\x02\x01\x05\x12\x04\xb2\x04!&\n\x11\
    \n\t\x04>\x03\0\x03\0\x02\x01\x01\x12\x04\xb2\x04'+\n\x11\n\t\x04>\x03\0\
    \x03\0\x02\x01\x03\x12\x04\xb2\x04./\n\x0e\n\x06\x04>\x03\0\x02\0\x12\
    \x04\xb5\x04\x10+\n\x0f\n\x07\x04>\x03\0\x02\0\x04\x12\x04\xb5\x04\x10\
    \x18\n\x0f\n\x07\x04>\x03\0\x02\0\x05\x12\x04\xb5\x04\x19\x1f\n\x0f\n\
    \x07\x04>\x03\0\x02\0\x01\x12\x04\xb5\x04\x20&\n\x0f\n\x07\x04>\x03\0\
    \x02\0\x03\x12\x04\xb5\x04)*\n\x0e\n\x06\x04>\x03\0\x02\x01\x12\x04\xb6\
    \x04\x10Q\n\x0f\n\x07\x04>\x03\0\x02\x01\x04\x12\x04\xb6\x04\x10\x18\n\
    \x0f\n\x07\x04>\x03\0\x02\x01\x06\x12\x04\xb6\x04\x19F\n\x0f\n\x07\x04>\
    \x03\0\x02\x01\x01\x12\x04\xb6\x04GL\n\x0f\n\x07\x04>\x03\0\x02\x01\x03\
    \x12\x04\xb6\x04OP\n\x0c\n\x04\x04>\x02\0\x12\x04\xb9\x04\x081\n\r\n\x05\
    \x04>\x02\0\x04\x12\x04\xb9\x04\x08\x10\n\r\n\x05\x04>\x02\0\x05\x12\x04\
    \xb9\x04\x11\x16\n\r\n\x05\x04>\x02\0\x01\x12\x04\xb9\x04\x17\x1e\n\r\n\
    \x05\x04>\x02\0\x03\x12\x04\xb9\x04!\"\n\r\n\x05\x04>\x02\0\x08\x12\x04\
    \xb9\x04#0\n\r\n\x05\x04>\x02\0\x07\x12\x04\xb9\x04./\n\x0c\n\x04\x04>\
    \x02\x01\x12\x04\xba\x04\x08'\n\r\n\x05\x04>\x02\x01\x04\x12\x04\xba\x04\
    \x08\x10\n\r\n\x05\x04>\x02\x01\x05\x12\x04\xba\x04\x11\x18\n\r\n\x05\
    \x04>\x02\x01\x01\x12\x04\xba\x04\x19\"\n\r\n\x05\x04>\x02\x01\x03\x12\
    \x04\xba\x04%&\n\x0c\n\x04\x04>\x02\x02\x12\x04\xbb\x04\x08'\n\r\n\x05\
    \x04>\x02\x02\x04\x12\x04\xbb\x04\x08\x10\n\r\n\x05\x04>\x02\x02\x05\x12\
    \x04\xbb\x04\x11\x16\n\r\n\x05\x04>\x02\x02\x01\x12\x04\xbb\x04\x17\"\n\
    \r\n\x05\x04>\x02\x02\x03\x12\x04\xbb\x04%&\n\x0c\n\x04\x04>\x02\x03\x12\
    \x04\xbc\x04\x08C\n\r\n\x05\x04>\x02\x03\x04\x12\x04\xbc\x04\x08\x10\n\r\
    \n\x05\x04>\x02\x03\x06\x12\x04\xbc\x04\x119\n\r\n\x05\x04>\x02\x03\x01\
    \x12\x04\xbc\x04:>\n\r\n\x05\x04>\x02\x03\x03\x12\x04\xbc\x04AB\n\x0c\n\
    \x02\x04?\x12\x06\xbf\x04\0\xdd\x04\x01\n\x0b\n\x03\x04?\x01\x12\x04\xbf\
    \x04\x08\x1a\n\x0e\n\x04\x04?\x03\0\x12\x06\xc0\x04\x08\xc2\x04\t\n\r\n\
    \x05\x04?\x03\0\x01\x12\x04\xc0\x04\x10\x16\n\x0e\n\x06\x04?\x03\0\x02\0\
    \x12\x04\xc1\x04\x10.\n\x0f\n\x07\x04?\x03\0\x02\0\x04\x12\x04\xc1\x04\
    \x10\x18\n\x0f\n\x07\x04?\x03\0\x02\0\x05\x12\x04\xc1\x04\x19\x20\n\x0f\
    \n\x07\x04?\x03\0\x02\0\x01\x12\x04\xc1\x04!)\n\x0f\n\x07\x04?\x03\0\x02\
    \0\x03\x12\x04\xc1\x04,-\n\x0c\n\x04\x04?\x02\0\x12\x04\xc4\x04\x08&\n\r\
    \n\x05\x04?\x02\0\x04\x12\x04\xc4\x04\x08\x10\n\r\n\x05\x04?\x02\0\x05\
    \x12\x04\xc4\x04\x11\x17\n\r\n\x05\x04?\x02\0\x01\x12\x04\xc4\x04\x18\
    \x20\n\r\n\x05\x04?\x02\0\x03\x12\x04\xc4\x04#%\n\x0c\n\x04\x04?\x02\x01\
    \x12\x04\xc5\x04\x08)\n\r\n\x05\x04?\x02\x01\x04\x12\x04\xc5\x04\x08\x10\
    \n\r\n\x05\x04?\x02\x01\x05\x12\x04\xc5\x04\x11\x18\n\r\n\x05\x04?\x02\
    \x01\x01\x12\x04\xc5\x04\x19$\n\r\n\x05\x04?\x02\x01\x03\x12\x04\xc5\x04\
    '(\n\x0c\n\x04\x04?\x02\x02\x12\x04\xc6\x04\x08'\n\r\n\x05\x04?\x02\x02\
    \x04\x12\x04\xc6\x04\x08\x10\n\r\n\x05\x04?\x02\x02\x05\x12\x04\xc6\x04\
    \x11\x17\n\r\n\x05\x04?\x02\x02\x01\x12\x04\xc6\x04\x18\"\n\r\n\x05\x04?\
    \x02\x02\x03\x12\x04\xc6\x04%&\n\x0c\n\x04\x04?\x02\x03\x12\x04\xc7\x04\
    \x08&\n\r\n\x05\x04?\x02\x03\x04\x12\x04\xc7\x04\x08\x10\n\r\n\x05\x04?\
    \x02\x03\x05\x12\x04\xc7\x04\x11\x17\n\r\n\x05\x04?\x02\x03\x01\x12\x04\
    \xc7\x04\x18!\n\r\n\x05\x04?\x02\x03\x03\x12\x04\xc7\x04$%\n\x0c\n\x04\
    \x04?\x02\x04\x12\x04\xc8\x04\x08+\n\r\n\x05\x04?\x02\x04\x04\x12\x04\
    \xc8\x04\x08\x10\n\r\n\x05\x04?\x02\x04\x05\x12\x04\xc8\x04\x11\x17\n\r\
    \n\x05\x04?\x02\x04\x01\x12\x04\xc8\x04\x18&\n\r\n\x05\x04?\x02\x04\x03\
    \x12\x04\xc8\x04)*\n\x0c\n\x04\x04?\x02\x05\x12\x04\xc9\x04\x08)\n\r\n\
    \x05\x04?\x02\x05\x04\x12\x04\xc9\x04\x08\x10\n\r\n\x05\x04?\x02\x05\x05\
    \x12\x04\xc9\x04\x11\x17\n\r\n\x05\x04?\x02\x05\x01\x12\x04\xc9\x04\x18#\
    \n\r\n\x05\x04?\x02\x05\x03\x12\x04\xc9\x04&(\n\x0c\n\x04\x04?\x02\x06\
    \x12\x04\xca\x04\x08.\n\r\n\x05\x04?\x02\x06\x04\x12\x04\xca\x04\x08\x10\
    \n\r\n\x05\x04?\x02\x06\x05\x12\x04\xca\x04\x11\x17\n\r\n\x05\x04?\x02\
    \x06\x01\x12\x04\xca\x04\x18(\n\r\n\x05\x04?\x02\x06\x03\x12\x04\xca\x04\
    +-\n\x0c\n\x04\x04?\x02\x07\x12\x04\xcb\x04\x083\n\r\n\x05\x04?\x02\x07\
    \x04\x12\x04\xcb\x04\x08\x10\n\r\n\x05\x04?\x02\x07\x05\x12\x04\xcb\x04\
    \x11\x17\n\r\n\x05\x04?\x02\x07\x01\x12\x04\xcb\x04\x18-\n\r\n\x05\x04?\
    \x02\x07\x03\x12\x04\xcb\x0402\n\x0c\n\x04\x04?\x02\x08\x12\x04\xcc\x04\
    \x08&\n\r\n\x05\x04?\x02\x08\x04\x12\x04\xcc\x04\x08\x10\n\r\n\x05\x04?\
    \x02\x08\x05\x12\x04\xcc\x04\x11\x18\n\r\n\x05\x04?\x02\x08\x01\x12\x04\
    \xcc\x04\x19\x20\n\r\n\x05\x04?\x02\x08\x03\x12\x04\xcc\x04#%\n\x0c\n\
    \x04\x04?\x02\t\x12\x04\xcd\x04\x08&\n\r\n\x05\x04?\x02\t\x04\x12\x04\
    \xcd\x04\x08\x10\n\r\n\x05\x04?\x02\t\x05\x12\x04\xcd\x04\x11\x16\n\r\n\
    \x05\x04?\x02\t\x01\x12\x04\xcd\x04\x17\x20\n\r\n\x05\x04?\x02\t\x03\x12\
    \x04\xcd\x04#%\n\x0c\n\x04\x04?\x02\n\x12\x04\xce\x04\x08#\n\r\n\x05\x04\
    ?\x02\n\x04\x12\x04\xce\x04\x08\x10\n\r\n\x05\x04?\x02\n\x05\x12\x04\xce\
    \x04\x11\x17\n\r\n\x05\x04?\x02\n\x01\x12\x04\xce\x04\x18\x1e\n\r\n\x05\
    \x04?\x02\n\x03\x12\x04\xce\x04!\"\n\x0c\n\x04\x04?\x02\x0b\x12\x04\xcf\
    \x04\x08$\n\r\n\x05\x04?\x02\x0b\x04\x12\x04\xcf\x04\x08\x10\n\r\n\x05\
    \x04?\x02\x0b\x05\x12\x04\xcf\x04\x11\x17\n\r\n\x05\x04?\x02\x0b\x01\x12\
    \x04\xcf\x04\x18\x1f\n\r\n\x05\x04?\x02\x0b\x03\x12\x04\xcf\x04\"#\n\x0c\
    \n\x04\x04?\x02\x0c\x12\x04\xd0\x04\x08$\n\r\n\x05\x04?\x02\x0c\x04\x12\
    \x04\xd0\x04\x08\x10\n\r\n\x05\x04?\x02\x0c\x05\x12\x04\xd0\x04\x11\x17\
    \n\r\n\x05\x04?\x02\x0c\x01\x12\x04\xd0\x04\x18\x1f\n\r\n\x05\x04?\x02\
    \x0c\x03\x12\x04\xd0\x04\"#\n\x0c\n\x04\x04?\x02\r\x12\x04\xd1\x04\x08$\
    \n\r\n\x05\x04?\x02\r\x04\x12\x04\xd1\x04\x08\x10\n\r\n\x05\x04?\x02\r\
    \x05\x12\x04\xd1\x04\x11\x17\n\r\n\x05\x04?\x02\r\x01\x12\x04\xd1\x04\
    \x18\x1f\n\r\n\x05\x04?\x02\r\x03\x12\x04\xd1\x04\"#\n\x0c\n\x04\x04?\
    \x02\x0e\x12\x04\xd2\x04\x08$\n\r\n\x05\x04?\x02\x0e\x04\x12\x04\xd2\x04\
    \x08\x10\n\r\n\x05\x04?\x02\x0e\x05\x12\x04\xd2\x04\x11\x17\n\r\n\x05\
    \x04?\x02\x0e\x01\x12\x04\xd2\x04\x18\x1e\n\r\n\x05\x04?\x02\x0e\x03\x12\
    \x04\xd2\x04!#\n\x0c\n\x04\x04?\x02\x0f\x12\x04\xd3\x04\x089\n\r\n\x05\
    \x04?\x02\x0f\x04\x12\x04\xd3\x04\x08\x10\n\r\n\x05\x04?\x02\x0f\x06\x12\
    \x04\xd3\x04\x11+\n\r\n\x05\x04?\x02\x0f\x01\x12\x04\xd3\x04,3\n\r\n\x05\
    \x04?\x02\x0f\x03\x12\x04\xd3\x0468\n\x0c\n\x04\x04?\x02\x10\x12\x04\xd4\
    \x04\x08)\n\r\n\x05\x04?\x02\x10\x04\x12\x04\xd4\x04\x08\x10\n\r\n\x05\
    \x04?\x02\x10\x05\x12\x04\xd4\x04\x11\x17\n\r\n\x05\x04?\x02\x10\x01\x12\
    \x04\xd4\x04\x18#\n\r\n\x05\x04?\x02\x10\x03\x12\x04\xd4\x04&(\n\x0c\n\
    \x04\x04?\x02\x11\x12\x04\xd5\x04\x08'\n\r\n\x05\x04?\x02\x11\x04\x12\
    \x04\xd5\x04\x08\x10\n\r\n\x05\x04?\x02\x11\x05\x12\x04\xd5\x04\x11\x17\
    \n\r\n\x05\x04?\x02\x11\x01\x12\x04\xd5\x04\x18!\n\r\n\x05\x04?\x02\x11\
    \x03\x12\x04\xd5\x04$&\n\x0c\n\x04\x04?\x02\x12\x12\x04\xd6\x04\x08$\n\r\
    \n\x05\x04?\x02\x12\x04\x12\x04\xd6\x04\x08\x10\n\r\n\x05\x04?\x02\x12\
    \x05\x12\x04\xd6\x04\x11\x15\n\r\n\x05\x04?\x02\x12\x01\x12\x04\xd6\x04\
    \x16\x1e\n\r\n\x05\x04?\x02\x12\x03\x12\x04\xd6\x04!#\n\x0c\n\x04\x04?\
    \x02\x13\x12\x04\xd7\x04\x08\"\n\r\n\x05\x04?\x02\x13\x04\x12\x04\xd7\
    \x04\x08\x10\n\r\n\x05\x04?\x02\x13\x05\x12\x04\xd7\x04\x11\x15\n\r\n\
    \x05\x04?\x02\x13\x01\x12\x04\xd7\x04\x16\x1c\n\r\n\x05\x04?\x02\x13\x03\
    \x12\x04\xd7\x04\x1f!\n\x0c\n\x04\x04?\x02\x14\x12\x04\xd8\x04\x08%\n\r\
    \n\x05\x04?\x02\x14\x04\x12\x04\xd8\x04\x08\x10\n\r\n\x05\x04?\x02\x14\
    \x05\x12\x04\xd8\x04\x11\x15\n\r\n\x05\x04?\x02\x14\x01\x12\x04\xd8\x04\
    \x16\x1f\n\r\n\x05\x04?\x02\x14\x03\x12\x04\xd8\x04\"$\n\x0c\n\x04\x04?\
    \x02\x15\x12\x04\xd9\x04\x08\x20\n\r\n\x05\x04?\x02\x15\x04\x12\x04\xd9\
    \x04\x08\x10\n\r\n\x05\x04?\x02\x15\x05\x12\x04\xd9\x04\x11\x17\n\r\n\
    \x05\x04?\x02\x15\x01\x12\x04\xd9\x04\x18\x1a\n\r\n\x05\x04?\x02\x15\x03\
    \x12\x04\xd9\x04\x1d\x1f\n\x0c\n\x04\x04?\x02\x16\x12\x04\xda\x04\x08'\n\
    \r\n\x05\x04?\x02\x16\x04\x12\x04\xda\x04\x08\x10\n\r\n\x05\x04?\x02\x16\
    \x05\x12\x04\xda\x04\x11\x17\n\r\n\x05\x04?\x02\x16\x01\x12\x04\xda\x04\
    \x18!\n\r\n\x05\x04?\x02\x16\x03\x12\x04\xda\x04$&\n\x0c\n\x04\x04?\x02\
    \x17\x12\x04\xdb\x04\x08'\n\r\n\x05\x04?\x02\x17\x04\x12\x04\xdb\x04\x08\
    \x10\n\r\n\x05\x04?\x02\x17\x05\x12\x04\xdb\x04\x11\x17\n\r\n\x05\x04?\
    \x02\x17\x01\x12\x04\xdb\x04\x18!\n\r\n\x05\x04?\x02\x17\x03\x12\x04\xdb\
    \x04$&\n\x0c\n\x04\x04?\x02\x18\x12\x04\xdc\x04\x08!\n\r\n\x05\x04?\x02\
    \x18\x04\x12\x04\xdc\x04\x08\x10\n\r\n\x05\x04?\x02\x18\x05\x12\x04\xdc\
    \x04\x11\x17\n\r\n\x05\x04?\x02\x18\x01\x12\x04\xdc\x04\x18\x1b\n\r\n\
    \x05\x04?\x02\x18\x03\x12\x04\xdc\x04\x1e\x20\n\x0c\n\x02\x04@\x12\x06\
    \xdf\x04\0\xe2\x04\x01\n\x0b\n\x03\x04@\x01\x12\x04\xdf\x04\x08\x1c\n\
    \x0c\n\x04\x04@\x02\0\x12\x04\xe0\x04\x080\n\r\n\x05\x04@\x02\0\x04\x12\
    \x04\xe0\x04\x08\x10\n\r\n\x05\x04@\x02\0\x05\x12\x04\xe0\x04\x11\x18\n\
    \r\n\x05\x04@\x02\0\x01\x12\x04\xe0\x04\x19+\n\r\n\x05\x04@\x02\0\x03\
    \x12\x04\xe0\x04./\n\x0c\n\x04\x04@\x02\x01\x12\x04\xe1\x04\x08.\n\r\n\
    \x05\x04@\x02\x01\x04\x12\x04\xe1\x04\x08\x10\n\r\n\x05\x04@\x02\x01\x05\
    \x12\x04\xe1\x04\x11\x17\n\r\n\x05\x04@\x02\x01\x01\x12\x04\xe1\x04\x18)\
    \n\r\n\x05\x04@\x02\x01\x03\x12\x04\xe1\x04,-\n\x0c\n\x02\x04A\x12\x06\
    \xe4\x04\0\xea\x04\x01\n\x0b\n\x03\x04A\x01\x12\x04\xe4\x04\x08\x20\n\
    \x0c\n\x04\x04A\x02\0\x12\x04\xe5\x04\x08#\n\r\n\x05\x04A\x02\0\x04\x12\
    \x04\xe5\x04\x08\x10\n\r\n\x05\x04A\x02\0\x05\x12\x04\xe5\x04\x11\x17\n\
    \r\n\x05\x04A\x02\0\x01\x12\x04\xe5\x04\x18\x1e\n\r\n\x05\x04A\x02\0\x03\
    \x12\x04\xe5\x04!\"\n\x0c\n\x04\x04A\x02\x01\x12\x04\xe6\x04\x08,\n\r\n\
    \x05\x04A\x02\x01\x04\x12\x04\xe6\x04\x08\x10\n\r\n\x05\x04A\x02\x01\x05\
    \x12\x04\xe6\x04\x11\x17\n\r\n\x05\x04A\x02\x01\x01\x12\x04\xe6\x04\x18'\
    \n\r\n\x05\x04A\x02\x01\x03\x12\x04\xe6\x04*+\n\x0c\n\x04\x04A\x02\x02\
    \x12\x04\xe7\x04\x08(\n\r\n\x05\x04A\x02\x02\x04\x12\x04\xe7\x04\x08\x10\
    \n\r\n\x05\x04A\x02\x02\x05\x12\x04\xe7\x04\x11\x17\n\r\n\x05\x04A\x02\
    \x02\x01\x12\x04\xe7\x04\x18#\n\r\n\x05\x04A\x02\x02\x03\x12\x04\xe7\x04\
    &'\n\x0c\n\x04\x04A\x02\x03\x12\x04\xe8\x04\x08(\n\r\n\x05\x04A\x02\x03\
    \x04\x12\x04\xe8\x04\x08\x10\n\r\n\x05\x04A\x02\x03\x05\x12\x04\xe8\x04\
    \x11\x17\n\r\n\x05\x04A\x02\x03\x01\x12\x04\xe8\x04\x18#\n\r\n\x05\x04A\
    \x02\x03\x03\x12\x04\xe8\x04&'\n\x0c\n\x04\x04A\x02\x04\x12\x04\xe9\x04\
    \x08(\n\r\n\x05\x04A\x02\x04\x04\x12\x04\xe9\x04\x08\x10\n\r\n\x05\x04A\
    \x02\x04\x05\x12\x04\xe9\x04\x11\x17\n\r\n\x05\x04A\x02\x04\x01\x12\x04\
    \xe9\x04\x18#\n\r\n\x05\x04A\x02\x04\x03\x12\x04\xe9\x04&'\n\x0c\n\x02\
    \x04B\x12\x06\xec\x04\0\xf6\x04\x01\n\x0b\n\x03\x04B\x01\x12\x04\xec\x04\
    \x08(\n\x0e\n\x04\x04B\x03\0\x12\x06\xed\x04\x08\xf2\x04\t\n\r\n\x05\x04\
    B\x03\0\x01\x12\x04\xed\x04\x10\x16\n\x0e\n\x06\x04B\x03\0\x02\0\x12\x04\
    \xee\x04\x109\n\x0f\n\x07\x04B\x03\0\x02\0\x04\x12\x04\xee\x04\x10\x18\n\
    \x0f\n\x07\x04B\x03\0\x02\0\x05\x12\x04\xee\x04\x19\x1f\n\x0f\n\x07\x04B\
    \x03\0\x02\0\x01\x12\x04\xee\x04\x204\n\x0f\n\x07\x04B\x03\0\x02\0\x03\
    \x12\x04\xee\x0478\n\x0e\n\x06\x04B\x03\0\x02\x01\x12\x04\xef\x04\x10/\n\
    \x0f\n\x07\x04B\x03\0\x02\x01\x04\x12\x04\xef\x04\x10\x18\n\x0f\n\x07\
    \x04B\x03\0\x02\x01\x05\x12\x04\xef\x04\x19\x1f\n\x0f\n\x07\x04B\x03\0\
    \x02\x01\x01\x12\x04\xef\x04\x20*\n\x0f\n\x07\x04B\x03\0\x02\x01\x03\x12\
    \x04\xef\x04-.\n\x0e\n\x06\x04B\x03\0\x02\x02\x12\x04\xf0\x04\x101\n\x0f\
    \n\x07\x04B\x03\0\x02\x02\x04\x12\x04\xf0\x04\x10\x18\n\x0f\n\x07\x04B\
    \x03\0\x02\x02\x05\x12\x04\xf0\x04\x19\x1f\n\x0f\n\x07\x04B\x03\0\x02\
    \x02\x01\x12\x04\xf0\x04\x20,\n\x0f\n\x07\x04B\x03\0\x02\x02\x03\x12\x04\
    \xf0\x04/0\n\x0e\n\x06\x04B\x03\0\x02\x03\x12\x04\xf1\x04\x106\n\x0f\n\
    \x07\x04B\x03\0\x02\x03\x04\x12\x04\xf1\x04\x10\x18\n\x0f\n\x07\x04B\x03\
    \0\x02\x03\x06\x12\x04\xf1\x04\x19'\n\x0f\n\x07\x04B\x03\0\x02\x03\x01\
    \x12\x04\xf1\x04(1\n\x0f\n\x07\x04B\x03\0\x02\x03\x03\x12\x04\xf1\x0445\
    \n\x0c\n\x04\x04B\x02\0\x12\x04\xf4\x04\x08F\n\r\n\x05\x04B\x02\0\x04\
    \x12\x04\xf4\x04\x08\x10\n\r\n\x05\x04B\x02\0\x06\x12\x04\xf4\x04\x119\n\
    \r\n\x05\x04B\x02\0\x01\x12\x04\xf4\x04:A\n\r\n\x05\x04B\x02\0\x03\x12\
    \x04\xf4\x04DE\n\x0c\n\x04\x04B\x02\x01\x12\x04\xf5\x04\x08\"\n\r\n\x05\
    \x04B\x02\x01\x04\x12\x04\xf5\x04\x08\x10\n\r\n\x05\x04B\x02\x01\x05\x12\
    \x04\xf5\x04\x11\x17\n\r\n\x05\x04B\x02\x01\x01\x12\x04\xf5\x04\x18\x1d\
    \n\r\n\x05\x04B\x02\x01\x03\x12\x04\xf5\x04\x20!\n\x0c\n\x02\x04C\x12\
    \x06\xf8\x04\0\xfc\x04\x01\n\x0b\n\x03\x04C\x01\x12\x04\xf8\x04\x08\x1f\
    \n\x0c\n\x04\x04C\x02\0\x12\x04\xf9\x04\x08)\n\r\n\x05\x04C\x02\0\x04\
    \x12\x04\xf9\x04\x08\x10\n\r\n\x05\x04C\x02\0\x05\x12\x04\xf9\x04\x11\
    \x18\n\r\n\x05\x04C\x02\0\x01\x12\x04\xf9\x04\x19$\n\r\n\x05\x04C\x02\0\
    \x03\x12\x04\xf9\x04'(\n\x0c\n\x04\x04C\x02\x01\x12\x04\xfa\x04\x08!\n\r\
    \n\x05\x04C\x02\x01\x04\x12\x04\xfa\x04\x08\x10\n\r\n\x05\x04C\x02\x01\
    \x05\x12\x04\xfa\x04\x11\x15\n\r\n\x05\x04C\x02\x01\x01\x12\x04\xfa\x04\
    \x16\x1c\n\r\n\x05\x04C\x02\x01\x03\x12\x04\xfa\x04\x1f\x20\n\x0c\n\x04\
    \x04C\x02\x02\x12\x04\xfb\x04\x08$\n\r\n\x05\x04C\x02\x02\x04\x12\x04\
    \xfb\x04\x08\x10\n\r\n\x05\x04C\x02\x02\x05\x12\x04\xfb\x04\x11\x17\n\r\
    \n\x05\x04C\x02\x02\x01\x12\x04\xfb\x04\x18\x1f\n\r\n\x05\x04C\x02\x02\
    \x03\x12\x04\xfb\x04\"#\n\x0c\n\x02\x04D\x12\x06\xfe\x04\0\x80\x05\x01\n\
    \x0b\n\x03\x04D\x01\x12\x04\xfe\x04\x08!\n\x0c\n\x04\x04D\x02\0\x12\x04\
    \xff\x04\x08+\n\r\n\x05\x04D\x02\0\x04\x12\x04\xff\x04\x08\x10\n\r\n\x05\
    \x04D\x02\0\x05\x12\x04\xff\x04\x11\x18\n\r\n\x05\x04D\x02\0\x01\x12\x04\
    \xff\x04\x19&\n\r\n\x05\x04D\x02\0\x03\x12\x04\xff\x04)*\n\x0c\n\x02\x04\
    E\x12\x06\x82\x05\0\x86\x05\x01\n\x0b\n\x03\x04E\x01\x12\x04\x82\x05\x08\
    )\n\x0c\n\x04\x04E\x02\0\x12\x04\x83\x05\x082\n\r\n\x05\x04E\x02\0\x04\
    \x12\x04\x83\x05\x08\x10\n\r\n\x05\x04E\x02\0\x05\x12\x04\x83\x05\x11\
    \x17\n\r\n\x05\x04E\x02\0\x01\x12\x04\x83\x05\x18\x1f\n\r\n\x05\x04E\x02\
    \0\x03\x12\x04\x83\x05\"#\n\r\n\x05\x04E\x02\0\x08\x12\x04\x83\x05$1\n\r\
    \n\x05\x04E\x02\0\x07\x12\x04\x83\x05/0\n\x0c\n\x04\x04E\x02\x01\x12\x04\
    \x84\x05\x08'\n\r\n\x05\x04E\x02\x01\x04\x12\x04\x84\x05\x08\x10\n\r\n\
    \x05\x04E\x02\x01\x05\x12\x04\x84\x05\x11\x17\n\r\n\x05\x04E\x02\x01\x01\
    \x12\x04\x84\x05\x18\"\n\r\n\x05\x04E\x02\x01\x03\x12\x04\x84\x05%&\n\
    \x0c\n\x04\x04E\x02\x02\x12\x04\x85\x05\x08+\n\r\n\x05\x04E\x02\x02\x04\
    \x12\x04\x85\x05\x08\x10\n\r\n\x05\x04E\x02\x02\x05\x12\x04\x85\x05\x11\
    \x17\n\r\n\x05\x04E\x02\x02\x01\x12\x04\x85\x05\x18&\n\r\n\x05\x04E\x02\
    \x02\x03\x12\x04\x85\x05)*\n\x0c\n\x02\x04F\x12\x06\x88\x05\0\x8a\x05\
    \x01\n\x0b\n\x03\x04F\x01\x12\x04\x88\x05\x08'\n\x0c\n\x04\x04F\x02\0\
    \x12\x04\x89\x05\x08*\n\r\n\x05\x04F\x02\0\x04\x12\x04\x89\x05\x08\x10\n\
    \r\n\x05\x04F\x02\0\x05\x12\x04\x89\x05\x11\x17\n\r\n\x05\x04F\x02\0\x01\
    \x12\x04\x89\x05\x18%\n\r\n\x05\x04F\x02\0\x03\x12\x04\x89\x05()\n\x0c\n\
    \x02\x04G\x12\x06\x8c\x05\0\x8e\x05\x01\n\x0b\n\x03\x04G\x01\x12\x04\x8c\
    \x05\x08/\n\x0c\n\x04\x04G\x02\0\x12\x04\x8d\x05\x082\n\r\n\x05\x04G\x02\
    \0\x04\x12\x04\x8d\x05\x08\x10\n\r\n\x05\x04G\x02\0\x05\x12\x04\x8d\x05\
    \x11\x17\n\r\n\x05\x04G\x02\0\x01\x12\x04\x8d\x05\x18\x1f\n\r\n\x05\x04G\
    \x02\0\x03\x12\x04\x8d\x05\"#\n\r\n\x05\x04G\x02\0\x08\x12\x04\x8d\x05$1\
    \n\r\n\x05\x04G\x02\0\x07\x12\x04\x8d\x05/0\n\x0c\n\x02\x04H\x12\x06\x90\
    \x05\0\x96\x05\x01\n\x0b\n\x03\x04H\x01\x12\x04\x90\x05\x08!\n\x0c\n\x04\
    \x04H\x02\0\x12\x04\x91\x05\x08&\n\r\n\x05\x04H\x02\0\x04\x12\x04\x91\
    \x05\x08\x10\n\r\n\x05\x04H\x02\0\x05\x12\x04\x91\x05\x11\x15\n\r\n\x05\
    \x04H\x02\0\x01\x12\x04\x91\x05\x16!\n\r\n\x05\x04H\x02\0\x03\x12\x04\
    \x91\x05$%\n\x0c\n\x04\x04H\x02\x01\x12\x04\x92\x05\x08&\n\r\n\x05\x04H\
    \x02\x01\x04\x12\x04\x92\x05\x08\x10\n\r\n\x05\x04H\x02\x01\x05\x12\x04\
    \x92\x05\x11\x17\n\r\n\x05\x04H\x02\x01\x01\x12\x04\x92\x05\x18!\n\r\n\
    \x05\x04H\x02\x01\x03\x12\x04\x92\x05$%\n\x0c\n\x04\x04H\x02\x02\x12\x04\
    \x93\x05\x08$\n\r\n\x05\x04H\x02\x02\x04\x12\x04\x93\x05\x08\x10\n\r\n\
    \x05\x04H\x02\x02\x05\x12\x04\x93\x05\x11\x16\n\r\n\x05\x04H\x02\x02\x01\
    \x12\x04\x93\x05\x17\x1f\n\r\n\x05\x04H\x02\x02\x03\x12\x04\x93\x05\"#\n\
    \x0c\n\x04\x04H\x02\x03\x12\x04\x94\x05\x08&\n\r\n\x05\x04H\x02\x03\x04\
    \x12\x04\x94\x05\x08\x10\n\r\n\x05\x04H\x02\x03\x05\x12\x04\x94\x05\x11\
    \x17\n\r\n\x05\x04H\x02\x03\x01\x12\x04\x94\x05\x18!\n\r\n\x05\x04H\x02\
    \x03\x03\x12\x04\x94\x05$%\n\x0c\n\x04\x04H\x02\x04\x12\x04\x95\x05\x08#\
    \n\r\n\x05\x04H\x02\x04\x04\x12\x04\x95\x05\x08\x10\n\r\n\x05\x04H\x02\
    \x04\x05\x12\x04\x95\x05\x11\x16\n\r\n\x05\x04H\x02\x04\x01\x12\x04\x95\
    \x05\x17\x1e\n\r\n\x05\x04H\x02\x04\x03\x12\x04\x95\x05!\"\n\x0c\n\x02\
    \x04I\x12\x06\x98\x05\0\x9c\x05\x01\n\x0b\n\x03\x04I\x01\x12\x04\x98\x05\
    \x08\x1e\n\x0c\n\x04\x04I\x02\0\x12\x04\x99\x05\x08&\n\r\n\x05\x04I\x02\
    \0\x04\x12\x04\x99\x05\x08\x10\n\r\n\x05\x04I\x02\0\x05\x12\x04\x99\x05\
    \x11\x17\n\r\n\x05\x04I\x02\0\x01\x12\x04\x99\x05\x18!\n\r\n\x05\x04I\
    \x02\0\x03\x12\x04\x99\x05$%\n\x0c\n\x04\x04I\x02\x01\x12\x04\x9a\x05\
    \x08$\n\r\n\x05\x04I\x02\x01\x04\x12\x04\x9a\x05\x08\x10\n\r\n\x05\x04I\
    \x02\x01\x05\x12\x04\x9a\x05\x11\x17\n\r\n\x05\x04I\x02\x01\x01\x12\x04\
    \x9a\x05\x18\x1f\n\r\n\x05\x04I\x02\x01\x03\x12\x04\x9a\x05\"#\n\x0c\n\
    \x04\x04I\x02\x02\x12\x04\x9b\x05\x08&\n\r\n\x05\x04I\x02\x02\x04\x12\
    \x04\x9b\x05\x08\x10\n\r\n\x05\x04I\x02\x02\x05\x12\x04\x9b\x05\x11\x16\
    \n\r\n\x05\x04I\x02\x02\x01\x12\x04\x9b\x05\x17!\n\r\n\x05\x04I\x02\x02\
    \x03\x12\x04\x9b\x05$%\n\x0c\n\x02\x04J\x12\x06\x9e\x05\0\xa0\x05\x01\n\
    \x0b\n\x03\x04J\x01\x12\x04\x9e\x05\x08\x1f\n\x0c\n\x04\x04J\x02\0\x12\
    \x04\x9f\x05\x08+\n\r\n\x05\x04J\x02\0\x04\x12\x04\x9f\x05\x08\x10\n\r\n\
    \x05\x04J\x02\0\x05\x12\x04\x9f\x05\x11\x18\n\r\n\x05\x04J\x02\0\x01\x12\
    \x04\x9f\x05\x19&\n\r\n\x05\x04J\x02\0\x03\x12\x04\x9f\x05)*\n\x0c\n\x02\
    \x04K\x12\x06\xa2\x05\0\xa5\x05\x01\n\x0b\n\x03\x04K\x01\x12\x04\xa2\x05\
    \x08'\n\x0c\n\x04\x04K\x02\0\x12\x04\xa3\x05\x08+\n\r\n\x05\x04K\x02\0\
    \x04\x12\x04\xa3\x05\x08\x10\n\r\n\x05\x04K\x02\0\x05\x12\x04\xa3\x05\
    \x11\x18\n\r\n\x05\x04K\x02\0\x01\x12\x04\xa3\x05\x19&\n\r\n\x05\x04K\
    \x02\0\x03\x12\x04\xa3\x05)*\n\x0c\n\x04\x04K\x02\x01\x12\x04\xa4\x05\
    \x082\n\r\n\x05\x04K\x02\x01\x04\x12\x04\xa4\x05\x08\x10\n\r\n\x05\x04K\
    \x02\x01\x05\x12\x04\xa4\x05\x11\x17\n\r\n\x05\x04K\x02\x01\x01\x12\x04\
    \xa4\x05\x18\x1f\n\r\n\x05\x04K\x02\x01\x03\x12\x04\xa4\x05\"#\n\r\n\x05\
    \x04K\x02\x01\x08\x12\x04\xa4\x05$1\n\r\n\x05\x04K\x02\x01\x07\x12\x04\
    \xa4\x05/0\n\x0c\n\x02\x04L\x12\x06\xa7\x05\0\xa9\x05\x01\n\x0b\n\x03\
    \x04L\x01\x12\x04\xa7\x05\x08+\n\x0c\n\x04\x04L\x02\0\x12\x04\xa8\x05\
    \x080\n\r\n\x05\x04L\x02\0\x04\x12\x04\xa8\x05\x08\x10\n\r\n\x05\x04L\
    \x02\0\x05\x12\x04\xa8\x05\x11\x18\n\r\n\x05\x04L\x02\0\x01\x12\x04\xa8\
    \x05\x19+\n\r\n\x05\x04L\x02\0\x03\x12\x04\xa8\x05./\n\x0c\n\x02\x04M\
    \x12\x06\xab\x05\0\xb2\x05\x01\n\x0b\n\x03\x04M\x01\x12\x04\xab\x05\x083\
    \n\x0c\n\x04\x04M\x02\0\x12\x04\xac\x05\x080\n\r\n\x05\x04M\x02\0\x04\
    \x12\x04\xac\x05\x08\x10\n\r\n\x05\x04M\x02\0\x05\x12\x04\xac\x05\x11\
    \x18\n\r\n\x05\x04M\x02\0\x01\x12\x04\xac\x05\x19+\n\r\n\x05\x04M\x02\0\
    \x03\x12\x04\xac\x05./\n\x0c\n\x04\x04M\x02\x01\x12\x04\xad\x05\x082\n\r\
    \n\x05\x04M\x02\x01\x04\x12\x04\xad\x05\x08\x10\n\r\n\x05\x04M\x02\x01\
    \x05\x12\x04\xad\x05\x11\x17\n\r\n\x05\x04M\x02\x01\x01\x12\x04\xad\x05\
    \x18\x1f\n\r\n\x05\x04M\x02\x01\x03\x12\x04\xad\x05\"#\n\r\n\x05\x04M\
    \x02\x01\x08\x12\x04\xad\x05$1\n\r\n\x05\x04M\x02\x01\x07\x12\x04\xad\
    \x05/0\n\x0c\n\x04\x04M\x02\x02\x12\x04\xae\x05\x08)\n\r\n\x05\x04M\x02\
    \x02\x04\x12\x04\xae\x05\x08\x10\n\r\n\x05\x04M\x02\x02\x05\x12\x04\xae\
    \x05\x11\x15\n\r\n\x05\x04M\x02\x02\x01\x12\x04\xae\x05\x16$\n\r\n\x05\
    \x04M\x02\x02\x03\x12\x04\xae\x05'(\n\x0c\n\x04\x04M\x02\x03\x12\x04\xaf\
    \x05\x08,\n\r\n\x05\x04M\x02\x03\x04\x12\x04\xaf\x05\x08\x10\n\r\n\x05\
    \x04M\x02\x03\x05\x12\x04\xaf\x05\x11\x16\n\r\n\x05\x04M\x02\x03\x01\x12\
    \x04\xaf\x05\x17'\n\r\n\x05\x04M\x02\x03\x03\x12\x04\xaf\x05*+\n\x0c\n\
    \x04\x04M\x02\x04\x12\x04\xb0\x05\x08,\n\r\n\x05\x04M\x02\x04\x04\x12\
    \x04\xb0\x05\x08\x10\n\r\n\x05\x04M\x02\x04\x05\x12\x04\xb0\x05\x11\x16\
    \n\r\n\x05\x04M\x02\x04\x01\x12\x04\xb0\x05\x17'\n\r\n\x05\x04M\x02\x04\
    \x03\x12\x04\xb0\x05*+\n\x0c\n\x04\x04M\x02\x05\x12\x04\xb1\x05\x088\n\r\
    \n\x05\x04M\x02\x05\x04\x12\x04\xb1\x05\x08\x10\n\r\n\x05\x04M\x02\x05\
    \x05\x12\x04\xb1\x05\x11\x16\n\r\n\x05\x04M\x02\x05\x01\x12\x04\xb1\x05\
    \x173\n\r\n\x05\x04M\x02\x05\x03\x12\x04\xb1\x0567\n\x0c\n\x02\x04N\x12\
    \x06\xb4\x05\0\xb5\x05\x01\n\x0b\n\x03\x04N\x01\x12\x04\xb4\x05\x08\x1a\
    \n\x0c\n\x02\x04O\x12\x06\xb7\x05\0\xbe\x05\x01\n\x0b\n\x03\x04O\x01\x12\
    \x04\xb7\x05\x08\x14\n\x0c\n\x04\x04O\x02\0\x12\x04\xb8\x05\x08\"\n\r\n\
    \x05\x04O\x02\0\x04\x12\x04\xb8\x05\x08\x10\n\r\n\x05\x04O\x02\0\x05\x12\
    \x04\xb8\x05\x11\x17\n\r\n\x05\x04O\x02\0\x01\x12\x04\xb8\x05\x18\x1d\n\
    \r\n\x05\x04O\x02\0\x03\x12\x04\xb8\x05\x20!\n\x0c\n\x04\x04O\x02\x01\
    \x12\x04\xb9\x05\x08$\n\r\n\x05\x04O\x02\x01\x04\x12\x04\xb9\x05\x08\x10\
    \n\r\n\x05\x04O\x02\x01\x05\x12\x04\xb9\x05\x11\x17\n\r\n\x05\x04O\x02\
    \x01\x01\x12\x04\xb9\x05\x18\x1f\n\r\n\x05\x04O\x02\x01\x03\x12\x04\xb9\
    \x05\"#\n\x0c\n\x04\x04O\x02\x02\x12\x04\xba\x05\x08#\n\r\n\x05\x04O\x02\
    \x02\x04\x12\x04\xba\x05\x08\x10\n\r\n\x05\x04O\x02\x02\x05\x12\x04\xba\
    \x05\x11\x16\n\r\n\x05\x04O\x02\x02\x01\x12\x04\xba\x05\x17\x1e\n\r\n\
    \x05\x04O\x02\x02\x03\x12\x04\xba\x05!\"\n\x0c\n\x04\x04O\x02\x03\x12\
    \x04\xbb\x05\x08%\n\r\n\x05\x04O\x02\x03\x04\x12\x04\xbb\x05\x08\x10\n\r\
    \n\x05\x04O\x02\x03\x05\x12\x04\xbb\x05\x11\x18\n\r\n\x05\x04O\x02\x03\
    \x01\x12\x04\xbb\x05\x19\x20\n\r\n\x05\x04O\x02\x03\x03\x12\x04\xbb\x05#\
    $\n\x0c\n\x04\x04O\x02\x04\x12\x04\xbc\x05\x08#\n\r\n\x05\x04O\x02\x04\
    \x04\x12\x04\xbc\x05\x08\x10\n\r\n\x05\x04O\x02\x04\x05\x12\x04\xbc\x05\
    \x11\x17\n\r\n\x05\x04O\x02\x04\x01\x12\x04\xbc\x05\x18\x1e\n\r\n\x05\
    \x04O\x02\x04\x03\x12\x04\xbc\x05!\"\n\x0c\n\x04\x04O\x02\x05\x12\x04\
    \xbd\x05\x08\x1f\n\r\n\x05\x04O\x02\x05\x04\x12\x04\xbd\x05\x08\x10\n\r\
    \n\x05\x04O\x02\x05\x05\x12\x04\xbd\x05\x11\x17\n\r\n\x05\x04O\x02\x05\
    \x01\x12\x04\xbd\x05\x18\x1a\n\r\n\x05\x04O\x02\x05\x03\x12\x04\xbd\x05\
    \x1d\x1e\n\x0c\n\x02\x04P\x12\x06\xc0\x05\0\xc2\x05\x01\n\x0b\n\x03\x04P\
    \x01\x12\x04\xc0\x05\x08$\n\x0c\n\x04\x04P\x02\0\x12\x04\xc1\x05\x08#\n\
    \r\n\x05\x04P\x02\0\x04\x12\x04\xc1\x05\x08\x10\n\r\n\x05\x04P\x02\0\x05\
    \x12\x04\xc1\x05\x11\x17\n\r\n\x05\x04P\x02\0\x01\x12\x04\xc1\x05\x18\
    \x1e\n\r\n\x05\x04P\x02\0\x03\x12\x04\xc1\x05!\"\n\x0c\n\x02\x04Q\x12\
    \x06\xc4\x05\0\xc8\x05\x01\n\x0b\n\x03\x04Q\x01\x12\x04\xc4\x05\x08,\n\
    \x0c\n\x04\x04Q\x02\0\x12\x04\xc5\x05\x082\n\r\n\x05\x04Q\x02\0\x04\x12\
    \x04\xc5\x05\x08\x10\n\r\n\x05\x04Q\x02\0\x05\x12\x04\xc5\x05\x11\x17\n\
    \r\n\x05\x04Q\x02\0\x01\x12\x04\xc5\x05\x18\x1f\n\r\n\x05\x04Q\x02\0\x03\
    \x12\x04\xc5\x05\"#\n\r\n\x05\x04Q\x02\0\x08\x12\x04\xc5\x05$1\n\r\n\x05\
    \x04Q\x02\0\x07\x12\x04\xc5\x05/0\n\x0c\n\x04\x04Q\x02\x01\x12\x04\xc6\
    \x05\x08/\n\r\n\x05\x04Q\x02\x01\x04\x12\x04\xc6\x05\x08\x10\n\r\n\x05\
    \x04Q\x02\x01\x05\x12\x04\xc6\x05\x11\x17\n\r\n\x05\x04Q\x02\x01\x01\x12\
    \x04\xc6\x05\x18*\n\r\n\x05\x04Q\x02\x01\x03\x12\x04\xc6\x05-.\n\x0c\n\
    \x04\x04Q\x02\x02\x12\x04\xc7\x05\x08+\n\r\n\x05\x04Q\x02\x02\x04\x12\
    \x04\xc7\x05\x08\x10\n\r\n\x05\x04Q\x02\x02\x05\x12\x04\xc7\x05\x11\x17\
    \n\r\n\x05\x04Q\x02\x02\x01\x12\x04\xc7\x05\x18&\n\r\n\x05\x04Q\x02\x02\
    \x03\x12\x04\xc7\x05)*\n\x0c\n\x02\x04R\x12\x06\xca\x05\0\xd3\x05\x01\n\
    \x0b\n\x03\x04R\x01\x12\x04\xca\x05\x08+\n\x0c\n\x04\x04R\x02\0\x12\x04\
    \xcb\x05\x08+\n\r\n\x05\x04R\x02\0\x04\x12\x04\xcb\x05\x08\x10\n\r\n\x05\
    \x04R\x02\0\x05\x12\x04\xcb\x05\x11\x17\n\r\n\x05\x04R\x02\0\x01\x12\x04\
    \xcb\x05\x18&\n\r\n\x05\x04R\x02\0\x03\x12\x04\xcb\x05)*\n\x0c\n\x04\x04\
    R\x02\x01\x12\x04\xcc\x05\x081\n\r\n\x05\x04R\x02\x01\x04\x12\x04\xcc\
    \x05\x08\x10\n\r\n\x05\x04R\x02\x01\x05\x12\x04\xcc\x05\x11\x17\n\r\n\
    \x05\x04R\x02\x01\x01\x12\x04\xcc\x05\x18,\n\r\n\x05\x04R\x02\x01\x03\
    \x12\x04\xcc\x05/0\n\x0c\n\x04\x04R\x02\x02\x12\x04\xcd\x05\x08$\n\r\n\
    \x05\x04R\x02\x02\x04\x12\x04\xcd\x05\x08\x10\n\r\n\x05\x04R\x02\x02\x05\
    \x12\x04\xcd\x05\x11\x16\n\r\n\x05\x04R\x02\x02\x01\x12\x04\xcd\x05\x17\
    \x1f\n\r\n\x05\x04R\x02\x02\x03\x12\x04\xcd\x05\"#\n\x0c\n\x04\x04R\x02\
    \x03\x12\x04\xce\x05\x08&\n\r\n\x05\x04R\x02\x03\x04\x12\x04\xce\x05\x08\
    \x10\n\r\n\x05\x04R\x02\x03\x05\x12\x04\xce\x05\x11\x16\n\r\n\x05\x04R\
    \x02\x03\x01\x12\x04\xce\x05\x17!\n\r\n\x05\x04R\x02\x03\x03\x12\x04\xce\
    \x05$%\n\x0c\n\x04\x04R\x02\x04\x12\x04\xcf\x05\x08&\n\r\n\x05\x04R\x02\
    \x04\x04\x12\x04\xcf\x05\x08\x10\n\r\n\x05\x04R\x02\x04\x05\x12\x04\xcf\
    \x05\x11\x16\n\r\n\x05\x04R\x02\x04\x01\x12\x04\xcf\x05\x17!\n\r\n\x05\
    \x04R\x02\x04\x03\x12\x04\xcf\x05$%\n\x0c\n\x04\x04R\x02\x05\x12\x04\xd0\
    \x05\x08(\n\r\n\x05\x04R\x02\x05\x04\x12\x04\xd0\x05\x08\x10\n\r\n\x05\
    \x04R\x02\x05\x05\x12\x04\xd0\x05\x11\x17\n\r\n\x05\x04R\x02\x05\x01\x12\
    \x04\xd0\x05\x18#\n\r\n\x05\x04R\x02\x05\x03\x12\x04\xd0\x05&'\n\x0c\n\
    \x04\x04R\x02\x06\x12\x04\xd1\x05\x08(\n\r\n\x05\x04R\x02\x06\x04\x12\
    \x04\xd1\x05\x08\x10\n\r\n\x05\x04R\x02\x06\x05\x12\x04\xd1\x05\x11\x17\
    \n\r\n\x05\x04R\x02\x06\x01\x12\x04\xd1\x05\x18#\n\r\n\x05\x04R\x02\x06\
    \x03\x12\x04\xd1\x05&'\n\x0c\n\x04\x04R\x02\x07\x12\x04\xd2\x05\x08&\n\r\
    \n\x05\x04R\x02\x07\x04\x12\x04\xd2\x05\x08\x10\n\r\n\x05\x04R\x02\x07\
    \x05\x12\x04\xd2\x05\x11\x16\n\r\n\x05\x04R\x02\x07\x01\x12\x04\xd2\x05\
    \x17!\n\r\n\x05\x04R\x02\x07\x03\x12\x04\xd2\x05$%\n\x0c\n\x02\x04S\x12\
    \x06\xd5\x05\0\xde\x05\x01\n\x0b\n\x03\x04S\x01\x12\x04\xd5\x05\x08\x1f\
    \n\x0c\n\x04\x04S\x02\0\x12\x04\xd6\x05\x082\n\r\n\x05\x04S\x02\0\x04\
    \x12\x04\xd6\x05\x08\x10\n\r\n\x05\x04S\x02\0\x05\x12\x04\xd6\x05\x11\
    \x17\n\r\n\x05\x04S\x02\0\x01\x12\x04\xd6\x05\x18\x1f\n\r\n\x05\x04S\x02\
    \0\x03\x12\x04\xd6\x05\"#\n\r\n\x05\x04S\x02\0\x08\x12\x04\xd6\x05$1\n\r\
    \n\x05\x04S\x02\0\x07\x12\x04\xd6\x05/0\n\x0c\n\x04\x04S\x02\x01\x12\x04\
    \xd7\x05\x08#\n\r\n\x05\x04S\x02\x01\x04\x12\x04\xd7\x05\x08\x10\n\r\n\
    \x05\x04S\x02\x01\x05\x12\x04\xd7\x05\x11\x17\n\r\n\x05\x04S\x02\x01\x01\
    \x12\x04\xd7\x05\x18\x1e\n\r\n\x05\x04S\x02\x01\x03\x12\x04\xd7\x05!\"\n\
    \x0c\n\x04\x04S\x02\x02\x12\x04\xd8\x05\x08/\n\r\n\x05\x04S\x02\x02\x04\
    \x12\x04\xd8\x05\x08\x10\n\r\n\x05\x04S\x02\x02\x05\x12\x04\xd8\x05\x11\
    \x17\n\r\n\x05\x04S\x02\x02\x01\x12\x04\xd8\x05\x18*\n\r\n\x05\x04S\x02\
    \x02\x03\x12\x04\xd8\x05-.\n\x0c\n\x04\x04S\x02\x03\x12\x04\xd9\x05\x08&\
    \n\r\n\x05\x04S\x02\x03\x04\x12\x04\xd9\x05\x08\x10\n\r\n\x05\x04S\x02\
    \x03\x05\x12\x04\xd9\x05\x11\x16\n\r\n\x05\x04S\x02\x03\x01\x12\x04\xd9\
    \x05\x17!\n\r\n\x05\x04S\x02\x03\x03\x12\x04\xd9\x05$%\n\x0c\n\x04\x04S\
    \x02\x04\x12\x04\xda\x05\x081\n\r\n\x05\x04S\x02\x04\x04\x12\x04\xda\x05\
    \x08\x10\n\r\n\x05\x04S\x02\x04\x05\x12\x04\xda\x05\x11\x17\n\r\n\x05\
    \x04S\x02\x04\x01\x12\x04\xda\x05\x18,\n\r\n\x05\x04S\x02\x04\x03\x12\
    \x04\xda\x05/0\n\x0c\n\x04\x04S\x02\x05\x12\x04\xdb\x05\x083\n\r\n\x05\
    \x04S\x02\x05\x04\x12\x04\xdb\x05\x08\x10\n\r\n\x05\x04S\x02\x05\x05\x12\
    \x04\xdb\x05\x11\x17\n\r\n\x05\x04S\x02\x05\x01\x12\x04\xdb\x05\x18.\n\r\
    \n\x05\x04S\x02\x05\x03\x12\x04\xdb\x0512\n\x0c\n\x04\x04S\x02\x06\x12\
    \x04\xdc\x05\x08.\n\r\n\x05\x04S\x02\x06\x04\x12\x04\xdc\x05\x08\x10\n\r\
    \n\x05\x04S\x02\x06\x05\x12\x04\xdc\x05\x11\x17\n\r\n\x05\x04S\x02\x06\
    \x01\x12\x04\xdc\x05\x18)\n\r\n\x05\x04S\x02\x06\x03\x12\x04\xdc\x05,-\n\
    \x0c\n\x04\x04S\x02\x07\x12\x04\xdd\x05\x08(\n\r\n\x05\x04S\x02\x07\x04\
    \x12\x04\xdd\x05\x08\x10\n\r\n\x05\x04S\x02\x07\x05\x12\x04\xdd\x05\x11\
    \x17\n\r\n\x05\x04S\x02\x07\x01\x12\x04\xdd\x05\x18#\n\r\n\x05\x04S\x02\
    \x07\x03\x12\x04\xdd\x05&'\n\x0c\n\x02\x04T\x12\x06\xe0\x05\0\xe9\x05\
    \x01\n\x0b\n\x03\x04T\x01\x12\x04\xe0\x05\x08\x1a\n\x0c\n\x04\x04T\x02\0\
    \x12\x04\xe1\x05\x082\n\r\n\x05\x04T\x02\0\x04\x12\x04\xe1\x05\x08\x10\n\
    \r\n\x05\x04T\x02\0\x05\x12\x04\xe1\x05\x11\x17\n\r\n\x05\x04T\x02\0\x01\
    \x12\x04\xe1\x05\x18\x1f\n\r\n\x05\x04T\x02\0\x03\x12\x04\xe1\x05\"#\n\r\
    \n\x05\x04T\x02\0\x08\x12\x04\xe1\x05$1\n\r\n\x05\x04T\x02\0\x07\x12\x04\
    \xe1\x05/0\n\x0c\n\x04\x04T\x02\x01\x12\x04\xe2\x05\x08#\n\r\n\x05\x04T\
    \x02\x01\x04\x12\x04\xe2\x05\x08\x10\n\r\n\x05\x04T\x02\x01\x05\x12\x04\
    \xe2\x05\x11\x17\n\r\n\x05\x04T\x02\x01\x01\x12\x04\xe2\x05\x18\x1e\n\r\
    \n\x05\x04T\x02\x01\x03\x12\x04\xe2\x05!\"\n\x0c\n\x04\x04T\x02\x02\x12\
    \x04\xe3\x05\x08/\n\r\n\x05\x04T\x02\x02\x04\x12\x04\xe3\x05\x08\x10\n\r\
    \n\x05\x04T\x02\x02\x05\x12\x04\xe3\x05\x11\x17\n\r\n\x05\x04T\x02\x02\
    \x01\x12\x04\xe3\x05\x18*\n\r\n\x05\x04T\x02\x02\x03\x12\x04\xe3\x05-.\n\
    \x0c\n\x04\x04T\x02\x03\x12\x04\xe4\x05\x08)\n\r\n\x05\x04T\x02\x03\x04\
    \x12\x04\xe4\x05\x08\x10\n\r\n\x05\x04T\x02\x03\x05\x12\x04\xe4\x05\x11\
    \x17\n\r\n\x05\x04T\x02\x03\x01\x12\x04\xe4\x05\x18$\n\r\n\x05\x04T\x02\
    \x03\x03\x12\x04\xe4\x05'(\n\x0c\n\x04\x04T\x02\x04\x12\x04\xe5\x05\x08&\
    \n\r\n\x05\x04T\x02\x04\x04\x12\x04\xe5\x05\x08\x10\n\r\n\x05\x04T\x02\
    \x04\x05\x12\x04\xe5\x05\x11\x16\n\r\n\x05\x04T\x02\x04\x01\x12\x04\xe5\
    \x05\x17!\n\r\n\x05\x04T\x02\x04\x03\x12\x04\xe5\x05$%\n\x0c\n\x04\x04T\
    \x02\x05\x12\x04\xe6\x05\x081\n\r\n\x05\x04T\x02\x05\x04\x12\x04\xe6\x05\
    \x08\x10\n\r\n\x05\x04T\x02\x05\x05\x12\x04\xe6\x05\x11\x17\n\r\n\x05\
    \x04T\x02\x05\x01\x12\x04\xe6\x05\x18,\n\r\n\x05\x04T\x02\x05\x03\x12\
    \x04\xe6\x05/0\n\x0c\n\x04\x04T\x02\x06\x12\x04\xe7\x05\x083\n\r\n\x05\
    \x04T\x02\x06\x04\x12\x04\xe7\x05\x08\x10\n\r\n\x05\x04T\x02\x06\x05\x12\
    \x04\xe7\x05\x11\x17\n\r\n\x05\x04T\x02\x06\x01\x12\x04\xe7\x05\x18.\n\r\
    \n\x05\x04T\x02\x06\x03\x12\x04\xe7\x0512\n\x0c\n\x04\x04T\x02\x07\x12\
    \x04\xe8\x05\x08.\n\r\n\x05\x04T\x02\x07\x04\x12\x04\xe8\x05\x08\x10\n\r\
    \n\x05\x04T\x02\x07\x05\x12\x04\xe8\x05\x11\x17\n\r\n\x05\x04T\x02\x07\
    \x01\x12\x04\xe8\x05\x18)\n\r\n\x05\x04T\x02\x07\x03\x12\x04\xe8\x05,-\n\
    \x0c\n\x02\x04U\x12\x06\xeb\x05\0\xed\x05\x01\n\x0b\n\x03\x04U\x01\x12\
    \x04\xeb\x05\x08&\n\x0c\n\x04\x04U\x02\0\x12\x04\xec\x05\x08&\n\r\n\x05\
    \x04U\x02\0\x04\x12\x04\xec\x05\x08\x10\n\r\n\x05\x04U\x02\0\x05\x12\x04\
    \xec\x05\x11\x17\n\r\n\x05\x04U\x02\0\x01\x12\x04\xec\x05\x18!\n\r\n\x05\
    \x04U\x02\0\x03\x12\x04\xec\x05$%\n\x0c\n\x02\x04V\x12\x06\xef\x05\0\xf6\
    \x05\x01\n\x0b\n\x03\x04V\x01\x12\x04\xef\x05\x08.\n\x0c\n\x04\x04V\x02\
    \0\x12\x04\xf0\x05\x082\n\r\n\x05\x04V\x02\0\x04\x12\x04\xf0\x05\x08\x10\
    \n\r\n\x05\x04V\x02\0\x05\x12\x04\xf0\x05\x11\x17\n\r\n\x05\x04V\x02\0\
    \x01\x12\x04\xf0\x05\x18\x1f\n\r\n\x05\x04V\x02\0\x03\x12\x04\xf0\x05\"#\
    \n\r\n\x05\x04V\x02\0\x08\x12\x04\xf0\x05$1\n\r\n\x05\x04V\x02\0\x07\x12\
    \x04\xf0\x05/0\n\x0c\n\x04\x04V\x02\x01\x12\x04\xf1\x05\x08\"\n\r\n\x05\
    \x04V\x02\x01\x04\x12\x04\xf1\x05\x08\x10\n\r\n\x05\x04V\x02\x01\x05\x12\
    \x04\xf1\x05\x11\x17\n\r\n\x05\x04V\x02\x01\x01\x12\x04\xf1\x05\x18\x1d\
    \n\r\n\x05\x04V\x02\x01\x03\x12\x04\xf1\x05\x20!\n\x0c\n\x04\x04V\x02\
    \x02\x12\x04\xf2\x05\x08!\n\r\n\x05\x04V\x02\x02\x04\x12\x04\xf2\x05\x08\
    \x10\n\r\n\x05\x04V\x02\x02\x05\x12\x04\xf2\x05\x11\x17\n\r\n\x05\x04V\
    \x02\x02\x01\x12\x04\xf2\x05\x18\x1c\n\r\n\x05\x04V\x02\x02\x03\x12\x04\
    \xf2\x05\x1f\x20\n\x0c\n\x04\x04V\x02\x03\x12\x04\xf3\x05\x08'\n\r\n\x05\
    \x04V\x02\x03\x04\x12\x04\xf3\x05\x08\x10\n\r\n\x05\x04V\x02\x03\x05\x12\
    \x04\xf3\x05\x11\x17\n\r\n\x05\x04V\x02\x03\x01\x12\x04\xf3\x05\x18\"\n\
    \r\n\x05\x04V\x02\x03\x03\x12\x04\xf3\x05%&\n\x0c\n\x04\x04V\x02\x04\x12\
    \x04\xf4\x05\x08+\n\r\n\x05\x04V\x02\x04\x04\x12\x04\xf4\x05\x08\x10\n\r\
    \n\x05\x04V\x02\x04\x05\x12\x04\xf4\x05\x11\x15\n\r\n\x05\x04V\x02\x04\
    \x01\x12\x04\xf4\x05\x16&\n\r\n\x05\x04V\x02\x04\x03\x12\x04\xf4\x05)*\n\
    \x0c\n\x04\x04V\x02\x05\x12\x04\xf5\x05\x08!\n\r\n\x05\x04V\x02\x05\x04\
    \x12\x04\xf5\x05\x08\x10\n\r\n\x05\x04V\x02\x05\x05\x12\x04\xf5\x05\x11\
    \x16\n\r\n\x05\x04V\x02\x05\x01\x12\x04\xf5\x05\x17\x1c\n\r\n\x05\x04V\
    \x02\x05\x03\x12\x04\xf5\x05\x1f\x20\n\x0c\n\x02\x04W\x12\x06\xf8\x05\0\
    \xfb\x05\x01\n\x0b\n\x03\x04W\x01\x12\x04\xf8\x05\x08-\n\x0c\n\x04\x04W\
    \x02\0\x12\x04\xf9\x05\x08&\n\r\n\x05\x04W\x02\0\x04\x12\x04\xf9\x05\x08\
    \x10\n\r\n\x05\x04W\x02\0\x05\x12\x04\xf9\x05\x11\x17\n\r\n\x05\x04W\x02\
    \0\x01\x12\x04\xf9\x05\x18!\n\r\n\x05\x04W\x02\0\x03\x12\x04\xf9\x05$%\n\
    \x0c\n\x04\x04W\x02\x01\x12\x04\xfa\x05\x08\x20\n\r\n\x05\x04W\x02\x01\
    \x04\x12\x04\xfa\x05\x08\x10\n\r\n\x05\x04W\x02\x01\x05\x12\x04\xfa\x05\
    \x11\x16\n\r\n\x05\x04W\x02\x01\x01\x12\x04\xfa\x05\x17\x1b\n\r\n\x05\
    \x04W\x02\x01\x03\x12\x04\xfa\x05\x1e\x1f\n\x0c\n\x02\x04X\x12\x06\xfd\
    \x05\0\x80\x06\x01\n\x0b\n\x03\x04X\x01\x12\x04\xfd\x05\x082\n\x0c\n\x04\
    \x04X\x02\0\x12\x04\xfe\x05\x082\n\r\n\x05\x04X\x02\0\x04\x12\x04\xfe\
    \x05\x08\x10\n\r\n\x05\x04X\x02\0\x05\x12\x04\xfe\x05\x11\x17\n\r\n\x05\
    \x04X\x02\0\x01\x12\x04\xfe\x05\x18\x1f\n\r\n\x05\x04X\x02\0\x03\x12\x04\
    \xfe\x05\"#\n\r\n\x05\x04X\x02\0\x08\x12\x04\xfe\x05$1\n\r\n\x05\x04X\
    \x02\0\x07\x12\x04\xfe\x05/0\n\x0c\n\x04\x04X\x02\x01\x12\x04\xff\x05\
    \x08!\n\r\n\x05\x04X\x02\x01\x04\x12\x04\xff\x05\x08\x10\n\r\n\x05\x04X\
    \x02\x01\x05\x12\x04\xff\x05\x11\x16\n\r\n\x05\x04X\x02\x01\x01\x12\x04\
    \xff\x05\x17\x1c\n\r\n\x05\x04X\x02\x01\x03\x12\x04\xff\x05\x1f\x20\n\
    \x0c\n\x02\x04Y\x12\x06\x82\x06\0\x85\x06\x01\n\x0b\n\x03\x04Y\x01\x12\
    \x04\x82\x06\x08/\n\x0c\n\x04\x04Y\x02\0\x12\x04\x83\x06\x08)\n\r\n\x05\
    \x04Y\x02\0\x04\x12\x04\x83\x06\x08\x10\n\r\n\x05\x04Y\x02\0\x05\x12\x04\
    \x83\x06\x11\x17\n\r\n\x05\x04Y\x02\0\x01\x12\x04\x83\x06\x18$\n\r\n\x05\
    \x04Y\x02\0\x03\x12\x04\x83\x06'(\n\x0c\n\x04\x04Y\x02\x01\x12\x04\x84\
    \x06\x08+\n\r\n\x05\x04Y\x02\x01\x04\x12\x04\x84\x06\x08\x10\n\r\n\x05\
    \x04Y\x02\x01\x05\x12\x04\x84\x06\x11\x17\n\r\n\x05\x04Y\x02\x01\x01\x12\
    \x04\x84\x06\x18&\n\r\n\x05\x04Y\x02\x01\x03\x12\x04\x84\x06)*\n\x0c\n\
    \x02\x04Z\x12\x06\x87\x06\0\x8a\x06\x01\n\x0b\n\x03\x04Z\x01\x12\x04\x87\
    \x06\x087\n\x0c\n\x04\x04Z\x02\0\x12\x04\x88\x06\x08$\n\r\n\x05\x04Z\x02\
    \0\x04\x12\x04\x88\x06\x08\x10\n\r\n\x05\x04Z\x02\0\x05\x12\x04\x88\x06\
    \x11\x17\n\r\n\x05\x04Z\x02\0\x01\x12\x04\x88\x06\x18\x1f\n\r\n\x05\x04Z\
    \x02\0\x03\x12\x04\x88\x06\"#\n\x0c\n\x04\x04Z\x02\x01\x12\x04\x89\x06\
    \x08.\n\r\n\x05\x04Z\x02\x01\x04\x12\x04\x89\x06\x08\x10\n\r\n\x05\x04Z\
    \x02\x01\x05\x12\x04\x89\x06\x11\x15\n\r\n\x05\x04Z\x02\x01\x01\x12\x04\
    \x89\x06\x16)\n\r\n\x05\x04Z\x02\x01\x03\x12\x04\x89\x06,-\n\x0c\n\x02\
    \x04[\x12\x06\x8c\x06\0\x98\x06\x01\n\x0b\n\x03\x04[\x01\x12\x04\x8c\x06\
    \x08#\n\x0e\n\x04\x04[\x03\0\x12\x06\x8d\x06\x08\x94\x06\t\n\r\n\x05\x04\
    [\x03\0\x01\x12\x04\x8d\x06\x10\x1a\n\x0e\n\x06\x04[\x03\0\x02\0\x12\x04\
    \x8e\x06\x10*\n\x0f\n\x07\x04[\x03\0\x02\0\x04\x12\x04\x8e\x06\x10\x18\n\
    \x0f\n\x07\x04[\x03\0\x02\0\x05\x12\x04\x8e\x06\x19\x1f\n\x0f\n\x07\x04[\
    \x03\0\x02\0\x01\x12\x04\x8e\x06\x20%\n\x0f\n\x07\x04[\x03\0\x02\0\x03\
    \x12\x04\x8e\x06()\n\x0e\n\x06\x04[\x03\0\x02\x01\x12\x04\x8f\x06\x10/\n\
    \x0f\n\x07\x04[\x03\0\x02\x01\x04\x12\x04\x8f\x06\x10\x18\n\x0f\n\x07\
    \x04[\x03\0\x02\x01\x05\x12\x04\x8f\x06\x19\x1f\n\x0f\n\x07\x04[\x03\0\
    \x02\x01\x01\x12\x04\x8f\x06\x20*\n\x0f\n\x07\x04[\x03\0\x02\x01\x03\x12\
    \x04\x8f\x06-.\n\x0e\n\x06\x04[\x03\0\x02\x02\x12\x04\x90\x06\x10-\n\x0f\
    \n\x07\x04[\x03\0\x02\x02\x04\x12\x04\x90\x06\x10\x18\n\x0f\n\x07\x04[\
    \x03\0\x02\x02\x05\x12\x04\x90\x06\x19\x1f\n\x0f\n\x07\x04[\x03\0\x02\
    \x02\x01\x12\x04\x90\x06\x20(\n\x0f\n\x07\x04[\x03\0\x02\x02\x03\x12\x04\
    \x90\x06+,\n\x0e\n\x06\x04[\x03\0\x02\x03\x12\x04\x91\x06\x10+\n\x0f\n\
    \x07\x04[\x03\0\x02\x03\x04\x12\x04\x91\x06\x10\x18\n\x0f\n\x07\x04[\x03\
    \0\x02\x03\x05\x12\x04\x91\x06\x19\x1f\n\x0f\n\x07\x04[\x03\0\x02\x03\
    \x01\x12\x04\x91\x06\x20&\n\x0f\n\x07\x04[\x03\0\x02\x03\x03\x12\x04\x91\
    \x06)*\n\x0e\n\x06\x04[\x03\0\x02\x04\x12\x04\x92\x06\x104\n\x0f\n\x07\
    \x04[\x03\0\x02\x04\x04\x12\x04\x92\x06\x10\x18\n\x0f\n\x07\x04[\x03\0\
    \x02\x04\x05\x12\x04\x92\x06\x19\x20\n\x0f\n\x07\x04[\x03\0\x02\x04\x01\
    \x12\x04\x92\x06!/\n\x0f\n\x07\x04[\x03\0\x02\x04\x03\x12\x04\x92\x0623\
    \n\x0e\n\x06\x04[\x03\0\x02\x05\x12\x04\x93\x06\x101\n\x0f\n\x07\x04[\
    \x03\0\x02\x05\x04\x12\x04\x93\x06\x10\x18\n\x0f\n\x07\x04[\x03\0\x02\
    \x05\x05\x12\x04\x93\x06\x19\x1f\n\x0f\n\x07\x04[\x03\0\x02\x05\x01\x12\
    \x04\x93\x06\x20,\n\x0f\n\x07\x04[\x03\0\x02\x05\x03\x12\x04\x93\x06/0\n\
    \x0c\n\x04\x04[\x02\0\x12\x04\x96\x06\x08,\n\r\n\x05\x04[\x02\0\x04\x12\
    \x04\x96\x06\x08\x10\n\r\n\x05\x04[\x02\0\x05\x12\x04\x96\x06\x11\x17\n\
    \r\n\x05\x04[\x02\0\x01\x12\x04\x96\x06\x18'\n\r\n\x05\x04[\x02\0\x03\
    \x12\x04\x96\x06*+\n\x0c\n\x04\x04[\x02\x01\x12\x04\x97\x06\x08J\n\r\n\
    \x05\x04[\x02\x01\x04\x12\x04\x97\x06\x08\x10\n\r\n\x05\x04[\x02\x01\x06\
    \x12\x04\x97\x06\x118\n\r\n\x05\x04[\x02\x01\x01\x12\x04\x97\x069E\n\r\n\
    \x05\x04[\x02\x01\x03\x12\x04\x97\x06HI\n\x0c\n\x02\x04\\\x12\x06\x9a\
    \x06\0\x9b\x06\x01\n\x0b\n\x03\x04\\\x01\x12\x04\x9a\x06\x08*\n\x0c\n\
    \x02\x04]\x12\x06\x9d\x06\0\xa4\x06\x01\n\x0b\n\x03\x04]\x01\x12\x04\x9d\
    \x06\x08#\n\x0e\n\x04\x04]\x03\0\x12\x06\x9e\x06\x08\xa1\x06\t\n\r\n\x05\
    \x04]\x03\0\x01\x12\x04\x9e\x06\x10\x1c\n\x0e\n\x06\x04]\x03\0\x02\0\x12\
    \x04\x9f\x06\x10;\n\x0f\n\x07\x04]\x03\0\x02\0\x04\x12\x04\x9f\x06\x10\
    \x18\n\x0f\n\x07\x04]\x03\0\x02\0\x05\x12\x04\x9f\x06\x19\x1f\n\x0f\n\
    \x07\x04]\x03\0\x02\0\x01\x12\x04\x9f\x06\x206\n\x0f\n\x07\x04]\x03\0\
    \x02\0\x03\x12\x04\x9f\x069:\n\x0e\n\x06\x04]\x03\0\x02\x01\x12\x04\xa0\
    \x06\x10*\n\x0f\n\x07\x04]\x03\0\x02\x01\x04\x12\x04\xa0\x06\x10\x18\n\
    \x0f\n\x07\x04]\x03\0\x02\x01\x05\x12\x04\xa0\x06\x19\x1f\n\x0f\n\x07\
    \x04]\x03\0\x02\x01\x01\x12\x04\xa0\x06\x20%\n\x0f\n\x07\x04]\x03\0\x02\
    \x01\x03\x12\x04\xa0\x06()\n\x0c\n\x04\x04]\x02\0\x12\x04\xa3\x06\x08M\n\
    \r\n\x05\x04]\x02\0\x04\x12\x04\xa3\x06\x08\x10\n\r\n\x05\x04]\x02\0\x06\
    \x12\x04\xa3\x06\x11:\n\r\n\x05\x04]\x02\0\x01\x12\x04\xa3\x06;H\n\r\n\
    \x05\x04]\x02\0\x03\x12\x04\xa3\x06KL\n\x0c\n\x02\x04^\x12\x06\xa6\x06\0\
    \xaa\x06\x01\n\x0b\n\x03\x04^\x01\x12\x04\xa6\x06\x08&\n\x0c\n\x04\x04^\
    \x02\0\x12\x04\xa7\x06\x08/\n\r\n\x05\x04^\x02\0\x04\x12\x04\xa7\x06\x08\
    \x10\n\r\n\x05\x04^\x02\0\x05\x12\x04\xa7\x06\x11\x17\n\r\n\x05\x04^\x02\
    \0\x01\x12\x04\xa7\x06\x18*\n\r\n\x05\x04^\x02\0\x03\x12\x04\xa7\x06-.\n\
    \x0c\n\x04\x04^\x02\x01\x12\x04\xa8\x06\x085\n\r\n\x05\x04^\x02\x01\x04\
    \x12\x04\xa8\x06\x08\x10\n\r\n\x05\x04^\x02\x01\x05\x12\x04\xa8\x06\x11\
    \x17\n\r\n\x05\x04^\x02\x01\x01\x12\x04\xa8\x06\x180\n\r\n\x05\x04^\x02\
    \x01\x03\x12\x04\xa8\x0634\n\x0c\n\x04\x04^\x02\x02\x12\x04\xa9\x06\x08=\
    \n\r\n\x05\x04^\x02\x02\x04\x12\x04\xa9\x06\x08\x10\n\r\n\x05\x04^\x02\
    \x02\x05\x12\x04\xa9\x06\x11\x17\n\r\n\x05\x04^\x02\x02\x01\x12\x04\xa9\
    \x06\x188\n\r\n\x05\x04^\x02\x02\x03\x12\x04\xa9\x06;<\n\x0c\n\x02\x04_\
    \x12\x06\xac\x06\0\xad\x06\x01\n\x0b\n\x03\x04_\x01\x12\x04\xac\x06\x08-\
    \n\x0c\n\x02\x04`\x12\x06\xaf\x06\0\xb2\x06\x01\n\x0b\n\x03\x04`\x01\x12\
    \x04\xaf\x06\x08,\n\x0c\n\x04\x04`\x02\0\x12\x04\xb0\x06\x08-\n\r\n\x05\
    \x04`\x02\0\x04\x12\x04\xb0\x06\x08\x10\n\r\n\x05\x04`\x02\0\x05\x12\x04\
    \xb0\x06\x11\x17\n\r\n\x05\x04`\x02\0\x01\x12\x04\xb0\x06\x18(\n\r\n\x05\
    \x04`\x02\0\x03\x12\x04\xb0\x06+,\n\x0c\n\x04\x04`\x02\x01\x12\x04\xb1\
    \x06\x08:\n\r\n\x05\x04`\x02\x01\x04\x12\x04\xb1\x06\x08\x10\n\r\n\x05\
    \x04`\x02\x01\x05\x12\x04\xb1\x06\x11\x17\n\r\n\x05\x04`\x02\x01\x01\x12\
    \x04\xb1\x06\x185\n\r\n\x05\x04`\x02\x01\x03\x12\x04\xb1\x0689\n\x0c\n\
    \x02\x04a\x12\x06\xb4\x06\0\xb5\x06\x01\n\x0b\n\x03\x04a\x01\x12\x04\xb4\
    \x06\x08,\n\x0c\n\x02\x04b\x12\x06\xb7\x06\0\xb9\x06\x01\n\x0b\n\x03\x04\
    b\x01\x12\x04\xb7\x06\x08-\n\x0c\n\x04\x04b\x02\0\x12\x04\xb8\x06\x08%\n\
    \r\n\x05\x04b\x02\0\x04\x12\x04\xb8\x06\x08\x10\n\r\n\x05\x04b\x02\0\x05\
    \x12\x04\xb8\x06\x11\x18\n\r\n\x05\x04b\x02\0\x01\x12\x04\xb8\x06\x19\
    \x20\n\r\n\x05\x04b\x02\0\x03\x12\x04\xb8\x06#$\n\x0c\n\x02\x04c\x12\x06\
    \xbb\x06\0\xc6\x06\x01\n\x0b\n\x03\x04c\x01\x12\x04\xbb\x06\x085\n\x0e\n\
    \x04\x04c\x03\0\x12\x06\xbc\x06\x08\xc1\x06\t\n\r\n\x05\x04c\x03\0\x01\
    \x12\x04\xbc\x06\x10\x1d\n\x0e\n\x06\x04c\x03\0\x02\0\x12\x04\xbd\x06\
    \x10.\n\x0f\n\x07\x04c\x03\0\x02\0\x04\x12\x04\xbd\x06\x10\x18\n\x0f\n\
    \x07\x04c\x03\0\x02\0\x05\x12\x04\xbd\x06\x19\x1f\n\x0f\n\x07\x04c\x03\0\
    \x02\0\x01\x12\x04\xbd\x06\x20)\n\x0f\n\x07\x04c\x03\0\x02\0\x03\x12\x04\
    \xbd\x06,-\n\x0e\n\x06\x04c\x03\0\x02\x01\x12\x04\xbe\x06\x10.\n\x0f\n\
    \x07\x04c\x03\0\x02\x01\x04\x12\x04\xbe\x06\x10\x18\n\x0f\n\x07\x04c\x03\
    \0\x02\x01\x05\x12\x04\xbe\x06\x19\x1f\n\x0f\n\x07\x04c\x03\0\x02\x01\
    \x01\x12\x04\xbe\x06\x20)\n\x0f\n\x07\x04c\x03\0\x02\x01\x03\x12\x04\xbe\
    \x06,-\n\x0e\n\x06\x04c\x03\0\x02\x02\x12\x04\xbf\x06\x10,\n\x0f\n\x07\
    \x04c\x03\0\x02\x02\x04\x12\x04\xbf\x06\x10\x18\n\x0f\n\x07\x04c\x03\0\
    \x02\x02\x05\x12\x04\xbf\x06\x19\x1f\n\x0f\n\x07\x04c\x03\0\x02\x02\x01\
    \x12\x04\xbf\x06\x20'\n\x0f\n\x07\x04c\x03\0\x02\x02\x03\x12\x04\xbf\x06\
    *+\n\x0e\n\x06\x04c\x03\0\x02\x03\x12\x04\xc0\x06\x10)\n\x0f\n\x07\x04c\
    \x03\0\x02\x03\x04\x12\x04\xc0\x06\x10\x18\n\x0f\n\x07\x04c\x03\0\x02\
    \x03\x05\x12\x04\xc0\x06\x19\x1d\n\x0f\n\x07\x04c\x03\0\x02\x03\x01\x12\
    \x04\xc0\x06\x1e$\n\x0f\n\x07\x04c\x03\0\x02\x03\x03\x12\x04\xc0\x06'(\n\
    \x0c\n\x04\x04c\x02\0\x12\x04\xc3\x06\x08%\n\r\n\x05\x04c\x02\0\x04\x12\
    \x04\xc3\x06\x08\x10\n\r\n\x05\x04c\x02\0\x05\x12\x04\xc3\x06\x11\x18\n\
    \r\n\x05\x04c\x02\0\x01\x12\x04\xc3\x06\x19\x20\n\r\n\x05\x04c\x02\0\x03\
    \x12\x04\xc3\x06#$\n\x0c\n\x04\x04c\x02\x01\x12\x04\xc4\x06\x08$\n\r\n\
    \x05\x04c\x02\x01\x04\x12\x04\xc4\x06\x08\x10\n\r\n\x05\x04c\x02\x01\x05\
    \x12\x04\xc4\x06\x11\x17\n\r\n\x05\x04c\x02\x01\x01\x12\x04\xc4\x06\x18\
    \x1f\n\r\n\x05\x04c\x02\x01\x03\x12\x04\xc4\x06\"#\n\x0c\n\x04\x04c\x02\
    \x02\x12\x04\xc5\x06\x08[\n\r\n\x05\x04c\x02\x02\x04\x12\x04\xc5\x06\x08\
    \x10\n\r\n\x05\x04c\x02\x02\x06\x12\x04\xc5\x06\x11M\n\r\n\x05\x04c\x02\
    \x02\x01\x12\x04\xc5\x06NV\n\r\n\x05\x04c\x02\x02\x03\x12\x04\xc5\x06YZ\
    \n\x0c\n\x02\x04d\x12\x06\xc8\x06\0\xc9\x06\x01\n\x0b\n\x03\x04d\x01\x12\
    \x04\xc8\x06\x08?\n\x0c\n\x02\x04e\x12\x06\xcb\x06\0\xcd\x06\x01\n\x0b\n\
    \x03\x04e\x01\x12\x04\xcb\x06\x08)\n\x0c\n\x04\x04e\x02\0\x12\x04\xcc\
    \x06\x08'\n\r\n\x05\x04e\x02\0\x04\x12\x04\xcc\x06\x08\x10\n\r\n\x05\x04\
    e\x02\0\x05\x12\x04\xcc\x06\x11\x17\n\r\n\x05\x04e\x02\0\x01\x12\x04\xcc\
    \x06\x18\"\n\r\n\x05\x04e\x02\0\x03\x12\x04\xcc\x06%&\n\x0c\n\x02\x04f\
    \x12\x06\xcf\x06\0\xd6\x06\x01\n\x0b\n\x03\x04f\x01\x12\x04\xcf\x06\x081\
    \n\x0e\n\x04\x04f\x03\0\x12\x06\xd0\x06\x08\xd3\x06\t\n\r\n\x05\x04f\x03\
    \0\x01\x12\x04\xd0\x06\x10\x16\n\x0e\n\x06\x04f\x03\0\x02\0\x12\x04\xd1\
    \x06\x10.\n\x0f\n\x07\x04f\x03\0\x02\0\x04\x12\x04\xd1\x06\x10\x18\n\x0f\
    \n\x07\x04f\x03\0\x02\0\x05\x12\x04\xd1\x06\x19\x1f\n\x0f\n\x07\x04f\x03\
    \0\x02\0\x01\x12\x04\xd1\x06\x20)\n\x0f\n\x07\x04f\x03\0\x02\0\x03\x12\
    \x04\xd1\x06,-\n\x0e\n\x06\x04f\x03\0\x02\x01\x12\x04\xd2\x06\x10*\n\x0f\
    \n\x07\x04f\x03\0\x02\x01\x04\x12\x04\xd2\x06\x10\x18\n\x0f\n\x07\x04f\
    \x03\0\x02\x01\x05\x12\x04\xd2\x06\x19\x1f\n\x0f\n\x07\x04f\x03\0\x02\
    \x01\x01\x12\x04\xd2\x06\x20%\n\x0f\n\x07\x04f\x03\0\x02\x01\x03\x12\x04\
    \xd2\x06()\n\x0c\n\x04\x04f\x02\0\x12\x04\xd5\x06\x08O\n\r\n\x05\x04f\
    \x02\0\x04\x12\x04\xd5\x06\x08\x10\n\r\n\x05\x04f\x02\0\x06\x12\x04\xd5\
    \x06\x11B\n\r\n\x05\x04f\x02\0\x01\x12\x04\xd5\x06CJ\n\r\n\x05\x04f\x02\
    \0\x03\x12\x04\xd5\x06MN\n\x0c\n\x02\x04g\x12\x06\xd8\x06\0\xdf\x06\x01\
    \n\x0b\n\x03\x04g\x01\x12\x04\xd8\x06\x08\x1f\n\x0c\n\x04\x04g\x02\0\x12\
    \x04\xd9\x06\x08*\n\r\n\x05\x04g\x02\0\x04\x12\x04\xd9\x06\x08\x10\n\r\n\
    \x05\x04g\x02\0\x05\x12\x04\xd9\x06\x11\x17\n\r\n\x05\x04g\x02\0\x01\x12\
    \x04\xd9\x06\x18%\n\r\n\x05\x04g\x02\0\x03\x12\x04\xd9\x06()\n\x0c\n\x04\
    \x04g\x02\x01\x12\x04\xda\x06\x08-\n\r\n\x05\x04g\x02\x01\x04\x12\x04\
    \xda\x06\x08\x10\n\r\n\x05\x04g\x02\x01\x05\x12\x04\xda\x06\x11\x15\n\r\
    \n\x05\x04g\x02\x01\x01\x12\x04\xda\x06\x16(\n\r\n\x05\x04g\x02\x01\x03\
    \x12\x04\xda\x06+,\n\x0c\n\x04\x04g\x02\x02\x12\x04\xdb\x06\x083\n\r\n\
    \x05\x04g\x02\x02\x04\x12\x04\xdb\x06\x08\x10\n\r\n\x05\x04g\x02\x02\x05\
    \x12\x04\xdb\x06\x11\x15\n\r\n\x05\x04g\x02\x02\x01\x12\x04\xdb\x06\x16.\
    \n\r\n\x05\x04g\x02\x02\x03\x12\x04\xdb\x0612\n\x0c\n\x04\x04g\x02\x03\
    \x12\x04\xdc\x06\x08:\n\r\n\x05\x04g\x02\x03\x04\x12\x04\xdc\x06\x08\x10\
    \n\r\n\x05\x04g\x02\x03\x05\x12\x04\xdc\x06\x11\x15\n\r\n\x05\x04g\x02\
    \x03\x01\x12\x04\xdc\x06\x165\n\r\n\x05\x04g\x02\x03\x03\x12\x04\xdc\x06\
    89\n\x0c\n\x04\x04g\x02\x04\x12\x04\xdd\x06\x08D\n\r\n\x05\x04g\x02\x04\
    \x04\x12\x04\xdd\x06\x08\x10\n\r\n\x05\x04g\x02\x04\x05\x12\x04\xdd\x06\
    \x11\x15\n\r\n\x05\x04g\x02\x04\x01\x12\x04\xdd\x06\x16?\n\r\n\x05\x04g\
    \x02\x04\x03\x12\x04\xdd\x06BC\n\x0c\n\x04\x04g\x02\x05\x12\x04\xde\x06\
    \x082\n\r\n\x05\x04g\x02\x05\x04\x12\x04\xde\x06\x08\x10\n\r\n\x05\x04g\
    \x02\x05\x05\x12\x04\xde\x06\x11\x15\n\r\n\x05\x04g\x02\x05\x01\x12\x04\
    \xde\x06\x16-\n\r\n\x05\x04g\x02\x05\x03\x12\x04\xde\x0601\n\x0c\n\x02\
    \x04h\x12\x06\xe1\x06\0\xe7\x06\x01\n\x0b\n\x03\x04h\x01\x12\x04\xe1\x06\
    \x08\x1e\n\x0e\n\x04\x04h\x03\0\x12\x06\xe2\x06\x08\xe4\x06\t\n\r\n\x05\
    \x04h\x03\0\x01\x12\x04\xe2\x06\x10\x1f\n\x0e\n\x06\x04h\x03\0\x02\0\x12\
    \x04\xe3\x06\x107\n\x0f\n\x07\x04h\x03\0\x02\0\x04\x12\x04\xe3\x06\x10\
    \x18\n\x0f\n\x07\x04h\x03\0\x02\0\x05\x12\x04\xe3\x06\x19\x20\n\x0f\n\
    \x07\x04h\x03\0\x02\0\x01\x12\x04\xe3\x06!2\n\x0f\n\x07\x04h\x03\0\x02\0\
    \x03\x12\x04\xe3\x0656\n\x0c\n\x04\x04h\x02\0\x12\x04\xe6\x06\x08P\n\r\n\
    \x05\x04h\x02\0\x04\x12\x04\xe6\x06\x08\x10\n\r\n\x05\x04h\x02\0\x06\x12\
    \x04\xe6\x06\x118\n\r\n\x05\x04h\x02\0\x01\x12\x04\xe6\x069K\n\r\n\x05\
    \x04h\x02\0\x03\x12\x04\xe6\x06NO\n\x0c\n\x02\x04i\x12\x06\xe9\x06\0\xf4\
    \x06\x01\n\x0b\n\x03\x04i\x01\x12\x04\xe9\x06\x08&\n\x0e\n\x04\x04i\x03\
    \0\x12\x06\xea\x06\x08\xf0\x06\t\n\r\n\x05\x04i\x03\0\x01\x12\x04\xea\
    \x06\x10\x1f\n\x0e\n\x06\x04i\x03\0\x02\0\x12\x04\xeb\x06\x107\n\x0f\n\
    \x07\x04i\x03\0\x02\0\x04\x12\x04\xeb\x06\x10\x18\n\x0f\n\x07\x04i\x03\0\
    \x02\0\x05\x12\x04\xeb\x06\x19\x20\n\x0f\n\x07\x04i\x03\0\x02\0\x01\x12\
    \x04\xeb\x06!2\n\x0f\n\x07\x04i\x03\0\x02\0\x03\x12\x04\xeb\x0656\n\x0e\
    \n\x06\x04i\x03\0\x02\x01\x12\x04\xec\x06\x10-\n\x0f\n\x07\x04i\x03\0\
    \x02\x01\x04\x12\x04\xec\x06\x10\x18\n\x0f\n\x07\x04i\x03\0\x02\x01\x05\
    \x12\x04\xec\x06\x19\x1e\n\x0f\n\x07\x04i\x03\0\x02\x01\x01\x12\x04\xec\
    \x06\x1f(\n\x0f\n\x07\x04i\x03\0\x02\x01\x03\x12\x04\xec\x06+,\n\x0e\n\
    \x06\x04i\x03\0\x02\x02\x12\x04\xed\x06\x101\n\x0f\n\x07\x04i\x03\0\x02\
    \x02\x04\x12\x04\xed\x06\x10\x18\n\x0f\n\x07\x04i\x03\0\x02\x02\x05\x12\
    \x04\xed\x06\x19\x1e\n\x0f\n\x07\x04i\x03\0\x02\x02\x01\x12\x04\xed\x06\
    \x1f,\n\x0f\n\x07\x04i\x03\0\x02\x02\x03\x12\x04\xed\x06/0\n\x0e\n\x06\
    \x04i\x03\0\x02\x03\x12\x04\xee\x06\x10+\n\x0f\n\x07\x04i\x03\0\x02\x03\
    \x04\x12\x04\xee\x06\x10\x18\n\x0f\n\x07\x04i\x03\0\x02\x03\x05\x12\x04\
    \xee\x06\x19\x1e\n\x0f\n\x07\x04i\x03\0\x02\x03\x01\x12\x04\xee\x06\x1f&\
    \n\x0f\n\x07\x04i\x03\0\x02\x03\x03\x12\x04\xee\x06)*\n\x0e\n\x06\x04i\
    \x03\0\x02\x04\x12\x04\xef\x06\x10)\n\x0f\n\x07\x04i\x03\0\x02\x04\x04\
    \x12\x04\xef\x06\x10\x18\n\x0f\n\x07\x04i\x03\0\x02\x04\x05\x12\x04\xef\
    \x06\x19\x1e\n\x0f\n\x07\x04i\x03\0\x02\x04\x01\x12\x04\xef\x06\x1f$\n\
    \x0f\n\x07\x04i\x03\0\x02\x04\x03\x12\x04\xef\x06'(\n\x0c\n\x04\x04i\x02\
    \0\x12\x04\xf2\x06\x081\n\r\n\x05\x04i\x02\0\x04\x12\x04\xf2\x06\x08\x10\
    \n\r\n\x05\x04i\x02\0\x05\x12\x04\xf2\x06\x11\x16\n\r\n\x05\x04i\x02\0\
    \x01\x12\x04\xf2\x06\x17\x1e\n\r\n\x05\x04i\x02\0\x03\x12\x04\xf2\x06!\"\
    \n\r\n\x05\x04i\x02\0\x08\x12\x04\xf2\x06#0\n\r\n\x05\x04i\x02\0\x07\x12\
    \x04\xf2\x06./\n\x0c\n\x04\x04i\x02\x01\x12\x04\xf3\x06\x08Y\n\r\n\x05\
    \x04i\x02\x01\x04\x12\x04\xf3\x06\x08\x10\n\r\n\x05\x04i\x02\x01\x06\x12\
    \x04\xf3\x06\x11@\n\r\n\x05\x04i\x02\x01\x01\x12\x04\xf3\x06AT\n\r\n\x05\
    \x04i\x02\x01\x03\x12\x04\xf3\x06WX\n\x0c\n\x02\x04j\x12\x06\xf6\x06\0\
    \xf9\x06\x01\n\x0b\n\x03\x04j\x01\x12\x04\xf6\x06\x08*\n\x0c\n\x04\x04j\
    \x02\0\x12\x04\xf7\x06\x08/\n\r\n\x05\x04j\x02\0\x04\x12\x04\xf7\x06\x08\
    \x10\n\r\n\x05\x04j\x02\0\x05\x12\x04\xf7\x06\x11\x18\n\r\n\x05\x04j\x02\
    \0\x01\x12\x04\xf7\x06\x19*\n\r\n\x05\x04j\x02\0\x03\x12\x04\xf7\x06-.\n\
    \x0c\n\x04\x04j\x02\x01\x12\x04\xf8\x06\x08\"\n\r\n\x05\x04j\x02\x01\x04\
    \x12\x04\xf8\x06\x08\x10\n\r\n\x05\x04j\x02\x01\x05\x12\x04\xf8\x06\x11\
    \x15\n\r\n\x05\x04j\x02\x01\x01\x12\x04\xf8\x06\x16\x1d\n\r\n\x05\x04j\
    \x02\x01\x03\x12\x04\xf8\x06\x20!\n\x0c\n\x02\x04k\x12\x06\xfb\x06\0\xfd\
    \x06\x01\n\x0b\n\x03\x04k\x01\x12\x04\xfb\x06\x082\n\x0c\n\x04\x04k\x02\
    \0\x12\x04\xfc\x06\x081\n\r\n\x05\x04k\x02\0\x04\x12\x04\xfc\x06\x08\x10\
    \n\r\n\x05\x04k\x02\0\x05\x12\x04\xfc\x06\x11\x16\n\r\n\x05\x04k\x02\0\
    \x01\x12\x04\xfc\x06\x17\x1e\n\r\n\x05\x04k\x02\0\x03\x12\x04\xfc\x06!\"\
    \n\r\n\x05\x04k\x02\0\x08\x12\x04\xfc\x06#0\n\r\n\x05\x04k\x02\0\x07\x12\
    \x04\xfc\x06./\n\x0c\n\x02\x04l\x12\x06\xff\x06\0\x85\x07\x01\n\x0b\n\
    \x03\x04l\x01\x12\x04\xff\x06\x08.\n\x0e\n\x04\x04l\x03\0\x12\x06\x80\
    \x07\x08\x82\x07\t\n\r\n\x05\x04l\x03\0\x01\x12\x04\x80\x07\x10\x1f\n\
    \x0e\n\x06\x04l\x03\0\x02\0\x12\x04\x81\x07\x107\n\x0f\n\x07\x04l\x03\0\
    \x02\0\x04\x12\x04\x81\x07\x10\x18\n\x0f\n\x07\x04l\x03\0\x02\0\x05\x12\
    \x04\x81\x07\x19\x20\n\x0f\n\x07\x04l\x03\0\x02\0\x01\x12\x04\x81\x07!2\
    \n\x0f\n\x07\x04l\x03\0\x02\0\x03\x12\x04\x81\x0756\n\x0c\n\x04\x04l\x02\
    \0\x12\x04\x84\x07\x08`\n\r\n\x05\x04l\x02\0\x04\x12\x04\x84\x07\x08\x10\
    \n\r\n\x05\x04l\x02\0\x06\x12\x04\x84\x07\x11H\n\r\n\x05\x04l\x02\0\x01\
    \x12\x04\x84\x07I[\n\r\n\x05\x04l\x02\0\x03\x12\x04\x84\x07^_\n\x0c\n\
    \x02\x04m\x12\x06\x87\x07\0\x8f\x07\x01\n\x0b\n\x03\x04m\x01\x12\x04\x87\
    \x07\x086\n\x0e\n\x04\x04m\x03\0\x12\x06\x88\x07\x08\x8b\x07\t\n\r\n\x05\
    \x04m\x03\0\x01\x12\x04\x88\x07\x10\"\n\x0e\n\x06\x04m\x03\0\x02\0\x12\
    \x04\x89\x07\x107\n\x0f\n\x07\x04m\x03\0\x02\0\x04\x12\x04\x89\x07\x10\
    \x18\n\x0f\n\x07\x04m\x03\0\x02\0\x05\x12\x04\x89\x07\x19\x20\n\x0f\n\
    \x07\x04m\x03\0\x02\0\x01\x12\x04\x89\x07!2\n\x0f\n\x07\x04m\x03\0\x02\0\
    \x03\x12\x04\x89\x0756\n\x0e\n\x06\x04m\x03\0\x02\x01\x12\x04\x8a\x07\
    \x106\n\x0f\n\x07\x04m\x03\0\x02\x01\x04\x12\x04\x8a\x07\x10\x18\n\x0f\n\
    \x07\x04m\x03\0\x02\x01\x05\x12\x04\x8a\x07\x19\x1e\n\x0f\n\x07\x04m\x03\
    \0\x02\x01\x01\x12\x04\x8a\x07\x1f#\n\x0f\n\x07\x04m\x03\0\x02\x01\x03\
    \x12\x04\x8a\x07&'\n\x0f\n\x07\x04m\x03\0\x02\x01\x08\x12\x04\x8a\x07(5\
    \n\x0f\n\x07\x04m\x03\0\x02\x01\x07\x12\x04\x8a\x0734\n\x0c\n\x04\x04m\
    \x02\0\x12\x04\x8d\x07\x081\n\r\n\x05\x04m\x02\0\x04\x12\x04\x8d\x07\x08\
    \x10\n\r\n\x05\x04m\x02\0\x05\x12\x04\x8d\x07\x11\x16\n\r\n\x05\x04m\x02\
    \0\x01\x12\x04\x8d\x07\x17\x1e\n\r\n\x05\x04m\x02\0\x03\x12\x04\x8d\x07!\
    \"\n\r\n\x05\x04m\x02\0\x08\x12\x04\x8d\x07#0\n\r\n\x05\x04m\x02\0\x07\
    \x12\x04\x8d\x07./\n\x0c\n\x04\x04m\x02\x01\x12\x04\x8e\x07\x08o\n\r\n\
    \x05\x04m\x02\x01\x04\x12\x04\x8e\x07\x08\x10\n\r\n\x05\x04m\x02\x01\x06\
    \x12\x04\x8e\x07\x11S\n\r\n\x05\x04m\x02\x01\x01\x12\x04\x8e\x07Tj\n\r\n\
    \x05\x04m\x02\x01\x03\x12\x04\x8e\x07mn\n\x0c\n\x02\x04n\x12\x06\x91\x07\
    \0\x9b\x07\x01\n\x0b\n\x03\x04n\x01\x12\x04\x91\x07\x08\x20\n\x0e\n\x04\
    \x04n\x03\0\x12\x06\x92\x07\x08\x96\x07\t\n\r\n\x05\x04n\x03\0\x01\x12\
    \x04\x92\x07\x10\x16\n\x0e\n\x06\x04n\x03\0\x02\0\x12\x04\x93\x07\x10(\n\
    \x0f\n\x07\x04n\x03\0\x02\0\x04\x12\x04\x93\x07\x10\x18\n\x0f\n\x07\x04n\
    \x03\0\x02\0\x05\x12\x04\x93\x07\x19\x20\n\x0f\n\x07\x04n\x03\0\x02\0\
    \x01\x12\x04\x93\x07!#\n\x0f\n\x07\x04n\x03\0\x02\0\x03\x12\x04\x93\x07&\
    '\n\x0e\n\x06\x04n\x03\0\x02\x01\x12\x04\x94\x07\x100\n\x0f\n\x07\x04n\
    \x03\0\x02\x01\x04\x12\x04\x94\x07\x10\x18\n\x0f\n\x07\x04n\x03\0\x02\
    \x01\x05\x12\x04\x94\x07\x19\x1f\n\x0f\n\x07\x04n\x03\0\x02\x01\x01\x12\
    \x04\x94\x07\x20+\n\x0f\n\x07\x04n\x03\0\x02\x01\x03\x12\x04\x94\x07./\n\
    \x0e\n\x06\x04n\x03\0\x02\x02\x12\x04\x95\x07\x107\n\x0f\n\x07\x04n\x03\
    \0\x02\x02\x04\x12\x04\x95\x07\x10\x18\n\x0f\n\x07\x04n\x03\0\x02\x02\
    \x05\x12\x04\x95\x07\x19\x1f\n\x0f\n\x07\x04n\x03\0\x02\x02\x01\x12\x04\
    \x95\x07\x202\n\x0f\n\x07\x04n\x03\0\x02\x02\x03\x12\x04\x95\x0756\n\x0c\
    \n\x04\x04n\x02\0\x12\x04\x98\x07\x08#\n\r\n\x05\x04n\x02\0\x04\x12\x04\
    \x98\x07\x08\x10\n\r\n\x05\x04n\x02\0\x05\x12\x04\x98\x07\x11\x18\n\r\n\
    \x05\x04n\x02\0\x01\x12\x04\x98\x07\x19\x1e\n\r\n\x05\x04n\x02\0\x03\x12\
    \x04\x98\x07!\"\n\x0c\n\x04\x04n\x02\x01\x12\x04\x99\x07\x08%\n\r\n\x05\
    \x04n\x02\x01\x04\x12\x04\x99\x07\x08\x10\n\r\n\x05\x04n\x02\x01\x05\x12\
    \x04\x99\x07\x11\x16\n\r\n\x05\x04n\x02\x01\x01\x12\x04\x99\x07\x17\x20\
    \n\r\n\x05\x04n\x02\x01\x03\x12\x04\x99\x07#$\n\x0c\n\x04\x04n\x02\x02\
    \x12\x04\x9a\x07\x08A\n\r\n\x05\x04n\x02\x02\x04\x12\x04\x9a\x07\x08\x10\
    \n\r\n\x05\x04n\x02\x02\x06\x12\x04\x9a\x07\x111\n\r\n\x05\x04n\x02\x02\
    \x01\x12\x04\x9a\x072<\n\r\n\x05\x04n\x02\x02\x03\x12\x04\x9a\x07?@\n\
    \x0c\n\x02\x04o\x12\x06\x9d\x07\0\x9f\x07\x01\n\x0b\n\x03\x04o\x01\x12\
    \x04\x9d\x07\x08\x1e\n\x0c\n\x04\x04o\x02\0\x12\x04\x9e\x07\x08&\n\r\n\
    \x05\x04o\x02\0\x04\x12\x04\x9e\x07\x08\x10\n\r\n\x05\x04o\x02\0\x05\x12\
    \x04\x9e\x07\x11\x18\n\r\n\x05\x04o\x02\0\x01\x12\x04\x9e\x07\x19!\n\r\n\
    \x05\x04o\x02\0\x03\x12\x04\x9e\x07$%\n\x0c\n\x02\x04p\x12\x06\xa1\x07\0\
    \xa4\x07\x01\n\x0b\n\x03\x04p\x01\x12\x04\xa1\x07\x08&\n\x0c\n\x04\x04p\
    \x02\0\x12\x04\xa2\x07\x081\n\r\n\x05\x04p\x02\0\x04\x12\x04\xa2\x07\x08\
    \x10\n\r\n\x05\x04p\x02\0\x05\x12\x04\xa2\x07\x11\x16\n\r\n\x05\x04p\x02\
    \0\x01\x12\x04\xa2\x07\x17\x1e\n\r\n\x05\x04p\x02\0\x03\x12\x04\xa2\x07!\
    \"\n\r\n\x05\x04p\x02\0\x08\x12\x04\xa2\x07#0\n\r\n\x05\x04p\x02\0\x07\
    \x12\x04\xa2\x07./\n\x0c\n\x04\x04p\x02\x01\x12\x04\xa3\x07\x08/\n\r\n\
    \x05\x04p\x02\x01\x04\x12\x04\xa3\x07\x08\x10\n\r\n\x05\x04p\x02\x01\x05\
    \x12\x04\xa3\x07\x11\x16\n\r\n\x05\x04p\x02\x01\x01\x12\x04\xa3\x07\x17\
    \x1c\n\r\n\x05\x04p\x02\x01\x03\x12\x04\xa3\x07\x1f\x20\n\r\n\x05\x04p\
    \x02\x01\x08\x12\x04\xa3\x07!.\n\r\n\x05\x04p\x02\x01\x07\x12\x04\xa3\
    \x07,-\n\x0c\n\x02\x04q\x12\x06\xa6\x07\0\xa8\x07\x01\n\x0b\n\x03\x04q\
    \x01\x12\x04\xa6\x07\x08\x1c\n\x0c\n\x04\x04q\x02\0\x12\x04\xa7\x07\x08&\
    \n\r\n\x05\x04q\x02\0\x04\x12\x04\xa7\x07\x08\x10\n\r\n\x05\x04q\x02\0\
    \x05\x12\x04\xa7\x07\x11\x18\n\r\n\x05\x04q\x02\0\x01\x12\x04\xa7\x07\
    \x19!\n\r\n\x05\x04q\x02\0\x03\x12\x04\xa7\x07$%\n\x0c\n\x02\x04r\x12\
    \x06\xaa\x07\0\xad\x07\x01\n\x0b\n\x03\x04r\x01\x12\x04\xaa\x07\x08$\n\
    \x0c\n\x04\x04r\x02\0\x12\x04\xab\x07\x081\n\r\n\x05\x04r\x02\0\x04\x12\
    \x04\xab\x07\x08\x10\n\r\n\x05\x04r\x02\0\x05\x12\x04\xab\x07\x11\x16\n\
    \r\n\x05\x04r\x02\0\x01\x12\x04\xab\x07\x17\x1e\n\r\n\x05\x04r\x02\0\x03\
    \x12\x04\xab\x07!\"\n\r\n\x05\x04r\x02\0\x08\x12\x04\xab\x07#0\n\r\n\x05\
    \x04r\x02\0\x07\x12\x04\xab\x07./\n\x0c\n\x04\x04r\x02\x01\x12\x04\xac\
    \x07\x089\n\r\n\x05\x04r\x02\x01\x04\x12\x04\xac\x07\x08\x10\n\r\n\x05\
    \x04r\x02\x01\x05\x12\x04\xac\x07\x11\x15\n\r\n\x05\x04r\x02\x01\x01\x12\
    \x04\xac\x07\x16\"\n\r\n\x05\x04r\x02\x01\x03\x12\x04\xac\x07%&\n\r\n\
    \x05\x04r\x02\x01\x08\x12\x04\xac\x07'8\n\r\n\x05\x04r\x02\x01\x07\x12\
    \x04\xac\x0727\n\x0c\n\x02\x04s\x12\x06\xaf\x07\0\xb1\x07\x01\n\x0b\n\
    \x03\x04s\x01\x12\x04\xaf\x07\x08$\n\x0c\n\x04\x04s\x02\0\x12\x04\xb0\
    \x07\x08(\n\r\n\x05\x04s\x02\0\x04\x12\x04\xb0\x07\x08\x10\n\r\n\x05\x04\
    s\x02\0\x05\x12\x04\xb0\x07\x11\x17\n\r\n\x05\x04s\x02\0\x01\x12\x04\xb0\
    \x07\x18#\n\r\n\x05\x04s\x02\0\x03\x12\x04\xb0\x07&'\n\x0c\n\x02\x04t\
    \x12\x06\xb3\x07\0\xb7\x07\x01\n\x0b\n\x03\x04t\x01\x12\x04\xb3\x07\x08,\
    \n\x0c\n\x04\x04t\x02\0\x12\x04\xb4\x07\x081\n\r\n\x05\x04t\x02\0\x04\
    \x12\x04\xb4\x07\x08\x10\n\r\n\x05\x04t\x02\0\x05\x12\x04\xb4\x07\x11\
    \x16\n\r\n\x05\x04t\x02\0\x01\x12\x04\xb4\x07\x17\x1e\n\r\n\x05\x04t\x02\
    \0\x03\x12\x04\xb4\x07!\"\n\r\n\x05\x04t\x02\0\x08\x12\x04\xb4\x07#0\n\r\
    \n\x05\x04t\x02\0\x07\x12\x04\xb4\x07./\n\x0c\n\x04\x04t\x02\x01\x12\x04\
    \xb5\x07\x08)\n\r\n\x05\x04t\x02\x01\x04\x12\x04\xb5\x07\x08\x10\n\r\n\
    \x05\x04t\x02\x01\x05\x12\x04\xb5\x07\x11\x16\n\r\n\x05\x04t\x02\x01\x01\
    \x12\x04\xb5\x07\x17$\n\r\n\x05\x04t\x02\x01\x03\x12\x04\xb5\x07'(\n\x0c\
    \n\x04\x04t\x02\x02\x12\x04\xb6\x07\x08'\n\r\n\x05\x04t\x02\x02\x04\x12\
    \x04\xb6\x07\x08\x10\n\r\n\x05\x04t\x02\x02\x05\x12\x04\xb6\x07\x11\x18\
    \n\r\n\x05\x04t\x02\x02\x01\x12\x04\xb6\x07\x19\"\n\r\n\x05\x04t\x02\x02\
    \x03\x12\x04\xb6\x07%&\n\x0c\n\x02\x04u\x12\x06\xb9\x07\0\xbb\x07\x01\n\
    \x0b\n\x03\x04u\x01\x12\x04\xb9\x07\x08'\n\x0c\n\x04\x04u\x02\0\x12\x04\
    \xba\x07\x08\"\n\r\n\x05\x04u\x02\0\x04\x12\x04\xba\x07\x08\x10\n\r\n\
    \x05\x04u\x02\0\x05\x12\x04\xba\x07\x11\x17\n\r\n\x05\x04u\x02\0\x01\x12\
    \x04\xba\x07\x18\x1d\n\r\n\x05\x04u\x02\0\x03\x12\x04\xba\x07\x20!\n\x0c\
    \n\x02\x04v\x12\x06\xbd\x07\0\xc0\x07\x01\n\x0b\n\x03\x04v\x01\x12\x04\
    \xbd\x07\x08/\n\x0c\n\x04\x04v\x02\0\x12\x04\xbe\x07\x081\n\r\n\x05\x04v\
    \x02\0\x04\x12\x04\xbe\x07\x08\x10\n\r\n\x05\x04v\x02\0\x05\x12\x04\xbe\
    \x07\x11\x16\n\r\n\x05\x04v\x02\0\x01\x12\x04\xbe\x07\x17\x1e\n\r\n\x05\
    \x04v\x02\0\x03\x12\x04\xbe\x07!\"\n\r\n\x05\x04v\x02\0\x08\x12\x04\xbe\
    \x07#0\n\r\n\x05\x04v\x02\0\x07\x12\x04\xbe\x07./\n\x0c\n\x04\x04v\x02\
    \x01\x12\x04\xbf\x07\x08(\n\r\n\x05\x04v\x02\x01\x04\x12\x04\xbf\x07\x08\
    \x10\n\r\n\x05\x04v\x02\x01\x05\x12\x04\xbf\x07\x11\x16\n\r\n\x05\x04v\
    \x02\x01\x01\x12\x04\xbf\x07\x17#\n\r\n\x05\x04v\x02\x01\x03\x12\x04\xbf\
    \x07&'\n\x0c\n\x02\x04w\x12\x06\xc2\x07\0\xc6\x07\x01\n\x0b\n\x03\x04w\
    \x01\x12\x04\xc2\x07\x08+\n\x0c\n\x04\x04w\x02\0\x12\x04\xc3\x07\x08,\n\
    \r\n\x05\x04w\x02\0\x04\x12\x04\xc3\x07\x08\x10\n\r\n\x05\x04w\x02\0\x05\
    \x12\x04\xc3\x07\x11\x18\n\r\n\x05\x04w\x02\0\x01\x12\x04\xc3\x07\x19'\n\
    \r\n\x05\x04w\x02\0\x03\x12\x04\xc3\x07*+\n\x0c\n\x04\x04w\x02\x01\x12\
    \x04\xc4\x07\x08\"\n\r\n\x05\x04w\x02\x01\x04\x12\x04\xc4\x07\x08\x10\n\
    \r\n\x05\x04w\x02\x01\x05\x12\x04\xc4\x07\x11\x17\n\r\n\x05\x04w\x02\x01\
    \x01\x12\x04\xc4\x07\x18\x1d\n\r\n\x05\x04w\x02\x01\x03\x12\x04\xc4\x07\
    \x20!\n\x0c\n\x04\x04w\x02\x02\x12\x04\xc5\x07\x08(\n\r\n\x05\x04w\x02\
    \x02\x04\x12\x04\xc5\x07\x08\x10\n\r\n\x05\x04w\x02\x02\x05\x12\x04\xc5\
    \x07\x11\x17\n\r\n\x05\x04w\x02\x02\x01\x12\x04\xc5\x07\x18#\n\r\n\x05\
    \x04w\x02\x02\x03\x12\x04\xc5\x07&'\n\x0c\n\x02\x04x\x12\x06\xc8\x07\0\
    \xcc\x07\x01\n\x0b\n\x03\x04x\x01\x12\x04\xc8\x07\x08%\n\x0c\n\x04\x04x\
    \x02\0\x12\x04\xc9\x07\x08(\n\r\n\x05\x04x\x02\0\x04\x12\x04\xc9\x07\x08\
    \x10\n\r\n\x05\x04x\x02\0\x05\x12\x04\xc9\x07\x11\x17\n\r\n\x05\x04x\x02\
    \0\x01\x12\x04\xc9\x07\x18#\n\r\n\x05\x04x\x02\0\x03\x12\x04\xc9\x07&'\n\
    \x0c\n\x04\x04x\x02\x01\x12\x04\xca\x07\x08-\n\r\n\x05\x04x\x02\x01\x04\
    \x12\x04\xca\x07\x08\x10\n\r\n\x05\x04x\x02\x01\x05\x12\x04\xca\x07\x11\
    \x16\n\r\n\x05\x04x\x02\x01\x01\x12\x04\xca\x07\x17(\n\r\n\x05\x04x\x02\
    \x01\x03\x12\x04\xca\x07+,\n\x0c\n\x04\x04x\x02\x02\x12\x04\xcb\x07\x08*\
    \n\r\n\x05\x04x\x02\x02\x04\x12\x04\xcb\x07\x08\x10\n\r\n\x05\x04x\x02\
    \x02\x05\x12\x04\xcb\x07\x11\x15\n\r\n\x05\x04x\x02\x02\x01\x12\x04\xcb\
    \x07\x16%\n\r\n\x05\x04x\x02\x02\x03\x12\x04\xcb\x07()\n\x0c\n\x02\x04y\
    \x12\x06\xce\x07\0\xd1\x07\x01\n\x0b\n\x03\x04y\x01\x12\x04\xce\x07\x08-\
    \n\x0c\n\x04\x04y\x02\0\x12\x04\xcf\x07\x08(\n\r\n\x05\x04y\x02\0\x04\
    \x12\x04\xcf\x07\x08\x10\n\r\n\x05\x04y\x02\0\x05\x12\x04\xcf\x07\x11\
    \x17\n\r\n\x05\x04y\x02\0\x01\x12\x04\xcf\x07\x18#\n\r\n\x05\x04y\x02\0\
    \x03\x12\x04\xcf\x07&'\n\x0c\n\x04\x04y\x02\x01\x12\x04\xd0\x07\x086\n\r\
    \n\x05\x04y\x02\x01\x04\x12\x04\xd0\x07\x08\x10\n\r\n\x05\x04y\x02\x01\
    \x05\x12\x04\xd0\x07\x11\x16\n\r\n\x05\x04y\x02\x01\x01\x12\x04\xd0\x07\
    \x171\n\r\n\x05\x04y\x02\x01\x03\x12\x04\xd0\x0745\n\x0c\n\x02\x04z\x12\
    \x06\xd3\x07\0\xd6\x07\x01\n\x0b\n\x03\x04z\x01\x12\x04\xd3\x07\x08\x18\
    \n\x0c\n\x04\x04z\x02\0\x12\x04\xd4\x07\x08#\n\r\n\x05\x04z\x02\0\x04\
    \x12\x04\xd4\x07\x08\x10\n\r\n\x05\x04z\x02\0\x05\x12\x04\xd4\x07\x11\
    \x17\n\r\n\x05\x04z\x02\0\x01\x12\x04\xd4\x07\x18\x1e\n\r\n\x05\x04z\x02\
    \0\x03\x12\x04\xd4\x07!\"\n\x0c\n\x04\x04z\x02\x01\x12\x04\xd5\x07\x08&\
    \n\r\n\x05\x04z\x02\x01\x04\x12\x04\xd5\x07\x08\x10\n\r\n\x05\x04z\x02\
    \x01\x05\x12\x04\xd5\x07\x11\x17\n\r\n\x05\x04z\x02\x01\x01\x12\x04\xd5\
    \x07\x18!\n\r\n\x05\x04z\x02\x01\x03\x12\x04\xd5\x07$%\n\x0c\n\x02\x04{\
    \x12\x06\xd8\x07\0\xda\x07\x01\n\x0b\n\x03\x04{\x01\x12\x04\xd8\x07\x08.\
    \n\x0c\n\x04\x04{\x02\0\x12\x04\xd9\x07\x08'\n\r\n\x05\x04{\x02\0\x04\
    \x12\x04\xd9\x07\x08\x10\n\r\n\x05\x04{\x02\0\x05\x12\x04\xd9\x07\x11\
    \x17\n\r\n\x05\x04{\x02\0\x01\x12\x04\xd9\x07\x18\"\n\r\n\x05\x04{\x02\0\
    \x03\x12\x04\xd9\x07%&\n\x0c\n\x02\x04|\x12\x06\xdc\x07\0\xe0\x07\x01\n\
    \x0b\n\x03\x04|\x01\x12\x04\xdc\x07\x08-\n\x0c\n\x04\x04|\x02\0\x12\x04\
    \xdd\x07\x08/\n\r\n\x05\x04|\x02\0\x04\x12\x04\xdd\x07\x08\x10\n\r\n\x05\
    \x04|\x02\0\x05\x12\x04\xdd\x07\x11\x17\n\r\n\x05\x04|\x02\0\x01\x12\x04\
    \xdd\x07\x18*\n\r\n\x05\x04|\x02\0\x03\x12\x04\xdd\x07-.\n\x0c\n\x04\x04\
    |\x02\x01\x12\x04\xde\x07\x08-\n\r\n\x05\x04|\x02\x01\x04\x12\x04\xde\
    \x07\x08\x10\n\r\n\x05\x04|\x02\x01\x05\x12\x04\xde\x07\x11\x17\n\r\n\
    \x05\x04|\x02\x01\x01\x12\x04\xde\x07\x18(\n\r\n\x05\x04|\x02\x01\x03\
    \x12\x04\xde\x07+,\n\x0c\n\x04\x04|\x02\x02\x12\x04\xdf\x07\x08/\n\r\n\
    \x05\x04|\x02\x02\x04\x12\x04\xdf\x07\x08\x10\n\r\n\x05\x04|\x02\x02\x05\
    \x12\x04\xdf\x07\x11\x17\n\r\n\x05\x04|\x02\x02\x01\x12\x04\xdf\x07\x18*\
    \n\r\n\x05\x04|\x02\x02\x03\x12\x04\xdf\x07-.\n\x0c\n\x02\x04}\x12\x06\
    \xe2\x07\0\xe6\x07\x01\n\x0b\n\x03\x04}\x01\x12\x04\xe2\x07\x08&\n\x0c\n\
    \x04\x04}\x02\0\x12\x04\xe3\x07\x081\n\r\n\x05\x04}\x02\0\x04\x12\x04\
    \xe3\x07\x08\x10\n\r\n\x05\x04}\x02\0\x05\x12\x04\xe3\x07\x11\x16\n\r\n\
    \x05\x04}\x02\0\x01\x12\x04\xe3\x07\x17\x1e\n\r\n\x05\x04}\x02\0\x03\x12\
    \x04\xe3\x07!\"\n\r\n\x05\x04}\x02\0\x08\x12\x04\xe3\x07#0\n\r\n\x05\x04\
    }\x02\0\x07\x12\x04\xe3\x07./\n\x0c\n\x04\x04}\x02\x01\x12\x04\xe4\x07\
    \x08-\n\r\n\x05\x04}\x02\x01\x04\x12\x04\xe4\x07\x08\x10\n\r\n\x05\x04}\
    \x02\x01\x05\x12\x04\xe4\x07\x11\x17\n\r\n\x05\x04}\x02\x01\x01\x12\x04\
    \xe4\x07\x18(\n\r\n\x05\x04}\x02\x01\x03\x12\x04\xe4\x07+,\n\x0c\n\x04\
    \x04}\x02\x02\x12\x04\xe5\x07\x080\n\r\n\x05\x04}\x02\x02\x04\x12\x04\
    \xe5\x07\x08\x10\n\r\n\x05\x04}\x02\x02\x05\x12\x04\xe5\x07\x11\x17\n\r\
    \n\x05\x04}\x02\x02\x01\x12\x04\xe5\x07\x18+\n\r\n\x05\x04}\x02\x02\x03\
    \x12\x04\xe5\x07./\n\x0c\n\x02\x04~\x12\x06\xe8\x07\0\xec\x07\x01\n\x0b\
    \n\x03\x04~\x01\x12\x04\xe8\x07\x082\n\x0c\n\x04\x04~\x02\0\x12\x04\xe9\
    \x07\x081\n\r\n\x05\x04~\x02\0\x04\x12\x04\xe9\x07\x08\x10\n\r\n\x05\x04\
    ~\x02\0\x05\x12\x04\xe9\x07\x11\x16\n\r\n\x05\x04~\x02\0\x01\x12\x04\xe9\
    \x07\x17\x1e\n\r\n\x05\x04~\x02\0\x03\x12\x04\xe9\x07!\"\n\r\n\x05\x04~\
    \x02\0\x08\x12\x04\xe9\x07#0\n\r\n\x05\x04~\x02\0\x07\x12\x04\xe9\x07./\
    \n\x0c\n\x04\x04~\x02\x01\x12\x04\xea\x07\x08-\n\r\n\x05\x04~\x02\x01\
    \x04\x12\x04\xea\x07\x08\x10\n\r\n\x05\x04~\x02\x01\x05\x12\x04\xea\x07\
    \x11\x17\n\r\n\x05\x04~\x02\x01\x01\x12\x04\xea\x07\x18(\n\r\n\x05\x04~\
    \x02\x01\x03\x12\x04\xea\x07+,\n\x0c\n\x04\x04~\x02\x02\x12\x04\xeb\x07\
    \x08/\n\r\n\x05\x04~\x02\x02\x04\x12\x04\xeb\x07\x08\x10\n\r\n\x05\x04~\
    \x02\x02\x05\x12\x04\xeb\x07\x11\x17\n\r\n\x05\x04~\x02\x02\x01\x12\x04\
    \xeb\x07\x18*\n\r\n\x05\x04~\x02\x02\x03\x12\x04\xeb\x07-.\n\x0c\n\x02\
    \x04\x7f\x12\x06\xee\x07\0\xf1\x07\x01\n\x0b\n\x03\x04\x7f\x01\x12\x04\
    \xee\x07\x08*\n\x0c\n\x04\x04\x7f\x02\0\x12\x04\xef\x07\x087\n\r\n\x05\
    \x04\x7f\x02\0\x04\x12\x04\xef\x07\x08\x10\n\r\n\x05\x04\x7f\x02\0\x05\
    \x12\x04\xef\x07\x11\x17\n\r\n\x05\x04\x7f\x02\0\x01\x12\x04\xef\x07\x18\
    2\n\r\n\x05\x04\x7f\x02\0\x03\x12\x04\xef\x0756\n\x0c\n\x04\x04\x7f\x02\
    \x01\x12\x04\xf0\x07\x089\n\r\n\x05\x04\x7f\x02\x01\x04\x12\x04\xf0\x07\
    \x08\x10\n\r\n\x05\x04\x7f\x02\x01\x05\x12\x04\xf0\x07\x11\x17\n\r\n\x05\
    \x04\x7f\x02\x01\x01\x12\x04\xf0\x07\x184\n\r\n\x05\x04\x7f\x02\x01\x03\
    \x12\x04\xf0\x0778\n\r\n\x03\x04\x80\x01\x12\x06\xf3\x07\0\xf6\x07\x01\n\
    \x0c\n\x04\x04\x80\x01\x01\x12\x04\xf3\x07\x08#\n\r\n\x05\x04\x80\x01\
    \x02\0\x12\x04\xf4\x07\x081\n\x0e\n\x06\x04\x80\x01\x02\0\x04\x12\x04\
    \xf4\x07\x08\x10\n\x0e\n\x06\x04\x80\x01\x02\0\x05\x12\x04\xf4\x07\x11\
    \x16\n\x0e\n\x06\x04\x80\x01\x02\0\x01\x12\x04\xf4\x07\x17\x1e\n\x0e\n\
    \x06\x04\x80\x01\x02\0\x03\x12\x04\xf4\x07!\"\n\x0e\n\x06\x04\x80\x01\
    \x02\0\x08\x12\x04\xf4\x07#0\n\x0e\n\x06\x04\x80\x01\x02\0\x07\x12\x04\
    \xf4\x07./\n\r\n\x05\x04\x80\x01\x02\x01\x12\x04\xf5\x07\x087\n\x0e\n\
    \x06\x04\x80\x01\x02\x01\x04\x12\x04\xf5\x07\x08\x10\n\x0e\n\x06\x04\x80\
    \x01\x02\x01\x05\x12\x04\xf5\x07\x11\x17\n\x0e\n\x06\x04\x80\x01\x02\x01\
    \x01\x12\x04\xf5\x07\x182\n\x0e\n\x06\x04\x80\x01\x02\x01\x03\x12\x04\
    \xf5\x0756\n\r\n\x03\x04\x81\x01\x12\x06\xf8\x07\0\x80\x08\x01\n\x0c\n\
    \x04\x04\x81\x01\x01\x12\x04\xf8\x07\x08.\n\x0f\n\x05\x04\x81\x01\x03\0\
    \x12\x06\xf9\x07\x08\xfc\x07\t\n\x0e\n\x06\x04\x81\x01\x03\0\x01\x12\x04\
    \xf9\x07\x10\x1b\n\x0f\n\x07\x04\x81\x01\x03\0\x02\0\x12\x04\xfa\x07\x10\
    5\n\x10\n\x08\x04\x81\x01\x03\0\x02\0\x04\x12\x04\xfa\x07\x10\x18\n\x10\
    \n\x08\x04\x81\x01\x03\0\x02\0\x05\x12\x04\xfa\x07\x19\x1f\n\x10\n\x08\
    \x04\x81\x01\x03\0\x02\0\x01\x12\x04\xfa\x07\x200\n\x10\n\x08\x04\x81\
    \x01\x03\0\x02\0\x03\x12\x04\xfa\x0734\n\x0f\n\x07\x04\x81\x01\x03\0\x02\
    \x01\x12\x04\xfb\x07\x10-\n\x10\n\x08\x04\x81\x01\x03\0\x02\x01\x04\x12\
    \x04\xfb\x07\x10\x18\n\x10\n\x08\x04\x81\x01\x03\0\x02\x01\x05\x12\x04\
    \xfb\x07\x19\x1f\n\x10\n\x08\x04\x81\x01\x03\0\x02\x01\x01\x12\x04\xfb\
    \x07\x20(\n\x10\n\x08\x04\x81\x01\x03\0\x02\x01\x03\x12\x04\xfb\x07+,\n\
    \r\n\x05\x04\x81\x01\x02\0\x12\x04\xfe\x07\x085\n\x0e\n\x06\x04\x81\x01\
    \x02\0\x04\x12\x04\xfe\x07\x08\x10\n\x0e\n\x06\x04\x81\x01\x02\0\x05\x12\
    \x04\xfe\x07\x11\x17\n\x0e\n\x06\x04\x81\x01\x02\0\x01\x12\x04\xfe\x07\
    \x180\n\x0e\n\x06\x04\x81\x01\x02\0\x03\x12\x04\xfe\x0734\n\r\n\x05\x04\
    \x81\x01\x02\x01\x12\x04\xff\x07\x08W\n\x0e\n\x06\x04\x81\x01\x02\x01\
    \x04\x12\x04\xff\x07\x08\x10\n\x0e\n\x06\x04\x81\x01\x02\x01\x06\x12\x04\
    \xff\x07\x11D\n\x0e\n\x06\x04\x81\x01\x02\x01\x01\x12\x04\xff\x07ER\n\
    \x0e\n\x06\x04\x81\x01\x02\x01\x03\x12\x04\xff\x07UV\n\r\n\x03\x04\x82\
    \x01\x12\x06\x82\x08\0\x83\x08\x01\n\x0c\n\x04\x04\x82\x01\x01\x12\x04\
    \x82\x08\x08&\n\r\n\x03\x04\x83\x01\x12\x06\x85\x08\0\x91\x08\x01\n\x0c\
    \n\x04\x04\x83\x01\x01\x12\x04\x85\x08\x08.\n\x0f\n\x05\x04\x83\x01\x03\
    \0\x12\x06\x86\x08\x08\x8d\x08\t\n\x0e\n\x06\x04\x83\x01\x03\0\x01\x12\
    \x04\x86\x08\x10\x20\n\x0f\n\x07\x04\x83\x01\x03\0\x02\0\x12\x04\x87\x08\
    \x106\n\x10\n\x08\x04\x83\x01\x03\0\x02\0\x04\x12\x04\x87\x08\x10\x18\n\
    \x10\n\x08\x04\x83\x01\x03\0\x02\0\x05\x12\x04\x87\x08\x19\x1f\n\x10\n\
    \x08\x04\x83\x01\x03\0\x02\0\x01\x12\x04\x87\x08\x201\n\x10\n\x08\x04\
    \x83\x01\x03\0\x02\0\x03\x12\x04\x87\x0845\n\x0f\n\x07\x04\x83\x01\x03\0\
    \x02\x01\x12\x04\x88\x08\x100\n\x10\n\x08\x04\x83\x01\x03\0\x02\x01\x04\
    \x12\x04\x88\x08\x10\x18\n\x10\n\x08\x04\x83\x01\x03\0\x02\x01\x05\x12\
    \x04\x88\x08\x19\x1f\n\x10\n\x08\x04\x83\x01\x03\0\x02\x01\x01\x12\x04\
    \x88\x08\x20+\n\x10\n\x08\x04\x83\x01\x03\0\x02\x01\x03\x12\x04\x88\x08.\
    /\n\x0f\n\x07\x04\x83\x01\x03\0\x02\x02\x12\x04\x89\x08\x105\n\x10\n\x08\
    \x04\x83\x01\x03\0\x02\x02\x04\x12\x04\x89\x08\x10\x18\n\x10\n\x08\x04\
    \x83\x01\x03\0\x02\x02\x05\x12\x04\x89\x08\x19\x1f\n\x10\n\x08\x04\x83\
    \x01\x03\0\x02\x02\x01\x12\x04\x89\x08\x200\n\x10\n\x08\x04\x83\x01\x03\
    \0\x02\x02\x03\x12\x04\x89\x0834\n\x0f\n\x07\x04\x83\x01\x03\0\x02\x03\
    \x12\x04\x8a\x08\x100\n\x10\n\x08\x04\x83\x01\x03\0\x02\x03\x04\x12\x04\
    \x8a\x08\x10\x18\n\x10\n\x08\x04\x83\x01\x03\0\x02\x03\x05\x12\x04\x8a\
    \x08\x19\x1f\n\x10\n\x08\x04\x83\x01\x03\0\x02\x03\x01\x12\x04\x8a\x08\
    \x20+\n\x10\n\x08\x04\x83\x01\x03\0\x02\x03\x03\x12\x04\x8a\x08./\n\x0f\
    \n\x07\x04\x83\x01\x03\0\x02\x04\x12\x04\x8b\x08\x10-\n\x10\n\x08\x04\
    \x83\x01\x03\0\x02\x04\x04\x12\x04\x8b\x08\x10\x18\n\x10\n\x08\x04\x83\
    \x01\x03\0\x02\x04\x05\x12\x04\x8b\x08\x19\x1d\n\x10\n\x08\x04\x83\x01\
    \x03\0\x02\x04\x01\x12\x04\x8b\x08\x1e(\n\x10\n\x08\x04\x83\x01\x03\0\
    \x02\x04\x03\x12\x04\x8b\x08+,\n\x0f\n\x07\x04\x83\x01\x03\0\x02\x05\x12\
    \x04\x8c\x08\x10/\n\x10\n\x08\x04\x83\x01\x03\0\x02\x05\x04\x12\x04\x8c\
    \x08\x10\x18\n\x10\n\x08\x04\x83\x01\x03\0\x02\x05\x05\x12\x04\x8c\x08\
    \x19\x1f\n\x10\n\x08\x04\x83\x01\x03\0\x02\x05\x01\x12\x04\x8c\x08\x20*\
    \n\x10\n\x08\x04\x83\x01\x03\0\x02\x05\x03\x12\x04\x8c\x08-.\n\r\n\x05\
    \x04\x83\x01\x02\0\x12\x04\x8f\x08\x081\n\x0e\n\x06\x04\x83\x01\x02\0\
    \x04\x12\x04\x8f\x08\x08\x10\n\x0e\n\x06\x04\x83\x01\x02\0\x05\x12\x04\
    \x8f\x08\x11\x16\n\x0e\n\x06\x04\x83\x01\x02\0\x01\x12\x04\x8f\x08\x17\
    \x1e\n\x0e\n\x06\x04\x83\x01\x02\0\x03\x12\x04\x8f\x08!\"\n\x0e\n\x06\
    \x04\x83\x01\x02\0\x08\x12\x04\x8f\x08#0\n\x0e\n\x06\x04\x83\x01\x02\0\
    \x07\x12\x04\x8f\x08./\n\r\n\x05\x04\x83\x01\x02\x01\x12\x04\x90\x08\x08\
    `\n\x0e\n\x06\x04\x83\x01\x02\x01\x04\x12\x04\x90\x08\x08\x10\n\x0e\n\
    \x06\x04\x83\x01\x02\x01\x06\x12\x04\x90\x08\x11I\n\x0e\n\x06\x04\x83\
    \x01\x02\x01\x01\x12\x04\x90\x08J[\n\x0e\n\x06\x04\x83\x01\x02\x01\x03\
    \x12\x04\x90\x08^_\n\r\n\x03\x04\x84\x01\x12\x06\x93\x08\0\x9b\x08\x01\n\
    \x0c\n\x04\x04\x84\x01\x01\x12\x04\x93\x08\x08)\n\x0f\n\x05\x04\x84\x01\
    \x03\0\x12\x06\x94\x08\x08\x97\x08\t\n\x0e\n\x06\x04\x84\x01\x03\0\x01\
    \x12\x04\x94\x08\x10\x1d\n\x0f\n\x07\x04\x84\x01\x03\0\x02\0\x12\x04\x95\
    \x08\x10-\n\x10\n\x08\x04\x84\x01\x03\0\x02\0\x04\x12\x04\x95\x08\x10\
    \x18\n\x10\n\x08\x04\x84\x01\x03\0\x02\0\x05\x12\x04\x95\x08\x19\x1f\n\
    \x10\n\x08\x04\x84\x01\x03\0\x02\0\x01\x12\x04\x95\x08\x20(\n\x10\n\x08\
    \x04\x84\x01\x03\0\x02\0\x03\x12\x04\x95\x08+,\n\x0f\n\x07\x04\x84\x01\
    \x03\0\x02\x01\x12\x04\x96\x08\x10.\n\x10\n\x08\x04\x84\x01\x03\0\x02\
    \x01\x04\x12\x04\x96\x08\x10\x18\n\x10\n\x08\x04\x84\x01\x03\0\x02\x01\
    \x05\x12\x04\x96\x08\x19\x1f\n\x10\n\x08\x04\x84\x01\x03\0\x02\x01\x01\
    \x12\x04\x96\x08\x20)\n\x10\n\x08\x04\x84\x01\x03\0\x02\x01\x03\x12\x04\
    \x96\x08,-\n\r\n\x05\x04\x84\x01\x02\0\x12\x04\x99\x08\x08U\n\x0e\n\x06\
    \x04\x84\x01\x02\0\x04\x12\x04\x99\x08\x08\x10\n\x0e\n\x06\x04\x84\x01\
    \x02\0\x06\x12\x04\x99\x08\x11A\n\x0e\n\x06\x04\x84\x01\x02\0\x01\x12\
    \x04\x99\x08BP\n\x0e\n\x06\x04\x84\x01\x02\0\x03\x12\x04\x99\x08ST\n\r\n\
    \x05\x04\x84\x01\x02\x01\x12\x04\x9a\x08\x082\n\x0e\n\x06\x04\x84\x01\
    \x02\x01\x04\x12\x04\x9a\x08\x08\x10\n\x0e\n\x06\x04\x84\x01\x02\x01\x05\
    \x12\x04\x9a\x08\x11\x17\n\x0e\n\x06\x04\x84\x01\x02\x01\x01\x12\x04\x9a\
    \x08\x18-\n\x0e\n\x06\x04\x84\x01\x02\x01\x03\x12\x04\x9a\x0801\n\r\n\
    \x03\x04\x85\x01\x12\x06\x9d\x08\0\xa5\x08\x01\n\x0c\n\x04\x04\x85\x01\
    \x01\x12\x04\x9d\x08\x08*\n\x0f\n\x05\x04\x85\x01\x03\0\x12\x06\x9e\x08\
    \x08\xa1\x08\t\n\x0e\n\x06\x04\x85\x01\x03\0\x01\x12\x04\x9e\x08\x10\x17\
    \n\x0f\n\x07\x04\x85\x01\x03\0\x02\0\x12\x04\x9f\x08\x10+\n\x10\n\x08\
    \x04\x85\x01\x03\0\x02\0\x04\x12\x04\x9f\x08\x10\x18\n\x10\n\x08\x04\x85\
    \x01\x03\0\x02\0\x05\x12\x04\x9f\x08\x19\x1f\n\x10\n\x08\x04\x85\x01\x03\
    \0\x02\0\x01\x12\x04\x9f\x08\x20&\n\x10\n\x08\x04\x85\x01\x03\0\x02\0\
    \x03\x12\x04\x9f\x08)*\n\x0f\n\x07\x04\x85\x01\x03\0\x02\x01\x12\x04\xa0\
    \x08\x10-\n\x10\n\x08\x04\x85\x01\x03\0\x02\x01\x04\x12\x04\xa0\x08\x10\
    \x18\n\x10\n\x08\x04\x85\x01\x03\0\x02\x01\x05\x12\x04\xa0\x08\x19\x1f\n\
    \x10\n\x08\x04\x85\x01\x03\0\x02\x01\x01\x12\x04\xa0\x08\x20(\n\x10\n\
    \x08\x04\x85\x01\x03\0\x02\x01\x03\x12\x04\xa0\x08+,\n\r\n\x05\x04\x85\
    \x01\x02\0\x12\x04\xa3\x08\x08(\n\x0e\n\x06\x04\x85\x01\x02\0\x04\x12\
    \x04\xa3\x08\x08\x10\n\x0e\n\x06\x04\x85\x01\x02\0\x05\x12\x04\xa3\x08\
    \x11\x16\n\x0e\n\x06\x04\x85\x01\x02\0\x01\x12\x04\xa3\x08\x17#\n\x0e\n\
    \x06\x04\x85\x01\x02\0\x03\x12\x04\xa3\x08&'\n\r\n\x05\x04\x85\x01\x02\
    \x01\x12\x04\xa4\x08\x08K\n\x0e\n\x06\x04\x85\x01\x02\x01\x04\x12\x04\
    \xa4\x08\x08\x10\n\x0e\n\x06\x04\x85\x01\x02\x01\x06\x12\x04\xa4\x08\x11\
    <\n\x0e\n\x06\x04\x85\x01\x02\x01\x01\x12\x04\xa4\x08=F\n\x0e\n\x06\x04\
    \x85\x01\x02\x01\x03\x12\x04\xa4\x08IJ\n\r\n\x03\x04\x86\x01\x12\x06\xa7\
    \x08\0\xb2\x08\x01\n\x0c\n\x04\x04\x86\x01\x01\x12\x04\xa7\x08\x08\x1d\n\
    \r\n\x05\x04\x86\x01\x02\0\x12\x04\xa8\x08\x08)\n\x0e\n\x06\x04\x86\x01\
    \x02\0\x04\x12\x04\xa8\x08\x08\x10\n\x0e\n\x06\x04\x86\x01\x02\0\x05\x12\
    \x04\xa8\x08\x11\x16\n\x0e\n\x06\x04\x86\x01\x02\0\x01\x12\x04\xa8\x08\
    \x17$\n\x0e\n\x06\x04\x86\x01\x02\0\x03\x12\x04\xa8\x08'(\n\r\n\x05\x04\
    \x86\x01\x02\x01\x12\x04\xa9\x08\x08(\n\x0e\n\x06\x04\x86\x01\x02\x01\
    \x04\x12\x04\xa9\x08\x08\x10\n\x0e\n\x06\x04\x86\x01\x02\x01\x05\x12\x04\
    \xa9\x08\x11\x17\n\x0e\n\x06\x04\x86\x01\x02\x01\x01\x12\x04\xa9\x08\x18\
    #\n\x0e\n\x06\x04\x86\x01\x02\x01\x03\x12\x04\xa9\x08&'\n\r\n\x05\x04\
    \x86\x01\x02\x02\x12\x04\xaa\x08\x08'\n\x0e\n\x06\x04\x86\x01\x02\x02\
    \x04\x12\x04\xaa\x08\x08\x10\n\x0e\n\x06\x04\x86\x01\x02\x02\x05\x12\x04\
    \xaa\x08\x11\x17\n\x0e\n\x06\x04\x86\x01\x02\x02\x01\x12\x04\xaa\x08\x18\
    \"\n\x0e\n\x06\x04\x86\x01\x02\x02\x03\x12\x04\xaa\x08%&\n\r\n\x05\x04\
    \x86\x01\x02\x03\x12\x04\xab\x08\x08'\n\x0e\n\x06\x04\x86\x01\x02\x03\
    \x04\x12\x04\xab\x08\x08\x10\n\x0e\n\x06\x04\x86\x01\x02\x03\x05\x12\x04\
    \xab\x08\x11\x16\n\x0e\n\x06\x04\x86\x01\x02\x03\x01\x12\x04\xab\x08\x17\
    \"\n\x0e\n\x06\x04\x86\x01\x02\x03\x03\x12\x04\xab\x08%&\n\r\n\x05\x04\
    \x86\x01\x02\x04\x12\x04\xac\x08\x08(\n\x0e\n\x06\x04\x86\x01\x02\x04\
    \x04\x12\x04\xac\x08\x08\x10\n\x0e\n\x06\x04\x86\x01\x02\x04\x05\x12\x04\
    \xac\x08\x11\x17\n\x0e\n\x06\x04\x86\x01\x02\x04\x01\x12\x04\xac\x08\x18\
    #\n\x0e\n\x06\x04\x86\x01\x02\x04\x03\x12\x04\xac\x08&'\n\r\n\x05\x04\
    \x86\x01\x02\x05\x12\x04\xad\x08\x08+\n\x0e\n\x06\x04\x86\x01\x02\x05\
    \x04\x12\x04\xad\x08\x08\x10\n\x0e\n\x06\x04\x86\x01\x02\x05\x05\x12\x04\
    \xad\x08\x11\x17\n\x0e\n\x06\x04\x86\x01\x02\x05\x01\x12\x04\xad\x08\x18\
    &\n\x0e\n\x06\x04\x86\x01\x02\x05\x03\x12\x04\xad\x08)*\n\r\n\x05\x04\
    \x86\x01\x02\x06\x12\x04\xae\x08\x08\"\n\x0e\n\x06\x04\x86\x01\x02\x06\
    \x04\x12\x04\xae\x08\x08\x10\n\x0e\n\x06\x04\x86\x01\x02\x06\x05\x12\x04\
    \xae\x08\x11\x17\n\x0e\n\x06\x04\x86\x01\x02\x06\x01\x12\x04\xae\x08\x18\
    \x1d\n\x0e\n\x06\x04\x86\x01\x02\x06\x03\x12\x04\xae\x08\x20!\n\r\n\x05\
    \x04\x86\x01\x02\x07\x12\x04\xaf\x08\x08)\n\x0e\n\x06\x04\x86\x01\x02\
    \x07\x04\x12\x04\xaf\x08\x08\x10\n\x0e\n\x06\x04\x86\x01\x02\x07\x05\x12\
    \x04\xaf\x08\x11\x16\n\x0e\n\x06\x04\x86\x01\x02\x07\x01\x12\x04\xaf\x08\
    \x17$\n\x0e\n\x06\x04\x86\x01\x02\x07\x03\x12\x04\xaf\x08'(\n\r\n\x05\
    \x04\x86\x01\x02\x08\x12\x04\xb0\x08\x08$\n\x0e\n\x06\x04\x86\x01\x02\
    \x08\x04\x12\x04\xb0\x08\x08\x10\n\x0e\n\x06\x04\x86\x01\x02\x08\x05\x12\
    \x04\xb0\x08\x11\x15\n\x0e\n\x06\x04\x86\x01\x02\x08\x01\x12\x04\xb0\x08\
    \x16\x1f\n\x0e\n\x06\x04\x86\x01\x02\x08\x03\x12\x04\xb0\x08\"#\n\r\n\
    \x05\x04\x86\x01\x02\t\x12\x04\xb1\x08\x083\n\x0e\n\x06\x04\x86\x01\x02\
    \t\x04\x12\x04\xb1\x08\x08\x10\n\x0e\n\x06\x04\x86\x01\x02\t\x05\x12\x04\
    \xb1\x08\x11\x17\n\x0e\n\x06\x04\x86\x01\x02\t\x01\x12\x04\xb1\x08\x18-\
    \n\x0e\n\x06\x04\x86\x01\x02\t\x03\x12\x04\xb1\x0802\n\r\n\x03\x04\x87\
    \x01\x12\x06\xb4\x08\0\xb8\x08\x01\n\x0c\n\x04\x04\x87\x01\x01\x12\x04\
    \xb4\x08\x08\x1f\n\r\n\x05\x04\x87\x01\x02\0\x12\x04\xb5\x08\x08'\n\x0e\
    \n\x06\x04\x87\x01\x02\0\x04\x12\x04\xb5\x08\x08\x10\n\x0e\n\x06\x04\x87\
    \x01\x02\0\x05\x12\x04\xb5\x08\x11\x17\n\x0e\n\x06\x04\x87\x01\x02\0\x01\
    \x12\x04\xb5\x08\x18\"\n\x0e\n\x06\x04\x87\x01\x02\0\x03\x12\x04\xb5\x08\
    %&\n\r\n\x05\x04\x87\x01\x02\x01\x12\x04\xb6\x08\x08'\n\x0e\n\x06\x04\
    \x87\x01\x02\x01\x04\x12\x04\xb6\x08\x08\x10\n\x0e\n\x06\x04\x87\x01\x02\
    \x01\x05\x12\x04\xb6\x08\x11\x16\n\x0e\n\x06\x04\x87\x01\x02\x01\x01\x12\
    \x04\xb6\x08\x17\"\n\x0e\n\x06\x04\x87\x01\x02\x01\x03\x12\x04\xb6\x08%&\
    \n\r\n\x05\x04\x87\x01\x02\x02\x12\x04\xb7\x08\x08*\n\x0e\n\x06\x04\x87\
    \x01\x02\x02\x04\x12\x04\xb7\x08\x08\x10\n\x0e\n\x06\x04\x87\x01\x02\x02\
    \x05\x12\x04\xb7\x08\x11\x16\n\x0e\n\x06\x04\x87\x01\x02\x02\x01\x12\x04\
    \xb7\x08\x17%\n\x0e\n\x06\x04\x87\x01\x02\x02\x03\x12\x04\xb7\x08()\n\r\
    \n\x03\x04\x88\x01\x12\x06\xba\x08\0\xd0\x08\x01\n\x0c\n\x04\x04\x88\x01\
    \x01\x12\x04\xba\x08\x08%\n\r\n\x05\x04\x88\x01\x02\0\x12\x04\xbb\x08\
    \x08)\n\x0e\n\x06\x04\x88\x01\x02\0\x04\x12\x04\xbb\x08\x08\x10\n\x0e\n\
    \x06\x04\x88\x01\x02\0\x05\x12\x04\xbb\x08\x11\x16\n\x0e\n\x06\x04\x88\
    \x01\x02\0\x01\x12\x04\xbb\x08\x17$\n\x0e\n\x06\x04\x88\x01\x02\0\x03\
    \x12\x04\xbb\x08'(\n\r\n\x05\x04\x88\x01\x02\x01\x12\x04\xbc\x08\x08(\n\
    \x0e\n\x06\x04\x88\x01\x02\x01\x04\x12\x04\xbc\x08\x08\x10\n\x0e\n\x06\
    \x04\x88\x01\x02\x01\x05\x12\x04\xbc\x08\x11\x17\n\x0e\n\x06\x04\x88\x01\
    \x02\x01\x01\x12\x04\xbc\x08\x18#\n\x0e\n\x06\x04\x88\x01\x02\x01\x03\
    \x12\x04\xbc\x08&'\n\r\n\x05\x04\x88\x01\x02\x02\x12\x04\xbd\x08\x08'\n\
    \x0e\n\x06\x04\x88\x01\x02\x02\x04\x12\x04\xbd\x08\x08\x10\n\x0e\n\x06\
    \x04\x88\x01\x02\x02\x05\x12\x04\xbd\x08\x11\x17\n\x0e\n\x06\x04\x88\x01\
    \x02\x02\x01\x12\x04\xbd\x08\x18\"\n\x0e\n\x06\x04\x88\x01\x02\x02\x03\
    \x12\x04\xbd\x08%&\n\r\n\x05\x04\x88\x01\x02\x03\x12\x04\xbe\x08\x08'\n\
    \x0e\n\x06\x04\x88\x01\x02\x03\x04\x12\x04\xbe\x08\x08\x10\n\x0e\n\x06\
    \x04\x88\x01\x02\x03\x05\x12\x04\xbe\x08\x11\x16\n\x0e\n\x06\x04\x88\x01\
    \x02\x03\x01\x12\x04\xbe\x08\x17\"\n\x0e\n\x06\x04\x88\x01\x02\x03\x03\
    \x12\x04\xbe\x08%&\n\r\n\x05\x04\x88\x01\x02\x04\x12\x04\xbf\x08\x08(\n\
    \x0e\n\x06\x04\x88\x01\x02\x04\x04\x12\x04\xbf\x08\x08\x10\n\x0e\n\x06\
    \x04\x88\x01\x02\x04\x05\x12\x04\xbf\x08\x11\x17\n\x0e\n\x06\x04\x88\x01\
    \x02\x04\x01\x12\x04\xbf\x08\x18#\n\x0e\n\x06\x04\x88\x01\x02\x04\x03\
    \x12\x04\xbf\x08&'\n\r\n\x05\x04\x88\x01\x02\x05\x12\x04\xc0\x08\x08*\n\
    \x0e\n\x06\x04\x88\x01\x02\x05\x04\x12\x04\xc0\x08\x08\x10\n\x0e\n\x06\
    \x04\x88\x01\x02\x05\x05\x12\x04\xc0\x08\x11\x16\n\x0e\n\x06\x04\x88\x01\
    \x02\x05\x01\x12\x04\xc0\x08\x17%\n\x0e\n\x06\x04\x88\x01\x02\x05\x03\
    \x12\x04\xc0\x08()\n\r\n\x05\x04\x88\x01\x02\x06\x12\x04\xc1\x08\x08+\n\
    \x0e\n\x06\x04\x88\x01\x02\x06\x04\x12\x04\xc1\x08\x08\x10\n\x0e\n\x06\
    \x04\x88\x01\x02\x06\x05\x12\x04\xc1\x08\x11\x16\n\x0e\n\x06\x04\x88\x01\
    \x02\x06\x01\x12\x04\xc1\x08\x17&\n\x0e\n\x06\x04\x88\x01\x02\x06\x03\
    \x12\x04\xc1\x08)*\n\r\n\x05\x04\x88\x01\x02\x07\x12\x04\xc2\x08\x08'\n\
    \x0e\n\x06\x04\x88\x01\x02\x07\x04\x12\x04\xc2\x08\x08\x10\n\x0e\n\x06\
    \x04\x88\x01\x02\x07\x05\x12\x04\xc2\x08\x11\x16\n\x0e\n\x06\x04\x88\x01\
    \x02\x07\x01\x12\x04\xc2\x08\x17\"\n\x0e\n\x06\x04\x88\x01\x02\x07\x03\
    \x12\x04\xc2\x08%&\n\r\n\x05\x04\x88\x01\x02\x08\x12\x04\xc3\x08\x08*\n\
    \x0e\n\x06\x04\x88\x01\x02\x08\x04\x12\x04\xc3\x08\x08\x10\n\x0e\n\x06\
    \x04\x88\x01\x02\x08\x05\x12\x04\xc3\x08\x11\x18\n\x0e\n\x06\x04\x88\x01\
    \x02\x08\x01\x12\x04\xc3\x08\x19%\n\x0e\n\x06\x04\x88\x01\x02\x08\x03\
    \x12\x04\xc3\x08()\n\r\n\x05\x04\x88\x01\x02\t\x12\x04\xc4\x08\x08-\n\
    \x0e\n\x06\x04\x88\x01\x02\t\x04\x12\x04\xc4\x08\x08\x10\n\x0e\n\x06\x04\
    \x88\x01\x02\t\x05\x12\x04\xc4\x08\x11\x16\n\x0e\n\x06\x04\x88\x01\x02\t\
    \x01\x12\x04\xc4\x08\x17'\n\x0e\n\x06\x04\x88\x01\x02\t\x03\x12\x04\xc4\
    \x08*,\n\r\n\x05\x04\x88\x01\x02\n\x12\x04\xc5\x08\x085\n\x0e\n\x06\x04\
    \x88\x01\x02\n\x04\x12\x04\xc5\x08\x08\x10\n\x0e\n\x06\x04\x88\x01\x02\n\
    \x05\x12\x04\xc5\x08\x11\x16\n\x0e\n\x06\x04\x88\x01\x02\n\x01\x12\x04\
    \xc5\x08\x17/\n\x0e\n\x06\x04\x88\x01\x02\n\x03\x12\x04\xc5\x0824\n\r\n\
    \x05\x04\x88\x01\x02\x0b\x12\x04\xc6\x08\x081\n\x0e\n\x06\x04\x88\x01\
    \x02\x0b\x04\x12\x04\xc6\x08\x08\x10\n\x0e\n\x06\x04\x88\x01\x02\x0b\x05\
    \x12\x04\xc6\x08\x11\x16\n\x0e\n\x06\x04\x88\x01\x02\x0b\x01\x12\x04\xc6\
    \x08\x17+\n\x0e\n\x06\x04\x88\x01\x02\x0b\x03\x12\x04\xc6\x08.0\n\r\n\
    \x05\x04\x88\x01\x02\x0c\x12\x04\xc7\x08\x08)\n\x0e\n\x06\x04\x88\x01\
    \x02\x0c\x04\x12\x04\xc7\x08\x08\x10\n\x0e\n\x06\x04\x88\x01\x02\x0c\x05\
    \x12\x04\xc7\x08\x11\x15\n\x0e\n\x06\x04\x88\x01\x02\x0c\x01\x12\x04\xc7\
    \x08\x16#\n\x0e\n\x06\x04\x88\x01\x02\x0c\x03\x12\x04\xc7\x08&(\n\r\n\
    \x05\x04\x88\x01\x02\r\x12\x04\xc8\x08\x08-\n\x0e\n\x06\x04\x88\x01\x02\
    \r\x04\x12\x04\xc8\x08\x08\x10\n\x0e\n\x06\x04\x88\x01\x02\r\x05\x12\x04\
    \xc8\x08\x11\x17\n\x0e\n\x06\x04\x88\x01\x02\r\x01\x12\x04\xc8\x08\x18'\
    \n\x0e\n\x06\x04\x88\x01\x02\r\x03\x12\x04\xc8\x08*,\n\r\n\x05\x04\x88\
    \x01\x02\x0e\x12\x04\xc9\x08\x08+\n\x0e\n\x06\x04\x88\x01\x02\x0e\x04\
    \x12\x04\xc9\x08\x08\x10\n\x0e\n\x06\x04\x88\x01\x02\x0e\x05\x12\x04\xc9\
    \x08\x11\x17\n\x0e\n\x06\x04\x88\x01\x02\x0e\x01\x12\x04\xc9\x08\x18%\n\
    \x0e\n\x06\x04\x88\x01\x02\x0e\x03\x12\x04\xc9\x08(*\n\r\n\x05\x04\x88\
    \x01\x02\x0f\x12\x04\xca\x08\x08.\n\x0e\n\x06\x04\x88\x01\x02\x0f\x04\
    \x12\x04\xca\x08\x08\x10\n\x0e\n\x06\x04\x88\x01\x02\x0f\x05\x12\x04\xca\
    \x08\x11\x17\n\x0e\n\x06\x04\x88\x01\x02\x0f\x01\x12\x04\xca\x08\x18(\n\
    \x0e\n\x06\x04\x88\x01\x02\x0f\x03\x12\x04\xca\x08+-\n\r\n\x05\x04\x88\
    \x01\x02\x10\x12\x04\xcb\x08\x082\n\x0e\n\x06\x04\x88\x01\x02\x10\x04\
    \x12\x04\xcb\x08\x08\x10\n\x0e\n\x06\x04\x88\x01\x02\x10\x05\x12\x04\xcb\
    \x08\x11\x17\n\x0e\n\x06\x04\x88\x01\x02\x10\x01\x12\x04\xcb\x08\x18,\n\
    \x0e\n\x06\x04\x88\x01\x02\x10\x03\x12\x04\xcb\x08/1\n\r\n\x05\x04\x88\
    \x01\x02\x11\x12\x04\xcc\x08\x084\n\x0e\n\x06\x04\x88\x01\x02\x11\x04\
    \x12\x04\xcc\x08\x08\x10\n\x0e\n\x06\x04\x88\x01\x02\x11\x05\x12\x04\xcc\
    \x08\x11\x16\n\x0e\n\x06\x04\x88\x01\x02\x11\x01\x12\x04\xcc\x08\x17.\n\
    \x0e\n\x06\x04\x88\x01\x02\x11\x03\x12\x04\xcc\x0813\n\r\n\x05\x04\x88\
    \x01\x02\x12\x12\x04\xcd\x08\x08.\n\x0e\n\x06\x04\x88\x01\x02\x12\x04\
    \x12\x04\xcd\x08\x08\x10\n\x0e\n\x06\x04\x88\x01\x02\x12\x05\x12\x04\xcd\
    \x08\x11\x17\n\x0e\n\x06\x04\x88\x01\x02\x12\x01\x12\x04\xcd\x08\x18(\n\
    \x0e\n\x06\x04\x88\x01\x02\x12\x03\x12\x04\xcd\x08+-\n\r\n\x05\x04\x88\
    \x01\x02\x13\x12\x04\xce\x08\x082\n\x0e\n\x06\x04\x88\x01\x02\x13\x04\
    \x12\x04\xce\x08\x08\x10\n\x0e\n\x06\x04\x88\x01\x02\x13\x05\x12\x04\xce\
    \x08\x11\x17\n\x0e\n\x06\x04\x88\x01\x02\x13\x01\x12\x04\xce\x08\x18,\n\
    \x0e\n\x06\x04\x88\x01\x02\x13\x03\x12\x04\xce\x08/1\n\r\n\x05\x04\x88\
    \x01\x02\x14\x12\x04\xcf\x08\x085\n\x0e\n\x06\x04\x88\x01\x02\x14\x04\
    \x12\x04\xcf\x08\x08\x10\n\x0e\n\x06\x04\x88\x01\x02\x14\x05\x12\x04\xcf\
    \x08\x11\x17\n\x0e\n\x06\x04\x88\x01\x02\x14\x01\x12\x04\xcf\x08\x18/\n\
    \x0e\n\x06\x04\x88\x01\x02\x14\x03\x12\x04\xcf\x0824\n\r\n\x03\x04\x89\
    \x01\x12\x06\xd2\x08\0\xd3\x08\x01\n\x0c\n\x04\x04\x89\x01\x01\x12\x04\
    \xd2\x08\x08\x1d\n\r\n\x03\x04\x8a\x01\x12\x06\xd5\x08\0\xd8\x08\x01\n\
    \x0c\n\x04\x04\x8a\x01\x01\x12\x04\xd5\x08\x08%\n\r\n\x05\x04\x8a\x01\
    \x02\0\x12\x04\xd6\x08\x081\n\x0e\n\x06\x04\x8a\x01\x02\0\x04\x12\x04\
    \xd6\x08\x08\x10\n\x0e\n\x06\x04\x8a\x01\x02\0\x05\x12\x04\xd6\x08\x11\
    \x16\n\x0e\n\x06\x04\x8a\x01\x02\0\x01\x12\x04\xd6\x08\x17\x1e\n\x0e\n\
    \x06\x04\x8a\x01\x02\0\x03\x12\x04\xd6\x08!\"\n\x0e\n\x06\x04\x8a\x01\
    \x02\0\x08\x12\x04\xd6\x08#0\n\x0e\n\x06\x04\x8a\x01\x02\0\x07\x12\x04\
    \xd6\x08./\n\r\n\x05\x04\x8a\x01\x02\x01\x12\x04\xd7\x08\x08*\n\x0e\n\
    \x06\x04\x8a\x01\x02\x01\x04\x12\x04\xd7\x08\x08\x10\n\x0e\n\x06\x04\x8a\
    \x01\x02\x01\x05\x12\x04\xd7\x08\x11\x16\n\x0e\n\x06\x04\x8a\x01\x02\x01\
    \x01\x12\x04\xd7\x08\x17%\n\x0e\n\x06\x04\x8a\x01\x02\x01\x03\x12\x04\
    \xd7\x08()\n\r\n\x03\x04\x8b\x01\x12\x06\xda\x08\0\xdb\x08\x01\n\x0c\n\
    \x04\x04\x8b\x01\x01\x12\x04\xda\x08\x08\x18\n\r\n\x03\x04\x8c\x01\x12\
    \x06\xdd\x08\0\xdf\x08\x01\n\x0c\n\x04\x04\x8c\x01\x01\x12\x04\xdd\x08\
    \x08\x20\n\r\n\x05\x04\x8c\x01\x02\0\x12\x04\xde\x08\x081\n\x0e\n\x06\
    \x04\x8c\x01\x02\0\x04\x12\x04\xde\x08\x08\x10\n\x0e\n\x06\x04\x8c\x01\
    \x02\0\x05\x12\x04\xde\x08\x11\x16\n\x0e\n\x06\x04\x8c\x01\x02\0\x01\x12\
    \x04\xde\x08\x17\x1e\n\x0e\n\x06\x04\x8c\x01\x02\0\x03\x12\x04\xde\x08!\
    \"\n\x0e\n\x06\x04\x8c\x01\x02\0\x08\x12\x04\xde\x08#0\n\x0e\n\x06\x04\
    \x8c\x01\x02\0\x07\x12\x04\xde\x08./\n\r\n\x03\x04\x8d\x01\x12\x06\xe1\
    \x08\0\xe4\x08\x01\n\x0c\n\x04\x04\x8d\x01\x01\x12\x04\xe1\x08\x08%\n\r\
    \n\x05\x04\x8d\x01\x02\0\x12\x04\xe2\x08\x08*\n\x0e\n\x06\x04\x8d\x01\
    \x02\0\x04\x12\x04\xe2\x08\x08\x10\n\x0e\n\x06\x04\x8d\x01\x02\0\x05\x12\
    \x04\xe2\x08\x11\x15\n\x0e\n\x06\x04\x8d\x01\x02\0\x01\x12\x04\xe2\x08\
    \x16%\n\x0e\n\x06\x04\x8d\x01\x02\0\x03\x12\x04\xe2\x08()\n\r\n\x05\x04\
    \x8d\x01\x02\x01\x12\x04\xe3\x08\x08(\n\x0e\n\x06\x04\x8d\x01\x02\x01\
    \x04\x12\x04\xe3\x08\x08\x10\n\x0e\n\x06\x04\x8d\x01\x02\x01\x05\x12\x04\
    \xe3\x08\x11\x17\n\x0e\n\x06\x04\x8d\x01\x02\x01\x01\x12\x04\xe3\x08\x18\
    #\n\x0e\n\x06\x04\x8d\x01\x02\x01\x03\x12\x04\xe3\x08&'\n\r\n\x03\x04\
    \x8e\x01\x12\x06\xe6\x08\0\xe8\x08\x01\n\x0c\n\x04\x04\x8e\x01\x01\x12\
    \x04\xe6\x08\x08$\n\r\n\x05\x04\x8e\x01\x02\0\x12\x04\xe7\x08\x08)\n\x0e\
    \n\x06\x04\x8e\x01\x02\0\x04\x12\x04\xe7\x08\x08\x10\n\x0e\n\x06\x04\x8e\
    \x01\x02\0\x05\x12\x04\xe7\x08\x11\x15\n\x0e\n\x06\x04\x8e\x01\x02\0\x01\
    \x12\x04\xe7\x08\x16$\n\x0e\n\x06\x04\x8e\x01\x02\0\x03\x12\x04\xe7\x08'\
    (\n\r\n\x03\x04\x8f\x01\x12\x06\xea\x08\0\xef\x08\x01\n\x0c\n\x04\x04\
    \x8f\x01\x01\x12\x04\xea\x08\x08'\n\r\n\x05\x04\x8f\x01\x02\0\x12\x04\
    \xeb\x08\x08,\n\x0e\n\x06\x04\x8f\x01\x02\0\x04\x12\x04\xeb\x08\x08\x10\
    \n\x0e\n\x06\x04\x8f\x01\x02\0\x05\x12\x04\xeb\x08\x11\x18\n\x0e\n\x06\
    \x04\x8f\x01\x02\0\x01\x12\x04\xeb\x08\x19'\n\x0e\n\x06\x04\x8f\x01\x02\
    \0\x03\x12\x04\xeb\x08*+\n\r\n\x05\x04\x8f\x01\x02\x01\x12\x04\xec\x08\
    \x08.\n\x0e\n\x06\x04\x8f\x01\x02\x01\x04\x12\x04\xec\x08\x08\x10\n\x0e\
    \n\x06\x04\x8f\x01\x02\x01\x05\x12\x04\xec\x08\x11\x18\n\x0e\n\x06\x04\
    \x8f\x01\x02\x01\x01\x12\x04\xec\x08\x19)\n\x0e\n\x06\x04\x8f\x01\x02\
    \x01\x03\x12\x04\xec\x08,-\n\r\n\x05\x04\x8f\x01\x02\x02\x12\x04\xed\x08\
    \x08%\n\x0e\n\x06\x04\x8f\x01\x02\x02\x04\x12\x04\xed\x08\x08\x10\n\x0e\
    \n\x06\x04\x8f\x01\x02\x02\x05\x12\x04\xed\x08\x11\x16\n\x0e\n\x06\x04\
    \x8f\x01\x02\x02\x01\x12\x04\xed\x08\x17\x20\n\x0e\n\x06\x04\x8f\x01\x02\
    \x02\x03\x12\x04\xed\x08#$\n\r\n\x05\x04\x8f\x01\x02\x03\x12\x04\xee\x08\
    \x08!\n\x0e\n\x06\x04\x8f\x01\x02\x03\x04\x12\x04\xee\x08\x08\x10\n\x0e\
    \n\x06\x04\x8f\x01\x02\x03\x05\x12\x04\xee\x08\x11\x15\n\x0e\n\x06\x04\
    \x8f\x01\x02\x03\x01\x12\x04\xee\x08\x16\x1c\n\x0e\n\x06\x04\x8f\x01\x02\
    \x03\x03\x12\x04\xee\x08\x1f\x20\n\r\n\x03\x04\x90\x01\x12\x06\xf1\x08\0\
    \xf6\x08\x01\n\x0c\n\x04\x04\x90\x01\x01\x12\x04\xf1\x08\x08/\n\r\n\x05\
    \x04\x90\x01\x02\0\x12\x04\xf2\x08\x08,\n\x0e\n\x06\x04\x90\x01\x02\0\
    \x04\x12\x04\xf2\x08\x08\x10\n\x0e\n\x06\x04\x90\x01\x02\0\x05\x12\x04\
    \xf2\x08\x11\x18\n\x0e\n\x06\x04\x90\x01\x02\0\x01\x12\x04\xf2\x08\x19'\
    \n\x0e\n\x06\x04\x90\x01\x02\0\x03\x12\x04\xf2\x08*+\n\r\n\x05\x04\x90\
    \x01\x02\x01\x12\x04\xf3\x08\x08.\n\x0e\n\x06\x04\x90\x01\x02\x01\x04\
    \x12\x04\xf3\x08\x08\x10\n\x0e\n\x06\x04\x90\x01\x02\x01\x05\x12\x04\xf3\
    \x08\x11\x18\n\x0e\n\x06\x04\x90\x01\x02\x01\x01\x12\x04\xf3\x08\x19)\n\
    \x0e\n\x06\x04\x90\x01\x02\x01\x03\x12\x04\xf3\x08,-\n\r\n\x05\x04\x90\
    \x01\x02\x02\x12\x04\xf4\x08\x081\n\x0e\n\x06\x04\x90\x01\x02\x02\x04\
    \x12\x04\xf4\x08\x08\x10\n\x0e\n\x06\x04\x90\x01\x02\x02\x05\x12\x04\xf4\
    \x08\x11\x16\n\x0e\n\x06\x04\x90\x01\x02\x02\x01\x12\x04\xf4\x08\x17\x1e\
    \n\x0e\n\x06\x04\x90\x01\x02\x02\x03\x12\x04\xf4\x08!\"\n\x0e\n\x06\x04\
    \x90\x01\x02\x02\x08\x12\x04\xf4\x08#0\n\x0e\n\x06\x04\x90\x01\x02\x02\
    \x07\x12\x04\xf4\x08./\n\r\n\x05\x04\x90\x01\x02\x03\x12\x04\xf5\x08\x08\
    %\n\x0e\n\x06\x04\x90\x01\x02\x03\x04\x12\x04\xf5\x08\x08\x10\n\x0e\n\
    \x06\x04\x90\x01\x02\x03\x05\x12\x04\xf5\x08\x11\x16\n\x0e\n\x06\x04\x90\
    \x01\x02\x03\x01\x12\x04\xf5\x08\x17\x20\n\x0e\n\x06\x04\x90\x01\x02\x03\
    \x03\x12\x04\xf5\x08#$\n\r\n\x03\x04\x91\x01\x12\x06\xf8\x08\0\xfb\x08\
    \x01\n\x0c\n\x04\x04\x91\x01\x01\x12\x04\xf8\x08\x08$\n\r\n\x05\x04\x91\
    \x01\x02\0\x12\x04\xf9\x08\x08\"\n\x0e\n\x06\x04\x91\x01\x02\0\x04\x12\
    \x04\xf9\x08\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\0\x05\x12\x04\xf9\x08\
    \x11\x17\n\x0e\n\x06\x04\x91\x01\x02\0\x01\x12\x04\xf9\x08\x18\x1d\n\x0e\
    \n\x06\x04\x91\x01\x02\0\x03\x12\x04\xf9\x08\x20!\n\r\n\x05\x04\x91\x01\
    \x02\x01\x12\x04\xfa\x08\x08(\n\x0e\n\x06\x04\x91\x01\x02\x01\x04\x12\
    \x04\xfa\x08\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x01\x05\x12\x04\xfa\x08\
    \x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x01\x01\x12\x04\xfa\x08\x18#\n\x0e\
    \n\x06\x04\x91\x01\x02\x01\x03\x12\x04\xfa\x08&'\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::steammessages_base::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(177);
            messages.push(CMsgClientUCMAddScreenshot::generated_message_descriptor_data());
            messages.push(CMsgClientUCMAddScreenshotResponse::generated_message_descriptor_data());
            messages.push(CMsgClientUCMDeleteScreenshot::generated_message_descriptor_data());
            messages.push(CMsgClientUCMDeleteScreenshotResponse::generated_message_descriptor_data());
            messages.push(CMsgClientUCMPublishFile::generated_message_descriptor_data());
            messages.push(CMsgClientUCMPublishFileResponse::generated_message_descriptor_data());
            messages.push(CMsgClientUCMUpdatePublishedFile::generated_message_descriptor_data());
            messages.push(CMsgClientUCMUpdatePublishedFileResponse::generated_message_descriptor_data());
            messages.push(CMsgClientUCMDeletePublishedFile::generated_message_descriptor_data());
            messages.push(CMsgClientUCMDeletePublishedFileResponse::generated_message_descriptor_data());
            messages.push(CMsgClientUCMEnumerateUserPublishedFiles::generated_message_descriptor_data());
            messages.push(CMsgClientUCMEnumerateUserPublishedFilesResponse::generated_message_descriptor_data());
            messages.push(CMsgClientUCMEnumerateUserSubscribedFiles::generated_message_descriptor_data());
            messages.push(CMsgClientUCMEnumerateUserSubscribedFilesResponse::generated_message_descriptor_data());
            messages.push(CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates::generated_message_descriptor_data());
            messages.push(CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse::generated_message_descriptor_data());
            messages.push(CMsgClientUCMPublishedFileUpdated::generated_message_descriptor_data());
            messages.push(CMsgClientWorkshopItemChangesRequest::generated_message_descriptor_data());
            messages.push(CMsgClientWorkshopItemChangesResponse::generated_message_descriptor_data());
            messages.push(CMsgClientWorkshopItemInfoRequest::generated_message_descriptor_data());
            messages.push(CMsgClientWorkshopItemInfoResponse::generated_message_descriptor_data());
            messages.push(CMsgClientUCMGetPublishedFilesForUser::generated_message_descriptor_data());
            messages.push(CMsgClientUCMGetPublishedFilesForUserResponse::generated_message_descriptor_data());
            messages.push(CMsgClientUCMSetUserPublishedFileAction::generated_message_descriptor_data());
            messages.push(CMsgClientUCMSetUserPublishedFileActionResponse::generated_message_descriptor_data());
            messages.push(CMsgClientUCMEnumeratePublishedFilesByUserAction::generated_message_descriptor_data());
            messages.push(CMsgClientUCMEnumeratePublishedFilesByUserActionResponse::generated_message_descriptor_data());
            messages.push(CMsgClientScreenshotsChanged::generated_message_descriptor_data());
            messages.push(CMsgClientUpdateUserGameInfo::generated_message_descriptor_data());
            messages.push(CMsgClientRichPresenceUpload::generated_message_descriptor_data());
            messages.push(CMsgClientRichPresenceRequest::generated_message_descriptor_data());
            messages.push(CMsgClientRichPresenceInfo::generated_message_descriptor_data());
            messages.push(CMsgClientCheckFileSignature::generated_message_descriptor_data());
            messages.push(CMsgClientCheckFileSignatureResponse::generated_message_descriptor_data());
            messages.push(CMsgClientReadMachineAuth::generated_message_descriptor_data());
            messages.push(CMsgClientReadMachineAuthResponse::generated_message_descriptor_data());
            messages.push(CMsgClientUpdateMachineAuth::generated_message_descriptor_data());
            messages.push(CMsgClientUpdateMachineAuthResponse::generated_message_descriptor_data());
            messages.push(CMsgClientRequestMachineAuth::generated_message_descriptor_data());
            messages.push(CMsgClientRequestMachineAuthResponse::generated_message_descriptor_data());
            messages.push(CMsgClientRegisterKey::generated_message_descriptor_data());
            messages.push(CMsgClientPurchaseResponse::generated_message_descriptor_data());
            messages.push(CMsgClientActivateOEMLicense::generated_message_descriptor_data());
            messages.push(CMsgClientRegisterOEMMachine::generated_message_descriptor_data());
            messages.push(CMsgClientRegisterOEMMachineResponse::generated_message_descriptor_data());
            messages.push(CMsgClientPurchaseWithMachineID::generated_message_descriptor_data());
            messages.push(CMsgTrading_InitiateTradeRequest::generated_message_descriptor_data());
            messages.push(CMsgTrading_InitiateTradeResponse::generated_message_descriptor_data());
            messages.push(CMsgTrading_CancelTradeRequest::generated_message_descriptor_data());
            messages.push(CMsgTrading_StartSession::generated_message_descriptor_data());
            messages.push(CMsgClientGetCDNAuthToken::generated_message_descriptor_data());
            messages.push(CMsgClientGetDepotDecryptionKey::generated_message_descriptor_data());
            messages.push(CMsgClientGetDepotDecryptionKeyResponse::generated_message_descriptor_data());
            messages.push(CMsgClientCheckAppBetaPassword::generated_message_descriptor_data());
            messages.push(CMsgClientCheckAppBetaPasswordResponse::generated_message_descriptor_data());
            messages.push(CMsgClientUpdateAppJobReport::generated_message_descriptor_data());
            messages.push(CMsgClientDPContentStatsReport::generated_message_descriptor_data());
            messages.push(CMsgClientGetCDNAuthTokenResponse::generated_message_descriptor_data());
            messages.push(CMsgDownloadRateStatistics::generated_message_descriptor_data());
            messages.push(CMsgClientRequestAccountData::generated_message_descriptor_data());
            messages.push(CMsgClientRequestAccountDataResponse::generated_message_descriptor_data());
            messages.push(CMsgClientUGSGetGlobalStats::generated_message_descriptor_data());
            messages.push(CMsgClientUGSGetGlobalStatsResponse::generated_message_descriptor_data());
            messages.push(CMsgGameServerData::generated_message_descriptor_data());
            messages.push(CMsgGameServerRemove::generated_message_descriptor_data());
            messages.push(CMsgClientGMSServerQuery::generated_message_descriptor_data());
            messages.push(CMsgGMSClientServerQueryResponse::generated_message_descriptor_data());
            messages.push(CMsgGameServerOutOfDate::generated_message_descriptor_data());
            messages.push(CMsgClientRedeemGuestPass::generated_message_descriptor_data());
            messages.push(CMsgClientRedeemGuestPassResponse::generated_message_descriptor_data());
            messages.push(CMsgClientGetClanActivityCounts::generated_message_descriptor_data());
            messages.push(CMsgClientGetClanActivityCountsResponse::generated_message_descriptor_data());
            messages.push(CMsgClientOGSReportString::generated_message_descriptor_data());
            messages.push(CMsgClientOGSReportBug::generated_message_descriptor_data());
            messages.push(CMsgGSAssociateWithClan::generated_message_descriptor_data());
            messages.push(CMsgGSAssociateWithClanResponse::generated_message_descriptor_data());
            messages.push(CMsgGSComputeNewPlayerCompatibility::generated_message_descriptor_data());
            messages.push(CMsgGSComputeNewPlayerCompatibilityResponse::generated_message_descriptor_data());
            messages.push(CMsgClientSentLogs::generated_message_descriptor_data());
            messages.push(CMsgGCClient::generated_message_descriptor_data());
            messages.push(CMsgClientRequestFreeLicense::generated_message_descriptor_data());
            messages.push(CMsgClientRequestFreeLicenseResponse::generated_message_descriptor_data());
            messages.push(CMsgDRMDownloadRequestWithCrashData::generated_message_descriptor_data());
            messages.push(CMsgDRMDownloadResponse::generated_message_descriptor_data());
            messages.push(CMsgDRMFinalResult::generated_message_descriptor_data());
            messages.push(CMsgClientDPCheckSpecialSurvey::generated_message_descriptor_data());
            messages.push(CMsgClientDPCheckSpecialSurveyResponse::generated_message_descriptor_data());
            messages.push(CMsgClientDPSendSpecialSurveyResponse::generated_message_descriptor_data());
            messages.push(CMsgClientDPSendSpecialSurveyResponseReply::generated_message_descriptor_data());
            messages.push(CMsgClientRequestForgottenPasswordEmail::generated_message_descriptor_data());
            messages.push(CMsgClientRequestForgottenPasswordEmailResponse::generated_message_descriptor_data());
            messages.push(CMsgClientItemAnnouncements::generated_message_descriptor_data());
            messages.push(CMsgClientRequestItemAnnouncements::generated_message_descriptor_data());
            messages.push(CMsgClientUserNotifications::generated_message_descriptor_data());
            messages.push(CMsgClientCommentNotifications::generated_message_descriptor_data());
            messages.push(CMsgClientRequestCommentNotifications::generated_message_descriptor_data());
            messages.push(CMsgClientOfflineMessageNotification::generated_message_descriptor_data());
            messages.push(CMsgClientRequestOfflineMessageCount::generated_message_descriptor_data());
            messages.push(CMsgClientChatGetFriendMessageHistory::generated_message_descriptor_data());
            messages.push(CMsgClientChatGetFriendMessageHistoryResponse::generated_message_descriptor_data());
            messages.push(CMsgClientChatGetFriendMessageHistoryForOfflineMessages::generated_message_descriptor_data());
            messages.push(CMsgClientFSGetFriendsSteamLevels::generated_message_descriptor_data());
            messages.push(CMsgClientFSGetFriendsSteamLevelsResponse::generated_message_descriptor_data());
            messages.push(CMsgClientEmailAddrInfo::generated_message_descriptor_data());
            messages.push(CMsgCREItemVoteSummary::generated_message_descriptor_data());
            messages.push(CMsgCREItemVoteSummaryResponse::generated_message_descriptor_data());
            messages.push(CMsgCREUpdateUserPublishedItemVote::generated_message_descriptor_data());
            messages.push(CMsgCREUpdateUserPublishedItemVoteResponse::generated_message_descriptor_data());
            messages.push(CMsgCREGetUserPublishedItemVoteDetails::generated_message_descriptor_data());
            messages.push(CMsgCREGetUserPublishedItemVoteDetailsResponse::generated_message_descriptor_data());
            messages.push(CMsgGameServerPingSample::generated_message_descriptor_data());
            messages.push(CMsgFSGetFollowerCount::generated_message_descriptor_data());
            messages.push(CMsgFSGetFollowerCountResponse::generated_message_descriptor_data());
            messages.push(CMsgFSGetIsFollowing::generated_message_descriptor_data());
            messages.push(CMsgFSGetIsFollowingResponse::generated_message_descriptor_data());
            messages.push(CMsgFSEnumerateFollowingList::generated_message_descriptor_data());
            messages.push(CMsgFSEnumerateFollowingListResponse::generated_message_descriptor_data());
            messages.push(CMsgDPGetNumberOfCurrentPlayers::generated_message_descriptor_data());
            messages.push(CMsgDPGetNumberOfCurrentPlayersResponse::generated_message_descriptor_data());
            messages.push(CMsgClientFriendUserStatusPublished::generated_message_descriptor_data());
            messages.push(CMsgClientServiceMethodLegacy::generated_message_descriptor_data());
            messages.push(CMsgClientServiceMethodLegacyResponse::generated_message_descriptor_data());
            messages.push(CMsgClientUIMode::generated_message_descriptor_data());
            messages.push(CMsgClientVanityURLChangedNotification::generated_message_descriptor_data());
            messages.push(CMsgClientAuthorizeLocalDeviceRequest::generated_message_descriptor_data());
            messages.push(CMsgClientAuthorizeLocalDevice::generated_message_descriptor_data());
            messages.push(CMsgClientAuthorizeLocalDeviceNotification::generated_message_descriptor_data());
            messages.push(CMsgClientDeauthorizeDeviceRequest::generated_message_descriptor_data());
            messages.push(CMsgClientDeauthorizeDevice::generated_message_descriptor_data());
            messages.push(CMsgClientUseLocalDeviceAuthorizations::generated_message_descriptor_data());
            messages.push(CMsgClientGetAuthorizedDevices::generated_message_descriptor_data());
            messages.push(CMsgClientGetAuthorizedDevicesResponse::generated_message_descriptor_data());
            messages.push(CMsgClientSharedLibraryLockStatus::generated_message_descriptor_data());
            messages.push(CMsgClientSharedLibraryStopPlaying::generated_message_descriptor_data());
            messages.push(CMsgClientServiceCall::generated_message_descriptor_data());
            messages.push(CMsgClientServiceModule::generated_message_descriptor_data());
            messages.push(CMsgClientServiceCallResponse::generated_message_descriptor_data());
            messages.push(CMsgAMUnlockStreaming::generated_message_descriptor_data());
            messages.push(CMsgAMUnlockStreamingResponse::generated_message_descriptor_data());
            messages.push(CMsgAMUnlockHEVC::generated_message_descriptor_data());
            messages.push(CMsgAMUnlockHEVCResponse::generated_message_descriptor_data());
            messages.push(CMsgClientPlayingSessionState::generated_message_descriptor_data());
            messages.push(CMsgClientKickPlayingSession::generated_message_descriptor_data());
            messages.push(CMsgClientVoiceCallPreAuthorize::generated_message_descriptor_data());
            messages.push(CMsgClientVoiceCallPreAuthorizeResponse::generated_message_descriptor_data());
            messages.push(CMsgBadgeCraftedNotification::generated_message_descriptor_data());
            messages.push(cmsg_client_ucmadd_screenshot::Tag::generated_message_descriptor_data());
            messages.push(cmsg_client_ucmupdate_published_file::KeyValueTag::generated_message_descriptor_data());
            messages.push(cmsg_client_ucmupdate_published_file::AdditionalPreview::generated_message_descriptor_data());
            messages.push(cmsg_client_ucmenumerate_user_published_files_response::PublishedFileId::generated_message_descriptor_data());
            messages.push(cmsg_client_ucmenumerate_user_subscribed_files_response::PublishedFileId::generated_message_descriptor_data());
            messages.push(cmsg_client_ucmenumerate_user_subscribed_files_with_updates_response::PublishedFileId::generated_message_descriptor_data());
            messages.push(cmsg_client_workshop_item_changes_response::WorkshopItemInfo::generated_message_descriptor_data());
            messages.push(cmsg_client_workshop_item_info_request::WorkshopItem::generated_message_descriptor_data());
            messages.push(cmsg_client_workshop_item_info_response::WorkshopItemInfo::generated_message_descriptor_data());
            messages.push(cmsg_client_ucmget_published_files_for_user_response::PublishedFileId::generated_message_descriptor_data());
            messages.push(cmsg_client_ucmenumerate_published_files_by_user_action_response::PublishedFileId::generated_message_descriptor_data());
            messages.push(cmsg_client_rich_presence_info::RichPresence::generated_message_descriptor_data());
            messages.push(cmsg_client_check_app_beta_password_response::BetaPassword::generated_message_descriptor_data());
            messages.push(cmsg_download_rate_statistics::StatsInfo::generated_message_descriptor_data());
            messages.push(cmsg_client_ugsget_global_stats_response::Day::generated_message_descriptor_data());
            messages.push(cmsg_client_ugsget_global_stats_response::day::Stat::generated_message_descriptor_data());
            messages.push(cmsg_game_server_data::Player::generated_message_descriptor_data());
            messages.push(cmsg_gmsclient_server_query_response::Server::generated_message_descriptor_data());
            messages.push(cmsg_client_item_announcements::UnseenItem::generated_message_descriptor_data());
            messages.push(cmsg_client_user_notifications::Notification::generated_message_descriptor_data());
            messages.push(cmsg_client_chat_get_friend_message_history_response::FriendMessage::generated_message_descriptor_data());
            messages.push(cmsg_client_fsget_friends_steam_levels_response::Friend::generated_message_descriptor_data());
            messages.push(cmsg_creitem_vote_summary::PublishedFileId::generated_message_descriptor_data());
            messages.push(cmsg_creitem_vote_summary_response::ItemVoteSummary::generated_message_descriptor_data());
            messages.push(cmsg_creget_user_published_item_vote_details::PublishedFileId::generated_message_descriptor_data());
            messages.push(cmsg_creget_user_published_item_vote_details_response::UserItemVoteDetail::generated_message_descriptor_data());
            messages.push(cmsg_game_server_ping_sample::Sample::generated_message_descriptor_data());
            messages.push(cmsg_client_use_local_device_authorizations::DeviceToken::generated_message_descriptor_data());
            messages.push(cmsg_client_get_authorized_devices_response::AuthorizedDevice::generated_message_descriptor_data());
            messages.push(cmsg_client_shared_library_lock_status::LockedLibrary::generated_message_descriptor_data());
            messages.push(cmsg_client_shared_library_stop_playing::StopApp::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
