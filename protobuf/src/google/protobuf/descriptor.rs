// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `google/protobuf/descriptor.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:google.protobuf.FileDescriptorSet)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FileDescriptorSet {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorSet.file)
    pub file: ::std::vec::Vec<FileDescriptorProto>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.FileDescriptorSet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileDescriptorSet {
    fn default() -> &'a FileDescriptorSet {
        <FileDescriptorSet as ::protobuf::Message>::default_instance()
    }
}

impl FileDescriptorSet {
    pub fn new() -> FileDescriptorSet {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "file",
            |m: &FileDescriptorSet| { &m.file },
            |m: &mut FileDescriptorSet| { &mut m.file },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileDescriptorSet>(
            "FileDescriptorSet",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileDescriptorSet {
    const NAME: &'static str = "FileDescriptorSet";

    fn is_initialized(&self) -> bool {
        for v in &self.file {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.file.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.file {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.file {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileDescriptorSet {
        FileDescriptorSet::new()
    }

    fn clear(&mut self) {
        self.file.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileDescriptorSet {
        static instance: FileDescriptorSet = FileDescriptorSet {
            file: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileDescriptorSet {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileDescriptorSet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileDescriptorSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileDescriptorSet {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:google.protobuf.FileDescriptorProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FileDescriptorProto {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.package)
    pub package: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.dependency)
    pub dependency: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.public_dependency)
    pub public_dependency: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.weak_dependency)
    pub weak_dependency: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.message_type)
    pub message_type: ::std::vec::Vec<DescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.enum_type)
    pub enum_type: ::std::vec::Vec<EnumDescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.service)
    pub service: ::std::vec::Vec<ServiceDescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.extension)
    pub extension: ::std::vec::Vec<FieldDescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.options)
    pub options: ::protobuf::MessageField<FileOptions>,
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.source_code_info)
    pub source_code_info: ::protobuf::MessageField<SourceCodeInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.FileDescriptorProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileDescriptorProto {
    fn default() -> &'a FileDescriptorProto {
        <FileDescriptorProto as ::protobuf::Message>::default_instance()
    }
}

impl FileDescriptorProto {
    pub fn new() -> FileDescriptorProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string package = 2;

    pub fn package(&self) -> &str {
        match self.package.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_package(&mut self) {
        self.package = ::std::option::Option::None;
    }

    pub fn has_package(&self) -> bool {
        self.package.is_some()
    }

    // Param is passed by value, moved
    pub fn set_package(&mut self, v: ::std::string::String) {
        self.package = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_package(&mut self) -> &mut ::std::string::String {
        if self.package.is_none() {
            self.package = ::std::option::Option::Some(::std::string::String::new());
        }
        self.package.as_mut().unwrap()
    }

    // Take field
    pub fn take_package(&mut self) -> ::std::string::String {
        self.package.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &FileDescriptorProto| { &m.name },
            |m: &mut FileDescriptorProto| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "package",
            |m: &FileDescriptorProto| { &m.package },
            |m: &mut FileDescriptorProto| { &mut m.package },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dependency",
            |m: &FileDescriptorProto| { &m.dependency },
            |m: &mut FileDescriptorProto| { &mut m.dependency },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "public_dependency",
            |m: &FileDescriptorProto| { &m.public_dependency },
            |m: &mut FileDescriptorProto| { &mut m.public_dependency },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "weak_dependency",
            |m: &FileDescriptorProto| { &m.weak_dependency },
            |m: &mut FileDescriptorProto| { &mut m.weak_dependency },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "message_type",
            |m: &FileDescriptorProto| { &m.message_type },
            |m: &mut FileDescriptorProto| { &mut m.message_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "enum_type",
            |m: &FileDescriptorProto| { &m.enum_type },
            |m: &mut FileDescriptorProto| { &mut m.enum_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "service",
            |m: &FileDescriptorProto| { &m.service },
            |m: &mut FileDescriptorProto| { &mut m.service },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "extension",
            |m: &FileDescriptorProto| { &m.extension },
            |m: &mut FileDescriptorProto| { &mut m.extension },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FileOptions>(
            "options",
            |m: &FileDescriptorProto| { &m.options },
            |m: &mut FileDescriptorProto| { &mut m.options },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SourceCodeInfo>(
            "source_code_info",
            |m: &FileDescriptorProto| { &m.source_code_info },
            |m: &mut FileDescriptorProto| { &mut m.source_code_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileDescriptorProto>(
            "FileDescriptorProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileDescriptorProto {
    const NAME: &'static str = "FileDescriptorProto";

    fn is_initialized(&self) -> bool {
        for v in &self.message_type {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.enum_type {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.service {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.source_code_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.package = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.dependency.push(is.read_string()?);
                },
                82 => {
                    is.read_repeated_packed_int32_into(&mut self.public_dependency)?;
                },
                80 => {
                    self.public_dependency.push(is.read_int32()?);
                },
                90 => {
                    is.read_repeated_packed_int32_into(&mut self.weak_dependency)?;
                },
                88 => {
                    self.weak_dependency.push(is.read_int32()?);
                },
                34 => {
                    self.message_type.push(is.read_message()?);
                },
                42 => {
                    self.enum_type.push(is.read_message()?);
                },
                50 => {
                    self.service.push(is.read_message()?);
                },
                58 => {
                    self.extension.push(is.read_message()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.options)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.source_code_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.package.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.dependency {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.public_dependency {
            my_size += ::protobuf::rt::int32_size(10, *value);
        };
        for value in &self.weak_dependency {
            my_size += ::protobuf::rt::int32_size(11, *value);
        };
        for value in &self.message_type {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.enum_type {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.service {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.source_code_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.package.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.dependency {
            os.write_string(3, &v)?;
        };
        for v in &self.public_dependency {
            os.write_int32(10, *v)?;
        };
        for v in &self.weak_dependency {
            os.write_int32(11, *v)?;
        };
        for v in &self.message_type {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.enum_type {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.service {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.extension {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if let Some(v) = self.options.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.source_code_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileDescriptorProto {
        FileDescriptorProto::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.package = ::std::option::Option::None;
        self.dependency.clear();
        self.public_dependency.clear();
        self.weak_dependency.clear();
        self.message_type.clear();
        self.enum_type.clear();
        self.service.clear();
        self.extension.clear();
        self.options.clear();
        self.source_code_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileDescriptorProto {
        static instance: FileDescriptorProto = FileDescriptorProto {
            name: ::std::option::Option::None,
            package: ::std::option::Option::None,
            dependency: ::std::vec::Vec::new(),
            public_dependency: ::std::vec::Vec::new(),
            weak_dependency: ::std::vec::Vec::new(),
            message_type: ::std::vec::Vec::new(),
            enum_type: ::std::vec::Vec::new(),
            service: ::std::vec::Vec::new(),
            extension: ::std::vec::Vec::new(),
            options: ::protobuf::MessageField::none(),
            source_code_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileDescriptorProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileDescriptorProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileDescriptorProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileDescriptorProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:google.protobuf.DescriptorProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DescriptorProto {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.field)
    pub field: ::std::vec::Vec<FieldDescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.extension)
    pub extension: ::std::vec::Vec<FieldDescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.nested_type)
    pub nested_type: ::std::vec::Vec<DescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.enum_type)
    pub enum_type: ::std::vec::Vec<EnumDescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.extension_range)
    pub extension_range: ::std::vec::Vec<descriptor_proto::ExtensionRange>,
    // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.oneof_decl)
    pub oneof_decl: ::std::vec::Vec<OneofDescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.options)
    pub options: ::protobuf::MessageField<MessageOptions>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.DescriptorProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DescriptorProto {
    fn default() -> &'a DescriptorProto {
        <DescriptorProto as ::protobuf::Message>::default_instance()
    }
}

impl DescriptorProto {
    pub fn new() -> DescriptorProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &DescriptorProto| { &m.name },
            |m: &mut DescriptorProto| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "field",
            |m: &DescriptorProto| { &m.field },
            |m: &mut DescriptorProto| { &mut m.field },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "extension",
            |m: &DescriptorProto| { &m.extension },
            |m: &mut DescriptorProto| { &mut m.extension },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "nested_type",
            |m: &DescriptorProto| { &m.nested_type },
            |m: &mut DescriptorProto| { &mut m.nested_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "enum_type",
            |m: &DescriptorProto| { &m.enum_type },
            |m: &mut DescriptorProto| { &mut m.enum_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "extension_range",
            |m: &DescriptorProto| { &m.extension_range },
            |m: &mut DescriptorProto| { &mut m.extension_range },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "oneof_decl",
            |m: &DescriptorProto| { &m.oneof_decl },
            |m: &mut DescriptorProto| { &mut m.oneof_decl },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MessageOptions>(
            "options",
            |m: &DescriptorProto| { &m.options },
            |m: &mut DescriptorProto| { &mut m.options },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DescriptorProto>(
            "DescriptorProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DescriptorProto {
    const NAME: &'static str = "DescriptorProto";

    fn is_initialized(&self) -> bool {
        for v in &self.field {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.nested_type {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.enum_type {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension_range {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.oneof_decl {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.field.push(is.read_message()?);
                },
                50 => {
                    self.extension.push(is.read_message()?);
                },
                26 => {
                    self.nested_type.push(is.read_message()?);
                },
                34 => {
                    self.enum_type.push(is.read_message()?);
                },
                42 => {
                    self.extension_range.push(is.read_message()?);
                },
                66 => {
                    self.oneof_decl.push(is.read_message()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.options)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.field {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.nested_type {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.enum_type {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.extension_range {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.oneof_decl {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.field {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.extension {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.nested_type {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.enum_type {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.extension_range {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.oneof_decl {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        if let Some(v) = self.options.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DescriptorProto {
        DescriptorProto::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.field.clear();
        self.extension.clear();
        self.nested_type.clear();
        self.enum_type.clear();
        self.extension_range.clear();
        self.oneof_decl.clear();
        self.options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DescriptorProto {
        static instance: DescriptorProto = DescriptorProto {
            name: ::std::option::Option::None,
            field: ::std::vec::Vec::new(),
            extension: ::std::vec::Vec::new(),
            nested_type: ::std::vec::Vec::new(),
            enum_type: ::std::vec::Vec::new(),
            extension_range: ::std::vec::Vec::new(),
            oneof_decl: ::std::vec::Vec::new(),
            options: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DescriptorProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DescriptorProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DescriptorProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DescriptorProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `DescriptorProto`
pub mod descriptor_proto {
    // @@protoc_insertion_point(message:google.protobuf.DescriptorProto.ExtensionRange)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ExtensionRange {
        // message fields
        // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.ExtensionRange.start)
        pub start: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.ExtensionRange.end)
        pub end: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:google.protobuf.DescriptorProto.ExtensionRange.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ExtensionRange {
        fn default() -> &'a ExtensionRange {
            <ExtensionRange as ::protobuf::Message>::default_instance()
        }
    }

    impl ExtensionRange {
        pub fn new() -> ExtensionRange {
            ::std::default::Default::default()
        }

        // optional int32 start = 1;

        pub fn start(&self) -> i32 {
            self.start.unwrap_or(0)
        }

        pub fn clear_start(&mut self) {
            self.start = ::std::option::Option::None;
        }

        pub fn has_start(&self) -> bool {
            self.start.is_some()
        }

        // Param is passed by value, moved
        pub fn set_start(&mut self, v: i32) {
            self.start = ::std::option::Option::Some(v);
        }

        // optional int32 end = 2;

        pub fn end(&self) -> i32 {
            self.end.unwrap_or(0)
        }

        pub fn clear_end(&mut self) {
            self.end = ::std::option::Option::None;
        }

        pub fn has_end(&self) -> bool {
            self.end.is_some()
        }

        // Param is passed by value, moved
        pub fn set_end(&mut self, v: i32) {
            self.end = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "start",
                |m: &ExtensionRange| { &m.start },
                |m: &mut ExtensionRange| { &mut m.start },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "end",
                |m: &ExtensionRange| { &m.end },
                |m: &mut ExtensionRange| { &mut m.end },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExtensionRange>(
                "DescriptorProto.ExtensionRange",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ExtensionRange {
        const NAME: &'static str = "ExtensionRange";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.start = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.end = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.start {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.end {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.start {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.end {
                os.write_int32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ExtensionRange {
            ExtensionRange::new()
        }

        fn clear(&mut self) {
            self.start = ::std::option::Option::None;
            self.end = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ExtensionRange {
            static instance: ExtensionRange = ExtensionRange {
                start: ::std::option::Option::None,
                end: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ExtensionRange {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("DescriptorProto.ExtensionRange").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ExtensionRange {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ExtensionRange {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:google.protobuf.FieldDescriptorProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FieldDescriptorProto {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.number)
    pub number: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.label)
    pub label: ::std::option::Option<::protobuf::EnumOrUnknown<field_descriptor_proto::Label>>,
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<field_descriptor_proto::Type>>,
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.type_name)
    pub type_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.extendee)
    pub extendee: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.default_value)
    pub default_value: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.oneof_index)
    pub oneof_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.options)
    pub options: ::protobuf::MessageField<FieldOptions>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.FieldDescriptorProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FieldDescriptorProto {
    fn default() -> &'a FieldDescriptorProto {
        <FieldDescriptorProto as ::protobuf::Message>::default_instance()
    }
}

impl FieldDescriptorProto {
    pub fn new() -> FieldDescriptorProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 number = 3;

    pub fn number(&self) -> i32 {
        self.number.unwrap_or(0)
    }

    pub fn clear_number(&mut self) {
        self.number = ::std::option::Option::None;
    }

    pub fn has_number(&self) -> bool {
        self.number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number(&mut self, v: i32) {
        self.number = ::std::option::Option::Some(v);
    }

    // optional .google.protobuf.FieldDescriptorProto.Label label = 4;

    pub fn label(&self) -> field_descriptor_proto::Label {
        match self.label {
            Some(e) => e.enum_value_or(field_descriptor_proto::Label::LABEL_OPTIONAL),
            None => field_descriptor_proto::Label::LABEL_OPTIONAL,
        }
    }

    pub fn clear_label(&mut self) {
        self.label = ::std::option::Option::None;
    }

    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: field_descriptor_proto::Label) {
        self.label = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .google.protobuf.FieldDescriptorProto.Type type = 5;

    pub fn type_(&self) -> field_descriptor_proto::Type {
        match self.type_ {
            Some(e) => e.enum_value_or(field_descriptor_proto::Type::TYPE_DOUBLE),
            None => field_descriptor_proto::Type::TYPE_DOUBLE,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: field_descriptor_proto::Type) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string type_name = 6;

    pub fn type_name(&self) -> &str {
        match self.type_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_name(&mut self) {
        self.type_name = ::std::option::Option::None;
    }

    pub fn has_type_name(&self) -> bool {
        self.type_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type_name(&mut self, v: ::std::string::String) {
        self.type_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type_name(&mut self) -> &mut ::std::string::String {
        if self.type_name.is_none() {
            self.type_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_name(&mut self) -> ::std::string::String {
        self.type_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string extendee = 2;

    pub fn extendee(&self) -> &str {
        match self.extendee.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_extendee(&mut self) {
        self.extendee = ::std::option::Option::None;
    }

    pub fn has_extendee(&self) -> bool {
        self.extendee.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extendee(&mut self, v: ::std::string::String) {
        self.extendee = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extendee(&mut self) -> &mut ::std::string::String {
        if self.extendee.is_none() {
            self.extendee = ::std::option::Option::Some(::std::string::String::new());
        }
        self.extendee.as_mut().unwrap()
    }

    // Take field
    pub fn take_extendee(&mut self) -> ::std::string::String {
        self.extendee.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string default_value = 7;

    pub fn default_value(&self) -> &str {
        match self.default_value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_default_value(&mut self) {
        self.default_value = ::std::option::Option::None;
    }

    pub fn has_default_value(&self) -> bool {
        self.default_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_value(&mut self, v: ::std::string::String) {
        self.default_value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_value(&mut self) -> &mut ::std::string::String {
        if self.default_value.is_none() {
            self.default_value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.default_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_default_value(&mut self) -> ::std::string::String {
        self.default_value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 oneof_index = 9;

    pub fn oneof_index(&self) -> i32 {
        self.oneof_index.unwrap_or(0)
    }

    pub fn clear_oneof_index(&mut self) {
        self.oneof_index = ::std::option::Option::None;
    }

    pub fn has_oneof_index(&self) -> bool {
        self.oneof_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_oneof_index(&mut self, v: i32) {
        self.oneof_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &FieldDescriptorProto| { &m.name },
            |m: &mut FieldDescriptorProto| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "number",
            |m: &FieldDescriptorProto| { &m.number },
            |m: &mut FieldDescriptorProto| { &mut m.number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "label",
            |m: &FieldDescriptorProto| { &m.label },
            |m: &mut FieldDescriptorProto| { &mut m.label },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &FieldDescriptorProto| { &m.type_ },
            |m: &mut FieldDescriptorProto| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type_name",
            |m: &FieldDescriptorProto| { &m.type_name },
            |m: &mut FieldDescriptorProto| { &mut m.type_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "extendee",
            |m: &FieldDescriptorProto| { &m.extendee },
            |m: &mut FieldDescriptorProto| { &mut m.extendee },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "default_value",
            |m: &FieldDescriptorProto| { &m.default_value },
            |m: &mut FieldDescriptorProto| { &mut m.default_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "oneof_index",
            |m: &FieldDescriptorProto| { &m.oneof_index },
            |m: &mut FieldDescriptorProto| { &mut m.oneof_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FieldOptions>(
            "options",
            |m: &FieldDescriptorProto| { &m.options },
            |m: &mut FieldDescriptorProto| { &mut m.options },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FieldDescriptorProto>(
            "FieldDescriptorProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FieldDescriptorProto {
    const NAME: &'static str = "FieldDescriptorProto";

    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.number = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.label = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                50 => {
                    self.type_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.extendee = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.default_value = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.oneof_index = ::std::option::Option::Some(is.read_int32()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.options)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.number {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.label {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(5, v.value());
        }
        if let Some(v) = self.type_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.extendee.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.default_value.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.oneof_index {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        if let Some(v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.number {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.label {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.type_name.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.extendee.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.default_value.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.oneof_index {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.options.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FieldDescriptorProto {
        FieldDescriptorProto::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.number = ::std::option::Option::None;
        self.label = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_name = ::std::option::Option::None;
        self.extendee = ::std::option::Option::None;
        self.default_value = ::std::option::Option::None;
        self.oneof_index = ::std::option::Option::None;
        self.options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FieldDescriptorProto {
        static instance: FieldDescriptorProto = FieldDescriptorProto {
            name: ::std::option::Option::None,
            number: ::std::option::Option::None,
            label: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            type_name: ::std::option::Option::None,
            extendee: ::std::option::Option::None,
            default_value: ::std::option::Option::None,
            oneof_index: ::std::option::Option::None,
            options: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FieldDescriptorProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FieldDescriptorProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FieldDescriptorProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FieldDescriptorProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `FieldDescriptorProto`
pub mod field_descriptor_proto {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:google.protobuf.FieldDescriptorProto.Type)
    pub enum Type {
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_DOUBLE)
        TYPE_DOUBLE = 1,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_FLOAT)
        TYPE_FLOAT = 2,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_INT64)
        TYPE_INT64 = 3,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_UINT64)
        TYPE_UINT64 = 4,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_INT32)
        TYPE_INT32 = 5,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_FIXED64)
        TYPE_FIXED64 = 6,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_FIXED32)
        TYPE_FIXED32 = 7,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_BOOL)
        TYPE_BOOL = 8,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_STRING)
        TYPE_STRING = 9,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_GROUP)
        TYPE_GROUP = 10,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_MESSAGE)
        TYPE_MESSAGE = 11,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_BYTES)
        TYPE_BYTES = 12,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_UINT32)
        TYPE_UINT32 = 13,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_ENUM)
        TYPE_ENUM = 14,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_SFIXED32)
        TYPE_SFIXED32 = 15,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_SFIXED64)
        TYPE_SFIXED64 = 16,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_SINT32)
        TYPE_SINT32 = 17,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_SINT64)
        TYPE_SINT64 = 18,
    }

    impl ::protobuf::Enum for Type {
        const NAME: &'static str = "Type";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Type> {
            match value {
                1 => ::std::option::Option::Some(Type::TYPE_DOUBLE),
                2 => ::std::option::Option::Some(Type::TYPE_FLOAT),
                3 => ::std::option::Option::Some(Type::TYPE_INT64),
                4 => ::std::option::Option::Some(Type::TYPE_UINT64),
                5 => ::std::option::Option::Some(Type::TYPE_INT32),
                6 => ::std::option::Option::Some(Type::TYPE_FIXED64),
                7 => ::std::option::Option::Some(Type::TYPE_FIXED32),
                8 => ::std::option::Option::Some(Type::TYPE_BOOL),
                9 => ::std::option::Option::Some(Type::TYPE_STRING),
                10 => ::std::option::Option::Some(Type::TYPE_GROUP),
                11 => ::std::option::Option::Some(Type::TYPE_MESSAGE),
                12 => ::std::option::Option::Some(Type::TYPE_BYTES),
                13 => ::std::option::Option::Some(Type::TYPE_UINT32),
                14 => ::std::option::Option::Some(Type::TYPE_ENUM),
                15 => ::std::option::Option::Some(Type::TYPE_SFIXED32),
                16 => ::std::option::Option::Some(Type::TYPE_SFIXED64),
                17 => ::std::option::Option::Some(Type::TYPE_SINT32),
                18 => ::std::option::Option::Some(Type::TYPE_SINT64),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Type> {
            match str {
                "TYPE_DOUBLE" => ::std::option::Option::Some(Type::TYPE_DOUBLE),
                "TYPE_FLOAT" => ::std::option::Option::Some(Type::TYPE_FLOAT),
                "TYPE_INT64" => ::std::option::Option::Some(Type::TYPE_INT64),
                "TYPE_UINT64" => ::std::option::Option::Some(Type::TYPE_UINT64),
                "TYPE_INT32" => ::std::option::Option::Some(Type::TYPE_INT32),
                "TYPE_FIXED64" => ::std::option::Option::Some(Type::TYPE_FIXED64),
                "TYPE_FIXED32" => ::std::option::Option::Some(Type::TYPE_FIXED32),
                "TYPE_BOOL" => ::std::option::Option::Some(Type::TYPE_BOOL),
                "TYPE_STRING" => ::std::option::Option::Some(Type::TYPE_STRING),
                "TYPE_GROUP" => ::std::option::Option::Some(Type::TYPE_GROUP),
                "TYPE_MESSAGE" => ::std::option::Option::Some(Type::TYPE_MESSAGE),
                "TYPE_BYTES" => ::std::option::Option::Some(Type::TYPE_BYTES),
                "TYPE_UINT32" => ::std::option::Option::Some(Type::TYPE_UINT32),
                "TYPE_ENUM" => ::std::option::Option::Some(Type::TYPE_ENUM),
                "TYPE_SFIXED32" => ::std::option::Option::Some(Type::TYPE_SFIXED32),
                "TYPE_SFIXED64" => ::std::option::Option::Some(Type::TYPE_SFIXED64),
                "TYPE_SINT32" => ::std::option::Option::Some(Type::TYPE_SINT32),
                "TYPE_SINT64" => ::std::option::Option::Some(Type::TYPE_SINT64),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Type] = &[
            Type::TYPE_DOUBLE,
            Type::TYPE_FLOAT,
            Type::TYPE_INT64,
            Type::TYPE_UINT64,
            Type::TYPE_INT32,
            Type::TYPE_FIXED64,
            Type::TYPE_FIXED32,
            Type::TYPE_BOOL,
            Type::TYPE_STRING,
            Type::TYPE_GROUP,
            Type::TYPE_MESSAGE,
            Type::TYPE_BYTES,
            Type::TYPE_UINT32,
            Type::TYPE_ENUM,
            Type::TYPE_SFIXED32,
            Type::TYPE_SFIXED64,
            Type::TYPE_SINT32,
            Type::TYPE_SINT64,
        ];
    }

    impl ::protobuf::EnumFull for Type {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("FieldDescriptorProto.Type").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Type::TYPE_DOUBLE => 0,
                Type::TYPE_FLOAT => 1,
                Type::TYPE_INT64 => 2,
                Type::TYPE_UINT64 => 3,
                Type::TYPE_INT32 => 4,
                Type::TYPE_FIXED64 => 5,
                Type::TYPE_FIXED32 => 6,
                Type::TYPE_BOOL => 7,
                Type::TYPE_STRING => 8,
                Type::TYPE_GROUP => 9,
                Type::TYPE_MESSAGE => 10,
                Type::TYPE_BYTES => 11,
                Type::TYPE_UINT32 => 12,
                Type::TYPE_ENUM => 13,
                Type::TYPE_SFIXED32 => 14,
                Type::TYPE_SFIXED64 => 15,
                Type::TYPE_SINT32 => 16,
                Type::TYPE_SINT64 => 17,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Type {
        fn default() -> Self {
            Type::TYPE_DOUBLE
        }
    }

    impl Type {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Type>("FieldDescriptorProto.Type")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:google.protobuf.FieldDescriptorProto.Label)
    pub enum Label {
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Label.LABEL_OPTIONAL)
        LABEL_OPTIONAL = 1,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Label.LABEL_REQUIRED)
        LABEL_REQUIRED = 2,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Label.LABEL_REPEATED)
        LABEL_REPEATED = 3,
    }

    impl ::protobuf::Enum for Label {
        const NAME: &'static str = "Label";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Label> {
            match value {
                1 => ::std::option::Option::Some(Label::LABEL_OPTIONAL),
                2 => ::std::option::Option::Some(Label::LABEL_REQUIRED),
                3 => ::std::option::Option::Some(Label::LABEL_REPEATED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Label> {
            match str {
                "LABEL_OPTIONAL" => ::std::option::Option::Some(Label::LABEL_OPTIONAL),
                "LABEL_REQUIRED" => ::std::option::Option::Some(Label::LABEL_REQUIRED),
                "LABEL_REPEATED" => ::std::option::Option::Some(Label::LABEL_REPEATED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Label] = &[
            Label::LABEL_OPTIONAL,
            Label::LABEL_REQUIRED,
            Label::LABEL_REPEATED,
        ];
    }

    impl ::protobuf::EnumFull for Label {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("FieldDescriptorProto.Label").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Label::LABEL_OPTIONAL => 0,
                Label::LABEL_REQUIRED => 1,
                Label::LABEL_REPEATED => 2,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Label {
        fn default() -> Self {
            Label::LABEL_OPTIONAL
        }
    }

    impl Label {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Label>("FieldDescriptorProto.Label")
        }
    }
}

// @@protoc_insertion_point(message:google.protobuf.OneofDescriptorProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct OneofDescriptorProto {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.OneofDescriptorProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.OneofDescriptorProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OneofDescriptorProto {
    fn default() -> &'a OneofDescriptorProto {
        <OneofDescriptorProto as ::protobuf::Message>::default_instance()
    }
}

impl OneofDescriptorProto {
    pub fn new() -> OneofDescriptorProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &OneofDescriptorProto| { &m.name },
            |m: &mut OneofDescriptorProto| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OneofDescriptorProto>(
            "OneofDescriptorProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OneofDescriptorProto {
    const NAME: &'static str = "OneofDescriptorProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OneofDescriptorProto {
        OneofDescriptorProto::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OneofDescriptorProto {
        static instance: OneofDescriptorProto = OneofDescriptorProto {
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OneofDescriptorProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OneofDescriptorProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OneofDescriptorProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OneofDescriptorProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:google.protobuf.EnumDescriptorProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EnumDescriptorProto {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.EnumDescriptorProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.EnumDescriptorProto.value)
    pub value: ::std::vec::Vec<EnumValueDescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.EnumDescriptorProto.options)
    pub options: ::protobuf::MessageField<EnumOptions>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.EnumDescriptorProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EnumDescriptorProto {
    fn default() -> &'a EnumDescriptorProto {
        <EnumDescriptorProto as ::protobuf::Message>::default_instance()
    }
}

impl EnumDescriptorProto {
    pub fn new() -> EnumDescriptorProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &EnumDescriptorProto| { &m.name },
            |m: &mut EnumDescriptorProto| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "value",
            |m: &EnumDescriptorProto| { &m.value },
            |m: &mut EnumDescriptorProto| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, EnumOptions>(
            "options",
            |m: &EnumDescriptorProto| { &m.options },
            |m: &mut EnumDescriptorProto| { &mut m.options },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EnumDescriptorProto>(
            "EnumDescriptorProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EnumDescriptorProto {
    const NAME: &'static str = "EnumDescriptorProto";

    fn is_initialized(&self) -> bool {
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.value.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.options)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.value {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.value {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.options.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EnumDescriptorProto {
        EnumDescriptorProto::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.value.clear();
        self.options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EnumDescriptorProto {
        static instance: EnumDescriptorProto = EnumDescriptorProto {
            name: ::std::option::Option::None,
            value: ::std::vec::Vec::new(),
            options: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EnumDescriptorProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EnumDescriptorProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EnumDescriptorProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnumDescriptorProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:google.protobuf.EnumValueDescriptorProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EnumValueDescriptorProto {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.EnumValueDescriptorProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.EnumValueDescriptorProto.number)
    pub number: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:google.protobuf.EnumValueDescriptorProto.options)
    pub options: ::protobuf::MessageField<EnumValueOptions>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.EnumValueDescriptorProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EnumValueDescriptorProto {
    fn default() -> &'a EnumValueDescriptorProto {
        <EnumValueDescriptorProto as ::protobuf::Message>::default_instance()
    }
}

impl EnumValueDescriptorProto {
    pub fn new() -> EnumValueDescriptorProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 number = 2;

    pub fn number(&self) -> i32 {
        self.number.unwrap_or(0)
    }

    pub fn clear_number(&mut self) {
        self.number = ::std::option::Option::None;
    }

    pub fn has_number(&self) -> bool {
        self.number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number(&mut self, v: i32) {
        self.number = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &EnumValueDescriptorProto| { &m.name },
            |m: &mut EnumValueDescriptorProto| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "number",
            |m: &EnumValueDescriptorProto| { &m.number },
            |m: &mut EnumValueDescriptorProto| { &mut m.number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, EnumValueOptions>(
            "options",
            |m: &EnumValueDescriptorProto| { &m.options },
            |m: &mut EnumValueDescriptorProto| { &mut m.options },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EnumValueDescriptorProto>(
            "EnumValueDescriptorProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EnumValueDescriptorProto {
    const NAME: &'static str = "EnumValueDescriptorProto";

    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.number = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.options)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.number {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.number {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.options.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EnumValueDescriptorProto {
        EnumValueDescriptorProto::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.number = ::std::option::Option::None;
        self.options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EnumValueDescriptorProto {
        static instance: EnumValueDescriptorProto = EnumValueDescriptorProto {
            name: ::std::option::Option::None,
            number: ::std::option::Option::None,
            options: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EnumValueDescriptorProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EnumValueDescriptorProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EnumValueDescriptorProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnumValueDescriptorProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:google.protobuf.ServiceDescriptorProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServiceDescriptorProto {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.ServiceDescriptorProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.ServiceDescriptorProto.method)
    pub method: ::std::vec::Vec<MethodDescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.ServiceDescriptorProto.options)
    pub options: ::protobuf::MessageField<ServiceOptions>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.ServiceDescriptorProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServiceDescriptorProto {
    fn default() -> &'a ServiceDescriptorProto {
        <ServiceDescriptorProto as ::protobuf::Message>::default_instance()
    }
}

impl ServiceDescriptorProto {
    pub fn new() -> ServiceDescriptorProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &ServiceDescriptorProto| { &m.name },
            |m: &mut ServiceDescriptorProto| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "method",
            |m: &ServiceDescriptorProto| { &m.method },
            |m: &mut ServiceDescriptorProto| { &mut m.method },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ServiceOptions>(
            "options",
            |m: &ServiceDescriptorProto| { &m.options },
            |m: &mut ServiceDescriptorProto| { &mut m.options },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServiceDescriptorProto>(
            "ServiceDescriptorProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServiceDescriptorProto {
    const NAME: &'static str = "ServiceDescriptorProto";

    fn is_initialized(&self) -> bool {
        for v in &self.method {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.method.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.options)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.method {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.method {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.options.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServiceDescriptorProto {
        ServiceDescriptorProto::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.method.clear();
        self.options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServiceDescriptorProto {
        static instance: ServiceDescriptorProto = ServiceDescriptorProto {
            name: ::std::option::Option::None,
            method: ::std::vec::Vec::new(),
            options: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServiceDescriptorProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServiceDescriptorProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServiceDescriptorProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceDescriptorProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:google.protobuf.MethodDescriptorProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MethodDescriptorProto {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.MethodDescriptorProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.MethodDescriptorProto.input_type)
    pub input_type: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.MethodDescriptorProto.output_type)
    pub output_type: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.MethodDescriptorProto.options)
    pub options: ::protobuf::MessageField<MethodOptions>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.MethodDescriptorProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MethodDescriptorProto {
    fn default() -> &'a MethodDescriptorProto {
        <MethodDescriptorProto as ::protobuf::Message>::default_instance()
    }
}

impl MethodDescriptorProto {
    pub fn new() -> MethodDescriptorProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string input_type = 2;

    pub fn input_type(&self) -> &str {
        match self.input_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_input_type(&mut self) {
        self.input_type = ::std::option::Option::None;
    }

    pub fn has_input_type(&self) -> bool {
        self.input_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_type(&mut self, v: ::std::string::String) {
        self.input_type = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input_type(&mut self) -> &mut ::std::string::String {
        if self.input_type.is_none() {
            self.input_type = ::std::option::Option::Some(::std::string::String::new());
        }
        self.input_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_input_type(&mut self) -> ::std::string::String {
        self.input_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string output_type = 3;

    pub fn output_type(&self) -> &str {
        match self.output_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_output_type(&mut self) {
        self.output_type = ::std::option::Option::None;
    }

    pub fn has_output_type(&self) -> bool {
        self.output_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_output_type(&mut self, v: ::std::string::String) {
        self.output_type = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output_type(&mut self) -> &mut ::std::string::String {
        if self.output_type.is_none() {
            self.output_type = ::std::option::Option::Some(::std::string::String::new());
        }
        self.output_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_output_type(&mut self) -> ::std::string::String {
        self.output_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &MethodDescriptorProto| { &m.name },
            |m: &mut MethodDescriptorProto| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "input_type",
            |m: &MethodDescriptorProto| { &m.input_type },
            |m: &mut MethodDescriptorProto| { &mut m.input_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "output_type",
            |m: &MethodDescriptorProto| { &m.output_type },
            |m: &mut MethodDescriptorProto| { &mut m.output_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MethodOptions>(
            "options",
            |m: &MethodDescriptorProto| { &m.options },
            |m: &mut MethodDescriptorProto| { &mut m.options },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MethodDescriptorProto>(
            "MethodDescriptorProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MethodDescriptorProto {
    const NAME: &'static str = "MethodDescriptorProto";

    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.input_type = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.output_type = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.options)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.input_type.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.output_type.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.input_type.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.output_type.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.options.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MethodDescriptorProto {
        MethodDescriptorProto::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.input_type = ::std::option::Option::None;
        self.output_type = ::std::option::Option::None;
        self.options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MethodDescriptorProto {
        static instance: MethodDescriptorProto = MethodDescriptorProto {
            name: ::std::option::Option::None,
            input_type: ::std::option::Option::None,
            output_type: ::std::option::Option::None,
            options: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MethodDescriptorProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MethodDescriptorProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MethodDescriptorProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MethodDescriptorProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:google.protobuf.FileOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FileOptions {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.java_package)
    pub java_package: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.java_outer_classname)
    pub java_outer_classname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.java_multiple_files)
    pub java_multiple_files: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.java_generate_equals_and_hash)
    pub java_generate_equals_and_hash: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.java_string_check_utf8)
    pub java_string_check_utf8: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.optimize_for)
    pub optimize_for: ::std::option::Option<::protobuf::EnumOrUnknown<file_options::OptimizeMode>>,
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.go_package)
    pub go_package: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.cc_generic_services)
    pub cc_generic_services: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.java_generic_services)
    pub java_generic_services: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.py_generic_services)
    pub py_generic_services: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.deprecated)
    pub deprecated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.uninterpreted_option)
    pub uninterpreted_option: ::std::vec::Vec<UninterpretedOption>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.FileOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileOptions {
    fn default() -> &'a FileOptions {
        <FileOptions as ::protobuf::Message>::default_instance()
    }
}

impl FileOptions {
    pub fn new() -> FileOptions {
        ::std::default::Default::default()
    }

    // optional string java_package = 1;

    pub fn java_package(&self) -> &str {
        match self.java_package.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_java_package(&mut self) {
        self.java_package = ::std::option::Option::None;
    }

    pub fn has_java_package(&self) -> bool {
        self.java_package.is_some()
    }

    // Param is passed by value, moved
    pub fn set_java_package(&mut self, v: ::std::string::String) {
        self.java_package = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_java_package(&mut self) -> &mut ::std::string::String {
        if self.java_package.is_none() {
            self.java_package = ::std::option::Option::Some(::std::string::String::new());
        }
        self.java_package.as_mut().unwrap()
    }

    // Take field
    pub fn take_java_package(&mut self) -> ::std::string::String {
        self.java_package.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string java_outer_classname = 8;

    pub fn java_outer_classname(&self) -> &str {
        match self.java_outer_classname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_java_outer_classname(&mut self) {
        self.java_outer_classname = ::std::option::Option::None;
    }

    pub fn has_java_outer_classname(&self) -> bool {
        self.java_outer_classname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_java_outer_classname(&mut self, v: ::std::string::String) {
        self.java_outer_classname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_java_outer_classname(&mut self) -> &mut ::std::string::String {
        if self.java_outer_classname.is_none() {
            self.java_outer_classname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.java_outer_classname.as_mut().unwrap()
    }

    // Take field
    pub fn take_java_outer_classname(&mut self) -> ::std::string::String {
        self.java_outer_classname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool java_multiple_files = 10;

    pub fn java_multiple_files(&self) -> bool {
        self.java_multiple_files.unwrap_or(false)
    }

    pub fn clear_java_multiple_files(&mut self) {
        self.java_multiple_files = ::std::option::Option::None;
    }

    pub fn has_java_multiple_files(&self) -> bool {
        self.java_multiple_files.is_some()
    }

    // Param is passed by value, moved
    pub fn set_java_multiple_files(&mut self, v: bool) {
        self.java_multiple_files = ::std::option::Option::Some(v);
    }

    // optional bool java_generate_equals_and_hash = 20;

    pub fn java_generate_equals_and_hash(&self) -> bool {
        self.java_generate_equals_and_hash.unwrap_or(false)
    }

    pub fn clear_java_generate_equals_and_hash(&mut self) {
        self.java_generate_equals_and_hash = ::std::option::Option::None;
    }

    pub fn has_java_generate_equals_and_hash(&self) -> bool {
        self.java_generate_equals_and_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_java_generate_equals_and_hash(&mut self, v: bool) {
        self.java_generate_equals_and_hash = ::std::option::Option::Some(v);
    }

    // optional bool java_string_check_utf8 = 27;

    pub fn java_string_check_utf8(&self) -> bool {
        self.java_string_check_utf8.unwrap_or(false)
    }

    pub fn clear_java_string_check_utf8(&mut self) {
        self.java_string_check_utf8 = ::std::option::Option::None;
    }

    pub fn has_java_string_check_utf8(&self) -> bool {
        self.java_string_check_utf8.is_some()
    }

    // Param is passed by value, moved
    pub fn set_java_string_check_utf8(&mut self, v: bool) {
        self.java_string_check_utf8 = ::std::option::Option::Some(v);
    }

    // optional .google.protobuf.FileOptions.OptimizeMode optimize_for = 9;

    pub fn optimize_for(&self) -> file_options::OptimizeMode {
        match self.optimize_for {
            Some(e) => e.enum_value_or(file_options::OptimizeMode::SPEED),
            None => file_options::OptimizeMode::SPEED,
        }
    }

    pub fn clear_optimize_for(&mut self) {
        self.optimize_for = ::std::option::Option::None;
    }

    pub fn has_optimize_for(&self) -> bool {
        self.optimize_for.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optimize_for(&mut self, v: file_options::OptimizeMode) {
        self.optimize_for = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string go_package = 11;

    pub fn go_package(&self) -> &str {
        match self.go_package.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_go_package(&mut self) {
        self.go_package = ::std::option::Option::None;
    }

    pub fn has_go_package(&self) -> bool {
        self.go_package.is_some()
    }

    // Param is passed by value, moved
    pub fn set_go_package(&mut self, v: ::std::string::String) {
        self.go_package = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_go_package(&mut self) -> &mut ::std::string::String {
        if self.go_package.is_none() {
            self.go_package = ::std::option::Option::Some(::std::string::String::new());
        }
        self.go_package.as_mut().unwrap()
    }

    // Take field
    pub fn take_go_package(&mut self) -> ::std::string::String {
        self.go_package.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool cc_generic_services = 16;

    pub fn cc_generic_services(&self) -> bool {
        self.cc_generic_services.unwrap_or(false)
    }

    pub fn clear_cc_generic_services(&mut self) {
        self.cc_generic_services = ::std::option::Option::None;
    }

    pub fn has_cc_generic_services(&self) -> bool {
        self.cc_generic_services.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cc_generic_services(&mut self, v: bool) {
        self.cc_generic_services = ::std::option::Option::Some(v);
    }

    // optional bool java_generic_services = 17;

    pub fn java_generic_services(&self) -> bool {
        self.java_generic_services.unwrap_or(false)
    }

    pub fn clear_java_generic_services(&mut self) {
        self.java_generic_services = ::std::option::Option::None;
    }

    pub fn has_java_generic_services(&self) -> bool {
        self.java_generic_services.is_some()
    }

    // Param is passed by value, moved
    pub fn set_java_generic_services(&mut self, v: bool) {
        self.java_generic_services = ::std::option::Option::Some(v);
    }

    // optional bool py_generic_services = 18;

    pub fn py_generic_services(&self) -> bool {
        self.py_generic_services.unwrap_or(false)
    }

    pub fn clear_py_generic_services(&mut self) {
        self.py_generic_services = ::std::option::Option::None;
    }

    pub fn has_py_generic_services(&self) -> bool {
        self.py_generic_services.is_some()
    }

    // Param is passed by value, moved
    pub fn set_py_generic_services(&mut self, v: bool) {
        self.py_generic_services = ::std::option::Option::Some(v);
    }

    // optional bool deprecated = 23;

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }

    pub fn clear_deprecated(&mut self) {
        self.deprecated = ::std::option::Option::None;
    }

    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated(&mut self, v: bool) {
        self.deprecated = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "java_package",
            |m: &FileOptions| { &m.java_package },
            |m: &mut FileOptions| { &mut m.java_package },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "java_outer_classname",
            |m: &FileOptions| { &m.java_outer_classname },
            |m: &mut FileOptions| { &mut m.java_outer_classname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "java_multiple_files",
            |m: &FileOptions| { &m.java_multiple_files },
            |m: &mut FileOptions| { &mut m.java_multiple_files },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "java_generate_equals_and_hash",
            |m: &FileOptions| { &m.java_generate_equals_and_hash },
            |m: &mut FileOptions| { &mut m.java_generate_equals_and_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "java_string_check_utf8",
            |m: &FileOptions| { &m.java_string_check_utf8 },
            |m: &mut FileOptions| { &mut m.java_string_check_utf8 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "optimize_for",
            |m: &FileOptions| { &m.optimize_for },
            |m: &mut FileOptions| { &mut m.optimize_for },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "go_package",
            |m: &FileOptions| { &m.go_package },
            |m: &mut FileOptions| { &mut m.go_package },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cc_generic_services",
            |m: &FileOptions| { &m.cc_generic_services },
            |m: &mut FileOptions| { &mut m.cc_generic_services },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "java_generic_services",
            |m: &FileOptions| { &m.java_generic_services },
            |m: &mut FileOptions| { &mut m.java_generic_services },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "py_generic_services",
            |m: &FileOptions| { &m.py_generic_services },
            |m: &mut FileOptions| { &mut m.py_generic_services },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deprecated",
            |m: &FileOptions| { &m.deprecated },
            |m: &mut FileOptions| { &mut m.deprecated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uninterpreted_option",
            |m: &FileOptions| { &m.uninterpreted_option },
            |m: &mut FileOptions| { &mut m.uninterpreted_option },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileOptions>(
            "FileOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileOptions {
    const NAME: &'static str = "FileOptions";

    fn is_initialized(&self) -> bool {
        for v in &self.uninterpreted_option {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.java_package = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.java_outer_classname = ::std::option::Option::Some(is.read_string()?);
                },
                80 => {
                    self.java_multiple_files = ::std::option::Option::Some(is.read_bool()?);
                },
                160 => {
                    self.java_generate_equals_and_hash = ::std::option::Option::Some(is.read_bool()?);
                },
                216 => {
                    self.java_string_check_utf8 = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.optimize_for = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                90 => {
                    self.go_package = ::std::option::Option::Some(is.read_string()?);
                },
                128 => {
                    self.cc_generic_services = ::std::option::Option::Some(is.read_bool()?);
                },
                136 => {
                    self.java_generic_services = ::std::option::Option::Some(is.read_bool()?);
                },
                144 => {
                    self.py_generic_services = ::std::option::Option::Some(is.read_bool()?);
                },
                184 => {
                    self.deprecated = ::std::option::Option::Some(is.read_bool()?);
                },
                7994 => {
                    self.uninterpreted_option.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.java_package.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.java_outer_classname.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.java_multiple_files {
            my_size += 1 + 1;
        }
        if let Some(v) = self.java_generate_equals_and_hash {
            my_size += 2 + 1;
        }
        if let Some(v) = self.java_string_check_utf8 {
            my_size += 2 + 1;
        }
        if let Some(v) = self.optimize_for {
            my_size += ::protobuf::rt::int32_size(9, v.value());
        }
        if let Some(v) = self.go_package.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.cc_generic_services {
            my_size += 2 + 1;
        }
        if let Some(v) = self.java_generic_services {
            my_size += 2 + 1;
        }
        if let Some(v) = self.py_generic_services {
            my_size += 2 + 1;
        }
        if let Some(v) = self.deprecated {
            my_size += 2 + 1;
        }
        for value in &self.uninterpreted_option {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.java_package.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.java_outer_classname.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.java_multiple_files {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.java_generate_equals_and_hash {
            os.write_bool(20, v)?;
        }
        if let Some(v) = self.java_string_check_utf8 {
            os.write_bool(27, v)?;
        }
        if let Some(v) = self.optimize_for {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.go_package.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.cc_generic_services {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.java_generic_services {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.py_generic_services {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.deprecated {
            os.write_bool(23, v)?;
        }
        for v in &self.uninterpreted_option {
            ::protobuf::rt::write_message_field_with_cached_size(999, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileOptions {
        FileOptions::new()
    }

    fn clear(&mut self) {
        self.java_package = ::std::option::Option::None;
        self.java_outer_classname = ::std::option::Option::None;
        self.java_multiple_files = ::std::option::Option::None;
        self.java_generate_equals_and_hash = ::std::option::Option::None;
        self.java_string_check_utf8 = ::std::option::Option::None;
        self.optimize_for = ::std::option::Option::None;
        self.go_package = ::std::option::Option::None;
        self.cc_generic_services = ::std::option::Option::None;
        self.java_generic_services = ::std::option::Option::None;
        self.py_generic_services = ::std::option::Option::None;
        self.deprecated = ::std::option::Option::None;
        self.uninterpreted_option.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileOptions {
        static instance: FileOptions = FileOptions {
            java_package: ::std::option::Option::None,
            java_outer_classname: ::std::option::Option::None,
            java_multiple_files: ::std::option::Option::None,
            java_generate_equals_and_hash: ::std::option::Option::None,
            java_string_check_utf8: ::std::option::Option::None,
            optimize_for: ::std::option::Option::None,
            go_package: ::std::option::Option::None,
            cc_generic_services: ::std::option::Option::None,
            java_generic_services: ::std::option::Option::None,
            py_generic_services: ::std::option::Option::None,
            deprecated: ::std::option::Option::None,
            uninterpreted_option: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `FileOptions`
pub mod file_options {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:google.protobuf.FileOptions.OptimizeMode)
    pub enum OptimizeMode {
        // @@protoc_insertion_point(enum_value:google.protobuf.FileOptions.OptimizeMode.SPEED)
        SPEED = 1,
        // @@protoc_insertion_point(enum_value:google.protobuf.FileOptions.OptimizeMode.CODE_SIZE)
        CODE_SIZE = 2,
        // @@protoc_insertion_point(enum_value:google.protobuf.FileOptions.OptimizeMode.LITE_RUNTIME)
        LITE_RUNTIME = 3,
    }

    impl ::protobuf::Enum for OptimizeMode {
        const NAME: &'static str = "OptimizeMode";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<OptimizeMode> {
            match value {
                1 => ::std::option::Option::Some(OptimizeMode::SPEED),
                2 => ::std::option::Option::Some(OptimizeMode::CODE_SIZE),
                3 => ::std::option::Option::Some(OptimizeMode::LITE_RUNTIME),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<OptimizeMode> {
            match str {
                "SPEED" => ::std::option::Option::Some(OptimizeMode::SPEED),
                "CODE_SIZE" => ::std::option::Option::Some(OptimizeMode::CODE_SIZE),
                "LITE_RUNTIME" => ::std::option::Option::Some(OptimizeMode::LITE_RUNTIME),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [OptimizeMode] = &[
            OptimizeMode::SPEED,
            OptimizeMode::CODE_SIZE,
            OptimizeMode::LITE_RUNTIME,
        ];
    }

    impl ::protobuf::EnumFull for OptimizeMode {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("FileOptions.OptimizeMode").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                OptimizeMode::SPEED => 0,
                OptimizeMode::CODE_SIZE => 1,
                OptimizeMode::LITE_RUNTIME => 2,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for OptimizeMode {
        fn default() -> Self {
            OptimizeMode::SPEED
        }
    }

    impl OptimizeMode {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<OptimizeMode>("FileOptions.OptimizeMode")
        }
    }
}

// @@protoc_insertion_point(message:google.protobuf.MessageOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MessageOptions {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.MessageOptions.message_set_wire_format)
    pub message_set_wire_format: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.MessageOptions.no_standard_descriptor_accessor)
    pub no_standard_descriptor_accessor: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.MessageOptions.deprecated)
    pub deprecated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.MessageOptions.uninterpreted_option)
    pub uninterpreted_option: ::std::vec::Vec<UninterpretedOption>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.MessageOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MessageOptions {
    fn default() -> &'a MessageOptions {
        <MessageOptions as ::protobuf::Message>::default_instance()
    }
}

impl MessageOptions {
    pub fn new() -> MessageOptions {
        ::std::default::Default::default()
    }

    // optional bool message_set_wire_format = 1;

    pub fn message_set_wire_format(&self) -> bool {
        self.message_set_wire_format.unwrap_or(false)
    }

    pub fn clear_message_set_wire_format(&mut self) {
        self.message_set_wire_format = ::std::option::Option::None;
    }

    pub fn has_message_set_wire_format(&self) -> bool {
        self.message_set_wire_format.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_set_wire_format(&mut self, v: bool) {
        self.message_set_wire_format = ::std::option::Option::Some(v);
    }

    // optional bool no_standard_descriptor_accessor = 2;

    pub fn no_standard_descriptor_accessor(&self) -> bool {
        self.no_standard_descriptor_accessor.unwrap_or(false)
    }

    pub fn clear_no_standard_descriptor_accessor(&mut self) {
        self.no_standard_descriptor_accessor = ::std::option::Option::None;
    }

    pub fn has_no_standard_descriptor_accessor(&self) -> bool {
        self.no_standard_descriptor_accessor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_no_standard_descriptor_accessor(&mut self, v: bool) {
        self.no_standard_descriptor_accessor = ::std::option::Option::Some(v);
    }

    // optional bool deprecated = 3;

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }

    pub fn clear_deprecated(&mut self) {
        self.deprecated = ::std::option::Option::None;
    }

    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated(&mut self, v: bool) {
        self.deprecated = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message_set_wire_format",
            |m: &MessageOptions| { &m.message_set_wire_format },
            |m: &mut MessageOptions| { &mut m.message_set_wire_format },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "no_standard_descriptor_accessor",
            |m: &MessageOptions| { &m.no_standard_descriptor_accessor },
            |m: &mut MessageOptions| { &mut m.no_standard_descriptor_accessor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deprecated",
            |m: &MessageOptions| { &m.deprecated },
            |m: &mut MessageOptions| { &mut m.deprecated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uninterpreted_option",
            |m: &MessageOptions| { &m.uninterpreted_option },
            |m: &mut MessageOptions| { &mut m.uninterpreted_option },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MessageOptions>(
            "MessageOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MessageOptions {
    const NAME: &'static str = "MessageOptions";

    fn is_initialized(&self) -> bool {
        for v in &self.uninterpreted_option {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.message_set_wire_format = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.no_standard_descriptor_accessor = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.deprecated = ::std::option::Option::Some(is.read_bool()?);
                },
                7994 => {
                    self.uninterpreted_option.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message_set_wire_format {
            my_size += 1 + 1;
        }
        if let Some(v) = self.no_standard_descriptor_accessor {
            my_size += 1 + 1;
        }
        if let Some(v) = self.deprecated {
            my_size += 1 + 1;
        }
        for value in &self.uninterpreted_option {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.message_set_wire_format {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.no_standard_descriptor_accessor {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.deprecated {
            os.write_bool(3, v)?;
        }
        for v in &self.uninterpreted_option {
            ::protobuf::rt::write_message_field_with_cached_size(999, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MessageOptions {
        MessageOptions::new()
    }

    fn clear(&mut self) {
        self.message_set_wire_format = ::std::option::Option::None;
        self.no_standard_descriptor_accessor = ::std::option::Option::None;
        self.deprecated = ::std::option::Option::None;
        self.uninterpreted_option.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MessageOptions {
        static instance: MessageOptions = MessageOptions {
            message_set_wire_format: ::std::option::Option::None,
            no_standard_descriptor_accessor: ::std::option::Option::None,
            deprecated: ::std::option::Option::None,
            uninterpreted_option: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MessageOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MessageOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MessageOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:google.protobuf.FieldOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FieldOptions {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.FieldOptions.ctype)
    pub ctype: ::std::option::Option<::protobuf::EnumOrUnknown<field_options::CType>>,
    // @@protoc_insertion_point(field:google.protobuf.FieldOptions.packed)
    pub packed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.FieldOptions.lazy)
    pub lazy: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.FieldOptions.deprecated)
    pub deprecated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.FieldOptions.experimental_map_key)
    pub experimental_map_key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.FieldOptions.weak)
    pub weak: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.FieldOptions.uninterpreted_option)
    pub uninterpreted_option: ::std::vec::Vec<UninterpretedOption>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.FieldOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FieldOptions {
    fn default() -> &'a FieldOptions {
        <FieldOptions as ::protobuf::Message>::default_instance()
    }
}

impl FieldOptions {
    pub fn new() -> FieldOptions {
        ::std::default::Default::default()
    }

    // optional .google.protobuf.FieldOptions.CType ctype = 1;

    pub fn ctype(&self) -> field_options::CType {
        match self.ctype {
            Some(e) => e.enum_value_or(field_options::CType::STRING),
            None => field_options::CType::STRING,
        }
    }

    pub fn clear_ctype(&mut self) {
        self.ctype = ::std::option::Option::None;
    }

    pub fn has_ctype(&self) -> bool {
        self.ctype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctype(&mut self, v: field_options::CType) {
        self.ctype = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool packed = 2;

    pub fn packed(&self) -> bool {
        self.packed.unwrap_or(false)
    }

    pub fn clear_packed(&mut self) {
        self.packed = ::std::option::Option::None;
    }

    pub fn has_packed(&self) -> bool {
        self.packed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packed(&mut self, v: bool) {
        self.packed = ::std::option::Option::Some(v);
    }

    // optional bool lazy = 5;

    pub fn lazy(&self) -> bool {
        self.lazy.unwrap_or(false)
    }

    pub fn clear_lazy(&mut self) {
        self.lazy = ::std::option::Option::None;
    }

    pub fn has_lazy(&self) -> bool {
        self.lazy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lazy(&mut self, v: bool) {
        self.lazy = ::std::option::Option::Some(v);
    }

    // optional bool deprecated = 3;

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }

    pub fn clear_deprecated(&mut self) {
        self.deprecated = ::std::option::Option::None;
    }

    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated(&mut self, v: bool) {
        self.deprecated = ::std::option::Option::Some(v);
    }

    // optional string experimental_map_key = 9;

    pub fn experimental_map_key(&self) -> &str {
        match self.experimental_map_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_experimental_map_key(&mut self) {
        self.experimental_map_key = ::std::option::Option::None;
    }

    pub fn has_experimental_map_key(&self) -> bool {
        self.experimental_map_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_experimental_map_key(&mut self, v: ::std::string::String) {
        self.experimental_map_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_experimental_map_key(&mut self) -> &mut ::std::string::String {
        if self.experimental_map_key.is_none() {
            self.experimental_map_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.experimental_map_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_experimental_map_key(&mut self) -> ::std::string::String {
        self.experimental_map_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool weak = 10;

    pub fn weak(&self) -> bool {
        self.weak.unwrap_or(false)
    }

    pub fn clear_weak(&mut self) {
        self.weak = ::std::option::Option::None;
    }

    pub fn has_weak(&self) -> bool {
        self.weak.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weak(&mut self, v: bool) {
        self.weak = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctype",
            |m: &FieldOptions| { &m.ctype },
            |m: &mut FieldOptions| { &mut m.ctype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "packed",
            |m: &FieldOptions| { &m.packed },
            |m: &mut FieldOptions| { &mut m.packed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lazy",
            |m: &FieldOptions| { &m.lazy },
            |m: &mut FieldOptions| { &mut m.lazy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deprecated",
            |m: &FieldOptions| { &m.deprecated },
            |m: &mut FieldOptions| { &mut m.deprecated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "experimental_map_key",
            |m: &FieldOptions| { &m.experimental_map_key },
            |m: &mut FieldOptions| { &mut m.experimental_map_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "weak",
            |m: &FieldOptions| { &m.weak },
            |m: &mut FieldOptions| { &mut m.weak },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uninterpreted_option",
            |m: &FieldOptions| { &m.uninterpreted_option },
            |m: &mut FieldOptions| { &mut m.uninterpreted_option },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FieldOptions>(
            "FieldOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FieldOptions {
    const NAME: &'static str = "FieldOptions";

    fn is_initialized(&self) -> bool {
        for v in &self.uninterpreted_option {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ctype = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.packed = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.lazy = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.deprecated = ::std::option::Option::Some(is.read_bool()?);
                },
                74 => {
                    self.experimental_map_key = ::std::option::Option::Some(is.read_string()?);
                },
                80 => {
                    self.weak = ::std::option::Option::Some(is.read_bool()?);
                },
                7994 => {
                    self.uninterpreted_option.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ctype {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.packed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.lazy {
            my_size += 1 + 1;
        }
        if let Some(v) = self.deprecated {
            my_size += 1 + 1;
        }
        if let Some(v) = self.experimental_map_key.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.weak {
            my_size += 1 + 1;
        }
        for value in &self.uninterpreted_option {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ctype {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.packed {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.lazy {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.deprecated {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.experimental_map_key.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.weak {
            os.write_bool(10, v)?;
        }
        for v in &self.uninterpreted_option {
            ::protobuf::rt::write_message_field_with_cached_size(999, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FieldOptions {
        FieldOptions::new()
    }

    fn clear(&mut self) {
        self.ctype = ::std::option::Option::None;
        self.packed = ::std::option::Option::None;
        self.lazy = ::std::option::Option::None;
        self.deprecated = ::std::option::Option::None;
        self.experimental_map_key = ::std::option::Option::None;
        self.weak = ::std::option::Option::None;
        self.uninterpreted_option.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FieldOptions {
        static instance: FieldOptions = FieldOptions {
            ctype: ::std::option::Option::None,
            packed: ::std::option::Option::None,
            lazy: ::std::option::Option::None,
            deprecated: ::std::option::Option::None,
            experimental_map_key: ::std::option::Option::None,
            weak: ::std::option::Option::None,
            uninterpreted_option: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FieldOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FieldOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FieldOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FieldOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `FieldOptions`
pub mod field_options {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:google.protobuf.FieldOptions.CType)
    pub enum CType {
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldOptions.CType.STRING)
        STRING = 0,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldOptions.CType.CORD)
        CORD = 1,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldOptions.CType.STRING_PIECE)
        STRING_PIECE = 2,
    }

    impl ::protobuf::Enum for CType {
        const NAME: &'static str = "CType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<CType> {
            match value {
                0 => ::std::option::Option::Some(CType::STRING),
                1 => ::std::option::Option::Some(CType::CORD),
                2 => ::std::option::Option::Some(CType::STRING_PIECE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<CType> {
            match str {
                "STRING" => ::std::option::Option::Some(CType::STRING),
                "CORD" => ::std::option::Option::Some(CType::CORD),
                "STRING_PIECE" => ::std::option::Option::Some(CType::STRING_PIECE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [CType] = &[
            CType::STRING,
            CType::CORD,
            CType::STRING_PIECE,
        ];
    }

    impl ::protobuf::EnumFull for CType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("FieldOptions.CType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for CType {
        fn default() -> Self {
            CType::STRING
        }
    }

    impl CType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CType>("FieldOptions.CType")
        }
    }
}

// @@protoc_insertion_point(message:google.protobuf.EnumOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EnumOptions {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.EnumOptions.allow_alias)
    pub allow_alias: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.EnumOptions.deprecated)
    pub deprecated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.EnumOptions.uninterpreted_option)
    pub uninterpreted_option: ::std::vec::Vec<UninterpretedOption>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.EnumOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EnumOptions {
    fn default() -> &'a EnumOptions {
        <EnumOptions as ::protobuf::Message>::default_instance()
    }
}

impl EnumOptions {
    pub fn new() -> EnumOptions {
        ::std::default::Default::default()
    }

    // optional bool allow_alias = 2;

    pub fn allow_alias(&self) -> bool {
        self.allow_alias.unwrap_or(false)
    }

    pub fn clear_allow_alias(&mut self) {
        self.allow_alias = ::std::option::Option::None;
    }

    pub fn has_allow_alias(&self) -> bool {
        self.allow_alias.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_alias(&mut self, v: bool) {
        self.allow_alias = ::std::option::Option::Some(v);
    }

    // optional bool deprecated = 3;

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }

    pub fn clear_deprecated(&mut self) {
        self.deprecated = ::std::option::Option::None;
    }

    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated(&mut self, v: bool) {
        self.deprecated = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "allow_alias",
            |m: &EnumOptions| { &m.allow_alias },
            |m: &mut EnumOptions| { &mut m.allow_alias },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deprecated",
            |m: &EnumOptions| { &m.deprecated },
            |m: &mut EnumOptions| { &mut m.deprecated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uninterpreted_option",
            |m: &EnumOptions| { &m.uninterpreted_option },
            |m: &mut EnumOptions| { &mut m.uninterpreted_option },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EnumOptions>(
            "EnumOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EnumOptions {
    const NAME: &'static str = "EnumOptions";

    fn is_initialized(&self) -> bool {
        for v in &self.uninterpreted_option {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.allow_alias = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.deprecated = ::std::option::Option::Some(is.read_bool()?);
                },
                7994 => {
                    self.uninterpreted_option.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.allow_alias {
            my_size += 1 + 1;
        }
        if let Some(v) = self.deprecated {
            my_size += 1 + 1;
        }
        for value in &self.uninterpreted_option {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.allow_alias {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.deprecated {
            os.write_bool(3, v)?;
        }
        for v in &self.uninterpreted_option {
            ::protobuf::rt::write_message_field_with_cached_size(999, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EnumOptions {
        EnumOptions::new()
    }

    fn clear(&mut self) {
        self.allow_alias = ::std::option::Option::None;
        self.deprecated = ::std::option::Option::None;
        self.uninterpreted_option.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EnumOptions {
        static instance: EnumOptions = EnumOptions {
            allow_alias: ::std::option::Option::None,
            deprecated: ::std::option::Option::None,
            uninterpreted_option: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EnumOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EnumOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EnumOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnumOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:google.protobuf.EnumValueOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EnumValueOptions {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.EnumValueOptions.deprecated)
    pub deprecated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.EnumValueOptions.uninterpreted_option)
    pub uninterpreted_option: ::std::vec::Vec<UninterpretedOption>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.EnumValueOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EnumValueOptions {
    fn default() -> &'a EnumValueOptions {
        <EnumValueOptions as ::protobuf::Message>::default_instance()
    }
}

impl EnumValueOptions {
    pub fn new() -> EnumValueOptions {
        ::std::default::Default::default()
    }

    // optional bool deprecated = 1;

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }

    pub fn clear_deprecated(&mut self) {
        self.deprecated = ::std::option::Option::None;
    }

    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated(&mut self, v: bool) {
        self.deprecated = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deprecated",
            |m: &EnumValueOptions| { &m.deprecated },
            |m: &mut EnumValueOptions| { &mut m.deprecated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uninterpreted_option",
            |m: &EnumValueOptions| { &m.uninterpreted_option },
            |m: &mut EnumValueOptions| { &mut m.uninterpreted_option },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EnumValueOptions>(
            "EnumValueOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EnumValueOptions {
    const NAME: &'static str = "EnumValueOptions";

    fn is_initialized(&self) -> bool {
        for v in &self.uninterpreted_option {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.deprecated = ::std::option::Option::Some(is.read_bool()?);
                },
                7994 => {
                    self.uninterpreted_option.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.deprecated {
            my_size += 1 + 1;
        }
        for value in &self.uninterpreted_option {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.deprecated {
            os.write_bool(1, v)?;
        }
        for v in &self.uninterpreted_option {
            ::protobuf::rt::write_message_field_with_cached_size(999, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EnumValueOptions {
        EnumValueOptions::new()
    }

    fn clear(&mut self) {
        self.deprecated = ::std::option::Option::None;
        self.uninterpreted_option.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EnumValueOptions {
        static instance: EnumValueOptions = EnumValueOptions {
            deprecated: ::std::option::Option::None,
            uninterpreted_option: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EnumValueOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EnumValueOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EnumValueOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnumValueOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:google.protobuf.ServiceOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServiceOptions {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.ServiceOptions.deprecated)
    pub deprecated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.ServiceOptions.uninterpreted_option)
    pub uninterpreted_option: ::std::vec::Vec<UninterpretedOption>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.ServiceOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServiceOptions {
    fn default() -> &'a ServiceOptions {
        <ServiceOptions as ::protobuf::Message>::default_instance()
    }
}

impl ServiceOptions {
    pub fn new() -> ServiceOptions {
        ::std::default::Default::default()
    }

    // optional bool deprecated = 33;

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }

    pub fn clear_deprecated(&mut self) {
        self.deprecated = ::std::option::Option::None;
    }

    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated(&mut self, v: bool) {
        self.deprecated = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deprecated",
            |m: &ServiceOptions| { &m.deprecated },
            |m: &mut ServiceOptions| { &mut m.deprecated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uninterpreted_option",
            |m: &ServiceOptions| { &m.uninterpreted_option },
            |m: &mut ServiceOptions| { &mut m.uninterpreted_option },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServiceOptions>(
            "ServiceOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServiceOptions {
    const NAME: &'static str = "ServiceOptions";

    fn is_initialized(&self) -> bool {
        for v in &self.uninterpreted_option {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                264 => {
                    self.deprecated = ::std::option::Option::Some(is.read_bool()?);
                },
                7994 => {
                    self.uninterpreted_option.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.deprecated {
            my_size += 2 + 1;
        }
        for value in &self.uninterpreted_option {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.deprecated {
            os.write_bool(33, v)?;
        }
        for v in &self.uninterpreted_option {
            ::protobuf::rt::write_message_field_with_cached_size(999, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServiceOptions {
        ServiceOptions::new()
    }

    fn clear(&mut self) {
        self.deprecated = ::std::option::Option::None;
        self.uninterpreted_option.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServiceOptions {
        static instance: ServiceOptions = ServiceOptions {
            deprecated: ::std::option::Option::None,
            uninterpreted_option: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServiceOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServiceOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServiceOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:google.protobuf.MethodOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MethodOptions {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.MethodOptions.deprecated)
    pub deprecated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.MethodOptions.uninterpreted_option)
    pub uninterpreted_option: ::std::vec::Vec<UninterpretedOption>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.MethodOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MethodOptions {
    fn default() -> &'a MethodOptions {
        <MethodOptions as ::protobuf::Message>::default_instance()
    }
}

impl MethodOptions {
    pub fn new() -> MethodOptions {
        ::std::default::Default::default()
    }

    // optional bool deprecated = 33;

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }

    pub fn clear_deprecated(&mut self) {
        self.deprecated = ::std::option::Option::None;
    }

    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated(&mut self, v: bool) {
        self.deprecated = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deprecated",
            |m: &MethodOptions| { &m.deprecated },
            |m: &mut MethodOptions| { &mut m.deprecated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uninterpreted_option",
            |m: &MethodOptions| { &m.uninterpreted_option },
            |m: &mut MethodOptions| { &mut m.uninterpreted_option },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MethodOptions>(
            "MethodOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MethodOptions {
    const NAME: &'static str = "MethodOptions";

    fn is_initialized(&self) -> bool {
        for v in &self.uninterpreted_option {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                264 => {
                    self.deprecated = ::std::option::Option::Some(is.read_bool()?);
                },
                7994 => {
                    self.uninterpreted_option.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.deprecated {
            my_size += 2 + 1;
        }
        for value in &self.uninterpreted_option {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.deprecated {
            os.write_bool(33, v)?;
        }
        for v in &self.uninterpreted_option {
            ::protobuf::rt::write_message_field_with_cached_size(999, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MethodOptions {
        MethodOptions::new()
    }

    fn clear(&mut self) {
        self.deprecated = ::std::option::Option::None;
        self.uninterpreted_option.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MethodOptions {
        static instance: MethodOptions = MethodOptions {
            deprecated: ::std::option::Option::None,
            uninterpreted_option: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MethodOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MethodOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MethodOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MethodOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:google.protobuf.UninterpretedOption)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UninterpretedOption {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.UninterpretedOption.name)
    pub name: ::std::vec::Vec<uninterpreted_option::NamePart>,
    // @@protoc_insertion_point(field:google.protobuf.UninterpretedOption.identifier_value)
    pub identifier_value: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.UninterpretedOption.positive_int_value)
    pub positive_int_value: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:google.protobuf.UninterpretedOption.negative_int_value)
    pub negative_int_value: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:google.protobuf.UninterpretedOption.double_value)
    pub double_value: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:google.protobuf.UninterpretedOption.string_value)
    pub string_value: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:google.protobuf.UninterpretedOption.aggregate_value)
    pub aggregate_value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.UninterpretedOption.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UninterpretedOption {
    fn default() -> &'a UninterpretedOption {
        <UninterpretedOption as ::protobuf::Message>::default_instance()
    }
}

impl UninterpretedOption {
    pub fn new() -> UninterpretedOption {
        ::std::default::Default::default()
    }

    // optional string identifier_value = 3;

    pub fn identifier_value(&self) -> &str {
        match self.identifier_value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_identifier_value(&mut self) {
        self.identifier_value = ::std::option::Option::None;
    }

    pub fn has_identifier_value(&self) -> bool {
        self.identifier_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identifier_value(&mut self, v: ::std::string::String) {
        self.identifier_value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identifier_value(&mut self) -> &mut ::std::string::String {
        if self.identifier_value.is_none() {
            self.identifier_value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.identifier_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_identifier_value(&mut self) -> ::std::string::String {
        self.identifier_value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 positive_int_value = 4;

    pub fn positive_int_value(&self) -> u64 {
        self.positive_int_value.unwrap_or(0)
    }

    pub fn clear_positive_int_value(&mut self) {
        self.positive_int_value = ::std::option::Option::None;
    }

    pub fn has_positive_int_value(&self) -> bool {
        self.positive_int_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_positive_int_value(&mut self, v: u64) {
        self.positive_int_value = ::std::option::Option::Some(v);
    }

    // optional int64 negative_int_value = 5;

    pub fn negative_int_value(&self) -> i64 {
        self.negative_int_value.unwrap_or(0)
    }

    pub fn clear_negative_int_value(&mut self) {
        self.negative_int_value = ::std::option::Option::None;
    }

    pub fn has_negative_int_value(&self) -> bool {
        self.negative_int_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_negative_int_value(&mut self, v: i64) {
        self.negative_int_value = ::std::option::Option::Some(v);
    }

    // optional double double_value = 6;

    pub fn double_value(&self) -> f64 {
        self.double_value.unwrap_or(0.)
    }

    pub fn clear_double_value(&mut self) {
        self.double_value = ::std::option::Option::None;
    }

    pub fn has_double_value(&self) -> bool {
        self.double_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_double_value(&mut self, v: f64) {
        self.double_value = ::std::option::Option::Some(v);
    }

    // optional bytes string_value = 7;

    pub fn string_value(&self) -> &[u8] {
        match self.string_value.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_string_value(&mut self) {
        self.string_value = ::std::option::Option::None;
    }

    pub fn has_string_value(&self) -> bool {
        self.string_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.string_value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.string_value.is_none() {
            self.string_value = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.string_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_value(&mut self) -> ::std::vec::Vec<u8> {
        self.string_value.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string aggregate_value = 8;

    pub fn aggregate_value(&self) -> &str {
        match self.aggregate_value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_aggregate_value(&mut self) {
        self.aggregate_value = ::std::option::Option::None;
    }

    pub fn has_aggregate_value(&self) -> bool {
        self.aggregate_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_aggregate_value(&mut self, v: ::std::string::String) {
        self.aggregate_value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_aggregate_value(&mut self) -> &mut ::std::string::String {
        if self.aggregate_value.is_none() {
            self.aggregate_value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.aggregate_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_aggregate_value(&mut self) -> ::std::string::String {
        self.aggregate_value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "name",
            |m: &UninterpretedOption| { &m.name },
            |m: &mut UninterpretedOption| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "identifier_value",
            |m: &UninterpretedOption| { &m.identifier_value },
            |m: &mut UninterpretedOption| { &mut m.identifier_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "positive_int_value",
            |m: &UninterpretedOption| { &m.positive_int_value },
            |m: &mut UninterpretedOption| { &mut m.positive_int_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "negative_int_value",
            |m: &UninterpretedOption| { &m.negative_int_value },
            |m: &mut UninterpretedOption| { &mut m.negative_int_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "double_value",
            |m: &UninterpretedOption| { &m.double_value },
            |m: &mut UninterpretedOption| { &mut m.double_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "string_value",
            |m: &UninterpretedOption| { &m.string_value },
            |m: &mut UninterpretedOption| { &mut m.string_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "aggregate_value",
            |m: &UninterpretedOption| { &m.aggregate_value },
            |m: &mut UninterpretedOption| { &mut m.aggregate_value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UninterpretedOption>(
            "UninterpretedOption",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UninterpretedOption {
    const NAME: &'static str = "UninterpretedOption";

    fn is_initialized(&self) -> bool {
        for v in &self.name {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.name.push(is.read_message()?);
                },
                26 => {
                    self.identifier_value = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.positive_int_value = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.negative_int_value = ::std::option::Option::Some(is.read_int64()?);
                },
                49 => {
                    self.double_value = ::std::option::Option::Some(is.read_double()?);
                },
                58 => {
                    self.string_value = ::std::option::Option::Some(is.read_bytes()?);
                },
                66 => {
                    self.aggregate_value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.name {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.identifier_value.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.positive_int_value {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.negative_int_value {
            my_size += ::protobuf::rt::int64_size(5, v);
        }
        if let Some(v) = self.double_value {
            my_size += 1 + 8;
        }
        if let Some(v) = self.string_value.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.aggregate_value.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.name {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.identifier_value.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.positive_int_value {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.negative_int_value {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.double_value {
            os.write_double(6, v)?;
        }
        if let Some(v) = self.string_value.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.aggregate_value.as_ref() {
            os.write_string(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UninterpretedOption {
        UninterpretedOption::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.identifier_value = ::std::option::Option::None;
        self.positive_int_value = ::std::option::Option::None;
        self.negative_int_value = ::std::option::Option::None;
        self.double_value = ::std::option::Option::None;
        self.string_value = ::std::option::Option::None;
        self.aggregate_value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UninterpretedOption {
        static instance: UninterpretedOption = UninterpretedOption {
            name: ::std::vec::Vec::new(),
            identifier_value: ::std::option::Option::None,
            positive_int_value: ::std::option::Option::None,
            negative_int_value: ::std::option::Option::None,
            double_value: ::std::option::Option::None,
            string_value: ::std::option::Option::None,
            aggregate_value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UninterpretedOption {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UninterpretedOption").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UninterpretedOption {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UninterpretedOption {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `UninterpretedOption`
pub mod uninterpreted_option {
    // @@protoc_insertion_point(message:google.protobuf.UninterpretedOption.NamePart)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct NamePart {
        // message fields
        // @@protoc_insertion_point(field:google.protobuf.UninterpretedOption.NamePart.name_part)
        pub name_part: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:google.protobuf.UninterpretedOption.NamePart.is_extension)
        pub is_extension: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:google.protobuf.UninterpretedOption.NamePart.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a NamePart {
        fn default() -> &'a NamePart {
            <NamePart as ::protobuf::Message>::default_instance()
        }
    }

    impl NamePart {
        pub fn new() -> NamePart {
            ::std::default::Default::default()
        }

        // required string name_part = 1;

        pub fn name_part(&self) -> &str {
            match self.name_part.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name_part(&mut self) {
            self.name_part = ::std::option::Option::None;
        }

        pub fn has_name_part(&self) -> bool {
            self.name_part.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name_part(&mut self, v: ::std::string::String) {
            self.name_part = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name_part(&mut self) -> &mut ::std::string::String {
            if self.name_part.is_none() {
                self.name_part = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name_part.as_mut().unwrap()
        }

        // Take field
        pub fn take_name_part(&mut self) -> ::std::string::String {
            self.name_part.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // required bool is_extension = 2;

        pub fn is_extension(&self) -> bool {
            self.is_extension.unwrap_or(false)
        }

        pub fn clear_is_extension(&mut self) {
            self.is_extension = ::std::option::Option::None;
        }

        pub fn has_is_extension(&self) -> bool {
            self.is_extension.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_extension(&mut self, v: bool) {
            self.is_extension = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name_part",
                |m: &NamePart| { &m.name_part },
                |m: &mut NamePart| { &mut m.name_part },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_extension",
                |m: &NamePart| { &m.is_extension },
                |m: &mut NamePart| { &mut m.is_extension },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NamePart>(
                "UninterpretedOption.NamePart",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for NamePart {
        const NAME: &'static str = "NamePart";

        fn is_initialized(&self) -> bool {
            if self.name_part.is_none() {
                return false;
            }
            if self.is_extension.is_none() {
                return false;
            }
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name_part = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.is_extension = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name_part.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.is_extension {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.name_part.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.is_extension {
                os.write_bool(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> NamePart {
            NamePart::new()
        }

        fn clear(&mut self) {
            self.name_part = ::std::option::Option::None;
            self.is_extension = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static NamePart {
            static instance: NamePart = NamePart {
                name_part: ::std::option::Option::None,
                is_extension: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for NamePart {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("UninterpretedOption.NamePart").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for NamePart {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for NamePart {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:google.protobuf.SourceCodeInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SourceCodeInfo {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.SourceCodeInfo.location)
    pub location: ::std::vec::Vec<source_code_info::Location>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.SourceCodeInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SourceCodeInfo {
    fn default() -> &'a SourceCodeInfo {
        <SourceCodeInfo as ::protobuf::Message>::default_instance()
    }
}

impl SourceCodeInfo {
    pub fn new() -> SourceCodeInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "location",
            |m: &SourceCodeInfo| { &m.location },
            |m: &mut SourceCodeInfo| { &mut m.location },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SourceCodeInfo>(
            "SourceCodeInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SourceCodeInfo {
    const NAME: &'static str = "SourceCodeInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.location.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.location {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.location {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SourceCodeInfo {
        SourceCodeInfo::new()
    }

    fn clear(&mut self) {
        self.location.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SourceCodeInfo {
        static instance: SourceCodeInfo = SourceCodeInfo {
            location: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SourceCodeInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SourceCodeInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SourceCodeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SourceCodeInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SourceCodeInfo`
pub mod source_code_info {
    // @@protoc_insertion_point(message:google.protobuf.SourceCodeInfo.Location)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Location {
        // message fields
        // @@protoc_insertion_point(field:google.protobuf.SourceCodeInfo.Location.path)
        pub path: ::std::vec::Vec<i32>,
        // @@protoc_insertion_point(field:google.protobuf.SourceCodeInfo.Location.span)
        pub span: ::std::vec::Vec<i32>,
        // @@protoc_insertion_point(field:google.protobuf.SourceCodeInfo.Location.leading_comments)
        pub leading_comments: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:google.protobuf.SourceCodeInfo.Location.trailing_comments)
        pub trailing_comments: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:google.protobuf.SourceCodeInfo.Location.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Location {
        fn default() -> &'a Location {
            <Location as ::protobuf::Message>::default_instance()
        }
    }

    impl Location {
        pub fn new() -> Location {
            ::std::default::Default::default()
        }

        // optional string leading_comments = 3;

        pub fn leading_comments(&self) -> &str {
            match self.leading_comments.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_leading_comments(&mut self) {
            self.leading_comments = ::std::option::Option::None;
        }

        pub fn has_leading_comments(&self) -> bool {
            self.leading_comments.is_some()
        }

        // Param is passed by value, moved
        pub fn set_leading_comments(&mut self, v: ::std::string::String) {
            self.leading_comments = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_leading_comments(&mut self) -> &mut ::std::string::String {
            if self.leading_comments.is_none() {
                self.leading_comments = ::std::option::Option::Some(::std::string::String::new());
            }
            self.leading_comments.as_mut().unwrap()
        }

        // Take field
        pub fn take_leading_comments(&mut self) -> ::std::string::String {
            self.leading_comments.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string trailing_comments = 4;

        pub fn trailing_comments(&self) -> &str {
            match self.trailing_comments.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_trailing_comments(&mut self) {
            self.trailing_comments = ::std::option::Option::None;
        }

        pub fn has_trailing_comments(&self) -> bool {
            self.trailing_comments.is_some()
        }

        // Param is passed by value, moved
        pub fn set_trailing_comments(&mut self, v: ::std::string::String) {
            self.trailing_comments = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_trailing_comments(&mut self) -> &mut ::std::string::String {
            if self.trailing_comments.is_none() {
                self.trailing_comments = ::std::option::Option::Some(::std::string::String::new());
            }
            self.trailing_comments.as_mut().unwrap()
        }

        // Take field
        pub fn take_trailing_comments(&mut self) -> ::std::string::String {
            self.trailing_comments.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "path",
                |m: &Location| { &m.path },
                |m: &mut Location| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "span",
                |m: &Location| { &m.span },
                |m: &mut Location| { &mut m.span },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "leading_comments",
                |m: &Location| { &m.leading_comments },
                |m: &mut Location| { &mut m.leading_comments },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "trailing_comments",
                |m: &Location| { &m.trailing_comments },
                |m: &mut Location| { &mut m.trailing_comments },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Location>(
                "SourceCodeInfo.Location",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Location {
        const NAME: &'static str = "Location";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        is.read_repeated_packed_int32_into(&mut self.path)?;
                    },
                    8 => {
                        self.path.push(is.read_int32()?);
                    },
                    18 => {
                        is.read_repeated_packed_int32_into(&mut self.span)?;
                    },
                    16 => {
                        self.span.push(is.read_int32()?);
                    },
                    26 => {
                        self.leading_comments = ::std::option::Option::Some(is.read_string()?);
                    },
                    34 => {
                        self.trailing_comments = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::vec_packed_int32_size(1, &self.path);
            my_size += ::protobuf::rt::vec_packed_int32_size(2, &self.span);
            if let Some(v) = self.leading_comments.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.trailing_comments.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_repeated_packed_int32(1, &self.path)?;
            os.write_repeated_packed_int32(2, &self.span)?;
            if let Some(v) = self.leading_comments.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.trailing_comments.as_ref() {
                os.write_string(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Location {
            Location::new()
        }

        fn clear(&mut self) {
            self.path.clear();
            self.span.clear();
            self.leading_comments = ::std::option::Option::None;
            self.trailing_comments = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Location {
            static instance: Location = Location {
                path: ::std::vec::Vec::new(),
                span: ::std::vec::Vec::new(),
                leading_comments: ::std::option::Option::None,
                trailing_comments: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Location {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("SourceCodeInfo.Location").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Location {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Location {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x20google/protobuf/descriptor.proto\x12\x0fgoogle.protobuf\"M\n\x11Fi\
    leDescriptorSet\x128\n\x04file\x18\x01\x20\x03(\x0b2$.google.protobuf.Fi\
    leDescriptorProtoR\x04file\"\xcc\x04\n\x13FileDescriptorProto\x12\x12\n\
    \x04name\x18\x01\x20\x01(\tR\x04name\x12\x18\n\x07package\x18\x02\x20\
    \x01(\tR\x07package\x12\x1e\n\ndependency\x18\x03\x20\x03(\tR\ndependenc\
    y\x12+\n\x11public_dependency\x18\n\x20\x03(\x05R\x10publicDependency\
    \x12'\n\x0fweak_dependency\x18\x0b\x20\x03(\x05R\x0eweakDependency\x12C\
    \n\x0cmessage_type\x18\x04\x20\x03(\x0b2\x20.google.protobuf.DescriptorP\
    rotoR\x0bmessageType\x12A\n\tenum_type\x18\x05\x20\x03(\x0b2$.google.pro\
    tobuf.EnumDescriptorProtoR\x08enumType\x12A\n\x07service\x18\x06\x20\x03\
    (\x0b2'.google.protobuf.ServiceDescriptorProtoR\x07service\x12C\n\texten\
    sion\x18\x07\x20\x03(\x0b2%.google.protobuf.FieldDescriptorProtoR\texten\
    sion\x126\n\x07options\x18\x08\x20\x01(\x0b2\x1c.google.protobuf.FileOpt\
    ionsR\x07options\x12I\n\x10source_code_info\x18\t\x20\x01(\x0b2\x1f.goog\
    le.protobuf.SourceCodeInfoR\x0esourceCodeInfo\"\xc2\x04\n\x0fDescriptorP\
    roto\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12;\n\x05field\x18\
    \x02\x20\x03(\x0b2%.google.protobuf.FieldDescriptorProtoR\x05field\x12C\
    \n\textension\x18\x06\x20\x03(\x0b2%.google.protobuf.FieldDescriptorProt\
    oR\textension\x12A\n\x0bnested_type\x18\x03\x20\x03(\x0b2\x20.google.pro\
    tobuf.DescriptorProtoR\nnestedType\x12A\n\tenum_type\x18\x04\x20\x03(\
    \x0b2$.google.protobuf.EnumDescriptorProtoR\x08enumType\x12X\n\x0fextens\
    ion_range\x18\x05\x20\x03(\x0b2/.google.protobuf.DescriptorProto.Extensi\
    onRangeR\x0eextensionRange\x12D\n\noneof_decl\x18\x08\x20\x03(\x0b2%.goo\
    gle.protobuf.OneofDescriptorProtoR\toneofDecl\x129\n\x07options\x18\x07\
    \x20\x01(\x0b2\x1f.google.protobuf.MessageOptionsR\x07options\x1a8\n\x0e\
    ExtensionRange\x12\x14\n\x05start\x18\x01\x20\x01(\x05R\x05start\x12\x10\
    \n\x03end\x18\x02\x20\x01(\x05R\x03end\"\x98\x06\n\x14FieldDescriptorPro\
    to\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x16\n\x06number\x18\
    \x03\x20\x01(\x05R\x06number\x12Q\n\x05label\x18\x04\x20\x01(\x0e2+.goog\
    le.protobuf.FieldDescriptorProto.Label:\x0eLABEL_OPTIONALR\x05label\x12K\
    \n\x04type\x18\x05\x20\x01(\x0e2*.google.protobuf.FieldDescriptorProto.T\
    ype:\x0bTYPE_DOUBLER\x04type\x12\x1b\n\ttype_name\x18\x06\x20\x01(\tR\
    \x08typeName\x12\x1a\n\x08extendee\x18\x02\x20\x01(\tR\x08extendee\x12#\
    \n\rdefault_value\x18\x07\x20\x01(\tR\x0cdefaultValue\x12\x1f\n\x0boneof\
    _index\x18\t\x20\x01(\x05R\noneofIndex\x127\n\x07options\x18\x08\x20\x01\
    (\x0b2\x1d.google.protobuf.FieldOptionsR\x07options\"\xb6\x02\n\x04Type\
    \x12\x0f\n\x0bTYPE_DOUBLE\x10\x01\x12\x0e\n\nTYPE_FLOAT\x10\x02\x12\x0e\
    \n\nTYPE_INT64\x10\x03\x12\x0f\n\x0bTYPE_UINT64\x10\x04\x12\x0e\n\nTYPE_\
    INT32\x10\x05\x12\x10\n\x0cTYPE_FIXED64\x10\x06\x12\x10\n\x0cTYPE_FIXED3\
    2\x10\x07\x12\r\n\tTYPE_BOOL\x10\x08\x12\x0f\n\x0bTYPE_STRING\x10\t\x12\
    \x0e\n\nTYPE_GROUP\x10\n\x12\x10\n\x0cTYPE_MESSAGE\x10\x0b\x12\x0e\n\nTY\
    PE_BYTES\x10\x0c\x12\x0f\n\x0bTYPE_UINT32\x10\r\x12\r\n\tTYPE_ENUM\x10\
    \x0e\x12\x11\n\rTYPE_SFIXED32\x10\x0f\x12\x11\n\rTYPE_SFIXED64\x10\x10\
    \x12\x0f\n\x0bTYPE_SINT32\x10\x11\x12\x0f\n\x0bTYPE_SINT64\x10\x12\"C\n\
    \x05Label\x12\x12\n\x0eLABEL_OPTIONAL\x10\x01\x12\x12\n\x0eLABEL_REQUIRE\
    D\x10\x02\x12\x12\n\x0eLABEL_REPEATED\x10\x03\"*\n\x14OneofDescriptorPro\
    to\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\"\xa2\x01\n\x13EnumDesc\
    riptorProto\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12?\n\x05valu\
    e\x18\x02\x20\x03(\x0b2).google.protobuf.EnumValueDescriptorProtoR\x05va\
    lue\x126\n\x07options\x18\x03\x20\x01(\x0b2\x1c.google.protobuf.EnumOpti\
    onsR\x07options\"\x83\x01\n\x18EnumValueDescriptorProto\x12\x12\n\x04nam\
    e\x18\x01\x20\x01(\tR\x04name\x12\x16\n\x06number\x18\x02\x20\x01(\x05R\
    \x06number\x12;\n\x07options\x18\x03\x20\x01(\x0b2!.google.protobuf.Enum\
    ValueOptionsR\x07options\"\xa7\x01\n\x16ServiceDescriptorProto\x12\x12\n\
    \x04name\x18\x01\x20\x01(\tR\x04name\x12>\n\x06method\x18\x02\x20\x03(\
    \x0b2&.google.protobuf.MethodDescriptorProtoR\x06method\x129\n\x07option\
    s\x18\x03\x20\x01(\x0b2\x1f.google.protobuf.ServiceOptionsR\x07options\"\
    \xa5\x01\n\x15MethodDescriptorProto\x12\x12\n\x04name\x18\x01\x20\x01(\t\
    R\x04name\x12\x1d\n\ninput_type\x18\x02\x20\x01(\tR\tinputType\x12\x1f\n\
    \x0boutput_type\x18\x03\x20\x01(\tR\noutputType\x128\n\x07options\x18\
    \x04\x20\x01(\x0b2\x1e.google.protobuf.MethodOptionsR\x07options\"\x83\
    \x06\n\x0bFileOptions\x12!\n\x0cjava_package\x18\x01\x20\x01(\tR\x0bjava\
    Package\x120\n\x14java_outer_classname\x18\x08\x20\x01(\tR\x12javaOuterC\
    lassname\x125\n\x13java_multiple_files\x18\n\x20\x01(\x08:\x05falseR\x11\
    javaMultipleFiles\x12G\n\x1djava_generate_equals_and_hash\x18\x14\x20\
    \x01(\x08:\x05falseR\x19javaGenerateEqualsAndHash\x12:\n\x16java_string_\
    check_utf8\x18\x1b\x20\x01(\x08:\x05falseR\x13javaStringCheckUtf8\x12S\n\
    \x0coptimize_for\x18\t\x20\x01(\x0e2).google.protobuf.FileOptions.Optimi\
    zeMode:\x05SPEEDR\x0boptimizeFor\x12\x1d\n\ngo_package\x18\x0b\x20\x01(\
    \tR\tgoPackage\x125\n\x13cc_generic_services\x18\x10\x20\x01(\x08:\x05fa\
    lseR\x11ccGenericServices\x129\n\x15java_generic_services\x18\x11\x20\
    \x01(\x08:\x05falseR\x13javaGenericServices\x125\n\x13py_generic_service\
    s\x18\x12\x20\x01(\x08:\x05falseR\x11pyGenericServices\x12%\n\ndeprecate\
    d\x18\x17\x20\x01(\x08:\x05falseR\ndeprecated\x12X\n\x14uninterpreted_op\
    tion\x18\xe7\x07\x20\x03(\x0b2$.google.protobuf.UninterpretedOptionR\x13\
    uninterpretedOption\":\n\x0cOptimizeMode\x12\t\n\x05SPEED\x10\x01\x12\r\
    \n\tCODE_SIZE\x10\x02\x12\x10\n\x0cLITE_RUNTIME\x10\x03*\t\x08\xe8\x07\
    \x10\x80\x80\x80\x80\x02\"\xa8\x02\n\x0eMessageOptions\x12<\n\x17message\
    _set_wire_format\x18\x01\x20\x01(\x08:\x05falseR\x14messageSetWireFormat\
    \x12L\n\x1fno_standard_descriptor_accessor\x18\x02\x20\x01(\x08:\x05fals\
    eR\x1cnoStandardDescriptorAccessor\x12%\n\ndeprecated\x18\x03\x20\x01(\
    \x08:\x05falseR\ndeprecated\x12X\n\x14uninterpreted_option\x18\xe7\x07\
    \x20\x03(\x0b2$.google.protobuf.UninterpretedOptionR\x13uninterpretedOpt\
    ion*\t\x08\xe8\x07\x10\x80\x80\x80\x80\x02\"\x8e\x03\n\x0cFieldOptions\
    \x12A\n\x05ctype\x18\x01\x20\x01(\x0e2#.google.protobuf.FieldOptions.CTy\
    pe:\x06STRINGR\x05ctype\x12\x16\n\x06packed\x18\x02\x20\x01(\x08R\x06pac\
    ked\x12\x19\n\x04lazy\x18\x05\x20\x01(\x08:\x05falseR\x04lazy\x12%\n\nde\
    precated\x18\x03\x20\x01(\x08:\x05falseR\ndeprecated\x120\n\x14experimen\
    tal_map_key\x18\t\x20\x01(\tR\x12experimentalMapKey\x12\x19\n\x04weak\
    \x18\n\x20\x01(\x08:\x05falseR\x04weak\x12X\n\x14uninterpreted_option\
    \x18\xe7\x07\x20\x03(\x0b2$.google.protobuf.UninterpretedOptionR\x13unin\
    terpretedOption\"/\n\x05CType\x12\n\n\x06STRING\x10\0\x12\x08\n\x04CORD\
    \x10\x01\x12\x10\n\x0cSTRING_PIECE\x10\x02*\t\x08\xe8\x07\x10\x80\x80\
    \x80\x80\x02\"\xba\x01\n\x0bEnumOptions\x12\x1f\n\x0ballow_alias\x18\x02\
    \x20\x01(\x08R\nallowAlias\x12%\n\ndeprecated\x18\x03\x20\x01(\x08:\x05f\
    alseR\ndeprecated\x12X\n\x14uninterpreted_option\x18\xe7\x07\x20\x03(\
    \x0b2$.google.protobuf.UninterpretedOptionR\x13uninterpretedOption*\t\
    \x08\xe8\x07\x10\x80\x80\x80\x80\x02\"\x9e\x01\n\x10EnumValueOptions\x12\
    %\n\ndeprecated\x18\x01\x20\x01(\x08:\x05falseR\ndeprecated\x12X\n\x14un\
    interpreted_option\x18\xe7\x07\x20\x03(\x0b2$.google.protobuf.Uninterpre\
    tedOptionR\x13uninterpretedOption*\t\x08\xe8\x07\x10\x80\x80\x80\x80\x02\
    \"\x9c\x01\n\x0eServiceOptions\x12%\n\ndeprecated\x18!\x20\x01(\x08:\x05\
    falseR\ndeprecated\x12X\n\x14uninterpreted_option\x18\xe7\x07\x20\x03(\
    \x0b2$.google.protobuf.UninterpretedOptionR\x13uninterpretedOption*\t\
    \x08\xe8\x07\x10\x80\x80\x80\x80\x02\"\x9b\x01\n\rMethodOptions\x12%\n\n\
    deprecated\x18!\x20\x01(\x08:\x05falseR\ndeprecated\x12X\n\x14uninterpre\
    ted_option\x18\xe7\x07\x20\x03(\x0b2$.google.protobuf.UninterpretedOptio\
    nR\x13uninterpretedOption*\t\x08\xe8\x07\x10\x80\x80\x80\x80\x02\"\x9a\
    \x03\n\x13UninterpretedOption\x12A\n\x04name\x18\x02\x20\x03(\x0b2-.goog\
    le.protobuf.UninterpretedOption.NamePartR\x04name\x12)\n\x10identifier_v\
    alue\x18\x03\x20\x01(\tR\x0fidentifierValue\x12,\n\x12positive_int_value\
    \x18\x04\x20\x01(\x04R\x10positiveIntValue\x12,\n\x12negative_int_value\
    \x18\x05\x20\x01(\x03R\x10negativeIntValue\x12!\n\x0cdouble_value\x18\
    \x06\x20\x01(\x01R\x0bdoubleValue\x12!\n\x0cstring_value\x18\x07\x20\x01\
    (\x0cR\x0bstringValue\x12'\n\x0faggregate_value\x18\x08\x20\x01(\tR\x0ea\
    ggregateValue\x1aJ\n\x08NamePart\x12\x1b\n\tname_part\x18\x01\x20\x02(\t\
    R\x08namePart\x12!\n\x0cis_extension\x18\x02\x20\x02(\x08R\x0bisExtensio\
    n\"\xeb\x01\n\x0eSourceCodeInfo\x12D\n\x08location\x18\x01\x20\x03(\x0b2\
    (.google.protobuf.SourceCodeInfo.LocationR\x08location\x1a\x92\x01\n\x08\
    Location\x12\x16\n\x04path\x18\x01\x20\x03(\x05R\x04pathB\x02\x10\x01\
    \x12\x16\n\x04span\x18\x02\x20\x03(\x05R\x04spanB\x02\x10\x01\x12)\n\x10\
    leading_comments\x18\x03\x20\x01(\tR\x0fleadingComments\x12+\n\x11traili\
    ng_comments\x18\x04\x20\x01(\tR\x10trailingCommentsB)\n\x13com.google.pr\
    otobufB\x10DescriptorProtosH\x01J\x9eK\n\x07\x12\x05\0\0\xd3\x01\x01\n\
    \x08\n\x01\x02\x12\x03\0\0\x18\n\x08\n\x01\x08\x12\x03\x02\0,\n\t\n\x02\
    \x08\x01\x12\x03\x02\0,\n\x08\n\x01\x08\x12\x03\x03\01\n\t\n\x02\x08\x08\
    \x12\x03\x03\01\n\x08\n\x01\x08\x12\x03\x04\0\x1c\n\t\n\x02\x08\t\x12\
    \x03\x04\0\x1c\n\n\n\x02\x04\0\x12\x04\x06\0\x08\x01\n\n\n\x03\x04\0\x01\
    \x12\x03\x06\x08\x19\n\x0b\n\x04\x04\0\x02\0\x12\x03\x07\x08?\n\x0c\n\
    \x05\x04\0\x02\0\x04\x12\x03\x07\x08\x10\n\x0c\n\x05\x04\0\x02\0\x06\x12\
    \x03\x07\x115\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x076:\n\x0c\n\x05\x04\
    \0\x02\0\x03\x12\x03\x07=>\n\n\n\x02\x04\x01\x12\x04\n\0\x16\x01\n\n\n\
    \x03\x04\x01\x01\x12\x03\n\x08\x1b\n\x0b\n\x04\x04\x01\x02\0\x12\x03\x0b\
    \x08!\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03\x0b\x08\x10\n\x0c\n\x05\x04\
    \x01\x02\0\x05\x12\x03\x0b\x11\x17\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\
    \x0b\x18\x1c\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x0b\x1f\x20\n\x0b\n\
    \x04\x04\x01\x02\x01\x12\x03\x0c\x08$\n\x0c\n\x05\x04\x01\x02\x01\x04\
    \x12\x03\x0c\x08\x10\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03\x0c\x11\x17\
    \n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\x0c\x18\x1f\n\x0c\n\x05\x04\x01\
    \x02\x01\x03\x12\x03\x0c\"#\n\x0b\n\x04\x04\x01\x02\x02\x12\x03\r\x08'\n\
    \x0c\n\x05\x04\x01\x02\x02\x04\x12\x03\r\x08\x10\n\x0c\n\x05\x04\x01\x02\
    \x02\x05\x12\x03\r\x11\x17\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03\r\x18\
    \"\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03\r%&\n\x0b\n\x04\x04\x01\x02\
    \x03\x12\x03\x0e\x08.\n\x0c\n\x05\x04\x01\x02\x03\x04\x12\x03\x0e\x08\
    \x10\n\x0c\n\x05\x04\x01\x02\x03\x05\x12\x03\x0e\x11\x16\n\x0c\n\x05\x04\
    \x01\x02\x03\x01\x12\x03\x0e\x17(\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\
    \x03\x0e+-\n\x0b\n\x04\x04\x01\x02\x04\x12\x03\x0f\x08,\n\x0c\n\x05\x04\
    \x01\x02\x04\x04\x12\x03\x0f\x08\x10\n\x0c\n\x05\x04\x01\x02\x04\x05\x12\
    \x03\x0f\x11\x16\n\x0c\n\x05\x04\x01\x02\x04\x01\x12\x03\x0f\x17&\n\x0c\
    \n\x05\x04\x01\x02\x04\x03\x12\x03\x0f)+\n\x0b\n\x04\x04\x01\x02\x05\x12\
    \x03\x10\x08C\n\x0c\n\x05\x04\x01\x02\x05\x04\x12\x03\x10\x08\x10\n\x0c\
    \n\x05\x04\x01\x02\x05\x06\x12\x03\x10\x111\n\x0c\n\x05\x04\x01\x02\x05\
    \x01\x12\x03\x102>\n\x0c\n\x05\x04\x01\x02\x05\x03\x12\x03\x10AB\n\x0b\n\
    \x04\x04\x01\x02\x06\x12\x03\x11\x08D\n\x0c\n\x05\x04\x01\x02\x06\x04\
    \x12\x03\x11\x08\x10\n\x0c\n\x05\x04\x01\x02\x06\x06\x12\x03\x11\x115\n\
    \x0c\n\x05\x04\x01\x02\x06\x01\x12\x03\x116?\n\x0c\n\x05\x04\x01\x02\x06\
    \x03\x12\x03\x11BC\n\x0b\n\x04\x04\x01\x02\x07\x12\x03\x12\x08E\n\x0c\n\
    \x05\x04\x01\x02\x07\x04\x12\x03\x12\x08\x10\n\x0c\n\x05\x04\x01\x02\x07\
    \x06\x12\x03\x12\x118\n\x0c\n\x05\x04\x01\x02\x07\x01\x12\x03\x129@\n\
    \x0c\n\x05\x04\x01\x02\x07\x03\x12\x03\x12CD\n\x0b\n\x04\x04\x01\x02\x08\
    \x12\x03\x13\x08E\n\x0c\n\x05\x04\x01\x02\x08\x04\x12\x03\x13\x08\x10\n\
    \x0c\n\x05\x04\x01\x02\x08\x06\x12\x03\x13\x116\n\x0c\n\x05\x04\x01\x02\
    \x08\x01\x12\x03\x137@\n\x0c\n\x05\x04\x01\x02\x08\x03\x12\x03\x13CD\n\
    \x0b\n\x04\x04\x01\x02\t\x12\x03\x14\x08:\n\x0c\n\x05\x04\x01\x02\t\x04\
    \x12\x03\x14\x08\x10\n\x0c\n\x05\x04\x01\x02\t\x06\x12\x03\x14\x11-\n\
    \x0c\n\x05\x04\x01\x02\t\x01\x12\x03\x14.5\n\x0c\n\x05\x04\x01\x02\t\x03\
    \x12\x03\x1489\n\x0b\n\x04\x04\x01\x02\n\x12\x03\x15\x08F\n\x0c\n\x05\
    \x04\x01\x02\n\x04\x12\x03\x15\x08\x10\n\x0c\n\x05\x04\x01\x02\n\x06\x12\
    \x03\x15\x110\n\x0c\n\x05\x04\x01\x02\n\x01\x12\x03\x151A\n\x0c\n\x05\
    \x04\x01\x02\n\x03\x12\x03\x15DE\n\n\n\x02\x04\x02\x12\x04\x18\0&\x01\n\
    \n\n\x03\x04\x02\x01\x12\x03\x18\x08\x17\n\x0c\n\x04\x04\x02\x03\0\x12\
    \x04\x19\x08\x1c\t\n\x0c\n\x05\x04\x02\x03\0\x01\x12\x03\x19\x10\x1e\n\r\
    \n\x06\x04\x02\x03\0\x02\0\x12\x03\x1a\x10)\n\x0e\n\x07\x04\x02\x03\0\
    \x02\0\x04\x12\x03\x1a\x10\x18\n\x0e\n\x07\x04\x02\x03\0\x02\0\x05\x12\
    \x03\x1a\x19\x1e\n\x0e\n\x07\x04\x02\x03\0\x02\0\x01\x12\x03\x1a\x1f$\n\
    \x0e\n\x07\x04\x02\x03\0\x02\0\x03\x12\x03\x1a'(\n\r\n\x06\x04\x02\x03\0\
    \x02\x01\x12\x03\x1b\x10'\n\x0e\n\x07\x04\x02\x03\0\x02\x01\x04\x12\x03\
    \x1b\x10\x18\n\x0e\n\x07\x04\x02\x03\0\x02\x01\x05\x12\x03\x1b\x19\x1e\n\
    \x0e\n\x07\x04\x02\x03\0\x02\x01\x01\x12\x03\x1b\x1f\"\n\x0e\n\x07\x04\
    \x02\x03\0\x02\x01\x03\x12\x03\x1b%&\n\x0b\n\x04\x04\x02\x02\0\x12\x03\
    \x1e\x08!\n\x0c\n\x05\x04\x02\x02\0\x04\x12\x03\x1e\x08\x10\n\x0c\n\x05\
    \x04\x02\x02\0\x05\x12\x03\x1e\x11\x17\n\x0c\n\x05\x04\x02\x02\0\x01\x12\
    \x03\x1e\x18\x1c\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03\x1e\x1f\x20\n\x0b\
    \n\x04\x04\x02\x02\x01\x12\x03\x1f\x08A\n\x0c\n\x05\x04\x02\x02\x01\x04\
    \x12\x03\x1f\x08\x10\n\x0c\n\x05\x04\x02\x02\x01\x06\x12\x03\x1f\x116\n\
    \x0c\n\x05\x04\x02\x02\x01\x01\x12\x03\x1f7<\n\x0c\n\x05\x04\x02\x02\x01\
    \x03\x12\x03\x1f?@\n\x0b\n\x04\x04\x02\x02\x02\x12\x03\x20\x08E\n\x0c\n\
    \x05\x04\x02\x02\x02\x04\x12\x03\x20\x08\x10\n\x0c\n\x05\x04\x02\x02\x02\
    \x06\x12\x03\x20\x116\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x03\x207@\n\
    \x0c\n\x05\x04\x02\x02\x02\x03\x12\x03\x20CD\n\x0b\n\x04\x04\x02\x02\x03\
    \x12\x03!\x08B\n\x0c\n\x05\x04\x02\x02\x03\x04\x12\x03!\x08\x10\n\x0c\n\
    \x05\x04\x02\x02\x03\x06\x12\x03!\x111\n\x0c\n\x05\x04\x02\x02\x03\x01\
    \x12\x03!2=\n\x0c\n\x05\x04\x02\x02\x03\x03\x12\x03!@A\n\x0b\n\x04\x04\
    \x02\x02\x04\x12\x03\"\x08D\n\x0c\n\x05\x04\x02\x02\x04\x04\x12\x03\"\
    \x08\x10\n\x0c\n\x05\x04\x02\x02\x04\x06\x12\x03\"\x115\n\x0c\n\x05\x04\
    \x02\x02\x04\x01\x12\x03\"6?\n\x0c\n\x05\x04\x02\x02\x04\x03\x12\x03\"BC\
    \n\x0b\n\x04\x04\x02\x02\x05\x12\x03#\x08U\n\x0c\n\x05\x04\x02\x02\x05\
    \x04\x12\x03#\x08\x10\n\x0c\n\x05\x04\x02\x02\x05\x06\x12\x03#\x11@\n\
    \x0c\n\x05\x04\x02\x02\x05\x01\x12\x03#AP\n\x0c\n\x05\x04\x02\x02\x05\
    \x03\x12\x03#ST\n\x0b\n\x04\x04\x02\x02\x06\x12\x03$\x08F\n\x0c\n\x05\
    \x04\x02\x02\x06\x04\x12\x03$\x08\x10\n\x0c\n\x05\x04\x02\x02\x06\x06\
    \x12\x03$\x116\n\x0c\n\x05\x04\x02\x02\x06\x01\x12\x03$7A\n\x0c\n\x05\
    \x04\x02\x02\x06\x03\x12\x03$DE\n\x0b\n\x04\x04\x02\x02\x07\x12\x03%\x08\
    =\n\x0c\n\x05\x04\x02\x02\x07\x04\x12\x03%\x08\x10\n\x0c\n\x05\x04\x02\
    \x02\x07\x06\x12\x03%\x110\n\x0c\n\x05\x04\x02\x02\x07\x01\x12\x03%18\n\
    \x0c\n\x05\x04\x02\x02\x07\x03\x12\x03%;<\n\n\n\x02\x04\x03\x12\x04(\0M\
    \x01\n\n\n\x03\x04\x03\x01\x12\x03(\x08\x1c\n\x0c\n\x04\x04\x03\x04\0\
    \x12\x04)\x08<\t\n\x0c\n\x05\x04\x03\x04\0\x01\x12\x03)\r\x11\n\r\n\x06\
    \x04\x03\x04\0\x02\0\x12\x03*\x10\x20\n\x0e\n\x07\x04\x03\x04\0\x02\0\
    \x01\x12\x03*\x10\x1b\n\x0e\n\x07\x04\x03\x04\0\x02\0\x02\x12\x03*\x1e\
    \x1f\n\r\n\x06\x04\x03\x04\0\x02\x01\x12\x03+\x10\x1f\n\x0e\n\x07\x04\
    \x03\x04\0\x02\x01\x01\x12\x03+\x10\x1a\n\x0e\n\x07\x04\x03\x04\0\x02\
    \x01\x02\x12\x03+\x1d\x1e\n\r\n\x06\x04\x03\x04\0\x02\x02\x12\x03,\x10\
    \x1f\n\x0e\n\x07\x04\x03\x04\0\x02\x02\x01\x12\x03,\x10\x1a\n\x0e\n\x07\
    \x04\x03\x04\0\x02\x02\x02\x12\x03,\x1d\x1e\n\r\n\x06\x04\x03\x04\0\x02\
    \x03\x12\x03-\x10\x20\n\x0e\n\x07\x04\x03\x04\0\x02\x03\x01\x12\x03-\x10\
    \x1b\n\x0e\n\x07\x04\x03\x04\0\x02\x03\x02\x12\x03-\x1e\x1f\n\r\n\x06\
    \x04\x03\x04\0\x02\x04\x12\x03.\x10\x1f\n\x0e\n\x07\x04\x03\x04\0\x02\
    \x04\x01\x12\x03.\x10\x1a\n\x0e\n\x07\x04\x03\x04\0\x02\x04\x02\x12\x03.\
    \x1d\x1e\n\r\n\x06\x04\x03\x04\0\x02\x05\x12\x03/\x10!\n\x0e\n\x07\x04\
    \x03\x04\0\x02\x05\x01\x12\x03/\x10\x1c\n\x0e\n\x07\x04\x03\x04\0\x02\
    \x05\x02\x12\x03/\x1f\x20\n\r\n\x06\x04\x03\x04\0\x02\x06\x12\x030\x10!\
    \n\x0e\n\x07\x04\x03\x04\0\x02\x06\x01\x12\x030\x10\x1c\n\x0e\n\x07\x04\
    \x03\x04\0\x02\x06\x02\x12\x030\x1f\x20\n\r\n\x06\x04\x03\x04\0\x02\x07\
    \x12\x031\x10\x1e\n\x0e\n\x07\x04\x03\x04\0\x02\x07\x01\x12\x031\x10\x19\
    \n\x0e\n\x07\x04\x03\x04\0\x02\x07\x02\x12\x031\x1c\x1d\n\r\n\x06\x04\
    \x03\x04\0\x02\x08\x12\x032\x10\x20\n\x0e\n\x07\x04\x03\x04\0\x02\x08\
    \x01\x12\x032\x10\x1b\n\x0e\n\x07\x04\x03\x04\0\x02\x08\x02\x12\x032\x1e\
    \x1f\n\r\n\x06\x04\x03\x04\0\x02\t\x12\x033\x10\x20\n\x0e\n\x07\x04\x03\
    \x04\0\x02\t\x01\x12\x033\x10\x1a\n\x0e\n\x07\x04\x03\x04\0\x02\t\x02\
    \x12\x033\x1d\x1f\n\r\n\x06\x04\x03\x04\0\x02\n\x12\x034\x10\"\n\x0e\n\
    \x07\x04\x03\x04\0\x02\n\x01\x12\x034\x10\x1c\n\x0e\n\x07\x04\x03\x04\0\
    \x02\n\x02\x12\x034\x1f!\n\r\n\x06\x04\x03\x04\0\x02\x0b\x12\x035\x10\
    \x20\n\x0e\n\x07\x04\x03\x04\0\x02\x0b\x01\x12\x035\x10\x1a\n\x0e\n\x07\
    \x04\x03\x04\0\x02\x0b\x02\x12\x035\x1d\x1f\n\r\n\x06\x04\x03\x04\0\x02\
    \x0c\x12\x036\x10!\n\x0e\n\x07\x04\x03\x04\0\x02\x0c\x01\x12\x036\x10\
    \x1b\n\x0e\n\x07\x04\x03\x04\0\x02\x0c\x02\x12\x036\x1e\x20\n\r\n\x06\
    \x04\x03\x04\0\x02\r\x12\x037\x10\x1f\n\x0e\n\x07\x04\x03\x04\0\x02\r\
    \x01\x12\x037\x10\x19\n\x0e\n\x07\x04\x03\x04\0\x02\r\x02\x12\x037\x1c\
    \x1e\n\r\n\x06\x04\x03\x04\0\x02\x0e\x12\x038\x10#\n\x0e\n\x07\x04\x03\
    \x04\0\x02\x0e\x01\x12\x038\x10\x1d\n\x0e\n\x07\x04\x03\x04\0\x02\x0e\
    \x02\x12\x038\x20\"\n\r\n\x06\x04\x03\x04\0\x02\x0f\x12\x039\x10#\n\x0e\
    \n\x07\x04\x03\x04\0\x02\x0f\x01\x12\x039\x10\x1d\n\x0e\n\x07\x04\x03\
    \x04\0\x02\x0f\x02\x12\x039\x20\"\n\r\n\x06\x04\x03\x04\0\x02\x10\x12\
    \x03:\x10!\n\x0e\n\x07\x04\x03\x04\0\x02\x10\x01\x12\x03:\x10\x1b\n\x0e\
    \n\x07\x04\x03\x04\0\x02\x10\x02\x12\x03:\x1e\x20\n\r\n\x06\x04\x03\x04\
    \0\x02\x11\x12\x03;\x10!\n\x0e\n\x07\x04\x03\x04\0\x02\x11\x01\x12\x03;\
    \x10\x1b\n\x0e\n\x07\x04\x03\x04\0\x02\x11\x02\x12\x03;\x1e\x20\n\x0c\n\
    \x04\x04\x03\x04\x01\x12\x04>\x08B\t\n\x0c\n\x05\x04\x03\x04\x01\x01\x12\
    \x03>\r\x12\n\r\n\x06\x04\x03\x04\x01\x02\0\x12\x03?\x10#\n\x0e\n\x07\
    \x04\x03\x04\x01\x02\0\x01\x12\x03?\x10\x1e\n\x0e\n\x07\x04\x03\x04\x01\
    \x02\0\x02\x12\x03?!\"\n\r\n\x06\x04\x03\x04\x01\x02\x01\x12\x03@\x10#\n\
    \x0e\n\x07\x04\x03\x04\x01\x02\x01\x01\x12\x03@\x10\x1e\n\x0e\n\x07\x04\
    \x03\x04\x01\x02\x01\x02\x12\x03@!\"\n\r\n\x06\x04\x03\x04\x01\x02\x02\
    \x12\x03A\x10#\n\x0e\n\x07\x04\x03\x04\x01\x02\x02\x01\x12\x03A\x10\x1e\
    \n\x0e\n\x07\x04\x03\x04\x01\x02\x02\x02\x12\x03A!\"\n\x0b\n\x04\x04\x03\
    \x02\0\x12\x03D\x08!\n\x0c\n\x05\x04\x03\x02\0\x04\x12\x03D\x08\x10\n\
    \x0c\n\x05\x04\x03\x02\0\x05\x12\x03D\x11\x17\n\x0c\n\x05\x04\x03\x02\0\
    \x01\x12\x03D\x18\x1c\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03D\x1f\x20\n\
    \x0b\n\x04\x04\x03\x02\x01\x12\x03E\x08\"\n\x0c\n\x05\x04\x03\x02\x01\
    \x04\x12\x03E\x08\x10\n\x0c\n\x05\x04\x03\x02\x01\x05\x12\x03E\x11\x16\n\
    \x0c\n\x05\x04\x03\x02\x01\x01\x12\x03E\x17\x1d\n\x0c\n\x05\x04\x03\x02\
    \x01\x03\x12\x03E\x20!\n\x0b\n\x04\x04\x03\x02\x02\x12\x03F\x08b\n\x0c\n\
    \x05\x04\x03\x02\x02\x04\x12\x03F\x08\x10\n\x0c\n\x05\x04\x03\x02\x02\
    \x06\x12\x03F\x11<\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\x03F=B\n\x0c\n\
    \x05\x04\x03\x02\x02\x03\x12\x03FEF\n\x0c\n\x05\x04\x03\x02\x02\x08\x12\
    \x03FGa\n\x0c\n\x05\x04\x03\x02\x02\x07\x12\x03FR`\n\x0b\n\x04\x04\x03\
    \x02\x03\x12\x03G\x08]\n\x0c\n\x05\x04\x03\x02\x03\x04\x12\x03G\x08\x10\
    \n\x0c\n\x05\x04\x03\x02\x03\x06\x12\x03G\x11;\n\x0c\n\x05\x04\x03\x02\
    \x03\x01\x12\x03G<@\n\x0c\n\x05\x04\x03\x02\x03\x03\x12\x03GCD\n\x0c\n\
    \x05\x04\x03\x02\x03\x08\x12\x03GE\\\n\x0c\n\x05\x04\x03\x02\x03\x07\x12\
    \x03GP[\n\x0b\n\x04\x04\x03\x02\x04\x12\x03H\x08&\n\x0c\n\x05\x04\x03\
    \x02\x04\x04\x12\x03H\x08\x10\n\x0c\n\x05\x04\x03\x02\x04\x05\x12\x03H\
    \x11\x17\n\x0c\n\x05\x04\x03\x02\x04\x01\x12\x03H\x18!\n\x0c\n\x05\x04\
    \x03\x02\x04\x03\x12\x03H$%\n\x0b\n\x04\x04\x03\x02\x05\x12\x03I\x08%\n\
    \x0c\n\x05\x04\x03\x02\x05\x04\x12\x03I\x08\x10\n\x0c\n\x05\x04\x03\x02\
    \x05\x05\x12\x03I\x11\x17\n\x0c\n\x05\x04\x03\x02\x05\x01\x12\x03I\x18\
    \x20\n\x0c\n\x05\x04\x03\x02\x05\x03\x12\x03I#$\n\x0b\n\x04\x04\x03\x02\
    \x06\x12\x03J\x08*\n\x0c\n\x05\x04\x03\x02\x06\x04\x12\x03J\x08\x10\n\
    \x0c\n\x05\x04\x03\x02\x06\x05\x12\x03J\x11\x17\n\x0c\n\x05\x04\x03\x02\
    \x06\x01\x12\x03J\x18%\n\x0c\n\x05\x04\x03\x02\x06\x03\x12\x03J()\n\x0b\
    \n\x04\x04\x03\x02\x07\x12\x03K\x08'\n\x0c\n\x05\x04\x03\x02\x07\x04\x12\
    \x03K\x08\x10\n\x0c\n\x05\x04\x03\x02\x07\x05\x12\x03K\x11\x16\n\x0c\n\
    \x05\x04\x03\x02\x07\x01\x12\x03K\x17\"\n\x0c\n\x05\x04\x03\x02\x07\x03\
    \x12\x03K%&\n\x0b\n\x04\x04\x03\x02\x08\x12\x03L\x08;\n\x0c\n\x05\x04\
    \x03\x02\x08\x04\x12\x03L\x08\x10\n\x0c\n\x05\x04\x03\x02\x08\x06\x12\
    \x03L\x11.\n\x0c\n\x05\x04\x03\x02\x08\x01\x12\x03L/6\n\x0c\n\x05\x04\
    \x03\x02\x08\x03\x12\x03L9:\n\n\n\x02\x04\x04\x12\x04O\0Q\x01\n\n\n\x03\
    \x04\x04\x01\x12\x03O\x08\x1c\n\x0b\n\x04\x04\x04\x02\0\x12\x03P\x08!\n\
    \x0c\n\x05\x04\x04\x02\0\x04\x12\x03P\x08\x10\n\x0c\n\x05\x04\x04\x02\0\
    \x05\x12\x03P\x11\x17\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03P\x18\x1c\n\
    \x0c\n\x05\x04\x04\x02\0\x03\x12\x03P\x1f\x20\n\n\n\x02\x04\x05\x12\x04S\
    \0W\x01\n\n\n\x03\x04\x05\x01\x12\x03S\x08\x1b\n\x0b\n\x04\x04\x05\x02\0\
    \x12\x03T\x08!\n\x0c\n\x05\x04\x05\x02\0\x04\x12\x03T\x08\x10\n\x0c\n\
    \x05\x04\x05\x02\0\x05\x12\x03T\x11\x17\n\x0c\n\x05\x04\x05\x02\0\x01\
    \x12\x03T\x18\x1c\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03T\x1f\x20\n\x0b\n\
    \x04\x04\x05\x02\x01\x12\x03U\x08E\n\x0c\n\x05\x04\x05\x02\x01\x04\x12\
    \x03U\x08\x10\n\x0c\n\x05\x04\x05\x02\x01\x06\x12\x03U\x11:\n\x0c\n\x05\
    \x04\x05\x02\x01\x01\x12\x03U;@\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03U\
    CD\n\x0b\n\x04\x04\x05\x02\x02\x12\x03V\x08:\n\x0c\n\x05\x04\x05\x02\x02\
    \x04\x12\x03V\x08\x10\n\x0c\n\x05\x04\x05\x02\x02\x06\x12\x03V\x11-\n\
    \x0c\n\x05\x04\x05\x02\x02\x01\x12\x03V.5\n\x0c\n\x05\x04\x05\x02\x02\
    \x03\x12\x03V89\n\n\n\x02\x04\x06\x12\x04Y\0]\x01\n\n\n\x03\x04\x06\x01\
    \x12\x03Y\x08\x20\n\x0b\n\x04\x04\x06\x02\0\x12\x03Z\x08!\n\x0c\n\x05\
    \x04\x06\x02\0\x04\x12\x03Z\x08\x10\n\x0c\n\x05\x04\x06\x02\0\x05\x12\
    \x03Z\x11\x17\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03Z\x18\x1c\n\x0c\n\x05\
    \x04\x06\x02\0\x03\x12\x03Z\x1f\x20\n\x0b\n\x04\x04\x06\x02\x01\x12\x03[\
    \x08\"\n\x0c\n\x05\x04\x06\x02\x01\x04\x12\x03[\x08\x10\n\x0c\n\x05\x04\
    \x06\x02\x01\x05\x12\x03[\x11\x16\n\x0c\n\x05\x04\x06\x02\x01\x01\x12\
    \x03[\x17\x1d\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03[\x20!\n\x0b\n\x04\
    \x04\x06\x02\x02\x12\x03\\\x08?\n\x0c\n\x05\x04\x06\x02\x02\x04\x12\x03\
    \\\x08\x10\n\x0c\n\x05\x04\x06\x02\x02\x06\x12\x03\\\x112\n\x0c\n\x05\
    \x04\x06\x02\x02\x01\x12\x03\\3:\n\x0c\n\x05\x04\x06\x02\x02\x03\x12\x03\
    \\=>\n\n\n\x02\x04\x07\x12\x04_\0c\x01\n\n\n\x03\x04\x07\x01\x12\x03_\
    \x08\x1e\n\x0b\n\x04\x04\x07\x02\0\x12\x03`\x08!\n\x0c\n\x05\x04\x07\x02\
    \0\x04\x12\x03`\x08\x10\n\x0c\n\x05\x04\x07\x02\0\x05\x12\x03`\x11\x17\n\
    \x0c\n\x05\x04\x07\x02\0\x01\x12\x03`\x18\x1c\n\x0c\n\x05\x04\x07\x02\0\
    \x03\x12\x03`\x1f\x20\n\x0b\n\x04\x04\x07\x02\x01\x12\x03a\x08C\n\x0c\n\
    \x05\x04\x07\x02\x01\x04\x12\x03a\x08\x10\n\x0c\n\x05\x04\x07\x02\x01\
    \x06\x12\x03a\x117\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\x03a8>\n\x0c\n\
    \x05\x04\x07\x02\x01\x03\x12\x03aAB\n\x0b\n\x04\x04\x07\x02\x02\x12\x03b\
    \x08=\n\x0c\n\x05\x04\x07\x02\x02\x04\x12\x03b\x08\x10\n\x0c\n\x05\x04\
    \x07\x02\x02\x06\x12\x03b\x110\n\x0c\n\x05\x04\x07\x02\x02\x01\x12\x03b1\
    8\n\x0c\n\x05\x04\x07\x02\x02\x03\x12\x03b;<\n\n\n\x02\x04\x08\x12\x04e\
    \0j\x01\n\n\n\x03\x04\x08\x01\x12\x03e\x08\x1d\n\x0b\n\x04\x04\x08\x02\0\
    \x12\x03f\x08!\n\x0c\n\x05\x04\x08\x02\0\x04\x12\x03f\x08\x10\n\x0c\n\
    \x05\x04\x08\x02\0\x05\x12\x03f\x11\x17\n\x0c\n\x05\x04\x08\x02\0\x01\
    \x12\x03f\x18\x1c\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03f\x1f\x20\n\x0b\n\
    \x04\x04\x08\x02\x01\x12\x03g\x08'\n\x0c\n\x05\x04\x08\x02\x01\x04\x12\
    \x03g\x08\x10\n\x0c\n\x05\x04\x08\x02\x01\x05\x12\x03g\x11\x17\n\x0c\n\
    \x05\x04\x08\x02\x01\x01\x12\x03g\x18\"\n\x0c\n\x05\x04\x08\x02\x01\x03\
    \x12\x03g%&\n\x0b\n\x04\x04\x08\x02\x02\x12\x03h\x08(\n\x0c\n\x05\x04\
    \x08\x02\x02\x04\x12\x03h\x08\x10\n\x0c\n\x05\x04\x08\x02\x02\x05\x12\
    \x03h\x11\x17\n\x0c\n\x05\x04\x08\x02\x02\x01\x12\x03h\x18#\n\x0c\n\x05\
    \x04\x08\x02\x02\x03\x12\x03h&'\n\x0b\n\x04\x04\x08\x02\x03\x12\x03i\x08\
    <\n\x0c\n\x05\x04\x08\x02\x03\x04\x12\x03i\x08\x10\n\x0c\n\x05\x04\x08\
    \x02\x03\x06\x12\x03i\x11/\n\x0c\n\x05\x04\x08\x02\x03\x01\x12\x03i07\n\
    \x0c\n\x05\x04\x08\x02\x03\x03\x12\x03i:;\n\x0b\n\x02\x04\t\x12\x05l\0\
    \x81\x01\x01\n\n\n\x03\x04\t\x01\x12\x03l\x08\x13\n\x0c\n\x04\x04\t\x04\
    \0\x12\x04m\x08q\t\n\x0c\n\x05\x04\t\x04\0\x01\x12\x03m\r\x19\n\r\n\x06\
    \x04\t\x04\0\x02\0\x12\x03n\x10\x1a\n\x0e\n\x07\x04\t\x04\0\x02\0\x01\
    \x12\x03n\x10\x15\n\x0e\n\x07\x04\t\x04\0\x02\0\x02\x12\x03n\x18\x19\n\r\
    \n\x06\x04\t\x04\0\x02\x01\x12\x03o\x10\x1e\n\x0e\n\x07\x04\t\x04\0\x02\
    \x01\x01\x12\x03o\x10\x19\n\x0e\n\x07\x04\t\x04\0\x02\x01\x02\x12\x03o\
    \x1c\x1d\n\r\n\x06\x04\t\x04\0\x02\x02\x12\x03p\x10!\n\x0e\n\x07\x04\t\
    \x04\0\x02\x02\x01\x12\x03p\x10\x1c\n\x0e\n\x07\x04\t\x04\0\x02\x02\x02\
    \x12\x03p\x1f\x20\n\x0b\n\x04\x04\t\x02\0\x12\x03s\x08)\n\x0c\n\x05\x04\
    \t\x02\0\x04\x12\x03s\x08\x10\n\x0c\n\x05\x04\t\x02\0\x05\x12\x03s\x11\
    \x17\n\x0c\n\x05\x04\t\x02\0\x01\x12\x03s\x18$\n\x0c\n\x05\x04\t\x02\0\
    \x03\x12\x03s'(\n\x0b\n\x04\x04\t\x02\x01\x12\x03t\x081\n\x0c\n\x05\x04\
    \t\x02\x01\x04\x12\x03t\x08\x10\n\x0c\n\x05\x04\t\x02\x01\x05\x12\x03t\
    \x11\x17\n\x0c\n\x05\x04\t\x02\x01\x01\x12\x03t\x18,\n\x0c\n\x05\x04\t\
    \x02\x01\x03\x12\x03t/0\n\x0b\n\x04\x04\t\x02\x02\x12\x03u\x08A\n\x0c\n\
    \x05\x04\t\x02\x02\x04\x12\x03u\x08\x10\n\x0c\n\x05\x04\t\x02\x02\x05\
    \x12\x03u\x11\x15\n\x0c\n\x05\x04\t\x02\x02\x01\x12\x03u\x16)\n\x0c\n\
    \x05\x04\t\x02\x02\x03\x12\x03u,.\n\x0c\n\x05\x04\t\x02\x02\x08\x12\x03u\
    /@\n\x0c\n\x05\x04\t\x02\x02\x07\x12\x03u:?\n\x0b\n\x04\x04\t\x02\x03\
    \x12\x03v\x08K\n\x0c\n\x05\x04\t\x02\x03\x04\x12\x03v\x08\x10\n\x0c\n\
    \x05\x04\t\x02\x03\x05\x12\x03v\x11\x15\n\x0c\n\x05\x04\t\x02\x03\x01\
    \x12\x03v\x163\n\x0c\n\x05\x04\t\x02\x03\x03\x12\x03v68\n\x0c\n\x05\x04\
    \t\x02\x03\x08\x12\x03v9J\n\x0c\n\x05\x04\t\x02\x03\x07\x12\x03vDI\n\x0b\
    \n\x04\x04\t\x02\x04\x12\x03w\x08D\n\x0c\n\x05\x04\t\x02\x04\x04\x12\x03\
    w\x08\x10\n\x0c\n\x05\x04\t\x02\x04\x05\x12\x03w\x11\x15\n\x0c\n\x05\x04\
    \t\x02\x04\x01\x12\x03w\x16,\n\x0c\n\x05\x04\t\x02\x04\x03\x12\x03w/1\n\
    \x0c\n\x05\x04\t\x02\x04\x08\x12\x03w2C\n\x0c\n\x05\x04\t\x02\x04\x07\
    \x12\x03w=B\n\x0b\n\x04\x04\t\x02\x05\x12\x03x\x08^\n\x0c\n\x05\x04\t\
    \x02\x05\x04\x12\x03x\x08\x10\n\x0c\n\x05\x04\t\x02\x05\x06\x12\x03x\x11\
    :\n\x0c\n\x05\x04\t\x02\x05\x01\x12\x03x;G\n\x0c\n\x05\x04\t\x02\x05\x03\
    \x12\x03xJK\n\x0c\n\x05\x04\t\x02\x05\x08\x12\x03xL]\n\x0c\n\x05\x04\t\
    \x02\x05\x07\x12\x03xW\\\n\x0b\n\x04\x04\t\x02\x06\x12\x03y\x08(\n\x0c\n\
    \x05\x04\t\x02\x06\x04\x12\x03y\x08\x10\n\x0c\n\x05\x04\t\x02\x06\x05\
    \x12\x03y\x11\x17\n\x0c\n\x05\x04\t\x02\x06\x01\x12\x03y\x18\"\n\x0c\n\
    \x05\x04\t\x02\x06\x03\x12\x03y%'\n\x0b\n\x04\x04\t\x02\x07\x12\x03z\x08\
    A\n\x0c\n\x05\x04\t\x02\x07\x04\x12\x03z\x08\x10\n\x0c\n\x05\x04\t\x02\
    \x07\x05\x12\x03z\x11\x15\n\x0c\n\x05\x04\t\x02\x07\x01\x12\x03z\x16)\n\
    \x0c\n\x05\x04\t\x02\x07\x03\x12\x03z,.\n\x0c\n\x05\x04\t\x02\x07\x08\
    \x12\x03z/@\n\x0c\n\x05\x04\t\x02\x07\x07\x12\x03z:?\n\x0b\n\x04\x04\t\
    \x02\x08\x12\x03{\x08C\n\x0c\n\x05\x04\t\x02\x08\x04\x12\x03{\x08\x10\n\
    \x0c\n\x05\x04\t\x02\x08\x05\x12\x03{\x11\x15\n\x0c\n\x05\x04\t\x02\x08\
    \x01\x12\x03{\x16+\n\x0c\n\x05\x04\t\x02\x08\x03\x12\x03{.0\n\x0c\n\x05\
    \x04\t\x02\x08\x08\x12\x03{1B\n\x0c\n\x05\x04\t\x02\x08\x07\x12\x03{<A\n\
    \x0b\n\x04\x04\t\x02\t\x12\x03|\x08A\n\x0c\n\x05\x04\t\x02\t\x04\x12\x03\
    |\x08\x10\n\x0c\n\x05\x04\t\x02\t\x05\x12\x03|\x11\x15\n\x0c\n\x05\x04\t\
    \x02\t\x01\x12\x03|\x16)\n\x0c\n\x05\x04\t\x02\t\x03\x12\x03|,.\n\x0c\n\
    \x05\x04\t\x02\t\x08\x12\x03|/@\n\x0c\n\x05\x04\t\x02\t\x07\x12\x03|:?\n\
    \x0b\n\x04\x04\t\x02\n\x12\x03}\x088\n\x0c\n\x05\x04\t\x02\n\x04\x12\x03\
    }\x08\x10\n\x0c\n\x05\x04\t\x02\n\x05\x12\x03}\x11\x15\n\x0c\n\x05\x04\t\
    \x02\n\x01\x12\x03}\x16\x20\n\x0c\n\x05\x04\t\x02\n\x03\x12\x03}#%\n\x0c\
    \n\x05\x04\t\x02\n\x08\x12\x03}&7\n\x0c\n\x05\x04\t\x02\n\x07\x12\x03}16\
    \n\x0b\n\x04\x04\t\x02\x0b\x12\x03~\x08Q\n\x0c\n\x05\x04\t\x02\x0b\x04\
    \x12\x03~\x08\x10\n\x0c\n\x05\x04\t\x02\x0b\x06\x12\x03~\x115\n\x0c\n\
    \x05\x04\t\x02\x0b\x01\x12\x03~6J\n\x0c\n\x05\x04\t\x02\x0b\x03\x12\x03~\
    MP\n\x0b\n\x03\x04\t\x05\x12\x04\x80\x01\x08\x1f\n\x0c\n\x04\x04\t\x05\0\
    \x12\x04\x80\x01\x13\x1e\n\r\n\x05\x04\t\x05\0\x01\x12\x04\x80\x01\x13\
    \x17\n\r\n\x05\x04\t\x05\0\x02\x12\x04\x80\x01\x1b\x1e\n\x0c\n\x02\x04\n\
    \x12\x06\x83\x01\0\x8a\x01\x01\n\x0b\n\x03\x04\n\x01\x12\x04\x83\x01\x08\
    \x16\n\x0c\n\x04\x04\n\x02\0\x12\x04\x84\x01\x08D\n\r\n\x05\x04\n\x02\0\
    \x04\x12\x04\x84\x01\x08\x10\n\r\n\x05\x04\n\x02\0\x05\x12\x04\x84\x01\
    \x11\x15\n\r\n\x05\x04\n\x02\0\x01\x12\x04\x84\x01\x16-\n\r\n\x05\x04\n\
    \x02\0\x03\x12\x04\x84\x0101\n\r\n\x05\x04\n\x02\0\x08\x12\x04\x84\x012C\
    \n\r\n\x05\x04\n\x02\0\x07\x12\x04\x84\x01=B\n\x0c\n\x04\x04\n\x02\x01\
    \x12\x04\x85\x01\x08L\n\r\n\x05\x04\n\x02\x01\x04\x12\x04\x85\x01\x08\
    \x10\n\r\n\x05\x04\n\x02\x01\x05\x12\x04\x85\x01\x11\x15\n\r\n\x05\x04\n\
    \x02\x01\x01\x12\x04\x85\x01\x165\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\
    \x85\x0189\n\r\n\x05\x04\n\x02\x01\x08\x12\x04\x85\x01:K\n\r\n\x05\x04\n\
    \x02\x01\x07\x12\x04\x85\x01EJ\n\x0c\n\x04\x04\n\x02\x02\x12\x04\x86\x01\
    \x087\n\r\n\x05\x04\n\x02\x02\x04\x12\x04\x86\x01\x08\x10\n\r\n\x05\x04\
    \n\x02\x02\x05\x12\x04\x86\x01\x11\x15\n\r\n\x05\x04\n\x02\x02\x01\x12\
    \x04\x86\x01\x16\x20\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\x86\x01#$\n\r\n\
    \x05\x04\n\x02\x02\x08\x12\x04\x86\x01%6\n\r\n\x05\x04\n\x02\x02\x07\x12\
    \x04\x86\x0105\n\x0c\n\x04\x04\n\x02\x03\x12\x04\x87\x01\x08Q\n\r\n\x05\
    \x04\n\x02\x03\x04\x12\x04\x87\x01\x08\x10\n\r\n\x05\x04\n\x02\x03\x06\
    \x12\x04\x87\x01\x115\n\r\n\x05\x04\n\x02\x03\x01\x12\x04\x87\x016J\n\r\
    \n\x05\x04\n\x02\x03\x03\x12\x04\x87\x01MP\n\x0b\n\x03\x04\n\x05\x12\x04\
    \x89\x01\x08\x1f\n\x0c\n\x04\x04\n\x05\0\x12\x04\x89\x01\x13\x1e\n\r\n\
    \x05\x04\n\x05\0\x01\x12\x04\x89\x01\x13\x17\n\r\n\x05\x04\n\x05\0\x02\
    \x12\x04\x89\x01\x1b\x1e\n\x0c\n\x02\x04\x0b\x12\x06\x8c\x01\0\x9c\x01\
    \x01\n\x0b\n\x03\x04\x0b\x01\x12\x04\x8c\x01\x08\x14\n\x0e\n\x04\x04\x0b\
    \x04\0\x12\x06\x8d\x01\x08\x91\x01\t\n\r\n\x05\x04\x0b\x04\0\x01\x12\x04\
    \x8d\x01\r\x12\n\x0e\n\x06\x04\x0b\x04\0\x02\0\x12\x04\x8e\x01\x10\x1b\n\
    \x0f\n\x07\x04\x0b\x04\0\x02\0\x01\x12\x04\x8e\x01\x10\x16\n\x0f\n\x07\
    \x04\x0b\x04\0\x02\0\x02\x12\x04\x8e\x01\x19\x1a\n\x0e\n\x06\x04\x0b\x04\
    \0\x02\x01\x12\x04\x8f\x01\x10\x19\n\x0f\n\x07\x04\x0b\x04\0\x02\x01\x01\
    \x12\x04\x8f\x01\x10\x14\n\x0f\n\x07\x04\x0b\x04\0\x02\x01\x02\x12\x04\
    \x8f\x01\x17\x18\n\x0e\n\x06\x04\x0b\x04\0\x02\x02\x12\x04\x90\x01\x10!\
    \n\x0f\n\x07\x04\x0b\x04\0\x02\x02\x01\x12\x04\x90\x01\x10\x1c\n\x0f\n\
    \x07\x04\x0b\x04\0\x02\x02\x02\x12\x04\x90\x01\x1f\x20\n\x0c\n\x04\x04\
    \x0b\x02\0\x12\x04\x93\x01\x08R\n\r\n\x05\x04\x0b\x02\0\x04\x12\x04\x93\
    \x01\x08\x10\n\r\n\x05\x04\x0b\x02\0\x06\x12\x04\x93\x01\x114\n\r\n\x05\
    \x04\x0b\x02\0\x01\x12\x04\x93\x015:\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\
    \x93\x01=>\n\r\n\x05\x04\x0b\x02\0\x08\x12\x04\x93\x01?Q\n\r\n\x05\x04\
    \x0b\x02\0\x07\x12\x04\x93\x01JP\n\x0c\n\x04\x04\x0b\x02\x01\x12\x04\x94\
    \x01\x08!\n\r\n\x05\x04\x0b\x02\x01\x04\x12\x04\x94\x01\x08\x10\n\r\n\
    \x05\x04\x0b\x02\x01\x05\x12\x04\x94\x01\x11\x15\n\r\n\x05\x04\x0b\x02\
    \x01\x01\x12\x04\x94\x01\x16\x1c\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\
    \x94\x01\x1f\x20\n\x0c\n\x04\x04\x0b\x02\x02\x12\x04\x95\x01\x081\n\r\n\
    \x05\x04\x0b\x02\x02\x04\x12\x04\x95\x01\x08\x10\n\r\n\x05\x04\x0b\x02\
    \x02\x05\x12\x04\x95\x01\x11\x15\n\r\n\x05\x04\x0b\x02\x02\x01\x12\x04\
    \x95\x01\x16\x1a\n\r\n\x05\x04\x0b\x02\x02\x03\x12\x04\x95\x01\x1d\x1e\n\
    \r\n\x05\x04\x0b\x02\x02\x08\x12\x04\x95\x01\x1f0\n\r\n\x05\x04\x0b\x02\
    \x02\x07\x12\x04\x95\x01*/\n\x0c\n\x04\x04\x0b\x02\x03\x12\x04\x96\x01\
    \x087\n\r\n\x05\x04\x0b\x02\x03\x04\x12\x04\x96\x01\x08\x10\n\r\n\x05\
    \x04\x0b\x02\x03\x05\x12\x04\x96\x01\x11\x15\n\r\n\x05\x04\x0b\x02\x03\
    \x01\x12\x04\x96\x01\x16\x20\n\r\n\x05\x04\x0b\x02\x03\x03\x12\x04\x96\
    \x01#$\n\r\n\x05\x04\x0b\x02\x03\x08\x12\x04\x96\x01%6\n\r\n\x05\x04\x0b\
    \x02\x03\x07\x12\x04\x96\x0105\n\x0c\n\x04\x04\x0b\x02\x04\x12\x04\x97\
    \x01\x081\n\r\n\x05\x04\x0b\x02\x04\x04\x12\x04\x97\x01\x08\x10\n\r\n\
    \x05\x04\x0b\x02\x04\x05\x12\x04\x97\x01\x11\x17\n\r\n\x05\x04\x0b\x02\
    \x04\x01\x12\x04\x97\x01\x18,\n\r\n\x05\x04\x0b\x02\x04\x03\x12\x04\x97\
    \x01/0\n\x0c\n\x04\x04\x0b\x02\x05\x12\x04\x98\x01\x082\n\r\n\x05\x04\
    \x0b\x02\x05\x04\x12\x04\x98\x01\x08\x10\n\r\n\x05\x04\x0b\x02\x05\x05\
    \x12\x04\x98\x01\x11\x15\n\r\n\x05\x04\x0b\x02\x05\x01\x12\x04\x98\x01\
    \x16\x1a\n\r\n\x05\x04\x0b\x02\x05\x03\x12\x04\x98\x01\x1d\x1f\n\r\n\x05\
    \x04\x0b\x02\x05\x08\x12\x04\x98\x01\x201\n\r\n\x05\x04\x0b\x02\x05\x07\
    \x12\x04\x98\x01+0\n\x0c\n\x04\x04\x0b\x02\x06\x12\x04\x99\x01\x08Q\n\r\
    \n\x05\x04\x0b\x02\x06\x04\x12\x04\x99\x01\x08\x10\n\r\n\x05\x04\x0b\x02\
    \x06\x06\x12\x04\x99\x01\x115\n\r\n\x05\x04\x0b\x02\x06\x01\x12\x04\x99\
    \x016J\n\r\n\x05\x04\x0b\x02\x06\x03\x12\x04\x99\x01MP\n\x0b\n\x03\x04\
    \x0b\x05\x12\x04\x9b\x01\x08\x1f\n\x0c\n\x04\x04\x0b\x05\0\x12\x04\x9b\
    \x01\x13\x1e\n\r\n\x05\x04\x0b\x05\0\x01\x12\x04\x9b\x01\x13\x17\n\r\n\
    \x05\x04\x0b\x05\0\x02\x12\x04\x9b\x01\x1b\x1e\n\x0c\n\x02\x04\x0c\x12\
    \x06\x9e\x01\0\xa4\x01\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\x9e\x01\x08\
    \x13\n\x0c\n\x04\x04\x0c\x02\0\x12\x04\x9f\x01\x08&\n\r\n\x05\x04\x0c\
    \x02\0\x04\x12\x04\x9f\x01\x08\x10\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\
    \x9f\x01\x11\x15\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\x9f\x01\x16!\n\r\n\
    \x05\x04\x0c\x02\0\x03\x12\x04\x9f\x01$%\n\x0c\n\x04\x04\x0c\x02\x01\x12\
    \x04\xa0\x01\x087\n\r\n\x05\x04\x0c\x02\x01\x04\x12\x04\xa0\x01\x08\x10\
    \n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\xa0\x01\x11\x15\n\r\n\x05\x04\x0c\
    \x02\x01\x01\x12\x04\xa0\x01\x16\x20\n\r\n\x05\x04\x0c\x02\x01\x03\x12\
    \x04\xa0\x01#$\n\r\n\x05\x04\x0c\x02\x01\x08\x12\x04\xa0\x01%6\n\r\n\x05\
    \x04\x0c\x02\x01\x07\x12\x04\xa0\x0105\n\x0c\n\x04\x04\x0c\x02\x02\x12\
    \x04\xa1\x01\x08Q\n\r\n\x05\x04\x0c\x02\x02\x04\x12\x04\xa1\x01\x08\x10\
    \n\r\n\x05\x04\x0c\x02\x02\x06\x12\x04\xa1\x01\x115\n\r\n\x05\x04\x0c\
    \x02\x02\x01\x12\x04\xa1\x016J\n\r\n\x05\x04\x0c\x02\x02\x03\x12\x04\xa1\
    \x01MP\n\x0b\n\x03\x04\x0c\x05\x12\x04\xa3\x01\x08\x1f\n\x0c\n\x04\x04\
    \x0c\x05\0\x12\x04\xa3\x01\x13\x1e\n\r\n\x05\x04\x0c\x05\0\x01\x12\x04\
    \xa3\x01\x13\x17\n\r\n\x05\x04\x0c\x05\0\x02\x12\x04\xa3\x01\x1b\x1e\n\
    \x0c\n\x02\x04\r\x12\x06\xa6\x01\0\xab\x01\x01\n\x0b\n\x03\x04\r\x01\x12\
    \x04\xa6\x01\x08\x18\n\x0c\n\x04\x04\r\x02\0\x12\x04\xa7\x01\x087\n\r\n\
    \x05\x04\r\x02\0\x04\x12\x04\xa7\x01\x08\x10\n\r\n\x05\x04\r\x02\0\x05\
    \x12\x04\xa7\x01\x11\x15\n\r\n\x05\x04\r\x02\0\x01\x12\x04\xa7\x01\x16\
    \x20\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xa7\x01#$\n\r\n\x05\x04\r\x02\0\
    \x08\x12\x04\xa7\x01%6\n\r\n\x05\x04\r\x02\0\x07\x12\x04\xa7\x0105\n\x0c\
    \n\x04\x04\r\x02\x01\x12\x04\xa8\x01\x08Q\n\r\n\x05\x04\r\x02\x01\x04\
    \x12\x04\xa8\x01\x08\x10\n\r\n\x05\x04\r\x02\x01\x06\x12\x04\xa8\x01\x11\
    5\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\xa8\x016J\n\r\n\x05\x04\r\x02\x01\
    \x03\x12\x04\xa8\x01MP\n\x0b\n\x03\x04\r\x05\x12\x04\xaa\x01\x08\x1f\n\
    \x0c\n\x04\x04\r\x05\0\x12\x04\xaa\x01\x13\x1e\n\r\n\x05\x04\r\x05\0\x01\
    \x12\x04\xaa\x01\x13\x17\n\r\n\x05\x04\r\x05\0\x02\x12\x04\xaa\x01\x1b\
    \x1e\n\x0c\n\x02\x04\x0e\x12\x06\xad\x01\0\xb2\x01\x01\n\x0b\n\x03\x04\
    \x0e\x01\x12\x04\xad\x01\x08\x16\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\xae\
    \x01\x088\n\r\n\x05\x04\x0e\x02\0\x04\x12\x04\xae\x01\x08\x10\n\r\n\x05\
    \x04\x0e\x02\0\x05\x12\x04\xae\x01\x11\x15\n\r\n\x05\x04\x0e\x02\0\x01\
    \x12\x04\xae\x01\x16\x20\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xae\x01#%\n\
    \r\n\x05\x04\x0e\x02\0\x08\x12\x04\xae\x01&7\n\r\n\x05\x04\x0e\x02\0\x07\
    \x12\x04\xae\x0116\n\x0c\n\x04\x04\x0e\x02\x01\x12\x04\xaf\x01\x08Q\n\r\
    \n\x05\x04\x0e\x02\x01\x04\x12\x04\xaf\x01\x08\x10\n\r\n\x05\x04\x0e\x02\
    \x01\x06\x12\x04\xaf\x01\x115\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\xaf\
    \x016J\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xaf\x01MP\n\x0b\n\x03\x04\
    \x0e\x05\x12\x04\xb1\x01\x08\x1f\n\x0c\n\x04\x04\x0e\x05\0\x12\x04\xb1\
    \x01\x13\x1e\n\r\n\x05\x04\x0e\x05\0\x01\x12\x04\xb1\x01\x13\x17\n\r\n\
    \x05\x04\x0e\x05\0\x02\x12\x04\xb1\x01\x1b\x1e\n\x0c\n\x02\x04\x0f\x12\
    \x06\xb4\x01\0\xb9\x01\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\xb4\x01\x08\
    \x15\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\xb5\x01\x088\n\r\n\x05\x04\x0f\
    \x02\0\x04\x12\x04\xb5\x01\x08\x10\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\
    \xb5\x01\x11\x15\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xb5\x01\x16\x20\n\r\
    \n\x05\x04\x0f\x02\0\x03\x12\x04\xb5\x01#%\n\r\n\x05\x04\x0f\x02\0\x08\
    \x12\x04\xb5\x01&7\n\r\n\x05\x04\x0f\x02\0\x07\x12\x04\xb5\x0116\n\x0c\n\
    \x04\x04\x0f\x02\x01\x12\x04\xb6\x01\x08Q\n\r\n\x05\x04\x0f\x02\x01\x04\
    \x12\x04\xb6\x01\x08\x10\n\r\n\x05\x04\x0f\x02\x01\x06\x12\x04\xb6\x01\
    \x115\n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\xb6\x016J\n\r\n\x05\x04\x0f\
    \x02\x01\x03\x12\x04\xb6\x01MP\n\x0b\n\x03\x04\x0f\x05\x12\x04\xb8\x01\
    \x08\x1f\n\x0c\n\x04\x04\x0f\x05\0\x12\x04\xb8\x01\x13\x1e\n\r\n\x05\x04\
    \x0f\x05\0\x01\x12\x04\xb8\x01\x13\x17\n\r\n\x05\x04\x0f\x05\0\x02\x12\
    \x04\xb8\x01\x1b\x1e\n\x0c\n\x02\x04\x10\x12\x06\xbb\x01\0\xc8\x01\x01\n\
    \x0b\n\x03\x04\x10\x01\x12\x04\xbb\x01\x08\x1b\n\x0e\n\x04\x04\x10\x03\0\
    \x12\x06\xbc\x01\x08\xbf\x01\t\n\r\n\x05\x04\x10\x03\0\x01\x12\x04\xbc\
    \x01\x10\x18\n\x0e\n\x06\x04\x10\x03\0\x02\0\x12\x04\xbd\x01\x10.\n\x0f\
    \n\x07\x04\x10\x03\0\x02\0\x04\x12\x04\xbd\x01\x10\x18\n\x0f\n\x07\x04\
    \x10\x03\0\x02\0\x05\x12\x04\xbd\x01\x19\x1f\n\x0f\n\x07\x04\x10\x03\0\
    \x02\0\x01\x12\x04\xbd\x01\x20)\n\x0f\n\x07\x04\x10\x03\0\x02\0\x03\x12\
    \x04\xbd\x01,-\n\x0e\n\x06\x04\x10\x03\0\x02\x01\x12\x04\xbe\x01\x10/\n\
    \x0f\n\x07\x04\x10\x03\0\x02\x01\x04\x12\x04\xbe\x01\x10\x18\n\x0f\n\x07\
    \x04\x10\x03\0\x02\x01\x05\x12\x04\xbe\x01\x19\x1d\n\x0f\n\x07\x04\x10\
    \x03\0\x02\x01\x01\x12\x04\xbe\x01\x1e*\n\x0f\n\x07\x04\x10\x03\0\x02\
    \x01\x03\x12\x04\xbe\x01-.\n\x0c\n\x04\x04\x10\x02\0\x12\x04\xc1\x01\x08\
    H\n\r\n\x05\x04\x10\x02\0\x04\x12\x04\xc1\x01\x08\x10\n\r\n\x05\x04\x10\
    \x02\0\x06\x12\x04\xc1\x01\x11>\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xc1\
    \x01?C\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xc1\x01FG\n\x0c\n\x04\x04\x10\
    \x02\x01\x12\x04\xc2\x01\x08-\n\r\n\x05\x04\x10\x02\x01\x04\x12\x04\xc2\
    \x01\x08\x10\n\r\n\x05\x04\x10\x02\x01\x05\x12\x04\xc2\x01\x11\x17\n\r\n\
    \x05\x04\x10\x02\x01\x01\x12\x04\xc2\x01\x18(\n\r\n\x05\x04\x10\x02\x01\
    \x03\x12\x04\xc2\x01+,\n\x0c\n\x04\x04\x10\x02\x02\x12\x04\xc3\x01\x08/\
    \n\r\n\x05\x04\x10\x02\x02\x04\x12\x04\xc3\x01\x08\x10\n\r\n\x05\x04\x10\
    \x02\x02\x05\x12\x04\xc3\x01\x11\x17\n\r\n\x05\x04\x10\x02\x02\x01\x12\
    \x04\xc3\x01\x18*\n\r\n\x05\x04\x10\x02\x02\x03\x12\x04\xc3\x01-.\n\x0c\
    \n\x04\x04\x10\x02\x03\x12\x04\xc4\x01\x08.\n\r\n\x05\x04\x10\x02\x03\
    \x04\x12\x04\xc4\x01\x08\x10\n\r\n\x05\x04\x10\x02\x03\x05\x12\x04\xc4\
    \x01\x11\x16\n\r\n\x05\x04\x10\x02\x03\x01\x12\x04\xc4\x01\x17)\n\r\n\
    \x05\x04\x10\x02\x03\x03\x12\x04\xc4\x01,-\n\x0c\n\x04\x04\x10\x02\x04\
    \x12\x04\xc5\x01\x08)\n\r\n\x05\x04\x10\x02\x04\x04\x12\x04\xc5\x01\x08\
    \x10\n\r\n\x05\x04\x10\x02\x04\x05\x12\x04\xc5\x01\x11\x17\n\r\n\x05\x04\
    \x10\x02\x04\x01\x12\x04\xc5\x01\x18$\n\r\n\x05\x04\x10\x02\x04\x03\x12\
    \x04\xc5\x01'(\n\x0c\n\x04\x04\x10\x02\x05\x12\x04\xc6\x01\x08(\n\r\n\
    \x05\x04\x10\x02\x05\x04\x12\x04\xc6\x01\x08\x10\n\r\n\x05\x04\x10\x02\
    \x05\x05\x12\x04\xc6\x01\x11\x16\n\r\n\x05\x04\x10\x02\x05\x01\x12\x04\
    \xc6\x01\x17#\n\r\n\x05\x04\x10\x02\x05\x03\x12\x04\xc6\x01&'\n\x0c\n\
    \x04\x04\x10\x02\x06\x12\x04\xc7\x01\x08,\n\r\n\x05\x04\x10\x02\x06\x04\
    \x12\x04\xc7\x01\x08\x10\n\r\n\x05\x04\x10\x02\x06\x05\x12\x04\xc7\x01\
    \x11\x17\n\r\n\x05\x04\x10\x02\x06\x01\x12\x04\xc7\x01\x18'\n\r\n\x05\
    \x04\x10\x02\x06\x03\x12\x04\xc7\x01*+\n\x0c\n\x02\x04\x11\x12\x06\xca\
    \x01\0\xd3\x01\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\xca\x01\x08\x16\n\x0e\
    \n\x04\x04\x11\x03\0\x12\x06\xcb\x01\x08\xd0\x01\t\n\r\n\x05\x04\x11\x03\
    \0\x01\x12\x04\xcb\x01\x10\x18\n\x0e\n\x06\x04\x11\x03\0\x02\0\x12\x04\
    \xcc\x01\x108\n\x0f\n\x07\x04\x11\x03\0\x02\0\x04\x12\x04\xcc\x01\x10\
    \x18\n\x0f\n\x07\x04\x11\x03\0\x02\0\x05\x12\x04\xcc\x01\x19\x1e\n\x0f\n\
    \x07\x04\x11\x03\0\x02\0\x01\x12\x04\xcc\x01\x1f#\n\x0f\n\x07\x04\x11\
    \x03\0\x02\0\x03\x12\x04\xcc\x01&'\n\x0f\n\x07\x04\x11\x03\0\x02\0\x08\
    \x12\x04\xcc\x01(7\n\x10\n\x08\x04\x11\x03\0\x02\0\x08\x02\x12\x04\xcc\
    \x01)6\n\x0e\n\x06\x04\x11\x03\0\x02\x01\x12\x04\xcd\x01\x108\n\x0f\n\
    \x07\x04\x11\x03\0\x02\x01\x04\x12\x04\xcd\x01\x10\x18\n\x0f\n\x07\x04\
    \x11\x03\0\x02\x01\x05\x12\x04\xcd\x01\x19\x1e\n\x0f\n\x07\x04\x11\x03\0\
    \x02\x01\x01\x12\x04\xcd\x01\x1f#\n\x0f\n\x07\x04\x11\x03\0\x02\x01\x03\
    \x12\x04\xcd\x01&'\n\x0f\n\x07\x04\x11\x03\0\x02\x01\x08\x12\x04\xcd\x01\
    (7\n\x10\n\x08\x04\x11\x03\0\x02\x01\x08\x02\x12\x04\xcd\x01)6\n\x0e\n\
    \x06\x04\x11\x03\0\x02\x02\x12\x04\xce\x01\x105\n\x0f\n\x07\x04\x11\x03\
    \0\x02\x02\x04\x12\x04\xce\x01\x10\x18\n\x0f\n\x07\x04\x11\x03\0\x02\x02\
    \x05\x12\x04\xce\x01\x19\x1f\n\x0f\n\x07\x04\x11\x03\0\x02\x02\x01\x12\
    \x04\xce\x01\x200\n\x0f\n\x07\x04\x11\x03\0\x02\x02\x03\x12\x04\xce\x013\
    4\n\x0e\n\x06\x04\x11\x03\0\x02\x03\x12\x04\xcf\x01\x106\n\x0f\n\x07\x04\
    \x11\x03\0\x02\x03\x04\x12\x04\xcf\x01\x10\x18\n\x0f\n\x07\x04\x11\x03\0\
    \x02\x03\x05\x12\x04\xcf\x01\x19\x1f\n\x0f\n\x07\x04\x11\x03\0\x02\x03\
    \x01\x12\x04\xcf\x01\x201\n\x0f\n\x07\x04\x11\x03\0\x02\x03\x03\x12\x04\
    \xcf\x0145\n\x0c\n\x04\x04\x11\x02\0\x12\x04\xd2\x01\x08G\n\r\n\x05\x04\
    \x11\x02\0\x04\x12\x04\xd2\x01\x08\x10\n\r\n\x05\x04\x11\x02\0\x06\x12\
    \x04\xd2\x01\x119\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xd2\x01:B\n\r\n\
    \x05\x04\x11\x02\0\x03\x12\x04\xd2\x01EF\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(21);
            messages.push(FileDescriptorSet::generated_message_descriptor_data());
            messages.push(FileDescriptorProto::generated_message_descriptor_data());
            messages.push(DescriptorProto::generated_message_descriptor_data());
            messages.push(FieldDescriptorProto::generated_message_descriptor_data());
            messages.push(OneofDescriptorProto::generated_message_descriptor_data());
            messages.push(EnumDescriptorProto::generated_message_descriptor_data());
            messages.push(EnumValueDescriptorProto::generated_message_descriptor_data());
            messages.push(ServiceDescriptorProto::generated_message_descriptor_data());
            messages.push(MethodDescriptorProto::generated_message_descriptor_data());
            messages.push(FileOptions::generated_message_descriptor_data());
            messages.push(MessageOptions::generated_message_descriptor_data());
            messages.push(FieldOptions::generated_message_descriptor_data());
            messages.push(EnumOptions::generated_message_descriptor_data());
            messages.push(EnumValueOptions::generated_message_descriptor_data());
            messages.push(ServiceOptions::generated_message_descriptor_data());
            messages.push(MethodOptions::generated_message_descriptor_data());
            messages.push(UninterpretedOption::generated_message_descriptor_data());
            messages.push(SourceCodeInfo::generated_message_descriptor_data());
            messages.push(descriptor_proto::ExtensionRange::generated_message_descriptor_data());
            messages.push(uninterpreted_option::NamePart::generated_message_descriptor_data());
            messages.push(source_code_info::Location::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(4);
            enums.push(field_descriptor_proto::Type::generated_enum_descriptor_data());
            enums.push(field_descriptor_proto::Label::generated_enum_descriptor_data());
            enums.push(file_options::OptimizeMode::generated_enum_descriptor_data());
            enums.push(field_options::CType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
