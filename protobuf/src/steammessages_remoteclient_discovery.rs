// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_remoteclient_discovery.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:CMsgRemoteClientBroadcastHeader)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteClientBroadcastHeader {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastHeader.client_id)
    pub client_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastHeader.msg_type)
    pub msg_type: ::std::option::Option<::protobuf::EnumOrUnknown<ERemoteClientBroadcastMsg>>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastHeader.instance_id)
    pub instance_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastHeader.device_id)
    pub device_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastHeader.device_token)
    pub device_token: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteClientBroadcastHeader.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteClientBroadcastHeader {
    fn default() -> &'a CMsgRemoteClientBroadcastHeader {
        <CMsgRemoteClientBroadcastHeader as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteClientBroadcastHeader {
    pub fn new() -> CMsgRemoteClientBroadcastHeader {
        ::std::default::Default::default()
    }

    // optional uint64 client_id = 1;

    pub fn client_id(&self) -> u64 {
        self.client_id.unwrap_or(0)
    }

    pub fn clear_client_id(&mut self) {
        self.client_id = ::std::option::Option::None;
    }

    pub fn has_client_id(&self) -> bool {
        self.client_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_id(&mut self, v: u64) {
        self.client_id = ::std::option::Option::Some(v);
    }

    // optional .ERemoteClientBroadcastMsg msg_type = 2;

    pub fn msg_type(&self) -> ERemoteClientBroadcastMsg {
        match self.msg_type {
            Some(e) => e.enum_value_or(ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgDiscovery),
            None => ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgDiscovery,
        }
    }

    pub fn clear_msg_type(&mut self) {
        self.msg_type = ::std::option::Option::None;
    }

    pub fn has_msg_type(&self) -> bool {
        self.msg_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_type(&mut self, v: ERemoteClientBroadcastMsg) {
        self.msg_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 instance_id = 3;

    pub fn instance_id(&self) -> u64 {
        self.instance_id.unwrap_or(0)
    }

    pub fn clear_instance_id(&mut self) {
        self.instance_id = ::std::option::Option::None;
    }

    pub fn has_instance_id(&self) -> bool {
        self.instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance_id(&mut self, v: u64) {
        self.instance_id = ::std::option::Option::Some(v);
    }

    // optional uint64 device_id = 4;

    pub fn device_id(&self) -> u64 {
        self.device_id.unwrap_or(0)
    }

    pub fn clear_device_id(&mut self) {
        self.device_id = ::std::option::Option::None;
    }

    pub fn has_device_id(&self) -> bool {
        self.device_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_id(&mut self, v: u64) {
        self.device_id = ::std::option::Option::Some(v);
    }

    // optional bytes device_token = 5;

    pub fn device_token(&self) -> &[u8] {
        match self.device_token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_device_token(&mut self) {
        self.device_token = ::std::option::Option::None;
    }

    pub fn has_device_token(&self) -> bool {
        self.device_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.device_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.device_token.is_none() {
            self.device_token = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.device_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_token(&mut self) -> ::std::vec::Vec<u8> {
        self.device_token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_id",
            |m: &CMsgRemoteClientBroadcastHeader| { &m.client_id },
            |m: &mut CMsgRemoteClientBroadcastHeader| { &mut m.client_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msg_type",
            |m: &CMsgRemoteClientBroadcastHeader| { &m.msg_type },
            |m: &mut CMsgRemoteClientBroadcastHeader| { &mut m.msg_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "instance_id",
            |m: &CMsgRemoteClientBroadcastHeader| { &m.instance_id },
            |m: &mut CMsgRemoteClientBroadcastHeader| { &mut m.instance_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "device_id",
            |m: &CMsgRemoteClientBroadcastHeader| { &m.device_id },
            |m: &mut CMsgRemoteClientBroadcastHeader| { &mut m.device_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "device_token",
            |m: &CMsgRemoteClientBroadcastHeader| { &m.device_token },
            |m: &mut CMsgRemoteClientBroadcastHeader| { &mut m.device_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRemoteClientBroadcastHeader>(
            "CMsgRemoteClientBroadcastHeader",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRemoteClientBroadcastHeader {
    const NAME: &'static str = "CMsgRemoteClientBroadcastHeader";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.client_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.msg_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.instance_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.device_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                42 => {
                    self.device_token = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.client_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.msg_type {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.instance_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.device_id {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.device_token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.client_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.msg_type {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.instance_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.device_id {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.device_token.as_ref() {
            os.write_bytes(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteClientBroadcastHeader {
        CMsgRemoteClientBroadcastHeader::new()
    }

    fn clear(&mut self) {
        self.client_id = ::std::option::Option::None;
        self.msg_type = ::std::option::Option::None;
        self.instance_id = ::std::option::Option::None;
        self.device_id = ::std::option::Option::None;
        self.device_token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteClientBroadcastHeader {
        static instance: CMsgRemoteClientBroadcastHeader = CMsgRemoteClientBroadcastHeader {
            client_id: ::std::option::Option::None,
            msg_type: ::std::option::Option::None,
            instance_id: ::std::option::Option::None,
            device_id: ::std::option::Option::None,
            device_token: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRemoteClientBroadcastHeader {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRemoteClientBroadcastHeader").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRemoteClientBroadcastHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteClientBroadcastHeader {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgRemoteClientBroadcastStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteClientBroadcastStatus {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.version)
    pub version: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.min_version)
    pub min_version: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.connect_port)
    pub connect_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.hostname)
    pub hostname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.enabled_services)
    pub enabled_services: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.ostype)
    pub ostype: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.is64bit)
    pub is64bit: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.users)
    pub users: ::std::vec::Vec<cmsg_remote_client_broadcast_status::User>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.euniverse)
    pub euniverse: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.screen_locked)
    pub screen_locked: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.games_running)
    pub games_running: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.mac_addresses)
    pub mac_addresses: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.download_lan_peer_group)
    pub download_lan_peer_group: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.broadcasting_active)
    pub broadcasting_active: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.vr_active)
    pub vr_active: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.content_cache_port)
    pub content_cache_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.ip_addresses)
    pub ip_addresses: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.public_ip_address)
    pub public_ip_address: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.remoteplay_active)
    pub remoteplay_active: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteClientBroadcastStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteClientBroadcastStatus {
    fn default() -> &'a CMsgRemoteClientBroadcastStatus {
        <CMsgRemoteClientBroadcastStatus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteClientBroadcastStatus {
    pub fn new() -> CMsgRemoteClientBroadcastStatus {
        ::std::default::Default::default()
    }

    // optional int32 version = 1;

    pub fn version(&self) -> i32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional int32 min_version = 2;

    pub fn min_version(&self) -> i32 {
        self.min_version.unwrap_or(0)
    }

    pub fn clear_min_version(&mut self) {
        self.min_version = ::std::option::Option::None;
    }

    pub fn has_min_version(&self) -> bool {
        self.min_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_version(&mut self, v: i32) {
        self.min_version = ::std::option::Option::Some(v);
    }

    // optional uint32 connect_port = 3;

    pub fn connect_port(&self) -> u32 {
        self.connect_port.unwrap_or(0)
    }

    pub fn clear_connect_port(&mut self) {
        self.connect_port = ::std::option::Option::None;
    }

    pub fn has_connect_port(&self) -> bool {
        self.connect_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connect_port(&mut self, v: u32) {
        self.connect_port = ::std::option::Option::Some(v);
    }

    // optional string hostname = 4;

    pub fn hostname(&self) -> &str {
        match self.hostname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_hostname(&mut self) {
        self.hostname = ::std::option::Option::None;
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&mut self) -> &mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 enabled_services = 6;

    pub fn enabled_services(&self) -> u32 {
        self.enabled_services.unwrap_or(0)
    }

    pub fn clear_enabled_services(&mut self) {
        self.enabled_services = ::std::option::Option::None;
    }

    pub fn has_enabled_services(&self) -> bool {
        self.enabled_services.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enabled_services(&mut self, v: u32) {
        self.enabled_services = ::std::option::Option::Some(v);
    }

    // optional int32 ostype = 7;

    pub fn ostype(&self) -> i32 {
        self.ostype.unwrap_or(0i32)
    }

    pub fn clear_ostype(&mut self) {
        self.ostype = ::std::option::Option::None;
    }

    pub fn has_ostype(&self) -> bool {
        self.ostype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ostype(&mut self, v: i32) {
        self.ostype = ::std::option::Option::Some(v);
    }

    // optional bool is64bit = 8;

    pub fn is64bit(&self) -> bool {
        self.is64bit.unwrap_or(false)
    }

    pub fn clear_is64bit(&mut self) {
        self.is64bit = ::std::option::Option::None;
    }

    pub fn has_is64bit(&self) -> bool {
        self.is64bit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is64bit(&mut self, v: bool) {
        self.is64bit = ::std::option::Option::Some(v);
    }

    // optional int32 euniverse = 11;

    pub fn euniverse(&self) -> i32 {
        self.euniverse.unwrap_or(0)
    }

    pub fn clear_euniverse(&mut self) {
        self.euniverse = ::std::option::Option::None;
    }

    pub fn has_euniverse(&self) -> bool {
        self.euniverse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_euniverse(&mut self, v: i32) {
        self.euniverse = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 12;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional bool screen_locked = 13;

    pub fn screen_locked(&self) -> bool {
        self.screen_locked.unwrap_or(false)
    }

    pub fn clear_screen_locked(&mut self) {
        self.screen_locked = ::std::option::Option::None;
    }

    pub fn has_screen_locked(&self) -> bool {
        self.screen_locked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screen_locked(&mut self, v: bool) {
        self.screen_locked = ::std::option::Option::Some(v);
    }

    // optional bool games_running = 14;

    pub fn games_running(&self) -> bool {
        self.games_running.unwrap_or(false)
    }

    pub fn clear_games_running(&mut self) {
        self.games_running = ::std::option::Option::None;
    }

    pub fn has_games_running(&self) -> bool {
        self.games_running.is_some()
    }

    // Param is passed by value, moved
    pub fn set_games_running(&mut self, v: bool) {
        self.games_running = ::std::option::Option::Some(v);
    }

    // optional uint32 download_lan_peer_group = 16;

    pub fn download_lan_peer_group(&self) -> u32 {
        self.download_lan_peer_group.unwrap_or(0)
    }

    pub fn clear_download_lan_peer_group(&mut self) {
        self.download_lan_peer_group = ::std::option::Option::None;
    }

    pub fn has_download_lan_peer_group(&self) -> bool {
        self.download_lan_peer_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_lan_peer_group(&mut self, v: u32) {
        self.download_lan_peer_group = ::std::option::Option::Some(v);
    }

    // optional bool broadcasting_active = 17;

    pub fn broadcasting_active(&self) -> bool {
        self.broadcasting_active.unwrap_or(false)
    }

    pub fn clear_broadcasting_active(&mut self) {
        self.broadcasting_active = ::std::option::Option::None;
    }

    pub fn has_broadcasting_active(&self) -> bool {
        self.broadcasting_active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcasting_active(&mut self, v: bool) {
        self.broadcasting_active = ::std::option::Option::Some(v);
    }

    // optional bool vr_active = 18;

    pub fn vr_active(&self) -> bool {
        self.vr_active.unwrap_or(false)
    }

    pub fn clear_vr_active(&mut self) {
        self.vr_active = ::std::option::Option::None;
    }

    pub fn has_vr_active(&self) -> bool {
        self.vr_active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vr_active(&mut self, v: bool) {
        self.vr_active = ::std::option::Option::Some(v);
    }

    // optional uint32 content_cache_port = 19;

    pub fn content_cache_port(&self) -> u32 {
        self.content_cache_port.unwrap_or(0)
    }

    pub fn clear_content_cache_port(&mut self) {
        self.content_cache_port = ::std::option::Option::None;
    }

    pub fn has_content_cache_port(&self) -> bool {
        self.content_cache_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_content_cache_port(&mut self, v: u32) {
        self.content_cache_port = ::std::option::Option::Some(v);
    }

    // optional string public_ip_address = 21;

    pub fn public_ip_address(&self) -> &str {
        match self.public_ip_address.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_public_ip_address(&mut self) {
        self.public_ip_address = ::std::option::Option::None;
    }

    pub fn has_public_ip_address(&self) -> bool {
        self.public_ip_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_ip_address(&mut self, v: ::std::string::String) {
        self.public_ip_address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_ip_address(&mut self) -> &mut ::std::string::String {
        if self.public_ip_address.is_none() {
            self.public_ip_address = ::std::option::Option::Some(::std::string::String::new());
        }
        self.public_ip_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_public_ip_address(&mut self) -> ::std::string::String {
        self.public_ip_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool remoteplay_active = 22;

    pub fn remoteplay_active(&self) -> bool {
        self.remoteplay_active.unwrap_or(false)
    }

    pub fn clear_remoteplay_active(&mut self) {
        self.remoteplay_active = ::std::option::Option::None;
    }

    pub fn has_remoteplay_active(&self) -> bool {
        self.remoteplay_active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remoteplay_active(&mut self, v: bool) {
        self.remoteplay_active = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(20);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.version },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "min_version",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.min_version },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.min_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "connect_port",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.connect_port },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.connect_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hostname",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.hostname },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.hostname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "enabled_services",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.enabled_services },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.enabled_services },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ostype",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.ostype },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.ostype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is64bit",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.is64bit },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.is64bit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "users",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.users },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.users },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "euniverse",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.euniverse },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.euniverse },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.timestamp },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "screen_locked",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.screen_locked },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.screen_locked },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "games_running",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.games_running },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.games_running },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "mac_addresses",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.mac_addresses },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.mac_addresses },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "download_lan_peer_group",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.download_lan_peer_group },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.download_lan_peer_group },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcasting_active",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.broadcasting_active },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.broadcasting_active },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vr_active",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.vr_active },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.vr_active },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "content_cache_port",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.content_cache_port },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.content_cache_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ip_addresses",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.ip_addresses },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.ip_addresses },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "public_ip_address",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.public_ip_address },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.public_ip_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "remoteplay_active",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.remoteplay_active },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.remoteplay_active },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRemoteClientBroadcastStatus>(
            "CMsgRemoteClientBroadcastStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRemoteClientBroadcastStatus {
    const NAME: &'static str = "CMsgRemoteClientBroadcastStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.min_version = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.connect_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.hostname = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.enabled_services = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.ostype = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.is64bit = ::std::option::Option::Some(is.read_bool()?);
                },
                74 => {
                    self.users.push(is.read_message()?);
                },
                88 => {
                    self.euniverse = ::std::option::Option::Some(is.read_int32()?);
                },
                96 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.screen_locked = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.games_running = ::std::option::Option::Some(is.read_bool()?);
                },
                122 => {
                    self.mac_addresses.push(is.read_string()?);
                },
                128 => {
                    self.download_lan_peer_group = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.broadcasting_active = ::std::option::Option::Some(is.read_bool()?);
                },
                144 => {
                    self.vr_active = ::std::option::Option::Some(is.read_bool()?);
                },
                152 => {
                    self.content_cache_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                162 => {
                    self.ip_addresses.push(is.read_string()?);
                },
                170 => {
                    self.public_ip_address = ::std::option::Option::Some(is.read_string()?);
                },
                176 => {
                    self.remoteplay_active = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.min_version {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.connect_port {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.hostname.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.enabled_services {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.ostype {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.is64bit {
            my_size += 1 + 1;
        }
        for value in &self.users {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.euniverse {
            my_size += ::protobuf::rt::int32_size(11, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.screen_locked {
            my_size += 1 + 1;
        }
        if let Some(v) = self.games_running {
            my_size += 1 + 1;
        }
        for value in &self.mac_addresses {
            my_size += ::protobuf::rt::string_size(15, &value);
        };
        if let Some(v) = self.download_lan_peer_group {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.broadcasting_active {
            my_size += 2 + 1;
        }
        if let Some(v) = self.vr_active {
            my_size += 2 + 1;
        }
        if let Some(v) = self.content_cache_port {
            my_size += ::protobuf::rt::uint32_size(19, v);
        }
        for value in &self.ip_addresses {
            my_size += ::protobuf::rt::string_size(20, &value);
        };
        if let Some(v) = self.public_ip_address.as_ref() {
            my_size += ::protobuf::rt::string_size(21, &v);
        }
        if let Some(v) = self.remoteplay_active {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.min_version {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.connect_port {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.hostname.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.enabled_services {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.ostype {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.is64bit {
            os.write_bool(8, v)?;
        }
        for v in &self.users {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        if let Some(v) = self.euniverse {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.screen_locked {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.games_running {
            os.write_bool(14, v)?;
        }
        for v in &self.mac_addresses {
            os.write_string(15, &v)?;
        };
        if let Some(v) = self.download_lan_peer_group {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.broadcasting_active {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.vr_active {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.content_cache_port {
            os.write_uint32(19, v)?;
        }
        for v in &self.ip_addresses {
            os.write_string(20, &v)?;
        };
        if let Some(v) = self.public_ip_address.as_ref() {
            os.write_string(21, v)?;
        }
        if let Some(v) = self.remoteplay_active {
            os.write_bool(22, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteClientBroadcastStatus {
        CMsgRemoteClientBroadcastStatus::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.min_version = ::std::option::Option::None;
        self.connect_port = ::std::option::Option::None;
        self.hostname = ::std::option::Option::None;
        self.enabled_services = ::std::option::Option::None;
        self.ostype = ::std::option::Option::None;
        self.is64bit = ::std::option::Option::None;
        self.users.clear();
        self.euniverse = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.screen_locked = ::std::option::Option::None;
        self.games_running = ::std::option::Option::None;
        self.mac_addresses.clear();
        self.download_lan_peer_group = ::std::option::Option::None;
        self.broadcasting_active = ::std::option::Option::None;
        self.vr_active = ::std::option::Option::None;
        self.content_cache_port = ::std::option::Option::None;
        self.ip_addresses.clear();
        self.public_ip_address = ::std::option::Option::None;
        self.remoteplay_active = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteClientBroadcastStatus {
        static instance: CMsgRemoteClientBroadcastStatus = CMsgRemoteClientBroadcastStatus {
            version: ::std::option::Option::None,
            min_version: ::std::option::Option::None,
            connect_port: ::std::option::Option::None,
            hostname: ::std::option::Option::None,
            enabled_services: ::std::option::Option::None,
            ostype: ::std::option::Option::None,
            is64bit: ::std::option::Option::None,
            users: ::std::vec::Vec::new(),
            euniverse: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            screen_locked: ::std::option::Option::None,
            games_running: ::std::option::Option::None,
            mac_addresses: ::std::vec::Vec::new(),
            download_lan_peer_group: ::std::option::Option::None,
            broadcasting_active: ::std::option::Option::None,
            vr_active: ::std::option::Option::None,
            content_cache_port: ::std::option::Option::None,
            ip_addresses: ::std::vec::Vec::new(),
            public_ip_address: ::std::option::Option::None,
            remoteplay_active: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRemoteClientBroadcastStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRemoteClientBroadcastStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRemoteClientBroadcastStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteClientBroadcastStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgRemoteClientBroadcastStatus`
pub mod cmsg_remote_client_broadcast_status {
    // @@protoc_insertion_point(message:CMsgRemoteClientBroadcastStatus.User)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct User {
        // message fields
        // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.User.steamid)
        pub steamid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.User.auth_key_id)
        pub auth_key_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgRemoteClientBroadcastStatus.User.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a User {
        fn default() -> &'a User {
            <User as ::protobuf::Message>::default_instance()
        }
    }

    impl User {
        pub fn new() -> User {
            ::std::default::Default::default()
        }

        // optional fixed64 steamid = 1;

        pub fn steamid(&self) -> u64 {
            self.steamid.unwrap_or(0)
        }

        pub fn clear_steamid(&mut self) {
            self.steamid = ::std::option::Option::None;
        }

        pub fn has_steamid(&self) -> bool {
            self.steamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid(&mut self, v: u64) {
            self.steamid = ::std::option::Option::Some(v);
        }

        // optional uint32 auth_key_id = 2;

        pub fn auth_key_id(&self) -> u32 {
            self.auth_key_id.unwrap_or(0)
        }

        pub fn clear_auth_key_id(&mut self) {
            self.auth_key_id = ::std::option::Option::None;
        }

        pub fn has_auth_key_id(&self) -> bool {
            self.auth_key_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_auth_key_id(&mut self, v: u32) {
            self.auth_key_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "steamid",
                |m: &User| { &m.steamid },
                |m: &mut User| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "auth_key_id",
                |m: &User| { &m.auth_key_id },
                |m: &mut User| { &mut m.auth_key_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<User>(
                "CMsgRemoteClientBroadcastStatus.User",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for User {
        const NAME: &'static str = "User";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.auth_key_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steamid {
                my_size += 1 + 8;
            }
            if let Some(v) = self.auth_key_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.steamid {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.auth_key_id {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> User {
            User::new()
        }

        fn clear(&mut self) {
            self.steamid = ::std::option::Option::None;
            self.auth_key_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static User {
            static instance: User = User {
                steamid: ::std::option::Option::None,
                auth_key_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for User {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgRemoteClientBroadcastStatus.User").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for User {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for User {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgRemoteClientBroadcastDiscovery)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteClientBroadcastDiscovery {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastDiscovery.seq_num)
    pub seq_num: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastDiscovery.client_ids)
    pub client_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteClientBroadcastDiscovery.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteClientBroadcastDiscovery {
    fn default() -> &'a CMsgRemoteClientBroadcastDiscovery {
        <CMsgRemoteClientBroadcastDiscovery as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteClientBroadcastDiscovery {
    pub fn new() -> CMsgRemoteClientBroadcastDiscovery {
        ::std::default::Default::default()
    }

    // optional uint32 seq_num = 1;

    pub fn seq_num(&self) -> u32 {
        self.seq_num.unwrap_or(0)
    }

    pub fn clear_seq_num(&mut self) {
        self.seq_num = ::std::option::Option::None;
    }

    pub fn has_seq_num(&self) -> bool {
        self.seq_num.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num(&mut self, v: u32) {
        self.seq_num = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seq_num",
            |m: &CMsgRemoteClientBroadcastDiscovery| { &m.seq_num },
            |m: &mut CMsgRemoteClientBroadcastDiscovery| { &mut m.seq_num },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "client_ids",
            |m: &CMsgRemoteClientBroadcastDiscovery| { &m.client_ids },
            |m: &mut CMsgRemoteClientBroadcastDiscovery| { &mut m.client_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRemoteClientBroadcastDiscovery>(
            "CMsgRemoteClientBroadcastDiscovery",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRemoteClientBroadcastDiscovery {
    const NAME: &'static str = "CMsgRemoteClientBroadcastDiscovery";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.seq_num = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.client_ids)?;
                },
                16 => {
                    self.client_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.seq_num {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.client_ids {
            my_size += ::protobuf::rt::uint64_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.seq_num {
            os.write_uint32(1, v)?;
        }
        for v in &self.client_ids {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteClientBroadcastDiscovery {
        CMsgRemoteClientBroadcastDiscovery::new()
    }

    fn clear(&mut self) {
        self.seq_num = ::std::option::Option::None;
        self.client_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteClientBroadcastDiscovery {
        static instance: CMsgRemoteClientBroadcastDiscovery = CMsgRemoteClientBroadcastDiscovery {
            seq_num: ::std::option::Option::None,
            client_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRemoteClientBroadcastDiscovery {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRemoteClientBroadcastDiscovery").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRemoteClientBroadcastDiscovery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteClientBroadcastDiscovery {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgRemoteClientBroadcastClientIDDeconflict)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteClientBroadcastClientIDDeconflict {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastClientIDDeconflict.client_ids)
    pub client_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteClientBroadcastClientIDDeconflict.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteClientBroadcastClientIDDeconflict {
    fn default() -> &'a CMsgRemoteClientBroadcastClientIDDeconflict {
        <CMsgRemoteClientBroadcastClientIDDeconflict as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteClientBroadcastClientIDDeconflict {
    pub fn new() -> CMsgRemoteClientBroadcastClientIDDeconflict {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "client_ids",
            |m: &CMsgRemoteClientBroadcastClientIDDeconflict| { &m.client_ids },
            |m: &mut CMsgRemoteClientBroadcastClientIDDeconflict| { &mut m.client_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRemoteClientBroadcastClientIDDeconflict>(
            "CMsgRemoteClientBroadcastClientIDDeconflict",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRemoteClientBroadcastClientIDDeconflict {
    const NAME: &'static str = "CMsgRemoteClientBroadcastClientIDDeconflict";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.client_ids)?;
                },
                16 => {
                    self.client_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.client_ids {
            my_size += ::protobuf::rt::uint64_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.client_ids {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteClientBroadcastClientIDDeconflict {
        CMsgRemoteClientBroadcastClientIDDeconflict::new()
    }

    fn clear(&mut self) {
        self.client_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteClientBroadcastClientIDDeconflict {
        static instance: CMsgRemoteClientBroadcastClientIDDeconflict = CMsgRemoteClientBroadcastClientIDDeconflict {
            client_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRemoteClientBroadcastClientIDDeconflict {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRemoteClientBroadcastClientIDDeconflict").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRemoteClientBroadcastClientIDDeconflict {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteClientBroadcastClientIDDeconflict {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgRemoteDeviceAuthorizationRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteDeviceAuthorizationRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationRequest.device_token)
    pub device_token: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationRequest.device_name)
    pub device_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationRequest.encrypted_request)
    pub encrypted_request: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteDeviceAuthorizationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceAuthorizationRequest {
    fn default() -> &'a CMsgRemoteDeviceAuthorizationRequest {
        <CMsgRemoteDeviceAuthorizationRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceAuthorizationRequest {
    pub fn new() -> CMsgRemoteDeviceAuthorizationRequest {
        ::std::default::Default::default()
    }

    // required bytes device_token = 1;

    pub fn device_token(&self) -> &[u8] {
        match self.device_token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_device_token(&mut self) {
        self.device_token = ::std::option::Option::None;
    }

    pub fn has_device_token(&self) -> bool {
        self.device_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.device_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.device_token.is_none() {
            self.device_token = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.device_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_token(&mut self) -> ::std::vec::Vec<u8> {
        self.device_token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string device_name = 2;

    pub fn device_name(&self) -> &str {
        match self.device_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_device_name(&mut self) {
        self.device_name = ::std::option::Option::None;
    }

    pub fn has_device_name(&self) -> bool {
        self.device_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_name(&mut self, v: ::std::string::String) {
        self.device_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_name(&mut self) -> &mut ::std::string::String {
        if self.device_name.is_none() {
            self.device_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.device_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_name(&mut self) -> ::std::string::String {
        self.device_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required bytes encrypted_request = 3;

    pub fn encrypted_request(&self) -> &[u8] {
        match self.encrypted_request.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_encrypted_request(&mut self) {
        self.encrypted_request = ::std::option::Option::None;
    }

    pub fn has_encrypted_request(&self) -> bool {
        self.encrypted_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encrypted_request(&mut self, v: ::std::vec::Vec<u8>) {
        self.encrypted_request = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encrypted_request(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.encrypted_request.is_none() {
            self.encrypted_request = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.encrypted_request.as_mut().unwrap()
    }

    // Take field
    pub fn take_encrypted_request(&mut self) -> ::std::vec::Vec<u8> {
        self.encrypted_request.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "device_token",
            |m: &CMsgRemoteDeviceAuthorizationRequest| { &m.device_token },
            |m: &mut CMsgRemoteDeviceAuthorizationRequest| { &mut m.device_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "device_name",
            |m: &CMsgRemoteDeviceAuthorizationRequest| { &m.device_name },
            |m: &mut CMsgRemoteDeviceAuthorizationRequest| { &mut m.device_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "encrypted_request",
            |m: &CMsgRemoteDeviceAuthorizationRequest| { &m.encrypted_request },
            |m: &mut CMsgRemoteDeviceAuthorizationRequest| { &mut m.encrypted_request },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRemoteDeviceAuthorizationRequest>(
            "CMsgRemoteDeviceAuthorizationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceAuthorizationRequest {
    const NAME: &'static str = "CMsgRemoteDeviceAuthorizationRequest";

    fn is_initialized(&self) -> bool {
        if self.device_token.is_none() {
            return false;
        }
        if self.encrypted_request.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.device_token = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.device_name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.encrypted_request = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.device_token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.device_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.encrypted_request.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.device_token.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.device_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.encrypted_request.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteDeviceAuthorizationRequest {
        CMsgRemoteDeviceAuthorizationRequest::new()
    }

    fn clear(&mut self) {
        self.device_token = ::std::option::Option::None;
        self.device_name = ::std::option::Option::None;
        self.encrypted_request = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteDeviceAuthorizationRequest {
        static instance: CMsgRemoteDeviceAuthorizationRequest = CMsgRemoteDeviceAuthorizationRequest {
            device_token: ::std::option::Option::None,
            device_name: ::std::option::Option::None,
            encrypted_request: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRemoteDeviceAuthorizationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRemoteDeviceAuthorizationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRemoteDeviceAuthorizationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteDeviceAuthorizationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgRemoteDeviceAuthorizationRequest`
pub mod cmsg_remote_device_authorization_request {
    // @@protoc_insertion_point(message:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CKeyEscrow_Ticket {
        // message fields
        // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.password)
        pub password: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.identifier)
        pub identifier: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.payload)
        pub payload: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.timestamp)
        pub timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.usage)
        pub usage: ::std::option::Option<::protobuf::EnumOrUnknown<EKeyEscrowUsage>>,
        // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.device_name)
        pub device_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.device_model)
        pub device_model: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.device_serial)
        pub device_serial: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.device_provisioning_id)
        pub device_provisioning_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CKeyEscrow_Ticket {
        fn default() -> &'a CKeyEscrow_Ticket {
            <CKeyEscrow_Ticket as ::protobuf::Message>::default_instance()
        }
    }

    impl CKeyEscrow_Ticket {
        pub fn new() -> CKeyEscrow_Ticket {
            ::std::default::Default::default()
        }

        // optional bytes password = 1;

        pub fn password(&self) -> &[u8] {
            match self.password.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_password(&mut self) {
            self.password = ::std::option::Option::None;
        }

        pub fn has_password(&self) -> bool {
            self.password.is_some()
        }

        // Param is passed by value, moved
        pub fn set_password(&mut self, v: ::std::vec::Vec<u8>) {
            self.password = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_password(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.password.is_none() {
                self.password = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.password.as_mut().unwrap()
        }

        // Take field
        pub fn take_password(&mut self) -> ::std::vec::Vec<u8> {
            self.password.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional uint64 identifier = 2;

        pub fn identifier(&self) -> u64 {
            self.identifier.unwrap_or(0)
        }

        pub fn clear_identifier(&mut self) {
            self.identifier = ::std::option::Option::None;
        }

        pub fn has_identifier(&self) -> bool {
            self.identifier.is_some()
        }

        // Param is passed by value, moved
        pub fn set_identifier(&mut self, v: u64) {
            self.identifier = ::std::option::Option::Some(v);
        }

        // optional bytes payload = 3;

        pub fn payload(&self) -> &[u8] {
            match self.payload.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_payload(&mut self) {
            self.payload = ::std::option::Option::None;
        }

        pub fn has_payload(&self) -> bool {
            self.payload.is_some()
        }

        // Param is passed by value, moved
        pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
            self.payload = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.payload.is_none() {
                self.payload = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.payload.as_mut().unwrap()
        }

        // Take field
        pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
            self.payload.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional uint32 timestamp = 4;

        pub fn timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        // optional .CMsgRemoteDeviceAuthorizationRequest.EKeyEscrowUsage usage = 5;

        pub fn usage(&self) -> EKeyEscrowUsage {
            match self.usage {
                Some(e) => e.enum_value_or(EKeyEscrowUsage::k_EKeyEscrowUsageStreamingDevice),
                None => EKeyEscrowUsage::k_EKeyEscrowUsageStreamingDevice,
            }
        }

        pub fn clear_usage(&mut self) {
            self.usage = ::std::option::Option::None;
        }

        pub fn has_usage(&self) -> bool {
            self.usage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_usage(&mut self, v: EKeyEscrowUsage) {
            self.usage = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional string device_name = 6;

        pub fn device_name(&self) -> &str {
            match self.device_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_device_name(&mut self) {
            self.device_name = ::std::option::Option::None;
        }

        pub fn has_device_name(&self) -> bool {
            self.device_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device_name(&mut self, v: ::std::string::String) {
            self.device_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_device_name(&mut self) -> &mut ::std::string::String {
            if self.device_name.is_none() {
                self.device_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.device_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_device_name(&mut self) -> ::std::string::String {
            self.device_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string device_model = 7;

        pub fn device_model(&self) -> &str {
            match self.device_model.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_device_model(&mut self) {
            self.device_model = ::std::option::Option::None;
        }

        pub fn has_device_model(&self) -> bool {
            self.device_model.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device_model(&mut self, v: ::std::string::String) {
            self.device_model = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_device_model(&mut self) -> &mut ::std::string::String {
            if self.device_model.is_none() {
                self.device_model = ::std::option::Option::Some(::std::string::String::new());
            }
            self.device_model.as_mut().unwrap()
        }

        // Take field
        pub fn take_device_model(&mut self) -> ::std::string::String {
            self.device_model.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string device_serial = 8;

        pub fn device_serial(&self) -> &str {
            match self.device_serial.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_device_serial(&mut self) {
            self.device_serial = ::std::option::Option::None;
        }

        pub fn has_device_serial(&self) -> bool {
            self.device_serial.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device_serial(&mut self, v: ::std::string::String) {
            self.device_serial = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_device_serial(&mut self) -> &mut ::std::string::String {
            if self.device_serial.is_none() {
                self.device_serial = ::std::option::Option::Some(::std::string::String::new());
            }
            self.device_serial.as_mut().unwrap()
        }

        // Take field
        pub fn take_device_serial(&mut self) -> ::std::string::String {
            self.device_serial.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 device_provisioning_id = 9;

        pub fn device_provisioning_id(&self) -> u32 {
            self.device_provisioning_id.unwrap_or(0)
        }

        pub fn clear_device_provisioning_id(&mut self) {
            self.device_provisioning_id = ::std::option::Option::None;
        }

        pub fn has_device_provisioning_id(&self) -> bool {
            self.device_provisioning_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device_provisioning_id(&mut self, v: u32) {
            self.device_provisioning_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(9);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "password",
                |m: &CKeyEscrow_Ticket| { &m.password },
                |m: &mut CKeyEscrow_Ticket| { &mut m.password },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "identifier",
                |m: &CKeyEscrow_Ticket| { &m.identifier },
                |m: &mut CKeyEscrow_Ticket| { &mut m.identifier },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "payload",
                |m: &CKeyEscrow_Ticket| { &m.payload },
                |m: &mut CKeyEscrow_Ticket| { &mut m.payload },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "timestamp",
                |m: &CKeyEscrow_Ticket| { &m.timestamp },
                |m: &mut CKeyEscrow_Ticket| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "usage",
                |m: &CKeyEscrow_Ticket| { &m.usage },
                |m: &mut CKeyEscrow_Ticket| { &mut m.usage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "device_name",
                |m: &CKeyEscrow_Ticket| { &m.device_name },
                |m: &mut CKeyEscrow_Ticket| { &mut m.device_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "device_model",
                |m: &CKeyEscrow_Ticket| { &m.device_model },
                |m: &mut CKeyEscrow_Ticket| { &mut m.device_model },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "device_serial",
                |m: &CKeyEscrow_Ticket| { &m.device_serial },
                |m: &mut CKeyEscrow_Ticket| { &mut m.device_serial },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "device_provisioning_id",
                |m: &CKeyEscrow_Ticket| { &m.device_provisioning_id },
                |m: &mut CKeyEscrow_Ticket| { &mut m.device_provisioning_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CKeyEscrow_Ticket>(
                "CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CKeyEscrow_Ticket {
        const NAME: &'static str = "CKeyEscrow_Ticket";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.password = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    16 => {
                        self.identifier = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    26 => {
                        self.payload = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    32 => {
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.usage = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    50 => {
                        self.device_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    58 => {
                        self.device_model = ::std::option::Option::Some(is.read_string()?);
                    },
                    66 => {
                        self.device_serial = ::std::option::Option::Some(is.read_string()?);
                    },
                    72 => {
                        self.device_provisioning_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.password.as_ref() {
                my_size += ::protobuf::rt::bytes_size(1, &v);
            }
            if let Some(v) = self.identifier {
                my_size += ::protobuf::rt::uint64_size(2, v);
            }
            if let Some(v) = self.payload.as_ref() {
                my_size += ::protobuf::rt::bytes_size(3, &v);
            }
            if let Some(v) = self.timestamp {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.usage {
                my_size += ::protobuf::rt::int32_size(5, v.value());
            }
            if let Some(v) = self.device_name.as_ref() {
                my_size += ::protobuf::rt::string_size(6, &v);
            }
            if let Some(v) = self.device_model.as_ref() {
                my_size += ::protobuf::rt::string_size(7, &v);
            }
            if let Some(v) = self.device_serial.as_ref() {
                my_size += ::protobuf::rt::string_size(8, &v);
            }
            if let Some(v) = self.device_provisioning_id {
                my_size += ::protobuf::rt::uint32_size(9, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.password.as_ref() {
                os.write_bytes(1, v)?;
            }
            if let Some(v) = self.identifier {
                os.write_uint64(2, v)?;
            }
            if let Some(v) = self.payload.as_ref() {
                os.write_bytes(3, v)?;
            }
            if let Some(v) = self.timestamp {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.usage {
                os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.device_name.as_ref() {
                os.write_string(6, v)?;
            }
            if let Some(v) = self.device_model.as_ref() {
                os.write_string(7, v)?;
            }
            if let Some(v) = self.device_serial.as_ref() {
                os.write_string(8, v)?;
            }
            if let Some(v) = self.device_provisioning_id {
                os.write_uint32(9, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CKeyEscrow_Ticket {
            CKeyEscrow_Ticket::new()
        }

        fn clear(&mut self) {
            self.password = ::std::option::Option::None;
            self.identifier = ::std::option::Option::None;
            self.payload = ::std::option::Option::None;
            self.timestamp = ::std::option::Option::None;
            self.usage = ::std::option::Option::None;
            self.device_name = ::std::option::Option::None;
            self.device_model = ::std::option::Option::None;
            self.device_serial = ::std::option::Option::None;
            self.device_provisioning_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CKeyEscrow_Ticket {
            static instance: CKeyEscrow_Ticket = CKeyEscrow_Ticket {
                password: ::std::option::Option::None,
                identifier: ::std::option::Option::None,
                payload: ::std::option::Option::None,
                timestamp: ::std::option::Option::None,
                usage: ::std::option::Option::None,
                device_name: ::std::option::Option::None,
                device_model: ::std::option::Option::None,
                device_serial: ::std::option::Option::None,
                device_provisioning_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CKeyEscrow_Ticket {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CKeyEscrow_Ticket {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CKeyEscrow_Ticket {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgRemoteDeviceAuthorizationRequest.EKeyEscrowUsage)
    pub enum EKeyEscrowUsage {
        // @@protoc_insertion_point(enum_value:CMsgRemoteDeviceAuthorizationRequest.EKeyEscrowUsage.k_EKeyEscrowUsageStreamingDevice)
        k_EKeyEscrowUsageStreamingDevice = 0,
    }

    impl ::protobuf::Enum for EKeyEscrowUsage {
        const NAME: &'static str = "EKeyEscrowUsage";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EKeyEscrowUsage> {
            match value {
                0 => ::std::option::Option::Some(EKeyEscrowUsage::k_EKeyEscrowUsageStreamingDevice),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EKeyEscrowUsage> {
            match str {
                "k_EKeyEscrowUsageStreamingDevice" => ::std::option::Option::Some(EKeyEscrowUsage::k_EKeyEscrowUsageStreamingDevice),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EKeyEscrowUsage] = &[
            EKeyEscrowUsage::k_EKeyEscrowUsageStreamingDevice,
        ];
    }

    impl ::protobuf::EnumFull for EKeyEscrowUsage {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgRemoteDeviceAuthorizationRequest.EKeyEscrowUsage").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EKeyEscrowUsage {
        fn default() -> Self {
            EKeyEscrowUsage::k_EKeyEscrowUsageStreamingDevice
        }
    }

    impl EKeyEscrowUsage {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EKeyEscrowUsage>("CMsgRemoteDeviceAuthorizationRequest.EKeyEscrowUsage")
        }
    }
}

// @@protoc_insertion_point(message:CMsgRemoteDeviceAuthorizationCancelRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteDeviceAuthorizationCancelRequest {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteDeviceAuthorizationCancelRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceAuthorizationCancelRequest {
    fn default() -> &'a CMsgRemoteDeviceAuthorizationCancelRequest {
        <CMsgRemoteDeviceAuthorizationCancelRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceAuthorizationCancelRequest {
    pub fn new() -> CMsgRemoteDeviceAuthorizationCancelRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRemoteDeviceAuthorizationCancelRequest>(
            "CMsgRemoteDeviceAuthorizationCancelRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceAuthorizationCancelRequest {
    const NAME: &'static str = "CMsgRemoteDeviceAuthorizationCancelRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteDeviceAuthorizationCancelRequest {
        CMsgRemoteDeviceAuthorizationCancelRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteDeviceAuthorizationCancelRequest {
        static instance: CMsgRemoteDeviceAuthorizationCancelRequest = CMsgRemoteDeviceAuthorizationCancelRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRemoteDeviceAuthorizationCancelRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRemoteDeviceAuthorizationCancelRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRemoteDeviceAuthorizationCancelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteDeviceAuthorizationCancelRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgRemoteDeviceAuthorizationResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteDeviceAuthorizationResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<ERemoteDeviceAuthorizationResult>>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationResponse.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteDeviceAuthorizationResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceAuthorizationResponse {
    fn default() -> &'a CMsgRemoteDeviceAuthorizationResponse {
        <CMsgRemoteDeviceAuthorizationResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceAuthorizationResponse {
    pub fn new() -> CMsgRemoteDeviceAuthorizationResponse {
        ::std::default::Default::default()
    }

    // required .ERemoteDeviceAuthorizationResult result = 1;

    pub fn result(&self) -> ERemoteDeviceAuthorizationResult {
        match self.result {
            Some(e) => e.enum_value_or(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationSuccess),
            None => ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationSuccess,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ERemoteDeviceAuthorizationResult) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional fixed64 steamid = 2;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgRemoteDeviceAuthorizationResponse| { &m.result },
            |m: &mut CMsgRemoteDeviceAuthorizationResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CMsgRemoteDeviceAuthorizationResponse| { &m.steamid },
            |m: &mut CMsgRemoteDeviceAuthorizationResponse| { &mut m.steamid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRemoteDeviceAuthorizationResponse>(
            "CMsgRemoteDeviceAuthorizationResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceAuthorizationResponse {
    const NAME: &'static str = "CMsgRemoteDeviceAuthorizationResponse";

    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                17 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteDeviceAuthorizationResponse {
        CMsgRemoteDeviceAuthorizationResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteDeviceAuthorizationResponse {
        static instance: CMsgRemoteDeviceAuthorizationResponse = CMsgRemoteDeviceAuthorizationResponse {
            result: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRemoteDeviceAuthorizationResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRemoteDeviceAuthorizationResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRemoteDeviceAuthorizationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteDeviceAuthorizationResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgRemoteDeviceStreamingRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteDeviceStreamingRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.request_id)
    pub request_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.maximum_resolution_x)
    pub maximum_resolution_x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.maximum_resolution_y)
    pub maximum_resolution_y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.audio_channel_count)
    pub audio_channel_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.device_version)
    pub device_version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.stream_desktop)
    pub stream_desktop: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.device_token)
    pub device_token: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.pin)
    pub pin: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.enable_video_streaming)
    pub enable_video_streaming: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.enable_audio_streaming)
    pub enable_audio_streaming: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.enable_input_streaming)
    pub enable_input_streaming: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.network_test)
    pub network_test: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.client_id)
    pub client_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.supported_transport)
    pub supported_transport: ::std::vec::Vec<::protobuf::EnumOrUnknown<EStreamTransport>>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.restricted)
    pub restricted: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.form_factor)
    pub form_factor: ::std::option::Option<::protobuf::EnumOrUnknown<EStreamDeviceFormFactor>>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.gamepad_count)
    pub gamepad_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.gamepads)
    pub gamepads: ::std::vec::Vec<cmsg_remote_device_streaming_request::ReservedGamepad>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.gameid)
    pub gameid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.stream_interface)
    pub stream_interface: ::std::option::Option<::protobuf::EnumOrUnknown<EStreamInterface>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteDeviceStreamingRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceStreamingRequest {
    fn default() -> &'a CMsgRemoteDeviceStreamingRequest {
        <CMsgRemoteDeviceStreamingRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceStreamingRequest {
    pub fn new() -> CMsgRemoteDeviceStreamingRequest {
        ::std::default::Default::default()
    }

    // required uint32 request_id = 1;

    pub fn request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional int32 maximum_resolution_x = 2;

    pub fn maximum_resolution_x(&self) -> i32 {
        self.maximum_resolution_x.unwrap_or(0)
    }

    pub fn clear_maximum_resolution_x(&mut self) {
        self.maximum_resolution_x = ::std::option::Option::None;
    }

    pub fn has_maximum_resolution_x(&self) -> bool {
        self.maximum_resolution_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_resolution_x(&mut self, v: i32) {
        self.maximum_resolution_x = ::std::option::Option::Some(v);
    }

    // optional int32 maximum_resolution_y = 3;

    pub fn maximum_resolution_y(&self) -> i32 {
        self.maximum_resolution_y.unwrap_or(0)
    }

    pub fn clear_maximum_resolution_y(&mut self) {
        self.maximum_resolution_y = ::std::option::Option::None;
    }

    pub fn has_maximum_resolution_y(&self) -> bool {
        self.maximum_resolution_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_resolution_y(&mut self, v: i32) {
        self.maximum_resolution_y = ::std::option::Option::Some(v);
    }

    // optional int32 audio_channel_count = 4;

    pub fn audio_channel_count(&self) -> i32 {
        self.audio_channel_count.unwrap_or(2i32)
    }

    pub fn clear_audio_channel_count(&mut self) {
        self.audio_channel_count = ::std::option::Option::None;
    }

    pub fn has_audio_channel_count(&self) -> bool {
        self.audio_channel_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audio_channel_count(&mut self, v: i32) {
        self.audio_channel_count = ::std::option::Option::Some(v);
    }

    // optional string device_version = 5;

    pub fn device_version(&self) -> &str {
        match self.device_version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_device_version(&mut self) {
        self.device_version = ::std::option::Option::None;
    }

    pub fn has_device_version(&self) -> bool {
        self.device_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_version(&mut self, v: ::std::string::String) {
        self.device_version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_version(&mut self) -> &mut ::std::string::String {
        if self.device_version.is_none() {
            self.device_version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.device_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_version(&mut self) -> ::std::string::String {
        self.device_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool stream_desktop = 6;

    pub fn stream_desktop(&self) -> bool {
        self.stream_desktop.unwrap_or(false)
    }

    pub fn clear_stream_desktop(&mut self) {
        self.stream_desktop = ::std::option::Option::None;
    }

    pub fn has_stream_desktop(&self) -> bool {
        self.stream_desktop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stream_desktop(&mut self, v: bool) {
        self.stream_desktop = ::std::option::Option::Some(v);
    }

    // optional bytes device_token = 7;

    pub fn device_token(&self) -> &[u8] {
        match self.device_token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_device_token(&mut self) {
        self.device_token = ::std::option::Option::None;
    }

    pub fn has_device_token(&self) -> bool {
        self.device_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.device_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.device_token.is_none() {
            self.device_token = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.device_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_token(&mut self) -> ::std::vec::Vec<u8> {
        self.device_token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes pin = 8;

    pub fn pin(&self) -> &[u8] {
        match self.pin.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_pin(&mut self) {
        self.pin = ::std::option::Option::None;
    }

    pub fn has_pin(&self) -> bool {
        self.pin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pin(&mut self, v: ::std::vec::Vec<u8>) {
        self.pin = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pin(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pin.is_none() {
            self.pin = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.pin.as_mut().unwrap()
    }

    // Take field
    pub fn take_pin(&mut self) -> ::std::vec::Vec<u8> {
        self.pin.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool enable_video_streaming = 9;

    pub fn enable_video_streaming(&self) -> bool {
        self.enable_video_streaming.unwrap_or(true)
    }

    pub fn clear_enable_video_streaming(&mut self) {
        self.enable_video_streaming = ::std::option::Option::None;
    }

    pub fn has_enable_video_streaming(&self) -> bool {
        self.enable_video_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_video_streaming(&mut self, v: bool) {
        self.enable_video_streaming = ::std::option::Option::Some(v);
    }

    // optional bool enable_audio_streaming = 10;

    pub fn enable_audio_streaming(&self) -> bool {
        self.enable_audio_streaming.unwrap_or(true)
    }

    pub fn clear_enable_audio_streaming(&mut self) {
        self.enable_audio_streaming = ::std::option::Option::None;
    }

    pub fn has_enable_audio_streaming(&self) -> bool {
        self.enable_audio_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_audio_streaming(&mut self, v: bool) {
        self.enable_audio_streaming = ::std::option::Option::Some(v);
    }

    // optional bool enable_input_streaming = 11;

    pub fn enable_input_streaming(&self) -> bool {
        self.enable_input_streaming.unwrap_or(true)
    }

    pub fn clear_enable_input_streaming(&mut self) {
        self.enable_input_streaming = ::std::option::Option::None;
    }

    pub fn has_enable_input_streaming(&self) -> bool {
        self.enable_input_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_input_streaming(&mut self, v: bool) {
        self.enable_input_streaming = ::std::option::Option::Some(v);
    }

    // optional bool network_test = 12;

    pub fn network_test(&self) -> bool {
        self.network_test.unwrap_or(false)
    }

    pub fn clear_network_test(&mut self) {
        self.network_test = ::std::option::Option::None;
    }

    pub fn has_network_test(&self) -> bool {
        self.network_test.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_test(&mut self, v: bool) {
        self.network_test = ::std::option::Option::Some(v);
    }

    // optional uint64 client_id = 13;

    pub fn client_id(&self) -> u64 {
        self.client_id.unwrap_or(0)
    }

    pub fn clear_client_id(&mut self) {
        self.client_id = ::std::option::Option::None;
    }

    pub fn has_client_id(&self) -> bool {
        self.client_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_id(&mut self, v: u64) {
        self.client_id = ::std::option::Option::Some(v);
    }

    // optional bool restricted = 15;

    pub fn restricted(&self) -> bool {
        self.restricted.unwrap_or(false)
    }

    pub fn clear_restricted(&mut self) {
        self.restricted = ::std::option::Option::None;
    }

    pub fn has_restricted(&self) -> bool {
        self.restricted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_restricted(&mut self, v: bool) {
        self.restricted = ::std::option::Option::Some(v);
    }

    // optional .EStreamDeviceFormFactor form_factor = 16;

    pub fn form_factor(&self) -> EStreamDeviceFormFactor {
        match self.form_factor {
            Some(e) => e.enum_value_or(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorUnknown),
            None => EStreamDeviceFormFactor::k_EStreamDeviceFormFactorUnknown,
        }
    }

    pub fn clear_form_factor(&mut self) {
        self.form_factor = ::std::option::Option::None;
    }

    pub fn has_form_factor(&self) -> bool {
        self.form_factor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_form_factor(&mut self, v: EStreamDeviceFormFactor) {
        self.form_factor = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 gamepad_count = 17;

    pub fn gamepad_count(&self) -> i32 {
        self.gamepad_count.unwrap_or(0)
    }

    pub fn clear_gamepad_count(&mut self) {
        self.gamepad_count = ::std::option::Option::None;
    }

    pub fn has_gamepad_count(&self) -> bool {
        self.gamepad_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gamepad_count(&mut self, v: i32) {
        self.gamepad_count = ::std::option::Option::Some(v);
    }

    // optional uint64 gameid = 19;

    pub fn gameid(&self) -> u64 {
        self.gameid.unwrap_or(0)
    }

    pub fn clear_gameid(&mut self) {
        self.gameid = ::std::option::Option::None;
    }

    pub fn has_gameid(&self) -> bool {
        self.gameid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameid(&mut self, v: u64) {
        self.gameid = ::std::option::Option::Some(v);
    }

    // optional .EStreamInterface stream_interface = 20;

    pub fn stream_interface(&self) -> EStreamInterface {
        match self.stream_interface {
            Some(e) => e.enum_value_or(EStreamInterface::k_EStreamInterfaceDefault),
            None => EStreamInterface::k_EStreamInterfaceDefault,
        }
    }

    pub fn clear_stream_interface(&mut self) {
        self.stream_interface = ::std::option::Option::None;
    }

    pub fn has_stream_interface(&self) -> bool {
        self.stream_interface.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stream_interface(&mut self, v: EStreamInterface) {
        self.stream_interface = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(20);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_id",
            |m: &CMsgRemoteDeviceStreamingRequest| { &m.request_id },
            |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.request_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "maximum_resolution_x",
            |m: &CMsgRemoteDeviceStreamingRequest| { &m.maximum_resolution_x },
            |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.maximum_resolution_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "maximum_resolution_y",
            |m: &CMsgRemoteDeviceStreamingRequest| { &m.maximum_resolution_y },
            |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.maximum_resolution_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "audio_channel_count",
            |m: &CMsgRemoteDeviceStreamingRequest| { &m.audio_channel_count },
            |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.audio_channel_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "device_version",
            |m: &CMsgRemoteDeviceStreamingRequest| { &m.device_version },
            |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.device_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stream_desktop",
            |m: &CMsgRemoteDeviceStreamingRequest| { &m.stream_desktop },
            |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.stream_desktop },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "device_token",
            |m: &CMsgRemoteDeviceStreamingRequest| { &m.device_token },
            |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.device_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pin",
            |m: &CMsgRemoteDeviceStreamingRequest| { &m.pin },
            |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.pin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "enable_video_streaming",
            |m: &CMsgRemoteDeviceStreamingRequest| { &m.enable_video_streaming },
            |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.enable_video_streaming },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "enable_audio_streaming",
            |m: &CMsgRemoteDeviceStreamingRequest| { &m.enable_audio_streaming },
            |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.enable_audio_streaming },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "enable_input_streaming",
            |m: &CMsgRemoteDeviceStreamingRequest| { &m.enable_input_streaming },
            |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.enable_input_streaming },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "network_test",
            |m: &CMsgRemoteDeviceStreamingRequest| { &m.network_test },
            |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.network_test },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_id",
            |m: &CMsgRemoteDeviceStreamingRequest| { &m.client_id },
            |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.client_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "supported_transport",
            |m: &CMsgRemoteDeviceStreamingRequest| { &m.supported_transport },
            |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.supported_transport },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "restricted",
            |m: &CMsgRemoteDeviceStreamingRequest| { &m.restricted },
            |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.restricted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "form_factor",
            |m: &CMsgRemoteDeviceStreamingRequest| { &m.form_factor },
            |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.form_factor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gamepad_count",
            |m: &CMsgRemoteDeviceStreamingRequest| { &m.gamepad_count },
            |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.gamepad_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "gamepads",
            |m: &CMsgRemoteDeviceStreamingRequest| { &m.gamepads },
            |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.gamepads },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gameid",
            |m: &CMsgRemoteDeviceStreamingRequest| { &m.gameid },
            |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.gameid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stream_interface",
            |m: &CMsgRemoteDeviceStreamingRequest| { &m.stream_interface },
            |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.stream_interface },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRemoteDeviceStreamingRequest>(
            "CMsgRemoteDeviceStreamingRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceStreamingRequest {
    const NAME: &'static str = "CMsgRemoteDeviceStreamingRequest";

    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        for v in &self.gamepads {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.maximum_resolution_x = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.maximum_resolution_y = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.audio_channel_count = ::std::option::Option::Some(is.read_int32()?);
                },
                42 => {
                    self.device_version = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.stream_desktop = ::std::option::Option::Some(is.read_bool()?);
                },
                58 => {
                    self.device_token = ::std::option::Option::Some(is.read_bytes()?);
                },
                66 => {
                    self.pin = ::std::option::Option::Some(is.read_bytes()?);
                },
                72 => {
                    self.enable_video_streaming = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.enable_audio_streaming = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.enable_input_streaming = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.network_test = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.client_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                112 => {
                    self.supported_transport.push(is.read_enum_or_unknown()?);
                },
                114 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.supported_transport)?
                },
                120 => {
                    self.restricted = ::std::option::Option::Some(is.read_bool()?);
                },
                128 => {
                    self.form_factor = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                136 => {
                    self.gamepad_count = ::std::option::Option::Some(is.read_int32()?);
                },
                146 => {
                    self.gamepads.push(is.read_message()?);
                },
                152 => {
                    self.gameid = ::std::option::Option::Some(is.read_uint64()?);
                },
                160 => {
                    self.stream_interface = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.maximum_resolution_x {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.maximum_resolution_y {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.audio_channel_count {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.device_version.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.stream_desktop {
            my_size += 1 + 1;
        }
        if let Some(v) = self.device_token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.pin.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.enable_video_streaming {
            my_size += 1 + 1;
        }
        if let Some(v) = self.enable_audio_streaming {
            my_size += 1 + 1;
        }
        if let Some(v) = self.enable_input_streaming {
            my_size += 1 + 1;
        }
        if let Some(v) = self.network_test {
            my_size += 1 + 1;
        }
        if let Some(v) = self.client_id {
            my_size += ::protobuf::rt::uint64_size(13, v);
        }
        for value in &self.supported_transport {
            my_size += ::protobuf::rt::int32_size(14, value.value());
        };
        if let Some(v) = self.restricted {
            my_size += 1 + 1;
        }
        if let Some(v) = self.form_factor {
            my_size += ::protobuf::rt::int32_size(16, v.value());
        }
        if let Some(v) = self.gamepad_count {
            my_size += ::protobuf::rt::int32_size(17, v);
        }
        for value in &self.gamepads {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.gameid {
            my_size += ::protobuf::rt::uint64_size(19, v);
        }
        if let Some(v) = self.stream_interface {
            my_size += ::protobuf::rt::int32_size(20, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.request_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.maximum_resolution_x {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.maximum_resolution_y {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.audio_channel_count {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.device_version.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.stream_desktop {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.device_token.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.pin.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.enable_video_streaming {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.enable_audio_streaming {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.enable_input_streaming {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.network_test {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.client_id {
            os.write_uint64(13, v)?;
        }
        for v in &self.supported_transport {
            os.write_enum(14, ::protobuf::EnumOrUnknown::value(v))?;
        };
        if let Some(v) = self.restricted {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.form_factor {
            os.write_enum(16, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.gamepad_count {
            os.write_int32(17, v)?;
        }
        for v in &self.gamepads {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        };
        if let Some(v) = self.gameid {
            os.write_uint64(19, v)?;
        }
        if let Some(v) = self.stream_interface {
            os.write_enum(20, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteDeviceStreamingRequest {
        CMsgRemoteDeviceStreamingRequest::new()
    }

    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.maximum_resolution_x = ::std::option::Option::None;
        self.maximum_resolution_y = ::std::option::Option::None;
        self.audio_channel_count = ::std::option::Option::None;
        self.device_version = ::std::option::Option::None;
        self.stream_desktop = ::std::option::Option::None;
        self.device_token = ::std::option::Option::None;
        self.pin = ::std::option::Option::None;
        self.enable_video_streaming = ::std::option::Option::None;
        self.enable_audio_streaming = ::std::option::Option::None;
        self.enable_input_streaming = ::std::option::Option::None;
        self.network_test = ::std::option::Option::None;
        self.client_id = ::std::option::Option::None;
        self.supported_transport.clear();
        self.restricted = ::std::option::Option::None;
        self.form_factor = ::std::option::Option::None;
        self.gamepad_count = ::std::option::Option::None;
        self.gamepads.clear();
        self.gameid = ::std::option::Option::None;
        self.stream_interface = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteDeviceStreamingRequest {
        static instance: CMsgRemoteDeviceStreamingRequest = CMsgRemoteDeviceStreamingRequest {
            request_id: ::std::option::Option::None,
            maximum_resolution_x: ::std::option::Option::None,
            maximum_resolution_y: ::std::option::Option::None,
            audio_channel_count: ::std::option::Option::None,
            device_version: ::std::option::Option::None,
            stream_desktop: ::std::option::Option::None,
            device_token: ::std::option::Option::None,
            pin: ::std::option::Option::None,
            enable_video_streaming: ::std::option::Option::None,
            enable_audio_streaming: ::std::option::Option::None,
            enable_input_streaming: ::std::option::Option::None,
            network_test: ::std::option::Option::None,
            client_id: ::std::option::Option::None,
            supported_transport: ::std::vec::Vec::new(),
            restricted: ::std::option::Option::None,
            form_factor: ::std::option::Option::None,
            gamepad_count: ::std::option::Option::None,
            gamepads: ::std::vec::Vec::new(),
            gameid: ::std::option::Option::None,
            stream_interface: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRemoteDeviceStreamingRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRemoteDeviceStreamingRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRemoteDeviceStreamingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteDeviceStreamingRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgRemoteDeviceStreamingRequest`
pub mod cmsg_remote_device_streaming_request {
    // @@protoc_insertion_point(message:CMsgRemoteDeviceStreamingRequest.ReservedGamepad)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ReservedGamepad {
        // message fields
        // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.ReservedGamepad.controller_type)
        pub controller_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.ReservedGamepad.controller_subtype)
        pub controller_subtype: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgRemoteDeviceStreamingRequest.ReservedGamepad.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ReservedGamepad {
        fn default() -> &'a ReservedGamepad {
            <ReservedGamepad as ::protobuf::Message>::default_instance()
        }
    }

    impl ReservedGamepad {
        pub fn new() -> ReservedGamepad {
            ::std::default::Default::default()
        }

        // optional uint32 controller_type = 1;

        pub fn controller_type(&self) -> u32 {
            self.controller_type.unwrap_or(0)
        }

        pub fn clear_controller_type(&mut self) {
            self.controller_type = ::std::option::Option::None;
        }

        pub fn has_controller_type(&self) -> bool {
            self.controller_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_controller_type(&mut self, v: u32) {
            self.controller_type = ::std::option::Option::Some(v);
        }

        // optional uint32 controller_subtype = 2;

        pub fn controller_subtype(&self) -> u32 {
            self.controller_subtype.unwrap_or(0)
        }

        pub fn clear_controller_subtype(&mut self) {
            self.controller_subtype = ::std::option::Option::None;
        }

        pub fn has_controller_subtype(&self) -> bool {
            self.controller_subtype.is_some()
        }

        // Param is passed by value, moved
        pub fn set_controller_subtype(&mut self, v: u32) {
            self.controller_subtype = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "controller_type",
                |m: &ReservedGamepad| { &m.controller_type },
                |m: &mut ReservedGamepad| { &mut m.controller_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "controller_subtype",
                |m: &ReservedGamepad| { &m.controller_subtype },
                |m: &mut ReservedGamepad| { &mut m.controller_subtype },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReservedGamepad>(
                "CMsgRemoteDeviceStreamingRequest.ReservedGamepad",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ReservedGamepad {
        const NAME: &'static str = "ReservedGamepad";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.controller_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.controller_subtype = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.controller_type {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.controller_subtype {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.controller_type {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.controller_subtype {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ReservedGamepad {
            ReservedGamepad::new()
        }

        fn clear(&mut self) {
            self.controller_type = ::std::option::Option::None;
            self.controller_subtype = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ReservedGamepad {
            static instance: ReservedGamepad = ReservedGamepad {
                controller_type: ::std::option::Option::None,
                controller_subtype: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ReservedGamepad {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgRemoteDeviceStreamingRequest.ReservedGamepad").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ReservedGamepad {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ReservedGamepad {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgRemoteDeviceStreamingCancelRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteDeviceStreamingCancelRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingCancelRequest.request_id)
    pub request_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteDeviceStreamingCancelRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceStreamingCancelRequest {
    fn default() -> &'a CMsgRemoteDeviceStreamingCancelRequest {
        <CMsgRemoteDeviceStreamingCancelRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceStreamingCancelRequest {
    pub fn new() -> CMsgRemoteDeviceStreamingCancelRequest {
        ::std::default::Default::default()
    }

    // required uint32 request_id = 1;

    pub fn request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_id",
            |m: &CMsgRemoteDeviceStreamingCancelRequest| { &m.request_id },
            |m: &mut CMsgRemoteDeviceStreamingCancelRequest| { &mut m.request_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRemoteDeviceStreamingCancelRequest>(
            "CMsgRemoteDeviceStreamingCancelRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceStreamingCancelRequest {
    const NAME: &'static str = "CMsgRemoteDeviceStreamingCancelRequest";

    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.request_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteDeviceStreamingCancelRequest {
        CMsgRemoteDeviceStreamingCancelRequest::new()
    }

    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteDeviceStreamingCancelRequest {
        static instance: CMsgRemoteDeviceStreamingCancelRequest = CMsgRemoteDeviceStreamingCancelRequest {
            request_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRemoteDeviceStreamingCancelRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRemoteDeviceStreamingCancelRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRemoteDeviceStreamingCancelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteDeviceStreamingCancelRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgRemoteDeviceStreamingProgress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteDeviceStreamingProgress {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingProgress.request_id)
    pub request_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingProgress.progress)
    pub progress: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteDeviceStreamingProgress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceStreamingProgress {
    fn default() -> &'a CMsgRemoteDeviceStreamingProgress {
        <CMsgRemoteDeviceStreamingProgress as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceStreamingProgress {
    pub fn new() -> CMsgRemoteDeviceStreamingProgress {
        ::std::default::Default::default()
    }

    // required uint32 request_id = 1;

    pub fn request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional float progress = 2;

    pub fn progress(&self) -> f32 {
        self.progress.unwrap_or(0.)
    }

    pub fn clear_progress(&mut self) {
        self.progress = ::std::option::Option::None;
    }

    pub fn has_progress(&self) -> bool {
        self.progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: f32) {
        self.progress = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_id",
            |m: &CMsgRemoteDeviceStreamingProgress| { &m.request_id },
            |m: &mut CMsgRemoteDeviceStreamingProgress| { &mut m.request_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "progress",
            |m: &CMsgRemoteDeviceStreamingProgress| { &m.progress },
            |m: &mut CMsgRemoteDeviceStreamingProgress| { &mut m.progress },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRemoteDeviceStreamingProgress>(
            "CMsgRemoteDeviceStreamingProgress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceStreamingProgress {
    const NAME: &'static str = "CMsgRemoteDeviceStreamingProgress";

    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.progress = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.progress {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.request_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.progress {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteDeviceStreamingProgress {
        CMsgRemoteDeviceStreamingProgress::new()
    }

    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.progress = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteDeviceStreamingProgress {
        static instance: CMsgRemoteDeviceStreamingProgress = CMsgRemoteDeviceStreamingProgress {
            request_id: ::std::option::Option::None,
            progress: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRemoteDeviceStreamingProgress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRemoteDeviceStreamingProgress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRemoteDeviceStreamingProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteDeviceStreamingProgress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgRemoteDeviceStreamingResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteDeviceStreamingResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingResponse.request_id)
    pub request_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingResponse.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<ERemoteDeviceStreamingResult>>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingResponse.port)
    pub port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingResponse.encrypted_session_key)
    pub encrypted_session_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingResponse.transport)
    pub transport: ::std::option::Option<::protobuf::EnumOrUnknown<EStreamTransport>>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingResponse.relay_server)
    pub relay_server: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingResponse.cert)
    pub cert: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteDeviceStreamingResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceStreamingResponse {
    fn default() -> &'a CMsgRemoteDeviceStreamingResponse {
        <CMsgRemoteDeviceStreamingResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceStreamingResponse {
    pub fn new() -> CMsgRemoteDeviceStreamingResponse {
        ::std::default::Default::default()
    }

    // required uint32 request_id = 1;

    pub fn request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // required .ERemoteDeviceStreamingResult result = 2;

    pub fn result(&self) -> ERemoteDeviceStreamingResult {
        match self.result {
            Some(e) => e.enum_value_or(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingSuccess),
            None => ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingSuccess,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ERemoteDeviceStreamingResult) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 port = 3;

    pub fn port(&self) -> u32 {
        self.port.unwrap_or(0)
    }

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = ::std::option::Option::Some(v);
    }

    // optional bytes encrypted_session_key = 4;

    pub fn encrypted_session_key(&self) -> &[u8] {
        match self.encrypted_session_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_encrypted_session_key(&mut self) {
        self.encrypted_session_key = ::std::option::Option::None;
    }

    pub fn has_encrypted_session_key(&self) -> bool {
        self.encrypted_session_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encrypted_session_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.encrypted_session_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encrypted_session_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.encrypted_session_key.is_none() {
            self.encrypted_session_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.encrypted_session_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_encrypted_session_key(&mut self) -> ::std::vec::Vec<u8> {
        self.encrypted_session_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .EStreamTransport transport = 6;

    pub fn transport(&self) -> EStreamTransport {
        match self.transport {
            Some(e) => e.enum_value_or(EStreamTransport::k_EStreamTransportUDP),
            None => EStreamTransport::k_EStreamTransportUDP,
        }
    }

    pub fn clear_transport(&mut self) {
        self.transport = ::std::option::Option::None;
    }

    pub fn has_transport(&self) -> bool {
        self.transport.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transport(&mut self, v: EStreamTransport) {
        self.transport = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string relay_server = 7;

    pub fn relay_server(&self) -> &str {
        match self.relay_server.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_relay_server(&mut self) {
        self.relay_server = ::std::option::Option::None;
    }

    pub fn has_relay_server(&self) -> bool {
        self.relay_server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relay_server(&mut self, v: ::std::string::String) {
        self.relay_server = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_relay_server(&mut self) -> &mut ::std::string::String {
        if self.relay_server.is_none() {
            self.relay_server = ::std::option::Option::Some(::std::string::String::new());
        }
        self.relay_server.as_mut().unwrap()
    }

    // Take field
    pub fn take_relay_server(&mut self) -> ::std::string::String {
        self.relay_server.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string cert = 8;

    pub fn cert(&self) -> &str {
        match self.cert.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_cert(&mut self) {
        self.cert = ::std::option::Option::None;
    }

    pub fn has_cert(&self) -> bool {
        self.cert.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cert(&mut self, v: ::std::string::String) {
        self.cert = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cert(&mut self) -> &mut ::std::string::String {
        if self.cert.is_none() {
            self.cert = ::std::option::Option::Some(::std::string::String::new());
        }
        self.cert.as_mut().unwrap()
    }

    // Take field
    pub fn take_cert(&mut self) -> ::std::string::String {
        self.cert.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_id",
            |m: &CMsgRemoteDeviceStreamingResponse| { &m.request_id },
            |m: &mut CMsgRemoteDeviceStreamingResponse| { &mut m.request_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgRemoteDeviceStreamingResponse| { &m.result },
            |m: &mut CMsgRemoteDeviceStreamingResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "port",
            |m: &CMsgRemoteDeviceStreamingResponse| { &m.port },
            |m: &mut CMsgRemoteDeviceStreamingResponse| { &mut m.port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "encrypted_session_key",
            |m: &CMsgRemoteDeviceStreamingResponse| { &m.encrypted_session_key },
            |m: &mut CMsgRemoteDeviceStreamingResponse| { &mut m.encrypted_session_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transport",
            |m: &CMsgRemoteDeviceStreamingResponse| { &m.transport },
            |m: &mut CMsgRemoteDeviceStreamingResponse| { &mut m.transport },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "relay_server",
            |m: &CMsgRemoteDeviceStreamingResponse| { &m.relay_server },
            |m: &mut CMsgRemoteDeviceStreamingResponse| { &mut m.relay_server },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cert",
            |m: &CMsgRemoteDeviceStreamingResponse| { &m.cert },
            |m: &mut CMsgRemoteDeviceStreamingResponse| { &mut m.cert },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRemoteDeviceStreamingResponse>(
            "CMsgRemoteDeviceStreamingResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceStreamingResponse {
    const NAME: &'static str = "CMsgRemoteDeviceStreamingResponse";

    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.port = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.encrypted_session_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                48 => {
                    self.transport = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                58 => {
                    self.relay_server = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.cert = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.port {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.encrypted_session_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.transport {
            my_size += ::protobuf::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.relay_server.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.cert.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.request_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.result {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.port {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.encrypted_session_key.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.transport {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.relay_server.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.cert.as_ref() {
            os.write_string(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteDeviceStreamingResponse {
        CMsgRemoteDeviceStreamingResponse::new()
    }

    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.port = ::std::option::Option::None;
        self.encrypted_session_key = ::std::option::Option::None;
        self.transport = ::std::option::Option::None;
        self.relay_server = ::std::option::Option::None;
        self.cert = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteDeviceStreamingResponse {
        static instance: CMsgRemoteDeviceStreamingResponse = CMsgRemoteDeviceStreamingResponse {
            request_id: ::std::option::Option::None,
            result: ::std::option::Option::None,
            port: ::std::option::Option::None,
            encrypted_session_key: ::std::option::Option::None,
            transport: ::std::option::Option::None,
            relay_server: ::std::option::Option::None,
            cert: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRemoteDeviceStreamingResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRemoteDeviceStreamingResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRemoteDeviceStreamingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteDeviceStreamingResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgRemoteDeviceProofRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteDeviceProofRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteDeviceProofRequest.challenge)
    pub challenge: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceProofRequest.request_id)
    pub request_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteDeviceProofRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceProofRequest {
    fn default() -> &'a CMsgRemoteDeviceProofRequest {
        <CMsgRemoteDeviceProofRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceProofRequest {
    pub fn new() -> CMsgRemoteDeviceProofRequest {
        ::std::default::Default::default()
    }

    // required bytes challenge = 1;

    pub fn challenge(&self) -> &[u8] {
        match self.challenge.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_challenge(&mut self) {
        self.challenge = ::std::option::Option::None;
    }

    pub fn has_challenge(&self) -> bool {
        self.challenge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge(&mut self, v: ::std::vec::Vec<u8>) {
        self.challenge = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_challenge(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.challenge.is_none() {
            self.challenge = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.challenge.as_mut().unwrap()
    }

    // Take field
    pub fn take_challenge(&mut self) -> ::std::vec::Vec<u8> {
        self.challenge.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 request_id = 2;

    pub fn request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge",
            |m: &CMsgRemoteDeviceProofRequest| { &m.challenge },
            |m: &mut CMsgRemoteDeviceProofRequest| { &mut m.challenge },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_id",
            |m: &CMsgRemoteDeviceProofRequest| { &m.request_id },
            |m: &mut CMsgRemoteDeviceProofRequest| { &mut m.request_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRemoteDeviceProofRequest>(
            "CMsgRemoteDeviceProofRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceProofRequest {
    const NAME: &'static str = "CMsgRemoteDeviceProofRequest";

    fn is_initialized(&self) -> bool {
        if self.challenge.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.challenge = ::std::option::Option::Some(is.read_bytes()?);
                },
                16 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.challenge.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.challenge.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteDeviceProofRequest {
        CMsgRemoteDeviceProofRequest::new()
    }

    fn clear(&mut self) {
        self.challenge = ::std::option::Option::None;
        self.request_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteDeviceProofRequest {
        static instance: CMsgRemoteDeviceProofRequest = CMsgRemoteDeviceProofRequest {
            challenge: ::std::option::Option::None,
            request_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRemoteDeviceProofRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRemoteDeviceProofRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRemoteDeviceProofRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteDeviceProofRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgRemoteDeviceProofResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteDeviceProofResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteDeviceProofResponse.response)
    pub response: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceProofResponse.request_id)
    pub request_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteDeviceProofResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceProofResponse {
    fn default() -> &'a CMsgRemoteDeviceProofResponse {
        <CMsgRemoteDeviceProofResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceProofResponse {
    pub fn new() -> CMsgRemoteDeviceProofResponse {
        ::std::default::Default::default()
    }

    // required bytes response = 1;

    pub fn response(&self) -> &[u8] {
        match self.response.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: ::std::vec::Vec<u8>) {
        self.response = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_response(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.response.is_none() {
            self.response = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.response.as_mut().unwrap()
    }

    // Take field
    pub fn take_response(&mut self) -> ::std::vec::Vec<u8> {
        self.response.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 request_id = 2;

    pub fn request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response",
            |m: &CMsgRemoteDeviceProofResponse| { &m.response },
            |m: &mut CMsgRemoteDeviceProofResponse| { &mut m.response },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_id",
            |m: &CMsgRemoteDeviceProofResponse| { &m.request_id },
            |m: &mut CMsgRemoteDeviceProofResponse| { &mut m.request_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRemoteDeviceProofResponse>(
            "CMsgRemoteDeviceProofResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceProofResponse {
    const NAME: &'static str = "CMsgRemoteDeviceProofResponse";

    fn is_initialized(&self) -> bool {
        if self.response.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.response = ::std::option::Option::Some(is.read_bytes()?);
                },
                16 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.response.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteDeviceProofResponse {
        CMsgRemoteDeviceProofResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.request_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteDeviceProofResponse {
        static instance: CMsgRemoteDeviceProofResponse = CMsgRemoteDeviceProofResponse {
            response: ::std::option::Option::None,
            request_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRemoteDeviceProofResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRemoteDeviceProofResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRemoteDeviceProofResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteDeviceProofResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgRemoteDeviceStreamTransportSignal)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteDeviceStreamTransportSignal {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamTransportSignal.token)
    pub token: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamTransportSignal.payload)
    pub payload: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteDeviceStreamTransportSignal.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceStreamTransportSignal {
    fn default() -> &'a CMsgRemoteDeviceStreamTransportSignal {
        <CMsgRemoteDeviceStreamTransportSignal as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceStreamTransportSignal {
    pub fn new() -> CMsgRemoteDeviceStreamTransportSignal {
        ::std::default::Default::default()
    }

    // optional bytes token = 1;

    pub fn token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.token.is_none() {
            self.token = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
        self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes payload = 2;

    pub fn payload(&self) -> &[u8] {
        match self.payload.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_payload(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.payload.is_none() {
            self.payload = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        self.payload.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "token",
            |m: &CMsgRemoteDeviceStreamTransportSignal| { &m.token },
            |m: &mut CMsgRemoteDeviceStreamTransportSignal| { &mut m.token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payload",
            |m: &CMsgRemoteDeviceStreamTransportSignal| { &m.payload },
            |m: &mut CMsgRemoteDeviceStreamTransportSignal| { &mut m.payload },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRemoteDeviceStreamTransportSignal>(
            "CMsgRemoteDeviceStreamTransportSignal",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceStreamTransportSignal {
    const NAME: &'static str = "CMsgRemoteDeviceStreamTransportSignal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.token = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.payload = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.payload.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.token.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.payload.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteDeviceStreamTransportSignal {
        CMsgRemoteDeviceStreamTransportSignal::new()
    }

    fn clear(&mut self) {
        self.token = ::std::option::Option::None;
        self.payload = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteDeviceStreamTransportSignal {
        static instance: CMsgRemoteDeviceStreamTransportSignal = CMsgRemoteDeviceStreamTransportSignal {
            token: ::std::option::Option::None,
            payload: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRemoteDeviceStreamTransportSignal {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRemoteDeviceStreamTransportSignal").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRemoteDeviceStreamTransportSignal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteDeviceStreamTransportSignal {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ERemoteClientBroadcastMsg)
pub enum ERemoteClientBroadcastMsg {
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteClientBroadcastMsgDiscovery)
    k_ERemoteClientBroadcastMsgDiscovery = 0,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteClientBroadcastMsgStatus)
    k_ERemoteClientBroadcastMsgStatus = 1,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteClientBroadcastMsgOffline)
    k_ERemoteClientBroadcastMsgOffline = 2,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteDeviceAuthorizationRequest)
    k_ERemoteDeviceAuthorizationRequest = 3,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteDeviceAuthorizationResponse)
    k_ERemoteDeviceAuthorizationResponse = 4,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteDeviceStreamingRequest)
    k_ERemoteDeviceStreamingRequest = 5,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteDeviceStreamingResponse)
    k_ERemoteDeviceStreamingResponse = 6,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteDeviceProofRequest)
    k_ERemoteDeviceProofRequest = 7,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteDeviceProofResponse)
    k_ERemoteDeviceProofResponse = 8,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteDeviceAuthorizationCancelRequest)
    k_ERemoteDeviceAuthorizationCancelRequest = 9,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteDeviceStreamingCancelRequest)
    k_ERemoteDeviceStreamingCancelRequest = 10,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteClientBroadcastMsgClientIDDeconflict)
    k_ERemoteClientBroadcastMsgClientIDDeconflict = 11,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteDeviceStreamTransportSignal)
    k_ERemoteDeviceStreamTransportSignal = 12,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteDeviceStreamingProgress)
    k_ERemoteDeviceStreamingProgress = 13,
}

impl ::protobuf::Enum for ERemoteClientBroadcastMsg {
    const NAME: &'static str = "ERemoteClientBroadcastMsg";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ERemoteClientBroadcastMsg> {
        match value {
            0 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgDiscovery),
            1 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgStatus),
            2 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgOffline),
            3 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationRequest),
            4 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationResponse),
            5 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingRequest),
            6 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingResponse),
            7 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceProofRequest),
            8 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceProofResponse),
            9 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationCancelRequest),
            10 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingCancelRequest),
            11 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgClientIDDeconflict),
            12 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamTransportSignal),
            13 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingProgress),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ERemoteClientBroadcastMsg> {
        match str {
            "k_ERemoteClientBroadcastMsgDiscovery" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgDiscovery),
            "k_ERemoteClientBroadcastMsgStatus" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgStatus),
            "k_ERemoteClientBroadcastMsgOffline" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgOffline),
            "k_ERemoteDeviceAuthorizationRequest" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationRequest),
            "k_ERemoteDeviceAuthorizationResponse" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationResponse),
            "k_ERemoteDeviceStreamingRequest" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingRequest),
            "k_ERemoteDeviceStreamingResponse" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingResponse),
            "k_ERemoteDeviceProofRequest" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceProofRequest),
            "k_ERemoteDeviceProofResponse" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceProofResponse),
            "k_ERemoteDeviceAuthorizationCancelRequest" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationCancelRequest),
            "k_ERemoteDeviceStreamingCancelRequest" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingCancelRequest),
            "k_ERemoteClientBroadcastMsgClientIDDeconflict" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgClientIDDeconflict),
            "k_ERemoteDeviceStreamTransportSignal" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamTransportSignal),
            "k_ERemoteDeviceStreamingProgress" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingProgress),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ERemoteClientBroadcastMsg] = &[
        ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgDiscovery,
        ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgStatus,
        ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgOffline,
        ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationRequest,
        ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationResponse,
        ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingRequest,
        ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingResponse,
        ERemoteClientBroadcastMsg::k_ERemoteDeviceProofRequest,
        ERemoteClientBroadcastMsg::k_ERemoteDeviceProofResponse,
        ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationCancelRequest,
        ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingCancelRequest,
        ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgClientIDDeconflict,
        ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamTransportSignal,
        ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingProgress,
    ];
}

impl ::protobuf::EnumFull for ERemoteClientBroadcastMsg {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ERemoteClientBroadcastMsg").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ERemoteClientBroadcastMsg {
    fn default() -> Self {
        ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgDiscovery
    }
}

impl ERemoteClientBroadcastMsg {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ERemoteClientBroadcastMsg>("ERemoteClientBroadcastMsg")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ERemoteClientService)
pub enum ERemoteClientService {
    // @@protoc_insertion_point(enum_value:ERemoteClientService.k_ERemoteClientServiceNone)
    k_ERemoteClientServiceNone = 0,
    // @@protoc_insertion_point(enum_value:ERemoteClientService.k_ERemoteClientServiceRemoteControl)
    k_ERemoteClientServiceRemoteControl = 1,
    // @@protoc_insertion_point(enum_value:ERemoteClientService.k_ERemoteClientServiceGameStreaming)
    k_ERemoteClientServiceGameStreaming = 2,
    // @@protoc_insertion_point(enum_value:ERemoteClientService.k_ERemoteClientServiceSiteLicense)
    k_ERemoteClientServiceSiteLicense = 4,
    // @@protoc_insertion_point(enum_value:ERemoteClientService.k_ERemoteClientServiceContentCache)
    k_ERemoteClientServiceContentCache = 8,
}

impl ::protobuf::Enum for ERemoteClientService {
    const NAME: &'static str = "ERemoteClientService";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ERemoteClientService> {
        match value {
            0 => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceNone),
            1 => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceRemoteControl),
            2 => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceGameStreaming),
            4 => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceSiteLicense),
            8 => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceContentCache),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ERemoteClientService> {
        match str {
            "k_ERemoteClientServiceNone" => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceNone),
            "k_ERemoteClientServiceRemoteControl" => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceRemoteControl),
            "k_ERemoteClientServiceGameStreaming" => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceGameStreaming),
            "k_ERemoteClientServiceSiteLicense" => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceSiteLicense),
            "k_ERemoteClientServiceContentCache" => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceContentCache),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ERemoteClientService] = &[
        ERemoteClientService::k_ERemoteClientServiceNone,
        ERemoteClientService::k_ERemoteClientServiceRemoteControl,
        ERemoteClientService::k_ERemoteClientServiceGameStreaming,
        ERemoteClientService::k_ERemoteClientServiceSiteLicense,
        ERemoteClientService::k_ERemoteClientServiceContentCache,
    ];
}

impl ::protobuf::EnumFull for ERemoteClientService {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ERemoteClientService").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ERemoteClientService::k_ERemoteClientServiceNone => 0,
            ERemoteClientService::k_ERemoteClientServiceRemoteControl => 1,
            ERemoteClientService::k_ERemoteClientServiceGameStreaming => 2,
            ERemoteClientService::k_ERemoteClientServiceSiteLicense => 3,
            ERemoteClientService::k_ERemoteClientServiceContentCache => 4,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ERemoteClientService {
    fn default() -> Self {
        ERemoteClientService::k_ERemoteClientServiceNone
    }
}

impl ERemoteClientService {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ERemoteClientService>("ERemoteClientService")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ERemoteDeviceAuthorizationResult)
pub enum ERemoteDeviceAuthorizationResult {
    // @@protoc_insertion_point(enum_value:ERemoteDeviceAuthorizationResult.k_ERemoteDeviceAuthorizationSuccess)
    k_ERemoteDeviceAuthorizationSuccess = 0,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceAuthorizationResult.k_ERemoteDeviceAuthorizationDenied)
    k_ERemoteDeviceAuthorizationDenied = 1,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceAuthorizationResult.k_ERemoteDeviceAuthorizationNotLoggedIn)
    k_ERemoteDeviceAuthorizationNotLoggedIn = 2,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceAuthorizationResult.k_ERemoteDeviceAuthorizationOffline)
    k_ERemoteDeviceAuthorizationOffline = 3,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceAuthorizationResult.k_ERemoteDeviceAuthorizationBusy)
    k_ERemoteDeviceAuthorizationBusy = 4,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceAuthorizationResult.k_ERemoteDeviceAuthorizationInProgress)
    k_ERemoteDeviceAuthorizationInProgress = 5,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceAuthorizationResult.k_ERemoteDeviceAuthorizationTimedOut)
    k_ERemoteDeviceAuthorizationTimedOut = 6,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceAuthorizationResult.k_ERemoteDeviceAuthorizationFailed)
    k_ERemoteDeviceAuthorizationFailed = 7,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceAuthorizationResult.k_ERemoteDeviceAuthorizationCanceled)
    k_ERemoteDeviceAuthorizationCanceled = 8,
}

impl ::protobuf::Enum for ERemoteDeviceAuthorizationResult {
    const NAME: &'static str = "ERemoteDeviceAuthorizationResult";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ERemoteDeviceAuthorizationResult> {
        match value {
            0 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationSuccess),
            1 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationDenied),
            2 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationNotLoggedIn),
            3 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationOffline),
            4 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationBusy),
            5 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationInProgress),
            6 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationTimedOut),
            7 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationFailed),
            8 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationCanceled),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ERemoteDeviceAuthorizationResult> {
        match str {
            "k_ERemoteDeviceAuthorizationSuccess" => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationSuccess),
            "k_ERemoteDeviceAuthorizationDenied" => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationDenied),
            "k_ERemoteDeviceAuthorizationNotLoggedIn" => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationNotLoggedIn),
            "k_ERemoteDeviceAuthorizationOffline" => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationOffline),
            "k_ERemoteDeviceAuthorizationBusy" => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationBusy),
            "k_ERemoteDeviceAuthorizationInProgress" => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationInProgress),
            "k_ERemoteDeviceAuthorizationTimedOut" => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationTimedOut),
            "k_ERemoteDeviceAuthorizationFailed" => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationFailed),
            "k_ERemoteDeviceAuthorizationCanceled" => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationCanceled),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ERemoteDeviceAuthorizationResult] = &[
        ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationSuccess,
        ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationDenied,
        ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationNotLoggedIn,
        ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationOffline,
        ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationBusy,
        ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationInProgress,
        ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationTimedOut,
        ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationFailed,
        ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationCanceled,
    ];
}

impl ::protobuf::EnumFull for ERemoteDeviceAuthorizationResult {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ERemoteDeviceAuthorizationResult").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ERemoteDeviceAuthorizationResult {
    fn default() -> Self {
        ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationSuccess
    }
}

impl ERemoteDeviceAuthorizationResult {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ERemoteDeviceAuthorizationResult>("ERemoteDeviceAuthorizationResult")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamDeviceFormFactor)
pub enum EStreamDeviceFormFactor {
    // @@protoc_insertion_point(enum_value:EStreamDeviceFormFactor.k_EStreamDeviceFormFactorUnknown)
    k_EStreamDeviceFormFactorUnknown = 0,
    // @@protoc_insertion_point(enum_value:EStreamDeviceFormFactor.k_EStreamDeviceFormFactorPhone)
    k_EStreamDeviceFormFactorPhone = 1,
    // @@protoc_insertion_point(enum_value:EStreamDeviceFormFactor.k_EStreamDeviceFormFactorTablet)
    k_EStreamDeviceFormFactorTablet = 2,
    // @@protoc_insertion_point(enum_value:EStreamDeviceFormFactor.k_EStreamDeviceFormFactorComputer)
    k_EStreamDeviceFormFactorComputer = 3,
    // @@protoc_insertion_point(enum_value:EStreamDeviceFormFactor.k_EStreamDeviceFormFactorTV)
    k_EStreamDeviceFormFactorTV = 4,
}

impl ::protobuf::Enum for EStreamDeviceFormFactor {
    const NAME: &'static str = "EStreamDeviceFormFactor";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamDeviceFormFactor> {
        match value {
            0 => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorUnknown),
            1 => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorPhone),
            2 => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorTablet),
            3 => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorComputer),
            4 => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorTV),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamDeviceFormFactor> {
        match str {
            "k_EStreamDeviceFormFactorUnknown" => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorUnknown),
            "k_EStreamDeviceFormFactorPhone" => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorPhone),
            "k_EStreamDeviceFormFactorTablet" => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorTablet),
            "k_EStreamDeviceFormFactorComputer" => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorComputer),
            "k_EStreamDeviceFormFactorTV" => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorTV),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamDeviceFormFactor] = &[
        EStreamDeviceFormFactor::k_EStreamDeviceFormFactorUnknown,
        EStreamDeviceFormFactor::k_EStreamDeviceFormFactorPhone,
        EStreamDeviceFormFactor::k_EStreamDeviceFormFactorTablet,
        EStreamDeviceFormFactor::k_EStreamDeviceFormFactorComputer,
        EStreamDeviceFormFactor::k_EStreamDeviceFormFactorTV,
    ];
}

impl ::protobuf::EnumFull for EStreamDeviceFormFactor {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStreamDeviceFormFactor").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EStreamDeviceFormFactor {
    fn default() -> Self {
        EStreamDeviceFormFactor::k_EStreamDeviceFormFactorUnknown
    }
}

impl EStreamDeviceFormFactor {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EStreamDeviceFormFactor>("EStreamDeviceFormFactor")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamTransport)
pub enum EStreamTransport {
    // @@protoc_insertion_point(enum_value:EStreamTransport.k_EStreamTransportNone)
    k_EStreamTransportNone = 0,
    // @@protoc_insertion_point(enum_value:EStreamTransport.k_EStreamTransportUDP)
    k_EStreamTransportUDP = 1,
    // @@protoc_insertion_point(enum_value:EStreamTransport.k_EStreamTransportUDPRelay)
    k_EStreamTransportUDPRelay = 2,
    // @@protoc_insertion_point(enum_value:EStreamTransport.k_EStreamTransportWebRTC)
    k_EStreamTransportWebRTC = 3,
    // @@protoc_insertion_point(enum_value:EStreamTransport.k_EStreamTransportSDR)
    k_EStreamTransportSDR = 4,
    // @@protoc_insertion_point(enum_value:EStreamTransport.k_EStreamTransportUDP_SNS)
    k_EStreamTransportUDP_SNS = 5,
    // @@protoc_insertion_point(enum_value:EStreamTransport.k_EStreamTransportUDPRelay_SNS)
    k_EStreamTransportUDPRelay_SNS = 6,
}

impl ::protobuf::Enum for EStreamTransport {
    const NAME: &'static str = "EStreamTransport";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamTransport> {
        match value {
            0 => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportNone),
            1 => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportUDP),
            2 => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportUDPRelay),
            3 => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportWebRTC),
            4 => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportSDR),
            5 => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportUDP_SNS),
            6 => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportUDPRelay_SNS),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamTransport> {
        match str {
            "k_EStreamTransportNone" => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportNone),
            "k_EStreamTransportUDP" => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportUDP),
            "k_EStreamTransportUDPRelay" => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportUDPRelay),
            "k_EStreamTransportWebRTC" => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportWebRTC),
            "k_EStreamTransportSDR" => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportSDR),
            "k_EStreamTransportUDP_SNS" => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportUDP_SNS),
            "k_EStreamTransportUDPRelay_SNS" => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportUDPRelay_SNS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamTransport] = &[
        EStreamTransport::k_EStreamTransportNone,
        EStreamTransport::k_EStreamTransportUDP,
        EStreamTransport::k_EStreamTransportUDPRelay,
        EStreamTransport::k_EStreamTransportWebRTC,
        EStreamTransport::k_EStreamTransportSDR,
        EStreamTransport::k_EStreamTransportUDP_SNS,
        EStreamTransport::k_EStreamTransportUDPRelay_SNS,
    ];
}

impl ::protobuf::EnumFull for EStreamTransport {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStreamTransport").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EStreamTransport {
    fn default() -> Self {
        EStreamTransport::k_EStreamTransportNone
    }
}

impl EStreamTransport {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EStreamTransport>("EStreamTransport")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamInterface)
pub enum EStreamInterface {
    // @@protoc_insertion_point(enum_value:EStreamInterface.k_EStreamInterfaceDefault)
    k_EStreamInterfaceDefault = 0,
    // @@protoc_insertion_point(enum_value:EStreamInterface.k_EStreamInterfaceRecentGames)
    k_EStreamInterfaceRecentGames = 1,
    // @@protoc_insertion_point(enum_value:EStreamInterface.k_EStreamInterfaceBigPicture)
    k_EStreamInterfaceBigPicture = 2,
    // @@protoc_insertion_point(enum_value:EStreamInterface.k_EStreamInterfaceDesktop)
    k_EStreamInterfaceDesktop = 3,
}

impl ::protobuf::Enum for EStreamInterface {
    const NAME: &'static str = "EStreamInterface";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamInterface> {
        match value {
            0 => ::std::option::Option::Some(EStreamInterface::k_EStreamInterfaceDefault),
            1 => ::std::option::Option::Some(EStreamInterface::k_EStreamInterfaceRecentGames),
            2 => ::std::option::Option::Some(EStreamInterface::k_EStreamInterfaceBigPicture),
            3 => ::std::option::Option::Some(EStreamInterface::k_EStreamInterfaceDesktop),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamInterface> {
        match str {
            "k_EStreamInterfaceDefault" => ::std::option::Option::Some(EStreamInterface::k_EStreamInterfaceDefault),
            "k_EStreamInterfaceRecentGames" => ::std::option::Option::Some(EStreamInterface::k_EStreamInterfaceRecentGames),
            "k_EStreamInterfaceBigPicture" => ::std::option::Option::Some(EStreamInterface::k_EStreamInterfaceBigPicture),
            "k_EStreamInterfaceDesktop" => ::std::option::Option::Some(EStreamInterface::k_EStreamInterfaceDesktop),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamInterface] = &[
        EStreamInterface::k_EStreamInterfaceDefault,
        EStreamInterface::k_EStreamInterfaceRecentGames,
        EStreamInterface::k_EStreamInterfaceBigPicture,
        EStreamInterface::k_EStreamInterfaceDesktop,
    ];
}

impl ::protobuf::EnumFull for EStreamInterface {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStreamInterface").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EStreamInterface {
    fn default() -> Self {
        EStreamInterface::k_EStreamInterfaceDefault
    }
}

impl EStreamInterface {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EStreamInterface>("EStreamInterface")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ERemoteDeviceStreamingResult)
pub enum ERemoteDeviceStreamingResult {
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingSuccess)
    k_ERemoteDeviceStreamingSuccess = 0,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingUnauthorized)
    k_ERemoteDeviceStreamingUnauthorized = 1,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingScreenLocked)
    k_ERemoteDeviceStreamingScreenLocked = 2,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingFailed)
    k_ERemoteDeviceStreamingFailed = 3,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingBusy)
    k_ERemoteDeviceStreamingBusy = 4,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingInProgress)
    k_ERemoteDeviceStreamingInProgress = 5,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingCanceled)
    k_ERemoteDeviceStreamingCanceled = 6,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingDriversNotInstalled)
    k_ERemoteDeviceStreamingDriversNotInstalled = 7,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingDisabled)
    k_ERemoteDeviceStreamingDisabled = 8,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingBroadcastingActive)
    k_ERemoteDeviceStreamingBroadcastingActive = 9,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingVRActive)
    k_ERemoteDeviceStreamingVRActive = 10,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingPINRequired)
    k_ERemoteDeviceStreamingPINRequired = 11,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingTransportUnavailable)
    k_ERemoteDeviceStreamingTransportUnavailable = 12,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingInvisible)
    k_ERemoteDeviceStreamingInvisible = 13,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingGameLaunchFailed)
    k_ERemoteDeviceStreamingGameLaunchFailed = 14,
}

impl ::protobuf::Enum for ERemoteDeviceStreamingResult {
    const NAME: &'static str = "ERemoteDeviceStreamingResult";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ERemoteDeviceStreamingResult> {
        match value {
            0 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingSuccess),
            1 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingUnauthorized),
            2 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingScreenLocked),
            3 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingFailed),
            4 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingBusy),
            5 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingInProgress),
            6 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingCanceled),
            7 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingDriversNotInstalled),
            8 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingDisabled),
            9 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingBroadcastingActive),
            10 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingVRActive),
            11 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingPINRequired),
            12 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingTransportUnavailable),
            13 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingInvisible),
            14 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingGameLaunchFailed),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ERemoteDeviceStreamingResult> {
        match str {
            "k_ERemoteDeviceStreamingSuccess" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingSuccess),
            "k_ERemoteDeviceStreamingUnauthorized" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingUnauthorized),
            "k_ERemoteDeviceStreamingScreenLocked" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingScreenLocked),
            "k_ERemoteDeviceStreamingFailed" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingFailed),
            "k_ERemoteDeviceStreamingBusy" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingBusy),
            "k_ERemoteDeviceStreamingInProgress" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingInProgress),
            "k_ERemoteDeviceStreamingCanceled" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingCanceled),
            "k_ERemoteDeviceStreamingDriversNotInstalled" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingDriversNotInstalled),
            "k_ERemoteDeviceStreamingDisabled" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingDisabled),
            "k_ERemoteDeviceStreamingBroadcastingActive" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingBroadcastingActive),
            "k_ERemoteDeviceStreamingVRActive" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingVRActive),
            "k_ERemoteDeviceStreamingPINRequired" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingPINRequired),
            "k_ERemoteDeviceStreamingTransportUnavailable" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingTransportUnavailable),
            "k_ERemoteDeviceStreamingInvisible" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingInvisible),
            "k_ERemoteDeviceStreamingGameLaunchFailed" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingGameLaunchFailed),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ERemoteDeviceStreamingResult] = &[
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingSuccess,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingUnauthorized,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingScreenLocked,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingFailed,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingBusy,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingInProgress,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingCanceled,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingDriversNotInstalled,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingDisabled,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingBroadcastingActive,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingVRActive,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingPINRequired,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingTransportUnavailable,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingInvisible,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingGameLaunchFailed,
    ];
}

impl ::protobuf::EnumFull for ERemoteDeviceStreamingResult {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ERemoteDeviceStreamingResult").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ERemoteDeviceStreamingResult {
    fn default() -> Self {
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingSuccess
    }
}

impl ERemoteDeviceStreamingResult {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ERemoteDeviceStreamingResult>("ERemoteDeviceStreamingResult")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n*steammessages_remoteclient_discovery.proto\"\xfc\x01\n\x1fCMsgRemoteC\
    lientBroadcastHeader\x12\x1b\n\tclient_id\x18\x01\x20\x01(\x04R\x08clien\
    tId\x12[\n\x08msg_type\x18\x02\x20\x01(\x0e2\x1a.ERemoteClientBroadcastM\
    sg:$k_ERemoteClientBroadcastMsgDiscoveryR\x07msgType\x12\x1f\n\x0binstan\
    ce_id\x18\x03\x20\x01(\x04R\ninstanceId\x12\x1b\n\tdevice_id\x18\x04\x20\
    \x01(\x04R\x08deviceId\x12!\n\x0cdevice_token\x18\x05\x20\x01(\x0cR\x0bd\
    eviceToken\"\xd4\x06\n\x1fCMsgRemoteClientBroadcastStatus\x12\x18\n\x07v\
    ersion\x18\x01\x20\x01(\x05R\x07version\x12\x1f\n\x0bmin_version\x18\x02\
    \x20\x01(\x05R\nminVersion\x12!\n\x0cconnect_port\x18\x03\x20\x01(\rR\
    \x0bconnectPort\x12\x1a\n\x08hostname\x18\x04\x20\x01(\tR\x08hostname\
    \x12)\n\x10enabled_services\x18\x06\x20\x01(\rR\x0fenabledServices\x12\
    \x19\n\x06ostype\x18\x07\x20\x01(\x05:\x010R\x06ostype\x12\x18\n\x07is64\
    bit\x18\x08\x20\x01(\x08R\x07is64bit\x12;\n\x05users\x18\t\x20\x03(\x0b2\
    %.CMsgRemoteClientBroadcastStatus.UserR\x05users\x12\x1c\n\teuniverse\
    \x18\x0b\x20\x01(\x05R\teuniverse\x12\x1c\n\ttimestamp\x18\x0c\x20\x01(\
    \rR\ttimestamp\x12#\n\rscreen_locked\x18\r\x20\x01(\x08R\x0cscreenLocked\
    \x12#\n\rgames_running\x18\x0e\x20\x01(\x08R\x0cgamesRunning\x12#\n\rmac\
    _addresses\x18\x0f\x20\x03(\tR\x0cmacAddresses\x125\n\x17download_lan_pe\
    er_group\x18\x10\x20\x01(\rR\x14downloadLanPeerGroup\x12/\n\x13broadcast\
    ing_active\x18\x11\x20\x01(\x08R\x12broadcastingActive\x12\x1b\n\tvr_act\
    ive\x18\x12\x20\x01(\x08R\x08vrActive\x12,\n\x12content_cache_port\x18\
    \x13\x20\x01(\rR\x10contentCachePort\x12!\n\x0cip_addresses\x18\x14\x20\
    \x03(\tR\x0bipAddresses\x12*\n\x11public_ip_address\x18\x15\x20\x01(\tR\
    \x0fpublicIpAddress\x12+\n\x11remoteplay_active\x18\x16\x20\x01(\x08R\
    \x10remoteplayActive\x1a@\n\x04User\x12\x18\n\x07steamid\x18\x01\x20\x01\
    (\x06R\x07steamid\x12\x1e\n\x0bauth_key_id\x18\x02\x20\x01(\rR\tauthKeyI\
    d\"\\\n\"CMsgRemoteClientBroadcastDiscovery\x12\x17\n\x07seq_num\x18\x01\
    \x20\x01(\rR\x06seqNum\x12\x1d\n\nclient_ids\x18\x02\x20\x03(\x04R\tclie\
    ntIds\"L\n+CMsgRemoteClientBroadcastClientIDDeconflict\x12\x1d\n\nclient\
    _ids\x18\x02\x20\x03(\x04R\tclientIds\"\xe8\x04\n$CMsgRemoteDeviceAuthor\
    izationRequest\x12!\n\x0cdevice_token\x18\x01\x20\x02(\x0cR\x0bdeviceTok\
    en\x12\x1f\n\x0bdevice_name\x18\x02\x20\x01(\tR\ndeviceName\x12+\n\x11en\
    crypted_request\x18\x03\x20\x02(\x0cR\x10encryptedRequest\x1a\x95\x03\n\
    \x11CKeyEscrow_Ticket\x12\x1a\n\x08password\x18\x01\x20\x01(\x0cR\x08pas\
    sword\x12\x1e\n\nidentifier\x18\x02\x20\x01(\x04R\nidentifier\x12\x18\n\
    \x07payload\x18\x03\x20\x01(\x0cR\x07payload\x12\x1c\n\ttimestamp\x18\
    \x04\x20\x01(\rR\ttimestamp\x12m\n\x05usage\x18\x05\x20\x01(\x0e25.CMsgR\
    emoteDeviceAuthorizationRequest.EKeyEscrowUsage:\x20k_EKeyEscrowUsageStr\
    eamingDeviceR\x05usage\x12\x1f\n\x0bdevice_name\x18\x06\x20\x01(\tR\ndev\
    iceName\x12!\n\x0cdevice_model\x18\x07\x20\x01(\tR\x0bdeviceModel\x12#\n\
    \rdevice_serial\x18\x08\x20\x01(\tR\x0cdeviceSerial\x124\n\x16device_pro\
    visioning_id\x18\t\x20\x01(\rR\x14deviceProvisioningId\"7\n\x0fEKeyEscro\
    wUsage\x12$\n\x20k_EKeyEscrowUsageStreamingDevice\x10\0\",\n*CMsgRemoteD\
    eviceAuthorizationCancelRequest\"\xa1\x01\n%CMsgRemoteDeviceAuthorizatio\
    nResponse\x12^\n\x06result\x18\x01\x20\x02(\x0e2!.ERemoteDeviceAuthoriza\
    tionResult:#k_ERemoteDeviceAuthorizationSuccessR\x06result\x12\x18\n\x07\
    steamid\x18\x02\x20\x01(\x06R\x07steamid\"\xe0\x08\n\x20CMsgRemoteDevice\
    StreamingRequest\x12\x1d\n\nrequest_id\x18\x01\x20\x02(\rR\trequestId\
    \x120\n\x14maximum_resolution_x\x18\x02\x20\x01(\x05R\x12maximumResoluti\
    onX\x120\n\x14maximum_resolution_y\x18\x03\x20\x01(\x05R\x12maximumResol\
    utionY\x121\n\x13audio_channel_count\x18\x04\x20\x01(\x05:\x012R\x11audi\
    oChannelCount\x12%\n\x0edevice_version\x18\x05\x20\x01(\tR\rdeviceVersio\
    n\x12%\n\x0estream_desktop\x18\x06\x20\x01(\x08R\rstreamDesktop\x12!\n\
    \x0cdevice_token\x18\x07\x20\x01(\x0cR\x0bdeviceToken\x12\x10\n\x03pin\
    \x18\x08\x20\x01(\x0cR\x03pin\x12:\n\x16enable_video_streaming\x18\t\x20\
    \x01(\x08:\x04trueR\x14enableVideoStreaming\x12:\n\x16enable_audio_strea\
    ming\x18\n\x20\x01(\x08:\x04trueR\x14enableAudioStreaming\x12:\n\x16enab\
    le_input_streaming\x18\x0b\x20\x01(\x08:\x04trueR\x14enableInputStreamin\
    g\x12!\n\x0cnetwork_test\x18\x0c\x20\x01(\x08R\x0bnetworkTest\x12\x1b\n\
    \tclient_id\x18\r\x20\x01(\x04R\x08clientId\x12B\n\x13supported_transpor\
    t\x18\x0e\x20\x03(\x0e2\x11.EStreamTransportR\x12supportedTransport\x12\
    \x1e\n\nrestricted\x18\x0f\x20\x01(\x08R\nrestricted\x12[\n\x0bform_fact\
    or\x18\x10\x20\x01(\x0e2\x18.EStreamDeviceFormFactor:\x20k_EStreamDevice\
    FormFactorUnknownR\nformFactor\x12#\n\rgamepad_count\x18\x11\x20\x01(\
    \x05R\x0cgamepadCount\x12M\n\x08gamepads\x18\x12\x20\x03(\x0b21.CMsgRemo\
    teDeviceStreamingRequest.ReservedGamepadR\x08gamepads\x12\x16\n\x06gamei\
    d\x18\x13\x20\x01(\x04R\x06gameid\x12W\n\x10stream_interface\x18\x14\x20\
    \x01(\x0e2\x11.EStreamInterface:\x19k_EStreamInterfaceDefaultR\x0fstream\
    Interface\x1ai\n\x0fReservedGamepad\x12'\n\x0fcontroller_type\x18\x01\
    \x20\x01(\rR\x0econtrollerType\x12-\n\x12controller_subtype\x18\x02\x20\
    \x01(\rR\x11controllerSubtype\"G\n&CMsgRemoteDeviceStreamingCancelReques\
    t\x12\x1d\n\nrequest_id\x18\x01\x20\x02(\rR\trequestId\"^\n!CMsgRemoteDe\
    viceStreamingProgress\x12\x1d\n\nrequest_id\x18\x01\x20\x02(\rR\trequest\
    Id\x12\x1a\n\x08progress\x18\x02\x20\x01(\x02R\x08progress\"\xe1\x02\n!C\
    MsgRemoteDeviceStreamingResponse\x12\x1d\n\nrequest_id\x18\x01\x20\x02(\
    \rR\trequestId\x12V\n\x06result\x18\x02\x20\x02(\x0e2\x1d.ERemoteDeviceS\
    treamingResult:\x1fk_ERemoteDeviceStreamingSuccessR\x06result\x12\x12\n\
    \x04port\x18\x03\x20\x01(\rR\x04port\x122\n\x15encrypted_session_key\x18\
    \x04\x20\x01(\x0cR\x13encryptedSessionKey\x12F\n\ttransport\x18\x06\x20\
    \x01(\x0e2\x11.EStreamTransport:\x15k_EStreamTransportUDPR\ttransport\
    \x12!\n\x0crelay_server\x18\x07\x20\x01(\tR\x0brelayServer\x12\x12\n\x04\
    cert\x18\x08\x20\x01(\tR\x04cert\"[\n\x1cCMsgRemoteDeviceProofRequest\
    \x12\x1c\n\tchallenge\x18\x01\x20\x02(\x0cR\tchallenge\x12\x1d\n\nreques\
    t_id\x18\x02\x20\x01(\rR\trequestId\"Z\n\x1dCMsgRemoteDeviceProofRespons\
    e\x12\x1a\n\x08response\x18\x01\x20\x02(\x0cR\x08response\x12\x1d\n\nreq\
    uest_id\x18\x02\x20\x01(\rR\trequestId\"W\n%CMsgRemoteDeviceStreamTransp\
    ortSignal\x12\x14\n\x05token\x18\x01\x20\x01(\x0cR\x05token\x12\x18\n\
    \x07payload\x18\x02\x20\x01(\x0cR\x07payload*\xd2\x04\n\x19ERemoteClient\
    BroadcastMsg\x12(\n$k_ERemoteClientBroadcastMsgDiscovery\x10\0\x12%\n!k_\
    ERemoteClientBroadcastMsgStatus\x10\x01\x12&\n\"k_ERemoteClientBroadcast\
    MsgOffline\x10\x02\x12'\n#k_ERemoteDeviceAuthorizationRequest\x10\x03\
    \x12(\n$k_ERemoteDeviceAuthorizationResponse\x10\x04\x12#\n\x1fk_ERemote\
    DeviceStreamingRequest\x10\x05\x12$\n\x20k_ERemoteDeviceStreamingRespons\
    e\x10\x06\x12\x1f\n\x1bk_ERemoteDeviceProofRequest\x10\x07\x12\x20\n\x1c\
    k_ERemoteDeviceProofResponse\x10\x08\x12-\n)k_ERemoteDeviceAuthorization\
    CancelRequest\x10\t\x12)\n%k_ERemoteDeviceStreamingCancelRequest\x10\n\
    \x121\n-k_ERemoteClientBroadcastMsgClientIDDeconflict\x10\x0b\x12(\n$k_E\
    RemoteDeviceStreamTransportSignal\x10\x0c\x12$\n\x20k_ERemoteDeviceStrea\
    mingProgress\x10\r*\xd7\x01\n\x14ERemoteClientService\x12\x1e\n\x1ak_ERe\
    moteClientServiceNone\x10\0\x12'\n#k_ERemoteClientServiceRemoteControl\
    \x10\x01\x12'\n#k_ERemoteClientServiceGameStreaming\x10\x02\x12%\n!k_ERe\
    moteClientServiceSiteLicense\x10\x04\x12&\n\"k_ERemoteClientServiceConte\
    ntCache\x10\x08*\x97\x03\n\x20ERemoteDeviceAuthorizationResult\x12'\n#k_\
    ERemoteDeviceAuthorizationSuccess\x10\0\x12&\n\"k_ERemoteDeviceAuthoriza\
    tionDenied\x10\x01\x12+\n'k_ERemoteDeviceAuthorizationNotLoggedIn\x10\
    \x02\x12'\n#k_ERemoteDeviceAuthorizationOffline\x10\x03\x12$\n\x20k_ERem\
    oteDeviceAuthorizationBusy\x10\x04\x12*\n&k_ERemoteDeviceAuthorizationIn\
    Progress\x10\x05\x12(\n$k_ERemoteDeviceAuthorizationTimedOut\x10\x06\x12\
    &\n\"k_ERemoteDeviceAuthorizationFailed\x10\x07\x12(\n$k_ERemoteDeviceAu\
    thorizationCanceled\x10\x08*\xd0\x01\n\x17EStreamDeviceFormFactor\x12$\n\
    \x20k_EStreamDeviceFormFactorUnknown\x10\0\x12\"\n\x1ek_EStreamDeviceFor\
    mFactorPhone\x10\x01\x12#\n\x1fk_EStreamDeviceFormFactorTablet\x10\x02\
    \x12%\n!k_EStreamDeviceFormFactorComputer\x10\x03\x12\x1f\n\x1bk_EStream\
    DeviceFormFactorTV\x10\x04*\xe5\x01\n\x10EStreamTransport\x12\x1a\n\x16k\
    _EStreamTransportNone\x10\0\x12\x19\n\x15k_EStreamTransportUDP\x10\x01\
    \x12\x1e\n\x1ak_EStreamTransportUDPRelay\x10\x02\x12\x1c\n\x18k_EStreamT\
    ransportWebRTC\x10\x03\x12\x19\n\x15k_EStreamTransportSDR\x10\x04\x12\
    \x1d\n\x19k_EStreamTransportUDP_SNS\x10\x05\x12\"\n\x1ek_EStreamTranspor\
    tUDPRelay_SNS\x10\x06*\x95\x01\n\x10EStreamInterface\x12\x1d\n\x19k_EStr\
    eamInterfaceDefault\x10\0\x12!\n\x1dk_EStreamInterfaceRecentGames\x10\
    \x01\x12\x20\n\x1ck_EStreamInterfaceBigPicture\x10\x02\x12\x1d\n\x19k_ES\
    treamInterfaceDesktop\x10\x03*\x88\x05\n\x1cERemoteDeviceStreamingResult\
    \x12#\n\x1fk_ERemoteDeviceStreamingSuccess\x10\0\x12(\n$k_ERemoteDeviceS\
    treamingUnauthorized\x10\x01\x12(\n$k_ERemoteDeviceStreamingScreenLocked\
    \x10\x02\x12\"\n\x1ek_ERemoteDeviceStreamingFailed\x10\x03\x12\x20\n\x1c\
    k_ERemoteDeviceStreamingBusy\x10\x04\x12&\n\"k_ERemoteDeviceStreamingInP\
    rogress\x10\x05\x12$\n\x20k_ERemoteDeviceStreamingCanceled\x10\x06\x12/\
    \n+k_ERemoteDeviceStreamingDriversNotInstalled\x10\x07\x12$\n\x20k_ERemo\
    teDeviceStreamingDisabled\x10\x08\x12.\n*k_ERemoteDeviceStreamingBroadca\
    stingActive\x10\t\x12$\n\x20k_ERemoteDeviceStreamingVRActive\x10\n\x12'\
    \n#k_ERemoteDeviceStreamingPINRequired\x10\x0b\x120\n,k_ERemoteDeviceStr\
    eamingTransportUnavailable\x10\x0c\x12%\n!k_ERemoteDeviceStreamingInvisi\
    ble\x10\r\x12,\n(k_ERemoteDeviceStreamingGameLaunchFailed\x10\x0eB\x02H\
    \x01J\xdbJ\n\x07\x12\x05\0\0\xd9\x01\x01\n\x08\n\x01\x08\x12\x03\0\0\x1c\
    \n\t\n\x02\x08\t\x12\x03\0\0\x1c\n\n\n\x02\x05\0\x12\x04\x02\0\x11\x01\n\
    \n\n\x03\x05\0\x01\x12\x03\x02\x05\x1e\n\x0b\n\x04\x05\0\x02\0\x12\x03\
    \x03\x081\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\x03\x08,\n\x0c\n\x05\x05\0\
    \x02\0\x02\x12\x03\x03/0\n\x0b\n\x04\x05\0\x02\x01\x12\x03\x04\x08.\n\
    \x0c\n\x05\x05\0\x02\x01\x01\x12\x03\x04\x08)\n\x0c\n\x05\x05\0\x02\x01\
    \x02\x12\x03\x04,-\n\x0b\n\x04\x05\0\x02\x02\x12\x03\x05\x08/\n\x0c\n\
    \x05\x05\0\x02\x02\x01\x12\x03\x05\x08*\n\x0c\n\x05\x05\0\x02\x02\x02\
    \x12\x03\x05-.\n\x0b\n\x04\x05\0\x02\x03\x12\x03\x06\x080\n\x0c\n\x05\
    \x05\0\x02\x03\x01\x12\x03\x06\x08+\n\x0c\n\x05\x05\0\x02\x03\x02\x12\
    \x03\x06./\n\x0b\n\x04\x05\0\x02\x04\x12\x03\x07\x081\n\x0c\n\x05\x05\0\
    \x02\x04\x01\x12\x03\x07\x08,\n\x0c\n\x05\x05\0\x02\x04\x02\x12\x03\x07/\
    0\n\x0b\n\x04\x05\0\x02\x05\x12\x03\x08\x08,\n\x0c\n\x05\x05\0\x02\x05\
    \x01\x12\x03\x08\x08'\n\x0c\n\x05\x05\0\x02\x05\x02\x12\x03\x08*+\n\x0b\
    \n\x04\x05\0\x02\x06\x12\x03\t\x08-\n\x0c\n\x05\x05\0\x02\x06\x01\x12\
    \x03\t\x08(\n\x0c\n\x05\x05\0\x02\x06\x02\x12\x03\t+,\n\x0b\n\x04\x05\0\
    \x02\x07\x12\x03\n\x08(\n\x0c\n\x05\x05\0\x02\x07\x01\x12\x03\n\x08#\n\
    \x0c\n\x05\x05\0\x02\x07\x02\x12\x03\n&'\n\x0b\n\x04\x05\0\x02\x08\x12\
    \x03\x0b\x08)\n\x0c\n\x05\x05\0\x02\x08\x01\x12\x03\x0b\x08$\n\x0c\n\x05\
    \x05\0\x02\x08\x02\x12\x03\x0b'(\n\x0b\n\x04\x05\0\x02\t\x12\x03\x0c\x08\
    6\n\x0c\n\x05\x05\0\x02\t\x01\x12\x03\x0c\x081\n\x0c\n\x05\x05\0\x02\t\
    \x02\x12\x03\x0c45\n\x0b\n\x04\x05\0\x02\n\x12\x03\r\x083\n\x0c\n\x05\
    \x05\0\x02\n\x01\x12\x03\r\x08-\n\x0c\n\x05\x05\0\x02\n\x02\x12\x03\r02\
    \n\x0b\n\x04\x05\0\x02\x0b\x12\x03\x0e\x08;\n\x0c\n\x05\x05\0\x02\x0b\
    \x01\x12\x03\x0e\x085\n\x0c\n\x05\x05\0\x02\x0b\x02\x12\x03\x0e8:\n\x0b\
    \n\x04\x05\0\x02\x0c\x12\x03\x0f\x082\n\x0c\n\x05\x05\0\x02\x0c\x01\x12\
    \x03\x0f\x08,\n\x0c\n\x05\x05\0\x02\x0c\x02\x12\x03\x0f/1\n\x0b\n\x04\
    \x05\0\x02\r\x12\x03\x10\x08.\n\x0c\n\x05\x05\0\x02\r\x01\x12\x03\x10\
    \x08(\n\x0c\n\x05\x05\0\x02\r\x02\x12\x03\x10+-\n\n\n\x02\x05\x01\x12\
    \x04\x13\0\x19\x01\n\n\n\x03\x05\x01\x01\x12\x03\x13\x05\x19\n\x0b\n\x04\
    \x05\x01\x02\0\x12\x03\x14\x08'\n\x0c\n\x05\x05\x01\x02\0\x01\x12\x03\
    \x14\x08\"\n\x0c\n\x05\x05\x01\x02\0\x02\x12\x03\x14%&\n\x0b\n\x04\x05\
    \x01\x02\x01\x12\x03\x15\x080\n\x0c\n\x05\x05\x01\x02\x01\x01\x12\x03\
    \x15\x08+\n\x0c\n\x05\x05\x01\x02\x01\x02\x12\x03\x15./\n\x0b\n\x04\x05\
    \x01\x02\x02\x12\x03\x16\x080\n\x0c\n\x05\x05\x01\x02\x02\x01\x12\x03\
    \x16\x08+\n\x0c\n\x05\x05\x01\x02\x02\x02\x12\x03\x16./\n\x0b\n\x04\x05\
    \x01\x02\x03\x12\x03\x17\x08.\n\x0c\n\x05\x05\x01\x02\x03\x01\x12\x03\
    \x17\x08)\n\x0c\n\x05\x05\x01\x02\x03\x02\x12\x03\x17,-\n\x0b\n\x04\x05\
    \x01\x02\x04\x12\x03\x18\x08/\n\x0c\n\x05\x05\x01\x02\x04\x01\x12\x03\
    \x18\x08*\n\x0c\n\x05\x05\x01\x02\x04\x02\x12\x03\x18-.\n\n\n\x02\x05\
    \x02\x12\x04\x1b\0%\x01\n\n\n\x03\x05\x02\x01\x12\x03\x1b\x05%\n\x0b\n\
    \x04\x05\x02\x02\0\x12\x03\x1c\x080\n\x0c\n\x05\x05\x02\x02\0\x01\x12\
    \x03\x1c\x08+\n\x0c\n\x05\x05\x02\x02\0\x02\x12\x03\x1c./\n\x0b\n\x04\
    \x05\x02\x02\x01\x12\x03\x1d\x08/\n\x0c\n\x05\x05\x02\x02\x01\x01\x12\
    \x03\x1d\x08*\n\x0c\n\x05\x05\x02\x02\x01\x02\x12\x03\x1d-.\n\x0b\n\x04\
    \x05\x02\x02\x02\x12\x03\x1e\x084\n\x0c\n\x05\x05\x02\x02\x02\x01\x12\
    \x03\x1e\x08/\n\x0c\n\x05\x05\x02\x02\x02\x02\x12\x03\x1e23\n\x0b\n\x04\
    \x05\x02\x02\x03\x12\x03\x1f\x080\n\x0c\n\x05\x05\x02\x02\x03\x01\x12\
    \x03\x1f\x08+\n\x0c\n\x05\x05\x02\x02\x03\x02\x12\x03\x1f./\n\x0b\n\x04\
    \x05\x02\x02\x04\x12\x03\x20\x08-\n\x0c\n\x05\x05\x02\x02\x04\x01\x12\
    \x03\x20\x08(\n\x0c\n\x05\x05\x02\x02\x04\x02\x12\x03\x20+,\n\x0b\n\x04\
    \x05\x02\x02\x05\x12\x03!\x083\n\x0c\n\x05\x05\x02\x02\x05\x01\x12\x03!\
    \x08.\n\x0c\n\x05\x05\x02\x02\x05\x02\x12\x03!12\n\x0b\n\x04\x05\x02\x02\
    \x06\x12\x03\"\x081\n\x0c\n\x05\x05\x02\x02\x06\x01\x12\x03\"\x08,\n\x0c\
    \n\x05\x05\x02\x02\x06\x02\x12\x03\"/0\n\x0b\n\x04\x05\x02\x02\x07\x12\
    \x03#\x08/\n\x0c\n\x05\x05\x02\x02\x07\x01\x12\x03#\x08*\n\x0c\n\x05\x05\
    \x02\x02\x07\x02\x12\x03#-.\n\x0b\n\x04\x05\x02\x02\x08\x12\x03$\x081\n\
    \x0c\n\x05\x05\x02\x02\x08\x01\x12\x03$\x08,\n\x0c\n\x05\x05\x02\x02\x08\
    \x02\x12\x03$/0\n\n\n\x02\x05\x03\x12\x04'\0-\x01\n\n\n\x03\x05\x03\x01\
    \x12\x03'\x05\x1c\n\x0b\n\x04\x05\x03\x02\0\x12\x03(\x08-\n\x0c\n\x05\
    \x05\x03\x02\0\x01\x12\x03(\x08(\n\x0c\n\x05\x05\x03\x02\0\x02\x12\x03(+\
    ,\n\x0b\n\x04\x05\x03\x02\x01\x12\x03)\x08+\n\x0c\n\x05\x05\x03\x02\x01\
    \x01\x12\x03)\x08&\n\x0c\n\x05\x05\x03\x02\x01\x02\x12\x03))*\n\x0b\n\
    \x04\x05\x03\x02\x02\x12\x03*\x08,\n\x0c\n\x05\x05\x03\x02\x02\x01\x12\
    \x03*\x08'\n\x0c\n\x05\x05\x03\x02\x02\x02\x12\x03**+\n\x0b\n\x04\x05\
    \x03\x02\x03\x12\x03+\x08.\n\x0c\n\x05\x05\x03\x02\x03\x01\x12\x03+\x08)\
    \n\x0c\n\x05\x05\x03\x02\x03\x02\x12\x03+,-\n\x0b\n\x04\x05\x03\x02\x04\
    \x12\x03,\x08(\n\x0c\n\x05\x05\x03\x02\x04\x01\x12\x03,\x08#\n\x0c\n\x05\
    \x05\x03\x02\x04\x02\x12\x03,&'\n\n\n\x02\x05\x04\x12\x04/\07\x01\n\n\n\
    \x03\x05\x04\x01\x12\x03/\x05\x15\n\x0b\n\x04\x05\x04\x02\0\x12\x030\x08\
    #\n\x0c\n\x05\x05\x04\x02\0\x01\x12\x030\x08\x1e\n\x0c\n\x05\x05\x04\x02\
    \0\x02\x12\x030!\"\n\x0b\n\x04\x05\x04\x02\x01\x12\x031\x08\"\n\x0c\n\
    \x05\x05\x04\x02\x01\x01\x12\x031\x08\x1d\n\x0c\n\x05\x05\x04\x02\x01\
    \x02\x12\x031\x20!\n\x0b\n\x04\x05\x04\x02\x02\x12\x032\x08'\n\x0c\n\x05\
    \x05\x04\x02\x02\x01\x12\x032\x08\"\n\x0c\n\x05\x05\x04\x02\x02\x02\x12\
    \x032%&\n\x0b\n\x04\x05\x04\x02\x03\x12\x033\x08%\n\x0c\n\x05\x05\x04\
    \x02\x03\x01\x12\x033\x08\x20\n\x0c\n\x05\x05\x04\x02\x03\x02\x12\x033#$\
    \n\x0b\n\x04\x05\x04\x02\x04\x12\x034\x08\"\n\x0c\n\x05\x05\x04\x02\x04\
    \x01\x12\x034\x08\x1d\n\x0c\n\x05\x05\x04\x02\x04\x02\x12\x034\x20!\n\
    \x0b\n\x04\x05\x04\x02\x05\x12\x035\x08&\n\x0c\n\x05\x05\x04\x02\x05\x01\
    \x12\x035\x08!\n\x0c\n\x05\x05\x04\x02\x05\x02\x12\x035$%\n\x0b\n\x04\
    \x05\x04\x02\x06\x12\x036\x08+\n\x0c\n\x05\x05\x04\x02\x06\x01\x12\x036\
    \x08&\n\x0c\n\x05\x05\x04\x02\x06\x02\x12\x036)*\n\n\n\x02\x05\x05\x12\
    \x049\0>\x01\n\n\n\x03\x05\x05\x01\x12\x039\x05\x15\n\x0b\n\x04\x05\x05\
    \x02\0\x12\x03:\x08&\n\x0c\n\x05\x05\x05\x02\0\x01\x12\x03:\x08!\n\x0c\n\
    \x05\x05\x05\x02\0\x02\x12\x03:$%\n\x0b\n\x04\x05\x05\x02\x01\x12\x03;\
    \x08*\n\x0c\n\x05\x05\x05\x02\x01\x01\x12\x03;\x08%\n\x0c\n\x05\x05\x05\
    \x02\x01\x02\x12\x03;()\n\x0b\n\x04\x05\x05\x02\x02\x12\x03<\x08)\n\x0c\
    \n\x05\x05\x05\x02\x02\x01\x12\x03<\x08$\n\x0c\n\x05\x05\x05\x02\x02\x02\
    \x12\x03<'(\n\x0b\n\x04\x05\x05\x02\x03\x12\x03=\x08&\n\x0c\n\x05\x05\
    \x05\x02\x03\x01\x12\x03=\x08!\n\x0c\n\x05\x05\x05\x02\x03\x02\x12\x03=$\
    %\n\n\n\x02\x05\x06\x12\x04@\0P\x01\n\n\n\x03\x05\x06\x01\x12\x03@\x05!\
    \n\x0b\n\x04\x05\x06\x02\0\x12\x03A\x08,\n\x0c\n\x05\x05\x06\x02\0\x01\
    \x12\x03A\x08'\n\x0c\n\x05\x05\x06\x02\0\x02\x12\x03A*+\n\x0b\n\x04\x05\
    \x06\x02\x01\x12\x03B\x081\n\x0c\n\x05\x05\x06\x02\x01\x01\x12\x03B\x08,\
    \n\x0c\n\x05\x05\x06\x02\x01\x02\x12\x03B/0\n\x0b\n\x04\x05\x06\x02\x02\
    \x12\x03C\x081\n\x0c\n\x05\x05\x06\x02\x02\x01\x12\x03C\x08,\n\x0c\n\x05\
    \x05\x06\x02\x02\x02\x12\x03C/0\n\x0b\n\x04\x05\x06\x02\x03\x12\x03D\x08\
    +\n\x0c\n\x05\x05\x06\x02\x03\x01\x12\x03D\x08&\n\x0c\n\x05\x05\x06\x02\
    \x03\x02\x12\x03D)*\n\x0b\n\x04\x05\x06\x02\x04\x12\x03E\x08)\n\x0c\n\
    \x05\x05\x06\x02\x04\x01\x12\x03E\x08$\n\x0c\n\x05\x05\x06\x02\x04\x02\
    \x12\x03E'(\n\x0b\n\x04\x05\x06\x02\x05\x12\x03F\x08/\n\x0c\n\x05\x05\
    \x06\x02\x05\x01\x12\x03F\x08*\n\x0c\n\x05\x05\x06\x02\x05\x02\x12\x03F-\
    .\n\x0b\n\x04\x05\x06\x02\x06\x12\x03G\x08-\n\x0c\n\x05\x05\x06\x02\x06\
    \x01\x12\x03G\x08(\n\x0c\n\x05\x05\x06\x02\x06\x02\x12\x03G+,\n\x0b\n\
    \x04\x05\x06\x02\x07\x12\x03H\x088\n\x0c\n\x05\x05\x06\x02\x07\x01\x12\
    \x03H\x083\n\x0c\n\x05\x05\x06\x02\x07\x02\x12\x03H67\n\x0b\n\x04\x05\
    \x06\x02\x08\x12\x03I\x08-\n\x0c\n\x05\x05\x06\x02\x08\x01\x12\x03I\x08(\
    \n\x0c\n\x05\x05\x06\x02\x08\x02\x12\x03I+,\n\x0b\n\x04\x05\x06\x02\t\
    \x12\x03J\x087\n\x0c\n\x05\x05\x06\x02\t\x01\x12\x03J\x082\n\x0c\n\x05\
    \x05\x06\x02\t\x02\x12\x03J56\n\x0b\n\x04\x05\x06\x02\n\x12\x03K\x08.\n\
    \x0c\n\x05\x05\x06\x02\n\x01\x12\x03K\x08(\n\x0c\n\x05\x05\x06\x02\n\x02\
    \x12\x03K+-\n\x0b\n\x04\x05\x06\x02\x0b\x12\x03L\x081\n\x0c\n\x05\x05\
    \x06\x02\x0b\x01\x12\x03L\x08+\n\x0c\n\x05\x05\x06\x02\x0b\x02\x12\x03L.\
    0\n\x0b\n\x04\x05\x06\x02\x0c\x12\x03M\x08:\n\x0c\n\x05\x05\x06\x02\x0c\
    \x01\x12\x03M\x084\n\x0c\n\x05\x05\x06\x02\x0c\x02\x12\x03M79\n\x0b\n\
    \x04\x05\x06\x02\r\x12\x03N\x08/\n\x0c\n\x05\x05\x06\x02\r\x01\x12\x03N\
    \x08)\n\x0c\n\x05\x05\x06\x02\r\x02\x12\x03N,.\n\x0b\n\x04\x05\x06\x02\
    \x0e\x12\x03O\x086\n\x0c\n\x05\x05\x06\x02\x0e\x01\x12\x03O\x080\n\x0c\n\
    \x05\x05\x06\x02\x0e\x02\x12\x03O35\n\n\n\x02\x04\0\x12\x04R\0X\x01\n\n\
    \n\x03\x04\0\x01\x12\x03R\x08'\n\x0b\n\x04\x04\0\x02\0\x12\x03S\x08&\n\
    \x0c\n\x05\x04\0\x02\0\x04\x12\x03S\x08\x10\n\x0c\n\x05\x04\0\x02\0\x05\
    \x12\x03S\x11\x17\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03S\x18!\n\x0c\n\x05\
    \x04\0\x02\0\x03\x12\x03S$%\n\x0b\n\x04\x04\0\x02\x01\x12\x03T\x08j\n\
    \x0c\n\x05\x04\0\x02\x01\x04\x12\x03T\x08\x10\n\x0c\n\x05\x04\0\x02\x01\
    \x06\x12\x03T\x11+\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03T,4\n\x0c\n\x05\
    \x04\0\x02\x01\x03\x12\x03T78\n\x0c\n\x05\x04\0\x02\x01\x08\x12\x03T9i\n\
    \x0c\n\x05\x04\0\x02\x01\x07\x12\x03TDh\n\x0b\n\x04\x04\0\x02\x02\x12\
    \x03U\x08(\n\x0c\n\x05\x04\0\x02\x02\x04\x12\x03U\x08\x10\n\x0c\n\x05\
    \x04\0\x02\x02\x05\x12\x03U\x11\x17\n\x0c\n\x05\x04\0\x02\x02\x01\x12\
    \x03U\x18#\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03U&'\n\x0b\n\x04\x04\0\
    \x02\x03\x12\x03V\x08&\n\x0c\n\x05\x04\0\x02\x03\x04\x12\x03V\x08\x10\n\
    \x0c\n\x05\x04\0\x02\x03\x05\x12\x03V\x11\x17\n\x0c\n\x05\x04\0\x02\x03\
    \x01\x12\x03V\x18!\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03V$%\n\x0b\n\x04\
    \x04\0\x02\x04\x12\x03W\x08(\n\x0c\n\x05\x04\0\x02\x04\x04\x12\x03W\x08\
    \x10\n\x0c\n\x05\x04\0\x02\x04\x05\x12\x03W\x11\x16\n\x0c\n\x05\x04\0\
    \x02\x04\x01\x12\x03W\x17#\n\x0c\n\x05\x04\0\x02\x04\x03\x12\x03W&'\n\n\
    \n\x02\x04\x01\x12\x04Z\0t\x01\n\n\n\x03\x04\x01\x01\x12\x03Z\x08'\n\x0c\
    \n\x04\x04\x01\x03\0\x12\x04[\x08^\t\n\x0c\n\x05\x04\x01\x03\0\x01\x12\
    \x03[\x10\x14\n\r\n\x06\x04\x01\x03\0\x02\0\x12\x03\\\x10-\n\x0e\n\x07\
    \x04\x01\x03\0\x02\0\x04\x12\x03\\\x10\x18\n\x0e\n\x07\x04\x01\x03\0\x02\
    \0\x05\x12\x03\\\x19\x20\n\x0e\n\x07\x04\x01\x03\0\x02\0\x01\x12\x03\\!(\
    \n\x0e\n\x07\x04\x01\x03\0\x02\0\x03\x12\x03\\+,\n\r\n\x06\x04\x01\x03\0\
    \x02\x01\x12\x03]\x100\n\x0e\n\x07\x04\x01\x03\0\x02\x01\x04\x12\x03]\
    \x10\x18\n\x0e\n\x07\x04\x01\x03\0\x02\x01\x05\x12\x03]\x19\x1f\n\x0e\n\
    \x07\x04\x01\x03\0\x02\x01\x01\x12\x03]\x20+\n\x0e\n\x07\x04\x01\x03\0\
    \x02\x01\x03\x12\x03]./\n\x0b\n\x04\x04\x01\x02\0\x12\x03`\x08#\n\x0c\n\
    \x05\x04\x01\x02\0\x04\x12\x03`\x08\x10\n\x0c\n\x05\x04\x01\x02\0\x05\
    \x12\x03`\x11\x16\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03`\x17\x1e\n\x0c\n\
    \x05\x04\x01\x02\0\x03\x12\x03`!\"\n\x0b\n\x04\x04\x01\x02\x01\x12\x03a\
    \x08'\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\x03a\x08\x10\n\x0c\n\x05\x04\
    \x01\x02\x01\x05\x12\x03a\x11\x16\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\
    \x03a\x17\"\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03a%&\n\x0b\n\x04\x04\
    \x01\x02\x02\x12\x03b\x08)\n\x0c\n\x05\x04\x01\x02\x02\x04\x12\x03b\x08\
    \x10\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03b\x11\x17\n\x0c\n\x05\x04\
    \x01\x02\x02\x01\x12\x03b\x18$\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03b'\
    (\n\x0b\n\x04\x04\x01\x02\x03\x12\x03c\x08%\n\x0c\n\x05\x04\x01\x02\x03\
    \x04\x12\x03c\x08\x10\n\x0c\n\x05\x04\x01\x02\x03\x05\x12\x03c\x11\x17\n\
    \x0c\n\x05\x04\x01\x02\x03\x01\x12\x03c\x18\x20\n\x0c\n\x05\x04\x01\x02\
    \x03\x03\x12\x03c#$\n\x0b\n\x04\x04\x01\x02\x04\x12\x03d\x08-\n\x0c\n\
    \x05\x04\x01\x02\x04\x04\x12\x03d\x08\x10\n\x0c\n\x05\x04\x01\x02\x04\
    \x05\x12\x03d\x11\x17\n\x0c\n\x05\x04\x01\x02\x04\x01\x12\x03d\x18(\n\
    \x0c\n\x05\x04\x01\x02\x04\x03\x12\x03d+,\n\x0b\n\x04\x04\x01\x02\x05\
    \x12\x03e\x080\n\x0c\n\x05\x04\x01\x02\x05\x04\x12\x03e\x08\x10\n\x0c\n\
    \x05\x04\x01\x02\x05\x05\x12\x03e\x11\x16\n\x0c\n\x05\x04\x01\x02\x05\
    \x01\x12\x03e\x17\x1d\n\x0c\n\x05\x04\x01\x02\x05\x03\x12\x03e\x20!\n\
    \x0c\n\x05\x04\x01\x02\x05\x08\x12\x03e\"/\n\x0c\n\x05\x04\x01\x02\x05\
    \x07\x12\x03e-.\n\x0b\n\x04\x04\x01\x02\x06\x12\x03f\x08\"\n\x0c\n\x05\
    \x04\x01\x02\x06\x04\x12\x03f\x08\x10\n\x0c\n\x05\x04\x01\x02\x06\x05\
    \x12\x03f\x11\x15\n\x0c\n\x05\x04\x01\x02\x06\x01\x12\x03f\x16\x1d\n\x0c\
    \n\x05\x04\x01\x02\x06\x03\x12\x03f\x20!\n\x0b\n\x04\x04\x01\x02\x07\x12\
    \x03g\x08A\n\x0c\n\x05\x04\x01\x02\x07\x04\x12\x03g\x08\x10\n\x0c\n\x05\
    \x04\x01\x02\x07\x06\x12\x03g\x116\n\x0c\n\x05\x04\x01\x02\x07\x01\x12\
    \x03g7<\n\x0c\n\x05\x04\x01\x02\x07\x03\x12\x03g?@\n\x0b\n\x04\x04\x01\
    \x02\x08\x12\x03h\x08&\n\x0c\n\x05\x04\x01\x02\x08\x04\x12\x03h\x08\x10\
    \n\x0c\n\x05\x04\x01\x02\x08\x05\x12\x03h\x11\x16\n\x0c\n\x05\x04\x01\
    \x02\x08\x01\x12\x03h\x17\x20\n\x0c\n\x05\x04\x01\x02\x08\x03\x12\x03h#%\
    \n\x0b\n\x04\x04\x01\x02\t\x12\x03i\x08'\n\x0c\n\x05\x04\x01\x02\t\x04\
    \x12\x03i\x08\x10\n\x0c\n\x05\x04\x01\x02\t\x05\x12\x03i\x11\x17\n\x0c\n\
    \x05\x04\x01\x02\t\x01\x12\x03i\x18!\n\x0c\n\x05\x04\x01\x02\t\x03\x12\
    \x03i$&\n\x0b\n\x04\x04\x01\x02\n\x12\x03j\x08)\n\x0c\n\x05\x04\x01\x02\
    \n\x04\x12\x03j\x08\x10\n\x0c\n\x05\x04\x01\x02\n\x05\x12\x03j\x11\x15\n\
    \x0c\n\x05\x04\x01\x02\n\x01\x12\x03j\x16#\n\x0c\n\x05\x04\x01\x02\n\x03\
    \x12\x03j&(\n\x0b\n\x04\x04\x01\x02\x0b\x12\x03k\x08)\n\x0c\n\x05\x04\
    \x01\x02\x0b\x04\x12\x03k\x08\x10\n\x0c\n\x05\x04\x01\x02\x0b\x05\x12\
    \x03k\x11\x15\n\x0c\n\x05\x04\x01\x02\x0b\x01\x12\x03k\x16#\n\x0c\n\x05\
    \x04\x01\x02\x0b\x03\x12\x03k&(\n\x0b\n\x04\x04\x01\x02\x0c\x12\x03l\x08\
    +\n\x0c\n\x05\x04\x01\x02\x0c\x04\x12\x03l\x08\x10\n\x0c\n\x05\x04\x01\
    \x02\x0c\x05\x12\x03l\x11\x17\n\x0c\n\x05\x04\x01\x02\x0c\x01\x12\x03l\
    \x18%\n\x0c\n\x05\x04\x01\x02\x0c\x03\x12\x03l(*\n\x0b\n\x04\x04\x01\x02\
    \r\x12\x03m\x085\n\x0c\n\x05\x04\x01\x02\r\x04\x12\x03m\x08\x10\n\x0c\n\
    \x05\x04\x01\x02\r\x05\x12\x03m\x11\x17\n\x0c\n\x05\x04\x01\x02\r\x01\
    \x12\x03m\x18/\n\x0c\n\x05\x04\x01\x02\r\x03\x12\x03m24\n\x0b\n\x04\x04\
    \x01\x02\x0e\x12\x03n\x08/\n\x0c\n\x05\x04\x01\x02\x0e\x04\x12\x03n\x08\
    \x10\n\x0c\n\x05\x04\x01\x02\x0e\x05\x12\x03n\x11\x15\n\x0c\n\x05\x04\
    \x01\x02\x0e\x01\x12\x03n\x16)\n\x0c\n\x05\x04\x01\x02\x0e\x03\x12\x03n,\
    .\n\x0b\n\x04\x04\x01\x02\x0f\x12\x03o\x08%\n\x0c\n\x05\x04\x01\x02\x0f\
    \x04\x12\x03o\x08\x10\n\x0c\n\x05\x04\x01\x02\x0f\x05\x12\x03o\x11\x15\n\
    \x0c\n\x05\x04\x01\x02\x0f\x01\x12\x03o\x16\x1f\n\x0c\n\x05\x04\x01\x02\
    \x0f\x03\x12\x03o\"$\n\x0b\n\x04\x04\x01\x02\x10\x12\x03p\x080\n\x0c\n\
    \x05\x04\x01\x02\x10\x04\x12\x03p\x08\x10\n\x0c\n\x05\x04\x01\x02\x10\
    \x05\x12\x03p\x11\x17\n\x0c\n\x05\x04\x01\x02\x10\x01\x12\x03p\x18*\n\
    \x0c\n\x05\x04\x01\x02\x10\x03\x12\x03p-/\n\x0b\n\x04\x04\x01\x02\x11\
    \x12\x03q\x08*\n\x0c\n\x05\x04\x01\x02\x11\x04\x12\x03q\x08\x10\n\x0c\n\
    \x05\x04\x01\x02\x11\x05\x12\x03q\x11\x17\n\x0c\n\x05\x04\x01\x02\x11\
    \x01\x12\x03q\x18$\n\x0c\n\x05\x04\x01\x02\x11\x03\x12\x03q')\n\x0b\n\
    \x04\x04\x01\x02\x12\x12\x03r\x08/\n\x0c\n\x05\x04\x01\x02\x12\x04\x12\
    \x03r\x08\x10\n\x0c\n\x05\x04\x01\x02\x12\x05\x12\x03r\x11\x17\n\x0c\n\
    \x05\x04\x01\x02\x12\x01\x12\x03r\x18)\n\x0c\n\x05\x04\x01\x02\x12\x03\
    \x12\x03r,.\n\x0b\n\x04\x04\x01\x02\x13\x12\x03s\x08-\n\x0c\n\x05\x04\
    \x01\x02\x13\x04\x12\x03s\x08\x10\n\x0c\n\x05\x04\x01\x02\x13\x05\x12\
    \x03s\x11\x15\n\x0c\n\x05\x04\x01\x02\x13\x01\x12\x03s\x16'\n\x0c\n\x05\
    \x04\x01\x02\x13\x03\x12\x03s*,\n\n\n\x02\x04\x02\x12\x04v\0y\x01\n\n\n\
    \x03\x04\x02\x01\x12\x03v\x08*\n\x0b\n\x04\x04\x02\x02\0\x12\x03w\x08$\n\
    \x0c\n\x05\x04\x02\x02\0\x04\x12\x03w\x08\x10\n\x0c\n\x05\x04\x02\x02\0\
    \x05\x12\x03w\x11\x17\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03w\x18\x1f\n\
    \x0c\n\x05\x04\x02\x02\0\x03\x12\x03w\"#\n\x0b\n\x04\x04\x02\x02\x01\x12\
    \x03x\x08'\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03x\x08\x10\n\x0c\n\x05\
    \x04\x02\x02\x01\x05\x12\x03x\x11\x17\n\x0c\n\x05\x04\x02\x02\x01\x01\
    \x12\x03x\x18\"\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03x%&\n\n\n\x02\x04\
    \x03\x12\x04{\0}\x01\n\n\n\x03\x04\x03\x01\x12\x03{\x083\n\x0b\n\x04\x04\
    \x03\x02\0\x12\x03|\x08'\n\x0c\n\x05\x04\x03\x02\0\x04\x12\x03|\x08\x10\
    \n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03|\x11\x17\n\x0c\n\x05\x04\x03\x02\
    \0\x01\x12\x03|\x18\"\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03|%&\n\x0b\n\
    \x02\x04\x04\x12\x05\x7f\0\x93\x01\x01\n\n\n\x03\x04\x04\x01\x12\x03\x7f\
    \x08,\n\x0e\n\x04\x04\x04\x03\0\x12\x06\x80\x01\x08\x8a\x01\t\n\r\n\x05\
    \x04\x04\x03\0\x01\x12\x04\x80\x01\x10!\n\x0e\n\x06\x04\x04\x03\0\x02\0\
    \x12\x04\x81\x01\x10,\n\x0f\n\x07\x04\x04\x03\0\x02\0\x04\x12\x04\x81\
    \x01\x10\x18\n\x0f\n\x07\x04\x04\x03\0\x02\0\x05\x12\x04\x81\x01\x19\x1e\
    \n\x0f\n\x07\x04\x04\x03\0\x02\0\x01\x12\x04\x81\x01\x1f'\n\x0f\n\x07\
    \x04\x04\x03\0\x02\0\x03\x12\x04\x81\x01*+\n\x0e\n\x06\x04\x04\x03\0\x02\
    \x01\x12\x04\x82\x01\x10/\n\x0f\n\x07\x04\x04\x03\0\x02\x01\x04\x12\x04\
    \x82\x01\x10\x18\n\x0f\n\x07\x04\x04\x03\0\x02\x01\x05\x12\x04\x82\x01\
    \x19\x1f\n\x0f\n\x07\x04\x04\x03\0\x02\x01\x01\x12\x04\x82\x01\x20*\n\
    \x0f\n\x07\x04\x04\x03\0\x02\x01\x03\x12\x04\x82\x01-.\n\x0e\n\x06\x04\
    \x04\x03\0\x02\x02\x12\x04\x83\x01\x10+\n\x0f\n\x07\x04\x04\x03\0\x02\
    \x02\x04\x12\x04\x83\x01\x10\x18\n\x0f\n\x07\x04\x04\x03\0\x02\x02\x05\
    \x12\x04\x83\x01\x19\x1e\n\x0f\n\x07\x04\x04\x03\0\x02\x02\x01\x12\x04\
    \x83\x01\x1f&\n\x0f\n\x07\x04\x04\x03\0\x02\x02\x03\x12\x04\x83\x01)*\n\
    \x0e\n\x06\x04\x04\x03\0\x02\x03\x12\x04\x84\x01\x10.\n\x0f\n\x07\x04\
    \x04\x03\0\x02\x03\x04\x12\x04\x84\x01\x10\x18\n\x0f\n\x07\x04\x04\x03\0\
    \x02\x03\x05\x12\x04\x84\x01\x19\x1f\n\x0f\n\x07\x04\x04\x03\0\x02\x03\
    \x01\x12\x04\x84\x01\x20)\n\x0f\n\x07\x04\x04\x03\0\x02\x03\x03\x12\x04\
    \x84\x01,-\n\x0f\n\x06\x04\x04\x03\0\x02\x04\x12\x05\x85\x01\x10\x86\x01\
    \n\x0f\n\x07\x04\x04\x03\0\x02\x04\x04\x12\x04\x85\x01\x10\x18\n\x0f\n\
    \x07\x04\x04\x03\0\x02\x04\x06\x12\x04\x85\x01\x19N\n\x0f\n\x07\x04\x04\
    \x03\0\x02\x04\x01\x12\x04\x85\x01OT\n\x0f\n\x07\x04\x04\x03\0\x02\x04\
    \x03\x12\x04\x85\x01WX\n\x10\n\x07\x04\x04\x03\0\x02\x04\x08\x12\x05\x85\
    \x01Y\x85\x01\n\x10\n\x07\x04\x04\x03\0\x02\x04\x07\x12\x05\x85\x01d\x84\
    \x01\n\x0e\n\x06\x04\x04\x03\0\x02\x05\x12\x04\x86\x01\x100\n\x0f\n\x07\
    \x04\x04\x03\0\x02\x05\x04\x12\x04\x86\x01\x10\x18\n\x0f\n\x07\x04\x04\
    \x03\0\x02\x05\x05\x12\x04\x86\x01\x19\x1f\n\x0f\n\x07\x04\x04\x03\0\x02\
    \x05\x01\x12\x04\x86\x01\x20+\n\x0f\n\x07\x04\x04\x03\0\x02\x05\x03\x12\
    \x04\x86\x01./\n\x0e\n\x06\x04\x04\x03\0\x02\x06\x12\x04\x87\x01\x101\n\
    \x0f\n\x07\x04\x04\x03\0\x02\x06\x04\x12\x04\x87\x01\x10\x18\n\x0f\n\x07\
    \x04\x04\x03\0\x02\x06\x05\x12\x04\x87\x01\x19\x1f\n\x0f\n\x07\x04\x04\
    \x03\0\x02\x06\x01\x12\x04\x87\x01\x20,\n\x0f\n\x07\x04\x04\x03\0\x02\
    \x06\x03\x12\x04\x87\x01/0\n\x0e\n\x06\x04\x04\x03\0\x02\x07\x12\x04\x88\
    \x01\x102\n\x0f\n\x07\x04\x04\x03\0\x02\x07\x04\x12\x04\x88\x01\x10\x18\
    \n\x0f\n\x07\x04\x04\x03\0\x02\x07\x05\x12\x04\x88\x01\x19\x1f\n\x0f\n\
    \x07\x04\x04\x03\0\x02\x07\x01\x12\x04\x88\x01\x20-\n\x0f\n\x07\x04\x04\
    \x03\0\x02\x07\x03\x12\x04\x88\x0101\n\x0e\n\x06\x04\x04\x03\0\x02\x08\
    \x12\x04\x89\x01\x10;\n\x0f\n\x07\x04\x04\x03\0\x02\x08\x04\x12\x04\x89\
    \x01\x10\x18\n\x0f\n\x07\x04\x04\x03\0\x02\x08\x05\x12\x04\x89\x01\x19\
    \x1f\n\x0f\n\x07\x04\x04\x03\0\x02\x08\x01\x12\x04\x89\x01\x206\n\x0f\n\
    \x07\x04\x04\x03\0\x02\x08\x03\x12\x04\x89\x019:\n\x0e\n\x04\x04\x04\x04\
    \0\x12\x06\x8c\x01\x08\x8e\x01\t\n\r\n\x05\x04\x04\x04\0\x01\x12\x04\x8c\
    \x01\r\x1c\n\x0e\n\x06\x04\x04\x04\0\x02\0\x12\x04\x8d\x01\x105\n\x0f\n\
    \x07\x04\x04\x04\0\x02\0\x01\x12\x04\x8d\x01\x100\n\x0f\n\x07\x04\x04\
    \x04\0\x02\0\x02\x12\x04\x8d\x0134\n\x0c\n\x04\x04\x04\x02\0\x12\x04\x90\
    \x01\x08(\n\r\n\x05\x04\x04\x02\0\x04\x12\x04\x90\x01\x08\x10\n\r\n\x05\
    \x04\x04\x02\0\x05\x12\x04\x90\x01\x11\x16\n\r\n\x05\x04\x04\x02\0\x01\
    \x12\x04\x90\x01\x17#\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\x90\x01&'\n\
    \x0c\n\x04\x04\x04\x02\x01\x12\x04\x91\x01\x08(\n\r\n\x05\x04\x04\x02\
    \x01\x04\x12\x04\x91\x01\x08\x10\n\r\n\x05\x04\x04\x02\x01\x05\x12\x04\
    \x91\x01\x11\x17\n\r\n\x05\x04\x04\x02\x01\x01\x12\x04\x91\x01\x18#\n\r\
    \n\x05\x04\x04\x02\x01\x03\x12\x04\x91\x01&'\n\x0c\n\x04\x04\x04\x02\x02\
    \x12\x04\x92\x01\x08-\n\r\n\x05\x04\x04\x02\x02\x04\x12\x04\x92\x01\x08\
    \x10\n\r\n\x05\x04\x04\x02\x02\x05\x12\x04\x92\x01\x11\x16\n\r\n\x05\x04\
    \x04\x02\x02\x01\x12\x04\x92\x01\x17(\n\r\n\x05\x04\x04\x02\x02\x03\x12\
    \x04\x92\x01+,\n\x0c\n\x02\x04\x05\x12\x06\x95\x01\0\x96\x01\x01\n\x0b\n\
    \x03\x04\x05\x01\x12\x04\x95\x01\x082\n\x0c\n\x02\x04\x06\x12\x06\x98\
    \x01\0\x9b\x01\x01\n\x0b\n\x03\x04\x06\x01\x12\x04\x98\x01\x08-\n\x0c\n\
    \x04\x04\x06\x02\0\x12\x04\x99\x01\x08n\n\r\n\x05\x04\x06\x02\0\x04\x12\
    \x04\x99\x01\x08\x10\n\r\n\x05\x04\x06\x02\0\x06\x12\x04\x99\x01\x112\n\
    \r\n\x05\x04\x06\x02\0\x01\x12\x04\x99\x0139\n\r\n\x05\x04\x06\x02\0\x03\
    \x12\x04\x99\x01<=\n\r\n\x05\x04\x06\x02\0\x08\x12\x04\x99\x01>m\n\r\n\
    \x05\x04\x06\x02\0\x07\x12\x04\x99\x01Il\n\x0c\n\x04\x04\x06\x02\x01\x12\
    \x04\x9a\x01\x08%\n\r\n\x05\x04\x06\x02\x01\x04\x12\x04\x9a\x01\x08\x10\
    \n\r\n\x05\x04\x06\x02\x01\x05\x12\x04\x9a\x01\x11\x18\n\r\n\x05\x04\x06\
    \x02\x01\x01\x12\x04\x9a\x01\x19\x20\n\r\n\x05\x04\x06\x02\x01\x03\x12\
    \x04\x9a\x01#$\n\x0c\n\x02\x04\x07\x12\x06\x9d\x01\0\xb7\x01\x01\n\x0b\n\
    \x03\x04\x07\x01\x12\x04\x9d\x01\x08(\n\x0e\n\x04\x04\x07\x03\0\x12\x06\
    \x9e\x01\x08\xa1\x01\t\n\r\n\x05\x04\x07\x03\0\x01\x12\x04\x9e\x01\x10\
    \x1f\n\x0e\n\x06\x04\x07\x03\0\x02\0\x12\x04\x9f\x01\x104\n\x0f\n\x07\
    \x04\x07\x03\0\x02\0\x04\x12\x04\x9f\x01\x10\x18\n\x0f\n\x07\x04\x07\x03\
    \0\x02\0\x05\x12\x04\x9f\x01\x19\x1f\n\x0f\n\x07\x04\x07\x03\0\x02\0\x01\
    \x12\x04\x9f\x01\x20/\n\x0f\n\x07\x04\x07\x03\0\x02\0\x03\x12\x04\x9f\
    \x0123\n\x0e\n\x06\x04\x07\x03\0\x02\x01\x12\x04\xa0\x01\x107\n\x0f\n\
    \x07\x04\x07\x03\0\x02\x01\x04\x12\x04\xa0\x01\x10\x18\n\x0f\n\x07\x04\
    \x07\x03\0\x02\x01\x05\x12\x04\xa0\x01\x19\x1f\n\x0f\n\x07\x04\x07\x03\0\
    \x02\x01\x01\x12\x04\xa0\x01\x202\n\x0f\n\x07\x04\x07\x03\0\x02\x01\x03\
    \x12\x04\xa0\x0156\n\x0c\n\x04\x04\x07\x02\0\x12\x04\xa3\x01\x08'\n\r\n\
    \x05\x04\x07\x02\0\x04\x12\x04\xa3\x01\x08\x10\n\r\n\x05\x04\x07\x02\0\
    \x05\x12\x04\xa3\x01\x11\x17\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\xa3\x01\
    \x18\"\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\xa3\x01%&\n\x0c\n\x04\x04\x07\
    \x02\x01\x12\x04\xa4\x01\x080\n\r\n\x05\x04\x07\x02\x01\x04\x12\x04\xa4\
    \x01\x08\x10\n\r\n\x05\x04\x07\x02\x01\x05\x12\x04\xa4\x01\x11\x16\n\r\n\
    \x05\x04\x07\x02\x01\x01\x12\x04\xa4\x01\x17+\n\r\n\x05\x04\x07\x02\x01\
    \x03\x12\x04\xa4\x01./\n\x0c\n\x04\x04\x07\x02\x02\x12\x04\xa5\x01\x080\
    \n\r\n\x05\x04\x07\x02\x02\x04\x12\x04\xa5\x01\x08\x10\n\r\n\x05\x04\x07\
    \x02\x02\x05\x12\x04\xa5\x01\x11\x16\n\r\n\x05\x04\x07\x02\x02\x01\x12\
    \x04\xa5\x01\x17+\n\r\n\x05\x04\x07\x02\x02\x03\x12\x04\xa5\x01./\n\x0c\
    \n\x04\x04\x07\x02\x03\x12\x04\xa6\x01\x08=\n\r\n\x05\x04\x07\x02\x03\
    \x04\x12\x04\xa6\x01\x08\x10\n\r\n\x05\x04\x07\x02\x03\x05\x12\x04\xa6\
    \x01\x11\x16\n\r\n\x05\x04\x07\x02\x03\x01\x12\x04\xa6\x01\x17*\n\r\n\
    \x05\x04\x07\x02\x03\x03\x12\x04\xa6\x01-.\n\r\n\x05\x04\x07\x02\x03\x08\
    \x12\x04\xa6\x01/<\n\r\n\x05\x04\x07\x02\x03\x07\x12\x04\xa6\x01:;\n\x0c\
    \n\x04\x04\x07\x02\x04\x12\x04\xa7\x01\x08+\n\r\n\x05\x04\x07\x02\x04\
    \x04\x12\x04\xa7\x01\x08\x10\n\r\n\x05\x04\x07\x02\x04\x05\x12\x04\xa7\
    \x01\x11\x17\n\r\n\x05\x04\x07\x02\x04\x01\x12\x04\xa7\x01\x18&\n\r\n\
    \x05\x04\x07\x02\x04\x03\x12\x04\xa7\x01)*\n\x0c\n\x04\x04\x07\x02\x05\
    \x12\x04\xa8\x01\x08)\n\r\n\x05\x04\x07\x02\x05\x04\x12\x04\xa8\x01\x08\
    \x10\n\r\n\x05\x04\x07\x02\x05\x05\x12\x04\xa8\x01\x11\x15\n\r\n\x05\x04\
    \x07\x02\x05\x01\x12\x04\xa8\x01\x16$\n\r\n\x05\x04\x07\x02\x05\x03\x12\
    \x04\xa8\x01'(\n\x0c\n\x04\x04\x07\x02\x06\x12\x04\xa9\x01\x08(\n\r\n\
    \x05\x04\x07\x02\x06\x04\x12\x04\xa9\x01\x08\x10\n\r\n\x05\x04\x07\x02\
    \x06\x05\x12\x04\xa9\x01\x11\x16\n\r\n\x05\x04\x07\x02\x06\x01\x12\x04\
    \xa9\x01\x17#\n\r\n\x05\x04\x07\x02\x06\x03\x12\x04\xa9\x01&'\n\x0c\n\
    \x04\x04\x07\x02\x07\x12\x04\xaa\x01\x08\x1f\n\r\n\x05\x04\x07\x02\x07\
    \x04\x12\x04\xaa\x01\x08\x10\n\r\n\x05\x04\x07\x02\x07\x05\x12\x04\xaa\
    \x01\x11\x16\n\r\n\x05\x04\x07\x02\x07\x01\x12\x04\xaa\x01\x17\x1a\n\r\n\
    \x05\x04\x07\x02\x07\x03\x12\x04\xaa\x01\x1d\x1e\n\x0c\n\x04\x04\x07\x02\
    \x08\x12\x04\xab\x01\x08B\n\r\n\x05\x04\x07\x02\x08\x04\x12\x04\xab\x01\
    \x08\x10\n\r\n\x05\x04\x07\x02\x08\x05\x12\x04\xab\x01\x11\x15\n\r\n\x05\
    \x04\x07\x02\x08\x01\x12\x04\xab\x01\x16,\n\r\n\x05\x04\x07\x02\x08\x03\
    \x12\x04\xab\x01/0\n\r\n\x05\x04\x07\x02\x08\x08\x12\x04\xab\x011A\n\r\n\
    \x05\x04\x07\x02\x08\x07\x12\x04\xab\x01<@\n\x0c\n\x04\x04\x07\x02\t\x12\
    \x04\xac\x01\x08C\n\r\n\x05\x04\x07\x02\t\x04\x12\x04\xac\x01\x08\x10\n\
    \r\n\x05\x04\x07\x02\t\x05\x12\x04\xac\x01\x11\x15\n\r\n\x05\x04\x07\x02\
    \t\x01\x12\x04\xac\x01\x16,\n\r\n\x05\x04\x07\x02\t\x03\x12\x04\xac\x01/\
    1\n\r\n\x05\x04\x07\x02\t\x08\x12\x04\xac\x012B\n\r\n\x05\x04\x07\x02\t\
    \x07\x12\x04\xac\x01=A\n\x0c\n\x04\x04\x07\x02\n\x12\x04\xad\x01\x08C\n\
    \r\n\x05\x04\x07\x02\n\x04\x12\x04\xad\x01\x08\x10\n\r\n\x05\x04\x07\x02\
    \n\x05\x12\x04\xad\x01\x11\x15\n\r\n\x05\x04\x07\x02\n\x01\x12\x04\xad\
    \x01\x16,\n\r\n\x05\x04\x07\x02\n\x03\x12\x04\xad\x01/1\n\r\n\x05\x04\
    \x07\x02\n\x08\x12\x04\xad\x012B\n\r\n\x05\x04\x07\x02\n\x07\x12\x04\xad\
    \x01=A\n\x0c\n\x04\x04\x07\x02\x0b\x12\x04\xae\x01\x08(\n\r\n\x05\x04\
    \x07\x02\x0b\x04\x12\x04\xae\x01\x08\x10\n\r\n\x05\x04\x07\x02\x0b\x05\
    \x12\x04\xae\x01\x11\x15\n\r\n\x05\x04\x07\x02\x0b\x01\x12\x04\xae\x01\
    \x16\"\n\r\n\x05\x04\x07\x02\x0b\x03\x12\x04\xae\x01%'\n\x0c\n\x04\x04\
    \x07\x02\x0c\x12\x04\xaf\x01\x08'\n\r\n\x05\x04\x07\x02\x0c\x04\x12\x04\
    \xaf\x01\x08\x10\n\r\n\x05\x04\x07\x02\x0c\x05\x12\x04\xaf\x01\x11\x17\n\
    \r\n\x05\x04\x07\x02\x0c\x01\x12\x04\xaf\x01\x18!\n\r\n\x05\x04\x07\x02\
    \x0c\x03\x12\x04\xaf\x01$&\n\x0c\n\x04\x04\x07\x02\r\x12\x04\xb0\x01\x08\
    <\n\r\n\x05\x04\x07\x02\r\x04\x12\x04\xb0\x01\x08\x10\n\r\n\x05\x04\x07\
    \x02\r\x06\x12\x04\xb0\x01\x11\"\n\r\n\x05\x04\x07\x02\r\x01\x12\x04\xb0\
    \x01#6\n\r\n\x05\x04\x07\x02\r\x03\x12\x04\xb0\x019;\n\x0c\n\x04\x04\x07\
    \x02\x0e\x12\x04\xb1\x01\x08&\n\r\n\x05\x04\x07\x02\x0e\x04\x12\x04\xb1\
    \x01\x08\x10\n\r\n\x05\x04\x07\x02\x0e\x05\x12\x04\xb1\x01\x11\x15\n\r\n\
    \x05\x04\x07\x02\x0e\x01\x12\x04\xb1\x01\x16\x20\n\r\n\x05\x04\x07\x02\
    \x0e\x03\x12\x04\xb1\x01#%\n\x0c\n\x04\x04\x07\x02\x0f\x12\x04\xb2\x01\
    \x08h\n\r\n\x05\x04\x07\x02\x0f\x04\x12\x04\xb2\x01\x08\x10\n\r\n\x05\
    \x04\x07\x02\x0f\x06\x12\x04\xb2\x01\x11)\n\r\n\x05\x04\x07\x02\x0f\x01\
    \x12\x04\xb2\x01*5\n\r\n\x05\x04\x07\x02\x0f\x03\x12\x04\xb2\x018:\n\r\n\
    \x05\x04\x07\x02\x0f\x08\x12\x04\xb2\x01;g\n\r\n\x05\x04\x07\x02\x0f\x07\
    \x12\x04\xb2\x01Ff\n\x0c\n\x04\x04\x07\x02\x10\x12\x04\xb3\x01\x08*\n\r\
    \n\x05\x04\x07\x02\x10\x04\x12\x04\xb3\x01\x08\x10\n\r\n\x05\x04\x07\x02\
    \x10\x05\x12\x04\xb3\x01\x11\x16\n\r\n\x05\x04\x07\x02\x10\x01\x12\x04\
    \xb3\x01\x17$\n\r\n\x05\x04\x07\x02\x10\x03\x12\x04\xb3\x01')\n\x0c\n\
    \x04\x04\x07\x02\x11\x12\x04\xb4\x01\x08Q\n\r\n\x05\x04\x07\x02\x11\x04\
    \x12\x04\xb4\x01\x08\x10\n\r\n\x05\x04\x07\x02\x11\x06\x12\x04\xb4\x01\
    \x11B\n\r\n\x05\x04\x07\x02\x11\x01\x12\x04\xb4\x01CK\n\r\n\x05\x04\x07\
    \x02\x11\x03\x12\x04\xb4\x01NP\n\x0c\n\x04\x04\x07\x02\x12\x12\x04\xb5\
    \x01\x08$\n\r\n\x05\x04\x07\x02\x12\x04\x12\x04\xb5\x01\x08\x10\n\r\n\
    \x05\x04\x07\x02\x12\x05\x12\x04\xb5\x01\x11\x17\n\r\n\x05\x04\x07\x02\
    \x12\x01\x12\x04\xb5\x01\x18\x1e\n\r\n\x05\x04\x07\x02\x12\x03\x12\x04\
    \xb5\x01!#\n\x0c\n\x04\x04\x07\x02\x13\x12\x04\xb6\x01\x08_\n\r\n\x05\
    \x04\x07\x02\x13\x04\x12\x04\xb6\x01\x08\x10\n\r\n\x05\x04\x07\x02\x13\
    \x06\x12\x04\xb6\x01\x11\"\n\r\n\x05\x04\x07\x02\x13\x01\x12\x04\xb6\x01\
    #3\n\r\n\x05\x04\x07\x02\x13\x03\x12\x04\xb6\x0168\n\r\n\x05\x04\x07\x02\
    \x13\x08\x12\x04\xb6\x019^\n\r\n\x05\x04\x07\x02\x13\x07\x12\x04\xb6\x01\
    D]\n\x0c\n\x02\x04\x08\x12\x06\xb9\x01\0\xbb\x01\x01\n\x0b\n\x03\x04\x08\
    \x01\x12\x04\xb9\x01\x08.\n\x0c\n\x04\x04\x08\x02\0\x12\x04\xba\x01\x08'\
    \n\r\n\x05\x04\x08\x02\0\x04\x12\x04\xba\x01\x08\x10\n\r\n\x05\x04\x08\
    \x02\0\x05\x12\x04\xba\x01\x11\x17\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\
    \xba\x01\x18\"\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\xba\x01%&\n\x0c\n\x02\
    \x04\t\x12\x06\xbd\x01\0\xc0\x01\x01\n\x0b\n\x03\x04\t\x01\x12\x04\xbd\
    \x01\x08)\n\x0c\n\x04\x04\t\x02\0\x12\x04\xbe\x01\x08'\n\r\n\x05\x04\t\
    \x02\0\x04\x12\x04\xbe\x01\x08\x10\n\r\n\x05\x04\t\x02\0\x05\x12\x04\xbe\
    \x01\x11\x17\n\r\n\x05\x04\t\x02\0\x01\x12\x04\xbe\x01\x18\"\n\r\n\x05\
    \x04\t\x02\0\x03\x12\x04\xbe\x01%&\n\x0c\n\x04\x04\t\x02\x01\x12\x04\xbf\
    \x01\x08$\n\r\n\x05\x04\t\x02\x01\x04\x12\x04\xbf\x01\x08\x10\n\r\n\x05\
    \x04\t\x02\x01\x05\x12\x04\xbf\x01\x11\x16\n\r\n\x05\x04\t\x02\x01\x01\
    \x12\x04\xbf\x01\x17\x1f\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\xbf\x01\"#\
    \n\x0c\n\x02\x04\n\x12\x06\xc2\x01\0\xca\x01\x01\n\x0b\n\x03\x04\n\x01\
    \x12\x04\xc2\x01\x08)\n\x0c\n\x04\x04\n\x02\0\x12\x04\xc3\x01\x08'\n\r\n\
    \x05\x04\n\x02\0\x04\x12\x04\xc3\x01\x08\x10\n\r\n\x05\x04\n\x02\0\x05\
    \x12\x04\xc3\x01\x11\x17\n\r\n\x05\x04\n\x02\0\x01\x12\x04\xc3\x01\x18\"\
    \n\r\n\x05\x04\n\x02\0\x03\x12\x04\xc3\x01%&\n\x0c\n\x04\x04\n\x02\x01\
    \x12\x04\xc4\x01\x08f\n\r\n\x05\x04\n\x02\x01\x04\x12\x04\xc4\x01\x08\
    \x10\n\r\n\x05\x04\n\x02\x01\x06\x12\x04\xc4\x01\x11.\n\r\n\x05\x04\n\
    \x02\x01\x01\x12\x04\xc4\x01/5\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\xc4\
    \x0189\n\r\n\x05\x04\n\x02\x01\x08\x12\x04\xc4\x01:e\n\r\n\x05\x04\n\x02\
    \x01\x07\x12\x04\xc4\x01Ed\n\x0c\n\x04\x04\n\x02\x02\x12\x04\xc5\x01\x08\
    !\n\r\n\x05\x04\n\x02\x02\x04\x12\x04\xc5\x01\x08\x10\n\r\n\x05\x04\n\
    \x02\x02\x05\x12\x04\xc5\x01\x11\x17\n\r\n\x05\x04\n\x02\x02\x01\x12\x04\
    \xc5\x01\x18\x1c\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\xc5\x01\x1f\x20\n\
    \x0c\n\x04\x04\n\x02\x03\x12\x04\xc6\x01\x081\n\r\n\x05\x04\n\x02\x03\
    \x04\x12\x04\xc6\x01\x08\x10\n\r\n\x05\x04\n\x02\x03\x05\x12\x04\xc6\x01\
    \x11\x16\n\r\n\x05\x04\n\x02\x03\x01\x12\x04\xc6\x01\x17,\n\r\n\x05\x04\
    \n\x02\x03\x03\x12\x04\xc6\x01/0\n\x0c\n\x04\x04\n\x02\x04\x12\x04\xc7\
    \x01\x08S\n\r\n\x05\x04\n\x02\x04\x04\x12\x04\xc7\x01\x08\x10\n\r\n\x05\
    \x04\n\x02\x04\x06\x12\x04\xc7\x01\x11\"\n\r\n\x05\x04\n\x02\x04\x01\x12\
    \x04\xc7\x01#,\n\r\n\x05\x04\n\x02\x04\x03\x12\x04\xc7\x01/0\n\r\n\x05\
    \x04\n\x02\x04\x08\x12\x04\xc7\x011R\n\r\n\x05\x04\n\x02\x04\x07\x12\x04\
    \xc7\x01<Q\n\x0c\n\x04\x04\n\x02\x05\x12\x04\xc8\x01\x08)\n\r\n\x05\x04\
    \n\x02\x05\x04\x12\x04\xc8\x01\x08\x10\n\r\n\x05\x04\n\x02\x05\x05\x12\
    \x04\xc8\x01\x11\x17\n\r\n\x05\x04\n\x02\x05\x01\x12\x04\xc8\x01\x18$\n\
    \r\n\x05\x04\n\x02\x05\x03\x12\x04\xc8\x01'(\n\x0c\n\x04\x04\n\x02\x06\
    \x12\x04\xc9\x01\x08!\n\r\n\x05\x04\n\x02\x06\x04\x12\x04\xc9\x01\x08\
    \x10\n\r\n\x05\x04\n\x02\x06\x05\x12\x04\xc9\x01\x11\x17\n\r\n\x05\x04\n\
    \x02\x06\x01\x12\x04\xc9\x01\x18\x1c\n\r\n\x05\x04\n\x02\x06\x03\x12\x04\
    \xc9\x01\x1f\x20\n\x0c\n\x02\x04\x0b\x12\x06\xcc\x01\0\xcf\x01\x01\n\x0b\
    \n\x03\x04\x0b\x01\x12\x04\xcc\x01\x08$\n\x0c\n\x04\x04\x0b\x02\0\x12\
    \x04\xcd\x01\x08%\n\r\n\x05\x04\x0b\x02\0\x04\x12\x04\xcd\x01\x08\x10\n\
    \r\n\x05\x04\x0b\x02\0\x05\x12\x04\xcd\x01\x11\x16\n\r\n\x05\x04\x0b\x02\
    \0\x01\x12\x04\xcd\x01\x17\x20\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\xcd\
    \x01#$\n\x0c\n\x04\x04\x0b\x02\x01\x12\x04\xce\x01\x08'\n\r\n\x05\x04\
    \x0b\x02\x01\x04\x12\x04\xce\x01\x08\x10\n\r\n\x05\x04\x0b\x02\x01\x05\
    \x12\x04\xce\x01\x11\x17\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\xce\x01\
    \x18\"\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\xce\x01%&\n\x0c\n\x02\x04\
    \x0c\x12\x06\xd1\x01\0\xd4\x01\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\xd1\
    \x01\x08%\n\x0c\n\x04\x04\x0c\x02\0\x12\x04\xd2\x01\x08$\n\r\n\x05\x04\
    \x0c\x02\0\x04\x12\x04\xd2\x01\x08\x10\n\r\n\x05\x04\x0c\x02\0\x05\x12\
    \x04\xd2\x01\x11\x16\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xd2\x01\x17\x1f\
    \n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xd2\x01\"#\n\x0c\n\x04\x04\x0c\x02\
    \x01\x12\x04\xd3\x01\x08'\n\r\n\x05\x04\x0c\x02\x01\x04\x12\x04\xd3\x01\
    \x08\x10\n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\xd3\x01\x11\x17\n\r\n\x05\
    \x04\x0c\x02\x01\x01\x12\x04\xd3\x01\x18\"\n\r\n\x05\x04\x0c\x02\x01\x03\
    \x12\x04\xd3\x01%&\n\x0c\n\x02\x04\r\x12\x06\xd6\x01\0\xd9\x01\x01\n\x0b\
    \n\x03\x04\r\x01\x12\x04\xd6\x01\x08-\n\x0c\n\x04\x04\r\x02\0\x12\x04\
    \xd7\x01\x08!\n\r\n\x05\x04\r\x02\0\x04\x12\x04\xd7\x01\x08\x10\n\r\n\
    \x05\x04\r\x02\0\x05\x12\x04\xd7\x01\x11\x16\n\r\n\x05\x04\r\x02\0\x01\
    \x12\x04\xd7\x01\x17\x1c\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xd7\x01\x1f\
    \x20\n\x0c\n\x04\x04\r\x02\x01\x12\x04\xd8\x01\x08#\n\r\n\x05\x04\r\x02\
    \x01\x04\x12\x04\xd8\x01\x08\x10\n\r\n\x05\x04\r\x02\x01\x05\x12\x04\xd8\
    \x01\x11\x16\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\xd8\x01\x17\x1e\n\r\n\
    \x05\x04\r\x02\x01\x03\x12\x04\xd8\x01!\"\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(17);
            messages.push(CMsgRemoteClientBroadcastHeader::generated_message_descriptor_data());
            messages.push(CMsgRemoteClientBroadcastStatus::generated_message_descriptor_data());
            messages.push(CMsgRemoteClientBroadcastDiscovery::generated_message_descriptor_data());
            messages.push(CMsgRemoteClientBroadcastClientIDDeconflict::generated_message_descriptor_data());
            messages.push(CMsgRemoteDeviceAuthorizationRequest::generated_message_descriptor_data());
            messages.push(CMsgRemoteDeviceAuthorizationCancelRequest::generated_message_descriptor_data());
            messages.push(CMsgRemoteDeviceAuthorizationResponse::generated_message_descriptor_data());
            messages.push(CMsgRemoteDeviceStreamingRequest::generated_message_descriptor_data());
            messages.push(CMsgRemoteDeviceStreamingCancelRequest::generated_message_descriptor_data());
            messages.push(CMsgRemoteDeviceStreamingProgress::generated_message_descriptor_data());
            messages.push(CMsgRemoteDeviceStreamingResponse::generated_message_descriptor_data());
            messages.push(CMsgRemoteDeviceProofRequest::generated_message_descriptor_data());
            messages.push(CMsgRemoteDeviceProofResponse::generated_message_descriptor_data());
            messages.push(CMsgRemoteDeviceStreamTransportSignal::generated_message_descriptor_data());
            messages.push(cmsg_remote_client_broadcast_status::User::generated_message_descriptor_data());
            messages.push(cmsg_remote_device_authorization_request::CKeyEscrow_Ticket::generated_message_descriptor_data());
            messages.push(cmsg_remote_device_streaming_request::ReservedGamepad::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(8);
            enums.push(ERemoteClientBroadcastMsg::generated_enum_descriptor_data());
            enums.push(ERemoteClientService::generated_enum_descriptor_data());
            enums.push(ERemoteDeviceAuthorizationResult::generated_enum_descriptor_data());
            enums.push(EStreamDeviceFormFactor::generated_enum_descriptor_data());
            enums.push(EStreamTransport::generated_enum_descriptor_data());
            enums.push(EStreamInterface::generated_enum_descriptor_data());
            enums.push(ERemoteDeviceStreamingResult::generated_enum_descriptor_data());
            enums.push(cmsg_remote_device_authorization_request::EKeyEscrowUsage::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
