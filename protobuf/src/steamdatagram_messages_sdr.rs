// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steamdatagram_messages_sdr.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:CMsgSteamDatagramRouterPingReply)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramRouterPingReply {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.client_timestamp)
    pub client_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.latency_datacenter_ids)
    pub latency_datacenter_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.latency_ping_ms)
    pub latency_ping_ms: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.your_public_ip)
    pub your_public_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.your_public_port)
    pub your_public_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.server_time)
    pub server_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.challenge)
    pub challenge: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.seconds_until_shutdown)
    pub seconds_until_shutdown: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.client_cookie)
    pub client_cookie: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.scoring_penalty_relay_cluster)
    pub scoring_penalty_relay_cluster: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.route_exceptions)
    pub route_exceptions: ::std::vec::Vec<cmsg_steam_datagram_router_ping_reply::RouteException>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.alt_addresses)
    pub alt_addresses: ::std::vec::Vec<cmsg_steam_datagram_router_ping_reply::AltAddress>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramRouterPingReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramRouterPingReply {
    fn default() -> &'a CMsgSteamDatagramRouterPingReply {
        <CMsgSteamDatagramRouterPingReply as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramRouterPingReply {
    pub fn new() -> CMsgSteamDatagramRouterPingReply {
        ::std::default::Default::default()
    }

    // optional fixed32 client_timestamp = 1;

    pub fn client_timestamp(&self) -> u32 {
        self.client_timestamp.unwrap_or(0)
    }

    pub fn clear_client_timestamp(&mut self) {
        self.client_timestamp = ::std::option::Option::None;
    }

    pub fn has_client_timestamp(&self) -> bool {
        self.client_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_timestamp(&mut self, v: u32) {
        self.client_timestamp = ::std::option::Option::Some(v);
    }

    // optional fixed32 your_public_ip = 4;

    pub fn your_public_ip(&self) -> u32 {
        self.your_public_ip.unwrap_or(0)
    }

    pub fn clear_your_public_ip(&mut self) {
        self.your_public_ip = ::std::option::Option::None;
    }

    pub fn has_your_public_ip(&self) -> bool {
        self.your_public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_your_public_ip(&mut self, v: u32) {
        self.your_public_ip = ::std::option::Option::Some(v);
    }

    // optional fixed32 your_public_port = 11;

    pub fn your_public_port(&self) -> u32 {
        self.your_public_port.unwrap_or(0)
    }

    pub fn clear_your_public_port(&mut self) {
        self.your_public_port = ::std::option::Option::None;
    }

    pub fn has_your_public_port(&self) -> bool {
        self.your_public_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_your_public_port(&mut self, v: u32) {
        self.your_public_port = ::std::option::Option::Some(v);
    }

    // optional fixed32 server_time = 5;

    pub fn server_time(&self) -> u32 {
        self.server_time.unwrap_or(0)
    }

    pub fn clear_server_time(&mut self) {
        self.server_time = ::std::option::Option::None;
    }

    pub fn has_server_time(&self) -> bool {
        self.server_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_time(&mut self, v: u32) {
        self.server_time = ::std::option::Option::Some(v);
    }

    // optional fixed64 challenge = 6;

    pub fn challenge(&self) -> u64 {
        self.challenge.unwrap_or(0)
    }

    pub fn clear_challenge(&mut self) {
        self.challenge = ::std::option::Option::None;
    }

    pub fn has_challenge(&self) -> bool {
        self.challenge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge(&mut self, v: u64) {
        self.challenge = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_until_shutdown = 7;

    pub fn seconds_until_shutdown(&self) -> u32 {
        self.seconds_until_shutdown.unwrap_or(0)
    }

    pub fn clear_seconds_until_shutdown(&mut self) {
        self.seconds_until_shutdown = ::std::option::Option::None;
    }

    pub fn has_seconds_until_shutdown(&self) -> bool {
        self.seconds_until_shutdown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_until_shutdown(&mut self, v: u32) {
        self.seconds_until_shutdown = ::std::option::Option::Some(v);
    }

    // optional fixed32 client_cookie = 8;

    pub fn client_cookie(&self) -> u32 {
        self.client_cookie.unwrap_or(0)
    }

    pub fn clear_client_cookie(&mut self) {
        self.client_cookie = ::std::option::Option::None;
    }

    pub fn has_client_cookie(&self) -> bool {
        self.client_cookie.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_cookie(&mut self, v: u32) {
        self.client_cookie = ::std::option::Option::Some(v);
    }

    // optional uint32 scoring_penalty_relay_cluster = 9;

    pub fn scoring_penalty_relay_cluster(&self) -> u32 {
        self.scoring_penalty_relay_cluster.unwrap_or(0)
    }

    pub fn clear_scoring_penalty_relay_cluster(&mut self) {
        self.scoring_penalty_relay_cluster = ::std::option::Option::None;
    }

    pub fn has_scoring_penalty_relay_cluster(&self) -> bool {
        self.scoring_penalty_relay_cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scoring_penalty_relay_cluster(&mut self, v: u32) {
        self.scoring_penalty_relay_cluster = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 12;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_timestamp",
            |m: &CMsgSteamDatagramRouterPingReply| { &m.client_timestamp },
            |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.client_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "latency_datacenter_ids",
            |m: &CMsgSteamDatagramRouterPingReply| { &m.latency_datacenter_ids },
            |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.latency_datacenter_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "latency_ping_ms",
            |m: &CMsgSteamDatagramRouterPingReply| { &m.latency_ping_ms },
            |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.latency_ping_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "your_public_ip",
            |m: &CMsgSteamDatagramRouterPingReply| { &m.your_public_ip },
            |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.your_public_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "your_public_port",
            |m: &CMsgSteamDatagramRouterPingReply| { &m.your_public_port },
            |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.your_public_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_time",
            |m: &CMsgSteamDatagramRouterPingReply| { &m.server_time },
            |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.server_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge",
            |m: &CMsgSteamDatagramRouterPingReply| { &m.challenge },
            |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.challenge },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seconds_until_shutdown",
            |m: &CMsgSteamDatagramRouterPingReply| { &m.seconds_until_shutdown },
            |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.seconds_until_shutdown },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_cookie",
            |m: &CMsgSteamDatagramRouterPingReply| { &m.client_cookie },
            |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.client_cookie },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scoring_penalty_relay_cluster",
            |m: &CMsgSteamDatagramRouterPingReply| { &m.scoring_penalty_relay_cluster },
            |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.scoring_penalty_relay_cluster },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CMsgSteamDatagramRouterPingReply| { &m.flags },
            |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "route_exceptions",
            |m: &CMsgSteamDatagramRouterPingReply| { &m.route_exceptions },
            |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.route_exceptions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "alt_addresses",
            |m: &CMsgSteamDatagramRouterPingReply| { &m.alt_addresses },
            |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.alt_addresses },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramRouterPingReply>(
            "CMsgSteamDatagramRouterPingReply",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramRouterPingReply {
    const NAME: &'static str = "CMsgSteamDatagramRouterPingReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.client_timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                18 => {
                    is.read_repeated_packed_fixed32_into(&mut self.latency_datacenter_ids)?;
                },
                21 => {
                    self.latency_datacenter_ids.push(is.read_fixed32()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.latency_ping_ms)?;
                },
                24 => {
                    self.latency_ping_ms.push(is.read_uint32()?);
                },
                37 => {
                    self.your_public_ip = ::std::option::Option::Some(is.read_fixed32()?);
                },
                93 => {
                    self.your_public_port = ::std::option::Option::Some(is.read_fixed32()?);
                },
                45 => {
                    self.server_time = ::std::option::Option::Some(is.read_fixed32()?);
                },
                49 => {
                    self.challenge = ::std::option::Option::Some(is.read_fixed64()?);
                },
                56 => {
                    self.seconds_until_shutdown = ::std::option::Option::Some(is.read_uint32()?);
                },
                69 => {
                    self.client_cookie = ::std::option::Option::Some(is.read_fixed32()?);
                },
                72 => {
                    self.scoring_penalty_relay_cluster = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                82 => {
                    self.route_exceptions.push(is.read_message()?);
                },
                106 => {
                    self.alt_addresses.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.client_timestamp {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::vec_packed_fixed32_size(2, &self.latency_datacenter_ids);
        my_size += ::protobuf::rt::vec_packed_uint32_size(3, &self.latency_ping_ms);
        if let Some(v) = self.your_public_ip {
            my_size += 1 + 4;
        }
        if let Some(v) = self.your_public_port {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.challenge {
            my_size += 1 + 8;
        }
        if let Some(v) = self.seconds_until_shutdown {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.client_cookie {
            my_size += 1 + 4;
        }
        if let Some(v) = self.scoring_penalty_relay_cluster {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        for value in &self.route_exceptions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.alt_addresses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.client_timestamp {
            os.write_fixed32(1, v)?;
        }
        os.write_repeated_packed_fixed32(2, &self.latency_datacenter_ids)?;
        os.write_repeated_packed_uint32(3, &self.latency_ping_ms)?;
        if let Some(v) = self.your_public_ip {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.your_public_port {
            os.write_fixed32(11, v)?;
        }
        if let Some(v) = self.server_time {
            os.write_fixed32(5, v)?;
        }
        if let Some(v) = self.challenge {
            os.write_fixed64(6, v)?;
        }
        if let Some(v) = self.seconds_until_shutdown {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.client_cookie {
            os.write_fixed32(8, v)?;
        }
        if let Some(v) = self.scoring_penalty_relay_cluster {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(12, v)?;
        }
        for v in &self.route_exceptions {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        for v in &self.alt_addresses {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramRouterPingReply {
        CMsgSteamDatagramRouterPingReply::new()
    }

    fn clear(&mut self) {
        self.client_timestamp = ::std::option::Option::None;
        self.latency_datacenter_ids.clear();
        self.latency_ping_ms.clear();
        self.your_public_ip = ::std::option::Option::None;
        self.your_public_port = ::std::option::Option::None;
        self.server_time = ::std::option::Option::None;
        self.challenge = ::std::option::Option::None;
        self.seconds_until_shutdown = ::std::option::Option::None;
        self.client_cookie = ::std::option::Option::None;
        self.scoring_penalty_relay_cluster = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.route_exceptions.clear();
        self.alt_addresses.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramRouterPingReply {
        static instance: CMsgSteamDatagramRouterPingReply = CMsgSteamDatagramRouterPingReply {
            client_timestamp: ::std::option::Option::None,
            latency_datacenter_ids: ::std::vec::Vec::new(),
            latency_ping_ms: ::std::vec::Vec::new(),
            your_public_ip: ::std::option::Option::None,
            your_public_port: ::std::option::Option::None,
            server_time: ::std::option::Option::None,
            challenge: ::std::option::Option::None,
            seconds_until_shutdown: ::std::option::Option::None,
            client_cookie: ::std::option::Option::None,
            scoring_penalty_relay_cluster: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            route_exceptions: ::std::vec::Vec::new(),
            alt_addresses: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramRouterPingReply {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramRouterPingReply").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramRouterPingReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramRouterPingReply {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSteamDatagramRouterPingReply`
pub mod cmsg_steam_datagram_router_ping_reply {
    // @@protoc_insertion_point(message:CMsgSteamDatagramRouterPingReply.RouteException)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RouteException {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.RouteException.data_center_id)
        pub data_center_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.RouteException.flags)
        pub flags: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.RouteException.penalty)
        pub penalty: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamDatagramRouterPingReply.RouteException.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RouteException {
        fn default() -> &'a RouteException {
            <RouteException as ::protobuf::Message>::default_instance()
        }
    }

    impl RouteException {
        pub fn new() -> RouteException {
            ::std::default::Default::default()
        }

        // optional fixed32 data_center_id = 1;

        pub fn data_center_id(&self) -> u32 {
            self.data_center_id.unwrap_or(0)
        }

        pub fn clear_data_center_id(&mut self) {
            self.data_center_id = ::std::option::Option::None;
        }

        pub fn has_data_center_id(&self) -> bool {
            self.data_center_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data_center_id(&mut self, v: u32) {
            self.data_center_id = ::std::option::Option::Some(v);
        }

        // optional uint32 flags = 2;

        pub fn flags(&self) -> u32 {
            self.flags.unwrap_or(0)
        }

        pub fn clear_flags(&mut self) {
            self.flags = ::std::option::Option::None;
        }

        pub fn has_flags(&self) -> bool {
            self.flags.is_some()
        }

        // Param is passed by value, moved
        pub fn set_flags(&mut self, v: u32) {
            self.flags = ::std::option::Option::Some(v);
        }

        // optional uint32 penalty = 3;

        pub fn penalty(&self) -> u32 {
            self.penalty.unwrap_or(0)
        }

        pub fn clear_penalty(&mut self) {
            self.penalty = ::std::option::Option::None;
        }

        pub fn has_penalty(&self) -> bool {
            self.penalty.is_some()
        }

        // Param is passed by value, moved
        pub fn set_penalty(&mut self, v: u32) {
            self.penalty = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "data_center_id",
                |m: &RouteException| { &m.data_center_id },
                |m: &mut RouteException| { &mut m.data_center_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "flags",
                |m: &RouteException| { &m.flags },
                |m: &mut RouteException| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "penalty",
                |m: &RouteException| { &m.penalty },
                |m: &mut RouteException| { &mut m.penalty },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RouteException>(
                "CMsgSteamDatagramRouterPingReply.RouteException",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RouteException {
        const NAME: &'static str = "RouteException";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.data_center_id = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    16 => {
                        self.flags = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.penalty = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data_center_id {
                my_size += 1 + 4;
            }
            if let Some(v) = self.flags {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.penalty {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data_center_id {
                os.write_fixed32(1, v)?;
            }
            if let Some(v) = self.flags {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.penalty {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RouteException {
            RouteException::new()
        }

        fn clear(&mut self) {
            self.data_center_id = ::std::option::Option::None;
            self.flags = ::std::option::Option::None;
            self.penalty = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RouteException {
            static instance: RouteException = RouteException {
                data_center_id: ::std::option::Option::None,
                flags: ::std::option::Option::None,
                penalty: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RouteException {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSteamDatagramRouterPingReply.RouteException").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RouteException {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RouteException {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgSteamDatagramRouterPingReply.AltAddress)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AltAddress {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.AltAddress.ipv4)
        pub ipv4: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.AltAddress.port)
        pub port: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.AltAddress.penalty)
        pub penalty: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.AltAddress.protocol)
        pub protocol: ::std::option::Option<::protobuf::EnumOrUnknown<alt_address::Protocol>>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.AltAddress.id)
        pub id: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamDatagramRouterPingReply.AltAddress.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AltAddress {
        fn default() -> &'a AltAddress {
            <AltAddress as ::protobuf::Message>::default_instance()
        }
    }

    impl AltAddress {
        pub fn new() -> AltAddress {
            ::std::default::Default::default()
        }

        // optional fixed32 ipv4 = 1;

        pub fn ipv4(&self) -> u32 {
            self.ipv4.unwrap_or(0)
        }

        pub fn clear_ipv4(&mut self) {
            self.ipv4 = ::std::option::Option::None;
        }

        pub fn has_ipv4(&self) -> bool {
            self.ipv4.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ipv4(&mut self, v: u32) {
            self.ipv4 = ::std::option::Option::Some(v);
        }

        // optional uint32 port = 2;

        pub fn port(&self) -> u32 {
            self.port.unwrap_or(0)
        }

        pub fn clear_port(&mut self) {
            self.port = ::std::option::Option::None;
        }

        pub fn has_port(&self) -> bool {
            self.port.is_some()
        }

        // Param is passed by value, moved
        pub fn set_port(&mut self, v: u32) {
            self.port = ::std::option::Option::Some(v);
        }

        // optional uint32 penalty = 3;

        pub fn penalty(&self) -> u32 {
            self.penalty.unwrap_or(0)
        }

        pub fn clear_penalty(&mut self) {
            self.penalty = ::std::option::Option::None;
        }

        pub fn has_penalty(&self) -> bool {
            self.penalty.is_some()
        }

        // Param is passed by value, moved
        pub fn set_penalty(&mut self, v: u32) {
            self.penalty = ::std::option::Option::Some(v);
        }

        // optional .CMsgSteamDatagramRouterPingReply.AltAddress.Protocol protocol = 4;

        pub fn protocol(&self) -> alt_address::Protocol {
            match self.protocol {
                Some(e) => e.enum_value_or(alt_address::Protocol::DefaultProtocol),
                None => alt_address::Protocol::DefaultProtocol,
            }
        }

        pub fn clear_protocol(&mut self) {
            self.protocol = ::std::option::Option::None;
        }

        pub fn has_protocol(&self) -> bool {
            self.protocol.is_some()
        }

        // Param is passed by value, moved
        pub fn set_protocol(&mut self, v: alt_address::Protocol) {
            self.protocol = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional string id = 5;

        pub fn id(&self) -> &str {
            match self.id.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: ::std::string::String) {
            self.id = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_id(&mut self) -> &mut ::std::string::String {
            if self.id.is_none() {
                self.id = ::std::option::Option::Some(::std::string::String::new());
            }
            self.id.as_mut().unwrap()
        }

        // Take field
        pub fn take_id(&mut self) -> ::std::string::String {
            self.id.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ipv4",
                |m: &AltAddress| { &m.ipv4 },
                |m: &mut AltAddress| { &mut m.ipv4 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "port",
                |m: &AltAddress| { &m.port },
                |m: &mut AltAddress| { &mut m.port },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "penalty",
                |m: &AltAddress| { &m.penalty },
                |m: &mut AltAddress| { &mut m.penalty },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "protocol",
                |m: &AltAddress| { &m.protocol },
                |m: &mut AltAddress| { &mut m.protocol },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "id",
                |m: &AltAddress| { &m.id },
                |m: &mut AltAddress| { &mut m.id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AltAddress>(
                "CMsgSteamDatagramRouterPingReply.AltAddress",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AltAddress {
        const NAME: &'static str = "AltAddress";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.ipv4 = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    16 => {
                        self.port = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.penalty = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.protocol = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    42 => {
                        self.id = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.ipv4 {
                my_size += 1 + 4;
            }
            if let Some(v) = self.port {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.penalty {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.protocol {
                my_size += ::protobuf::rt::int32_size(4, v.value());
            }
            if let Some(v) = self.id.as_ref() {
                my_size += ::protobuf::rt::string_size(5, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.ipv4 {
                os.write_fixed32(1, v)?;
            }
            if let Some(v) = self.port {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.penalty {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.protocol {
                os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.id.as_ref() {
                os.write_string(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AltAddress {
            AltAddress::new()
        }

        fn clear(&mut self) {
            self.ipv4 = ::std::option::Option::None;
            self.port = ::std::option::Option::None;
            self.penalty = ::std::option::Option::None;
            self.protocol = ::std::option::Option::None;
            self.id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AltAddress {
            static instance: AltAddress = AltAddress {
                ipv4: ::std::option::Option::None,
                port: ::std::option::Option::None,
                penalty: ::std::option::Option::None,
                protocol: ::std::option::Option::None,
                id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AltAddress {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSteamDatagramRouterPingReply.AltAddress").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AltAddress {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AltAddress {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `AltAddress`
    pub mod alt_address {
        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:CMsgSteamDatagramRouterPingReply.AltAddress.Protocol)
        pub enum Protocol {
            // @@protoc_insertion_point(enum_value:CMsgSteamDatagramRouterPingReply.AltAddress.Protocol.DefaultProtocol)
            DefaultProtocol = 0,
            // @@protoc_insertion_point(enum_value:CMsgSteamDatagramRouterPingReply.AltAddress.Protocol.NetworkNext)
            NetworkNext = 1,
        }

        impl ::protobuf::Enum for Protocol {
            const NAME: &'static str = "Protocol";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<Protocol> {
                match value {
                    0 => ::std::option::Option::Some(Protocol::DefaultProtocol),
                    1 => ::std::option::Option::Some(Protocol::NetworkNext),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<Protocol> {
                match str {
                    "DefaultProtocol" => ::std::option::Option::Some(Protocol::DefaultProtocol),
                    "NetworkNext" => ::std::option::Option::Some(Protocol::NetworkNext),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [Protocol] = &[
                Protocol::DefaultProtocol,
                Protocol::NetworkNext,
            ];
        }

        impl ::protobuf::EnumFull for Protocol {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("CMsgSteamDatagramRouterPingReply.AltAddress.Protocol").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for Protocol {
            fn default() -> Self {
                Protocol::DefaultProtocol
            }
        }

        impl Protocol {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Protocol>("CMsgSteamDatagramRouterPingReply.AltAddress.Protocol")
            }
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgSteamDatagramRouterPingReply.Flags)
    pub enum Flags {
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramRouterPingReply.Flags.FLAG_MAYBE_MORE_DATA_CENTERS)
        FLAG_MAYBE_MORE_DATA_CENTERS = 1,
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramRouterPingReply.Flags.FLAG_MAYBE_MORE_ALT_ADDRESSES)
        FLAG_MAYBE_MORE_ALT_ADDRESSES = 2,
    }

    impl ::protobuf::Enum for Flags {
        const NAME: &'static str = "Flags";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Flags> {
            match value {
                1 => ::std::option::Option::Some(Flags::FLAG_MAYBE_MORE_DATA_CENTERS),
                2 => ::std::option::Option::Some(Flags::FLAG_MAYBE_MORE_ALT_ADDRESSES),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Flags> {
            match str {
                "FLAG_MAYBE_MORE_DATA_CENTERS" => ::std::option::Option::Some(Flags::FLAG_MAYBE_MORE_DATA_CENTERS),
                "FLAG_MAYBE_MORE_ALT_ADDRESSES" => ::std::option::Option::Some(Flags::FLAG_MAYBE_MORE_ALT_ADDRESSES),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Flags] = &[
            Flags::FLAG_MAYBE_MORE_DATA_CENTERS,
            Flags::FLAG_MAYBE_MORE_ALT_ADDRESSES,
        ];
    }

    impl ::protobuf::EnumFull for Flags {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgSteamDatagramRouterPingReply.Flags").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Flags::FLAG_MAYBE_MORE_DATA_CENTERS => 0,
                Flags::FLAG_MAYBE_MORE_ALT_ADDRESSES => 1,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Flags {
        fn default() -> Self {
            Flags::FLAG_MAYBE_MORE_DATA_CENTERS
        }
    }

    impl Flags {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Flags>("CMsgSteamDatagramRouterPingReply.Flags")
        }
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramGameserverPingRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramGameserverPingRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverPingRequest.your_public_ip)
    pub your_public_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverPingRequest.your_public_port)
    pub your_public_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverPingRequest.server_time)
    pub server_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverPingRequest.challenge)
    pub challenge: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverPingRequest.router_timestamp)
    pub router_timestamp: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramGameserverPingRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramGameserverPingRequest {
    fn default() -> &'a CMsgSteamDatagramGameserverPingRequest {
        <CMsgSteamDatagramGameserverPingRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramGameserverPingRequest {
    pub fn new() -> CMsgSteamDatagramGameserverPingRequest {
        ::std::default::Default::default()
    }

    // optional fixed32 your_public_ip = 1;

    pub fn your_public_ip(&self) -> u32 {
        self.your_public_ip.unwrap_or(0)
    }

    pub fn clear_your_public_ip(&mut self) {
        self.your_public_ip = ::std::option::Option::None;
    }

    pub fn has_your_public_ip(&self) -> bool {
        self.your_public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_your_public_ip(&mut self, v: u32) {
        self.your_public_ip = ::std::option::Option::Some(v);
    }

    // optional fixed32 your_public_port = 5;

    pub fn your_public_port(&self) -> u32 {
        self.your_public_port.unwrap_or(0)
    }

    pub fn clear_your_public_port(&mut self) {
        self.your_public_port = ::std::option::Option::None;
    }

    pub fn has_your_public_port(&self) -> bool {
        self.your_public_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_your_public_port(&mut self, v: u32) {
        self.your_public_port = ::std::option::Option::Some(v);
    }

    // optional fixed32 server_time = 2;

    pub fn server_time(&self) -> u32 {
        self.server_time.unwrap_or(0)
    }

    pub fn clear_server_time(&mut self) {
        self.server_time = ::std::option::Option::None;
    }

    pub fn has_server_time(&self) -> bool {
        self.server_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_time(&mut self, v: u32) {
        self.server_time = ::std::option::Option::Some(v);
    }

    // optional fixed64 challenge = 3;

    pub fn challenge(&self) -> u64 {
        self.challenge.unwrap_or(0)
    }

    pub fn clear_challenge(&mut self) {
        self.challenge = ::std::option::Option::None;
    }

    pub fn has_challenge(&self) -> bool {
        self.challenge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge(&mut self, v: u64) {
        self.challenge = ::std::option::Option::Some(v);
    }

    // optional fixed32 router_timestamp = 4;

    pub fn router_timestamp(&self) -> u32 {
        self.router_timestamp.unwrap_or(0)
    }

    pub fn clear_router_timestamp(&mut self) {
        self.router_timestamp = ::std::option::Option::None;
    }

    pub fn has_router_timestamp(&self) -> bool {
        self.router_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_router_timestamp(&mut self, v: u32) {
        self.router_timestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "your_public_ip",
            |m: &CMsgSteamDatagramGameserverPingRequest| { &m.your_public_ip },
            |m: &mut CMsgSteamDatagramGameserverPingRequest| { &mut m.your_public_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "your_public_port",
            |m: &CMsgSteamDatagramGameserverPingRequest| { &m.your_public_port },
            |m: &mut CMsgSteamDatagramGameserverPingRequest| { &mut m.your_public_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_time",
            |m: &CMsgSteamDatagramGameserverPingRequest| { &m.server_time },
            |m: &mut CMsgSteamDatagramGameserverPingRequest| { &mut m.server_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge",
            |m: &CMsgSteamDatagramGameserverPingRequest| { &m.challenge },
            |m: &mut CMsgSteamDatagramGameserverPingRequest| { &mut m.challenge },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "router_timestamp",
            |m: &CMsgSteamDatagramGameserverPingRequest| { &m.router_timestamp },
            |m: &mut CMsgSteamDatagramGameserverPingRequest| { &mut m.router_timestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramGameserverPingRequest>(
            "CMsgSteamDatagramGameserverPingRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramGameserverPingRequest {
    const NAME: &'static str = "CMsgSteamDatagramGameserverPingRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.your_public_ip = ::std::option::Option::Some(is.read_fixed32()?);
                },
                45 => {
                    self.your_public_port = ::std::option::Option::Some(is.read_fixed32()?);
                },
                21 => {
                    self.server_time = ::std::option::Option::Some(is.read_fixed32()?);
                },
                25 => {
                    self.challenge = ::std::option::Option::Some(is.read_fixed64()?);
                },
                37 => {
                    self.router_timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.your_public_ip {
            my_size += 1 + 4;
        }
        if let Some(v) = self.your_public_port {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.challenge {
            my_size += 1 + 8;
        }
        if let Some(v) = self.router_timestamp {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.your_public_ip {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.your_public_port {
            os.write_fixed32(5, v)?;
        }
        if let Some(v) = self.server_time {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.challenge {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.router_timestamp {
            os.write_fixed32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramGameserverPingRequest {
        CMsgSteamDatagramGameserverPingRequest::new()
    }

    fn clear(&mut self) {
        self.your_public_ip = ::std::option::Option::None;
        self.your_public_port = ::std::option::Option::None;
        self.server_time = ::std::option::Option::None;
        self.challenge = ::std::option::Option::None;
        self.router_timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramGameserverPingRequest {
        static instance: CMsgSteamDatagramGameserverPingRequest = CMsgSteamDatagramGameserverPingRequest {
            your_public_ip: ::std::option::Option::None,
            your_public_port: ::std::option::Option::None,
            server_time: ::std::option::Option::None,
            challenge: ::std::option::Option::None,
            router_timestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramGameserverPingRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramGameserverPingRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramGameserverPingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramGameserverPingRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamDatagramLegacyGameserverPingReply)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramLegacyGameserverPingReply {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramLegacyGameserverPingReply.router_timestamp)
    pub router_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLegacyGameserverPingReply.dummy_pad)
    pub dummy_pad: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramLegacyGameserverPingReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramLegacyGameserverPingReply {
    fn default() -> &'a CMsgSteamDatagramLegacyGameserverPingReply {
        <CMsgSteamDatagramLegacyGameserverPingReply as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramLegacyGameserverPingReply {
    pub fn new() -> CMsgSteamDatagramLegacyGameserverPingReply {
        ::std::default::Default::default()
    }

    // optional fixed32 router_timestamp = 4;

    pub fn router_timestamp(&self) -> u32 {
        self.router_timestamp.unwrap_or(0)
    }

    pub fn clear_router_timestamp(&mut self) {
        self.router_timestamp = ::std::option::Option::None;
    }

    pub fn has_router_timestamp(&self) -> bool {
        self.router_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_router_timestamp(&mut self, v: u32) {
        self.router_timestamp = ::std::option::Option::Some(v);
    }

    // optional fixed64 dummy_pad = 99;

    pub fn dummy_pad(&self) -> u64 {
        self.dummy_pad.unwrap_or(0)
    }

    pub fn clear_dummy_pad(&mut self) {
        self.dummy_pad = ::std::option::Option::None;
    }

    pub fn has_dummy_pad(&self) -> bool {
        self.dummy_pad.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy_pad(&mut self, v: u64) {
        self.dummy_pad = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "router_timestamp",
            |m: &CMsgSteamDatagramLegacyGameserverPingReply| { &m.router_timestamp },
            |m: &mut CMsgSteamDatagramLegacyGameserverPingReply| { &mut m.router_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dummy_pad",
            |m: &CMsgSteamDatagramLegacyGameserverPingReply| { &m.dummy_pad },
            |m: &mut CMsgSteamDatagramLegacyGameserverPingReply| { &mut m.dummy_pad },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramLegacyGameserverPingReply>(
            "CMsgSteamDatagramLegacyGameserverPingReply",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramLegacyGameserverPingReply {
    const NAME: &'static str = "CMsgSteamDatagramLegacyGameserverPingReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                37 => {
                    self.router_timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                793 => {
                    self.dummy_pad = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.router_timestamp {
            my_size += 1 + 4;
        }
        if let Some(v) = self.dummy_pad {
            my_size += 2 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.router_timestamp {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.dummy_pad {
            os.write_fixed64(99, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramLegacyGameserverPingReply {
        CMsgSteamDatagramLegacyGameserverPingReply::new()
    }

    fn clear(&mut self) {
        self.router_timestamp = ::std::option::Option::None;
        self.dummy_pad = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramLegacyGameserverPingReply {
        static instance: CMsgSteamDatagramLegacyGameserverPingReply = CMsgSteamDatagramLegacyGameserverPingReply {
            router_timestamp: ::std::option::Option::None,
            dummy_pad: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramLegacyGameserverPingReply {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramLegacyGameserverPingReply").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramLegacyGameserverPingReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramLegacyGameserverPingReply {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamDatagramGameserverPingReply)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramGameserverPingReply {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverPingReply.cert)
    pub cert: ::protobuf::MessageField<super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverPingReply.signed_data)
    pub signed_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverPingReply.signature)
    pub signature: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramGameserverPingReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramGameserverPingReply {
    fn default() -> &'a CMsgSteamDatagramGameserverPingReply {
        <CMsgSteamDatagramGameserverPingReply as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramGameserverPingReply {
    pub fn new() -> CMsgSteamDatagramGameserverPingReply {
        ::std::default::Default::default()
    }

    // optional bytes signed_data = 2;

    pub fn signed_data(&self) -> &[u8] {
        match self.signed_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_signed_data(&mut self) {
        self.signed_data = ::std::option::Option::None;
    }

    pub fn has_signed_data(&self) -> bool {
        self.signed_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signed_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.signed_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signed_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signed_data.is_none() {
            self.signed_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.signed_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_signed_data(&mut self) -> ::std::vec::Vec<u8> {
        self.signed_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes signature = 3;

    pub fn signature(&self) -> &[u8] {
        match self.signature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_signature(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signature.is_none() {
            self.signature = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned>(
            "cert",
            |m: &CMsgSteamDatagramGameserverPingReply| { &m.cert },
            |m: &mut CMsgSteamDatagramGameserverPingReply| { &mut m.cert },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "signed_data",
            |m: &CMsgSteamDatagramGameserverPingReply| { &m.signed_data },
            |m: &mut CMsgSteamDatagramGameserverPingReply| { &mut m.signed_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "signature",
            |m: &CMsgSteamDatagramGameserverPingReply| { &m.signature },
            |m: &mut CMsgSteamDatagramGameserverPingReply| { &mut m.signature },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramGameserverPingReply>(
            "CMsgSteamDatagramGameserverPingReply",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramGameserverPingReply {
    const NAME: &'static str = "CMsgSteamDatagramGameserverPingReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cert)?;
                },
                18 => {
                    self.signed_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.signature = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cert.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.signed_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cert.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.signed_data.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.signature.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramGameserverPingReply {
        CMsgSteamDatagramGameserverPingReply::new()
    }

    fn clear(&mut self) {
        self.cert.clear();
        self.signed_data = ::std::option::Option::None;
        self.signature = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramGameserverPingReply {
        static instance: CMsgSteamDatagramGameserverPingReply = CMsgSteamDatagramGameserverPingReply {
            cert: ::protobuf::MessageField::none(),
            signed_data: ::std::option::Option::None,
            signature: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramGameserverPingReply {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramGameserverPingReply").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramGameserverPingReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramGameserverPingReply {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSteamDatagramGameserverPingReply`
pub mod cmsg_steam_datagram_gameserver_ping_reply {
    // @@protoc_insertion_point(message:CMsgSteamDatagramGameserverPingReply.SignedData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SignedData {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverPingReply.SignedData.challenge_time)
        pub challenge_time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverPingReply.SignedData.challenge)
        pub challenge: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverPingReply.SignedData.router_timestamp)
        pub router_timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverPingReply.SignedData.data_center_id)
        pub data_center_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverPingReply.SignedData.appid)
        pub appid: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamDatagramGameserverPingReply.SignedData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SignedData {
        fn default() -> &'a SignedData {
            <SignedData as ::protobuf::Message>::default_instance()
        }
    }

    impl SignedData {
        pub fn new() -> SignedData {
            ::std::default::Default::default()
        }

        // optional fixed32 challenge_time = 2;

        pub fn challenge_time(&self) -> u32 {
            self.challenge_time.unwrap_or(0)
        }

        pub fn clear_challenge_time(&mut self) {
            self.challenge_time = ::std::option::Option::None;
        }

        pub fn has_challenge_time(&self) -> bool {
            self.challenge_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_challenge_time(&mut self, v: u32) {
            self.challenge_time = ::std::option::Option::Some(v);
        }

        // optional fixed64 challenge = 3;

        pub fn challenge(&self) -> u64 {
            self.challenge.unwrap_or(0)
        }

        pub fn clear_challenge(&mut self) {
            self.challenge = ::std::option::Option::None;
        }

        pub fn has_challenge(&self) -> bool {
            self.challenge.is_some()
        }

        // Param is passed by value, moved
        pub fn set_challenge(&mut self, v: u64) {
            self.challenge = ::std::option::Option::Some(v);
        }

        // optional fixed32 router_timestamp = 4;

        pub fn router_timestamp(&self) -> u32 {
            self.router_timestamp.unwrap_or(0)
        }

        pub fn clear_router_timestamp(&mut self) {
            self.router_timestamp = ::std::option::Option::None;
        }

        pub fn has_router_timestamp(&self) -> bool {
            self.router_timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_router_timestamp(&mut self, v: u32) {
            self.router_timestamp = ::std::option::Option::Some(v);
        }

        // optional fixed32 data_center_id = 5;

        pub fn data_center_id(&self) -> u32 {
            self.data_center_id.unwrap_or(0)
        }

        pub fn clear_data_center_id(&mut self) {
            self.data_center_id = ::std::option::Option::None;
        }

        pub fn has_data_center_id(&self) -> bool {
            self.data_center_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data_center_id(&mut self, v: u32) {
            self.data_center_id = ::std::option::Option::Some(v);
        }

        // optional uint32 appid = 6;

        pub fn appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "challenge_time",
                |m: &SignedData| { &m.challenge_time },
                |m: &mut SignedData| { &mut m.challenge_time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "challenge",
                |m: &SignedData| { &m.challenge },
                |m: &mut SignedData| { &mut m.challenge },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "router_timestamp",
                |m: &SignedData| { &m.router_timestamp },
                |m: &mut SignedData| { &mut m.router_timestamp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "data_center_id",
                |m: &SignedData| { &m.data_center_id },
                |m: &mut SignedData| { &mut m.data_center_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "appid",
                |m: &SignedData| { &m.appid },
                |m: &mut SignedData| { &mut m.appid },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SignedData>(
                "CMsgSteamDatagramGameserverPingReply.SignedData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SignedData {
        const NAME: &'static str = "SignedData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    21 => {
                        self.challenge_time = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    25 => {
                        self.challenge = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    37 => {
                        self.router_timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    45 => {
                        self.data_center_id = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    48 => {
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.challenge_time {
                my_size += 1 + 4;
            }
            if let Some(v) = self.challenge {
                my_size += 1 + 8;
            }
            if let Some(v) = self.router_timestamp {
                my_size += 1 + 4;
            }
            if let Some(v) = self.data_center_id {
                my_size += 1 + 4;
            }
            if let Some(v) = self.appid {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.challenge_time {
                os.write_fixed32(2, v)?;
            }
            if let Some(v) = self.challenge {
                os.write_fixed64(3, v)?;
            }
            if let Some(v) = self.router_timestamp {
                os.write_fixed32(4, v)?;
            }
            if let Some(v) = self.data_center_id {
                os.write_fixed32(5, v)?;
            }
            if let Some(v) = self.appid {
                os.write_uint32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SignedData {
            SignedData::new()
        }

        fn clear(&mut self) {
            self.challenge_time = ::std::option::Option::None;
            self.challenge = ::std::option::Option::None;
            self.router_timestamp = ::std::option::Option::None;
            self.data_center_id = ::std::option::Option::None;
            self.appid = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SignedData {
            static instance: SignedData = SignedData {
                challenge_time: ::std::option::Option::None,
                challenge: ::std::option::Option::None,
                router_timestamp: ::std::option::Option::None,
                data_center_id: ::std::option::Option::None,
                appid: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SignedData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSteamDatagramGameserverPingReply.SignedData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SignedData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SignedData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramNoSessionRelayToClient)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramNoSessionRelayToClient {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoSessionRelayToClient.connection_id)
    pub connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoSessionRelayToClient.your_public_ip)
    pub your_public_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoSessionRelayToClient.your_public_port)
    pub your_public_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoSessionRelayToClient.server_time)
    pub server_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoSessionRelayToClient.challenge)
    pub challenge: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoSessionRelayToClient.seconds_until_shutdown)
    pub seconds_until_shutdown: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramNoSessionRelayToClient.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramNoSessionRelayToClient {
    fn default() -> &'a CMsgSteamDatagramNoSessionRelayToClient {
        <CMsgSteamDatagramNoSessionRelayToClient as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramNoSessionRelayToClient {
    pub fn new() -> CMsgSteamDatagramNoSessionRelayToClient {
        ::std::default::Default::default()
    }

    // optional fixed32 connection_id = 7;

    pub fn connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }

    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 your_public_ip = 2;

    pub fn your_public_ip(&self) -> u32 {
        self.your_public_ip.unwrap_or(0)
    }

    pub fn clear_your_public_ip(&mut self) {
        self.your_public_ip = ::std::option::Option::None;
    }

    pub fn has_your_public_ip(&self) -> bool {
        self.your_public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_your_public_ip(&mut self, v: u32) {
        self.your_public_ip = ::std::option::Option::Some(v);
    }

    // optional fixed32 your_public_port = 6;

    pub fn your_public_port(&self) -> u32 {
        self.your_public_port.unwrap_or(0)
    }

    pub fn clear_your_public_port(&mut self) {
        self.your_public_port = ::std::option::Option::None;
    }

    pub fn has_your_public_port(&self) -> bool {
        self.your_public_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_your_public_port(&mut self, v: u32) {
        self.your_public_port = ::std::option::Option::Some(v);
    }

    // optional fixed32 server_time = 3;

    pub fn server_time(&self) -> u32 {
        self.server_time.unwrap_or(0)
    }

    pub fn clear_server_time(&mut self) {
        self.server_time = ::std::option::Option::None;
    }

    pub fn has_server_time(&self) -> bool {
        self.server_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_time(&mut self, v: u32) {
        self.server_time = ::std::option::Option::Some(v);
    }

    // optional fixed64 challenge = 4;

    pub fn challenge(&self) -> u64 {
        self.challenge.unwrap_or(0)
    }

    pub fn clear_challenge(&mut self) {
        self.challenge = ::std::option::Option::None;
    }

    pub fn has_challenge(&self) -> bool {
        self.challenge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge(&mut self, v: u64) {
        self.challenge = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_until_shutdown = 5;

    pub fn seconds_until_shutdown(&self) -> u32 {
        self.seconds_until_shutdown.unwrap_or(0)
    }

    pub fn clear_seconds_until_shutdown(&mut self) {
        self.seconds_until_shutdown = ::std::option::Option::None;
    }

    pub fn has_seconds_until_shutdown(&self) -> bool {
        self.seconds_until_shutdown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_until_shutdown(&mut self, v: u32) {
        self.seconds_until_shutdown = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "connection_id",
            |m: &CMsgSteamDatagramNoSessionRelayToClient| { &m.connection_id },
            |m: &mut CMsgSteamDatagramNoSessionRelayToClient| { &mut m.connection_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "your_public_ip",
            |m: &CMsgSteamDatagramNoSessionRelayToClient| { &m.your_public_ip },
            |m: &mut CMsgSteamDatagramNoSessionRelayToClient| { &mut m.your_public_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "your_public_port",
            |m: &CMsgSteamDatagramNoSessionRelayToClient| { &m.your_public_port },
            |m: &mut CMsgSteamDatagramNoSessionRelayToClient| { &mut m.your_public_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_time",
            |m: &CMsgSteamDatagramNoSessionRelayToClient| { &m.server_time },
            |m: &mut CMsgSteamDatagramNoSessionRelayToClient| { &mut m.server_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge",
            |m: &CMsgSteamDatagramNoSessionRelayToClient| { &m.challenge },
            |m: &mut CMsgSteamDatagramNoSessionRelayToClient| { &mut m.challenge },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seconds_until_shutdown",
            |m: &CMsgSteamDatagramNoSessionRelayToClient| { &m.seconds_until_shutdown },
            |m: &mut CMsgSteamDatagramNoSessionRelayToClient| { &mut m.seconds_until_shutdown },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramNoSessionRelayToClient>(
            "CMsgSteamDatagramNoSessionRelayToClient",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramNoSessionRelayToClient {
    const NAME: &'static str = "CMsgSteamDatagramNoSessionRelayToClient";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                61 => {
                    self.connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                21 => {
                    self.your_public_ip = ::std::option::Option::Some(is.read_fixed32()?);
                },
                53 => {
                    self.your_public_port = ::std::option::Option::Some(is.read_fixed32()?);
                },
                29 => {
                    self.server_time = ::std::option::Option::Some(is.read_fixed32()?);
                },
                33 => {
                    self.challenge = ::std::option::Option::Some(is.read_fixed64()?);
                },
                40 => {
                    self.seconds_until_shutdown = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.your_public_ip {
            my_size += 1 + 4;
        }
        if let Some(v) = self.your_public_port {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.challenge {
            my_size += 1 + 8;
        }
        if let Some(v) = self.seconds_until_shutdown {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.connection_id {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.your_public_ip {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.your_public_port {
            os.write_fixed32(6, v)?;
        }
        if let Some(v) = self.server_time {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.challenge {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.seconds_until_shutdown {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramNoSessionRelayToClient {
        CMsgSteamDatagramNoSessionRelayToClient::new()
    }

    fn clear(&mut self) {
        self.connection_id = ::std::option::Option::None;
        self.your_public_ip = ::std::option::Option::None;
        self.your_public_port = ::std::option::Option::None;
        self.server_time = ::std::option::Option::None;
        self.challenge = ::std::option::Option::None;
        self.seconds_until_shutdown = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramNoSessionRelayToClient {
        static instance: CMsgSteamDatagramNoSessionRelayToClient = CMsgSteamDatagramNoSessionRelayToClient {
            connection_id: ::std::option::Option::None,
            your_public_ip: ::std::option::Option::None,
            your_public_port: ::std::option::Option::None,
            server_time: ::std::option::Option::None,
            challenge: ::std::option::Option::None,
            seconds_until_shutdown: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramNoSessionRelayToClient {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramNoSessionRelayToClient").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramNoSessionRelayToClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramNoSessionRelayToClient {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamDatagramNoSessionRelayToPeer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramNoSessionRelayToPeer {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoSessionRelayToPeer.legacy_relay_session_id)
    pub legacy_relay_session_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoSessionRelayToPeer.from_relay_session_id)
    pub from_relay_session_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoSessionRelayToPeer.from_connection_id)
    pub from_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoSessionRelayToPeer.kludge_pad)
    pub kludge_pad: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramNoSessionRelayToPeer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramNoSessionRelayToPeer {
    fn default() -> &'a CMsgSteamDatagramNoSessionRelayToPeer {
        <CMsgSteamDatagramNoSessionRelayToPeer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramNoSessionRelayToPeer {
    pub fn new() -> CMsgSteamDatagramNoSessionRelayToPeer {
        ::std::default::Default::default()
    }

    // optional uint32 legacy_relay_session_id = 1;

    pub fn legacy_relay_session_id(&self) -> u32 {
        self.legacy_relay_session_id.unwrap_or(0)
    }

    pub fn clear_legacy_relay_session_id(&mut self) {
        self.legacy_relay_session_id = ::std::option::Option::None;
    }

    pub fn has_legacy_relay_session_id(&self) -> bool {
        self.legacy_relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_relay_session_id(&mut self, v: u32) {
        self.legacy_relay_session_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 from_relay_session_id = 2;

    pub fn from_relay_session_id(&self) -> u32 {
        self.from_relay_session_id.unwrap_or(0)
    }

    pub fn clear_from_relay_session_id(&mut self) {
        self.from_relay_session_id = ::std::option::Option::None;
    }

    pub fn has_from_relay_session_id(&self) -> bool {
        self.from_relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_relay_session_id(&mut self, v: u32) {
        self.from_relay_session_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 from_connection_id = 7;

    pub fn from_connection_id(&self) -> u32 {
        self.from_connection_id.unwrap_or(0)
    }

    pub fn clear_from_connection_id(&mut self) {
        self.from_connection_id = ::std::option::Option::None;
    }

    pub fn has_from_connection_id(&self) -> bool {
        self.from_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_connection_id(&mut self, v: u32) {
        self.from_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 kludge_pad = 99;

    pub fn kludge_pad(&self) -> u64 {
        self.kludge_pad.unwrap_or(0)
    }

    pub fn clear_kludge_pad(&mut self) {
        self.kludge_pad = ::std::option::Option::None;
    }

    pub fn has_kludge_pad(&self) -> bool {
        self.kludge_pad.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kludge_pad(&mut self, v: u64) {
        self.kludge_pad = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "legacy_relay_session_id",
            |m: &CMsgSteamDatagramNoSessionRelayToPeer| { &m.legacy_relay_session_id },
            |m: &mut CMsgSteamDatagramNoSessionRelayToPeer| { &mut m.legacy_relay_session_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "from_relay_session_id",
            |m: &CMsgSteamDatagramNoSessionRelayToPeer| { &m.from_relay_session_id },
            |m: &mut CMsgSteamDatagramNoSessionRelayToPeer| { &mut m.from_relay_session_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "from_connection_id",
            |m: &CMsgSteamDatagramNoSessionRelayToPeer| { &m.from_connection_id },
            |m: &mut CMsgSteamDatagramNoSessionRelayToPeer| { &mut m.from_connection_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kludge_pad",
            |m: &CMsgSteamDatagramNoSessionRelayToPeer| { &m.kludge_pad },
            |m: &mut CMsgSteamDatagramNoSessionRelayToPeer| { &mut m.kludge_pad },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramNoSessionRelayToPeer>(
            "CMsgSteamDatagramNoSessionRelayToPeer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramNoSessionRelayToPeer {
    const NAME: &'static str = "CMsgSteamDatagramNoSessionRelayToPeer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.legacy_relay_session_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.from_relay_session_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                61 => {
                    self.from_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                793 => {
                    self.kludge_pad = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.legacy_relay_session_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.from_relay_session_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.from_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.kludge_pad {
            my_size += 2 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.legacy_relay_session_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.from_relay_session_id {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.from_connection_id {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.kludge_pad {
            os.write_fixed64(99, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramNoSessionRelayToPeer {
        CMsgSteamDatagramNoSessionRelayToPeer::new()
    }

    fn clear(&mut self) {
        self.legacy_relay_session_id = ::std::option::Option::None;
        self.from_relay_session_id = ::std::option::Option::None;
        self.from_connection_id = ::std::option::Option::None;
        self.kludge_pad = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramNoSessionRelayToPeer {
        static instance: CMsgSteamDatagramNoSessionRelayToPeer = CMsgSteamDatagramNoSessionRelayToPeer {
            legacy_relay_session_id: ::std::option::Option::None,
            from_relay_session_id: ::std::option::Option::None,
            from_connection_id: ::std::option::Option::None,
            kludge_pad: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramNoSessionRelayToPeer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramNoSessionRelayToPeer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramNoSessionRelayToPeer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramNoSessionRelayToPeer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamDatagramClientPingSampleRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramClientPingSampleRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleRequest.connection_id)
    pub connection_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramClientPingSampleRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramClientPingSampleRequest {
    fn default() -> &'a CMsgSteamDatagramClientPingSampleRequest {
        <CMsgSteamDatagramClientPingSampleRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramClientPingSampleRequest {
    pub fn new() -> CMsgSteamDatagramClientPingSampleRequest {
        ::std::default::Default::default()
    }

    // optional fixed32 connection_id = 1;

    pub fn connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }

    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "connection_id",
            |m: &CMsgSteamDatagramClientPingSampleRequest| { &m.connection_id },
            |m: &mut CMsgSteamDatagramClientPingSampleRequest| { &mut m.connection_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramClientPingSampleRequest>(
            "CMsgSteamDatagramClientPingSampleRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramClientPingSampleRequest {
    const NAME: &'static str = "CMsgSteamDatagramClientPingSampleRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.connection_id {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.connection_id {
            os.write_fixed32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramClientPingSampleRequest {
        CMsgSteamDatagramClientPingSampleRequest::new()
    }

    fn clear(&mut self) {
        self.connection_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramClientPingSampleRequest {
        static instance: CMsgSteamDatagramClientPingSampleRequest = CMsgSteamDatagramClientPingSampleRequest {
            connection_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramClientPingSampleRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramClientPingSampleRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramClientPingSampleRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramClientPingSampleRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamDatagramClientPingSampleReply)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramClientPingSampleReply {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleReply.connection_id)
    pub connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleReply.override_active)
    pub override_active: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleReply.pops)
    pub pops: ::std::vec::Vec<cmsg_steam_datagram_client_ping_sample_reply::POP>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleReply.legacy_data_centers)
    pub legacy_data_centers: ::std::vec::Vec<cmsg_steam_datagram_client_ping_sample_reply::LegacyDataCenter>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramClientPingSampleReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramClientPingSampleReply {
    fn default() -> &'a CMsgSteamDatagramClientPingSampleReply {
        <CMsgSteamDatagramClientPingSampleReply as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramClientPingSampleReply {
    pub fn new() -> CMsgSteamDatagramClientPingSampleReply {
        ::std::default::Default::default()
    }

    // optional fixed32 connection_id = 1;

    pub fn connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }

    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }

    // optional bool override_active = 4;

    pub fn override_active(&self) -> bool {
        self.override_active.unwrap_or(false)
    }

    pub fn clear_override_active(&mut self) {
        self.override_active = ::std::option::Option::None;
    }

    pub fn has_override_active(&self) -> bool {
        self.override_active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_override_active(&mut self, v: bool) {
        self.override_active = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "connection_id",
            |m: &CMsgSteamDatagramClientPingSampleReply| { &m.connection_id },
            |m: &mut CMsgSteamDatagramClientPingSampleReply| { &mut m.connection_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "override_active",
            |m: &CMsgSteamDatagramClientPingSampleReply| { &m.override_active },
            |m: &mut CMsgSteamDatagramClientPingSampleReply| { &mut m.override_active },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pops",
            |m: &CMsgSteamDatagramClientPingSampleReply| { &m.pops },
            |m: &mut CMsgSteamDatagramClientPingSampleReply| { &mut m.pops },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "legacy_data_centers",
            |m: &CMsgSteamDatagramClientPingSampleReply| { &m.legacy_data_centers },
            |m: &mut CMsgSteamDatagramClientPingSampleReply| { &mut m.legacy_data_centers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramClientPingSampleReply>(
            "CMsgSteamDatagramClientPingSampleReply",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramClientPingSampleReply {
    const NAME: &'static str = "CMsgSteamDatagramClientPingSampleReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                32 => {
                    self.override_active = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    self.pops.push(is.read_message()?);
                },
                26 => {
                    self.legacy_data_centers.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.override_active {
            my_size += 1 + 1;
        }
        for value in &self.pops {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.legacy_data_centers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.override_active {
            os.write_bool(4, v)?;
        }
        for v in &self.pops {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.legacy_data_centers {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramClientPingSampleReply {
        CMsgSteamDatagramClientPingSampleReply::new()
    }

    fn clear(&mut self) {
        self.connection_id = ::std::option::Option::None;
        self.override_active = ::std::option::Option::None;
        self.pops.clear();
        self.legacy_data_centers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramClientPingSampleReply {
        static instance: CMsgSteamDatagramClientPingSampleReply = CMsgSteamDatagramClientPingSampleReply {
            connection_id: ::std::option::Option::None,
            override_active: ::std::option::Option::None,
            pops: ::std::vec::Vec::new(),
            legacy_data_centers: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramClientPingSampleReply {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramClientPingSampleReply").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramClientPingSampleReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramClientPingSampleReply {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSteamDatagramClientPingSampleReply`
pub mod cmsg_steam_datagram_client_ping_sample_reply {
    // @@protoc_insertion_point(message:CMsgSteamDatagramClientPingSampleReply.POP)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct POP {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleReply.POP.pop_id)
        pub pop_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleReply.POP.default_front_ping_ms)
        pub default_front_ping_ms: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleReply.POP.cluster_penalty)
        pub cluster_penalty: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleReply.POP.alt_addresses)
        pub alt_addresses: ::std::vec::Vec<pop::AltAddress>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleReply.POP.default_e2e_ping_ms)
        pub default_e2e_ping_ms: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleReply.POP.default_e2e_score)
        pub default_e2e_score: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleReply.POP.p2p_via_peer_relay_pop_id)
        pub p2p_via_peer_relay_pop_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleReply.POP.best_dc_ping_ms)
        pub best_dc_ping_ms: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleReply.POP.best_dc_score)
        pub best_dc_score: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleReply.POP.best_dc_via_relay_pop_id)
        pub best_dc_via_relay_pop_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleReply.POP.default_dc_ping_ms)
        pub default_dc_ping_ms: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleReply.POP.default_dc_score)
        pub default_dc_score: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleReply.POP.default_dc_via_relay_pop_id)
        pub default_dc_via_relay_pop_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleReply.POP.test_dc_ping_ms)
        pub test_dc_ping_ms: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleReply.POP.test_dc_score)
        pub test_dc_score: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleReply.POP.test_dc_via_relay_pop_id)
        pub test_dc_via_relay_pop_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamDatagramClientPingSampleReply.POP.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a POP {
        fn default() -> &'a POP {
            <POP as ::protobuf::Message>::default_instance()
        }
    }

    impl POP {
        pub fn new() -> POP {
            ::std::default::Default::default()
        }

        // optional fixed32 pop_id = 1;

        pub fn pop_id(&self) -> u32 {
            self.pop_id.unwrap_or(0)
        }

        pub fn clear_pop_id(&mut self) {
            self.pop_id = ::std::option::Option::None;
        }

        pub fn has_pop_id(&self) -> bool {
            self.pop_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pop_id(&mut self, v: u32) {
            self.pop_id = ::std::option::Option::Some(v);
        }

        // optional uint32 default_front_ping_ms = 2;

        pub fn default_front_ping_ms(&self) -> u32 {
            self.default_front_ping_ms.unwrap_or(0)
        }

        pub fn clear_default_front_ping_ms(&mut self) {
            self.default_front_ping_ms = ::std::option::Option::None;
        }

        pub fn has_default_front_ping_ms(&self) -> bool {
            self.default_front_ping_ms.is_some()
        }

        // Param is passed by value, moved
        pub fn set_default_front_ping_ms(&mut self, v: u32) {
            self.default_front_ping_ms = ::std::option::Option::Some(v);
        }

        // optional uint32 cluster_penalty = 4;

        pub fn cluster_penalty(&self) -> u32 {
            self.cluster_penalty.unwrap_or(0)
        }

        pub fn clear_cluster_penalty(&mut self) {
            self.cluster_penalty = ::std::option::Option::None;
        }

        pub fn has_cluster_penalty(&self) -> bool {
            self.cluster_penalty.is_some()
        }

        // Param is passed by value, moved
        pub fn set_cluster_penalty(&mut self, v: u32) {
            self.cluster_penalty = ::std::option::Option::Some(v);
        }

        // optional uint32 default_e2e_ping_ms = 3;

        pub fn default_e2e_ping_ms(&self) -> u32 {
            self.default_e2e_ping_ms.unwrap_or(0)
        }

        pub fn clear_default_e2e_ping_ms(&mut self) {
            self.default_e2e_ping_ms = ::std::option::Option::None;
        }

        pub fn has_default_e2e_ping_ms(&self) -> bool {
            self.default_e2e_ping_ms.is_some()
        }

        // Param is passed by value, moved
        pub fn set_default_e2e_ping_ms(&mut self, v: u32) {
            self.default_e2e_ping_ms = ::std::option::Option::Some(v);
        }

        // optional uint32 default_e2e_score = 5;

        pub fn default_e2e_score(&self) -> u32 {
            self.default_e2e_score.unwrap_or(0)
        }

        pub fn clear_default_e2e_score(&mut self) {
            self.default_e2e_score = ::std::option::Option::None;
        }

        pub fn has_default_e2e_score(&self) -> bool {
            self.default_e2e_score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_default_e2e_score(&mut self, v: u32) {
            self.default_e2e_score = ::std::option::Option::Some(v);
        }

        // optional fixed32 p2p_via_peer_relay_pop_id = 6;

        pub fn p2p_via_peer_relay_pop_id(&self) -> u32 {
            self.p2p_via_peer_relay_pop_id.unwrap_or(0)
        }

        pub fn clear_p2p_via_peer_relay_pop_id(&mut self) {
            self.p2p_via_peer_relay_pop_id = ::std::option::Option::None;
        }

        pub fn has_p2p_via_peer_relay_pop_id(&self) -> bool {
            self.p2p_via_peer_relay_pop_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_p2p_via_peer_relay_pop_id(&mut self, v: u32) {
            self.p2p_via_peer_relay_pop_id = ::std::option::Option::Some(v);
        }

        // optional uint32 best_dc_ping_ms = 9;

        pub fn best_dc_ping_ms(&self) -> u32 {
            self.best_dc_ping_ms.unwrap_or(0)
        }

        pub fn clear_best_dc_ping_ms(&mut self) {
            self.best_dc_ping_ms = ::std::option::Option::None;
        }

        pub fn has_best_dc_ping_ms(&self) -> bool {
            self.best_dc_ping_ms.is_some()
        }

        // Param is passed by value, moved
        pub fn set_best_dc_ping_ms(&mut self, v: u32) {
            self.best_dc_ping_ms = ::std::option::Option::Some(v);
        }

        // optional uint32 best_dc_score = 10;

        pub fn best_dc_score(&self) -> u32 {
            self.best_dc_score.unwrap_or(0)
        }

        pub fn clear_best_dc_score(&mut self) {
            self.best_dc_score = ::std::option::Option::None;
        }

        pub fn has_best_dc_score(&self) -> bool {
            self.best_dc_score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_best_dc_score(&mut self, v: u32) {
            self.best_dc_score = ::std::option::Option::Some(v);
        }

        // optional fixed32 best_dc_via_relay_pop_id = 11;

        pub fn best_dc_via_relay_pop_id(&self) -> u32 {
            self.best_dc_via_relay_pop_id.unwrap_or(0)
        }

        pub fn clear_best_dc_via_relay_pop_id(&mut self) {
            self.best_dc_via_relay_pop_id = ::std::option::Option::None;
        }

        pub fn has_best_dc_via_relay_pop_id(&self) -> bool {
            self.best_dc_via_relay_pop_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_best_dc_via_relay_pop_id(&mut self, v: u32) {
            self.best_dc_via_relay_pop_id = ::std::option::Option::Some(v);
        }

        // optional uint32 default_dc_ping_ms = 12;

        pub fn default_dc_ping_ms(&self) -> u32 {
            self.default_dc_ping_ms.unwrap_or(0)
        }

        pub fn clear_default_dc_ping_ms(&mut self) {
            self.default_dc_ping_ms = ::std::option::Option::None;
        }

        pub fn has_default_dc_ping_ms(&self) -> bool {
            self.default_dc_ping_ms.is_some()
        }

        // Param is passed by value, moved
        pub fn set_default_dc_ping_ms(&mut self, v: u32) {
            self.default_dc_ping_ms = ::std::option::Option::Some(v);
        }

        // optional uint32 default_dc_score = 13;

        pub fn default_dc_score(&self) -> u32 {
            self.default_dc_score.unwrap_or(0)
        }

        pub fn clear_default_dc_score(&mut self) {
            self.default_dc_score = ::std::option::Option::None;
        }

        pub fn has_default_dc_score(&self) -> bool {
            self.default_dc_score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_default_dc_score(&mut self, v: u32) {
            self.default_dc_score = ::std::option::Option::Some(v);
        }

        // optional fixed32 default_dc_via_relay_pop_id = 14;

        pub fn default_dc_via_relay_pop_id(&self) -> u32 {
            self.default_dc_via_relay_pop_id.unwrap_or(0)
        }

        pub fn clear_default_dc_via_relay_pop_id(&mut self) {
            self.default_dc_via_relay_pop_id = ::std::option::Option::None;
        }

        pub fn has_default_dc_via_relay_pop_id(&self) -> bool {
            self.default_dc_via_relay_pop_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_default_dc_via_relay_pop_id(&mut self, v: u32) {
            self.default_dc_via_relay_pop_id = ::std::option::Option::Some(v);
        }

        // optional uint32 test_dc_ping_ms = 15;

        pub fn test_dc_ping_ms(&self) -> u32 {
            self.test_dc_ping_ms.unwrap_or(0)
        }

        pub fn clear_test_dc_ping_ms(&mut self) {
            self.test_dc_ping_ms = ::std::option::Option::None;
        }

        pub fn has_test_dc_ping_ms(&self) -> bool {
            self.test_dc_ping_ms.is_some()
        }

        // Param is passed by value, moved
        pub fn set_test_dc_ping_ms(&mut self, v: u32) {
            self.test_dc_ping_ms = ::std::option::Option::Some(v);
        }

        // optional uint32 test_dc_score = 16;

        pub fn test_dc_score(&self) -> u32 {
            self.test_dc_score.unwrap_or(0)
        }

        pub fn clear_test_dc_score(&mut self) {
            self.test_dc_score = ::std::option::Option::None;
        }

        pub fn has_test_dc_score(&self) -> bool {
            self.test_dc_score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_test_dc_score(&mut self, v: u32) {
            self.test_dc_score = ::std::option::Option::Some(v);
        }

        // optional fixed32 test_dc_via_relay_pop_id = 17;

        pub fn test_dc_via_relay_pop_id(&self) -> u32 {
            self.test_dc_via_relay_pop_id.unwrap_or(0)
        }

        pub fn clear_test_dc_via_relay_pop_id(&mut self) {
            self.test_dc_via_relay_pop_id = ::std::option::Option::None;
        }

        pub fn has_test_dc_via_relay_pop_id(&self) -> bool {
            self.test_dc_via_relay_pop_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_test_dc_via_relay_pop_id(&mut self, v: u32) {
            self.test_dc_via_relay_pop_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(16);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "pop_id",
                |m: &POP| { &m.pop_id },
                |m: &mut POP| { &mut m.pop_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "default_front_ping_ms",
                |m: &POP| { &m.default_front_ping_ms },
                |m: &mut POP| { &mut m.default_front_ping_ms },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "cluster_penalty",
                |m: &POP| { &m.cluster_penalty },
                |m: &mut POP| { &mut m.cluster_penalty },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "alt_addresses",
                |m: &POP| { &m.alt_addresses },
                |m: &mut POP| { &mut m.alt_addresses },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "default_e2e_ping_ms",
                |m: &POP| { &m.default_e2e_ping_ms },
                |m: &mut POP| { &mut m.default_e2e_ping_ms },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "default_e2e_score",
                |m: &POP| { &m.default_e2e_score },
                |m: &mut POP| { &mut m.default_e2e_score },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "p2p_via_peer_relay_pop_id",
                |m: &POP| { &m.p2p_via_peer_relay_pop_id },
                |m: &mut POP| { &mut m.p2p_via_peer_relay_pop_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "best_dc_ping_ms",
                |m: &POP| { &m.best_dc_ping_ms },
                |m: &mut POP| { &mut m.best_dc_ping_ms },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "best_dc_score",
                |m: &POP| { &m.best_dc_score },
                |m: &mut POP| { &mut m.best_dc_score },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "best_dc_via_relay_pop_id",
                |m: &POP| { &m.best_dc_via_relay_pop_id },
                |m: &mut POP| { &mut m.best_dc_via_relay_pop_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "default_dc_ping_ms",
                |m: &POP| { &m.default_dc_ping_ms },
                |m: &mut POP| { &mut m.default_dc_ping_ms },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "default_dc_score",
                |m: &POP| { &m.default_dc_score },
                |m: &mut POP| { &mut m.default_dc_score },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "default_dc_via_relay_pop_id",
                |m: &POP| { &m.default_dc_via_relay_pop_id },
                |m: &mut POP| { &mut m.default_dc_via_relay_pop_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "test_dc_ping_ms",
                |m: &POP| { &m.test_dc_ping_ms },
                |m: &mut POP| { &mut m.test_dc_ping_ms },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "test_dc_score",
                |m: &POP| { &m.test_dc_score },
                |m: &mut POP| { &mut m.test_dc_score },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "test_dc_via_relay_pop_id",
                |m: &POP| { &m.test_dc_via_relay_pop_id },
                |m: &mut POP| { &mut m.test_dc_via_relay_pop_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<POP>(
                "CMsgSteamDatagramClientPingSampleReply.POP",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for POP {
        const NAME: &'static str = "POP";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.pop_id = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    16 => {
                        self.default_front_ping_ms = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.cluster_penalty = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    58 => {
                        self.alt_addresses.push(is.read_message()?);
                    },
                    24 => {
                        self.default_e2e_ping_ms = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.default_e2e_score = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    53 => {
                        self.p2p_via_peer_relay_pop_id = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    72 => {
                        self.best_dc_ping_ms = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.best_dc_score = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    93 => {
                        self.best_dc_via_relay_pop_id = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    96 => {
                        self.default_dc_ping_ms = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    104 => {
                        self.default_dc_score = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    117 => {
                        self.default_dc_via_relay_pop_id = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    120 => {
                        self.test_dc_ping_ms = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    128 => {
                        self.test_dc_score = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    141 => {
                        self.test_dc_via_relay_pop_id = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.pop_id {
                my_size += 1 + 4;
            }
            if let Some(v) = self.default_front_ping_ms {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.cluster_penalty {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            for value in &self.alt_addresses {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.default_e2e_ping_ms {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.default_e2e_score {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.p2p_via_peer_relay_pop_id {
                my_size += 1 + 4;
            }
            if let Some(v) = self.best_dc_ping_ms {
                my_size += ::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.best_dc_score {
                my_size += ::protobuf::rt::uint32_size(10, v);
            }
            if let Some(v) = self.best_dc_via_relay_pop_id {
                my_size += 1 + 4;
            }
            if let Some(v) = self.default_dc_ping_ms {
                my_size += ::protobuf::rt::uint32_size(12, v);
            }
            if let Some(v) = self.default_dc_score {
                my_size += ::protobuf::rt::uint32_size(13, v);
            }
            if let Some(v) = self.default_dc_via_relay_pop_id {
                my_size += 1 + 4;
            }
            if let Some(v) = self.test_dc_ping_ms {
                my_size += ::protobuf::rt::uint32_size(15, v);
            }
            if let Some(v) = self.test_dc_score {
                my_size += ::protobuf::rt::uint32_size(16, v);
            }
            if let Some(v) = self.test_dc_via_relay_pop_id {
                my_size += 2 + 4;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.pop_id {
                os.write_fixed32(1, v)?;
            }
            if let Some(v) = self.default_front_ping_ms {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.cluster_penalty {
                os.write_uint32(4, v)?;
            }
            for v in &self.alt_addresses {
                ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
            };
            if let Some(v) = self.default_e2e_ping_ms {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.default_e2e_score {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.p2p_via_peer_relay_pop_id {
                os.write_fixed32(6, v)?;
            }
            if let Some(v) = self.best_dc_ping_ms {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.best_dc_score {
                os.write_uint32(10, v)?;
            }
            if let Some(v) = self.best_dc_via_relay_pop_id {
                os.write_fixed32(11, v)?;
            }
            if let Some(v) = self.default_dc_ping_ms {
                os.write_uint32(12, v)?;
            }
            if let Some(v) = self.default_dc_score {
                os.write_uint32(13, v)?;
            }
            if let Some(v) = self.default_dc_via_relay_pop_id {
                os.write_fixed32(14, v)?;
            }
            if let Some(v) = self.test_dc_ping_ms {
                os.write_uint32(15, v)?;
            }
            if let Some(v) = self.test_dc_score {
                os.write_uint32(16, v)?;
            }
            if let Some(v) = self.test_dc_via_relay_pop_id {
                os.write_fixed32(17, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> POP {
            POP::new()
        }

        fn clear(&mut self) {
            self.pop_id = ::std::option::Option::None;
            self.default_front_ping_ms = ::std::option::Option::None;
            self.cluster_penalty = ::std::option::Option::None;
            self.alt_addresses.clear();
            self.default_e2e_ping_ms = ::std::option::Option::None;
            self.default_e2e_score = ::std::option::Option::None;
            self.p2p_via_peer_relay_pop_id = ::std::option::Option::None;
            self.best_dc_ping_ms = ::std::option::Option::None;
            self.best_dc_score = ::std::option::Option::None;
            self.best_dc_via_relay_pop_id = ::std::option::Option::None;
            self.default_dc_ping_ms = ::std::option::Option::None;
            self.default_dc_score = ::std::option::Option::None;
            self.default_dc_via_relay_pop_id = ::std::option::Option::None;
            self.test_dc_ping_ms = ::std::option::Option::None;
            self.test_dc_score = ::std::option::Option::None;
            self.test_dc_via_relay_pop_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static POP {
            static instance: POP = POP {
                pop_id: ::std::option::Option::None,
                default_front_ping_ms: ::std::option::Option::None,
                cluster_penalty: ::std::option::Option::None,
                alt_addresses: ::std::vec::Vec::new(),
                default_e2e_ping_ms: ::std::option::Option::None,
                default_e2e_score: ::std::option::Option::None,
                p2p_via_peer_relay_pop_id: ::std::option::Option::None,
                best_dc_ping_ms: ::std::option::Option::None,
                best_dc_score: ::std::option::Option::None,
                best_dc_via_relay_pop_id: ::std::option::Option::None,
                default_dc_ping_ms: ::std::option::Option::None,
                default_dc_score: ::std::option::Option::None,
                default_dc_via_relay_pop_id: ::std::option::Option::None,
                test_dc_ping_ms: ::std::option::Option::None,
                test_dc_score: ::std::option::Option::None,
                test_dc_via_relay_pop_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for POP {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSteamDatagramClientPingSampleReply.POP").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for POP {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for POP {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `POP`
    pub mod pop {
        // @@protoc_insertion_point(message:CMsgSteamDatagramClientPingSampleReply.POP.AltAddress)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct AltAddress {
            // message fields
            // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleReply.POP.AltAddress.id)
            pub id: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleReply.POP.AltAddress.front_ping_ms)
            pub front_ping_ms: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleReply.POP.AltAddress.penalty)
            pub penalty: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgSteamDatagramClientPingSampleReply.POP.AltAddress.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a AltAddress {
            fn default() -> &'a AltAddress {
                <AltAddress as ::protobuf::Message>::default_instance()
            }
        }

        impl AltAddress {
            pub fn new() -> AltAddress {
                ::std::default::Default::default()
            }

            // optional string id = 1;

            pub fn id(&self) -> &str {
                match self.id.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_id(&mut self) {
                self.id = ::std::option::Option::None;
            }

            pub fn has_id(&self) -> bool {
                self.id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_id(&mut self, v: ::std::string::String) {
                self.id = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_id(&mut self) -> &mut ::std::string::String {
                if self.id.is_none() {
                    self.id = ::std::option::Option::Some(::std::string::String::new());
                }
                self.id.as_mut().unwrap()
            }

            // Take field
            pub fn take_id(&mut self) -> ::std::string::String {
                self.id.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional uint32 front_ping_ms = 2;

            pub fn front_ping_ms(&self) -> u32 {
                self.front_ping_ms.unwrap_or(0)
            }

            pub fn clear_front_ping_ms(&mut self) {
                self.front_ping_ms = ::std::option::Option::None;
            }

            pub fn has_front_ping_ms(&self) -> bool {
                self.front_ping_ms.is_some()
            }

            // Param is passed by value, moved
            pub fn set_front_ping_ms(&mut self, v: u32) {
                self.front_ping_ms = ::std::option::Option::Some(v);
            }

            // optional uint32 penalty = 3;

            pub fn penalty(&self) -> u32 {
                self.penalty.unwrap_or(0)
            }

            pub fn clear_penalty(&mut self) {
                self.penalty = ::std::option::Option::None;
            }

            pub fn has_penalty(&self) -> bool {
                self.penalty.is_some()
            }

            // Param is passed by value, moved
            pub fn set_penalty(&mut self, v: u32) {
                self.penalty = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "id",
                    |m: &AltAddress| { &m.id },
                    |m: &mut AltAddress| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "front_ping_ms",
                    |m: &AltAddress| { &m.front_ping_ms },
                    |m: &mut AltAddress| { &mut m.front_ping_ms },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "penalty",
                    |m: &AltAddress| { &m.penalty },
                    |m: &mut AltAddress| { &mut m.penalty },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AltAddress>(
                    "CMsgSteamDatagramClientPingSampleReply.POP.AltAddress",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for AltAddress {
            const NAME: &'static str = "AltAddress";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.id = ::std::option::Option::Some(is.read_string()?);
                        },
                        16 => {
                            self.front_ping_ms = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        24 => {
                            self.penalty = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.id.as_ref() {
                    my_size += ::protobuf::rt::string_size(1, &v);
                }
                if let Some(v) = self.front_ping_ms {
                    my_size += ::protobuf::rt::uint32_size(2, v);
                }
                if let Some(v) = self.penalty {
                    my_size += ::protobuf::rt::uint32_size(3, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.id.as_ref() {
                    os.write_string(1, v)?;
                }
                if let Some(v) = self.front_ping_ms {
                    os.write_uint32(2, v)?;
                }
                if let Some(v) = self.penalty {
                    os.write_uint32(3, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> AltAddress {
                AltAddress::new()
            }

            fn clear(&mut self) {
                self.id = ::std::option::Option::None;
                self.front_ping_ms = ::std::option::Option::None;
                self.penalty = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static AltAddress {
                static instance: AltAddress = AltAddress {
                    id: ::std::option::Option::None,
                    front_ping_ms: ::std::option::Option::None,
                    penalty: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for AltAddress {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CMsgSteamDatagramClientPingSampleReply.POP.AltAddress").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for AltAddress {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for AltAddress {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:CMsgSteamDatagramClientPingSampleReply.LegacyDataCenter)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LegacyDataCenter {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleReply.LegacyDataCenter.data_center_id)
        pub data_center_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleReply.LegacyDataCenter.best_dc_via_relay_pop_id)
        pub best_dc_via_relay_pop_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleReply.LegacyDataCenter.best_dc_ping_ms)
        pub best_dc_ping_ms: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamDatagramClientPingSampleReply.LegacyDataCenter.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LegacyDataCenter {
        fn default() -> &'a LegacyDataCenter {
            <LegacyDataCenter as ::protobuf::Message>::default_instance()
        }
    }

    impl LegacyDataCenter {
        pub fn new() -> LegacyDataCenter {
            ::std::default::Default::default()
        }

        // optional fixed32 data_center_id = 1;

        pub fn data_center_id(&self) -> u32 {
            self.data_center_id.unwrap_or(0)
        }

        pub fn clear_data_center_id(&mut self) {
            self.data_center_id = ::std::option::Option::None;
        }

        pub fn has_data_center_id(&self) -> bool {
            self.data_center_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data_center_id(&mut self, v: u32) {
            self.data_center_id = ::std::option::Option::Some(v);
        }

        // optional fixed32 best_dc_via_relay_pop_id = 2;

        pub fn best_dc_via_relay_pop_id(&self) -> u32 {
            self.best_dc_via_relay_pop_id.unwrap_or(0)
        }

        pub fn clear_best_dc_via_relay_pop_id(&mut self) {
            self.best_dc_via_relay_pop_id = ::std::option::Option::None;
        }

        pub fn has_best_dc_via_relay_pop_id(&self) -> bool {
            self.best_dc_via_relay_pop_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_best_dc_via_relay_pop_id(&mut self, v: u32) {
            self.best_dc_via_relay_pop_id = ::std::option::Option::Some(v);
        }

        // optional uint32 best_dc_ping_ms = 3;

        pub fn best_dc_ping_ms(&self) -> u32 {
            self.best_dc_ping_ms.unwrap_or(0)
        }

        pub fn clear_best_dc_ping_ms(&mut self) {
            self.best_dc_ping_ms = ::std::option::Option::None;
        }

        pub fn has_best_dc_ping_ms(&self) -> bool {
            self.best_dc_ping_ms.is_some()
        }

        // Param is passed by value, moved
        pub fn set_best_dc_ping_ms(&mut self, v: u32) {
            self.best_dc_ping_ms = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "data_center_id",
                |m: &LegacyDataCenter| { &m.data_center_id },
                |m: &mut LegacyDataCenter| { &mut m.data_center_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "best_dc_via_relay_pop_id",
                |m: &LegacyDataCenter| { &m.best_dc_via_relay_pop_id },
                |m: &mut LegacyDataCenter| { &mut m.best_dc_via_relay_pop_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "best_dc_ping_ms",
                |m: &LegacyDataCenter| { &m.best_dc_ping_ms },
                |m: &mut LegacyDataCenter| { &mut m.best_dc_ping_ms },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LegacyDataCenter>(
                "CMsgSteamDatagramClientPingSampleReply.LegacyDataCenter",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for LegacyDataCenter {
        const NAME: &'static str = "LegacyDataCenter";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.data_center_id = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    21 => {
                        self.best_dc_via_relay_pop_id = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    24 => {
                        self.best_dc_ping_ms = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data_center_id {
                my_size += 1 + 4;
            }
            if let Some(v) = self.best_dc_via_relay_pop_id {
                my_size += 1 + 4;
            }
            if let Some(v) = self.best_dc_ping_ms {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data_center_id {
                os.write_fixed32(1, v)?;
            }
            if let Some(v) = self.best_dc_via_relay_pop_id {
                os.write_fixed32(2, v)?;
            }
            if let Some(v) = self.best_dc_ping_ms {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LegacyDataCenter {
            LegacyDataCenter::new()
        }

        fn clear(&mut self) {
            self.data_center_id = ::std::option::Option::None;
            self.best_dc_via_relay_pop_id = ::std::option::Option::None;
            self.best_dc_ping_ms = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LegacyDataCenter {
            static instance: LegacyDataCenter = LegacyDataCenter {
                data_center_id: ::std::option::Option::None,
                best_dc_via_relay_pop_id: ::std::option::Option::None,
                best_dc_ping_ms: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for LegacyDataCenter {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSteamDatagramClientPingSampleReply.LegacyDataCenter").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for LegacyDataCenter {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for LegacyDataCenter {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramClientSwitchedPrimary)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramClientSwitchedPrimary {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.connection_id)
    pub connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.from_ip)
    pub from_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.from_port)
    pub from_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.from_router_cluster)
    pub from_router_cluster: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.from_active_time)
    pub from_active_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.from_active_packets_recv)
    pub from_active_packets_recv: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.from_dropped_reason)
    pub from_dropped_reason: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.gap_ms)
    pub gap_ms: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.from_quality_now)
    pub from_quality_now: ::protobuf::MessageField<cmsg_steam_datagram_client_switched_primary::RouterQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.to_quality_now)
    pub to_quality_now: ::protobuf::MessageField<cmsg_steam_datagram_client_switched_primary::RouterQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.from_quality_then)
    pub from_quality_then: ::protobuf::MessageField<cmsg_steam_datagram_client_switched_primary::RouterQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.to_quality_then)
    pub to_quality_then: ::protobuf::MessageField<cmsg_steam_datagram_client_switched_primary::RouterQuality>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramClientSwitchedPrimary.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramClientSwitchedPrimary {
    fn default() -> &'a CMsgSteamDatagramClientSwitchedPrimary {
        <CMsgSteamDatagramClientSwitchedPrimary as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramClientSwitchedPrimary {
    pub fn new() -> CMsgSteamDatagramClientSwitchedPrimary {
        ::std::default::Default::default()
    }

    // optional fixed32 connection_id = 1;

    pub fn connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }

    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 from_ip = 2;

    pub fn from_ip(&self) -> u32 {
        self.from_ip.unwrap_or(0)
    }

    pub fn clear_from_ip(&mut self) {
        self.from_ip = ::std::option::Option::None;
    }

    pub fn has_from_ip(&self) -> bool {
        self.from_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_ip(&mut self, v: u32) {
        self.from_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 from_port = 3;

    pub fn from_port(&self) -> u32 {
        self.from_port.unwrap_or(0)
    }

    pub fn clear_from_port(&mut self) {
        self.from_port = ::std::option::Option::None;
    }

    pub fn has_from_port(&self) -> bool {
        self.from_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_port(&mut self, v: u32) {
        self.from_port = ::std::option::Option::Some(v);
    }

    // optional fixed32 from_router_cluster = 4;

    pub fn from_router_cluster(&self) -> u32 {
        self.from_router_cluster.unwrap_or(0)
    }

    pub fn clear_from_router_cluster(&mut self) {
        self.from_router_cluster = ::std::option::Option::None;
    }

    pub fn has_from_router_cluster(&self) -> bool {
        self.from_router_cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_router_cluster(&mut self, v: u32) {
        self.from_router_cluster = ::std::option::Option::Some(v);
    }

    // optional uint32 from_active_time = 5;

    pub fn from_active_time(&self) -> u32 {
        self.from_active_time.unwrap_or(0)
    }

    pub fn clear_from_active_time(&mut self) {
        self.from_active_time = ::std::option::Option::None;
    }

    pub fn has_from_active_time(&self) -> bool {
        self.from_active_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_active_time(&mut self, v: u32) {
        self.from_active_time = ::std::option::Option::Some(v);
    }

    // optional uint32 from_active_packets_recv = 6;

    pub fn from_active_packets_recv(&self) -> u32 {
        self.from_active_packets_recv.unwrap_or(0)
    }

    pub fn clear_from_active_packets_recv(&mut self) {
        self.from_active_packets_recv = ::std::option::Option::None;
    }

    pub fn has_from_active_packets_recv(&self) -> bool {
        self.from_active_packets_recv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_active_packets_recv(&mut self, v: u32) {
        self.from_active_packets_recv = ::std::option::Option::Some(v);
    }

    // optional string from_dropped_reason = 7;

    pub fn from_dropped_reason(&self) -> &str {
        match self.from_dropped_reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_from_dropped_reason(&mut self) {
        self.from_dropped_reason = ::std::option::Option::None;
    }

    pub fn has_from_dropped_reason(&self) -> bool {
        self.from_dropped_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_dropped_reason(&mut self, v: ::std::string::String) {
        self.from_dropped_reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from_dropped_reason(&mut self) -> &mut ::std::string::String {
        if self.from_dropped_reason.is_none() {
            self.from_dropped_reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.from_dropped_reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_from_dropped_reason(&mut self) -> ::std::string::String {
        self.from_dropped_reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 gap_ms = 8;

    pub fn gap_ms(&self) -> u32 {
        self.gap_ms.unwrap_or(0)
    }

    pub fn clear_gap_ms(&mut self) {
        self.gap_ms = ::std::option::Option::None;
    }

    pub fn has_gap_ms(&self) -> bool {
        self.gap_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gap_ms(&mut self, v: u32) {
        self.gap_ms = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "connection_id",
            |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.connection_id },
            |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.connection_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "from_ip",
            |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.from_ip },
            |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.from_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "from_port",
            |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.from_port },
            |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.from_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "from_router_cluster",
            |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.from_router_cluster },
            |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.from_router_cluster },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "from_active_time",
            |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.from_active_time },
            |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.from_active_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "from_active_packets_recv",
            |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.from_active_packets_recv },
            |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.from_active_packets_recv },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "from_dropped_reason",
            |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.from_dropped_reason },
            |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.from_dropped_reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gap_ms",
            |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.gap_ms },
            |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.gap_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_steam_datagram_client_switched_primary::RouterQuality>(
            "from_quality_now",
            |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.from_quality_now },
            |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.from_quality_now },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_steam_datagram_client_switched_primary::RouterQuality>(
            "to_quality_now",
            |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.to_quality_now },
            |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.to_quality_now },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_steam_datagram_client_switched_primary::RouterQuality>(
            "from_quality_then",
            |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.from_quality_then },
            |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.from_quality_then },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_steam_datagram_client_switched_primary::RouterQuality>(
            "to_quality_then",
            |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.to_quality_then },
            |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.to_quality_then },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramClientSwitchedPrimary>(
            "CMsgSteamDatagramClientSwitchedPrimary",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramClientSwitchedPrimary {
    const NAME: &'static str = "CMsgSteamDatagramClientSwitchedPrimary";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                21 => {
                    self.from_ip = ::std::option::Option::Some(is.read_fixed32()?);
                },
                24 => {
                    self.from_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                37 => {
                    self.from_router_cluster = ::std::option::Option::Some(is.read_fixed32()?);
                },
                40 => {
                    self.from_active_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.from_active_packets_recv = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.from_dropped_reason = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.gap_ms = ::std::option::Option::Some(is.read_uint32()?);
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.from_quality_now)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.to_quality_now)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.from_quality_then)?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.to_quality_then)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.from_ip {
            my_size += 1 + 4;
        }
        if let Some(v) = self.from_port {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.from_router_cluster {
            my_size += 1 + 4;
        }
        if let Some(v) = self.from_active_time {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.from_active_packets_recv {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.from_dropped_reason.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.gap_ms {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.from_quality_now.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.to_quality_now.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.from_quality_then.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.to_quality_then.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.from_ip {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.from_port {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.from_router_cluster {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.from_active_time {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.from_active_packets_recv {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.from_dropped_reason.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.gap_ms {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.from_quality_now.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.to_quality_now.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.from_quality_then.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.to_quality_then.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramClientSwitchedPrimary {
        CMsgSteamDatagramClientSwitchedPrimary::new()
    }

    fn clear(&mut self) {
        self.connection_id = ::std::option::Option::None;
        self.from_ip = ::std::option::Option::None;
        self.from_port = ::std::option::Option::None;
        self.from_router_cluster = ::std::option::Option::None;
        self.from_active_time = ::std::option::Option::None;
        self.from_active_packets_recv = ::std::option::Option::None;
        self.from_dropped_reason = ::std::option::Option::None;
        self.gap_ms = ::std::option::Option::None;
        self.from_quality_now.clear();
        self.to_quality_now.clear();
        self.from_quality_then.clear();
        self.to_quality_then.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramClientSwitchedPrimary {
        static instance: CMsgSteamDatagramClientSwitchedPrimary = CMsgSteamDatagramClientSwitchedPrimary {
            connection_id: ::std::option::Option::None,
            from_ip: ::std::option::Option::None,
            from_port: ::std::option::Option::None,
            from_router_cluster: ::std::option::Option::None,
            from_active_time: ::std::option::Option::None,
            from_active_packets_recv: ::std::option::Option::None,
            from_dropped_reason: ::std::option::Option::None,
            gap_ms: ::std::option::Option::None,
            from_quality_now: ::protobuf::MessageField::none(),
            to_quality_now: ::protobuf::MessageField::none(),
            from_quality_then: ::protobuf::MessageField::none(),
            to_quality_then: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramClientSwitchedPrimary {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramClientSwitchedPrimary").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramClientSwitchedPrimary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramClientSwitchedPrimary {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSteamDatagramClientSwitchedPrimary`
pub mod cmsg_steam_datagram_client_switched_primary {
    // @@protoc_insertion_point(message:CMsgSteamDatagramClientSwitchedPrimary.RouterQuality)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RouterQuality {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.RouterQuality.score)
        pub score: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.RouterQuality.front_ping)
        pub front_ping: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.RouterQuality.back_ping)
        pub back_ping: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.RouterQuality.seconds_until_down)
        pub seconds_until_down: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamDatagramClientSwitchedPrimary.RouterQuality.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RouterQuality {
        fn default() -> &'a RouterQuality {
            <RouterQuality as ::protobuf::Message>::default_instance()
        }
    }

    impl RouterQuality {
        pub fn new() -> RouterQuality {
            ::std::default::Default::default()
        }

        // optional uint32 score = 1;

        pub fn score(&self) -> u32 {
            self.score.unwrap_or(0)
        }

        pub fn clear_score(&mut self) {
            self.score = ::std::option::Option::None;
        }

        pub fn has_score(&self) -> bool {
            self.score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score(&mut self, v: u32) {
            self.score = ::std::option::Option::Some(v);
        }

        // optional uint32 front_ping = 2;

        pub fn front_ping(&self) -> u32 {
            self.front_ping.unwrap_or(0)
        }

        pub fn clear_front_ping(&mut self) {
            self.front_ping = ::std::option::Option::None;
        }

        pub fn has_front_ping(&self) -> bool {
            self.front_ping.is_some()
        }

        // Param is passed by value, moved
        pub fn set_front_ping(&mut self, v: u32) {
            self.front_ping = ::std::option::Option::Some(v);
        }

        // optional uint32 back_ping = 3;

        pub fn back_ping(&self) -> u32 {
            self.back_ping.unwrap_or(0)
        }

        pub fn clear_back_ping(&mut self) {
            self.back_ping = ::std::option::Option::None;
        }

        pub fn has_back_ping(&self) -> bool {
            self.back_ping.is_some()
        }

        // Param is passed by value, moved
        pub fn set_back_ping(&mut self, v: u32) {
            self.back_ping = ::std::option::Option::Some(v);
        }

        // optional uint32 seconds_until_down = 4;

        pub fn seconds_until_down(&self) -> u32 {
            self.seconds_until_down.unwrap_or(0)
        }

        pub fn clear_seconds_until_down(&mut self) {
            self.seconds_until_down = ::std::option::Option::None;
        }

        pub fn has_seconds_until_down(&self) -> bool {
            self.seconds_until_down.is_some()
        }

        // Param is passed by value, moved
        pub fn set_seconds_until_down(&mut self, v: u32) {
            self.seconds_until_down = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "score",
                |m: &RouterQuality| { &m.score },
                |m: &mut RouterQuality| { &mut m.score },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "front_ping",
                |m: &RouterQuality| { &m.front_ping },
                |m: &mut RouterQuality| { &mut m.front_ping },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "back_ping",
                |m: &RouterQuality| { &m.back_ping },
                |m: &mut RouterQuality| { &mut m.back_ping },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "seconds_until_down",
                |m: &RouterQuality| { &m.seconds_until_down },
                |m: &mut RouterQuality| { &mut m.seconds_until_down },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RouterQuality>(
                "CMsgSteamDatagramClientSwitchedPrimary.RouterQuality",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RouterQuality {
        const NAME: &'static str = "RouterQuality";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.score = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.front_ping = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.back_ping = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.seconds_until_down = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.score {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.front_ping {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.back_ping {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.seconds_until_down {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.score {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.front_ping {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.back_ping {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.seconds_until_down {
                os.write_uint32(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RouterQuality {
            RouterQuality::new()
        }

        fn clear(&mut self) {
            self.score = ::std::option::Option::None;
            self.front_ping = ::std::option::Option::None;
            self.back_ping = ::std::option::Option::None;
            self.seconds_until_down = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RouterQuality {
            static instance: RouterQuality = RouterQuality {
                score: ::std::option::Option::None,
                front_ping: ::std::option::Option::None,
                back_ping: ::std::option::Option::None,
                seconds_until_down: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RouterQuality {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSteamDatagramClientSwitchedPrimary.RouterQuality").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RouterQuality {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RouterQuality {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramConnectRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramConnectRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectRequest.connection_id)
    pub connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectRequest.my_timestamp)
    pub my_timestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectRequest.ping_est_ms)
    pub ping_est_ms: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectRequest.virtual_port)
    pub virtual_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectRequest.gameserver_relay_session_id)
    pub gameserver_relay_session_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectRequest.crypt)
    pub crypt: ::protobuf::MessageField<super::steamnetworkingsockets_messages::CMsgSteamDatagramSessionCryptInfoSigned>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectRequest.cert)
    pub cert: ::protobuf::MessageField<super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectRequest.routing_secret)
    pub routing_secret: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectRequest.legacy_client_steam_id)
    pub legacy_client_steam_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramConnectRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectRequest {
    fn default() -> &'a CMsgSteamDatagramConnectRequest {
        <CMsgSteamDatagramConnectRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectRequest {
    pub fn new() -> CMsgSteamDatagramConnectRequest {
        ::std::default::Default::default()
    }

    // optional fixed32 connection_id = 1;

    pub fn connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }

    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 my_timestamp = 4;

    pub fn my_timestamp(&self) -> u64 {
        self.my_timestamp.unwrap_or(0)
    }

    pub fn clear_my_timestamp(&mut self) {
        self.my_timestamp = ::std::option::Option::None;
    }

    pub fn has_my_timestamp(&self) -> bool {
        self.my_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_my_timestamp(&mut self, v: u64) {
        self.my_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_est_ms = 5;

    pub fn ping_est_ms(&self) -> u32 {
        self.ping_est_ms.unwrap_or(0)
    }

    pub fn clear_ping_est_ms(&mut self) {
        self.ping_est_ms = ::std::option::Option::None;
    }

    pub fn has_ping_est_ms(&self) -> bool {
        self.ping_est_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_est_ms(&mut self, v: u32) {
        self.ping_est_ms = ::std::option::Option::Some(v);
    }

    // optional uint32 virtual_port = 9;

    pub fn virtual_port(&self) -> u32 {
        self.virtual_port.unwrap_or(0)
    }

    pub fn clear_virtual_port(&mut self) {
        self.virtual_port = ::std::option::Option::None;
    }

    pub fn has_virtual_port(&self) -> bool {
        self.virtual_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_virtual_port(&mut self, v: u32) {
        self.virtual_port = ::std::option::Option::Some(v);
    }

    // optional uint32 gameserver_relay_session_id = 2;

    pub fn gameserver_relay_session_id(&self) -> u32 {
        self.gameserver_relay_session_id.unwrap_or(0)
    }

    pub fn clear_gameserver_relay_session_id(&mut self) {
        self.gameserver_relay_session_id = ::std::option::Option::None;
    }

    pub fn has_gameserver_relay_session_id(&self) -> bool {
        self.gameserver_relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameserver_relay_session_id(&mut self, v: u32) {
        self.gameserver_relay_session_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 routing_secret = 10;

    pub fn routing_secret(&self) -> u64 {
        self.routing_secret.unwrap_or(0)
    }

    pub fn clear_routing_secret(&mut self) {
        self.routing_secret = ::std::option::Option::None;
    }

    pub fn has_routing_secret(&self) -> bool {
        self.routing_secret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_routing_secret(&mut self, v: u64) {
        self.routing_secret = ::std::option::Option::Some(v);
    }

    // optional fixed64 legacy_client_steam_id = 3;

    pub fn legacy_client_steam_id(&self) -> u64 {
        self.legacy_client_steam_id.unwrap_or(0)
    }

    pub fn clear_legacy_client_steam_id(&mut self) {
        self.legacy_client_steam_id = ::std::option::Option::None;
    }

    pub fn has_legacy_client_steam_id(&self) -> bool {
        self.legacy_client_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_client_steam_id(&mut self, v: u64) {
        self.legacy_client_steam_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "connection_id",
            |m: &CMsgSteamDatagramConnectRequest| { &m.connection_id },
            |m: &mut CMsgSteamDatagramConnectRequest| { &mut m.connection_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "my_timestamp",
            |m: &CMsgSteamDatagramConnectRequest| { &m.my_timestamp },
            |m: &mut CMsgSteamDatagramConnectRequest| { &mut m.my_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ping_est_ms",
            |m: &CMsgSteamDatagramConnectRequest| { &m.ping_est_ms },
            |m: &mut CMsgSteamDatagramConnectRequest| { &mut m.ping_est_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "virtual_port",
            |m: &CMsgSteamDatagramConnectRequest| { &m.virtual_port },
            |m: &mut CMsgSteamDatagramConnectRequest| { &mut m.virtual_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gameserver_relay_session_id",
            |m: &CMsgSteamDatagramConnectRequest| { &m.gameserver_relay_session_id },
            |m: &mut CMsgSteamDatagramConnectRequest| { &mut m.gameserver_relay_session_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steamnetworkingsockets_messages::CMsgSteamDatagramSessionCryptInfoSigned>(
            "crypt",
            |m: &CMsgSteamDatagramConnectRequest| { &m.crypt },
            |m: &mut CMsgSteamDatagramConnectRequest| { &mut m.crypt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned>(
            "cert",
            |m: &CMsgSteamDatagramConnectRequest| { &m.cert },
            |m: &mut CMsgSteamDatagramConnectRequest| { &mut m.cert },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "routing_secret",
            |m: &CMsgSteamDatagramConnectRequest| { &m.routing_secret },
            |m: &mut CMsgSteamDatagramConnectRequest| { &mut m.routing_secret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "legacy_client_steam_id",
            |m: &CMsgSteamDatagramConnectRequest| { &m.legacy_client_steam_id },
            |m: &mut CMsgSteamDatagramConnectRequest| { &mut m.legacy_client_steam_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramConnectRequest>(
            "CMsgSteamDatagramConnectRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramConnectRequest {
    const NAME: &'static str = "CMsgSteamDatagramConnectRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                33 => {
                    self.my_timestamp = ::std::option::Option::Some(is.read_fixed64()?);
                },
                40 => {
                    self.ping_est_ms = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.virtual_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.gameserver_relay_session_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.crypt)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cert)?;
                },
                81 => {
                    self.routing_secret = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.legacy_client_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.my_timestamp {
            my_size += 1 + 8;
        }
        if let Some(v) = self.ping_est_ms {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.virtual_port {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.gameserver_relay_session_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.crypt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.cert.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.routing_secret {
            my_size += 1 + 8;
        }
        if let Some(v) = self.legacy_client_steam_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.my_timestamp {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.ping_est_ms {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.virtual_port {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.gameserver_relay_session_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.crypt.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.cert.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.routing_secret {
            os.write_fixed64(10, v)?;
        }
        if let Some(v) = self.legacy_client_steam_id {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramConnectRequest {
        CMsgSteamDatagramConnectRequest::new()
    }

    fn clear(&mut self) {
        self.connection_id = ::std::option::Option::None;
        self.my_timestamp = ::std::option::Option::None;
        self.ping_est_ms = ::std::option::Option::None;
        self.virtual_port = ::std::option::Option::None;
        self.gameserver_relay_session_id = ::std::option::Option::None;
        self.crypt.clear();
        self.cert.clear();
        self.routing_secret = ::std::option::Option::None;
        self.legacy_client_steam_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectRequest {
        static instance: CMsgSteamDatagramConnectRequest = CMsgSteamDatagramConnectRequest {
            connection_id: ::std::option::Option::None,
            my_timestamp: ::std::option::Option::None,
            ping_est_ms: ::std::option::Option::None,
            virtual_port: ::std::option::Option::None,
            gameserver_relay_session_id: ::std::option::Option::None,
            crypt: ::protobuf::MessageField::none(),
            cert: ::protobuf::MessageField::none(),
            routing_secret: ::std::option::Option::None,
            legacy_client_steam_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramConnectRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramConnectRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramConnectRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamDatagramConnectOK)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramConnectOK {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectOK.client_connection_id)
    pub client_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectOK.server_connection_id)
    pub server_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectOK.your_timestamp)
    pub your_timestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectOK.delay_time_usec)
    pub delay_time_usec: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectOK.gameserver_relay_session_id)
    pub gameserver_relay_session_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectOK.crypt)
    pub crypt: ::protobuf::MessageField<super::steamnetworkingsockets_messages::CMsgSteamDatagramSessionCryptInfoSigned>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectOK.cert)
    pub cert: ::protobuf::MessageField<super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramConnectOK.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectOK {
    fn default() -> &'a CMsgSteamDatagramConnectOK {
        <CMsgSteamDatagramConnectOK as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectOK {
    pub fn new() -> CMsgSteamDatagramConnectOK {
        ::std::default::Default::default()
    }

    // optional fixed32 client_connection_id = 1;

    pub fn client_connection_id(&self) -> u32 {
        self.client_connection_id.unwrap_or(0)
    }

    pub fn clear_client_connection_id(&mut self) {
        self.client_connection_id = ::std::option::Option::None;
    }

    pub fn has_client_connection_id(&self) -> bool {
        self.client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_connection_id(&mut self, v: u32) {
        self.client_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 server_connection_id = 7;

    pub fn server_connection_id(&self) -> u32 {
        self.server_connection_id.unwrap_or(0)
    }

    pub fn clear_server_connection_id(&mut self) {
        self.server_connection_id = ::std::option::Option::None;
    }

    pub fn has_server_connection_id(&self) -> bool {
        self.server_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_connection_id(&mut self, v: u32) {
        self.server_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 your_timestamp = 3;

    pub fn your_timestamp(&self) -> u64 {
        self.your_timestamp.unwrap_or(0)
    }

    pub fn clear_your_timestamp(&mut self) {
        self.your_timestamp = ::std::option::Option::None;
    }

    pub fn has_your_timestamp(&self) -> bool {
        self.your_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_your_timestamp(&mut self, v: u64) {
        self.your_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 delay_time_usec = 4;

    pub fn delay_time_usec(&self) -> u32 {
        self.delay_time_usec.unwrap_or(0)
    }

    pub fn clear_delay_time_usec(&mut self) {
        self.delay_time_usec = ::std::option::Option::None;
    }

    pub fn has_delay_time_usec(&self) -> bool {
        self.delay_time_usec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delay_time_usec(&mut self, v: u32) {
        self.delay_time_usec = ::std::option::Option::Some(v);
    }

    // optional uint32 gameserver_relay_session_id = 2;

    pub fn gameserver_relay_session_id(&self) -> u32 {
        self.gameserver_relay_session_id.unwrap_or(0)
    }

    pub fn clear_gameserver_relay_session_id(&mut self) {
        self.gameserver_relay_session_id = ::std::option::Option::None;
    }

    pub fn has_gameserver_relay_session_id(&self) -> bool {
        self.gameserver_relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameserver_relay_session_id(&mut self, v: u32) {
        self.gameserver_relay_session_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_connection_id",
            |m: &CMsgSteamDatagramConnectOK| { &m.client_connection_id },
            |m: &mut CMsgSteamDatagramConnectOK| { &mut m.client_connection_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_connection_id",
            |m: &CMsgSteamDatagramConnectOK| { &m.server_connection_id },
            |m: &mut CMsgSteamDatagramConnectOK| { &mut m.server_connection_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "your_timestamp",
            |m: &CMsgSteamDatagramConnectOK| { &m.your_timestamp },
            |m: &mut CMsgSteamDatagramConnectOK| { &mut m.your_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "delay_time_usec",
            |m: &CMsgSteamDatagramConnectOK| { &m.delay_time_usec },
            |m: &mut CMsgSteamDatagramConnectOK| { &mut m.delay_time_usec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gameserver_relay_session_id",
            |m: &CMsgSteamDatagramConnectOK| { &m.gameserver_relay_session_id },
            |m: &mut CMsgSteamDatagramConnectOK| { &mut m.gameserver_relay_session_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steamnetworkingsockets_messages::CMsgSteamDatagramSessionCryptInfoSigned>(
            "crypt",
            |m: &CMsgSteamDatagramConnectOK| { &m.crypt },
            |m: &mut CMsgSteamDatagramConnectOK| { &mut m.crypt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned>(
            "cert",
            |m: &CMsgSteamDatagramConnectOK| { &m.cert },
            |m: &mut CMsgSteamDatagramConnectOK| { &mut m.cert },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramConnectOK>(
            "CMsgSteamDatagramConnectOK",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramConnectOK {
    const NAME: &'static str = "CMsgSteamDatagramConnectOK";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.client_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                61 => {
                    self.server_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                25 => {
                    self.your_timestamp = ::std::option::Option::Some(is.read_fixed64()?);
                },
                32 => {
                    self.delay_time_usec = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.gameserver_relay_session_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.crypt)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cert)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.client_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.your_timestamp {
            my_size += 1 + 8;
        }
        if let Some(v) = self.delay_time_usec {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.gameserver_relay_session_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.crypt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.cert.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.client_connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.server_connection_id {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.your_timestamp {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.delay_time_usec {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.gameserver_relay_session_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.crypt.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.cert.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramConnectOK {
        CMsgSteamDatagramConnectOK::new()
    }

    fn clear(&mut self) {
        self.client_connection_id = ::std::option::Option::None;
        self.server_connection_id = ::std::option::Option::None;
        self.your_timestamp = ::std::option::Option::None;
        self.delay_time_usec = ::std::option::Option::None;
        self.gameserver_relay_session_id = ::std::option::Option::None;
        self.crypt.clear();
        self.cert.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectOK {
        static instance: CMsgSteamDatagramConnectOK = CMsgSteamDatagramConnectOK {
            client_connection_id: ::std::option::Option::None,
            server_connection_id: ::std::option::Option::None,
            your_timestamp: ::std::option::Option::None,
            delay_time_usec: ::std::option::Option::None,
            gameserver_relay_session_id: ::std::option::Option::None,
            crypt: ::protobuf::MessageField::none(),
            cert: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramConnectOK {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramConnectOK").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramConnectOK {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectOK {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamNetworkingP2PSDRRoutingSummary)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamNetworkingP2PSDRRoutingSummary {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamNetworkingP2PSDRRoutingSummary.initial_ping)
    pub initial_ping: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamNetworkingP2PSDRRoutingSummary.initial_ping_front_local)
    pub initial_ping_front_local: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamNetworkingP2PSDRRoutingSummary.initial_ping_front_remote)
    pub initial_ping_front_remote: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamNetworkingP2PSDRRoutingSummary.initial_score)
    pub initial_score: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamNetworkingP2PSDRRoutingSummary.initial_pop_local)
    pub initial_pop_local: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamNetworkingP2PSDRRoutingSummary.initial_pop_remote)
    pub initial_pop_remote: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamNetworkingP2PSDRRoutingSummary.negotiation_ms)
    pub negotiation_ms: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamNetworkingP2PSDRRoutingSummary.selected_seconds)
    pub selected_seconds: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamNetworkingP2PSDRRoutingSummary.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamNetworkingP2PSDRRoutingSummary {
    fn default() -> &'a CMsgSteamNetworkingP2PSDRRoutingSummary {
        <CMsgSteamNetworkingP2PSDRRoutingSummary as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamNetworkingP2PSDRRoutingSummary {
    pub fn new() -> CMsgSteamNetworkingP2PSDRRoutingSummary {
        ::std::default::Default::default()
    }

    // optional uint32 initial_ping = 1;

    pub fn initial_ping(&self) -> u32 {
        self.initial_ping.unwrap_or(0)
    }

    pub fn clear_initial_ping(&mut self) {
        self.initial_ping = ::std::option::Option::None;
    }

    pub fn has_initial_ping(&self) -> bool {
        self.initial_ping.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_ping(&mut self, v: u32) {
        self.initial_ping = ::std::option::Option::Some(v);
    }

    // optional uint32 initial_ping_front_local = 2;

    pub fn initial_ping_front_local(&self) -> u32 {
        self.initial_ping_front_local.unwrap_or(0)
    }

    pub fn clear_initial_ping_front_local(&mut self) {
        self.initial_ping_front_local = ::std::option::Option::None;
    }

    pub fn has_initial_ping_front_local(&self) -> bool {
        self.initial_ping_front_local.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_ping_front_local(&mut self, v: u32) {
        self.initial_ping_front_local = ::std::option::Option::Some(v);
    }

    // optional uint32 initial_ping_front_remote = 3;

    pub fn initial_ping_front_remote(&self) -> u32 {
        self.initial_ping_front_remote.unwrap_or(0)
    }

    pub fn clear_initial_ping_front_remote(&mut self) {
        self.initial_ping_front_remote = ::std::option::Option::None;
    }

    pub fn has_initial_ping_front_remote(&self) -> bool {
        self.initial_ping_front_remote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_ping_front_remote(&mut self, v: u32) {
        self.initial_ping_front_remote = ::std::option::Option::Some(v);
    }

    // optional uint32 initial_score = 4;

    pub fn initial_score(&self) -> u32 {
        self.initial_score.unwrap_or(0)
    }

    pub fn clear_initial_score(&mut self) {
        self.initial_score = ::std::option::Option::None;
    }

    pub fn has_initial_score(&self) -> bool {
        self.initial_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_score(&mut self, v: u32) {
        self.initial_score = ::std::option::Option::Some(v);
    }

    // optional fixed32 initial_pop_local = 5;

    pub fn initial_pop_local(&self) -> u32 {
        self.initial_pop_local.unwrap_or(0)
    }

    pub fn clear_initial_pop_local(&mut self) {
        self.initial_pop_local = ::std::option::Option::None;
    }

    pub fn has_initial_pop_local(&self) -> bool {
        self.initial_pop_local.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_pop_local(&mut self, v: u32) {
        self.initial_pop_local = ::std::option::Option::Some(v);
    }

    // optional fixed32 initial_pop_remote = 6;

    pub fn initial_pop_remote(&self) -> u32 {
        self.initial_pop_remote.unwrap_or(0)
    }

    pub fn clear_initial_pop_remote(&mut self) {
        self.initial_pop_remote = ::std::option::Option::None;
    }

    pub fn has_initial_pop_remote(&self) -> bool {
        self.initial_pop_remote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_pop_remote(&mut self, v: u32) {
        self.initial_pop_remote = ::std::option::Option::Some(v);
    }

    // optional uint32 negotiation_ms = 7;

    pub fn negotiation_ms(&self) -> u32 {
        self.negotiation_ms.unwrap_or(0)
    }

    pub fn clear_negotiation_ms(&mut self) {
        self.negotiation_ms = ::std::option::Option::None;
    }

    pub fn has_negotiation_ms(&self) -> bool {
        self.negotiation_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_negotiation_ms(&mut self, v: u32) {
        self.negotiation_ms = ::std::option::Option::Some(v);
    }

    // optional uint32 selected_seconds = 8;

    pub fn selected_seconds(&self) -> u32 {
        self.selected_seconds.unwrap_or(0)
    }

    pub fn clear_selected_seconds(&mut self) {
        self.selected_seconds = ::std::option::Option::None;
    }

    pub fn has_selected_seconds(&self) -> bool {
        self.selected_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selected_seconds(&mut self, v: u32) {
        self.selected_seconds = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "initial_ping",
            |m: &CMsgSteamNetworkingP2PSDRRoutingSummary| { &m.initial_ping },
            |m: &mut CMsgSteamNetworkingP2PSDRRoutingSummary| { &mut m.initial_ping },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "initial_ping_front_local",
            |m: &CMsgSteamNetworkingP2PSDRRoutingSummary| { &m.initial_ping_front_local },
            |m: &mut CMsgSteamNetworkingP2PSDRRoutingSummary| { &mut m.initial_ping_front_local },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "initial_ping_front_remote",
            |m: &CMsgSteamNetworkingP2PSDRRoutingSummary| { &m.initial_ping_front_remote },
            |m: &mut CMsgSteamNetworkingP2PSDRRoutingSummary| { &mut m.initial_ping_front_remote },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "initial_score",
            |m: &CMsgSteamNetworkingP2PSDRRoutingSummary| { &m.initial_score },
            |m: &mut CMsgSteamNetworkingP2PSDRRoutingSummary| { &mut m.initial_score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "initial_pop_local",
            |m: &CMsgSteamNetworkingP2PSDRRoutingSummary| { &m.initial_pop_local },
            |m: &mut CMsgSteamNetworkingP2PSDRRoutingSummary| { &mut m.initial_pop_local },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "initial_pop_remote",
            |m: &CMsgSteamNetworkingP2PSDRRoutingSummary| { &m.initial_pop_remote },
            |m: &mut CMsgSteamNetworkingP2PSDRRoutingSummary| { &mut m.initial_pop_remote },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "negotiation_ms",
            |m: &CMsgSteamNetworkingP2PSDRRoutingSummary| { &m.negotiation_ms },
            |m: &mut CMsgSteamNetworkingP2PSDRRoutingSummary| { &mut m.negotiation_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "selected_seconds",
            |m: &CMsgSteamNetworkingP2PSDRRoutingSummary| { &m.selected_seconds },
            |m: &mut CMsgSteamNetworkingP2PSDRRoutingSummary| { &mut m.selected_seconds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamNetworkingP2PSDRRoutingSummary>(
            "CMsgSteamNetworkingP2PSDRRoutingSummary",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamNetworkingP2PSDRRoutingSummary {
    const NAME: &'static str = "CMsgSteamNetworkingP2PSDRRoutingSummary";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.initial_ping = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.initial_ping_front_local = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.initial_ping_front_remote = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.initial_score = ::std::option::Option::Some(is.read_uint32()?);
                },
                45 => {
                    self.initial_pop_local = ::std::option::Option::Some(is.read_fixed32()?);
                },
                53 => {
                    self.initial_pop_remote = ::std::option::Option::Some(is.read_fixed32()?);
                },
                56 => {
                    self.negotiation_ms = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.selected_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.initial_ping {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.initial_ping_front_local {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.initial_ping_front_remote {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.initial_score {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.initial_pop_local {
            my_size += 1 + 4;
        }
        if let Some(v) = self.initial_pop_remote {
            my_size += 1 + 4;
        }
        if let Some(v) = self.negotiation_ms {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.selected_seconds {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.initial_ping {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.initial_ping_front_local {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.initial_ping_front_remote {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.initial_score {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.initial_pop_local {
            os.write_fixed32(5, v)?;
        }
        if let Some(v) = self.initial_pop_remote {
            os.write_fixed32(6, v)?;
        }
        if let Some(v) = self.negotiation_ms {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.selected_seconds {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamNetworkingP2PSDRRoutingSummary {
        CMsgSteamNetworkingP2PSDRRoutingSummary::new()
    }

    fn clear(&mut self) {
        self.initial_ping = ::std::option::Option::None;
        self.initial_ping_front_local = ::std::option::Option::None;
        self.initial_ping_front_remote = ::std::option::Option::None;
        self.initial_score = ::std::option::Option::None;
        self.initial_pop_local = ::std::option::Option::None;
        self.initial_pop_remote = ::std::option::Option::None;
        self.negotiation_ms = ::std::option::Option::None;
        self.selected_seconds = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamNetworkingP2PSDRRoutingSummary {
        static instance: CMsgSteamNetworkingP2PSDRRoutingSummary = CMsgSteamNetworkingP2PSDRRoutingSummary {
            initial_ping: ::std::option::Option::None,
            initial_ping_front_local: ::std::option::Option::None,
            initial_ping_front_remote: ::std::option::Option::None,
            initial_score: ::std::option::Option::None,
            initial_pop_local: ::std::option::Option::None,
            initial_pop_remote: ::std::option::Option::None,
            negotiation_ms: ::std::option::Option::None,
            selected_seconds: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamNetworkingP2PSDRRoutingSummary {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamNetworkingP2PSDRRoutingSummary").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamNetworkingP2PSDRRoutingSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamNetworkingP2PSDRRoutingSummary {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamDatagramP2PRoutingSummary)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramP2PRoutingSummary {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PRoutingSummary.ice)
    pub ice: ::protobuf::MessageField<super::steamnetworkingsockets_messages::CMsgSteamNetworkingICESessionSummary>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PRoutingSummary.sdr)
    pub sdr: ::protobuf::MessageField<CMsgSteamNetworkingP2PSDRRoutingSummary>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramP2PRoutingSummary.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramP2PRoutingSummary {
    fn default() -> &'a CMsgSteamDatagramP2PRoutingSummary {
        <CMsgSteamDatagramP2PRoutingSummary as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramP2PRoutingSummary {
    pub fn new() -> CMsgSteamDatagramP2PRoutingSummary {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steamnetworkingsockets_messages::CMsgSteamNetworkingICESessionSummary>(
            "ice",
            |m: &CMsgSteamDatagramP2PRoutingSummary| { &m.ice },
            |m: &mut CMsgSteamDatagramP2PRoutingSummary| { &mut m.ice },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSteamNetworkingP2PSDRRoutingSummary>(
            "sdr",
            |m: &CMsgSteamDatagramP2PRoutingSummary| { &m.sdr },
            |m: &mut CMsgSteamDatagramP2PRoutingSummary| { &mut m.sdr },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramP2PRoutingSummary>(
            "CMsgSteamDatagramP2PRoutingSummary",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramP2PRoutingSummary {
    const NAME: &'static str = "CMsgSteamDatagramP2PRoutingSummary";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ice)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sdr)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ice.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.sdr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ice.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.sdr.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramP2PRoutingSummary {
        CMsgSteamDatagramP2PRoutingSummary::new()
    }

    fn clear(&mut self) {
        self.ice.clear();
        self.sdr.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramP2PRoutingSummary {
        static instance: CMsgSteamDatagramP2PRoutingSummary = CMsgSteamDatagramP2PRoutingSummary {
            ice: ::protobuf::MessageField::none(),
            sdr: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramP2PRoutingSummary {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramP2PRoutingSummary").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramP2PRoutingSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramP2PRoutingSummary {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamDatagramConnectionClosed)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramConnectionClosed {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionClosed.to_connection_id)
    pub to_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionClosed.from_connection_id)
    pub from_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionClosed.from_identity_string)
    pub from_identity_string: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionClosed.legacy_from_identity_binary)
    pub legacy_from_identity_binary: ::protobuf::MessageField<super::steamnetworkingsockets_messages_certs::CMsgSteamNetworkingIdentityLegacyBinary>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionClosed.legacy_from_steam_id)
    pub legacy_from_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionClosed.legacy_gameserver_relay_session_id)
    pub legacy_gameserver_relay_session_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionClosed.to_relay_session_id)
    pub to_relay_session_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionClosed.from_relay_session_id)
    pub from_relay_session_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionClosed.forward_target_relay_routing_token)
    pub forward_target_relay_routing_token: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionClosed.forward_target_revision)
    pub forward_target_revision: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionClosed.relay_mode)
    pub relay_mode: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_steam_datagram_connection_closed::ERelayMode>>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionClosed.debug)
    pub debug: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionClosed.reason_code)
    pub reason_code: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionClosed.routing_secret)
    pub routing_secret: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionClosed.not_primary_session)
    pub not_primary_session: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionClosed.not_primary_transport)
    pub not_primary_transport: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionClosed.quality_relay)
    pub quality_relay: ::protobuf::MessageField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionClosed.quality_e2e)
    pub quality_e2e: ::protobuf::MessageField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionClosed.p2p_routing_summary)
    pub p2p_routing_summary: ::protobuf::MessageField<CMsgSteamDatagramP2PRoutingSummary>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramConnectionClosed.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectionClosed {
    fn default() -> &'a CMsgSteamDatagramConnectionClosed {
        <CMsgSteamDatagramConnectionClosed as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectionClosed {
    pub fn new() -> CMsgSteamDatagramConnectionClosed {
        ::std::default::Default::default()
    }

    // optional fixed32 to_connection_id = 7;

    pub fn to_connection_id(&self) -> u32 {
        self.to_connection_id.unwrap_or(0)
    }

    pub fn clear_to_connection_id(&mut self) {
        self.to_connection_id = ::std::option::Option::None;
    }

    pub fn has_to_connection_id(&self) -> bool {
        self.to_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to_connection_id(&mut self, v: u32) {
        self.to_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 from_connection_id = 8;

    pub fn from_connection_id(&self) -> u32 {
        self.from_connection_id.unwrap_or(0)
    }

    pub fn clear_from_connection_id(&mut self) {
        self.from_connection_id = ::std::option::Option::None;
    }

    pub fn has_from_connection_id(&self) -> bool {
        self.from_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_connection_id(&mut self, v: u32) {
        self.from_connection_id = ::std::option::Option::Some(v);
    }

    // optional string from_identity_string = 15;

    pub fn from_identity_string(&self) -> &str {
        match self.from_identity_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_from_identity_string(&mut self) {
        self.from_identity_string = ::std::option::Option::None;
    }

    pub fn has_from_identity_string(&self) -> bool {
        self.from_identity_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_identity_string(&mut self, v: ::std::string::String) {
        self.from_identity_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from_identity_string(&mut self) -> &mut ::std::string::String {
        if self.from_identity_string.is_none() {
            self.from_identity_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.from_identity_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_from_identity_string(&mut self) -> ::std::string::String {
        self.from_identity_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 legacy_from_steam_id = 3;

    pub fn legacy_from_steam_id(&self) -> u64 {
        self.legacy_from_steam_id.unwrap_or(0)
    }

    pub fn clear_legacy_from_steam_id(&mut self) {
        self.legacy_from_steam_id = ::std::option::Option::None;
    }

    pub fn has_legacy_from_steam_id(&self) -> bool {
        self.legacy_from_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_from_steam_id(&mut self, v: u64) {
        self.legacy_from_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 legacy_gameserver_relay_session_id = 2;

    pub fn legacy_gameserver_relay_session_id(&self) -> u32 {
        self.legacy_gameserver_relay_session_id.unwrap_or(0)
    }

    pub fn clear_legacy_gameserver_relay_session_id(&mut self) {
        self.legacy_gameserver_relay_session_id = ::std::option::Option::None;
    }

    pub fn has_legacy_gameserver_relay_session_id(&self) -> bool {
        self.legacy_gameserver_relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_gameserver_relay_session_id(&mut self, v: u32) {
        self.legacy_gameserver_relay_session_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 to_relay_session_id = 9;

    pub fn to_relay_session_id(&self) -> u32 {
        self.to_relay_session_id.unwrap_or(0)
    }

    pub fn clear_to_relay_session_id(&mut self) {
        self.to_relay_session_id = ::std::option::Option::None;
    }

    pub fn has_to_relay_session_id(&self) -> bool {
        self.to_relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to_relay_session_id(&mut self, v: u32) {
        self.to_relay_session_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 from_relay_session_id = 10;

    pub fn from_relay_session_id(&self) -> u32 {
        self.from_relay_session_id.unwrap_or(0)
    }

    pub fn clear_from_relay_session_id(&mut self) {
        self.from_relay_session_id = ::std::option::Option::None;
    }

    pub fn has_from_relay_session_id(&self) -> bool {
        self.from_relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_relay_session_id(&mut self, v: u32) {
        self.from_relay_session_id = ::std::option::Option::Some(v);
    }

    // optional bytes forward_target_relay_routing_token = 11;

    pub fn forward_target_relay_routing_token(&self) -> &[u8] {
        match self.forward_target_relay_routing_token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_forward_target_relay_routing_token(&mut self) {
        self.forward_target_relay_routing_token = ::std::option::Option::None;
    }

    pub fn has_forward_target_relay_routing_token(&self) -> bool {
        self.forward_target_relay_routing_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_forward_target_relay_routing_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.forward_target_relay_routing_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_forward_target_relay_routing_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.forward_target_relay_routing_token.is_none() {
            self.forward_target_relay_routing_token = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.forward_target_relay_routing_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_forward_target_relay_routing_token(&mut self) -> ::std::vec::Vec<u8> {
        self.forward_target_relay_routing_token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 forward_target_revision = 12;

    pub fn forward_target_revision(&self) -> u32 {
        self.forward_target_revision.unwrap_or(0)
    }

    pub fn clear_forward_target_revision(&mut self) {
        self.forward_target_revision = ::std::option::Option::None;
    }

    pub fn has_forward_target_revision(&self) -> bool {
        self.forward_target_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_forward_target_revision(&mut self, v: u32) {
        self.forward_target_revision = ::std::option::Option::Some(v);
    }

    // optional .CMsgSteamDatagramConnectionClosed.ERelayMode relay_mode = 4;

    pub fn relay_mode(&self) -> cmsg_steam_datagram_connection_closed::ERelayMode {
        match self.relay_mode {
            Some(e) => e.enum_value_or(cmsg_steam_datagram_connection_closed::ERelayMode::None),
            None => cmsg_steam_datagram_connection_closed::ERelayMode::None,
        }
    }

    pub fn clear_relay_mode(&mut self) {
        self.relay_mode = ::std::option::Option::None;
    }

    pub fn has_relay_mode(&self) -> bool {
        self.relay_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relay_mode(&mut self, v: cmsg_steam_datagram_connection_closed::ERelayMode) {
        self.relay_mode = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string debug = 5;

    pub fn debug(&self) -> &str {
        match self.debug.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_debug(&mut self) {
        self.debug = ::std::option::Option::None;
    }

    pub fn has_debug(&self) -> bool {
        self.debug.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug(&mut self, v: ::std::string::String) {
        self.debug = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_debug(&mut self) -> &mut ::std::string::String {
        if self.debug.is_none() {
            self.debug = ::std::option::Option::Some(::std::string::String::new());
        }
        self.debug.as_mut().unwrap()
    }

    // Take field
    pub fn take_debug(&mut self) -> ::std::string::String {
        self.debug.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 reason_code = 6;

    pub fn reason_code(&self) -> u32 {
        self.reason_code.unwrap_or(0)
    }

    pub fn clear_reason_code(&mut self) {
        self.reason_code = ::std::option::Option::None;
    }

    pub fn has_reason_code(&self) -> bool {
        self.reason_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason_code(&mut self, v: u32) {
        self.reason_code = ::std::option::Option::Some(v);
    }

    // optional fixed64 routing_secret = 14;

    pub fn routing_secret(&self) -> u64 {
        self.routing_secret.unwrap_or(0)
    }

    pub fn clear_routing_secret(&mut self) {
        self.routing_secret = ::std::option::Option::None;
    }

    pub fn has_routing_secret(&self) -> bool {
        self.routing_secret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_routing_secret(&mut self, v: u64) {
        self.routing_secret = ::std::option::Option::Some(v);
    }

    // optional bool not_primary_session = 16;

    pub fn not_primary_session(&self) -> bool {
        self.not_primary_session.unwrap_or(false)
    }

    pub fn clear_not_primary_session(&mut self) {
        self.not_primary_session = ::std::option::Option::None;
    }

    pub fn has_not_primary_session(&self) -> bool {
        self.not_primary_session.is_some()
    }

    // Param is passed by value, moved
    pub fn set_not_primary_session(&mut self, v: bool) {
        self.not_primary_session = ::std::option::Option::Some(v);
    }

    // optional bool not_primary_transport = 19;

    pub fn not_primary_transport(&self) -> bool {
        self.not_primary_transport.unwrap_or(false)
    }

    pub fn clear_not_primary_transport(&mut self) {
        self.not_primary_transport = ::std::option::Option::None;
    }

    pub fn has_not_primary_transport(&self) -> bool {
        self.not_primary_transport.is_some()
    }

    // Param is passed by value, moved
    pub fn set_not_primary_transport(&mut self, v: bool) {
        self.not_primary_transport = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(19);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "to_connection_id",
            |m: &CMsgSteamDatagramConnectionClosed| { &m.to_connection_id },
            |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.to_connection_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "from_connection_id",
            |m: &CMsgSteamDatagramConnectionClosed| { &m.from_connection_id },
            |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.from_connection_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "from_identity_string",
            |m: &CMsgSteamDatagramConnectionClosed| { &m.from_identity_string },
            |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.from_identity_string },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steamnetworkingsockets_messages_certs::CMsgSteamNetworkingIdentityLegacyBinary>(
            "legacy_from_identity_binary",
            |m: &CMsgSteamDatagramConnectionClosed| { &m.legacy_from_identity_binary },
            |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.legacy_from_identity_binary },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "legacy_from_steam_id",
            |m: &CMsgSteamDatagramConnectionClosed| { &m.legacy_from_steam_id },
            |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.legacy_from_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "legacy_gameserver_relay_session_id",
            |m: &CMsgSteamDatagramConnectionClosed| { &m.legacy_gameserver_relay_session_id },
            |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.legacy_gameserver_relay_session_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "to_relay_session_id",
            |m: &CMsgSteamDatagramConnectionClosed| { &m.to_relay_session_id },
            |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.to_relay_session_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "from_relay_session_id",
            |m: &CMsgSteamDatagramConnectionClosed| { &m.from_relay_session_id },
            |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.from_relay_session_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "forward_target_relay_routing_token",
            |m: &CMsgSteamDatagramConnectionClosed| { &m.forward_target_relay_routing_token },
            |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.forward_target_relay_routing_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "forward_target_revision",
            |m: &CMsgSteamDatagramConnectionClosed| { &m.forward_target_revision },
            |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.forward_target_revision },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "relay_mode",
            |m: &CMsgSteamDatagramConnectionClosed| { &m.relay_mode },
            |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.relay_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "debug",
            |m: &CMsgSteamDatagramConnectionClosed| { &m.debug },
            |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.debug },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason_code",
            |m: &CMsgSteamDatagramConnectionClosed| { &m.reason_code },
            |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.reason_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "routing_secret",
            |m: &CMsgSteamDatagramConnectionClosed| { &m.routing_secret },
            |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.routing_secret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "not_primary_session",
            |m: &CMsgSteamDatagramConnectionClosed| { &m.not_primary_session },
            |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.not_primary_session },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "not_primary_transport",
            |m: &CMsgSteamDatagramConnectionClosed| { &m.not_primary_transport },
            |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.not_primary_transport },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>(
            "quality_relay",
            |m: &CMsgSteamDatagramConnectionClosed| { &m.quality_relay },
            |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.quality_relay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>(
            "quality_e2e",
            |m: &CMsgSteamDatagramConnectionClosed| { &m.quality_e2e },
            |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.quality_e2e },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSteamDatagramP2PRoutingSummary>(
            "p2p_routing_summary",
            |m: &CMsgSteamDatagramConnectionClosed| { &m.p2p_routing_summary },
            |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.p2p_routing_summary },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramConnectionClosed>(
            "CMsgSteamDatagramConnectionClosed",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramConnectionClosed {
    const NAME: &'static str = "CMsgSteamDatagramConnectionClosed";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                61 => {
                    self.to_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                69 => {
                    self.from_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                122 => {
                    self.from_identity_string = ::std::option::Option::Some(is.read_string()?);
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.legacy_from_identity_binary)?;
                },
                25 => {
                    self.legacy_from_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.legacy_gameserver_relay_session_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                77 => {
                    self.to_relay_session_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                85 => {
                    self.from_relay_session_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                90 => {
                    self.forward_target_relay_routing_token = ::std::option::Option::Some(is.read_bytes()?);
                },
                96 => {
                    self.forward_target_revision = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.relay_mode = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                42 => {
                    self.debug = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.reason_code = ::std::option::Option::Some(is.read_uint32()?);
                },
                113 => {
                    self.routing_secret = ::std::option::Option::Some(is.read_fixed64()?);
                },
                128 => {
                    self.not_primary_session = ::std::option::Option::Some(is.read_bool()?);
                },
                152 => {
                    self.not_primary_transport = ::std::option::Option::Some(is.read_bool()?);
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.quality_relay)?;
                },
                146 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.quality_e2e)?;
                },
                170 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.p2p_routing_summary)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.to_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.from_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.from_identity_string.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.legacy_from_identity_binary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.legacy_from_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.legacy_gameserver_relay_session_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.to_relay_session_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.from_relay_session_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.forward_target_relay_routing_token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(11, &v);
        }
        if let Some(v) = self.forward_target_revision {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.relay_mode {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.debug.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.reason_code {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.routing_secret {
            my_size += 1 + 8;
        }
        if let Some(v) = self.not_primary_session {
            my_size += 2 + 1;
        }
        if let Some(v) = self.not_primary_transport {
            my_size += 2 + 1;
        }
        if let Some(v) = self.quality_relay.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.quality_e2e.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.p2p_routing_summary.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.to_connection_id {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.from_connection_id {
            os.write_fixed32(8, v)?;
        }
        if let Some(v) = self.from_identity_string.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.legacy_from_identity_binary.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.legacy_from_steam_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.legacy_gameserver_relay_session_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.to_relay_session_id {
            os.write_fixed32(9, v)?;
        }
        if let Some(v) = self.from_relay_session_id {
            os.write_fixed32(10, v)?;
        }
        if let Some(v) = self.forward_target_relay_routing_token.as_ref() {
            os.write_bytes(11, v)?;
        }
        if let Some(v) = self.forward_target_revision {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.relay_mode {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.debug.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.reason_code {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.routing_secret {
            os.write_fixed64(14, v)?;
        }
        if let Some(v) = self.not_primary_session {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.not_primary_transport {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.quality_relay.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.quality_e2e.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        if let Some(v) = self.p2p_routing_summary.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramConnectionClosed {
        CMsgSteamDatagramConnectionClosed::new()
    }

    fn clear(&mut self) {
        self.to_connection_id = ::std::option::Option::None;
        self.from_connection_id = ::std::option::Option::None;
        self.from_identity_string = ::std::option::Option::None;
        self.legacy_from_identity_binary.clear();
        self.legacy_from_steam_id = ::std::option::Option::None;
        self.legacy_gameserver_relay_session_id = ::std::option::Option::None;
        self.to_relay_session_id = ::std::option::Option::None;
        self.from_relay_session_id = ::std::option::Option::None;
        self.forward_target_relay_routing_token = ::std::option::Option::None;
        self.forward_target_revision = ::std::option::Option::None;
        self.relay_mode = ::std::option::Option::None;
        self.debug = ::std::option::Option::None;
        self.reason_code = ::std::option::Option::None;
        self.routing_secret = ::std::option::Option::None;
        self.not_primary_session = ::std::option::Option::None;
        self.not_primary_transport = ::std::option::Option::None;
        self.quality_relay.clear();
        self.quality_e2e.clear();
        self.p2p_routing_summary.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectionClosed {
        static instance: CMsgSteamDatagramConnectionClosed = CMsgSteamDatagramConnectionClosed {
            to_connection_id: ::std::option::Option::None,
            from_connection_id: ::std::option::Option::None,
            from_identity_string: ::std::option::Option::None,
            legacy_from_identity_binary: ::protobuf::MessageField::none(),
            legacy_from_steam_id: ::std::option::Option::None,
            legacy_gameserver_relay_session_id: ::std::option::Option::None,
            to_relay_session_id: ::std::option::Option::None,
            from_relay_session_id: ::std::option::Option::None,
            forward_target_relay_routing_token: ::std::option::Option::None,
            forward_target_revision: ::std::option::Option::None,
            relay_mode: ::std::option::Option::None,
            debug: ::std::option::Option::None,
            reason_code: ::std::option::Option::None,
            routing_secret: ::std::option::Option::None,
            not_primary_session: ::std::option::Option::None,
            not_primary_transport: ::std::option::Option::None,
            quality_relay: ::protobuf::MessageField::none(),
            quality_e2e: ::protobuf::MessageField::none(),
            p2p_routing_summary: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramConnectionClosed {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramConnectionClosed").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramConnectionClosed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionClosed {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSteamDatagramConnectionClosed`
pub mod cmsg_steam_datagram_connection_closed {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgSteamDatagramConnectionClosed.ERelayMode)
    pub enum ERelayMode {
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionClosed.ERelayMode.None)
        None = 0,
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionClosed.ERelayMode.EndToEnd)
        EndToEnd = 1,
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionClosed.ERelayMode.ClosedByPeer)
        ClosedByPeer = 2,
    }

    impl ::protobuf::Enum for ERelayMode {
        const NAME: &'static str = "ERelayMode";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ERelayMode> {
            match value {
                0 => ::std::option::Option::Some(ERelayMode::None),
                1 => ::std::option::Option::Some(ERelayMode::EndToEnd),
                2 => ::std::option::Option::Some(ERelayMode::ClosedByPeer),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ERelayMode> {
            match str {
                "None" => ::std::option::Option::Some(ERelayMode::None),
                "EndToEnd" => ::std::option::Option::Some(ERelayMode::EndToEnd),
                "ClosedByPeer" => ::std::option::Option::Some(ERelayMode::ClosedByPeer),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ERelayMode] = &[
            ERelayMode::None,
            ERelayMode::EndToEnd,
            ERelayMode::ClosedByPeer,
        ];
    }

    impl ::protobuf::EnumFull for ERelayMode {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgSteamDatagramConnectionClosed.ERelayMode").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ERelayMode {
        fn default() -> Self {
            ERelayMode::None
        }
    }

    impl ERelayMode {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ERelayMode>("CMsgSteamDatagramConnectionClosed.ERelayMode")
        }
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramNoConnection)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramNoConnection {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoConnection.to_connection_id)
    pub to_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoConnection.from_connection_id)
    pub from_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoConnection.legacy_gameserver_relay_session_id)
    pub legacy_gameserver_relay_session_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoConnection.to_relay_session_id)
    pub to_relay_session_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoConnection.from_relay_session_id)
    pub from_relay_session_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoConnection.from_identity_string)
    pub from_identity_string: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoConnection.legacy_from_steam_id)
    pub legacy_from_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoConnection.end_to_end)
    pub end_to_end: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoConnection.not_primary_session)
    pub not_primary_session: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoConnection.not_primary_transport)
    pub not_primary_transport: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoConnection.quality_relay)
    pub quality_relay: ::protobuf::MessageField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoConnection.quality_e2e)
    pub quality_e2e: ::protobuf::MessageField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoConnection.p2p_routing_summary)
    pub p2p_routing_summary: ::protobuf::MessageField<CMsgSteamDatagramP2PRoutingSummary>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoConnection.routing_secret)
    pub routing_secret: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoConnection.dummy_pad)
    pub dummy_pad: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramNoConnection.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramNoConnection {
    fn default() -> &'a CMsgSteamDatagramNoConnection {
        <CMsgSteamDatagramNoConnection as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramNoConnection {
    pub fn new() -> CMsgSteamDatagramNoConnection {
        ::std::default::Default::default()
    }

    // optional fixed32 to_connection_id = 5;

    pub fn to_connection_id(&self) -> u32 {
        self.to_connection_id.unwrap_or(0)
    }

    pub fn clear_to_connection_id(&mut self) {
        self.to_connection_id = ::std::option::Option::None;
    }

    pub fn has_to_connection_id(&self) -> bool {
        self.to_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to_connection_id(&mut self, v: u32) {
        self.to_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 from_connection_id = 6;

    pub fn from_connection_id(&self) -> u32 {
        self.from_connection_id.unwrap_or(0)
    }

    pub fn clear_from_connection_id(&mut self) {
        self.from_connection_id = ::std::option::Option::None;
    }

    pub fn has_from_connection_id(&self) -> bool {
        self.from_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_connection_id(&mut self, v: u32) {
        self.from_connection_id = ::std::option::Option::Some(v);
    }

    // optional uint32 legacy_gameserver_relay_session_id = 2;

    pub fn legacy_gameserver_relay_session_id(&self) -> u32 {
        self.legacy_gameserver_relay_session_id.unwrap_or(0)
    }

    pub fn clear_legacy_gameserver_relay_session_id(&mut self) {
        self.legacy_gameserver_relay_session_id = ::std::option::Option::None;
    }

    pub fn has_legacy_gameserver_relay_session_id(&self) -> bool {
        self.legacy_gameserver_relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_gameserver_relay_session_id(&mut self, v: u32) {
        self.legacy_gameserver_relay_session_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 to_relay_session_id = 9;

    pub fn to_relay_session_id(&self) -> u32 {
        self.to_relay_session_id.unwrap_or(0)
    }

    pub fn clear_to_relay_session_id(&mut self) {
        self.to_relay_session_id = ::std::option::Option::None;
    }

    pub fn has_to_relay_session_id(&self) -> bool {
        self.to_relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to_relay_session_id(&mut self, v: u32) {
        self.to_relay_session_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 from_relay_session_id = 10;

    pub fn from_relay_session_id(&self) -> u32 {
        self.from_relay_session_id.unwrap_or(0)
    }

    pub fn clear_from_relay_session_id(&mut self) {
        self.from_relay_session_id = ::std::option::Option::None;
    }

    pub fn has_from_relay_session_id(&self) -> bool {
        self.from_relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_relay_session_id(&mut self, v: u32) {
        self.from_relay_session_id = ::std::option::Option::Some(v);
    }

    // optional string from_identity_string = 7;

    pub fn from_identity_string(&self) -> &str {
        match self.from_identity_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_from_identity_string(&mut self) {
        self.from_identity_string = ::std::option::Option::None;
    }

    pub fn has_from_identity_string(&self) -> bool {
        self.from_identity_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_identity_string(&mut self, v: ::std::string::String) {
        self.from_identity_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from_identity_string(&mut self) -> &mut ::std::string::String {
        if self.from_identity_string.is_none() {
            self.from_identity_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.from_identity_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_from_identity_string(&mut self) -> ::std::string::String {
        self.from_identity_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 legacy_from_steam_id = 3;

    pub fn legacy_from_steam_id(&self) -> u64 {
        self.legacy_from_steam_id.unwrap_or(0)
    }

    pub fn clear_legacy_from_steam_id(&mut self) {
        self.legacy_from_steam_id = ::std::option::Option::None;
    }

    pub fn has_legacy_from_steam_id(&self) -> bool {
        self.legacy_from_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_from_steam_id(&mut self, v: u64) {
        self.legacy_from_steam_id = ::std::option::Option::Some(v);
    }

    // optional bool end_to_end = 4;

    pub fn end_to_end(&self) -> bool {
        self.end_to_end.unwrap_or(false)
    }

    pub fn clear_end_to_end(&mut self) {
        self.end_to_end = ::std::option::Option::None;
    }

    pub fn has_end_to_end(&self) -> bool {
        self.end_to_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_to_end(&mut self, v: bool) {
        self.end_to_end = ::std::option::Option::Some(v);
    }

    // optional bool not_primary_session = 12;

    pub fn not_primary_session(&self) -> bool {
        self.not_primary_session.unwrap_or(false)
    }

    pub fn clear_not_primary_session(&mut self) {
        self.not_primary_session = ::std::option::Option::None;
    }

    pub fn has_not_primary_session(&self) -> bool {
        self.not_primary_session.is_some()
    }

    // Param is passed by value, moved
    pub fn set_not_primary_session(&mut self, v: bool) {
        self.not_primary_session = ::std::option::Option::Some(v);
    }

    // optional bool not_primary_transport = 15;

    pub fn not_primary_transport(&self) -> bool {
        self.not_primary_transport.unwrap_or(false)
    }

    pub fn clear_not_primary_transport(&mut self) {
        self.not_primary_transport = ::std::option::Option::None;
    }

    pub fn has_not_primary_transport(&self) -> bool {
        self.not_primary_transport.is_some()
    }

    // Param is passed by value, moved
    pub fn set_not_primary_transport(&mut self, v: bool) {
        self.not_primary_transport = ::std::option::Option::Some(v);
    }

    // optional fixed64 routing_secret = 11;

    pub fn routing_secret(&self) -> u64 {
        self.routing_secret.unwrap_or(0)
    }

    pub fn clear_routing_secret(&mut self) {
        self.routing_secret = ::std::option::Option::None;
    }

    pub fn has_routing_secret(&self) -> bool {
        self.routing_secret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_routing_secret(&mut self, v: u64) {
        self.routing_secret = ::std::option::Option::Some(v);
    }

    // optional fixed32 dummy_pad = 1023;

    pub fn dummy_pad(&self) -> u32 {
        self.dummy_pad.unwrap_or(0)
    }

    pub fn clear_dummy_pad(&mut self) {
        self.dummy_pad = ::std::option::Option::None;
    }

    pub fn has_dummy_pad(&self) -> bool {
        self.dummy_pad.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy_pad(&mut self, v: u32) {
        self.dummy_pad = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(15);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "to_connection_id",
            |m: &CMsgSteamDatagramNoConnection| { &m.to_connection_id },
            |m: &mut CMsgSteamDatagramNoConnection| { &mut m.to_connection_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "from_connection_id",
            |m: &CMsgSteamDatagramNoConnection| { &m.from_connection_id },
            |m: &mut CMsgSteamDatagramNoConnection| { &mut m.from_connection_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "legacy_gameserver_relay_session_id",
            |m: &CMsgSteamDatagramNoConnection| { &m.legacy_gameserver_relay_session_id },
            |m: &mut CMsgSteamDatagramNoConnection| { &mut m.legacy_gameserver_relay_session_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "to_relay_session_id",
            |m: &CMsgSteamDatagramNoConnection| { &m.to_relay_session_id },
            |m: &mut CMsgSteamDatagramNoConnection| { &mut m.to_relay_session_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "from_relay_session_id",
            |m: &CMsgSteamDatagramNoConnection| { &m.from_relay_session_id },
            |m: &mut CMsgSteamDatagramNoConnection| { &mut m.from_relay_session_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "from_identity_string",
            |m: &CMsgSteamDatagramNoConnection| { &m.from_identity_string },
            |m: &mut CMsgSteamDatagramNoConnection| { &mut m.from_identity_string },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "legacy_from_steam_id",
            |m: &CMsgSteamDatagramNoConnection| { &m.legacy_from_steam_id },
            |m: &mut CMsgSteamDatagramNoConnection| { &mut m.legacy_from_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "end_to_end",
            |m: &CMsgSteamDatagramNoConnection| { &m.end_to_end },
            |m: &mut CMsgSteamDatagramNoConnection| { &mut m.end_to_end },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "not_primary_session",
            |m: &CMsgSteamDatagramNoConnection| { &m.not_primary_session },
            |m: &mut CMsgSteamDatagramNoConnection| { &mut m.not_primary_session },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "not_primary_transport",
            |m: &CMsgSteamDatagramNoConnection| { &m.not_primary_transport },
            |m: &mut CMsgSteamDatagramNoConnection| { &mut m.not_primary_transport },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>(
            "quality_relay",
            |m: &CMsgSteamDatagramNoConnection| { &m.quality_relay },
            |m: &mut CMsgSteamDatagramNoConnection| { &mut m.quality_relay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>(
            "quality_e2e",
            |m: &CMsgSteamDatagramNoConnection| { &m.quality_e2e },
            |m: &mut CMsgSteamDatagramNoConnection| { &mut m.quality_e2e },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSteamDatagramP2PRoutingSummary>(
            "p2p_routing_summary",
            |m: &CMsgSteamDatagramNoConnection| { &m.p2p_routing_summary },
            |m: &mut CMsgSteamDatagramNoConnection| { &mut m.p2p_routing_summary },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "routing_secret",
            |m: &CMsgSteamDatagramNoConnection| { &m.routing_secret },
            |m: &mut CMsgSteamDatagramNoConnection| { &mut m.routing_secret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dummy_pad",
            |m: &CMsgSteamDatagramNoConnection| { &m.dummy_pad },
            |m: &mut CMsgSteamDatagramNoConnection| { &mut m.dummy_pad },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramNoConnection>(
            "CMsgSteamDatagramNoConnection",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramNoConnection {
    const NAME: &'static str = "CMsgSteamDatagramNoConnection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                45 => {
                    self.to_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                53 => {
                    self.from_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                16 => {
                    self.legacy_gameserver_relay_session_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                77 => {
                    self.to_relay_session_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                85 => {
                    self.from_relay_session_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                58 => {
                    self.from_identity_string = ::std::option::Option::Some(is.read_string()?);
                },
                25 => {
                    self.legacy_from_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                32 => {
                    self.end_to_end = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.not_primary_session = ::std::option::Option::Some(is.read_bool()?);
                },
                120 => {
                    self.not_primary_transport = ::std::option::Option::Some(is.read_bool()?);
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.quality_relay)?;
                },
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.quality_e2e)?;
                },
                130 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.p2p_routing_summary)?;
                },
                89 => {
                    self.routing_secret = ::std::option::Option::Some(is.read_fixed64()?);
                },
                8189 => {
                    self.dummy_pad = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.to_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.from_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.legacy_gameserver_relay_session_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.to_relay_session_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.from_relay_session_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.from_identity_string.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.legacy_from_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.end_to_end {
            my_size += 1 + 1;
        }
        if let Some(v) = self.not_primary_session {
            my_size += 1 + 1;
        }
        if let Some(v) = self.not_primary_transport {
            my_size += 1 + 1;
        }
        if let Some(v) = self.quality_relay.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.quality_e2e.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.p2p_routing_summary.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.routing_secret {
            my_size += 1 + 8;
        }
        if let Some(v) = self.dummy_pad {
            my_size += 2 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.to_connection_id {
            os.write_fixed32(5, v)?;
        }
        if let Some(v) = self.from_connection_id {
            os.write_fixed32(6, v)?;
        }
        if let Some(v) = self.legacy_gameserver_relay_session_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.to_relay_session_id {
            os.write_fixed32(9, v)?;
        }
        if let Some(v) = self.from_relay_session_id {
            os.write_fixed32(10, v)?;
        }
        if let Some(v) = self.from_identity_string.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.legacy_from_steam_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.end_to_end {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.not_primary_session {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.not_primary_transport {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.quality_relay.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.quality_e2e.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        if let Some(v) = self.p2p_routing_summary.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if let Some(v) = self.routing_secret {
            os.write_fixed64(11, v)?;
        }
        if let Some(v) = self.dummy_pad {
            os.write_fixed32(1023, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramNoConnection {
        CMsgSteamDatagramNoConnection::new()
    }

    fn clear(&mut self) {
        self.to_connection_id = ::std::option::Option::None;
        self.from_connection_id = ::std::option::Option::None;
        self.legacy_gameserver_relay_session_id = ::std::option::Option::None;
        self.to_relay_session_id = ::std::option::Option::None;
        self.from_relay_session_id = ::std::option::Option::None;
        self.from_identity_string = ::std::option::Option::None;
        self.legacy_from_steam_id = ::std::option::Option::None;
        self.end_to_end = ::std::option::Option::None;
        self.not_primary_session = ::std::option::Option::None;
        self.not_primary_transport = ::std::option::Option::None;
        self.quality_relay.clear();
        self.quality_e2e.clear();
        self.p2p_routing_summary.clear();
        self.routing_secret = ::std::option::Option::None;
        self.dummy_pad = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramNoConnection {
        static instance: CMsgSteamDatagramNoConnection = CMsgSteamDatagramNoConnection {
            to_connection_id: ::std::option::Option::None,
            from_connection_id: ::std::option::Option::None,
            legacy_gameserver_relay_session_id: ::std::option::Option::None,
            to_relay_session_id: ::std::option::Option::None,
            from_relay_session_id: ::std::option::Option::None,
            from_identity_string: ::std::option::Option::None,
            legacy_from_steam_id: ::std::option::Option::None,
            end_to_end: ::std::option::Option::None,
            not_primary_session: ::std::option::Option::None,
            not_primary_transport: ::std::option::Option::None,
            quality_relay: ::protobuf::MessageField::none(),
            quality_e2e: ::protobuf::MessageField::none(),
            p2p_routing_summary: ::protobuf::MessageField::none(),
            routing_secret: ::std::option::Option::None,
            dummy_pad: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramNoConnection {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramNoConnection").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramNoConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramNoConnection {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamDatagramGameserverSessionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramGameserverSessionRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverSessionRequest.ticket)
    pub ticket: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverSessionRequest.challenge_time)
    pub challenge_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverSessionRequest.challenge)
    pub challenge: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverSessionRequest.client_connection_id)
    pub client_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverSessionRequest.server_connection_id)
    pub server_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverSessionRequest.network_config_version)
    pub network_config_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverSessionRequest.protocol_version)
    pub protocol_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverSessionRequest.platform)
    pub platform: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverSessionRequest.build)
    pub build: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramGameserverSessionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramGameserverSessionRequest {
    fn default() -> &'a CMsgSteamDatagramGameserverSessionRequest {
        <CMsgSteamDatagramGameserverSessionRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramGameserverSessionRequest {
    pub fn new() -> CMsgSteamDatagramGameserverSessionRequest {
        ::std::default::Default::default()
    }

    // optional bytes ticket = 1;

    pub fn ticket(&self) -> &[u8] {
        match self.ticket.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_ticket(&mut self) {
        self.ticket = ::std::option::Option::None;
    }

    pub fn has_ticket(&self) -> bool {
        self.ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket(&mut self, v: ::std::vec::Vec<u8>) {
        self.ticket = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticket(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ticket.is_none() {
            self.ticket = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_ticket(&mut self) -> ::std::vec::Vec<u8> {
        self.ticket.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed32 challenge_time = 3;

    pub fn challenge_time(&self) -> u32 {
        self.challenge_time.unwrap_or(0)
    }

    pub fn clear_challenge_time(&mut self) {
        self.challenge_time = ::std::option::Option::None;
    }

    pub fn has_challenge_time(&self) -> bool {
        self.challenge_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_time(&mut self, v: u32) {
        self.challenge_time = ::std::option::Option::Some(v);
    }

    // optional fixed64 challenge = 4;

    pub fn challenge(&self) -> u64 {
        self.challenge.unwrap_or(0)
    }

    pub fn clear_challenge(&mut self) {
        self.challenge = ::std::option::Option::None;
    }

    pub fn has_challenge(&self) -> bool {
        self.challenge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge(&mut self, v: u64) {
        self.challenge = ::std::option::Option::Some(v);
    }

    // optional fixed32 client_connection_id = 5;

    pub fn client_connection_id(&self) -> u32 {
        self.client_connection_id.unwrap_or(0)
    }

    pub fn clear_client_connection_id(&mut self) {
        self.client_connection_id = ::std::option::Option::None;
    }

    pub fn has_client_connection_id(&self) -> bool {
        self.client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_connection_id(&mut self, v: u32) {
        self.client_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 server_connection_id = 8;

    pub fn server_connection_id(&self) -> u32 {
        self.server_connection_id.unwrap_or(0)
    }

    pub fn clear_server_connection_id(&mut self) {
        self.server_connection_id = ::std::option::Option::None;
    }

    pub fn has_server_connection_id(&self) -> bool {
        self.server_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_connection_id(&mut self, v: u32) {
        self.server_connection_id = ::std::option::Option::Some(v);
    }

    // optional uint32 network_config_version = 6;

    pub fn network_config_version(&self) -> u32 {
        self.network_config_version.unwrap_or(0)
    }

    pub fn clear_network_config_version(&mut self) {
        self.network_config_version = ::std::option::Option::None;
    }

    pub fn has_network_config_version(&self) -> bool {
        self.network_config_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_config_version(&mut self, v: u32) {
        self.network_config_version = ::std::option::Option::Some(v);
    }

    // optional uint32 protocol_version = 7;

    pub fn protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }

    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }

    // optional string platform = 9;

    pub fn platform(&self) -> &str {
        match self.platform.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_platform(&mut self) {
        self.platform = ::std::option::Option::None;
    }

    pub fn has_platform(&self) -> bool {
        self.platform.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform(&mut self, v: ::std::string::String) {
        self.platform = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_platform(&mut self) -> &mut ::std::string::String {
        if self.platform.is_none() {
            self.platform = ::std::option::Option::Some(::std::string::String::new());
        }
        self.platform.as_mut().unwrap()
    }

    // Take field
    pub fn take_platform(&mut self) -> ::std::string::String {
        self.platform.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string build = 10;

    pub fn build(&self) -> &str {
        match self.build.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_build(&mut self) {
        self.build = ::std::option::Option::None;
    }

    pub fn has_build(&self) -> bool {
        self.build.is_some()
    }

    // Param is passed by value, moved
    pub fn set_build(&mut self, v: ::std::string::String) {
        self.build = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_build(&mut self) -> &mut ::std::string::String {
        if self.build.is_none() {
            self.build = ::std::option::Option::Some(::std::string::String::new());
        }
        self.build.as_mut().unwrap()
    }

    // Take field
    pub fn take_build(&mut self) -> ::std::string::String {
        self.build.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ticket",
            |m: &CMsgSteamDatagramGameserverSessionRequest| { &m.ticket },
            |m: &mut CMsgSteamDatagramGameserverSessionRequest| { &mut m.ticket },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge_time",
            |m: &CMsgSteamDatagramGameserverSessionRequest| { &m.challenge_time },
            |m: &mut CMsgSteamDatagramGameserverSessionRequest| { &mut m.challenge_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge",
            |m: &CMsgSteamDatagramGameserverSessionRequest| { &m.challenge },
            |m: &mut CMsgSteamDatagramGameserverSessionRequest| { &mut m.challenge },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_connection_id",
            |m: &CMsgSteamDatagramGameserverSessionRequest| { &m.client_connection_id },
            |m: &mut CMsgSteamDatagramGameserverSessionRequest| { &mut m.client_connection_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_connection_id",
            |m: &CMsgSteamDatagramGameserverSessionRequest| { &m.server_connection_id },
            |m: &mut CMsgSteamDatagramGameserverSessionRequest| { &mut m.server_connection_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "network_config_version",
            |m: &CMsgSteamDatagramGameserverSessionRequest| { &m.network_config_version },
            |m: &mut CMsgSteamDatagramGameserverSessionRequest| { &mut m.network_config_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "protocol_version",
            |m: &CMsgSteamDatagramGameserverSessionRequest| { &m.protocol_version },
            |m: &mut CMsgSteamDatagramGameserverSessionRequest| { &mut m.protocol_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "platform",
            |m: &CMsgSteamDatagramGameserverSessionRequest| { &m.platform },
            |m: &mut CMsgSteamDatagramGameserverSessionRequest| { &mut m.platform },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "build",
            |m: &CMsgSteamDatagramGameserverSessionRequest| { &m.build },
            |m: &mut CMsgSteamDatagramGameserverSessionRequest| { &mut m.build },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramGameserverSessionRequest>(
            "CMsgSteamDatagramGameserverSessionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramGameserverSessionRequest {
    const NAME: &'static str = "CMsgSteamDatagramGameserverSessionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ticket = ::std::option::Option::Some(is.read_bytes()?);
                },
                29 => {
                    self.challenge_time = ::std::option::Option::Some(is.read_fixed32()?);
                },
                33 => {
                    self.challenge = ::std::option::Option::Some(is.read_fixed64()?);
                },
                45 => {
                    self.client_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                69 => {
                    self.server_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                48 => {
                    self.network_config_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.protocol_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                74 => {
                    self.platform = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.build = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ticket.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.challenge_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.challenge {
            my_size += 1 + 8;
        }
        if let Some(v) = self.client_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.network_config_version {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.protocol_version {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.platform.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.build.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ticket.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.challenge_time {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.challenge {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.client_connection_id {
            os.write_fixed32(5, v)?;
        }
        if let Some(v) = self.server_connection_id {
            os.write_fixed32(8, v)?;
        }
        if let Some(v) = self.network_config_version {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.protocol_version {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.platform.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.build.as_ref() {
            os.write_string(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramGameserverSessionRequest {
        CMsgSteamDatagramGameserverSessionRequest::new()
    }

    fn clear(&mut self) {
        self.ticket = ::std::option::Option::None;
        self.challenge_time = ::std::option::Option::None;
        self.challenge = ::std::option::Option::None;
        self.client_connection_id = ::std::option::Option::None;
        self.server_connection_id = ::std::option::Option::None;
        self.network_config_version = ::std::option::Option::None;
        self.protocol_version = ::std::option::Option::None;
        self.platform = ::std::option::Option::None;
        self.build = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramGameserverSessionRequest {
        static instance: CMsgSteamDatagramGameserverSessionRequest = CMsgSteamDatagramGameserverSessionRequest {
            ticket: ::std::option::Option::None,
            challenge_time: ::std::option::Option::None,
            challenge: ::std::option::Option::None,
            client_connection_id: ::std::option::Option::None,
            server_connection_id: ::std::option::Option::None,
            network_config_version: ::std::option::Option::None,
            protocol_version: ::std::option::Option::None,
            platform: ::std::option::Option::None,
            build: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramGameserverSessionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramGameserverSessionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramGameserverSessionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramGameserverSessionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamDatagramGameserverSessionEstablished)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramGameserverSessionEstablished {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverSessionEstablished.connection_id)
    pub connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverSessionEstablished.gameserver_identity_string)
    pub gameserver_identity_string: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverSessionEstablished.seconds_until_shutdown)
    pub seconds_until_shutdown: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverSessionEstablished.seq_num_r2c)
    pub seq_num_r2c: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverSessionEstablished.dummy_legacy_identity_binary)
    pub dummy_legacy_identity_binary: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverSessionEstablished.legacy_gameserver_steamid)
    pub legacy_gameserver_steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramGameserverSessionEstablished.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramGameserverSessionEstablished {
    fn default() -> &'a CMsgSteamDatagramGameserverSessionEstablished {
        <CMsgSteamDatagramGameserverSessionEstablished as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramGameserverSessionEstablished {
    pub fn new() -> CMsgSteamDatagramGameserverSessionEstablished {
        ::std::default::Default::default()
    }

    // optional fixed32 connection_id = 1;

    pub fn connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }

    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }

    // optional string gameserver_identity_string = 2;

    pub fn gameserver_identity_string(&self) -> &str {
        match self.gameserver_identity_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_gameserver_identity_string(&mut self) {
        self.gameserver_identity_string = ::std::option::Option::None;
    }

    pub fn has_gameserver_identity_string(&self) -> bool {
        self.gameserver_identity_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameserver_identity_string(&mut self, v: ::std::string::String) {
        self.gameserver_identity_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gameserver_identity_string(&mut self) -> &mut ::std::string::String {
        if self.gameserver_identity_string.is_none() {
            self.gameserver_identity_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.gameserver_identity_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_gameserver_identity_string(&mut self) -> ::std::string::String {
        self.gameserver_identity_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 seconds_until_shutdown = 4;

    pub fn seconds_until_shutdown(&self) -> u32 {
        self.seconds_until_shutdown.unwrap_or(0)
    }

    pub fn clear_seconds_until_shutdown(&mut self) {
        self.seconds_until_shutdown = ::std::option::Option::None;
    }

    pub fn has_seconds_until_shutdown(&self) -> bool {
        self.seconds_until_shutdown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_until_shutdown(&mut self, v: u32) {
        self.seconds_until_shutdown = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_r2c = 6;

    pub fn seq_num_r2c(&self) -> u32 {
        self.seq_num_r2c.unwrap_or(0)
    }

    pub fn clear_seq_num_r2c(&mut self) {
        self.seq_num_r2c = ::std::option::Option::None;
    }

    pub fn has_seq_num_r2c(&self) -> bool {
        self.seq_num_r2c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_r2c(&mut self, v: u32) {
        self.seq_num_r2c = ::std::option::Option::Some(v);
    }

    // optional bytes dummy_legacy_identity_binary = 7;

    pub fn dummy_legacy_identity_binary(&self) -> &[u8] {
        match self.dummy_legacy_identity_binary.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_dummy_legacy_identity_binary(&mut self) {
        self.dummy_legacy_identity_binary = ::std::option::Option::None;
    }

    pub fn has_dummy_legacy_identity_binary(&self) -> bool {
        self.dummy_legacy_identity_binary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy_legacy_identity_binary(&mut self, v: ::std::vec::Vec<u8>) {
        self.dummy_legacy_identity_binary = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dummy_legacy_identity_binary(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.dummy_legacy_identity_binary.is_none() {
            self.dummy_legacy_identity_binary = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.dummy_legacy_identity_binary.as_mut().unwrap()
    }

    // Take field
    pub fn take_dummy_legacy_identity_binary(&mut self) -> ::std::vec::Vec<u8> {
        self.dummy_legacy_identity_binary.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed64 legacy_gameserver_steamid = 3;

    pub fn legacy_gameserver_steamid(&self) -> u64 {
        self.legacy_gameserver_steamid.unwrap_or(0)
    }

    pub fn clear_legacy_gameserver_steamid(&mut self) {
        self.legacy_gameserver_steamid = ::std::option::Option::None;
    }

    pub fn has_legacy_gameserver_steamid(&self) -> bool {
        self.legacy_gameserver_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_gameserver_steamid(&mut self, v: u64) {
        self.legacy_gameserver_steamid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "connection_id",
            |m: &CMsgSteamDatagramGameserverSessionEstablished| { &m.connection_id },
            |m: &mut CMsgSteamDatagramGameserverSessionEstablished| { &mut m.connection_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gameserver_identity_string",
            |m: &CMsgSteamDatagramGameserverSessionEstablished| { &m.gameserver_identity_string },
            |m: &mut CMsgSteamDatagramGameserverSessionEstablished| { &mut m.gameserver_identity_string },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seconds_until_shutdown",
            |m: &CMsgSteamDatagramGameserverSessionEstablished| { &m.seconds_until_shutdown },
            |m: &mut CMsgSteamDatagramGameserverSessionEstablished| { &mut m.seconds_until_shutdown },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seq_num_r2c",
            |m: &CMsgSteamDatagramGameserverSessionEstablished| { &m.seq_num_r2c },
            |m: &mut CMsgSteamDatagramGameserverSessionEstablished| { &mut m.seq_num_r2c },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dummy_legacy_identity_binary",
            |m: &CMsgSteamDatagramGameserverSessionEstablished| { &m.dummy_legacy_identity_binary },
            |m: &mut CMsgSteamDatagramGameserverSessionEstablished| { &mut m.dummy_legacy_identity_binary },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "legacy_gameserver_steamid",
            |m: &CMsgSteamDatagramGameserverSessionEstablished| { &m.legacy_gameserver_steamid },
            |m: &mut CMsgSteamDatagramGameserverSessionEstablished| { &mut m.legacy_gameserver_steamid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramGameserverSessionEstablished>(
            "CMsgSteamDatagramGameserverSessionEstablished",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramGameserverSessionEstablished {
    const NAME: &'static str = "CMsgSteamDatagramGameserverSessionEstablished";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                18 => {
                    self.gameserver_identity_string = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.seconds_until_shutdown = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.seq_num_r2c = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.dummy_legacy_identity_binary = ::std::option::Option::Some(is.read_bytes()?);
                },
                25 => {
                    self.legacy_gameserver_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.gameserver_identity_string.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.seconds_until_shutdown {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.seq_num_r2c {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.dummy_legacy_identity_binary.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.legacy_gameserver_steamid {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.gameserver_identity_string.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.seconds_until_shutdown {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.seq_num_r2c {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.dummy_legacy_identity_binary.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.legacy_gameserver_steamid {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramGameserverSessionEstablished {
        CMsgSteamDatagramGameserverSessionEstablished::new()
    }

    fn clear(&mut self) {
        self.connection_id = ::std::option::Option::None;
        self.gameserver_identity_string = ::std::option::Option::None;
        self.seconds_until_shutdown = ::std::option::Option::None;
        self.seq_num_r2c = ::std::option::Option::None;
        self.dummy_legacy_identity_binary = ::std::option::Option::None;
        self.legacy_gameserver_steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramGameserverSessionEstablished {
        static instance: CMsgSteamDatagramGameserverSessionEstablished = CMsgSteamDatagramGameserverSessionEstablished {
            connection_id: ::std::option::Option::None,
            gameserver_identity_string: ::std::option::Option::None,
            seconds_until_shutdown: ::std::option::Option::None,
            seq_num_r2c: ::std::option::Option::None,
            dummy_legacy_identity_binary: ::std::option::Option::None,
            legacy_gameserver_steamid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramGameserverSessionEstablished {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramGameserverSessionEstablished").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramGameserverSessionEstablished {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramGameserverSessionEstablished {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamDatagramConnectionStatsClientToRouter)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramConnectionStatsClientToRouter {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsClientToRouter.quality_relay)
    pub quality_relay: ::protobuf::MessageField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsClientToRouter.quality_e2e)
    pub quality_e2e: ::protobuf::MessageField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsClientToRouter.ack_relay)
    pub ack_relay: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsClientToRouter.legacy_ack_e2e)
    pub legacy_ack_e2e: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsClientToRouter.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsClientToRouter.client_connection_id)
    pub client_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsClientToRouter.seq_num_c2r)
    pub seq_num_c2r: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsClientToRouter.seq_num_e2e)
    pub seq_num_e2e: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramConnectionStatsClientToRouter.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectionStatsClientToRouter {
    fn default() -> &'a CMsgSteamDatagramConnectionStatsClientToRouter {
        <CMsgSteamDatagramConnectionStatsClientToRouter as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectionStatsClientToRouter {
    pub fn new() -> CMsgSteamDatagramConnectionStatsClientToRouter {
        ::std::default::Default::default()
    }

    // optional uint32 flags = 6;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional fixed32 client_connection_id = 8;

    pub fn client_connection_id(&self) -> u32 {
        self.client_connection_id.unwrap_or(0)
    }

    pub fn clear_client_connection_id(&mut self) {
        self.client_connection_id = ::std::option::Option::None;
    }

    pub fn has_client_connection_id(&self) -> bool {
        self.client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_connection_id(&mut self, v: u32) {
        self.client_connection_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_c2r = 9;

    pub fn seq_num_c2r(&self) -> u32 {
        self.seq_num_c2r.unwrap_or(0)
    }

    pub fn clear_seq_num_c2r(&mut self) {
        self.seq_num_c2r = ::std::option::Option::None;
    }

    pub fn has_seq_num_c2r(&self) -> bool {
        self.seq_num_c2r.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_c2r(&mut self, v: u32) {
        self.seq_num_c2r = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_e2e = 10;

    pub fn seq_num_e2e(&self) -> u32 {
        self.seq_num_e2e.unwrap_or(0)
    }

    pub fn clear_seq_num_e2e(&mut self) {
        self.seq_num_e2e = ::std::option::Option::None;
    }

    pub fn has_seq_num_e2e(&self) -> bool {
        self.seq_num_e2e.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_e2e(&mut self, v: u32) {
        self.seq_num_e2e = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>(
            "quality_relay",
            |m: &CMsgSteamDatagramConnectionStatsClientToRouter| { &m.quality_relay },
            |m: &mut CMsgSteamDatagramConnectionStatsClientToRouter| { &mut m.quality_relay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>(
            "quality_e2e",
            |m: &CMsgSteamDatagramConnectionStatsClientToRouter| { &m.quality_e2e },
            |m: &mut CMsgSteamDatagramConnectionStatsClientToRouter| { &mut m.quality_e2e },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ack_relay",
            |m: &CMsgSteamDatagramConnectionStatsClientToRouter| { &m.ack_relay },
            |m: &mut CMsgSteamDatagramConnectionStatsClientToRouter| { &mut m.ack_relay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "legacy_ack_e2e",
            |m: &CMsgSteamDatagramConnectionStatsClientToRouter| { &m.legacy_ack_e2e },
            |m: &mut CMsgSteamDatagramConnectionStatsClientToRouter| { &mut m.legacy_ack_e2e },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CMsgSteamDatagramConnectionStatsClientToRouter| { &m.flags },
            |m: &mut CMsgSteamDatagramConnectionStatsClientToRouter| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_connection_id",
            |m: &CMsgSteamDatagramConnectionStatsClientToRouter| { &m.client_connection_id },
            |m: &mut CMsgSteamDatagramConnectionStatsClientToRouter| { &mut m.client_connection_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seq_num_c2r",
            |m: &CMsgSteamDatagramConnectionStatsClientToRouter| { &m.seq_num_c2r },
            |m: &mut CMsgSteamDatagramConnectionStatsClientToRouter| { &mut m.seq_num_c2r },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seq_num_e2e",
            |m: &CMsgSteamDatagramConnectionStatsClientToRouter| { &m.seq_num_e2e },
            |m: &mut CMsgSteamDatagramConnectionStatsClientToRouter| { &mut m.seq_num_e2e },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramConnectionStatsClientToRouter>(
            "CMsgSteamDatagramConnectionStatsClientToRouter",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramConnectionStatsClientToRouter {
    const NAME: &'static str = "CMsgSteamDatagramConnectionStatsClientToRouter";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.quality_relay)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.quality_e2e)?;
                },
                34 => {
                    is.read_repeated_packed_fixed32_into(&mut self.ack_relay)?;
                },
                37 => {
                    self.ack_relay.push(is.read_fixed32()?);
                },
                42 => {
                    is.read_repeated_packed_fixed32_into(&mut self.legacy_ack_e2e)?;
                },
                45 => {
                    self.legacy_ack_e2e.push(is.read_fixed32()?);
                },
                48 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                69 => {
                    self.client_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                72 => {
                    self.seq_num_c2r = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.seq_num_e2e = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quality_relay.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.quality_e2e.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += 5 * self.ack_relay.len() as u64;
        my_size += 5 * self.legacy_ack_e2e.len() as u64;
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.client_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.seq_num_c2r {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.seq_num_e2e {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.quality_relay.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.quality_e2e.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.ack_relay {
            os.write_fixed32(4, *v)?;
        };
        for v in &self.legacy_ack_e2e {
            os.write_fixed32(5, *v)?;
        };
        if let Some(v) = self.flags {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.client_connection_id {
            os.write_fixed32(8, v)?;
        }
        if let Some(v) = self.seq_num_c2r {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.seq_num_e2e {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramConnectionStatsClientToRouter {
        CMsgSteamDatagramConnectionStatsClientToRouter::new()
    }

    fn clear(&mut self) {
        self.quality_relay.clear();
        self.quality_e2e.clear();
        self.ack_relay.clear();
        self.legacy_ack_e2e.clear();
        self.flags = ::std::option::Option::None;
        self.client_connection_id = ::std::option::Option::None;
        self.seq_num_c2r = ::std::option::Option::None;
        self.seq_num_e2e = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectionStatsClientToRouter {
        static instance: CMsgSteamDatagramConnectionStatsClientToRouter = CMsgSteamDatagramConnectionStatsClientToRouter {
            quality_relay: ::protobuf::MessageField::none(),
            quality_e2e: ::protobuf::MessageField::none(),
            ack_relay: ::std::vec::Vec::new(),
            legacy_ack_e2e: ::std::vec::Vec::new(),
            flags: ::std::option::Option::None,
            client_connection_id: ::std::option::Option::None,
            seq_num_c2r: ::std::option::Option::None,
            seq_num_e2e: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramConnectionStatsClientToRouter {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramConnectionStatsClientToRouter").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramConnectionStatsClientToRouter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionStatsClientToRouter {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSteamDatagramConnectionStatsClientToRouter`
pub mod cmsg_steam_datagram_connection_stats_client_to_router {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgSteamDatagramConnectionStatsClientToRouter.Flags)
    pub enum Flags {
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsClientToRouter.Flags.ACK_REQUEST_RELAY)
        ACK_REQUEST_RELAY = 1,
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsClientToRouter.Flags.ACK_REQUEST_E2E)
        ACK_REQUEST_E2E = 2,
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsClientToRouter.Flags.ACK_REQUEST_IMMEDIATE)
        ACK_REQUEST_IMMEDIATE = 4,
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsClientToRouter.Flags.NOT_PRIMARY_SESSION)
        NOT_PRIMARY_SESSION = 8,
    }

    impl ::protobuf::Enum for Flags {
        const NAME: &'static str = "Flags";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Flags> {
            match value {
                1 => ::std::option::Option::Some(Flags::ACK_REQUEST_RELAY),
                2 => ::std::option::Option::Some(Flags::ACK_REQUEST_E2E),
                4 => ::std::option::Option::Some(Flags::ACK_REQUEST_IMMEDIATE),
                8 => ::std::option::Option::Some(Flags::NOT_PRIMARY_SESSION),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Flags> {
            match str {
                "ACK_REQUEST_RELAY" => ::std::option::Option::Some(Flags::ACK_REQUEST_RELAY),
                "ACK_REQUEST_E2E" => ::std::option::Option::Some(Flags::ACK_REQUEST_E2E),
                "ACK_REQUEST_IMMEDIATE" => ::std::option::Option::Some(Flags::ACK_REQUEST_IMMEDIATE),
                "NOT_PRIMARY_SESSION" => ::std::option::Option::Some(Flags::NOT_PRIMARY_SESSION),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Flags] = &[
            Flags::ACK_REQUEST_RELAY,
            Flags::ACK_REQUEST_E2E,
            Flags::ACK_REQUEST_IMMEDIATE,
            Flags::NOT_PRIMARY_SESSION,
        ];
    }

    impl ::protobuf::EnumFull for Flags {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgSteamDatagramConnectionStatsClientToRouter.Flags").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Flags::ACK_REQUEST_RELAY => 0,
                Flags::ACK_REQUEST_E2E => 1,
                Flags::ACK_REQUEST_IMMEDIATE => 2,
                Flags::NOT_PRIMARY_SESSION => 3,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Flags {
        fn default() -> Self {
            Flags::ACK_REQUEST_RELAY
        }
    }

    impl Flags {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Flags>("CMsgSteamDatagramConnectionStatsClientToRouter.Flags")
        }
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramConnectionStatsRouterToClient)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramConnectionStatsRouterToClient {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToClient.quality_relay)
    pub quality_relay: ::protobuf::MessageField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToClient.quality_e2e)
    pub quality_e2e: ::protobuf::MessageField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToClient.seconds_until_shutdown)
    pub seconds_until_shutdown: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToClient.migrate_request_ip)
    pub migrate_request_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToClient.migrate_request_port)
    pub migrate_request_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToClient.scoring_penalty_relay_cluster)
    pub scoring_penalty_relay_cluster: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToClient.ack_relay)
    pub ack_relay: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToClient.legacy_ack_e2e)
    pub legacy_ack_e2e: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToClient.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToClient.client_connection_id)
    pub client_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToClient.seq_num_r2c)
    pub seq_num_r2c: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToClient.seq_num_e2e)
    pub seq_num_e2e: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramConnectionStatsRouterToClient.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectionStatsRouterToClient {
    fn default() -> &'a CMsgSteamDatagramConnectionStatsRouterToClient {
        <CMsgSteamDatagramConnectionStatsRouterToClient as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectionStatsRouterToClient {
    pub fn new() -> CMsgSteamDatagramConnectionStatsRouterToClient {
        ::std::default::Default::default()
    }

    // optional uint32 seconds_until_shutdown = 6;

    pub fn seconds_until_shutdown(&self) -> u32 {
        self.seconds_until_shutdown.unwrap_or(0)
    }

    pub fn clear_seconds_until_shutdown(&mut self) {
        self.seconds_until_shutdown = ::std::option::Option::None;
    }

    pub fn has_seconds_until_shutdown(&self) -> bool {
        self.seconds_until_shutdown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_until_shutdown(&mut self, v: u32) {
        self.seconds_until_shutdown = ::std::option::Option::Some(v);
    }

    // optional fixed32 migrate_request_ip = 10;

    pub fn migrate_request_ip(&self) -> u32 {
        self.migrate_request_ip.unwrap_or(0)
    }

    pub fn clear_migrate_request_ip(&mut self) {
        self.migrate_request_ip = ::std::option::Option::None;
    }

    pub fn has_migrate_request_ip(&self) -> bool {
        self.migrate_request_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_migrate_request_ip(&mut self, v: u32) {
        self.migrate_request_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 migrate_request_port = 11;

    pub fn migrate_request_port(&self) -> u32 {
        self.migrate_request_port.unwrap_or(0)
    }

    pub fn clear_migrate_request_port(&mut self) {
        self.migrate_request_port = ::std::option::Option::None;
    }

    pub fn has_migrate_request_port(&self) -> bool {
        self.migrate_request_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_migrate_request_port(&mut self, v: u32) {
        self.migrate_request_port = ::std::option::Option::Some(v);
    }

    // optional uint32 scoring_penalty_relay_cluster = 12;

    pub fn scoring_penalty_relay_cluster(&self) -> u32 {
        self.scoring_penalty_relay_cluster.unwrap_or(0)
    }

    pub fn clear_scoring_penalty_relay_cluster(&mut self) {
        self.scoring_penalty_relay_cluster = ::std::option::Option::None;
    }

    pub fn has_scoring_penalty_relay_cluster(&self) -> bool {
        self.scoring_penalty_relay_cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scoring_penalty_relay_cluster(&mut self, v: u32) {
        self.scoring_penalty_relay_cluster = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 15;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional fixed32 client_connection_id = 7;

    pub fn client_connection_id(&self) -> u32 {
        self.client_connection_id.unwrap_or(0)
    }

    pub fn clear_client_connection_id(&mut self) {
        self.client_connection_id = ::std::option::Option::None;
    }

    pub fn has_client_connection_id(&self) -> bool {
        self.client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_connection_id(&mut self, v: u32) {
        self.client_connection_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_r2c = 8;

    pub fn seq_num_r2c(&self) -> u32 {
        self.seq_num_r2c.unwrap_or(0)
    }

    pub fn clear_seq_num_r2c(&mut self) {
        self.seq_num_r2c = ::std::option::Option::None;
    }

    pub fn has_seq_num_r2c(&self) -> bool {
        self.seq_num_r2c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_r2c(&mut self, v: u32) {
        self.seq_num_r2c = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_e2e = 9;

    pub fn seq_num_e2e(&self) -> u32 {
        self.seq_num_e2e.unwrap_or(0)
    }

    pub fn clear_seq_num_e2e(&mut self) {
        self.seq_num_e2e = ::std::option::Option::None;
    }

    pub fn has_seq_num_e2e(&self) -> bool {
        self.seq_num_e2e.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_e2e(&mut self, v: u32) {
        self.seq_num_e2e = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>(
            "quality_relay",
            |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.quality_relay },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.quality_relay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>(
            "quality_e2e",
            |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.quality_e2e },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.quality_e2e },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seconds_until_shutdown",
            |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.seconds_until_shutdown },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.seconds_until_shutdown },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "migrate_request_ip",
            |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.migrate_request_ip },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.migrate_request_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "migrate_request_port",
            |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.migrate_request_port },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.migrate_request_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scoring_penalty_relay_cluster",
            |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.scoring_penalty_relay_cluster },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.scoring_penalty_relay_cluster },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ack_relay",
            |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.ack_relay },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.ack_relay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "legacy_ack_e2e",
            |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.legacy_ack_e2e },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.legacy_ack_e2e },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.flags },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_connection_id",
            |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.client_connection_id },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.client_connection_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seq_num_r2c",
            |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.seq_num_r2c },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.seq_num_r2c },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seq_num_e2e",
            |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.seq_num_e2e },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.seq_num_e2e },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramConnectionStatsRouterToClient>(
            "CMsgSteamDatagramConnectionStatsRouterToClient",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramConnectionStatsRouterToClient {
    const NAME: &'static str = "CMsgSteamDatagramConnectionStatsRouterToClient";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.quality_relay)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.quality_e2e)?;
                },
                48 => {
                    self.seconds_until_shutdown = ::std::option::Option::Some(is.read_uint32()?);
                },
                85 => {
                    self.migrate_request_ip = ::std::option::Option::Some(is.read_fixed32()?);
                },
                88 => {
                    self.migrate_request_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.scoring_penalty_relay_cluster = ::std::option::Option::Some(is.read_uint32()?);
                },
                106 => {
                    is.read_repeated_packed_fixed32_into(&mut self.ack_relay)?;
                },
                109 => {
                    self.ack_relay.push(is.read_fixed32()?);
                },
                114 => {
                    is.read_repeated_packed_fixed32_into(&mut self.legacy_ack_e2e)?;
                },
                117 => {
                    self.legacy_ack_e2e.push(is.read_fixed32()?);
                },
                120 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                61 => {
                    self.client_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                64 => {
                    self.seq_num_r2c = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.seq_num_e2e = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quality_relay.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.quality_e2e.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.seconds_until_shutdown {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.migrate_request_ip {
            my_size += 1 + 4;
        }
        if let Some(v) = self.migrate_request_port {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.scoring_penalty_relay_cluster {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        my_size += 5 * self.ack_relay.len() as u64;
        my_size += 5 * self.legacy_ack_e2e.len() as u64;
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.client_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.seq_num_r2c {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.seq_num_e2e {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.quality_relay.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.quality_e2e.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.seconds_until_shutdown {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.migrate_request_ip {
            os.write_fixed32(10, v)?;
        }
        if let Some(v) = self.migrate_request_port {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.scoring_penalty_relay_cluster {
            os.write_uint32(12, v)?;
        }
        for v in &self.ack_relay {
            os.write_fixed32(13, *v)?;
        };
        for v in &self.legacy_ack_e2e {
            os.write_fixed32(14, *v)?;
        };
        if let Some(v) = self.flags {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.client_connection_id {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.seq_num_r2c {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.seq_num_e2e {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramConnectionStatsRouterToClient {
        CMsgSteamDatagramConnectionStatsRouterToClient::new()
    }

    fn clear(&mut self) {
        self.quality_relay.clear();
        self.quality_e2e.clear();
        self.seconds_until_shutdown = ::std::option::Option::None;
        self.migrate_request_ip = ::std::option::Option::None;
        self.migrate_request_port = ::std::option::Option::None;
        self.scoring_penalty_relay_cluster = ::std::option::Option::None;
        self.ack_relay.clear();
        self.legacy_ack_e2e.clear();
        self.flags = ::std::option::Option::None;
        self.client_connection_id = ::std::option::Option::None;
        self.seq_num_r2c = ::std::option::Option::None;
        self.seq_num_e2e = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectionStatsRouterToClient {
        static instance: CMsgSteamDatagramConnectionStatsRouterToClient = CMsgSteamDatagramConnectionStatsRouterToClient {
            quality_relay: ::protobuf::MessageField::none(),
            quality_e2e: ::protobuf::MessageField::none(),
            seconds_until_shutdown: ::std::option::Option::None,
            migrate_request_ip: ::std::option::Option::None,
            migrate_request_port: ::std::option::Option::None,
            scoring_penalty_relay_cluster: ::std::option::Option::None,
            ack_relay: ::std::vec::Vec::new(),
            legacy_ack_e2e: ::std::vec::Vec::new(),
            flags: ::std::option::Option::None,
            client_connection_id: ::std::option::Option::None,
            seq_num_r2c: ::std::option::Option::None,
            seq_num_e2e: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramConnectionStatsRouterToClient {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramConnectionStatsRouterToClient").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramConnectionStatsRouterToClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionStatsRouterToClient {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSteamDatagramConnectionStatsRouterToClient`
pub mod cmsg_steam_datagram_connection_stats_router_to_client {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgSteamDatagramConnectionStatsRouterToClient.Flags)
    pub enum Flags {
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsRouterToClient.Flags.ACK_REQUEST_RELAY)
        ACK_REQUEST_RELAY = 1,
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsRouterToClient.Flags.ACK_REQUEST_E2E)
        ACK_REQUEST_E2E = 2,
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsRouterToClient.Flags.ACK_REQUEST_IMMEDIATE)
        ACK_REQUEST_IMMEDIATE = 4,
    }

    impl ::protobuf::Enum for Flags {
        const NAME: &'static str = "Flags";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Flags> {
            match value {
                1 => ::std::option::Option::Some(Flags::ACK_REQUEST_RELAY),
                2 => ::std::option::Option::Some(Flags::ACK_REQUEST_E2E),
                4 => ::std::option::Option::Some(Flags::ACK_REQUEST_IMMEDIATE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Flags> {
            match str {
                "ACK_REQUEST_RELAY" => ::std::option::Option::Some(Flags::ACK_REQUEST_RELAY),
                "ACK_REQUEST_E2E" => ::std::option::Option::Some(Flags::ACK_REQUEST_E2E),
                "ACK_REQUEST_IMMEDIATE" => ::std::option::Option::Some(Flags::ACK_REQUEST_IMMEDIATE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Flags] = &[
            Flags::ACK_REQUEST_RELAY,
            Flags::ACK_REQUEST_E2E,
            Flags::ACK_REQUEST_IMMEDIATE,
        ];
    }

    impl ::protobuf::EnumFull for Flags {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgSteamDatagramConnectionStatsRouterToClient.Flags").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Flags::ACK_REQUEST_RELAY => 0,
                Flags::ACK_REQUEST_E2E => 1,
                Flags::ACK_REQUEST_IMMEDIATE => 2,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Flags {
        fn default() -> Self {
            Flags::ACK_REQUEST_RELAY
        }
    }

    impl Flags {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Flags>("CMsgSteamDatagramConnectionStatsRouterToClient.Flags")
        }
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramConnectionStatsRouterToServer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramConnectionStatsRouterToServer {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToServer.quality_relay)
    pub quality_relay: ::protobuf::MessageField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToServer.quality_e2e)
    pub quality_e2e: ::protobuf::MessageField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToServer.ack_relay)
    pub ack_relay: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToServer.legacy_ack_e2e)
    pub legacy_ack_e2e: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToServer.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToServer.seq_num_r2s)
    pub seq_num_r2s: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToServer.seq_num_e2e)
    pub seq_num_e2e: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToServer.client_identity_string)
    pub client_identity_string: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToServer.legacy_client_steam_id)
    pub legacy_client_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToServer.relay_session_id)
    pub relay_session_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToServer.client_connection_id)
    pub client_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToServer.server_connection_id)
    pub server_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToServer.routing_secret)
    pub routing_secret: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramConnectionStatsRouterToServer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectionStatsRouterToServer {
    fn default() -> &'a CMsgSteamDatagramConnectionStatsRouterToServer {
        <CMsgSteamDatagramConnectionStatsRouterToServer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectionStatsRouterToServer {
    pub fn new() -> CMsgSteamDatagramConnectionStatsRouterToServer {
        ::std::default::Default::default()
    }

    // optional uint32 flags = 12;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_r2s = 5;

    pub fn seq_num_r2s(&self) -> u32 {
        self.seq_num_r2s.unwrap_or(0)
    }

    pub fn clear_seq_num_r2s(&mut self) {
        self.seq_num_r2s = ::std::option::Option::None;
    }

    pub fn has_seq_num_r2s(&self) -> bool {
        self.seq_num_r2s.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_r2s(&mut self, v: u32) {
        self.seq_num_r2s = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_e2e = 6;

    pub fn seq_num_e2e(&self) -> u32 {
        self.seq_num_e2e.unwrap_or(0)
    }

    pub fn clear_seq_num_e2e(&mut self) {
        self.seq_num_e2e = ::std::option::Option::None;
    }

    pub fn has_seq_num_e2e(&self) -> bool {
        self.seq_num_e2e.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_e2e(&mut self, v: u32) {
        self.seq_num_e2e = ::std::option::Option::Some(v);
    }

    // optional string client_identity_string = 15;

    pub fn client_identity_string(&self) -> &str {
        match self.client_identity_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_client_identity_string(&mut self) {
        self.client_identity_string = ::std::option::Option::None;
    }

    pub fn has_client_identity_string(&self) -> bool {
        self.client_identity_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_identity_string(&mut self, v: ::std::string::String) {
        self.client_identity_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_identity_string(&mut self) -> &mut ::std::string::String {
        if self.client_identity_string.is_none() {
            self.client_identity_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.client_identity_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_client_identity_string(&mut self) -> ::std::string::String {
        self.client_identity_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 legacy_client_steam_id = 7;

    pub fn legacy_client_steam_id(&self) -> u64 {
        self.legacy_client_steam_id.unwrap_or(0)
    }

    pub fn clear_legacy_client_steam_id(&mut self) {
        self.legacy_client_steam_id = ::std::option::Option::None;
    }

    pub fn has_legacy_client_steam_id(&self) -> bool {
        self.legacy_client_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_client_steam_id(&mut self, v: u64) {
        self.legacy_client_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 relay_session_id = 8;

    pub fn relay_session_id(&self) -> u32 {
        self.relay_session_id.unwrap_or(0)
    }

    pub fn clear_relay_session_id(&mut self) {
        self.relay_session_id = ::std::option::Option::None;
    }

    pub fn has_relay_session_id(&self) -> bool {
        self.relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relay_session_id(&mut self, v: u32) {
        self.relay_session_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 client_connection_id = 9;

    pub fn client_connection_id(&self) -> u32 {
        self.client_connection_id.unwrap_or(0)
    }

    pub fn clear_client_connection_id(&mut self) {
        self.client_connection_id = ::std::option::Option::None;
    }

    pub fn has_client_connection_id(&self) -> bool {
        self.client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_connection_id(&mut self, v: u32) {
        self.client_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 server_connection_id = 13;

    pub fn server_connection_id(&self) -> u32 {
        self.server_connection_id.unwrap_or(0)
    }

    pub fn clear_server_connection_id(&mut self) {
        self.server_connection_id = ::std::option::Option::None;
    }

    pub fn has_server_connection_id(&self) -> bool {
        self.server_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_connection_id(&mut self, v: u32) {
        self.server_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 routing_secret = 14;

    pub fn routing_secret(&self) -> u64 {
        self.routing_secret.unwrap_or(0)
    }

    pub fn clear_routing_secret(&mut self) {
        self.routing_secret = ::std::option::Option::None;
    }

    pub fn has_routing_secret(&self) -> bool {
        self.routing_secret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_routing_secret(&mut self, v: u64) {
        self.routing_secret = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>(
            "quality_relay",
            |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.quality_relay },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.quality_relay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>(
            "quality_e2e",
            |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.quality_e2e },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.quality_e2e },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ack_relay",
            |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.ack_relay },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.ack_relay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "legacy_ack_e2e",
            |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.legacy_ack_e2e },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.legacy_ack_e2e },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.flags },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seq_num_r2s",
            |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.seq_num_r2s },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.seq_num_r2s },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seq_num_e2e",
            |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.seq_num_e2e },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.seq_num_e2e },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_identity_string",
            |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.client_identity_string },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.client_identity_string },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "legacy_client_steam_id",
            |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.legacy_client_steam_id },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.legacy_client_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "relay_session_id",
            |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.relay_session_id },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.relay_session_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_connection_id",
            |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.client_connection_id },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.client_connection_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_connection_id",
            |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.server_connection_id },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.server_connection_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "routing_secret",
            |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.routing_secret },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.routing_secret },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramConnectionStatsRouterToServer>(
            "CMsgSteamDatagramConnectionStatsRouterToServer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramConnectionStatsRouterToServer {
    const NAME: &'static str = "CMsgSteamDatagramConnectionStatsRouterToServer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.quality_relay)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.quality_e2e)?;
                },
                82 => {
                    is.read_repeated_packed_fixed32_into(&mut self.ack_relay)?;
                },
                85 => {
                    self.ack_relay.push(is.read_fixed32()?);
                },
                90 => {
                    is.read_repeated_packed_fixed32_into(&mut self.legacy_ack_e2e)?;
                },
                93 => {
                    self.legacy_ack_e2e.push(is.read_fixed32()?);
                },
                96 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.seq_num_r2s = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.seq_num_e2e = ::std::option::Option::Some(is.read_uint32()?);
                },
                122 => {
                    self.client_identity_string = ::std::option::Option::Some(is.read_string()?);
                },
                57 => {
                    self.legacy_client_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                64 => {
                    self.relay_session_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                77 => {
                    self.client_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                109 => {
                    self.server_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                113 => {
                    self.routing_secret = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quality_relay.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.quality_e2e.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += 5 * self.ack_relay.len() as u64;
        my_size += 5 * self.legacy_ack_e2e.len() as u64;
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.seq_num_r2s {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.seq_num_e2e {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.client_identity_string.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.legacy_client_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.relay_session_id {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.client_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.routing_secret {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.quality_relay.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.quality_e2e.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.ack_relay {
            os.write_fixed32(10, *v)?;
        };
        for v in &self.legacy_ack_e2e {
            os.write_fixed32(11, *v)?;
        };
        if let Some(v) = self.flags {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.seq_num_r2s {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.seq_num_e2e {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.client_identity_string.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.legacy_client_steam_id {
            os.write_fixed64(7, v)?;
        }
        if let Some(v) = self.relay_session_id {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.client_connection_id {
            os.write_fixed32(9, v)?;
        }
        if let Some(v) = self.server_connection_id {
            os.write_fixed32(13, v)?;
        }
        if let Some(v) = self.routing_secret {
            os.write_fixed64(14, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramConnectionStatsRouterToServer {
        CMsgSteamDatagramConnectionStatsRouterToServer::new()
    }

    fn clear(&mut self) {
        self.quality_relay.clear();
        self.quality_e2e.clear();
        self.ack_relay.clear();
        self.legacy_ack_e2e.clear();
        self.flags = ::std::option::Option::None;
        self.seq_num_r2s = ::std::option::Option::None;
        self.seq_num_e2e = ::std::option::Option::None;
        self.client_identity_string = ::std::option::Option::None;
        self.legacy_client_steam_id = ::std::option::Option::None;
        self.relay_session_id = ::std::option::Option::None;
        self.client_connection_id = ::std::option::Option::None;
        self.server_connection_id = ::std::option::Option::None;
        self.routing_secret = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectionStatsRouterToServer {
        static instance: CMsgSteamDatagramConnectionStatsRouterToServer = CMsgSteamDatagramConnectionStatsRouterToServer {
            quality_relay: ::protobuf::MessageField::none(),
            quality_e2e: ::protobuf::MessageField::none(),
            ack_relay: ::std::vec::Vec::new(),
            legacy_ack_e2e: ::std::vec::Vec::new(),
            flags: ::std::option::Option::None,
            seq_num_r2s: ::std::option::Option::None,
            seq_num_e2e: ::std::option::Option::None,
            client_identity_string: ::std::option::Option::None,
            legacy_client_steam_id: ::std::option::Option::None,
            relay_session_id: ::std::option::Option::None,
            client_connection_id: ::std::option::Option::None,
            server_connection_id: ::std::option::Option::None,
            routing_secret: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramConnectionStatsRouterToServer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramConnectionStatsRouterToServer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramConnectionStatsRouterToServer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionStatsRouterToServer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSteamDatagramConnectionStatsRouterToServer`
pub mod cmsg_steam_datagram_connection_stats_router_to_server {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgSteamDatagramConnectionStatsRouterToServer.Flags)
    pub enum Flags {
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsRouterToServer.Flags.ACK_REQUEST_RELAY)
        ACK_REQUEST_RELAY = 1,
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsRouterToServer.Flags.ACK_REQUEST_E2E)
        ACK_REQUEST_E2E = 2,
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsRouterToServer.Flags.ACK_REQUEST_IMMEDIATE)
        ACK_REQUEST_IMMEDIATE = 4,
    }

    impl ::protobuf::Enum for Flags {
        const NAME: &'static str = "Flags";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Flags> {
            match value {
                1 => ::std::option::Option::Some(Flags::ACK_REQUEST_RELAY),
                2 => ::std::option::Option::Some(Flags::ACK_REQUEST_E2E),
                4 => ::std::option::Option::Some(Flags::ACK_REQUEST_IMMEDIATE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Flags> {
            match str {
                "ACK_REQUEST_RELAY" => ::std::option::Option::Some(Flags::ACK_REQUEST_RELAY),
                "ACK_REQUEST_E2E" => ::std::option::Option::Some(Flags::ACK_REQUEST_E2E),
                "ACK_REQUEST_IMMEDIATE" => ::std::option::Option::Some(Flags::ACK_REQUEST_IMMEDIATE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Flags] = &[
            Flags::ACK_REQUEST_RELAY,
            Flags::ACK_REQUEST_E2E,
            Flags::ACK_REQUEST_IMMEDIATE,
        ];
    }

    impl ::protobuf::EnumFull for Flags {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgSteamDatagramConnectionStatsRouterToServer.Flags").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Flags::ACK_REQUEST_RELAY => 0,
                Flags::ACK_REQUEST_E2E => 1,
                Flags::ACK_REQUEST_IMMEDIATE => 2,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Flags {
        fn default() -> Self {
            Flags::ACK_REQUEST_RELAY
        }
    }

    impl Flags {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Flags>("CMsgSteamDatagramConnectionStatsRouterToServer.Flags")
        }
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramConnectionStatsServerToRouter)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramConnectionStatsServerToRouter {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsServerToRouter.quality_relay)
    pub quality_relay: ::protobuf::MessageField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsServerToRouter.quality_e2e)
    pub quality_e2e: ::protobuf::MessageField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsServerToRouter.ack_relay)
    pub ack_relay: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsServerToRouter.legacy_ack_e2e)
    pub legacy_ack_e2e: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsServerToRouter.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsServerToRouter.seq_num_s2r)
    pub seq_num_s2r: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsServerToRouter.seq_num_e2e)
    pub seq_num_e2e: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsServerToRouter.relay_session_id)
    pub relay_session_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsServerToRouter.client_connection_id)
    pub client_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsServerToRouter.server_connection_id)
    pub server_connection_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramConnectionStatsServerToRouter.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectionStatsServerToRouter {
    fn default() -> &'a CMsgSteamDatagramConnectionStatsServerToRouter {
        <CMsgSteamDatagramConnectionStatsServerToRouter as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectionStatsServerToRouter {
    pub fn new() -> CMsgSteamDatagramConnectionStatsServerToRouter {
        ::std::default::Default::default()
    }

    // optional uint32 flags = 10;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_s2r = 3;

    pub fn seq_num_s2r(&self) -> u32 {
        self.seq_num_s2r.unwrap_or(0)
    }

    pub fn clear_seq_num_s2r(&mut self) {
        self.seq_num_s2r = ::std::option::Option::None;
    }

    pub fn has_seq_num_s2r(&self) -> bool {
        self.seq_num_s2r.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_s2r(&mut self, v: u32) {
        self.seq_num_s2r = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_e2e = 4;

    pub fn seq_num_e2e(&self) -> u32 {
        self.seq_num_e2e.unwrap_or(0)
    }

    pub fn clear_seq_num_e2e(&mut self) {
        self.seq_num_e2e = ::std::option::Option::None;
    }

    pub fn has_seq_num_e2e(&self) -> bool {
        self.seq_num_e2e.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_e2e(&mut self, v: u32) {
        self.seq_num_e2e = ::std::option::Option::Some(v);
    }

    // optional uint32 relay_session_id = 6;

    pub fn relay_session_id(&self) -> u32 {
        self.relay_session_id.unwrap_or(0)
    }

    pub fn clear_relay_session_id(&mut self) {
        self.relay_session_id = ::std::option::Option::None;
    }

    pub fn has_relay_session_id(&self) -> bool {
        self.relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relay_session_id(&mut self, v: u32) {
        self.relay_session_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 client_connection_id = 7;

    pub fn client_connection_id(&self) -> u32 {
        self.client_connection_id.unwrap_or(0)
    }

    pub fn clear_client_connection_id(&mut self) {
        self.client_connection_id = ::std::option::Option::None;
    }

    pub fn has_client_connection_id(&self) -> bool {
        self.client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_connection_id(&mut self, v: u32) {
        self.client_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 server_connection_id = 11;

    pub fn server_connection_id(&self) -> u32 {
        self.server_connection_id.unwrap_or(0)
    }

    pub fn clear_server_connection_id(&mut self) {
        self.server_connection_id = ::std::option::Option::None;
    }

    pub fn has_server_connection_id(&self) -> bool {
        self.server_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_connection_id(&mut self, v: u32) {
        self.server_connection_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>(
            "quality_relay",
            |m: &CMsgSteamDatagramConnectionStatsServerToRouter| { &m.quality_relay },
            |m: &mut CMsgSteamDatagramConnectionStatsServerToRouter| { &mut m.quality_relay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>(
            "quality_e2e",
            |m: &CMsgSteamDatagramConnectionStatsServerToRouter| { &m.quality_e2e },
            |m: &mut CMsgSteamDatagramConnectionStatsServerToRouter| { &mut m.quality_e2e },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ack_relay",
            |m: &CMsgSteamDatagramConnectionStatsServerToRouter| { &m.ack_relay },
            |m: &mut CMsgSteamDatagramConnectionStatsServerToRouter| { &mut m.ack_relay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "legacy_ack_e2e",
            |m: &CMsgSteamDatagramConnectionStatsServerToRouter| { &m.legacy_ack_e2e },
            |m: &mut CMsgSteamDatagramConnectionStatsServerToRouter| { &mut m.legacy_ack_e2e },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CMsgSteamDatagramConnectionStatsServerToRouter| { &m.flags },
            |m: &mut CMsgSteamDatagramConnectionStatsServerToRouter| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seq_num_s2r",
            |m: &CMsgSteamDatagramConnectionStatsServerToRouter| { &m.seq_num_s2r },
            |m: &mut CMsgSteamDatagramConnectionStatsServerToRouter| { &mut m.seq_num_s2r },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seq_num_e2e",
            |m: &CMsgSteamDatagramConnectionStatsServerToRouter| { &m.seq_num_e2e },
            |m: &mut CMsgSteamDatagramConnectionStatsServerToRouter| { &mut m.seq_num_e2e },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "relay_session_id",
            |m: &CMsgSteamDatagramConnectionStatsServerToRouter| { &m.relay_session_id },
            |m: &mut CMsgSteamDatagramConnectionStatsServerToRouter| { &mut m.relay_session_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_connection_id",
            |m: &CMsgSteamDatagramConnectionStatsServerToRouter| { &m.client_connection_id },
            |m: &mut CMsgSteamDatagramConnectionStatsServerToRouter| { &mut m.client_connection_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_connection_id",
            |m: &CMsgSteamDatagramConnectionStatsServerToRouter| { &m.server_connection_id },
            |m: &mut CMsgSteamDatagramConnectionStatsServerToRouter| { &mut m.server_connection_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramConnectionStatsServerToRouter>(
            "CMsgSteamDatagramConnectionStatsServerToRouter",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramConnectionStatsServerToRouter {
    const NAME: &'static str = "CMsgSteamDatagramConnectionStatsServerToRouter";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.quality_relay)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.quality_e2e)?;
                },
                66 => {
                    is.read_repeated_packed_fixed32_into(&mut self.ack_relay)?;
                },
                69 => {
                    self.ack_relay.push(is.read_fixed32()?);
                },
                74 => {
                    is.read_repeated_packed_fixed32_into(&mut self.legacy_ack_e2e)?;
                },
                77 => {
                    self.legacy_ack_e2e.push(is.read_fixed32()?);
                },
                80 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.seq_num_s2r = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.seq_num_e2e = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.relay_session_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                61 => {
                    self.client_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                93 => {
                    self.server_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quality_relay.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.quality_e2e.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += 5 * self.ack_relay.len() as u64;
        my_size += 5 * self.legacy_ack_e2e.len() as u64;
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.seq_num_s2r {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.seq_num_e2e {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.relay_session_id {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.client_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_connection_id {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.quality_relay.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.quality_e2e.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.ack_relay {
            os.write_fixed32(8, *v)?;
        };
        for v in &self.legacy_ack_e2e {
            os.write_fixed32(9, *v)?;
        };
        if let Some(v) = self.flags {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.seq_num_s2r {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.seq_num_e2e {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.relay_session_id {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.client_connection_id {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.server_connection_id {
            os.write_fixed32(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramConnectionStatsServerToRouter {
        CMsgSteamDatagramConnectionStatsServerToRouter::new()
    }

    fn clear(&mut self) {
        self.quality_relay.clear();
        self.quality_e2e.clear();
        self.ack_relay.clear();
        self.legacy_ack_e2e.clear();
        self.flags = ::std::option::Option::None;
        self.seq_num_s2r = ::std::option::Option::None;
        self.seq_num_e2e = ::std::option::Option::None;
        self.relay_session_id = ::std::option::Option::None;
        self.client_connection_id = ::std::option::Option::None;
        self.server_connection_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectionStatsServerToRouter {
        static instance: CMsgSteamDatagramConnectionStatsServerToRouter = CMsgSteamDatagramConnectionStatsServerToRouter {
            quality_relay: ::protobuf::MessageField::none(),
            quality_e2e: ::protobuf::MessageField::none(),
            ack_relay: ::std::vec::Vec::new(),
            legacy_ack_e2e: ::std::vec::Vec::new(),
            flags: ::std::option::Option::None,
            seq_num_s2r: ::std::option::Option::None,
            seq_num_e2e: ::std::option::Option::None,
            relay_session_id: ::std::option::Option::None,
            client_connection_id: ::std::option::Option::None,
            server_connection_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramConnectionStatsServerToRouter {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramConnectionStatsServerToRouter").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramConnectionStatsServerToRouter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionStatsServerToRouter {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSteamDatagramConnectionStatsServerToRouter`
pub mod cmsg_steam_datagram_connection_stats_server_to_router {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgSteamDatagramConnectionStatsServerToRouter.Flags)
    pub enum Flags {
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsServerToRouter.Flags.ACK_REQUEST_RELAY)
        ACK_REQUEST_RELAY = 1,
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsServerToRouter.Flags.ACK_REQUEST_E2E)
        ACK_REQUEST_E2E = 2,
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsServerToRouter.Flags.ACK_REQUEST_IMMEDIATE)
        ACK_REQUEST_IMMEDIATE = 4,
    }

    impl ::protobuf::Enum for Flags {
        const NAME: &'static str = "Flags";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Flags> {
            match value {
                1 => ::std::option::Option::Some(Flags::ACK_REQUEST_RELAY),
                2 => ::std::option::Option::Some(Flags::ACK_REQUEST_E2E),
                4 => ::std::option::Option::Some(Flags::ACK_REQUEST_IMMEDIATE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Flags> {
            match str {
                "ACK_REQUEST_RELAY" => ::std::option::Option::Some(Flags::ACK_REQUEST_RELAY),
                "ACK_REQUEST_E2E" => ::std::option::Option::Some(Flags::ACK_REQUEST_E2E),
                "ACK_REQUEST_IMMEDIATE" => ::std::option::Option::Some(Flags::ACK_REQUEST_IMMEDIATE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Flags] = &[
            Flags::ACK_REQUEST_RELAY,
            Flags::ACK_REQUEST_E2E,
            Flags::ACK_REQUEST_IMMEDIATE,
        ];
    }

    impl ::protobuf::EnumFull for Flags {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgSteamDatagramConnectionStatsServerToRouter.Flags").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Flags::ACK_REQUEST_RELAY => 0,
                Flags::ACK_REQUEST_E2E => 1,
                Flags::ACK_REQUEST_IMMEDIATE => 2,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Flags {
        fn default() -> Self {
            Flags::ACK_REQUEST_RELAY
        }
    }

    impl Flags {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Flags>("CMsgSteamDatagramConnectionStatsServerToRouter.Flags")
        }
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramP2PSessionRequestBody)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramP2PSessionRequestBody {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PSessionRequestBody.challenge_time)
    pub challenge_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PSessionRequestBody.challenge)
    pub challenge: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PSessionRequestBody.client_connection_id)
    pub client_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PSessionRequestBody.legacy_peer_steam_id)
    pub legacy_peer_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PSessionRequestBody.peer_identity_string)
    pub peer_identity_string: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PSessionRequestBody.peer_connection_id)
    pub peer_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PSessionRequestBody.protocol_version)
    pub protocol_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PSessionRequestBody.network_config_version)
    pub network_config_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PSessionRequestBody.unused_public_ip)
    pub unused_public_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PSessionRequestBody.platform)
    pub platform: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PSessionRequestBody.build)
    pub build: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramP2PSessionRequestBody.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramP2PSessionRequestBody {
    fn default() -> &'a CMsgSteamDatagramP2PSessionRequestBody {
        <CMsgSteamDatagramP2PSessionRequestBody as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramP2PSessionRequestBody {
    pub fn new() -> CMsgSteamDatagramP2PSessionRequestBody {
        ::std::default::Default::default()
    }

    // optional fixed32 challenge_time = 1;

    pub fn challenge_time(&self) -> u32 {
        self.challenge_time.unwrap_or(0)
    }

    pub fn clear_challenge_time(&mut self) {
        self.challenge_time = ::std::option::Option::None;
    }

    pub fn has_challenge_time(&self) -> bool {
        self.challenge_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_time(&mut self, v: u32) {
        self.challenge_time = ::std::option::Option::Some(v);
    }

    // optional fixed64 challenge = 2;

    pub fn challenge(&self) -> u64 {
        self.challenge.unwrap_or(0)
    }

    pub fn clear_challenge(&mut self) {
        self.challenge = ::std::option::Option::None;
    }

    pub fn has_challenge(&self) -> bool {
        self.challenge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge(&mut self, v: u64) {
        self.challenge = ::std::option::Option::Some(v);
    }

    // optional fixed32 client_connection_id = 3;

    pub fn client_connection_id(&self) -> u32 {
        self.client_connection_id.unwrap_or(0)
    }

    pub fn clear_client_connection_id(&mut self) {
        self.client_connection_id = ::std::option::Option::None;
    }

    pub fn has_client_connection_id(&self) -> bool {
        self.client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_connection_id(&mut self, v: u32) {
        self.client_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 legacy_peer_steam_id = 4;

    pub fn legacy_peer_steam_id(&self) -> u64 {
        self.legacy_peer_steam_id.unwrap_or(0)
    }

    pub fn clear_legacy_peer_steam_id(&mut self) {
        self.legacy_peer_steam_id = ::std::option::Option::None;
    }

    pub fn has_legacy_peer_steam_id(&self) -> bool {
        self.legacy_peer_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_peer_steam_id(&mut self, v: u64) {
        self.legacy_peer_steam_id = ::std::option::Option::Some(v);
    }

    // optional string peer_identity_string = 11;

    pub fn peer_identity_string(&self) -> &str {
        match self.peer_identity_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_peer_identity_string(&mut self) {
        self.peer_identity_string = ::std::option::Option::None;
    }

    pub fn has_peer_identity_string(&self) -> bool {
        self.peer_identity_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peer_identity_string(&mut self, v: ::std::string::String) {
        self.peer_identity_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_peer_identity_string(&mut self) -> &mut ::std::string::String {
        if self.peer_identity_string.is_none() {
            self.peer_identity_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.peer_identity_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_peer_identity_string(&mut self) -> ::std::string::String {
        self.peer_identity_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed32 peer_connection_id = 5;

    pub fn peer_connection_id(&self) -> u32 {
        self.peer_connection_id.unwrap_or(0)
    }

    pub fn clear_peer_connection_id(&mut self) {
        self.peer_connection_id = ::std::option::Option::None;
    }

    pub fn has_peer_connection_id(&self) -> bool {
        self.peer_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peer_connection_id(&mut self, v: u32) {
        self.peer_connection_id = ::std::option::Option::Some(v);
    }

    // optional uint32 protocol_version = 8;

    pub fn protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }

    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }

    // optional uint32 network_config_version = 9;

    pub fn network_config_version(&self) -> u32 {
        self.network_config_version.unwrap_or(0)
    }

    pub fn clear_network_config_version(&mut self) {
        self.network_config_version = ::std::option::Option::None;
    }

    pub fn has_network_config_version(&self) -> bool {
        self.network_config_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_config_version(&mut self, v: u32) {
        self.network_config_version = ::std::option::Option::Some(v);
    }

    // optional fixed32 unused_public_ip = 10;

    pub fn unused_public_ip(&self) -> u32 {
        self.unused_public_ip.unwrap_or(0)
    }

    pub fn clear_unused_public_ip(&mut self) {
        self.unused_public_ip = ::std::option::Option::None;
    }

    pub fn has_unused_public_ip(&self) -> bool {
        self.unused_public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unused_public_ip(&mut self, v: u32) {
        self.unused_public_ip = ::std::option::Option::Some(v);
    }

    // optional string platform = 12;

    pub fn platform(&self) -> &str {
        match self.platform.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_platform(&mut self) {
        self.platform = ::std::option::Option::None;
    }

    pub fn has_platform(&self) -> bool {
        self.platform.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform(&mut self, v: ::std::string::String) {
        self.platform = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_platform(&mut self) -> &mut ::std::string::String {
        if self.platform.is_none() {
            self.platform = ::std::option::Option::Some(::std::string::String::new());
        }
        self.platform.as_mut().unwrap()
    }

    // Take field
    pub fn take_platform(&mut self) -> ::std::string::String {
        self.platform.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string build = 13;

    pub fn build(&self) -> &str {
        match self.build.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_build(&mut self) {
        self.build = ::std::option::Option::None;
    }

    pub fn has_build(&self) -> bool {
        self.build.is_some()
    }

    // Param is passed by value, moved
    pub fn set_build(&mut self, v: ::std::string::String) {
        self.build = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_build(&mut self) -> &mut ::std::string::String {
        if self.build.is_none() {
            self.build = ::std::option::Option::Some(::std::string::String::new());
        }
        self.build.as_mut().unwrap()
    }

    // Take field
    pub fn take_build(&mut self) -> ::std::string::String {
        self.build.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge_time",
            |m: &CMsgSteamDatagramP2PSessionRequestBody| { &m.challenge_time },
            |m: &mut CMsgSteamDatagramP2PSessionRequestBody| { &mut m.challenge_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge",
            |m: &CMsgSteamDatagramP2PSessionRequestBody| { &m.challenge },
            |m: &mut CMsgSteamDatagramP2PSessionRequestBody| { &mut m.challenge },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_connection_id",
            |m: &CMsgSteamDatagramP2PSessionRequestBody| { &m.client_connection_id },
            |m: &mut CMsgSteamDatagramP2PSessionRequestBody| { &mut m.client_connection_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "legacy_peer_steam_id",
            |m: &CMsgSteamDatagramP2PSessionRequestBody| { &m.legacy_peer_steam_id },
            |m: &mut CMsgSteamDatagramP2PSessionRequestBody| { &mut m.legacy_peer_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "peer_identity_string",
            |m: &CMsgSteamDatagramP2PSessionRequestBody| { &m.peer_identity_string },
            |m: &mut CMsgSteamDatagramP2PSessionRequestBody| { &mut m.peer_identity_string },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "peer_connection_id",
            |m: &CMsgSteamDatagramP2PSessionRequestBody| { &m.peer_connection_id },
            |m: &mut CMsgSteamDatagramP2PSessionRequestBody| { &mut m.peer_connection_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "protocol_version",
            |m: &CMsgSteamDatagramP2PSessionRequestBody| { &m.protocol_version },
            |m: &mut CMsgSteamDatagramP2PSessionRequestBody| { &mut m.protocol_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "network_config_version",
            |m: &CMsgSteamDatagramP2PSessionRequestBody| { &m.network_config_version },
            |m: &mut CMsgSteamDatagramP2PSessionRequestBody| { &mut m.network_config_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unused_public_ip",
            |m: &CMsgSteamDatagramP2PSessionRequestBody| { &m.unused_public_ip },
            |m: &mut CMsgSteamDatagramP2PSessionRequestBody| { &mut m.unused_public_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "platform",
            |m: &CMsgSteamDatagramP2PSessionRequestBody| { &m.platform },
            |m: &mut CMsgSteamDatagramP2PSessionRequestBody| { &mut m.platform },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "build",
            |m: &CMsgSteamDatagramP2PSessionRequestBody| { &m.build },
            |m: &mut CMsgSteamDatagramP2PSessionRequestBody| { &mut m.build },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramP2PSessionRequestBody>(
            "CMsgSteamDatagramP2PSessionRequestBody",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramP2PSessionRequestBody {
    const NAME: &'static str = "CMsgSteamDatagramP2PSessionRequestBody";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.challenge_time = ::std::option::Option::Some(is.read_fixed32()?);
                },
                17 => {
                    self.challenge = ::std::option::Option::Some(is.read_fixed64()?);
                },
                29 => {
                    self.client_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                33 => {
                    self.legacy_peer_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                90 => {
                    self.peer_identity_string = ::std::option::Option::Some(is.read_string()?);
                },
                45 => {
                    self.peer_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                64 => {
                    self.protocol_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.network_config_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                85 => {
                    self.unused_public_ip = ::std::option::Option::Some(is.read_fixed32()?);
                },
                98 => {
                    self.platform = ::std::option::Option::Some(is.read_string()?);
                },
                106 => {
                    self.build = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.challenge_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.challenge {
            my_size += 1 + 8;
        }
        if let Some(v) = self.client_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.legacy_peer_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.peer_identity_string.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.peer_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.protocol_version {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.network_config_version {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.unused_public_ip {
            my_size += 1 + 4;
        }
        if let Some(v) = self.platform.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.build.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.challenge_time {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.challenge {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.client_connection_id {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.legacy_peer_steam_id {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.peer_identity_string.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.peer_connection_id {
            os.write_fixed32(5, v)?;
        }
        if let Some(v) = self.protocol_version {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.network_config_version {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.unused_public_ip {
            os.write_fixed32(10, v)?;
        }
        if let Some(v) = self.platform.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.build.as_ref() {
            os.write_string(13, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramP2PSessionRequestBody {
        CMsgSteamDatagramP2PSessionRequestBody::new()
    }

    fn clear(&mut self) {
        self.challenge_time = ::std::option::Option::None;
        self.challenge = ::std::option::Option::None;
        self.client_connection_id = ::std::option::Option::None;
        self.legacy_peer_steam_id = ::std::option::Option::None;
        self.peer_identity_string = ::std::option::Option::None;
        self.peer_connection_id = ::std::option::Option::None;
        self.protocol_version = ::std::option::Option::None;
        self.network_config_version = ::std::option::Option::None;
        self.unused_public_ip = ::std::option::Option::None;
        self.platform = ::std::option::Option::None;
        self.build = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramP2PSessionRequestBody {
        static instance: CMsgSteamDatagramP2PSessionRequestBody = CMsgSteamDatagramP2PSessionRequestBody {
            challenge_time: ::std::option::Option::None,
            challenge: ::std::option::Option::None,
            client_connection_id: ::std::option::Option::None,
            legacy_peer_steam_id: ::std::option::Option::None,
            peer_identity_string: ::std::option::Option::None,
            peer_connection_id: ::std::option::Option::None,
            protocol_version: ::std::option::Option::None,
            network_config_version: ::std::option::Option::None,
            unused_public_ip: ::std::option::Option::None,
            platform: ::std::option::Option::None,
            build: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramP2PSessionRequestBody {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramP2PSessionRequestBody").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramP2PSessionRequestBody {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramP2PSessionRequestBody {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamDatagramP2PSessionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramP2PSessionRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PSessionRequest.cert)
    pub cert: ::protobuf::MessageField<super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PSessionRequest.body)
    pub body: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PSessionRequest.signature)
    pub signature: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramP2PSessionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramP2PSessionRequest {
    fn default() -> &'a CMsgSteamDatagramP2PSessionRequest {
        <CMsgSteamDatagramP2PSessionRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramP2PSessionRequest {
    pub fn new() -> CMsgSteamDatagramP2PSessionRequest {
        ::std::default::Default::default()
    }

    // optional bytes body = 2;

    pub fn body(&self) -> &[u8] {
        match self.body.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_body(&mut self) {
        self.body = ::std::option::Option::None;
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::vec::Vec<u8>) {
        self.body = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.body.is_none() {
            self.body = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::vec::Vec<u8> {
        self.body.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes signature = 3;

    pub fn signature(&self) -> &[u8] {
        match self.signature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_signature(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signature.is_none() {
            self.signature = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned>(
            "cert",
            |m: &CMsgSteamDatagramP2PSessionRequest| { &m.cert },
            |m: &mut CMsgSteamDatagramP2PSessionRequest| { &mut m.cert },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "body",
            |m: &CMsgSteamDatagramP2PSessionRequest| { &m.body },
            |m: &mut CMsgSteamDatagramP2PSessionRequest| { &mut m.body },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "signature",
            |m: &CMsgSteamDatagramP2PSessionRequest| { &m.signature },
            |m: &mut CMsgSteamDatagramP2PSessionRequest| { &mut m.signature },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramP2PSessionRequest>(
            "CMsgSteamDatagramP2PSessionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramP2PSessionRequest {
    const NAME: &'static str = "CMsgSteamDatagramP2PSessionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cert)?;
                },
                18 => {
                    self.body = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.signature = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cert.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.body.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cert.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.body.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.signature.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramP2PSessionRequest {
        CMsgSteamDatagramP2PSessionRequest::new()
    }

    fn clear(&mut self) {
        self.cert.clear();
        self.body = ::std::option::Option::None;
        self.signature = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramP2PSessionRequest {
        static instance: CMsgSteamDatagramP2PSessionRequest = CMsgSteamDatagramP2PSessionRequest {
            cert: ::protobuf::MessageField::none(),
            body: ::std::option::Option::None,
            signature: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramP2PSessionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramP2PSessionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramP2PSessionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramP2PSessionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamDatagramP2PSessionEstablished)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramP2PSessionEstablished {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PSessionEstablished.connection_id)
    pub connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PSessionEstablished.seconds_until_shutdown)
    pub seconds_until_shutdown: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PSessionEstablished.relay_routing_token)
    pub relay_routing_token: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PSessionEstablished.seq_num_r2c)
    pub seq_num_r2c: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramP2PSessionEstablished.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramP2PSessionEstablished {
    fn default() -> &'a CMsgSteamDatagramP2PSessionEstablished {
        <CMsgSteamDatagramP2PSessionEstablished as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramP2PSessionEstablished {
    pub fn new() -> CMsgSteamDatagramP2PSessionEstablished {
        ::std::default::Default::default()
    }

    // optional fixed32 connection_id = 1;

    pub fn connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }

    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_until_shutdown = 3;

    pub fn seconds_until_shutdown(&self) -> u32 {
        self.seconds_until_shutdown.unwrap_or(0)
    }

    pub fn clear_seconds_until_shutdown(&mut self) {
        self.seconds_until_shutdown = ::std::option::Option::None;
    }

    pub fn has_seconds_until_shutdown(&self) -> bool {
        self.seconds_until_shutdown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_until_shutdown(&mut self, v: u32) {
        self.seconds_until_shutdown = ::std::option::Option::Some(v);
    }

    // optional bytes relay_routing_token = 4;

    pub fn relay_routing_token(&self) -> &[u8] {
        match self.relay_routing_token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_relay_routing_token(&mut self) {
        self.relay_routing_token = ::std::option::Option::None;
    }

    pub fn has_relay_routing_token(&self) -> bool {
        self.relay_routing_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relay_routing_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.relay_routing_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_relay_routing_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.relay_routing_token.is_none() {
            self.relay_routing_token = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.relay_routing_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_relay_routing_token(&mut self) -> ::std::vec::Vec<u8> {
        self.relay_routing_token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 seq_num_r2c = 5;

    pub fn seq_num_r2c(&self) -> u32 {
        self.seq_num_r2c.unwrap_or(0)
    }

    pub fn clear_seq_num_r2c(&mut self) {
        self.seq_num_r2c = ::std::option::Option::None;
    }

    pub fn has_seq_num_r2c(&self) -> bool {
        self.seq_num_r2c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_r2c(&mut self, v: u32) {
        self.seq_num_r2c = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "connection_id",
            |m: &CMsgSteamDatagramP2PSessionEstablished| { &m.connection_id },
            |m: &mut CMsgSteamDatagramP2PSessionEstablished| { &mut m.connection_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seconds_until_shutdown",
            |m: &CMsgSteamDatagramP2PSessionEstablished| { &m.seconds_until_shutdown },
            |m: &mut CMsgSteamDatagramP2PSessionEstablished| { &mut m.seconds_until_shutdown },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "relay_routing_token",
            |m: &CMsgSteamDatagramP2PSessionEstablished| { &m.relay_routing_token },
            |m: &mut CMsgSteamDatagramP2PSessionEstablished| { &mut m.relay_routing_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seq_num_r2c",
            |m: &CMsgSteamDatagramP2PSessionEstablished| { &m.seq_num_r2c },
            |m: &mut CMsgSteamDatagramP2PSessionEstablished| { &mut m.seq_num_r2c },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramP2PSessionEstablished>(
            "CMsgSteamDatagramP2PSessionEstablished",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramP2PSessionEstablished {
    const NAME: &'static str = "CMsgSteamDatagramP2PSessionEstablished";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                24 => {
                    self.seconds_until_shutdown = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.relay_routing_token = ::std::option::Option::Some(is.read_bytes()?);
                },
                40 => {
                    self.seq_num_r2c = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.seconds_until_shutdown {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.relay_routing_token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.seq_num_r2c {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.seconds_until_shutdown {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.relay_routing_token.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.seq_num_r2c {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramP2PSessionEstablished {
        CMsgSteamDatagramP2PSessionEstablished::new()
    }

    fn clear(&mut self) {
        self.connection_id = ::std::option::Option::None;
        self.seconds_until_shutdown = ::std::option::Option::None;
        self.relay_routing_token = ::std::option::Option::None;
        self.seq_num_r2c = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramP2PSessionEstablished {
        static instance: CMsgSteamDatagramP2PSessionEstablished = CMsgSteamDatagramP2PSessionEstablished {
            connection_id: ::std::option::Option::None,
            seconds_until_shutdown: ::std::option::Option::None,
            relay_routing_token: ::std::option::Option::None,
            seq_num_r2c: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramP2PSessionEstablished {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramP2PSessionEstablished").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramP2PSessionEstablished {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramP2PSessionEstablished {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamDatagramConnectionStatsP2PClientToRouter)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramConnectionStatsP2PClientToRouter {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PClientToRouter.quality_relay)
    pub quality_relay: ::protobuf::MessageField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PClientToRouter.quality_e2e)
    pub quality_e2e: ::protobuf::MessageField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PClientToRouter.p2p_routing_summary)
    pub p2p_routing_summary: ::protobuf::MessageField<CMsgSteamDatagramP2PRoutingSummary>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PClientToRouter.ack_relay)
    pub ack_relay: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PClientToRouter.legacy_ack_e2e)
    pub legacy_ack_e2e: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PClientToRouter.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PClientToRouter.forward_target_relay_routing_token)
    pub forward_target_relay_routing_token: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PClientToRouter.forward_target_revision)
    pub forward_target_revision: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PClientToRouter.routes)
    pub routes: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PClientToRouter.ack_peer_routes_revision)
    pub ack_peer_routes_revision: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PClientToRouter.connection_id)
    pub connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PClientToRouter.seq_num_c2r)
    pub seq_num_c2r: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PClientToRouter.seq_num_e2e)
    pub seq_num_e2e: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramConnectionStatsP2PClientToRouter.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectionStatsP2PClientToRouter {
    fn default() -> &'a CMsgSteamDatagramConnectionStatsP2PClientToRouter {
        <CMsgSteamDatagramConnectionStatsP2PClientToRouter as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectionStatsP2PClientToRouter {
    pub fn new() -> CMsgSteamDatagramConnectionStatsP2PClientToRouter {
        ::std::default::Default::default()
    }

    // optional uint32 flags = 5;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional bytes forward_target_relay_routing_token = 6;

    pub fn forward_target_relay_routing_token(&self) -> &[u8] {
        match self.forward_target_relay_routing_token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_forward_target_relay_routing_token(&mut self) {
        self.forward_target_relay_routing_token = ::std::option::Option::None;
    }

    pub fn has_forward_target_relay_routing_token(&self) -> bool {
        self.forward_target_relay_routing_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_forward_target_relay_routing_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.forward_target_relay_routing_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_forward_target_relay_routing_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.forward_target_relay_routing_token.is_none() {
            self.forward_target_relay_routing_token = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.forward_target_relay_routing_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_forward_target_relay_routing_token(&mut self) -> ::std::vec::Vec<u8> {
        self.forward_target_relay_routing_token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 forward_target_revision = 7;

    pub fn forward_target_revision(&self) -> u32 {
        self.forward_target_revision.unwrap_or(0)
    }

    pub fn clear_forward_target_revision(&mut self) {
        self.forward_target_revision = ::std::option::Option::None;
    }

    pub fn has_forward_target_revision(&self) -> bool {
        self.forward_target_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_forward_target_revision(&mut self, v: u32) {
        self.forward_target_revision = ::std::option::Option::Some(v);
    }

    // optional bytes routes = 8;

    pub fn routes(&self) -> &[u8] {
        match self.routes.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_routes(&mut self) {
        self.routes = ::std::option::Option::None;
    }

    pub fn has_routes(&self) -> bool {
        self.routes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_routes(&mut self, v: ::std::vec::Vec<u8>) {
        self.routes = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_routes(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.routes.is_none() {
            self.routes = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.routes.as_mut().unwrap()
    }

    // Take field
    pub fn take_routes(&mut self) -> ::std::vec::Vec<u8> {
        self.routes.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 ack_peer_routes_revision = 9;

    pub fn ack_peer_routes_revision(&self) -> u32 {
        self.ack_peer_routes_revision.unwrap_or(0)
    }

    pub fn clear_ack_peer_routes_revision(&mut self) {
        self.ack_peer_routes_revision = ::std::option::Option::None;
    }

    pub fn has_ack_peer_routes_revision(&self) -> bool {
        self.ack_peer_routes_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ack_peer_routes_revision(&mut self, v: u32) {
        self.ack_peer_routes_revision = ::std::option::Option::Some(v);
    }

    // optional fixed32 connection_id = 10;

    pub fn connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }

    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_c2r = 11;

    pub fn seq_num_c2r(&self) -> u32 {
        self.seq_num_c2r.unwrap_or(0)
    }

    pub fn clear_seq_num_c2r(&mut self) {
        self.seq_num_c2r = ::std::option::Option::None;
    }

    pub fn has_seq_num_c2r(&self) -> bool {
        self.seq_num_c2r.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_c2r(&mut self, v: u32) {
        self.seq_num_c2r = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_e2e = 12;

    pub fn seq_num_e2e(&self) -> u32 {
        self.seq_num_e2e.unwrap_or(0)
    }

    pub fn clear_seq_num_e2e(&mut self) {
        self.seq_num_e2e = ::std::option::Option::None;
    }

    pub fn has_seq_num_e2e(&self) -> bool {
        self.seq_num_e2e.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_e2e(&mut self, v: u32) {
        self.seq_num_e2e = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>(
            "quality_relay",
            |m: &CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &m.quality_relay },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &mut m.quality_relay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>(
            "quality_e2e",
            |m: &CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &m.quality_e2e },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &mut m.quality_e2e },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSteamDatagramP2PRoutingSummary>(
            "p2p_routing_summary",
            |m: &CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &m.p2p_routing_summary },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &mut m.p2p_routing_summary },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ack_relay",
            |m: &CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &m.ack_relay },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &mut m.ack_relay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "legacy_ack_e2e",
            |m: &CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &m.legacy_ack_e2e },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &mut m.legacy_ack_e2e },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &m.flags },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "forward_target_relay_routing_token",
            |m: &CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &m.forward_target_relay_routing_token },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &mut m.forward_target_relay_routing_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "forward_target_revision",
            |m: &CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &m.forward_target_revision },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &mut m.forward_target_revision },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "routes",
            |m: &CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &m.routes },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &mut m.routes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ack_peer_routes_revision",
            |m: &CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &m.ack_peer_routes_revision },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &mut m.ack_peer_routes_revision },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "connection_id",
            |m: &CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &m.connection_id },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &mut m.connection_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seq_num_c2r",
            |m: &CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &m.seq_num_c2r },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &mut m.seq_num_c2r },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seq_num_e2e",
            |m: &CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &m.seq_num_e2e },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &mut m.seq_num_e2e },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramConnectionStatsP2PClientToRouter>(
            "CMsgSteamDatagramConnectionStatsP2PClientToRouter",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramConnectionStatsP2PClientToRouter {
    const NAME: &'static str = "CMsgSteamDatagramConnectionStatsP2PClientToRouter";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.quality_relay)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.quality_e2e)?;
                },
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.p2p_routing_summary)?;
                },
                26 => {
                    is.read_repeated_packed_fixed32_into(&mut self.ack_relay)?;
                },
                29 => {
                    self.ack_relay.push(is.read_fixed32()?);
                },
                34 => {
                    is.read_repeated_packed_fixed32_into(&mut self.legacy_ack_e2e)?;
                },
                37 => {
                    self.legacy_ack_e2e.push(is.read_fixed32()?);
                },
                40 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    self.forward_target_relay_routing_token = ::std::option::Option::Some(is.read_bytes()?);
                },
                56 => {
                    self.forward_target_revision = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.routes = ::std::option::Option::Some(is.read_bytes()?);
                },
                72 => {
                    self.ack_peer_routes_revision = ::std::option::Option::Some(is.read_uint32()?);
                },
                85 => {
                    self.connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                88 => {
                    self.seq_num_c2r = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.seq_num_e2e = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quality_relay.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.quality_e2e.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.p2p_routing_summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += 5 * self.ack_relay.len() as u64;
        my_size += 5 * self.legacy_ack_e2e.len() as u64;
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.forward_target_relay_routing_token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.forward_target_revision {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.routes.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.ack_peer_routes_revision {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.seq_num_c2r {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.seq_num_e2e {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.quality_relay.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.quality_e2e.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.p2p_routing_summary.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        for v in &self.ack_relay {
            os.write_fixed32(3, *v)?;
        };
        for v in &self.legacy_ack_e2e {
            os.write_fixed32(4, *v)?;
        };
        if let Some(v) = self.flags {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.forward_target_relay_routing_token.as_ref() {
            os.write_bytes(6, v)?;
        }
        if let Some(v) = self.forward_target_revision {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.routes.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.ack_peer_routes_revision {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.connection_id {
            os.write_fixed32(10, v)?;
        }
        if let Some(v) = self.seq_num_c2r {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.seq_num_e2e {
            os.write_uint32(12, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramConnectionStatsP2PClientToRouter {
        CMsgSteamDatagramConnectionStatsP2PClientToRouter::new()
    }

    fn clear(&mut self) {
        self.quality_relay.clear();
        self.quality_e2e.clear();
        self.p2p_routing_summary.clear();
        self.ack_relay.clear();
        self.legacy_ack_e2e.clear();
        self.flags = ::std::option::Option::None;
        self.forward_target_relay_routing_token = ::std::option::Option::None;
        self.forward_target_revision = ::std::option::Option::None;
        self.routes = ::std::option::Option::None;
        self.ack_peer_routes_revision = ::std::option::Option::None;
        self.connection_id = ::std::option::Option::None;
        self.seq_num_c2r = ::std::option::Option::None;
        self.seq_num_e2e = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectionStatsP2PClientToRouter {
        static instance: CMsgSteamDatagramConnectionStatsP2PClientToRouter = CMsgSteamDatagramConnectionStatsP2PClientToRouter {
            quality_relay: ::protobuf::MessageField::none(),
            quality_e2e: ::protobuf::MessageField::none(),
            p2p_routing_summary: ::protobuf::MessageField::none(),
            ack_relay: ::std::vec::Vec::new(),
            legacy_ack_e2e: ::std::vec::Vec::new(),
            flags: ::std::option::Option::None,
            forward_target_relay_routing_token: ::std::option::Option::None,
            forward_target_revision: ::std::option::Option::None,
            routes: ::std::option::Option::None,
            ack_peer_routes_revision: ::std::option::Option::None,
            connection_id: ::std::option::Option::None,
            seq_num_c2r: ::std::option::Option::None,
            seq_num_e2e: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramConnectionStatsP2PClientToRouter {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramConnectionStatsP2PClientToRouter").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramConnectionStatsP2PClientToRouter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionStatsP2PClientToRouter {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSteamDatagramConnectionStatsP2PClientToRouter`
pub mod cmsg_steam_datagram_connection_stats_p2pclient_to_router {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgSteamDatagramConnectionStatsP2PClientToRouter.Flags)
    pub enum Flags {
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsP2PClientToRouter.Flags.ACK_REQUEST_RELAY)
        ACK_REQUEST_RELAY = 1,
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsP2PClientToRouter.Flags.ACK_REQUEST_E2E)
        ACK_REQUEST_E2E = 2,
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsP2PClientToRouter.Flags.ACK_REQUEST_IMMEDIATE)
        ACK_REQUEST_IMMEDIATE = 4,
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsP2PClientToRouter.Flags.NOT_PRIMARY_SESSION)
        NOT_PRIMARY_SESSION = 8,
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsP2PClientToRouter.Flags.NOT_PRIMARY_TRANSPORT_E2E)
        NOT_PRIMARY_TRANSPORT_E2E = 16,
    }

    impl ::protobuf::Enum for Flags {
        const NAME: &'static str = "Flags";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Flags> {
            match value {
                1 => ::std::option::Option::Some(Flags::ACK_REQUEST_RELAY),
                2 => ::std::option::Option::Some(Flags::ACK_REQUEST_E2E),
                4 => ::std::option::Option::Some(Flags::ACK_REQUEST_IMMEDIATE),
                8 => ::std::option::Option::Some(Flags::NOT_PRIMARY_SESSION),
                16 => ::std::option::Option::Some(Flags::NOT_PRIMARY_TRANSPORT_E2E),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Flags> {
            match str {
                "ACK_REQUEST_RELAY" => ::std::option::Option::Some(Flags::ACK_REQUEST_RELAY),
                "ACK_REQUEST_E2E" => ::std::option::Option::Some(Flags::ACK_REQUEST_E2E),
                "ACK_REQUEST_IMMEDIATE" => ::std::option::Option::Some(Flags::ACK_REQUEST_IMMEDIATE),
                "NOT_PRIMARY_SESSION" => ::std::option::Option::Some(Flags::NOT_PRIMARY_SESSION),
                "NOT_PRIMARY_TRANSPORT_E2E" => ::std::option::Option::Some(Flags::NOT_PRIMARY_TRANSPORT_E2E),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Flags] = &[
            Flags::ACK_REQUEST_RELAY,
            Flags::ACK_REQUEST_E2E,
            Flags::ACK_REQUEST_IMMEDIATE,
            Flags::NOT_PRIMARY_SESSION,
            Flags::NOT_PRIMARY_TRANSPORT_E2E,
        ];
    }

    impl ::protobuf::EnumFull for Flags {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgSteamDatagramConnectionStatsP2PClientToRouter.Flags").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Flags::ACK_REQUEST_RELAY => 0,
                Flags::ACK_REQUEST_E2E => 1,
                Flags::ACK_REQUEST_IMMEDIATE => 2,
                Flags::NOT_PRIMARY_SESSION => 3,
                Flags::NOT_PRIMARY_TRANSPORT_E2E => 4,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Flags {
        fn default() -> Self {
            Flags::ACK_REQUEST_RELAY
        }
    }

    impl Flags {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Flags>("CMsgSteamDatagramConnectionStatsP2PClientToRouter.Flags")
        }
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramConnectionStatsP2PRouterToClient)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramConnectionStatsP2PRouterToClient {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToClient.quality_relay)
    pub quality_relay: ::protobuf::MessageField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToClient.quality_e2e)
    pub quality_e2e: ::protobuf::MessageField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToClient.seconds_until_shutdown)
    pub seconds_until_shutdown: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToClient.migrate_request_ip)
    pub migrate_request_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToClient.migrate_request_port)
    pub migrate_request_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToClient.scoring_penalty_relay_cluster)
    pub scoring_penalty_relay_cluster: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToClient.ack_relay)
    pub ack_relay: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToClient.legacy_ack_e2e)
    pub legacy_ack_e2e: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToClient.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToClient.ack_forward_target_revision)
    pub ack_forward_target_revision: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToClient.routes)
    pub routes: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToClient.ack_peer_routes_revision)
    pub ack_peer_routes_revision: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToClient.connection_id)
    pub connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToClient.seq_num_r2c)
    pub seq_num_r2c: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToClient.seq_num_e2e)
    pub seq_num_e2e: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramConnectionStatsP2PRouterToClient.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectionStatsP2PRouterToClient {
    fn default() -> &'a CMsgSteamDatagramConnectionStatsP2PRouterToClient {
        <CMsgSteamDatagramConnectionStatsP2PRouterToClient as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectionStatsP2PRouterToClient {
    pub fn new() -> CMsgSteamDatagramConnectionStatsP2PRouterToClient {
        ::std::default::Default::default()
    }

    // optional uint32 seconds_until_shutdown = 3;

    pub fn seconds_until_shutdown(&self) -> u32 {
        self.seconds_until_shutdown.unwrap_or(0)
    }

    pub fn clear_seconds_until_shutdown(&mut self) {
        self.seconds_until_shutdown = ::std::option::Option::None;
    }

    pub fn has_seconds_until_shutdown(&self) -> bool {
        self.seconds_until_shutdown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_until_shutdown(&mut self, v: u32) {
        self.seconds_until_shutdown = ::std::option::Option::Some(v);
    }

    // optional fixed32 migrate_request_ip = 4;

    pub fn migrate_request_ip(&self) -> u32 {
        self.migrate_request_ip.unwrap_or(0)
    }

    pub fn clear_migrate_request_ip(&mut self) {
        self.migrate_request_ip = ::std::option::Option::None;
    }

    pub fn has_migrate_request_ip(&self) -> bool {
        self.migrate_request_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_migrate_request_ip(&mut self, v: u32) {
        self.migrate_request_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 migrate_request_port = 5;

    pub fn migrate_request_port(&self) -> u32 {
        self.migrate_request_port.unwrap_or(0)
    }

    pub fn clear_migrate_request_port(&mut self) {
        self.migrate_request_port = ::std::option::Option::None;
    }

    pub fn has_migrate_request_port(&self) -> bool {
        self.migrate_request_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_migrate_request_port(&mut self, v: u32) {
        self.migrate_request_port = ::std::option::Option::Some(v);
    }

    // optional uint32 scoring_penalty_relay_cluster = 6;

    pub fn scoring_penalty_relay_cluster(&self) -> u32 {
        self.scoring_penalty_relay_cluster.unwrap_or(0)
    }

    pub fn clear_scoring_penalty_relay_cluster(&mut self) {
        self.scoring_penalty_relay_cluster = ::std::option::Option::None;
    }

    pub fn has_scoring_penalty_relay_cluster(&self) -> bool {
        self.scoring_penalty_relay_cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scoring_penalty_relay_cluster(&mut self, v: u32) {
        self.scoring_penalty_relay_cluster = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 9;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 ack_forward_target_revision = 10;

    pub fn ack_forward_target_revision(&self) -> u32 {
        self.ack_forward_target_revision.unwrap_or(0)
    }

    pub fn clear_ack_forward_target_revision(&mut self) {
        self.ack_forward_target_revision = ::std::option::Option::None;
    }

    pub fn has_ack_forward_target_revision(&self) -> bool {
        self.ack_forward_target_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ack_forward_target_revision(&mut self, v: u32) {
        self.ack_forward_target_revision = ::std::option::Option::Some(v);
    }

    // optional bytes routes = 11;

    pub fn routes(&self) -> &[u8] {
        match self.routes.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_routes(&mut self) {
        self.routes = ::std::option::Option::None;
    }

    pub fn has_routes(&self) -> bool {
        self.routes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_routes(&mut self, v: ::std::vec::Vec<u8>) {
        self.routes = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_routes(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.routes.is_none() {
            self.routes = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.routes.as_mut().unwrap()
    }

    // Take field
    pub fn take_routes(&mut self) -> ::std::vec::Vec<u8> {
        self.routes.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 ack_peer_routes_revision = 12;

    pub fn ack_peer_routes_revision(&self) -> u32 {
        self.ack_peer_routes_revision.unwrap_or(0)
    }

    pub fn clear_ack_peer_routes_revision(&mut self) {
        self.ack_peer_routes_revision = ::std::option::Option::None;
    }

    pub fn has_ack_peer_routes_revision(&self) -> bool {
        self.ack_peer_routes_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ack_peer_routes_revision(&mut self, v: u32) {
        self.ack_peer_routes_revision = ::std::option::Option::Some(v);
    }

    // optional fixed32 connection_id = 13;

    pub fn connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }

    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_r2c = 14;

    pub fn seq_num_r2c(&self) -> u32 {
        self.seq_num_r2c.unwrap_or(0)
    }

    pub fn clear_seq_num_r2c(&mut self) {
        self.seq_num_r2c = ::std::option::Option::None;
    }

    pub fn has_seq_num_r2c(&self) -> bool {
        self.seq_num_r2c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_r2c(&mut self, v: u32) {
        self.seq_num_r2c = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_e2e = 15;

    pub fn seq_num_e2e(&self) -> u32 {
        self.seq_num_e2e.unwrap_or(0)
    }

    pub fn clear_seq_num_e2e(&mut self) {
        self.seq_num_e2e = ::std::option::Option::None;
    }

    pub fn has_seq_num_e2e(&self) -> bool {
        self.seq_num_e2e.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_e2e(&mut self, v: u32) {
        self.seq_num_e2e = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(15);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>(
            "quality_relay",
            |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.quality_relay },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.quality_relay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>(
            "quality_e2e",
            |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.quality_e2e },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.quality_e2e },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seconds_until_shutdown",
            |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.seconds_until_shutdown },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.seconds_until_shutdown },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "migrate_request_ip",
            |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.migrate_request_ip },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.migrate_request_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "migrate_request_port",
            |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.migrate_request_port },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.migrate_request_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scoring_penalty_relay_cluster",
            |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.scoring_penalty_relay_cluster },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.scoring_penalty_relay_cluster },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ack_relay",
            |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.ack_relay },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.ack_relay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "legacy_ack_e2e",
            |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.legacy_ack_e2e },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.legacy_ack_e2e },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.flags },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ack_forward_target_revision",
            |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.ack_forward_target_revision },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.ack_forward_target_revision },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "routes",
            |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.routes },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.routes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ack_peer_routes_revision",
            |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.ack_peer_routes_revision },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.ack_peer_routes_revision },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "connection_id",
            |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.connection_id },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.connection_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seq_num_r2c",
            |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.seq_num_r2c },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.seq_num_r2c },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seq_num_e2e",
            |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.seq_num_e2e },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.seq_num_e2e },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramConnectionStatsP2PRouterToClient>(
            "CMsgSteamDatagramConnectionStatsP2PRouterToClient",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramConnectionStatsP2PRouterToClient {
    const NAME: &'static str = "CMsgSteamDatagramConnectionStatsP2PRouterToClient";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.quality_relay)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.quality_e2e)?;
                },
                24 => {
                    self.seconds_until_shutdown = ::std::option::Option::Some(is.read_uint32()?);
                },
                37 => {
                    self.migrate_request_ip = ::std::option::Option::Some(is.read_fixed32()?);
                },
                40 => {
                    self.migrate_request_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.scoring_penalty_relay_cluster = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    is.read_repeated_packed_fixed32_into(&mut self.ack_relay)?;
                },
                61 => {
                    self.ack_relay.push(is.read_fixed32()?);
                },
                66 => {
                    is.read_repeated_packed_fixed32_into(&mut self.legacy_ack_e2e)?;
                },
                69 => {
                    self.legacy_ack_e2e.push(is.read_fixed32()?);
                },
                72 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.ack_forward_target_revision = ::std::option::Option::Some(is.read_uint32()?);
                },
                90 => {
                    self.routes = ::std::option::Option::Some(is.read_bytes()?);
                },
                96 => {
                    self.ack_peer_routes_revision = ::std::option::Option::Some(is.read_uint32()?);
                },
                109 => {
                    self.connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                112 => {
                    self.seq_num_r2c = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.seq_num_e2e = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quality_relay.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.quality_e2e.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.seconds_until_shutdown {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.migrate_request_ip {
            my_size += 1 + 4;
        }
        if let Some(v) = self.migrate_request_port {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.scoring_penalty_relay_cluster {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        my_size += 5 * self.ack_relay.len() as u64;
        my_size += 5 * self.legacy_ack_e2e.len() as u64;
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.ack_forward_target_revision {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.routes.as_ref() {
            my_size += ::protobuf::rt::bytes_size(11, &v);
        }
        if let Some(v) = self.ack_peer_routes_revision {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.seq_num_r2c {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.seq_num_e2e {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.quality_relay.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.quality_e2e.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.seconds_until_shutdown {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.migrate_request_ip {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.migrate_request_port {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.scoring_penalty_relay_cluster {
            os.write_uint32(6, v)?;
        }
        for v in &self.ack_relay {
            os.write_fixed32(7, *v)?;
        };
        for v in &self.legacy_ack_e2e {
            os.write_fixed32(8, *v)?;
        };
        if let Some(v) = self.flags {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.ack_forward_target_revision {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.routes.as_ref() {
            os.write_bytes(11, v)?;
        }
        if let Some(v) = self.ack_peer_routes_revision {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.connection_id {
            os.write_fixed32(13, v)?;
        }
        if let Some(v) = self.seq_num_r2c {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.seq_num_e2e {
            os.write_uint32(15, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramConnectionStatsP2PRouterToClient {
        CMsgSteamDatagramConnectionStatsP2PRouterToClient::new()
    }

    fn clear(&mut self) {
        self.quality_relay.clear();
        self.quality_e2e.clear();
        self.seconds_until_shutdown = ::std::option::Option::None;
        self.migrate_request_ip = ::std::option::Option::None;
        self.migrate_request_port = ::std::option::Option::None;
        self.scoring_penalty_relay_cluster = ::std::option::Option::None;
        self.ack_relay.clear();
        self.legacy_ack_e2e.clear();
        self.flags = ::std::option::Option::None;
        self.ack_forward_target_revision = ::std::option::Option::None;
        self.routes = ::std::option::Option::None;
        self.ack_peer_routes_revision = ::std::option::Option::None;
        self.connection_id = ::std::option::Option::None;
        self.seq_num_r2c = ::std::option::Option::None;
        self.seq_num_e2e = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectionStatsP2PRouterToClient {
        static instance: CMsgSteamDatagramConnectionStatsP2PRouterToClient = CMsgSteamDatagramConnectionStatsP2PRouterToClient {
            quality_relay: ::protobuf::MessageField::none(),
            quality_e2e: ::protobuf::MessageField::none(),
            seconds_until_shutdown: ::std::option::Option::None,
            migrate_request_ip: ::std::option::Option::None,
            migrate_request_port: ::std::option::Option::None,
            scoring_penalty_relay_cluster: ::std::option::Option::None,
            ack_relay: ::std::vec::Vec::new(),
            legacy_ack_e2e: ::std::vec::Vec::new(),
            flags: ::std::option::Option::None,
            ack_forward_target_revision: ::std::option::Option::None,
            routes: ::std::option::Option::None,
            ack_peer_routes_revision: ::std::option::Option::None,
            connection_id: ::std::option::Option::None,
            seq_num_r2c: ::std::option::Option::None,
            seq_num_e2e: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramConnectionStatsP2PRouterToClient {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramConnectionStatsP2PRouterToClient").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramConnectionStatsP2PRouterToClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionStatsP2PRouterToClient {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSteamDatagramConnectionStatsP2PRouterToClient`
pub mod cmsg_steam_datagram_connection_stats_p2prouter_to_client {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgSteamDatagramConnectionStatsP2PRouterToClient.Flags)
    pub enum Flags {
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsP2PRouterToClient.Flags.ACK_REQUEST_RELAY)
        ACK_REQUEST_RELAY = 1,
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsP2PRouterToClient.Flags.ACK_REQUEST_E2E)
        ACK_REQUEST_E2E = 2,
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsP2PRouterToClient.Flags.ACK_REQUEST_IMMEDIATE)
        ACK_REQUEST_IMMEDIATE = 4,
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsP2PRouterToClient.Flags.NOT_PRIMARY_TRANSPORT_E2E)
        NOT_PRIMARY_TRANSPORT_E2E = 16,
    }

    impl ::protobuf::Enum for Flags {
        const NAME: &'static str = "Flags";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Flags> {
            match value {
                1 => ::std::option::Option::Some(Flags::ACK_REQUEST_RELAY),
                2 => ::std::option::Option::Some(Flags::ACK_REQUEST_E2E),
                4 => ::std::option::Option::Some(Flags::ACK_REQUEST_IMMEDIATE),
                16 => ::std::option::Option::Some(Flags::NOT_PRIMARY_TRANSPORT_E2E),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Flags> {
            match str {
                "ACK_REQUEST_RELAY" => ::std::option::Option::Some(Flags::ACK_REQUEST_RELAY),
                "ACK_REQUEST_E2E" => ::std::option::Option::Some(Flags::ACK_REQUEST_E2E),
                "ACK_REQUEST_IMMEDIATE" => ::std::option::Option::Some(Flags::ACK_REQUEST_IMMEDIATE),
                "NOT_PRIMARY_TRANSPORT_E2E" => ::std::option::Option::Some(Flags::NOT_PRIMARY_TRANSPORT_E2E),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Flags] = &[
            Flags::ACK_REQUEST_RELAY,
            Flags::ACK_REQUEST_E2E,
            Flags::ACK_REQUEST_IMMEDIATE,
            Flags::NOT_PRIMARY_TRANSPORT_E2E,
        ];
    }

    impl ::protobuf::EnumFull for Flags {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgSteamDatagramConnectionStatsP2PRouterToClient.Flags").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Flags::ACK_REQUEST_RELAY => 0,
                Flags::ACK_REQUEST_E2E => 1,
                Flags::ACK_REQUEST_IMMEDIATE => 2,
                Flags::NOT_PRIMARY_TRANSPORT_E2E => 3,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Flags {
        fn default() -> Self {
            Flags::ACK_REQUEST_RELAY
        }
    }

    impl Flags {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Flags>("CMsgSteamDatagramConnectionStatsP2PRouterToClient.Flags")
        }
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramP2PBadRouteRouterToClient)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramP2PBadRouteRouterToClient {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PBadRouteRouterToClient.connection_id)
    pub connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PBadRouteRouterToClient.failed_relay_routing_token)
    pub failed_relay_routing_token: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PBadRouteRouterToClient.ack_forward_target_revision)
    pub ack_forward_target_revision: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PBadRouteRouterToClient.kludge_pad)
    pub kludge_pad: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramP2PBadRouteRouterToClient.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramP2PBadRouteRouterToClient {
    fn default() -> &'a CMsgSteamDatagramP2PBadRouteRouterToClient {
        <CMsgSteamDatagramP2PBadRouteRouterToClient as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramP2PBadRouteRouterToClient {
    pub fn new() -> CMsgSteamDatagramP2PBadRouteRouterToClient {
        ::std::default::Default::default()
    }

    // optional fixed32 connection_id = 1;

    pub fn connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }

    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }

    // optional bytes failed_relay_routing_token = 2;

    pub fn failed_relay_routing_token(&self) -> &[u8] {
        match self.failed_relay_routing_token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_failed_relay_routing_token(&mut self) {
        self.failed_relay_routing_token = ::std::option::Option::None;
    }

    pub fn has_failed_relay_routing_token(&self) -> bool {
        self.failed_relay_routing_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_failed_relay_routing_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.failed_relay_routing_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_failed_relay_routing_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.failed_relay_routing_token.is_none() {
            self.failed_relay_routing_token = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.failed_relay_routing_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_failed_relay_routing_token(&mut self) -> ::std::vec::Vec<u8> {
        self.failed_relay_routing_token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 ack_forward_target_revision = 3;

    pub fn ack_forward_target_revision(&self) -> u32 {
        self.ack_forward_target_revision.unwrap_or(0)
    }

    pub fn clear_ack_forward_target_revision(&mut self) {
        self.ack_forward_target_revision = ::std::option::Option::None;
    }

    pub fn has_ack_forward_target_revision(&self) -> bool {
        self.ack_forward_target_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ack_forward_target_revision(&mut self, v: u32) {
        self.ack_forward_target_revision = ::std::option::Option::Some(v);
    }

    // optional fixed64 kludge_pad = 99;

    pub fn kludge_pad(&self) -> u64 {
        self.kludge_pad.unwrap_or(0)
    }

    pub fn clear_kludge_pad(&mut self) {
        self.kludge_pad = ::std::option::Option::None;
    }

    pub fn has_kludge_pad(&self) -> bool {
        self.kludge_pad.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kludge_pad(&mut self, v: u64) {
        self.kludge_pad = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "connection_id",
            |m: &CMsgSteamDatagramP2PBadRouteRouterToClient| { &m.connection_id },
            |m: &mut CMsgSteamDatagramP2PBadRouteRouterToClient| { &mut m.connection_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "failed_relay_routing_token",
            |m: &CMsgSteamDatagramP2PBadRouteRouterToClient| { &m.failed_relay_routing_token },
            |m: &mut CMsgSteamDatagramP2PBadRouteRouterToClient| { &mut m.failed_relay_routing_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ack_forward_target_revision",
            |m: &CMsgSteamDatagramP2PBadRouteRouterToClient| { &m.ack_forward_target_revision },
            |m: &mut CMsgSteamDatagramP2PBadRouteRouterToClient| { &mut m.ack_forward_target_revision },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kludge_pad",
            |m: &CMsgSteamDatagramP2PBadRouteRouterToClient| { &m.kludge_pad },
            |m: &mut CMsgSteamDatagramP2PBadRouteRouterToClient| { &mut m.kludge_pad },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramP2PBadRouteRouterToClient>(
            "CMsgSteamDatagramP2PBadRouteRouterToClient",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramP2PBadRouteRouterToClient {
    const NAME: &'static str = "CMsgSteamDatagramP2PBadRouteRouterToClient";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                18 => {
                    self.failed_relay_routing_token = ::std::option::Option::Some(is.read_bytes()?);
                },
                24 => {
                    self.ack_forward_target_revision = ::std::option::Option::Some(is.read_uint32()?);
                },
                793 => {
                    self.kludge_pad = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.failed_relay_routing_token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.ack_forward_target_revision {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.kludge_pad {
            my_size += 2 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.failed_relay_routing_token.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.ack_forward_target_revision {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.kludge_pad {
            os.write_fixed64(99, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramP2PBadRouteRouterToClient {
        CMsgSteamDatagramP2PBadRouteRouterToClient::new()
    }

    fn clear(&mut self) {
        self.connection_id = ::std::option::Option::None;
        self.failed_relay_routing_token = ::std::option::Option::None;
        self.ack_forward_target_revision = ::std::option::Option::None;
        self.kludge_pad = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramP2PBadRouteRouterToClient {
        static instance: CMsgSteamDatagramP2PBadRouteRouterToClient = CMsgSteamDatagramP2PBadRouteRouterToClient {
            connection_id: ::std::option::Option::None,
            failed_relay_routing_token: ::std::option::Option::None,
            ack_forward_target_revision: ::std::option::Option::None,
            kludge_pad: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramP2PBadRouteRouterToClient {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramP2PBadRouteRouterToClient").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramP2PBadRouteRouterToClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramP2PBadRouteRouterToClient {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamDatagramP2PRoutes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramP2PRoutes {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PRoutes.relay_clusters)
    pub relay_clusters: ::std::vec::Vec<cmsg_steam_datagram_p2proutes::RelayCluster>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PRoutes.routes)
    pub routes: ::std::vec::Vec<cmsg_steam_datagram_p2proutes::Route>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PRoutes.revision)
    pub revision: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramP2PRoutes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramP2PRoutes {
    fn default() -> &'a CMsgSteamDatagramP2PRoutes {
        <CMsgSteamDatagramP2PRoutes as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramP2PRoutes {
    pub fn new() -> CMsgSteamDatagramP2PRoutes {
        ::std::default::Default::default()
    }

    // optional uint32 revision = 3;

    pub fn revision(&self) -> u32 {
        self.revision.unwrap_or(0)
    }

    pub fn clear_revision(&mut self) {
        self.revision = ::std::option::Option::None;
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: u32) {
        self.revision = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "relay_clusters",
            |m: &CMsgSteamDatagramP2PRoutes| { &m.relay_clusters },
            |m: &mut CMsgSteamDatagramP2PRoutes| { &mut m.relay_clusters },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "routes",
            |m: &CMsgSteamDatagramP2PRoutes| { &m.routes },
            |m: &mut CMsgSteamDatagramP2PRoutes| { &mut m.routes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "revision",
            |m: &CMsgSteamDatagramP2PRoutes| { &m.revision },
            |m: &mut CMsgSteamDatagramP2PRoutes| { &mut m.revision },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramP2PRoutes>(
            "CMsgSteamDatagramP2PRoutes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramP2PRoutes {
    const NAME: &'static str = "CMsgSteamDatagramP2PRoutes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.relay_clusters.push(is.read_message()?);
                },
                18 => {
                    self.routes.push(is.read_message()?);
                },
                24 => {
                    self.revision = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.relay_clusters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.routes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.revision {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.relay_clusters {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.routes {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.revision {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramP2PRoutes {
        CMsgSteamDatagramP2PRoutes::new()
    }

    fn clear(&mut self) {
        self.relay_clusters.clear();
        self.routes.clear();
        self.revision = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramP2PRoutes {
        static instance: CMsgSteamDatagramP2PRoutes = CMsgSteamDatagramP2PRoutes {
            relay_clusters: ::std::vec::Vec::new(),
            routes: ::std::vec::Vec::new(),
            revision: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramP2PRoutes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramP2PRoutes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramP2PRoutes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramP2PRoutes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSteamDatagramP2PRoutes`
pub mod cmsg_steam_datagram_p2proutes {
    // @@protoc_insertion_point(message:CMsgSteamDatagramP2PRoutes.RelayCluster)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RelayCluster {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamDatagramP2PRoutes.RelayCluster.pop_id)
        pub pop_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramP2PRoutes.RelayCluster.ping_ms)
        pub ping_ms: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramP2PRoutes.RelayCluster.score_penalty)
        pub score_penalty: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramP2PRoutes.RelayCluster.session_relay_routing_token)
        pub session_relay_routing_token: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamDatagramP2PRoutes.RelayCluster.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RelayCluster {
        fn default() -> &'a RelayCluster {
            <RelayCluster as ::protobuf::Message>::default_instance()
        }
    }

    impl RelayCluster {
        pub fn new() -> RelayCluster {
            ::std::default::Default::default()
        }

        // optional fixed32 pop_id = 1;

        pub fn pop_id(&self) -> u32 {
            self.pop_id.unwrap_or(0)
        }

        pub fn clear_pop_id(&mut self) {
            self.pop_id = ::std::option::Option::None;
        }

        pub fn has_pop_id(&self) -> bool {
            self.pop_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pop_id(&mut self, v: u32) {
            self.pop_id = ::std::option::Option::Some(v);
        }

        // optional uint32 ping_ms = 2;

        pub fn ping_ms(&self) -> u32 {
            self.ping_ms.unwrap_or(0)
        }

        pub fn clear_ping_ms(&mut self) {
            self.ping_ms = ::std::option::Option::None;
        }

        pub fn has_ping_ms(&self) -> bool {
            self.ping_ms.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ping_ms(&mut self, v: u32) {
            self.ping_ms = ::std::option::Option::Some(v);
        }

        // optional uint32 score_penalty = 3;

        pub fn score_penalty(&self) -> u32 {
            self.score_penalty.unwrap_or(0)
        }

        pub fn clear_score_penalty(&mut self) {
            self.score_penalty = ::std::option::Option::None;
        }

        pub fn has_score_penalty(&self) -> bool {
            self.score_penalty.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score_penalty(&mut self, v: u32) {
            self.score_penalty = ::std::option::Option::Some(v);
        }

        // optional bytes session_relay_routing_token = 4;

        pub fn session_relay_routing_token(&self) -> &[u8] {
            match self.session_relay_routing_token.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_session_relay_routing_token(&mut self) {
            self.session_relay_routing_token = ::std::option::Option::None;
        }

        pub fn has_session_relay_routing_token(&self) -> bool {
            self.session_relay_routing_token.is_some()
        }

        // Param is passed by value, moved
        pub fn set_session_relay_routing_token(&mut self, v: ::std::vec::Vec<u8>) {
            self.session_relay_routing_token = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_session_relay_routing_token(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.session_relay_routing_token.is_none() {
                self.session_relay_routing_token = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.session_relay_routing_token.as_mut().unwrap()
        }

        // Take field
        pub fn take_session_relay_routing_token(&mut self) -> ::std::vec::Vec<u8> {
            self.session_relay_routing_token.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "pop_id",
                |m: &RelayCluster| { &m.pop_id },
                |m: &mut RelayCluster| { &mut m.pop_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ping_ms",
                |m: &RelayCluster| { &m.ping_ms },
                |m: &mut RelayCluster| { &mut m.ping_ms },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "score_penalty",
                |m: &RelayCluster| { &m.score_penalty },
                |m: &mut RelayCluster| { &mut m.score_penalty },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "session_relay_routing_token",
                |m: &RelayCluster| { &m.session_relay_routing_token },
                |m: &mut RelayCluster| { &mut m.session_relay_routing_token },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RelayCluster>(
                "CMsgSteamDatagramP2PRoutes.RelayCluster",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RelayCluster {
        const NAME: &'static str = "RelayCluster";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.pop_id = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    16 => {
                        self.ping_ms = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.score_penalty = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    34 => {
                        self.session_relay_routing_token = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.pop_id {
                my_size += 1 + 4;
            }
            if let Some(v) = self.ping_ms {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.score_penalty {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.session_relay_routing_token.as_ref() {
                my_size += ::protobuf::rt::bytes_size(4, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.pop_id {
                os.write_fixed32(1, v)?;
            }
            if let Some(v) = self.ping_ms {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.score_penalty {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.session_relay_routing_token.as_ref() {
                os.write_bytes(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RelayCluster {
            RelayCluster::new()
        }

        fn clear(&mut self) {
            self.pop_id = ::std::option::Option::None;
            self.ping_ms = ::std::option::Option::None;
            self.score_penalty = ::std::option::Option::None;
            self.session_relay_routing_token = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RelayCluster {
            static instance: RelayCluster = RelayCluster {
                pop_id: ::std::option::Option::None,
                ping_ms: ::std::option::Option::None,
                score_penalty: ::std::option::Option::None,
                session_relay_routing_token: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RelayCluster {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSteamDatagramP2PRoutes.RelayCluster").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RelayCluster {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RelayCluster {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgSteamDatagramP2PRoutes.Route)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Route {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamDatagramP2PRoutes.Route.my_pop_id)
        pub my_pop_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramP2PRoutes.Route.your_pop_id)
        pub your_pop_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramP2PRoutes.Route.score)
        pub score: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamDatagramP2PRoutes.Route.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Route {
        fn default() -> &'a Route {
            <Route as ::protobuf::Message>::default_instance()
        }
    }

    impl Route {
        pub fn new() -> Route {
            ::std::default::Default::default()
        }

        // optional fixed32 my_pop_id = 1;

        pub fn my_pop_id(&self) -> u32 {
            self.my_pop_id.unwrap_or(0)
        }

        pub fn clear_my_pop_id(&mut self) {
            self.my_pop_id = ::std::option::Option::None;
        }

        pub fn has_my_pop_id(&self) -> bool {
            self.my_pop_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_my_pop_id(&mut self, v: u32) {
            self.my_pop_id = ::std::option::Option::Some(v);
        }

        // optional fixed32 your_pop_id = 2;

        pub fn your_pop_id(&self) -> u32 {
            self.your_pop_id.unwrap_or(0)
        }

        pub fn clear_your_pop_id(&mut self) {
            self.your_pop_id = ::std::option::Option::None;
        }

        pub fn has_your_pop_id(&self) -> bool {
            self.your_pop_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_your_pop_id(&mut self, v: u32) {
            self.your_pop_id = ::std::option::Option::Some(v);
        }

        // optional uint32 score = 3;

        pub fn score(&self) -> u32 {
            self.score.unwrap_or(0)
        }

        pub fn clear_score(&mut self) {
            self.score = ::std::option::Option::None;
        }

        pub fn has_score(&self) -> bool {
            self.score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score(&mut self, v: u32) {
            self.score = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "my_pop_id",
                |m: &Route| { &m.my_pop_id },
                |m: &mut Route| { &mut m.my_pop_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "your_pop_id",
                |m: &Route| { &m.your_pop_id },
                |m: &mut Route| { &mut m.your_pop_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "score",
                |m: &Route| { &m.score },
                |m: &mut Route| { &mut m.score },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Route>(
                "CMsgSteamDatagramP2PRoutes.Route",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Route {
        const NAME: &'static str = "Route";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.my_pop_id = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    21 => {
                        self.your_pop_id = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    24 => {
                        self.score = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.my_pop_id {
                my_size += 1 + 4;
            }
            if let Some(v) = self.your_pop_id {
                my_size += 1 + 4;
            }
            if let Some(v) = self.score {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.my_pop_id {
                os.write_fixed32(1, v)?;
            }
            if let Some(v) = self.your_pop_id {
                os.write_fixed32(2, v)?;
            }
            if let Some(v) = self.score {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Route {
            Route::new()
        }

        fn clear(&mut self) {
            self.my_pop_id = ::std::option::Option::None;
            self.your_pop_id = ::std::option::Option::None;
            self.score = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Route {
            static instance: Route = Route {
                my_pop_id: ::std::option::Option::None,
                your_pop_id: ::std::option::Option::None,
                score: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Route {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSteamDatagramP2PRoutes.Route").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Route {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Route {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramGameServerSample)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramGameServerSample {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameServerSample.ipv4)
    pub ipv4: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameServerSample.port)
    pub port: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramGameServerSample.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramGameServerSample {
    fn default() -> &'a CMsgSteamDatagramGameServerSample {
        <CMsgSteamDatagramGameServerSample as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramGameServerSample {
    pub fn new() -> CMsgSteamDatagramGameServerSample {
        ::std::default::Default::default()
    }

    // optional fixed32 ipv4 = 1;

    pub fn ipv4(&self) -> u32 {
        self.ipv4.unwrap_or(0)
    }

    pub fn clear_ipv4(&mut self) {
        self.ipv4 = ::std::option::Option::None;
    }

    pub fn has_ipv4(&self) -> bool {
        self.ipv4.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ipv4(&mut self, v: u32) {
        self.ipv4 = ::std::option::Option::Some(v);
    }

    // optional uint32 port = 2;

    pub fn port(&self) -> u32 {
        self.port.unwrap_or(0)
    }

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ipv4",
            |m: &CMsgSteamDatagramGameServerSample| { &m.ipv4 },
            |m: &mut CMsgSteamDatagramGameServerSample| { &mut m.ipv4 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "port",
            |m: &CMsgSteamDatagramGameServerSample| { &m.port },
            |m: &mut CMsgSteamDatagramGameServerSample| { &mut m.port },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramGameServerSample>(
            "CMsgSteamDatagramGameServerSample",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramGameServerSample {
    const NAME: &'static str = "CMsgSteamDatagramGameServerSample";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.ipv4 = ::std::option::Option::Some(is.read_fixed32()?);
                },
                16 => {
                    self.port = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ipv4 {
            my_size += 1 + 4;
        }
        if let Some(v) = self.port {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ipv4 {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.port {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramGameServerSample {
        CMsgSteamDatagramGameServerSample::new()
    }

    fn clear(&mut self) {
        self.ipv4 = ::std::option::Option::None;
        self.port = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramGameServerSample {
        static instance: CMsgSteamDatagramGameServerSample = CMsgSteamDatagramGameServerSample {
            ipv4: ::std::option::Option::None,
            port: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramGameServerSample {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramGameServerSample").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramGameServerSample {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramGameServerSample {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamDatagramGameServerSampleDataCenter)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramGameServerSampleDataCenter {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameServerSampleDataCenter.datacenter_id)
    pub datacenter_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameServerSampleDataCenter.servers)
    pub servers: ::std::vec::Vec<CMsgSteamDatagramGameServerSample>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramGameServerSampleDataCenter.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramGameServerSampleDataCenter {
    fn default() -> &'a CMsgSteamDatagramGameServerSampleDataCenter {
        <CMsgSteamDatagramGameServerSampleDataCenter as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramGameServerSampleDataCenter {
    pub fn new() -> CMsgSteamDatagramGameServerSampleDataCenter {
        ::std::default::Default::default()
    }

    // optional fixed32 datacenter_id = 1;

    pub fn datacenter_id(&self) -> u32 {
        self.datacenter_id.unwrap_or(0)
    }

    pub fn clear_datacenter_id(&mut self) {
        self.datacenter_id = ::std::option::Option::None;
    }

    pub fn has_datacenter_id(&self) -> bool {
        self.datacenter_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_datacenter_id(&mut self, v: u32) {
        self.datacenter_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "datacenter_id",
            |m: &CMsgSteamDatagramGameServerSampleDataCenter| { &m.datacenter_id },
            |m: &mut CMsgSteamDatagramGameServerSampleDataCenter| { &mut m.datacenter_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "servers",
            |m: &CMsgSteamDatagramGameServerSampleDataCenter| { &m.servers },
            |m: &mut CMsgSteamDatagramGameServerSampleDataCenter| { &mut m.servers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramGameServerSampleDataCenter>(
            "CMsgSteamDatagramGameServerSampleDataCenter",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramGameServerSampleDataCenter {
    const NAME: &'static str = "CMsgSteamDatagramGameServerSampleDataCenter";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.datacenter_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                26 => {
                    self.servers.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.datacenter_id {
            my_size += 1 + 4;
        }
        for value in &self.servers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.datacenter_id {
            os.write_fixed32(1, v)?;
        }
        for v in &self.servers {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramGameServerSampleDataCenter {
        CMsgSteamDatagramGameServerSampleDataCenter::new()
    }

    fn clear(&mut self) {
        self.datacenter_id = ::std::option::Option::None;
        self.servers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramGameServerSampleDataCenter {
        static instance: CMsgSteamDatagramGameServerSampleDataCenter = CMsgSteamDatagramGameServerSampleDataCenter {
            datacenter_id: ::std::option::Option::None,
            servers: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramGameServerSampleDataCenter {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramGameServerSampleDataCenter").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramGameServerSampleDataCenter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramGameServerSampleDataCenter {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamDatagramRelayToRelayPing)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramRelayToRelayPing {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramRelayToRelayPing.request_timestamp)
    pub request_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRelayToRelayPing.request_date)
    pub request_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRelayToRelayPing.my_pop_id)
    pub my_pop_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRelayToRelayPing.your_pop_id)
    pub your_pop_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRelayToRelayPing.checksum)
    pub checksum: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRelayToRelayPing.data_centers)
    pub data_centers: ::std::vec::Vec<CMsgSteamDatagramGameServerSampleDataCenter>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramRelayToRelayPing.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramRelayToRelayPing {
    fn default() -> &'a CMsgSteamDatagramRelayToRelayPing {
        <CMsgSteamDatagramRelayToRelayPing as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramRelayToRelayPing {
    pub fn new() -> CMsgSteamDatagramRelayToRelayPing {
        ::std::default::Default::default()
    }

    // optional fixed32 request_timestamp = 1;

    pub fn request_timestamp(&self) -> u32 {
        self.request_timestamp.unwrap_or(0)
    }

    pub fn clear_request_timestamp(&mut self) {
        self.request_timestamp = ::std::option::Option::None;
    }

    pub fn has_request_timestamp(&self) -> bool {
        self.request_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_timestamp(&mut self, v: u32) {
        self.request_timestamp = ::std::option::Option::Some(v);
    }

    // optional fixed32 request_date = 2;

    pub fn request_date(&self) -> u32 {
        self.request_date.unwrap_or(0)
    }

    pub fn clear_request_date(&mut self) {
        self.request_date = ::std::option::Option::None;
    }

    pub fn has_request_date(&self) -> bool {
        self.request_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_date(&mut self, v: u32) {
        self.request_date = ::std::option::Option::Some(v);
    }

    // optional fixed32 my_pop_id = 3;

    pub fn my_pop_id(&self) -> u32 {
        self.my_pop_id.unwrap_or(0)
    }

    pub fn clear_my_pop_id(&mut self) {
        self.my_pop_id = ::std::option::Option::None;
    }

    pub fn has_my_pop_id(&self) -> bool {
        self.my_pop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_my_pop_id(&mut self, v: u32) {
        self.my_pop_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 your_pop_id = 4;

    pub fn your_pop_id(&self) -> u32 {
        self.your_pop_id.unwrap_or(0)
    }

    pub fn clear_your_pop_id(&mut self) {
        self.your_pop_id = ::std::option::Option::None;
    }

    pub fn has_your_pop_id(&self) -> bool {
        self.your_pop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_your_pop_id(&mut self, v: u32) {
        self.your_pop_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 checksum = 5;

    pub fn checksum(&self) -> u32 {
        self.checksum.unwrap_or(0)
    }

    pub fn clear_checksum(&mut self) {
        self.checksum = ::std::option::Option::None;
    }

    pub fn has_checksum(&self) -> bool {
        self.checksum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checksum(&mut self, v: u32) {
        self.checksum = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_timestamp",
            |m: &CMsgSteamDatagramRelayToRelayPing| { &m.request_timestamp },
            |m: &mut CMsgSteamDatagramRelayToRelayPing| { &mut m.request_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_date",
            |m: &CMsgSteamDatagramRelayToRelayPing| { &m.request_date },
            |m: &mut CMsgSteamDatagramRelayToRelayPing| { &mut m.request_date },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "my_pop_id",
            |m: &CMsgSteamDatagramRelayToRelayPing| { &m.my_pop_id },
            |m: &mut CMsgSteamDatagramRelayToRelayPing| { &mut m.my_pop_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "your_pop_id",
            |m: &CMsgSteamDatagramRelayToRelayPing| { &m.your_pop_id },
            |m: &mut CMsgSteamDatagramRelayToRelayPing| { &mut m.your_pop_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "checksum",
            |m: &CMsgSteamDatagramRelayToRelayPing| { &m.checksum },
            |m: &mut CMsgSteamDatagramRelayToRelayPing| { &mut m.checksum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data_centers",
            |m: &CMsgSteamDatagramRelayToRelayPing| { &m.data_centers },
            |m: &mut CMsgSteamDatagramRelayToRelayPing| { &mut m.data_centers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramRelayToRelayPing>(
            "CMsgSteamDatagramRelayToRelayPing",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramRelayToRelayPing {
    const NAME: &'static str = "CMsgSteamDatagramRelayToRelayPing";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.request_timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                21 => {
                    self.request_date = ::std::option::Option::Some(is.read_fixed32()?);
                },
                29 => {
                    self.my_pop_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                37 => {
                    self.your_pop_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                45 => {
                    self.checksum = ::std::option::Option::Some(is.read_fixed32()?);
                },
                50 => {
                    self.data_centers.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request_timestamp {
            my_size += 1 + 4;
        }
        if let Some(v) = self.request_date {
            my_size += 1 + 4;
        }
        if let Some(v) = self.my_pop_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.your_pop_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.checksum {
            my_size += 1 + 4;
        }
        for value in &self.data_centers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.request_timestamp {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.request_date {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.my_pop_id {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.your_pop_id {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.checksum {
            os.write_fixed32(5, v)?;
        }
        for v in &self.data_centers {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramRelayToRelayPing {
        CMsgSteamDatagramRelayToRelayPing::new()
    }

    fn clear(&mut self) {
        self.request_timestamp = ::std::option::Option::None;
        self.request_date = ::std::option::Option::None;
        self.my_pop_id = ::std::option::Option::None;
        self.your_pop_id = ::std::option::Option::None;
        self.checksum = ::std::option::Option::None;
        self.data_centers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramRelayToRelayPing {
        static instance: CMsgSteamDatagramRelayToRelayPing = CMsgSteamDatagramRelayToRelayPing {
            request_timestamp: ::std::option::Option::None,
            request_date: ::std::option::Option::None,
            my_pop_id: ::std::option::Option::None,
            your_pop_id: ::std::option::Option::None,
            checksum: ::std::option::Option::None,
            data_centers: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramRelayToRelayPing {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramRelayToRelayPing").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramRelayToRelayPing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramRelayToRelayPing {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamDatagramDataCenterState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramDataCenterState {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramDataCenterState.data_centers)
    pub data_centers: ::std::vec::Vec<cmsg_steam_datagram_data_center_state::DataCenter>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramDataCenterState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramDataCenterState {
    fn default() -> &'a CMsgSteamDatagramDataCenterState {
        <CMsgSteamDatagramDataCenterState as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramDataCenterState {
    pub fn new() -> CMsgSteamDatagramDataCenterState {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data_centers",
            |m: &CMsgSteamDatagramDataCenterState| { &m.data_centers },
            |m: &mut CMsgSteamDatagramDataCenterState| { &mut m.data_centers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramDataCenterState>(
            "CMsgSteamDatagramDataCenterState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramDataCenterState {
    const NAME: &'static str = "CMsgSteamDatagramDataCenterState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data_centers.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.data_centers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.data_centers {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramDataCenterState {
        CMsgSteamDatagramDataCenterState::new()
    }

    fn clear(&mut self) {
        self.data_centers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramDataCenterState {
        static instance: CMsgSteamDatagramDataCenterState = CMsgSteamDatagramDataCenterState {
            data_centers: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramDataCenterState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramDataCenterState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramDataCenterState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramDataCenterState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSteamDatagramDataCenterState`
pub mod cmsg_steam_datagram_data_center_state {
    // @@protoc_insertion_point(message:CMsgSteamDatagramDataCenterState.Server)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Server {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamDatagramDataCenterState.Server.address)
        pub address: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramDataCenterState.Server.ping_ms)
        pub ping_ms: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamDatagramDataCenterState.Server.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Server {
        fn default() -> &'a Server {
            <Server as ::protobuf::Message>::default_instance()
        }
    }

    impl Server {
        pub fn new() -> Server {
            ::std::default::Default::default()
        }

        // optional string address = 1;

        pub fn address(&self) -> &str {
            match self.address.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_address(&mut self) {
            self.address = ::std::option::Option::None;
        }

        pub fn has_address(&self) -> bool {
            self.address.is_some()
        }

        // Param is passed by value, moved
        pub fn set_address(&mut self, v: ::std::string::String) {
            self.address = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_address(&mut self) -> &mut ::std::string::String {
            if self.address.is_none() {
                self.address = ::std::option::Option::Some(::std::string::String::new());
            }
            self.address.as_mut().unwrap()
        }

        // Take field
        pub fn take_address(&mut self) -> ::std::string::String {
            self.address.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 ping_ms = 2;

        pub fn ping_ms(&self) -> u32 {
            self.ping_ms.unwrap_or(0)
        }

        pub fn clear_ping_ms(&mut self) {
            self.ping_ms = ::std::option::Option::None;
        }

        pub fn has_ping_ms(&self) -> bool {
            self.ping_ms.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ping_ms(&mut self, v: u32) {
            self.ping_ms = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "address",
                |m: &Server| { &m.address },
                |m: &mut Server| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ping_ms",
                |m: &Server| { &m.ping_ms },
                |m: &mut Server| { &mut m.ping_ms },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Server>(
                "CMsgSteamDatagramDataCenterState.Server",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Server {
        const NAME: &'static str = "Server";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.address = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.ping_ms = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.address.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.ping_ms {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.address.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.ping_ms {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Server {
            Server::new()
        }

        fn clear(&mut self) {
            self.address = ::std::option::Option::None;
            self.ping_ms = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Server {
            static instance: Server = Server {
                address: ::std::option::Option::None,
                ping_ms: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Server {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSteamDatagramDataCenterState.Server").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Server {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Server {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgSteamDatagramDataCenterState.DataCenter)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DataCenter {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamDatagramDataCenterState.DataCenter.code)
        pub code: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramDataCenterState.DataCenter.server_sample)
        pub server_sample: ::std::vec::Vec<Server>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramDataCenterState.DataCenter.relay_sample)
        pub relay_sample: ::std::vec::Vec<Server>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamDatagramDataCenterState.DataCenter.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DataCenter {
        fn default() -> &'a DataCenter {
            <DataCenter as ::protobuf::Message>::default_instance()
        }
    }

    impl DataCenter {
        pub fn new() -> DataCenter {
            ::std::default::Default::default()
        }

        // optional string code = 1;

        pub fn code(&self) -> &str {
            match self.code.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_code(&mut self) {
            self.code = ::std::option::Option::None;
        }

        pub fn has_code(&self) -> bool {
            self.code.is_some()
        }

        // Param is passed by value, moved
        pub fn set_code(&mut self, v: ::std::string::String) {
            self.code = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_code(&mut self) -> &mut ::std::string::String {
            if self.code.is_none() {
                self.code = ::std::option::Option::Some(::std::string::String::new());
            }
            self.code.as_mut().unwrap()
        }

        // Take field
        pub fn take_code(&mut self) -> ::std::string::String {
            self.code.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "code",
                |m: &DataCenter| { &m.code },
                |m: &mut DataCenter| { &mut m.code },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "server_sample",
                |m: &DataCenter| { &m.server_sample },
                |m: &mut DataCenter| { &mut m.server_sample },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "relay_sample",
                |m: &DataCenter| { &m.relay_sample },
                |m: &mut DataCenter| { &mut m.relay_sample },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DataCenter>(
                "CMsgSteamDatagramDataCenterState.DataCenter",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for DataCenter {
        const NAME: &'static str = "DataCenter";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.code = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.server_sample.push(is.read_message()?);
                    },
                    26 => {
                        self.relay_sample.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.code.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            for value in &self.server_sample {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.relay_sample {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.code.as_ref() {
                os.write_string(1, v)?;
            }
            for v in &self.server_sample {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            for v in &self.relay_sample {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DataCenter {
            DataCenter::new()
        }

        fn clear(&mut self) {
            self.code = ::std::option::Option::None;
            self.server_sample.clear();
            self.relay_sample.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DataCenter {
            static instance: DataCenter = DataCenter {
                code: ::std::option::Option::None,
                server_sample: ::std::vec::Vec::new(),
                relay_sample: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for DataCenter {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSteamDatagramDataCenterState.DataCenter").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DataCenter {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for DataCenter {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramRouterHealth)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramRouterHealth {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterHealth.cpu_load)
    pub cpu_load: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterHealth.cpu_load_raw)
    pub cpu_load_raw: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterHealth.active_sessions)
    pub active_sessions: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterHealth.data_pkts_sec)
    pub data_pkts_sec: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterHealth.other_pkts_sec)
    pub other_pkts_sec: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterHealth.seconds_until_shutdown)
    pub seconds_until_shutdown: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterHealth.cpu_cost_per_user)
    pub cpu_cost_per_user: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterHealth.cpu_cost_per_packet)
    pub cpu_cost_per_packet: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterHealth.data_centers)
    pub data_centers: ::std::vec::Vec<cmsg_steam_datagram_router_health::DataCenter>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterHealth.magic)
    pub magic: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramRouterHealth.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramRouterHealth {
    fn default() -> &'a CMsgSteamDatagramRouterHealth {
        <CMsgSteamDatagramRouterHealth as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramRouterHealth {
    pub fn new() -> CMsgSteamDatagramRouterHealth {
        ::std::default::Default::default()
    }

    // optional float cpu_load = 1;

    pub fn cpu_load(&self) -> f32 {
        self.cpu_load.unwrap_or(0.)
    }

    pub fn clear_cpu_load(&mut self) {
        self.cpu_load = ::std::option::Option::None;
    }

    pub fn has_cpu_load(&self) -> bool {
        self.cpu_load.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_load(&mut self, v: f32) {
        self.cpu_load = ::std::option::Option::Some(v);
    }

    // optional float cpu_load_raw = 10;

    pub fn cpu_load_raw(&self) -> f32 {
        self.cpu_load_raw.unwrap_or(0.)
    }

    pub fn clear_cpu_load_raw(&mut self) {
        self.cpu_load_raw = ::std::option::Option::None;
    }

    pub fn has_cpu_load_raw(&self) -> bool {
        self.cpu_load_raw.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_load_raw(&mut self, v: f32) {
        self.cpu_load_raw = ::std::option::Option::Some(v);
    }

    // optional uint32 active_sessions = 2;

    pub fn active_sessions(&self) -> u32 {
        self.active_sessions.unwrap_or(0)
    }

    pub fn clear_active_sessions(&mut self) {
        self.active_sessions = ::std::option::Option::None;
    }

    pub fn has_active_sessions(&self) -> bool {
        self.active_sessions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_sessions(&mut self, v: u32) {
        self.active_sessions = ::std::option::Option::Some(v);
    }

    // optional uint32 data_pkts_sec = 3;

    pub fn data_pkts_sec(&self) -> u32 {
        self.data_pkts_sec.unwrap_or(0)
    }

    pub fn clear_data_pkts_sec(&mut self) {
        self.data_pkts_sec = ::std::option::Option::None;
    }

    pub fn has_data_pkts_sec(&self) -> bool {
        self.data_pkts_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_pkts_sec(&mut self, v: u32) {
        self.data_pkts_sec = ::std::option::Option::Some(v);
    }

    // optional uint32 other_pkts_sec = 4;

    pub fn other_pkts_sec(&self) -> u32 {
        self.other_pkts_sec.unwrap_or(0)
    }

    pub fn clear_other_pkts_sec(&mut self) {
        self.other_pkts_sec = ::std::option::Option::None;
    }

    pub fn has_other_pkts_sec(&self) -> bool {
        self.other_pkts_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_pkts_sec(&mut self, v: u32) {
        self.other_pkts_sec = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_until_shutdown = 5;

    pub fn seconds_until_shutdown(&self) -> u32 {
        self.seconds_until_shutdown.unwrap_or(0)
    }

    pub fn clear_seconds_until_shutdown(&mut self) {
        self.seconds_until_shutdown = ::std::option::Option::None;
    }

    pub fn has_seconds_until_shutdown(&self) -> bool {
        self.seconds_until_shutdown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_until_shutdown(&mut self, v: u32) {
        self.seconds_until_shutdown = ::std::option::Option::Some(v);
    }

    // optional float cpu_cost_per_user = 8;

    pub fn cpu_cost_per_user(&self) -> f32 {
        self.cpu_cost_per_user.unwrap_or(0.)
    }

    pub fn clear_cpu_cost_per_user(&mut self) {
        self.cpu_cost_per_user = ::std::option::Option::None;
    }

    pub fn has_cpu_cost_per_user(&self) -> bool {
        self.cpu_cost_per_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_cost_per_user(&mut self, v: f32) {
        self.cpu_cost_per_user = ::std::option::Option::Some(v);
    }

    // optional float cpu_cost_per_packet = 9;

    pub fn cpu_cost_per_packet(&self) -> f32 {
        self.cpu_cost_per_packet.unwrap_or(0.)
    }

    pub fn clear_cpu_cost_per_packet(&mut self) {
        self.cpu_cost_per_packet = ::std::option::Option::None;
    }

    pub fn has_cpu_cost_per_packet(&self) -> bool {
        self.cpu_cost_per_packet.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_cost_per_packet(&mut self, v: f32) {
        self.cpu_cost_per_packet = ::std::option::Option::Some(v);
    }

    // optional fixed64 magic = 7;

    pub fn magic(&self) -> u64 {
        self.magic.unwrap_or(0)
    }

    pub fn clear_magic(&mut self) {
        self.magic = ::std::option::Option::None;
    }

    pub fn has_magic(&self) -> bool {
        self.magic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_magic(&mut self, v: u64) {
        self.magic = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cpu_load",
            |m: &CMsgSteamDatagramRouterHealth| { &m.cpu_load },
            |m: &mut CMsgSteamDatagramRouterHealth| { &mut m.cpu_load },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cpu_load_raw",
            |m: &CMsgSteamDatagramRouterHealth| { &m.cpu_load_raw },
            |m: &mut CMsgSteamDatagramRouterHealth| { &mut m.cpu_load_raw },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "active_sessions",
            |m: &CMsgSteamDatagramRouterHealth| { &m.active_sessions },
            |m: &mut CMsgSteamDatagramRouterHealth| { &mut m.active_sessions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data_pkts_sec",
            |m: &CMsgSteamDatagramRouterHealth| { &m.data_pkts_sec },
            |m: &mut CMsgSteamDatagramRouterHealth| { &mut m.data_pkts_sec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "other_pkts_sec",
            |m: &CMsgSteamDatagramRouterHealth| { &m.other_pkts_sec },
            |m: &mut CMsgSteamDatagramRouterHealth| { &mut m.other_pkts_sec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seconds_until_shutdown",
            |m: &CMsgSteamDatagramRouterHealth| { &m.seconds_until_shutdown },
            |m: &mut CMsgSteamDatagramRouterHealth| { &mut m.seconds_until_shutdown },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cpu_cost_per_user",
            |m: &CMsgSteamDatagramRouterHealth| { &m.cpu_cost_per_user },
            |m: &mut CMsgSteamDatagramRouterHealth| { &mut m.cpu_cost_per_user },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cpu_cost_per_packet",
            |m: &CMsgSteamDatagramRouterHealth| { &m.cpu_cost_per_packet },
            |m: &mut CMsgSteamDatagramRouterHealth| { &mut m.cpu_cost_per_packet },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data_centers",
            |m: &CMsgSteamDatagramRouterHealth| { &m.data_centers },
            |m: &mut CMsgSteamDatagramRouterHealth| { &mut m.data_centers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "magic",
            |m: &CMsgSteamDatagramRouterHealth| { &m.magic },
            |m: &mut CMsgSteamDatagramRouterHealth| { &mut m.magic },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramRouterHealth>(
            "CMsgSteamDatagramRouterHealth",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramRouterHealth {
    const NAME: &'static str = "CMsgSteamDatagramRouterHealth";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.cpu_load = ::std::option::Option::Some(is.read_float()?);
                },
                85 => {
                    self.cpu_load_raw = ::std::option::Option::Some(is.read_float()?);
                },
                16 => {
                    self.active_sessions = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.data_pkts_sec = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.other_pkts_sec = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.seconds_until_shutdown = ::std::option::Option::Some(is.read_uint32()?);
                },
                69 => {
                    self.cpu_cost_per_user = ::std::option::Option::Some(is.read_float()?);
                },
                77 => {
                    self.cpu_cost_per_packet = ::std::option::Option::Some(is.read_float()?);
                },
                50 => {
                    self.data_centers.push(is.read_message()?);
                },
                57 => {
                    self.magic = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cpu_load {
            my_size += 1 + 4;
        }
        if let Some(v) = self.cpu_load_raw {
            my_size += 1 + 4;
        }
        if let Some(v) = self.active_sessions {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.data_pkts_sec {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.other_pkts_sec {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.seconds_until_shutdown {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.cpu_cost_per_user {
            my_size += 1 + 4;
        }
        if let Some(v) = self.cpu_cost_per_packet {
            my_size += 1 + 4;
        }
        for value in &self.data_centers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.magic {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cpu_load {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.cpu_load_raw {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.active_sessions {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.data_pkts_sec {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.other_pkts_sec {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.seconds_until_shutdown {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.cpu_cost_per_user {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.cpu_cost_per_packet {
            os.write_float(9, v)?;
        }
        for v in &self.data_centers {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if let Some(v) = self.magic {
            os.write_fixed64(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramRouterHealth {
        CMsgSteamDatagramRouterHealth::new()
    }

    fn clear(&mut self) {
        self.cpu_load = ::std::option::Option::None;
        self.cpu_load_raw = ::std::option::Option::None;
        self.active_sessions = ::std::option::Option::None;
        self.data_pkts_sec = ::std::option::Option::None;
        self.other_pkts_sec = ::std::option::Option::None;
        self.seconds_until_shutdown = ::std::option::Option::None;
        self.cpu_cost_per_user = ::std::option::Option::None;
        self.cpu_cost_per_packet = ::std::option::Option::None;
        self.data_centers.clear();
        self.magic = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramRouterHealth {
        static instance: CMsgSteamDatagramRouterHealth = CMsgSteamDatagramRouterHealth {
            cpu_load: ::std::option::Option::None,
            cpu_load_raw: ::std::option::Option::None,
            active_sessions: ::std::option::Option::None,
            data_pkts_sec: ::std::option::Option::None,
            other_pkts_sec: ::std::option::Option::None,
            seconds_until_shutdown: ::std::option::Option::None,
            cpu_cost_per_user: ::std::option::Option::None,
            cpu_cost_per_packet: ::std::option::Option::None,
            data_centers: ::std::vec::Vec::new(),
            magic: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramRouterHealth {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramRouterHealth").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramRouterHealth {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramRouterHealth {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSteamDatagramRouterHealth`
pub mod cmsg_steam_datagram_router_health {
    // @@protoc_insertion_point(message:CMsgSteamDatagramRouterHealth.DataCenter)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DataCenter {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamDatagramRouterHealth.DataCenter.datacenter_id)
        pub datacenter_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramRouterHealth.DataCenter.state)
        pub state: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramRouterHealth.DataCenter.servers)
        pub servers: ::std::vec::Vec<super::CMsgSteamDatagramGameServerSample>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamDatagramRouterHealth.DataCenter.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DataCenter {
        fn default() -> &'a DataCenter {
            <DataCenter as ::protobuf::Message>::default_instance()
        }
    }

    impl DataCenter {
        pub fn new() -> DataCenter {
            ::std::default::Default::default()
        }

        // optional fixed32 datacenter_id = 1;

        pub fn datacenter_id(&self) -> u32 {
            self.datacenter_id.unwrap_or(0)
        }

        pub fn clear_datacenter_id(&mut self) {
            self.datacenter_id = ::std::option::Option::None;
        }

        pub fn has_datacenter_id(&self) -> bool {
            self.datacenter_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_datacenter_id(&mut self, v: u32) {
            self.datacenter_id = ::std::option::Option::Some(v);
        }

        // optional uint32 state = 2;

        pub fn state(&self) -> u32 {
            self.state.unwrap_or(0)
        }

        pub fn clear_state(&mut self) {
            self.state = ::std::option::Option::None;
        }

        pub fn has_state(&self) -> bool {
            self.state.is_some()
        }

        // Param is passed by value, moved
        pub fn set_state(&mut self, v: u32) {
            self.state = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "datacenter_id",
                |m: &DataCenter| { &m.datacenter_id },
                |m: &mut DataCenter| { &mut m.datacenter_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "state",
                |m: &DataCenter| { &m.state },
                |m: &mut DataCenter| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "servers",
                |m: &DataCenter| { &m.servers },
                |m: &mut DataCenter| { &mut m.servers },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DataCenter>(
                "CMsgSteamDatagramRouterHealth.DataCenter",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for DataCenter {
        const NAME: &'static str = "DataCenter";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.datacenter_id = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    16 => {
                        self.state = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.servers.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.datacenter_id {
                my_size += 1 + 4;
            }
            if let Some(v) = self.state {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            for value in &self.servers {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.datacenter_id {
                os.write_fixed32(1, v)?;
            }
            if let Some(v) = self.state {
                os.write_uint32(2, v)?;
            }
            for v in &self.servers {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DataCenter {
            DataCenter::new()
        }

        fn clear(&mut self) {
            self.datacenter_id = ::std::option::Option::None;
            self.state = ::std::option::Option::None;
            self.servers.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DataCenter {
            static instance: DataCenter = DataCenter {
                datacenter_id: ::std::option::Option::None,
                state: ::std::option::Option::None,
                servers: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for DataCenter {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSteamDatagramRouterHealth.DataCenter").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DataCenter {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for DataCenter {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramConnectionStatsP2PRouterToRouter)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramConnectionStatsP2PRouterToRouter {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToRouter.quality_relay)
    pub quality_relay: ::protobuf::MessageField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToRouter.quality_e2e)
    pub quality_e2e: ::protobuf::MessageField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToRouter.ack_relay)
    pub ack_relay: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToRouter.legacy_ack_e2e)
    pub legacy_ack_e2e: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToRouter.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToRouter.ack_forward_target_revision)
    pub ack_forward_target_revision: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToRouter.routes)
    pub routes: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToRouter.ack_peer_routes_revision)
    pub ack_peer_routes_revision: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToRouter.from_connection_id)
    pub from_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToRouter.to_connection_id)
    pub to_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToRouter.from_relay_session_id)
    pub from_relay_session_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToRouter.seq_num_nonce)
    pub seq_num_nonce: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToRouter.to_relay_session_id)
    pub to_relay_session_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToRouter.seq_num_r2r)
    pub seq_num_r2r: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToRouter.seq_num_e2e)
    pub seq_num_e2e: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramConnectionStatsP2PRouterToRouter.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectionStatsP2PRouterToRouter {
    fn default() -> &'a CMsgSteamDatagramConnectionStatsP2PRouterToRouter {
        <CMsgSteamDatagramConnectionStatsP2PRouterToRouter as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectionStatsP2PRouterToRouter {
    pub fn new() -> CMsgSteamDatagramConnectionStatsP2PRouterToRouter {
        ::std::default::Default::default()
    }

    // optional uint32 flags = 5;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 ack_forward_target_revision = 6;

    pub fn ack_forward_target_revision(&self) -> u32 {
        self.ack_forward_target_revision.unwrap_or(0)
    }

    pub fn clear_ack_forward_target_revision(&mut self) {
        self.ack_forward_target_revision = ::std::option::Option::None;
    }

    pub fn has_ack_forward_target_revision(&self) -> bool {
        self.ack_forward_target_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ack_forward_target_revision(&mut self, v: u32) {
        self.ack_forward_target_revision = ::std::option::Option::Some(v);
    }

    // optional bytes routes = 7;

    pub fn routes(&self) -> &[u8] {
        match self.routes.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_routes(&mut self) {
        self.routes = ::std::option::Option::None;
    }

    pub fn has_routes(&self) -> bool {
        self.routes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_routes(&mut self, v: ::std::vec::Vec<u8>) {
        self.routes = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_routes(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.routes.is_none() {
            self.routes = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.routes.as_mut().unwrap()
    }

    // Take field
    pub fn take_routes(&mut self) -> ::std::vec::Vec<u8> {
        self.routes.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 ack_peer_routes_revision = 8;

    pub fn ack_peer_routes_revision(&self) -> u32 {
        self.ack_peer_routes_revision.unwrap_or(0)
    }

    pub fn clear_ack_peer_routes_revision(&mut self) {
        self.ack_peer_routes_revision = ::std::option::Option::None;
    }

    pub fn has_ack_peer_routes_revision(&self) -> bool {
        self.ack_peer_routes_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ack_peer_routes_revision(&mut self, v: u32) {
        self.ack_peer_routes_revision = ::std::option::Option::Some(v);
    }

    // optional fixed32 from_connection_id = 21;

    pub fn from_connection_id(&self) -> u32 {
        self.from_connection_id.unwrap_or(0)
    }

    pub fn clear_from_connection_id(&mut self) {
        self.from_connection_id = ::std::option::Option::None;
    }

    pub fn has_from_connection_id(&self) -> bool {
        self.from_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_connection_id(&mut self, v: u32) {
        self.from_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 to_connection_id = 24;

    pub fn to_connection_id(&self) -> u32 {
        self.to_connection_id.unwrap_or(0)
    }

    pub fn clear_to_connection_id(&mut self) {
        self.to_connection_id = ::std::option::Option::None;
    }

    pub fn has_to_connection_id(&self) -> bool {
        self.to_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to_connection_id(&mut self, v: u32) {
        self.to_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 from_relay_session_id = 22;

    pub fn from_relay_session_id(&self) -> u32 {
        self.from_relay_session_id.unwrap_or(0)
    }

    pub fn clear_from_relay_session_id(&mut self) {
        self.from_relay_session_id = ::std::option::Option::None;
    }

    pub fn has_from_relay_session_id(&self) -> bool {
        self.from_relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_relay_session_id(&mut self, v: u32) {
        self.from_relay_session_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_nonce = 28;

    pub fn seq_num_nonce(&self) -> u32 {
        self.seq_num_nonce.unwrap_or(0)
    }

    pub fn clear_seq_num_nonce(&mut self) {
        self.seq_num_nonce = ::std::option::Option::None;
    }

    pub fn has_seq_num_nonce(&self) -> bool {
        self.seq_num_nonce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_nonce(&mut self, v: u32) {
        self.seq_num_nonce = ::std::option::Option::Some(v);
    }

    // optional fixed32 to_relay_session_id = 25;

    pub fn to_relay_session_id(&self) -> u32 {
        self.to_relay_session_id.unwrap_or(0)
    }

    pub fn clear_to_relay_session_id(&mut self) {
        self.to_relay_session_id = ::std::option::Option::None;
    }

    pub fn has_to_relay_session_id(&self) -> bool {
        self.to_relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to_relay_session_id(&mut self, v: u32) {
        self.to_relay_session_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_r2r = 26;

    pub fn seq_num_r2r(&self) -> u32 {
        self.seq_num_r2r.unwrap_or(0)
    }

    pub fn clear_seq_num_r2r(&mut self) {
        self.seq_num_r2r = ::std::option::Option::None;
    }

    pub fn has_seq_num_r2r(&self) -> bool {
        self.seq_num_r2r.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_r2r(&mut self, v: u32) {
        self.seq_num_r2r = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_e2e = 27;

    pub fn seq_num_e2e(&self) -> u32 {
        self.seq_num_e2e.unwrap_or(0)
    }

    pub fn clear_seq_num_e2e(&mut self) {
        self.seq_num_e2e = ::std::option::Option::None;
    }

    pub fn has_seq_num_e2e(&self) -> bool {
        self.seq_num_e2e.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_e2e(&mut self, v: u32) {
        self.seq_num_e2e = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(15);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>(
            "quality_relay",
            |m: &CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &m.quality_relay },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &mut m.quality_relay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>(
            "quality_e2e",
            |m: &CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &m.quality_e2e },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &mut m.quality_e2e },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ack_relay",
            |m: &CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &m.ack_relay },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &mut m.ack_relay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "legacy_ack_e2e",
            |m: &CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &m.legacy_ack_e2e },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &mut m.legacy_ack_e2e },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &m.flags },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ack_forward_target_revision",
            |m: &CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &m.ack_forward_target_revision },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &mut m.ack_forward_target_revision },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "routes",
            |m: &CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &m.routes },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &mut m.routes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ack_peer_routes_revision",
            |m: &CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &m.ack_peer_routes_revision },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &mut m.ack_peer_routes_revision },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "from_connection_id",
            |m: &CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &m.from_connection_id },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &mut m.from_connection_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "to_connection_id",
            |m: &CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &m.to_connection_id },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &mut m.to_connection_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "from_relay_session_id",
            |m: &CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &m.from_relay_session_id },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &mut m.from_relay_session_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seq_num_nonce",
            |m: &CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &m.seq_num_nonce },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &mut m.seq_num_nonce },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "to_relay_session_id",
            |m: &CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &m.to_relay_session_id },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &mut m.to_relay_session_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seq_num_r2r",
            |m: &CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &m.seq_num_r2r },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &mut m.seq_num_r2r },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seq_num_e2e",
            |m: &CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &m.seq_num_e2e },
            |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &mut m.seq_num_e2e },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramConnectionStatsP2PRouterToRouter>(
            "CMsgSteamDatagramConnectionStatsP2PRouterToRouter",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramConnectionStatsP2PRouterToRouter {
    const NAME: &'static str = "CMsgSteamDatagramConnectionStatsP2PRouterToRouter";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.quality_relay)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.quality_e2e)?;
                },
                26 => {
                    is.read_repeated_packed_fixed32_into(&mut self.ack_relay)?;
                },
                29 => {
                    self.ack_relay.push(is.read_fixed32()?);
                },
                34 => {
                    is.read_repeated_packed_fixed32_into(&mut self.legacy_ack_e2e)?;
                },
                37 => {
                    self.legacy_ack_e2e.push(is.read_fixed32()?);
                },
                40 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.ack_forward_target_revision = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.routes = ::std::option::Option::Some(is.read_bytes()?);
                },
                64 => {
                    self.ack_peer_routes_revision = ::std::option::Option::Some(is.read_uint32()?);
                },
                173 => {
                    self.from_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                197 => {
                    self.to_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                181 => {
                    self.from_relay_session_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                224 => {
                    self.seq_num_nonce = ::std::option::Option::Some(is.read_uint32()?);
                },
                205 => {
                    self.to_relay_session_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                208 => {
                    self.seq_num_r2r = ::std::option::Option::Some(is.read_uint32()?);
                },
                216 => {
                    self.seq_num_e2e = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quality_relay.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.quality_e2e.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += 5 * self.ack_relay.len() as u64;
        my_size += 5 * self.legacy_ack_e2e.len() as u64;
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.ack_forward_target_revision {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.routes.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.ack_peer_routes_revision {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.from_connection_id {
            my_size += 2 + 4;
        }
        if let Some(v) = self.to_connection_id {
            my_size += 2 + 4;
        }
        if let Some(v) = self.from_relay_session_id {
            my_size += 2 + 4;
        }
        if let Some(v) = self.seq_num_nonce {
            my_size += ::protobuf::rt::uint32_size(28, v);
        }
        if let Some(v) = self.to_relay_session_id {
            my_size += 2 + 4;
        }
        if let Some(v) = self.seq_num_r2r {
            my_size += ::protobuf::rt::uint32_size(26, v);
        }
        if let Some(v) = self.seq_num_e2e {
            my_size += ::protobuf::rt::uint32_size(27, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.quality_relay.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.quality_e2e.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.ack_relay {
            os.write_fixed32(3, *v)?;
        };
        for v in &self.legacy_ack_e2e {
            os.write_fixed32(4, *v)?;
        };
        if let Some(v) = self.flags {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.ack_forward_target_revision {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.routes.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.ack_peer_routes_revision {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.from_connection_id {
            os.write_fixed32(21, v)?;
        }
        if let Some(v) = self.to_connection_id {
            os.write_fixed32(24, v)?;
        }
        if let Some(v) = self.from_relay_session_id {
            os.write_fixed32(22, v)?;
        }
        if let Some(v) = self.seq_num_nonce {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.to_relay_session_id {
            os.write_fixed32(25, v)?;
        }
        if let Some(v) = self.seq_num_r2r {
            os.write_uint32(26, v)?;
        }
        if let Some(v) = self.seq_num_e2e {
            os.write_uint32(27, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramConnectionStatsP2PRouterToRouter {
        CMsgSteamDatagramConnectionStatsP2PRouterToRouter::new()
    }

    fn clear(&mut self) {
        self.quality_relay.clear();
        self.quality_e2e.clear();
        self.ack_relay.clear();
        self.legacy_ack_e2e.clear();
        self.flags = ::std::option::Option::None;
        self.ack_forward_target_revision = ::std::option::Option::None;
        self.routes = ::std::option::Option::None;
        self.ack_peer_routes_revision = ::std::option::Option::None;
        self.from_connection_id = ::std::option::Option::None;
        self.to_connection_id = ::std::option::Option::None;
        self.from_relay_session_id = ::std::option::Option::None;
        self.seq_num_nonce = ::std::option::Option::None;
        self.to_relay_session_id = ::std::option::Option::None;
        self.seq_num_r2r = ::std::option::Option::None;
        self.seq_num_e2e = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectionStatsP2PRouterToRouter {
        static instance: CMsgSteamDatagramConnectionStatsP2PRouterToRouter = CMsgSteamDatagramConnectionStatsP2PRouterToRouter {
            quality_relay: ::protobuf::MessageField::none(),
            quality_e2e: ::protobuf::MessageField::none(),
            ack_relay: ::std::vec::Vec::new(),
            legacy_ack_e2e: ::std::vec::Vec::new(),
            flags: ::std::option::Option::None,
            ack_forward_target_revision: ::std::option::Option::None,
            routes: ::std::option::Option::None,
            ack_peer_routes_revision: ::std::option::Option::None,
            from_connection_id: ::std::option::Option::None,
            to_connection_id: ::std::option::Option::None,
            from_relay_session_id: ::std::option::Option::None,
            seq_num_nonce: ::std::option::Option::None,
            to_relay_session_id: ::std::option::Option::None,
            seq_num_r2r: ::std::option::Option::None,
            seq_num_e2e: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramConnectionStatsP2PRouterToRouter {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramConnectionStatsP2PRouterToRouter").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramConnectionStatsP2PRouterToRouter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionStatsP2PRouterToRouter {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSteamDatagramConnectionStatsP2PRouterToRouter`
pub mod cmsg_steam_datagram_connection_stats_p2prouter_to_router {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgSteamDatagramConnectionStatsP2PRouterToRouter.Flags)
    pub enum Flags {
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsP2PRouterToRouter.Flags.ACK_REQUEST_RELAY)
        ACK_REQUEST_RELAY = 1,
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsP2PRouterToRouter.Flags.ACK_REQUEST_E2E)
        ACK_REQUEST_E2E = 2,
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsP2PRouterToRouter.Flags.ACK_REQUEST_IMMEDIATE)
        ACK_REQUEST_IMMEDIATE = 4,
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsP2PRouterToRouter.Flags.NOT_PRIMARY_TRANSPORT_E2E)
        NOT_PRIMARY_TRANSPORT_E2E = 16,
    }

    impl ::protobuf::Enum for Flags {
        const NAME: &'static str = "Flags";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Flags> {
            match value {
                1 => ::std::option::Option::Some(Flags::ACK_REQUEST_RELAY),
                2 => ::std::option::Option::Some(Flags::ACK_REQUEST_E2E),
                4 => ::std::option::Option::Some(Flags::ACK_REQUEST_IMMEDIATE),
                16 => ::std::option::Option::Some(Flags::NOT_PRIMARY_TRANSPORT_E2E),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Flags> {
            match str {
                "ACK_REQUEST_RELAY" => ::std::option::Option::Some(Flags::ACK_REQUEST_RELAY),
                "ACK_REQUEST_E2E" => ::std::option::Option::Some(Flags::ACK_REQUEST_E2E),
                "ACK_REQUEST_IMMEDIATE" => ::std::option::Option::Some(Flags::ACK_REQUEST_IMMEDIATE),
                "NOT_PRIMARY_TRANSPORT_E2E" => ::std::option::Option::Some(Flags::NOT_PRIMARY_TRANSPORT_E2E),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Flags] = &[
            Flags::ACK_REQUEST_RELAY,
            Flags::ACK_REQUEST_E2E,
            Flags::ACK_REQUEST_IMMEDIATE,
            Flags::NOT_PRIMARY_TRANSPORT_E2E,
        ];
    }

    impl ::protobuf::EnumFull for Flags {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgSteamDatagramConnectionStatsP2PRouterToRouter.Flags").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Flags::ACK_REQUEST_RELAY => 0,
                Flags::ACK_REQUEST_E2E => 1,
                Flags::ACK_REQUEST_IMMEDIATE => 2,
                Flags::NOT_PRIMARY_TRANSPORT_E2E => 3,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Flags {
        fn default() -> Self {
            Flags::ACK_REQUEST_RELAY
        }
    }

    impl Flags {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Flags>("CMsgSteamDatagramConnectionStatsP2PRouterToRouter.Flags")
        }
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramNetworkNextRouterPingRequestExtraData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramNetworkNextRouterPingRequestExtraData {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramNetworkNextRouterPingRequestExtraData.client_id)
    pub client_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNetworkNextRouterPingRequestExtraData.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNetworkNextRouterPingRequestExtraData.protocol_ver)
    pub protocol_ver: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramNetworkNextRouterPingRequestExtraData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramNetworkNextRouterPingRequestExtraData {
    fn default() -> &'a CMsgSteamDatagramNetworkNextRouterPingRequestExtraData {
        <CMsgSteamDatagramNetworkNextRouterPingRequestExtraData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramNetworkNextRouterPingRequestExtraData {
    pub fn new() -> CMsgSteamDatagramNetworkNextRouterPingRequestExtraData {
        ::std::default::Default::default()
    }

    // optional string client_id = 3;

    pub fn client_id(&self) -> &str {
        match self.client_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_client_id(&mut self) {
        self.client_id = ::std::option::Option::None;
    }

    pub fn has_client_id(&self) -> bool {
        self.client_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_id(&mut self, v: ::std::string::String) {
        self.client_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_id(&mut self) -> &mut ::std::string::String {
        if self.client_id.is_none() {
            self.client_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.client_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_client_id(&mut self) -> ::std::string::String {
        self.client_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 app_id = 4;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 protocol_ver = 5;

    pub fn protocol_ver(&self) -> u32 {
        self.protocol_ver.unwrap_or(0)
    }

    pub fn clear_protocol_ver(&mut self) {
        self.protocol_ver = ::std::option::Option::None;
    }

    pub fn has_protocol_ver(&self) -> bool {
        self.protocol_ver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_ver(&mut self, v: u32) {
        self.protocol_ver = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_id",
            |m: &CMsgSteamDatagramNetworkNextRouterPingRequestExtraData| { &m.client_id },
            |m: &mut CMsgSteamDatagramNetworkNextRouterPingRequestExtraData| { &mut m.client_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgSteamDatagramNetworkNextRouterPingRequestExtraData| { &m.app_id },
            |m: &mut CMsgSteamDatagramNetworkNextRouterPingRequestExtraData| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "protocol_ver",
            |m: &CMsgSteamDatagramNetworkNextRouterPingRequestExtraData| { &m.protocol_ver },
            |m: &mut CMsgSteamDatagramNetworkNextRouterPingRequestExtraData| { &mut m.protocol_ver },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramNetworkNextRouterPingRequestExtraData>(
            "CMsgSteamDatagramNetworkNextRouterPingRequestExtraData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramNetworkNextRouterPingRequestExtraData {
    const NAME: &'static str = "CMsgSteamDatagramNetworkNextRouterPingRequestExtraData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                26 => {
                    self.client_id = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.protocol_ver = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.client_id.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.protocol_ver {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.client_id.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.protocol_ver {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramNetworkNextRouterPingRequestExtraData {
        CMsgSteamDatagramNetworkNextRouterPingRequestExtraData::new()
    }

    fn clear(&mut self) {
        self.client_id = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.protocol_ver = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramNetworkNextRouterPingRequestExtraData {
        static instance: CMsgSteamDatagramNetworkNextRouterPingRequestExtraData = CMsgSteamDatagramNetworkNextRouterPingRequestExtraData {
            client_id: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            protocol_ver: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramNetworkNextRouterPingRequestExtraData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramNetworkNextRouterPingRequestExtraData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramNetworkNextRouterPingRequestExtraData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramNetworkNextRouterPingRequestExtraData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamDatagramNetworkNextRouterPingReplyExtraData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramNetworkNextRouterPingReplyExtraData {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramNetworkNextRouterPingReplyExtraData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramNetworkNextRouterPingReplyExtraData {
    fn default() -> &'a CMsgSteamDatagramNetworkNextRouterPingReplyExtraData {
        <CMsgSteamDatagramNetworkNextRouterPingReplyExtraData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramNetworkNextRouterPingReplyExtraData {
    pub fn new() -> CMsgSteamDatagramNetworkNextRouterPingReplyExtraData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramNetworkNextRouterPingReplyExtraData>(
            "CMsgSteamDatagramNetworkNextRouterPingReplyExtraData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramNetworkNextRouterPingReplyExtraData {
    const NAME: &'static str = "CMsgSteamDatagramNetworkNextRouterPingReplyExtraData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramNetworkNextRouterPingReplyExtraData {
        CMsgSteamDatagramNetworkNextRouterPingReplyExtraData::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramNetworkNextRouterPingReplyExtraData {
        static instance: CMsgSteamDatagramNetworkNextRouterPingReplyExtraData = CMsgSteamDatagramNetworkNextRouterPingReplyExtraData {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramNetworkNextRouterPingReplyExtraData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramNetworkNextRouterPingReplyExtraData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramNetworkNextRouterPingReplyExtraData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramNetworkNextRouterPingReplyExtraData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESteamDatagramMsgID)
pub enum ESteamDatagramMsgID {
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_Invalid)
    k_ESteamDatagramMsg_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_RouterPingRequest)
    k_ESteamDatagramMsg_RouterPingRequest = 1,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_RouterPingReply)
    k_ESteamDatagramMsg_RouterPingReply = 2,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_GameserverPingRequest)
    k_ESteamDatagramMsg_GameserverPingRequest = 3,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_LegacyGameserverPingReply)
    k_ESteamDatagramMsg_LegacyGameserverPingReply = 4,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_GameserverSessionRequest)
    k_ESteamDatagramMsg_GameserverSessionRequest = 5,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_GameserverSessionEstablished)
    k_ESteamDatagramMsg_GameserverSessionEstablished = 6,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_NoSession)
    k_ESteamDatagramMsg_NoSession = 7,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_Diagnostic)
    k_ESteamDatagramMsg_Diagnostic = 8,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_DataClientToRouter)
    k_ESteamDatagramMsg_DataClientToRouter = 9,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_DataRouterToServer)
    k_ESteamDatagramMsg_DataRouterToServer = 10,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_DataServerToRouter)
    k_ESteamDatagramMsg_DataServerToRouter = 11,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_DataRouterToClient)
    k_ESteamDatagramMsg_DataRouterToClient = 12,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_Stats)
    k_ESteamDatagramMsg_Stats = 13,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_ClientPingSampleRequest)
    k_ESteamDatagramMsg_ClientPingSampleRequest = 14,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_ClientPingSampleReply)
    k_ESteamDatagramMsg_ClientPingSampleReply = 15,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_ClientToRouterSwitchedPrimary)
    k_ESteamDatagramMsg_ClientToRouterSwitchedPrimary = 16,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_RelayHealth)
    k_ESteamDatagramMsg_RelayHealth = 17,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_ConnectRequest)
    k_ESteamDatagramMsg_ConnectRequest = 18,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_ConnectOK)
    k_ESteamDatagramMsg_ConnectOK = 19,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_ConnectionClosed)
    k_ESteamDatagramMsg_ConnectionClosed = 20,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_NoConnection)
    k_ESteamDatagramMsg_NoConnection = 21,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_RelayToRelayPingRequest)
    k_ESteamDatagramMsg_RelayToRelayPingRequest = 22,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_RelayToRelayPingReply)
    k_ESteamDatagramMsg_RelayToRelayPingReply = 23,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_P2PSessionRequest)
    k_ESteamDatagramMsg_P2PSessionRequest = 24,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_P2PSessionEstablished)
    k_ESteamDatagramMsg_P2PSessionEstablished = 25,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_P2PStatsClient)
    k_ESteamDatagramMsg_P2PStatsClient = 26,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_P2PStatsRelay)
    k_ESteamDatagramMsg_P2PStatsRelay = 27,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_P2PBadRoute)
    k_ESteamDatagramMsg_P2PBadRoute = 28,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_GameserverPingReply)
    k_ESteamDatagramMsg_GameserverPingReply = 29,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_GameserverRegistration)
    k_ESteamDatagramMsg_GameserverRegistration = 30,
}

impl ::protobuf::Enum for ESteamDatagramMsgID {
    const NAME: &'static str = "ESteamDatagramMsgID";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESteamDatagramMsgID> {
        match value {
            0 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_Invalid),
            1 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_RouterPingRequest),
            2 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_RouterPingReply),
            3 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverPingRequest),
            4 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_LegacyGameserverPingReply),
            5 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverSessionRequest),
            6 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverSessionEstablished),
            7 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_NoSession),
            8 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_Diagnostic),
            9 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_DataClientToRouter),
            10 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_DataRouterToServer),
            11 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_DataServerToRouter),
            12 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_DataRouterToClient),
            13 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_Stats),
            14 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_ClientPingSampleRequest),
            15 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_ClientPingSampleReply),
            16 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_ClientToRouterSwitchedPrimary),
            17 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_RelayHealth),
            18 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_ConnectRequest),
            19 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_ConnectOK),
            20 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_ConnectionClosed),
            21 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_NoConnection),
            22 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_RelayToRelayPingRequest),
            23 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_RelayToRelayPingReply),
            24 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_P2PSessionRequest),
            25 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_P2PSessionEstablished),
            26 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_P2PStatsClient),
            27 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_P2PStatsRelay),
            28 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_P2PBadRoute),
            29 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverPingReply),
            30 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverRegistration),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESteamDatagramMsgID> {
        match str {
            "k_ESteamDatagramMsg_Invalid" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_Invalid),
            "k_ESteamDatagramMsg_RouterPingRequest" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_RouterPingRequest),
            "k_ESteamDatagramMsg_RouterPingReply" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_RouterPingReply),
            "k_ESteamDatagramMsg_GameserverPingRequest" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverPingRequest),
            "k_ESteamDatagramMsg_LegacyGameserverPingReply" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_LegacyGameserverPingReply),
            "k_ESteamDatagramMsg_GameserverSessionRequest" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverSessionRequest),
            "k_ESteamDatagramMsg_GameserverSessionEstablished" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverSessionEstablished),
            "k_ESteamDatagramMsg_NoSession" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_NoSession),
            "k_ESteamDatagramMsg_Diagnostic" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_Diagnostic),
            "k_ESteamDatagramMsg_DataClientToRouter" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_DataClientToRouter),
            "k_ESteamDatagramMsg_DataRouterToServer" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_DataRouterToServer),
            "k_ESteamDatagramMsg_DataServerToRouter" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_DataServerToRouter),
            "k_ESteamDatagramMsg_DataRouterToClient" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_DataRouterToClient),
            "k_ESteamDatagramMsg_Stats" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_Stats),
            "k_ESteamDatagramMsg_ClientPingSampleRequest" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_ClientPingSampleRequest),
            "k_ESteamDatagramMsg_ClientPingSampleReply" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_ClientPingSampleReply),
            "k_ESteamDatagramMsg_ClientToRouterSwitchedPrimary" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_ClientToRouterSwitchedPrimary),
            "k_ESteamDatagramMsg_RelayHealth" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_RelayHealth),
            "k_ESteamDatagramMsg_ConnectRequest" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_ConnectRequest),
            "k_ESteamDatagramMsg_ConnectOK" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_ConnectOK),
            "k_ESteamDatagramMsg_ConnectionClosed" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_ConnectionClosed),
            "k_ESteamDatagramMsg_NoConnection" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_NoConnection),
            "k_ESteamDatagramMsg_RelayToRelayPingRequest" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_RelayToRelayPingRequest),
            "k_ESteamDatagramMsg_RelayToRelayPingReply" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_RelayToRelayPingReply),
            "k_ESteamDatagramMsg_P2PSessionRequest" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_P2PSessionRequest),
            "k_ESteamDatagramMsg_P2PSessionEstablished" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_P2PSessionEstablished),
            "k_ESteamDatagramMsg_P2PStatsClient" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_P2PStatsClient),
            "k_ESteamDatagramMsg_P2PStatsRelay" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_P2PStatsRelay),
            "k_ESteamDatagramMsg_P2PBadRoute" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_P2PBadRoute),
            "k_ESteamDatagramMsg_GameserverPingReply" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverPingReply),
            "k_ESteamDatagramMsg_GameserverRegistration" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverRegistration),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESteamDatagramMsgID] = &[
        ESteamDatagramMsgID::k_ESteamDatagramMsg_Invalid,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_RouterPingRequest,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_RouterPingReply,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverPingRequest,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_LegacyGameserverPingReply,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverSessionRequest,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverSessionEstablished,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_NoSession,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_Diagnostic,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_DataClientToRouter,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_DataRouterToServer,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_DataServerToRouter,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_DataRouterToClient,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_Stats,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_ClientPingSampleRequest,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_ClientPingSampleReply,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_ClientToRouterSwitchedPrimary,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_RelayHealth,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_ConnectRequest,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_ConnectOK,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_ConnectionClosed,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_NoConnection,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_RelayToRelayPingRequest,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_RelayToRelayPingReply,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_P2PSessionRequest,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_P2PSessionEstablished,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_P2PStatsClient,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_P2PStatsRelay,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_P2PBadRoute,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverPingReply,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverRegistration,
    ];
}

impl ::protobuf::EnumFull for ESteamDatagramMsgID {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESteamDatagramMsgID").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESteamDatagramMsgID {
    fn default() -> Self {
        ESteamDatagramMsgID::k_ESteamDatagramMsg_Invalid
    }
}

impl ESteamDatagramMsgID {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ESteamDatagramMsgID>("ESteamDatagramMsgID")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x20steamdatagram_messages_sdr.proto\x1a+steamnetworkingsockets_messag\
    es_certs.proto\x1a%steamnetworkingsockets_messages.proto\"\xd3\x08\n\x20\
    CMsgSteamDatagramRouterPingReply\x12)\n\x10client_timestamp\x18\x01\x20\
    \x01(\x07R\x0fclientTimestamp\x128\n\x16latency_datacenter_ids\x18\x02\
    \x20\x03(\x07R\x14latencyDatacenterIdsB\x02\x10\x01\x12*\n\x0flatency_pi\
    ng_ms\x18\x03\x20\x03(\rR\rlatencyPingMsB\x02\x10\x01\x12$\n\x0eyour_pub\
    lic_ip\x18\x04\x20\x01(\x07R\x0cyourPublicIp\x12(\n\x10your_public_port\
    \x18\x0b\x20\x01(\x07R\x0eyourPublicPort\x12\x1f\n\x0bserver_time\x18\
    \x05\x20\x01(\x07R\nserverTime\x12\x1c\n\tchallenge\x18\x06\x20\x01(\x06\
    R\tchallenge\x124\n\x16seconds_until_shutdown\x18\x07\x20\x01(\rR\x14sec\
    ondsUntilShutdown\x12#\n\rclient_cookie\x18\x08\x20\x01(\x07R\x0cclientC\
    ookie\x12A\n\x1dscoring_penalty_relay_cluster\x18\t\x20\x01(\rR\x1ascori\
    ngPenaltyRelayCluster\x12\x14\n\x05flags\x18\x0c\x20\x01(\rR\x05flags\
    \x12[\n\x10route_exceptions\x18\n\x20\x03(\x0b20.CMsgSteamDatagramRouter\
    PingReply.RouteExceptionR\x0frouteExceptions\x12Q\n\ralt_addresses\x18\r\
    \x20\x03(\x0b2,.CMsgSteamDatagramRouterPingReply.AltAddressR\x0caltAddre\
    sses\x1af\n\x0eRouteException\x12$\n\x0edata_center_id\x18\x01\x20\x01(\
    \x07R\x0cdataCenterId\x12\x14\n\x05flags\x18\x02\x20\x01(\rR\x05flags\
    \x12\x18\n\x07penalty\x18\x03\x20\x01(\rR\x07penalty\x1a\xf4\x01\n\nAltA\
    ddress\x12\x12\n\x04ipv4\x18\x01\x20\x01(\x07R\x04ipv4\x12\x12\n\x04port\
    \x18\x02\x20\x01(\rR\x04port\x12\x18\n\x07penalty\x18\x03\x20\x01(\rR\
    \x07penalty\x12b\n\x08protocol\x18\x04\x20\x01(\x0e25.CMsgSteamDatagramR\
    outerPingReply.AltAddress.Protocol:\x0fDefaultProtocolR\x08protocol\x12\
    \x0e\n\x02id\x18\x05\x20\x01(\tR\x02id\"0\n\x08Protocol\x12\x13\n\x0fDef\
    aultProtocol\x10\0\x12\x0f\n\x0bNetworkNext\x10\x01\"L\n\x05Flags\x12\
    \x20\n\x1cFLAG_MAYBE_MORE_DATA_CENTERS\x10\x01\x12!\n\x1dFLAG_MAYBE_MORE\
    _ALT_ADDRESSES\x10\x02\"\xe2\x01\n&CMsgSteamDatagramGameserverPingReques\
    t\x12$\n\x0eyour_public_ip\x18\x01\x20\x01(\x07R\x0cyourPublicIp\x12(\n\
    \x10your_public_port\x18\x05\x20\x01(\x07R\x0eyourPublicPort\x12\x1f\n\
    \x0bserver_time\x18\x02\x20\x01(\x07R\nserverTime\x12\x1c\n\tchallenge\
    \x18\x03\x20\x01(\x06R\tchallenge\x12)\n\x10router_timestamp\x18\x04\x20\
    \x01(\x07R\x0frouterTimestamp\"t\n*CMsgSteamDatagramLegacyGameserverPing\
    Reply\x12)\n\x10router_timestamp\x18\x04\x20\x01(\x07R\x0frouterTimestam\
    p\x12\x1b\n\tdummy_pad\x18c\x20\x01(\x06R\x08dummyPad\"\xd9\x02\n$CMsgSt\
    eamDatagramGameserverPingReply\x127\n\x04cert\x18\x01\x20\x01(\x0b2#.CMs\
    gSteamDatagramCertificateSignedR\x04cert\x12\x1f\n\x0bsigned_data\x18\
    \x02\x20\x01(\x0cR\nsignedData\x12\x1c\n\tsignature\x18\x03\x20\x01(\x0c\
    R\tsignature\x1a\xb8\x01\n\nSignedData\x12%\n\x0echallenge_time\x18\x02\
    \x20\x01(\x07R\rchallengeTime\x12\x1c\n\tchallenge\x18\x03\x20\x01(\x06R\
    \tchallenge\x12)\n\x10router_timestamp\x18\x04\x20\x01(\x07R\x0frouterTi\
    mestamp\x12$\n\x0edata_center_id\x18\x05\x20\x01(\x07R\x0cdataCenterId\
    \x12\x14\n\x05appid\x18\x06\x20\x01(\rR\x05appid\"\x93\x02\n'CMsgSteamDa\
    tagramNoSessionRelayToClient\x12#\n\rconnection_id\x18\x07\x20\x01(\x07R\
    \x0cconnectionId\x12$\n\x0eyour_public_ip\x18\x02\x20\x01(\x07R\x0cyourP\
    ublicIp\x12(\n\x10your_public_port\x18\x06\x20\x01(\x07R\x0eyourPublicPo\
    rt\x12\x1f\n\x0bserver_time\x18\x03\x20\x01(\x07R\nserverTime\x12\x1c\n\
    \tchallenge\x18\x04\x20\x01(\x06R\tchallenge\x124\n\x16seconds_until_shu\
    tdown\x18\x05\x20\x01(\rR\x14secondsUntilShutdown\"\xde\x01\n%CMsgSteamD\
    atagramNoSessionRelayToPeer\x125\n\x17legacy_relay_session_id\x18\x01\
    \x20\x01(\rR\x14legacyRelaySessionId\x121\n\x15from_relay_session_id\x18\
    \x02\x20\x01(\x07R\x12fromRelaySessionId\x12,\n\x12from_connection_id\
    \x18\x07\x20\x01(\x07R\x10fromConnectionId\x12\x1d\n\nkludge_pad\x18c\
    \x20\x01(\x06R\tkludgePad\"O\n(CMsgSteamDatagramClientPingSampleRequest\
    \x12#\n\rconnection_id\x18\x01\x20\x01(\x07R\x0cconnectionId\"\x9a\n\n&C\
    MsgSteamDatagramClientPingSampleReply\x12#\n\rconnection_id\x18\x01\x20\
    \x01(\x07R\x0cconnectionId\x12'\n\x0foverride_active\x18\x04\x20\x01(\
    \x08R\x0eoverrideActive\x12?\n\x04pops\x18\x02\x20\x03(\x0b2+.CMsgSteamD\
    atagramClientPingSampleReply.POPR\x04pops\x12h\n\x13legacy_data_centers\
    \x18\x03\x20\x03(\x0b28.CMsgSteamDatagramClientPingSampleReply.LegacyDat\
    aCenterR\x11legacyDataCenters\x1a\xdd\x06\n\x03POP\x12\x15\n\x06pop_id\
    \x18\x01\x20\x01(\x07R\x05popId\x121\n\x15default_front_ping_ms\x18\x02\
    \x20\x01(\rR\x12defaultFrontPingMs\x12'\n\x0fcluster_penalty\x18\x04\x20\
    \x01(\rR\x0eclusterPenalty\x12[\n\ralt_addresses\x18\x07\x20\x03(\x0b26.\
    CMsgSteamDatagramClientPingSampleReply.POP.AltAddressR\x0caltAddresses\
    \x12-\n\x13default_e2e_ping_ms\x18\x03\x20\x01(\rR\x10defaultE2ePingMs\
    \x12*\n\x11default_e2e_score\x18\x05\x20\x01(\rR\x0fdefaultE2eScore\x127\
    \n\x19p2p_via_peer_relay_pop_id\x18\x06\x20\x01(\x07R\x14p2pViaPeerRelay\
    PopId\x12%\n\x0fbest_dc_ping_ms\x18\t\x20\x01(\rR\x0cbestDcPingMs\x12\"\
    \n\rbest_dc_score\x18\n\x20\x01(\rR\x0bbestDcScore\x125\n\x18best_dc_via\
    _relay_pop_id\x18\x0b\x20\x01(\x07R\x13bestDcViaRelayPopId\x12+\n\x12def\
    ault_dc_ping_ms\x18\x0c\x20\x01(\rR\x0fdefaultDcPingMs\x12(\n\x10default\
    _dc_score\x18\r\x20\x01(\rR\x0edefaultDcScore\x12;\n\x1bdefault_dc_via_r\
    elay_pop_id\x18\x0e\x20\x01(\x07R\x16defaultDcViaRelayPopId\x12%\n\x0fte\
    st_dc_ping_ms\x18\x0f\x20\x01(\rR\x0ctestDcPingMs\x12\"\n\rtest_dc_score\
    \x18\x10\x20\x01(\rR\x0btestDcScore\x125\n\x18test_dc_via_relay_pop_id\
    \x18\x11\x20\x01(\x07R\x13testDcViaRelayPopId\x1aZ\n\nAltAddress\x12\x0e\
    \n\x02id\x18\x01\x20\x01(\tR\x02id\x12\"\n\rfront_ping_ms\x18\x02\x20\
    \x01(\rR\x0bfrontPingMs\x12\x18\n\x07penalty\x18\x03\x20\x01(\rR\x07pena\
    lty\x1a\x96\x01\n\x10LegacyDataCenter\x12$\n\x0edata_center_id\x18\x01\
    \x20\x01(\x07R\x0cdataCenterId\x125\n\x18best_dc_via_relay_pop_id\x18\
    \x02\x20\x01(\x07R\x13bestDcViaRelayPopId\x12%\n\x0fbest_dc_ping_ms\x18\
    \x03\x20\x01(\rR\x0cbestDcPingMs\"\xef\x06\n&CMsgSteamDatagramClientSwit\
    chedPrimary\x12#\n\rconnection_id\x18\x01\x20\x01(\x07R\x0cconnectionId\
    \x12\x17\n\x07from_ip\x18\x02\x20\x01(\x07R\x06fromIp\x12\x1b\n\tfrom_po\
    rt\x18\x03\x20\x01(\rR\x08fromPort\x12.\n\x13from_router_cluster\x18\x04\
    \x20\x01(\x07R\x11fromRouterCluster\x12(\n\x10from_active_time\x18\x05\
    \x20\x01(\rR\x0efromActiveTime\x127\n\x18from_active_packets_recv\x18\
    \x06\x20\x01(\rR\x15fromActivePacketsRecv\x12.\n\x13from_dropped_reason\
    \x18\x07\x20\x01(\tR\x11fromDroppedReason\x12\x15\n\x06gap_ms\x18\x08\
    \x20\x01(\rR\x05gapMs\x12_\n\x10from_quality_now\x18\t\x20\x01(\x0b25.CM\
    sgSteamDatagramClientSwitchedPrimary.RouterQualityR\x0efromQualityNow\
    \x12[\n\x0eto_quality_now\x18\n\x20\x01(\x0b25.CMsgSteamDatagramClientSw\
    itchedPrimary.RouterQualityR\x0ctoQualityNow\x12a\n\x11from_quality_then\
    \x18\x0b\x20\x01(\x0b25.CMsgSteamDatagramClientSwitchedPrimary.RouterQua\
    lityR\x0ffromQualityThen\x12]\n\x0fto_quality_then\x18\x0c\x20\x01(\x0b2\
    5.CMsgSteamDatagramClientSwitchedPrimary.RouterQualityR\rtoQualityThen\
    \x1a\x8f\x01\n\rRouterQuality\x12\x14\n\x05score\x18\x01\x20\x01(\rR\x05\
    score\x12\x1d\n\nfront_ping\x18\x02\x20\x01(\rR\tfrontPing\x12\x1b\n\tba\
    ck_ping\x18\x03\x20\x01(\rR\x08backPing\x12,\n\x12seconds_until_down\x18\
    \x04\x20\x01(\rR\x10secondsUntilDown\"\xc0\x03\n\x1fCMsgSteamDatagramCon\
    nectRequest\x12#\n\rconnection_id\x18\x01\x20\x01(\x07R\x0cconnectionId\
    \x12!\n\x0cmy_timestamp\x18\x04\x20\x01(\x06R\x0bmyTimestamp\x12\x1e\n\
    \x0bping_est_ms\x18\x05\x20\x01(\rR\tpingEstMs\x12!\n\x0cvirtual_port\
    \x18\t\x20\x01(\rR\x0bvirtualPort\x12=\n\x1bgameserver_relay_session_id\
    \x18\x02\x20\x01(\rR\x18gameserverRelaySessionId\x12>\n\x05crypt\x18\x06\
    \x20\x01(\x0b2(.CMsgSteamDatagramSessionCryptInfoSignedR\x05crypt\x127\n\
    \x04cert\x18\x07\x20\x01(\x0b2#.CMsgSteamDatagramCertificateSignedR\x04c\
    ert\x12%\n\x0erouting_secret\x18\n\x20\x01(\x06R\rroutingSecret\x123\n\
    \x16legacy_client_steam_id\x18\x03\x20\x01(\x06R\x13legacyClientSteamId\
    \"\x87\x03\n\x1aCMsgSteamDatagramConnectOK\x120\n\x14client_connection_i\
    d\x18\x01\x20\x01(\x07R\x12clientConnectionId\x120\n\x14server_connectio\
    n_id\x18\x07\x20\x01(\x07R\x12serverConnectionId\x12%\n\x0eyour_timestam\
    p\x18\x03\x20\x01(\x06R\ryourTimestamp\x12&\n\x0fdelay_time_usec\x18\x04\
    \x20\x01(\rR\rdelayTimeUsec\x12=\n\x1bgameserver_relay_session_id\x18\
    \x02\x20\x01(\rR\x18gameserverRelaySessionId\x12>\n\x05crypt\x18\x05\x20\
    \x01(\x0b2(.CMsgSteamDatagramSessionCryptInfoSignedR\x05crypt\x127\n\x04\
    cert\x18\x06\x20\x01(\x0b2#.CMsgSteamDatagramCertificateSignedR\x04cert\
    \"\x91\x03\n'CMsgSteamNetworkingP2PSDRRoutingSummary\x12!\n\x0cinitial_p\
    ing\x18\x01\x20\x01(\rR\x0binitialPing\x127\n\x18initial_ping_front_loca\
    l\x18\x02\x20\x01(\rR\x15initialPingFrontLocal\x129\n\x19initial_ping_fr\
    ont_remote\x18\x03\x20\x01(\rR\x16initialPingFrontRemote\x12#\n\rinitial\
    _score\x18\x04\x20\x01(\rR\x0cinitialScore\x12*\n\x11initial_pop_local\
    \x18\x05\x20\x01(\x07R\x0finitialPopLocal\x12,\n\x12initial_pop_remote\
    \x18\x06\x20\x01(\x07R\x10initialPopRemote\x12%\n\x0enegotiation_ms\x18\
    \x07\x20\x01(\rR\rnegotiationMs\x12)\n\x10selected_seconds\x18\x08\x20\
    \x01(\rR\x0fselectedSeconds\"\x99\x01\n\"CMsgSteamDatagramP2PRoutingSumm\
    ary\x127\n\x03ice\x18\x02\x20\x01(\x0b2%.CMsgSteamNetworkingICESessionSu\
    mmaryR\x03ice\x12:\n\x03sdr\x18\x03\x20\x01(\x0b2(.CMsgSteamNetworkingP2\
    PSDRRoutingSummaryR\x03sdr\"\xac\t\n!CMsgSteamDatagramConnectionClosed\
    \x12(\n\x10to_connection_id\x18\x07\x20\x01(\x07R\x0etoConnectionId\x12,\
    \n\x12from_connection_id\x18\x08\x20\x01(\x07R\x10fromConnectionId\x120\
    \n\x14from_identity_string\x18\x0f\x20\x01(\tR\x12fromIdentityString\x12\
    g\n\x1blegacy_from_identity_binary\x18\r\x20\x01(\x0b2(.CMsgSteamNetwork\
    ingIdentityLegacyBinaryR\x18legacyFromIdentityBinary\x12/\n\x14legacy_fr\
    om_steam_id\x18\x03\x20\x01(\x06R\x11legacyFromSteamId\x12J\n\"legacy_ga\
    meserver_relay_session_id\x18\x02\x20\x01(\rR\x1elegacyGameserverRelaySe\
    ssionId\x12-\n\x13to_relay_session_id\x18\t\x20\x01(\x07R\x10toRelaySess\
    ionId\x121\n\x15from_relay_session_id\x18\n\x20\x01(\x07R\x12fromRelaySe\
    ssionId\x12J\n\"forward_target_relay_routing_token\x18\x0b\x20\x01(\x0cR\
    \x1eforwardTargetRelayRoutingToken\x126\n\x17forward_target_revision\x18\
    \x0c\x20\x01(\rR\x15forwardTargetRevision\x12R\n\nrelay_mode\x18\x04\x20\
    \x01(\x0e2-.CMsgSteamDatagramConnectionClosed.ERelayMode:\x04NoneR\trela\
    yMode\x12\x14\n\x05debug\x18\x05\x20\x01(\tR\x05debug\x12\x1f\n\x0breaso\
    n_code\x18\x06\x20\x01(\rR\nreasonCode\x12%\n\x0erouting_secret\x18\x0e\
    \x20\x01(\x06R\rroutingSecret\x12.\n\x13not_primary_session\x18\x10\x20\
    \x01(\x08R\x11notPrimarySession\x122\n\x15not_primary_transport\x18\x13\
    \x20\x01(\x08R\x13notPrimaryTransport\x12H\n\rquality_relay\x18\x11\x20\
    \x01(\x0b2#.CMsgSteamDatagramConnectionQualityR\x0cqualityRelay\x12D\n\
    \x0bquality_e2e\x18\x12\x20\x01(\x0b2#.CMsgSteamDatagramConnectionQualit\
    yR\nqualityE2e\x12S\n\x13p2p_routing_summary\x18\x15\x20\x01(\x0b2#.CMsg\
    SteamDatagramP2PRoutingSummaryR\x11p2pRoutingSummary\"6\n\nERelayMode\
    \x12\x08\n\x04None\x10\0\x12\x0c\n\x08EndToEnd\x10\x01\x12\x10\n\x0cClos\
    edByPeer\x10\x02\"\xb4\x06\n\x1dCMsgSteamDatagramNoConnection\x12(\n\x10\
    to_connection_id\x18\x05\x20\x01(\x07R\x0etoConnectionId\x12,\n\x12from_\
    connection_id\x18\x06\x20\x01(\x07R\x10fromConnectionId\x12J\n\"legacy_g\
    ameserver_relay_session_id\x18\x02\x20\x01(\rR\x1elegacyGameserverRelayS\
    essionId\x12-\n\x13to_relay_session_id\x18\t\x20\x01(\x07R\x10toRelaySes\
    sionId\x121\n\x15from_relay_session_id\x18\n\x20\x01(\x07R\x12fromRelayS\
    essionId\x120\n\x14from_identity_string\x18\x07\x20\x01(\tR\x12fromIdent\
    ityString\x12/\n\x14legacy_from_steam_id\x18\x03\x20\x01(\x06R\x11legacy\
    FromSteamId\x12\x1c\n\nend_to_end\x18\x04\x20\x01(\x08R\x08endToEnd\x12.\
    \n\x13not_primary_session\x18\x0c\x20\x01(\x08R\x11notPrimarySession\x12\
    2\n\x15not_primary_transport\x18\x0f\x20\x01(\x08R\x13notPrimaryTranspor\
    t\x12H\n\rquality_relay\x18\r\x20\x01(\x0b2#.CMsgSteamDatagramConnection\
    QualityR\x0cqualityRelay\x12D\n\x0bquality_e2e\x18\x0e\x20\x01(\x0b2#.CM\
    sgSteamDatagramConnectionQualityR\nqualityE2e\x12S\n\x13p2p_routing_summ\
    ary\x18\x10\x20\x01(\x0b2#.CMsgSteamDatagramP2PRoutingSummaryR\x11p2pRou\
    tingSummary\x12%\n\x0erouting_secret\x18\x0b\x20\x01(\x06R\rroutingSecre\
    t\x12\x1c\n\tdummy_pad\x18\xff\x07\x20\x01(\x07R\x08dummyPad\"\xff\x02\n\
    )CMsgSteamDatagramGameserverSessionRequest\x12\x16\n\x06ticket\x18\x01\
    \x20\x01(\x0cR\x06ticket\x12%\n\x0echallenge_time\x18\x03\x20\x01(\x07R\
    \rchallengeTime\x12\x1c\n\tchallenge\x18\x04\x20\x01(\x06R\tchallenge\
    \x120\n\x14client_connection_id\x18\x05\x20\x01(\x07R\x12clientConnectio\
    nId\x120\n\x14server_connection_id\x18\x08\x20\x01(\x07R\x12serverConnec\
    tionId\x124\n\x16network_config_version\x18\x06\x20\x01(\rR\x14networkCo\
    nfigVersion\x12)\n\x10protocol_version\x18\x07\x20\x01(\rR\x0fprotocolVe\
    rsion\x12\x1a\n\x08platform\x18\t\x20\x01(\tR\x08platform\x12\x14\n\x05b\
    uild\x18\n\x20\x01(\tR\x05build\"\xe5\x02\n-CMsgSteamDatagramGameserverS\
    essionEstablished\x12#\n\rconnection_id\x18\x01\x20\x01(\x07R\x0cconnect\
    ionId\x12<\n\x1agameserver_identity_string\x18\x02\x20\x01(\tR\x18gamese\
    rverIdentityString\x124\n\x16seconds_until_shutdown\x18\x04\x20\x01(\rR\
    \x14secondsUntilShutdown\x12\x1e\n\x0bseq_num_r2c\x18\x06\x20\x01(\rR\ts\
    eqNumR2c\x12?\n\x1cdummy_legacy_identity_binary\x18\x07\x20\x01(\x0cR\
    \x19dummyLegacyIdentityBinary\x12:\n\x19legacy_gameserver_steamid\x18\
    \x03\x20\x01(\x06R\x17legacyGameserverSteamid\"\xf4\x03\n.CMsgSteamDatag\
    ramConnectionStatsClientToRouter\x12H\n\rquality_relay\x18\x01\x20\x01(\
    \x0b2#.CMsgSteamDatagramConnectionQualityR\x0cqualityRelay\x12D\n\x0bqua\
    lity_e2e\x18\x02\x20\x01(\x0b2#.CMsgSteamDatagramConnectionQualityR\nqua\
    lityE2e\x12\x1b\n\tack_relay\x18\x04\x20\x03(\x07R\x08ackRelay\x12$\n\
    \x0elegacy_ack_e2e\x18\x05\x20\x03(\x07R\x0clegacyAckE2e\x12\x14\n\x05fl\
    ags\x18\x06\x20\x01(\rR\x05flags\x120\n\x14client_connection_id\x18\x08\
    \x20\x01(\x07R\x12clientConnectionId\x12\x1e\n\x0bseq_num_c2r\x18\t\x20\
    \x01(\rR\tseqNumC2r\x12\x1e\n\x0bseq_num_e2e\x18\n\x20\x01(\rR\tseqNumE2\
    e\"g\n\x05Flags\x12\x15\n\x11ACK_REQUEST_RELAY\x10\x01\x12\x13\n\x0fACK_\
    REQUEST_E2E\x10\x02\x12\x19\n\x15ACK_REQUEST_IMMEDIATE\x10\x04\x12\x17\n\
    \x13NOT_PRIMARY_SESSION\x10\x08\"\xb4\x05\n.CMsgSteamDatagramConnectionS\
    tatsRouterToClient\x12H\n\rquality_relay\x18\x01\x20\x01(\x0b2#.CMsgStea\
    mDatagramConnectionQualityR\x0cqualityRelay\x12D\n\x0bquality_e2e\x18\
    \x02\x20\x01(\x0b2#.CMsgSteamDatagramConnectionQualityR\nqualityE2e\x124\
    \n\x16seconds_until_shutdown\x18\x06\x20\x01(\rR\x14secondsUntilShutdown\
    \x12,\n\x12migrate_request_ip\x18\n\x20\x01(\x07R\x10migrateRequestIp\
    \x120\n\x14migrate_request_port\x18\x0b\x20\x01(\rR\x12migrateRequestPor\
    t\x12A\n\x1dscoring_penalty_relay_cluster\x18\x0c\x20\x01(\rR\x1ascoring\
    PenaltyRelayCluster\x12\x1b\n\tack_relay\x18\r\x20\x03(\x07R\x08ackRelay\
    \x12$\n\x0elegacy_ack_e2e\x18\x0e\x20\x03(\x07R\x0clegacyAckE2e\x12\x14\
    \n\x05flags\x18\x0f\x20\x01(\rR\x05flags\x120\n\x14client_connection_id\
    \x18\x07\x20\x01(\x07R\x12clientConnectionId\x12\x1e\n\x0bseq_num_r2c\
    \x18\x08\x20\x01(\rR\tseqNumR2c\x12\x1e\n\x0bseq_num_e2e\x18\t\x20\x01(\
    \rR\tseqNumE2e\"N\n\x05Flags\x12\x15\n\x11ACK_REQUEST_RELAY\x10\x01\x12\
    \x13\n\x0fACK_REQUEST_E2E\x10\x02\x12\x19\n\x15ACK_REQUEST_IMMEDIATE\x10\
    \x04\"\xc9\x05\n.CMsgSteamDatagramConnectionStatsRouterToServer\x12H\n\r\
    quality_relay\x18\x01\x20\x01(\x0b2#.CMsgSteamDatagramConnectionQualityR\
    \x0cqualityRelay\x12D\n\x0bquality_e2e\x18\x02\x20\x01(\x0b2#.CMsgSteamD\
    atagramConnectionQualityR\nqualityE2e\x12\x1b\n\tack_relay\x18\n\x20\x03\
    (\x07R\x08ackRelay\x12$\n\x0elegacy_ack_e2e\x18\x0b\x20\x03(\x07R\x0cleg\
    acyAckE2e\x12\x14\n\x05flags\x18\x0c\x20\x01(\rR\x05flags\x12\x1e\n\x0bs\
    eq_num_r2s\x18\x05\x20\x01(\rR\tseqNumR2s\x12\x1e\n\x0bseq_num_e2e\x18\
    \x06\x20\x01(\rR\tseqNumE2e\x124\n\x16client_identity_string\x18\x0f\x20\
    \x01(\tR\x14clientIdentityString\x123\n\x16legacy_client_steam_id\x18\
    \x07\x20\x01(\x06R\x13legacyClientSteamId\x12(\n\x10relay_session_id\x18\
    \x08\x20\x01(\rR\x0erelaySessionId\x120\n\x14client_connection_id\x18\t\
    \x20\x01(\x07R\x12clientConnectionId\x120\n\x14server_connection_id\x18\
    \r\x20\x01(\x07R\x12serverConnectionId\x12%\n\x0erouting_secret\x18\x0e\
    \x20\x01(\x06R\rroutingSecret\"N\n\x05Flags\x12\x15\n\x11ACK_REQUEST_REL\
    AY\x10\x01\x12\x13\n\x0fACK_REQUEST_E2E\x10\x02\x12\x19\n\x15ACK_REQUEST\
    _IMMEDIATE\x10\x04\"\xb7\x04\n.CMsgSteamDatagramConnectionStatsServerToR\
    outer\x12H\n\rquality_relay\x18\x01\x20\x01(\x0b2#.CMsgSteamDatagramConn\
    ectionQualityR\x0cqualityRelay\x12D\n\x0bquality_e2e\x18\x02\x20\x01(\
    \x0b2#.CMsgSteamDatagramConnectionQualityR\nqualityE2e\x12\x1b\n\tack_re\
    lay\x18\x08\x20\x03(\x07R\x08ackRelay\x12$\n\x0elegacy_ack_e2e\x18\t\x20\
    \x03(\x07R\x0clegacyAckE2e\x12\x14\n\x05flags\x18\n\x20\x01(\rR\x05flags\
    \x12\x1e\n\x0bseq_num_s2r\x18\x03\x20\x01(\rR\tseqNumS2r\x12\x1e\n\x0bse\
    q_num_e2e\x18\x04\x20\x01(\rR\tseqNumE2e\x12(\n\x10relay_session_id\x18\
    \x06\x20\x01(\rR\x0erelaySessionId\x120\n\x14client_connection_id\x18\
    \x07\x20\x01(\x07R\x12clientConnectionId\x120\n\x14server_connection_id\
    \x18\x0b\x20\x01(\x07R\x12serverConnectionId\"N\n\x05Flags\x12\x15\n\x11\
    ACK_REQUEST_RELAY\x10\x01\x12\x13\n\x0fACK_REQUEST_E2E\x10\x02\x12\x19\n\
    \x15ACK_REQUEST_IMMEDIATE\x10\x04\"\xed\x03\n&CMsgSteamDatagramP2PSessio\
    nRequestBody\x12%\n\x0echallenge_time\x18\x01\x20\x01(\x07R\rchallengeTi\
    me\x12\x1c\n\tchallenge\x18\x02\x20\x01(\x06R\tchallenge\x120\n\x14clien\
    t_connection_id\x18\x03\x20\x01(\x07R\x12clientConnectionId\x12/\n\x14le\
    gacy_peer_steam_id\x18\x04\x20\x01(\x06R\x11legacyPeerSteamId\x120\n\x14\
    peer_identity_string\x18\x0b\x20\x01(\tR\x12peerIdentityString\x12,\n\
    \x12peer_connection_id\x18\x05\x20\x01(\x07R\x10peerConnectionId\x12)\n\
    \x10protocol_version\x18\x08\x20\x01(\rR\x0fprotocolVersion\x124\n\x16ne\
    twork_config_version\x18\t\x20\x01(\rR\x14networkConfigVersion\x12(\n\
    \x10unused_public_ip\x18\n\x20\x01(\x07R\x0eunusedPublicIp\x12\x1a\n\x08\
    platform\x18\x0c\x20\x01(\tR\x08platform\x12\x14\n\x05build\x18\r\x20\
    \x01(\tR\x05build\"\x8f\x01\n\"CMsgSteamDatagramP2PSessionRequest\x127\n\
    \x04cert\x18\x01\x20\x01(\x0b2#.CMsgSteamDatagramCertificateSignedR\x04c\
    ert\x12\x12\n\x04body\x18\x02\x20\x01(\x0cR\x04body\x12\x1c\n\tsignature\
    \x18\x03\x20\x01(\x0cR\tsignature\"\xd3\x01\n&CMsgSteamDatagramP2PSessio\
    nEstablished\x12#\n\rconnection_id\x18\x01\x20\x01(\x07R\x0cconnectionId\
    \x124\n\x16seconds_until_shutdown\x18\x03\x20\x01(\rR\x14secondsUntilShu\
    tdown\x12.\n\x13relay_routing_token\x18\x04\x20\x01(\x0cR\x11relayRoutin\
    gToken\x12\x1e\n\x0bseq_num_r2c\x18\x05\x20\x01(\rR\tseqNumR2c\"\xb4\x06\
    \n1CMsgSteamDatagramConnectionStatsP2PClientToRouter\x12H\n\rquality_rel\
    ay\x18\x01\x20\x01(\x0b2#.CMsgSteamDatagramConnectionQualityR\x0cquality\
    Relay\x12D\n\x0bquality_e2e\x18\x02\x20\x01(\x0b2#.CMsgSteamDatagramConn\
    ectionQualityR\nqualityE2e\x12S\n\x13p2p_routing_summary\x18\x0e\x20\x01\
    (\x0b2#.CMsgSteamDatagramP2PRoutingSummaryR\x11p2pRoutingSummary\x12\x1b\
    \n\tack_relay\x18\x03\x20\x03(\x07R\x08ackRelay\x12$\n\x0elegacy_ack_e2e\
    \x18\x04\x20\x03(\x07R\x0clegacyAckE2e\x12\x14\n\x05flags\x18\x05\x20\
    \x01(\rR\x05flags\x12J\n\"forward_target_relay_routing_token\x18\x06\x20\
    \x01(\x0cR\x1eforwardTargetRelayRoutingToken\x126\n\x17forward_target_re\
    vision\x18\x07\x20\x01(\rR\x15forwardTargetRevision\x12\x16\n\x06routes\
    \x18\x08\x20\x01(\x0cR\x06routes\x127\n\x18ack_peer_routes_revision\x18\
    \t\x20\x01(\rR\x15ackPeerRoutesRevision\x12#\n\rconnection_id\x18\n\x20\
    \x01(\x07R\x0cconnectionId\x12\x1e\n\x0bseq_num_c2r\x18\x0b\x20\x01(\rR\
    \tseqNumC2r\x12\x1e\n\x0bseq_num_e2e\x18\x0c\x20\x01(\rR\tseqNumE2e\"\
    \x86\x01\n\x05Flags\x12\x15\n\x11ACK_REQUEST_RELAY\x10\x01\x12\x13\n\x0f\
    ACK_REQUEST_E2E\x10\x02\x12\x19\n\x15ACK_REQUEST_IMMEDIATE\x10\x04\x12\
    \x17\n\x13NOT_PRIMARY_SESSION\x10\x08\x12\x1d\n\x19NOT_PRIMARY_TRANSPORT\
    _E2E\x10\x10\"\xd9\x06\n1CMsgSteamDatagramConnectionStatsP2PRouterToClie\
    nt\x12H\n\rquality_relay\x18\x01\x20\x01(\x0b2#.CMsgSteamDatagramConnect\
    ionQualityR\x0cqualityRelay\x12D\n\x0bquality_e2e\x18\x02\x20\x01(\x0b2#\
    .CMsgSteamDatagramConnectionQualityR\nqualityE2e\x124\n\x16seconds_until\
    _shutdown\x18\x03\x20\x01(\rR\x14secondsUntilShutdown\x12,\n\x12migrate_\
    request_ip\x18\x04\x20\x01(\x07R\x10migrateRequestIp\x120\n\x14migrate_r\
    equest_port\x18\x05\x20\x01(\rR\x12migrateRequestPort\x12A\n\x1dscoring_\
    penalty_relay_cluster\x18\x06\x20\x01(\rR\x1ascoringPenaltyRelayCluster\
    \x12\x1b\n\tack_relay\x18\x07\x20\x03(\x07R\x08ackRelay\x12$\n\x0elegacy\
    _ack_e2e\x18\x08\x20\x03(\x07R\x0clegacyAckE2e\x12\x14\n\x05flags\x18\t\
    \x20\x01(\rR\x05flags\x12=\n\x1back_forward_target_revision\x18\n\x20\
    \x01(\rR\x18ackForwardTargetRevision\x12\x16\n\x06routes\x18\x0b\x20\x01\
    (\x0cR\x06routes\x127\n\x18ack_peer_routes_revision\x18\x0c\x20\x01(\rR\
    \x15ackPeerRoutesRevision\x12#\n\rconnection_id\x18\r\x20\x01(\x07R\x0cc\
    onnectionId\x12\x1e\n\x0bseq_num_r2c\x18\x0e\x20\x01(\rR\tseqNumR2c\x12\
    \x1e\n\x0bseq_num_e2e\x18\x0f\x20\x01(\rR\tseqNumE2e\"m\n\x05Flags\x12\
    \x15\n\x11ACK_REQUEST_RELAY\x10\x01\x12\x13\n\x0fACK_REQUEST_E2E\x10\x02\
    \x12\x19\n\x15ACK_REQUEST_IMMEDIATE\x10\x04\x12\x1d\n\x19NOT_PRIMARY_TRA\
    NSPORT_E2E\x10\x10\"\xec\x01\n*CMsgSteamDatagramP2PBadRouteRouterToClien\
    t\x12#\n\rconnection_id\x18\x01\x20\x01(\x07R\x0cconnectionId\x12;\n\x1a\
    failed_relay_routing_token\x18\x02\x20\x01(\x0cR\x17failedRelayRoutingTo\
    ken\x12=\n\x1back_forward_target_revision\x18\x03\x20\x01(\rR\x18ackForw\
    ardTargetRevision\x12\x1d\n\nkludge_pad\x18c\x20\x01(\x06R\tkludgePad\"\
    \xc4\x03\n\x1aCMsgSteamDatagramP2PRoutes\x12O\n\x0erelay_clusters\x18\
    \x01\x20\x03(\x0b2(.CMsgSteamDatagramP2PRoutes.RelayClusterR\rrelayClust\
    ers\x129\n\x06routes\x18\x02\x20\x03(\x0b2!.CMsgSteamDatagramP2PRoutes.R\
    outeR\x06routes\x12\x1a\n\x08revision\x18\x03\x20\x01(\rR\x08revision\
    \x1a\xa2\x01\n\x0cRelayCluster\x12\x15\n\x06pop_id\x18\x01\x20\x01(\x07R\
    \x05popId\x12\x17\n\x07ping_ms\x18\x02\x20\x01(\rR\x06pingMs\x12#\n\rsco\
    re_penalty\x18\x03\x20\x01(\rR\x0cscorePenalty\x12=\n\x1bsession_relay_r\
    outing_token\x18\x04\x20\x01(\x0cR\x18sessionRelayRoutingToken\x1aY\n\
    \x05Route\x12\x1a\n\tmy_pop_id\x18\x01\x20\x01(\x07R\x07myPopId\x12\x1e\
    \n\x0byour_pop_id\x18\x02\x20\x01(\x07R\tyourPopId\x12\x14\n\x05score\
    \x18\x03\x20\x01(\rR\x05score\"K\n!CMsgSteamDatagramGameServerSample\x12\
    \x12\n\x04ipv4\x18\x01\x20\x01(\x07R\x04ipv4\x12\x12\n\x04port\x18\x02\
    \x20\x01(\rR\x04port\"\x90\x01\n+CMsgSteamDatagramGameServerSampleDataCe\
    nter\x12#\n\rdatacenter_id\x18\x01\x20\x01(\x07R\x0cdatacenterId\x12<\n\
    \x07servers\x18\x03\x20\x03(\x0b2\".CMsgSteamDatagramGameServerSampleR\
    \x07servers\"\x9c\x02\n!CMsgSteamDatagramRelayToRelayPing\x12+\n\x11requ\
    est_timestamp\x18\x01\x20\x01(\x07R\x10requestTimestamp\x12!\n\x0creques\
    t_date\x18\x02\x20\x01(\x07R\x0brequestDate\x12\x1a\n\tmy_pop_id\x18\x03\
    \x20\x01(\x07R\x07myPopId\x12\x1e\n\x0byour_pop_id\x18\x04\x20\x01(\x07R\
    \tyourPopId\x12\x1a\n\x08checksum\x18\x05\x20\x01(\x07R\x08checksum\x12O\
    \n\x0cdata_centers\x18\x06\x20\x03(\x0b2,.CMsgSteamDatagramGameServerSam\
    pleDataCenterR\x0bdataCenters\"\xef\x02\n\x20CMsgSteamDatagramDataCenter\
    State\x12O\n\x0cdata_centers\x18\x01\x20\x03(\x0b2,.CMsgSteamDatagramDat\
    aCenterState.DataCenterR\x0bdataCenters\x1a;\n\x06Server\x12\x18\n\x07ad\
    dress\x18\x01\x20\x01(\tR\x07address\x12\x17\n\x07ping_ms\x18\x02\x20\
    \x01(\rR\x06pingMs\x1a\xbc\x01\n\nDataCenter\x12\x12\n\x04code\x18\x01\
    \x20\x01(\tR\x04code\x12M\n\rserver_sample\x18\x02\x20\x03(\x0b2(.CMsgSt\
    eamDatagramDataCenterState.ServerR\x0cserverSample\x12K\n\x0crelay_sampl\
    e\x18\x03\x20\x03(\x0b2(.CMsgSteamDatagramDataCenterState.ServerR\x0brel\
    aySample\"\xcb\x04\n\x1dCMsgSteamDatagramRouterHealth\x12\x19\n\x08cpu_l\
    oad\x18\x01\x20\x01(\x02R\x07cpuLoad\x12\x20\n\x0ccpu_load_raw\x18\n\x20\
    \x01(\x02R\ncpuLoadRaw\x12'\n\x0factive_sessions\x18\x02\x20\x01(\rR\x0e\
    activeSessions\x12\"\n\rdata_pkts_sec\x18\x03\x20\x01(\rR\x0bdataPktsSec\
    \x12$\n\x0eother_pkts_sec\x18\x04\x20\x01(\rR\x0cotherPktsSec\x124\n\x16\
    seconds_until_shutdown\x18\x05\x20\x01(\rR\x14secondsUntilShutdown\x12)\
    \n\x11cpu_cost_per_user\x18\x08\x20\x01(\x02R\x0ecpuCostPerUser\x12-\n\
    \x13cpu_cost_per_packet\x18\t\x20\x01(\x02R\x10cpuCostPerPacket\x12L\n\
    \x0cdata_centers\x18\x06\x20\x03(\x0b2).CMsgSteamDatagramRouterHealth.Da\
    taCenterR\x0bdataCenters\x12\x14\n\x05magic\x18\x07\x20\x01(\x06R\x05mag\
    ic\x1a\x85\x01\n\nDataCenter\x12#\n\rdatacenter_id\x18\x01\x20\x01(\x07R\
    \x0cdatacenterId\x12\x14\n\x05state\x18\x02\x20\x01(\rR\x05state\x12<\n\
    \x07servers\x18\x03\x20\x03(\x0b2\".CMsgSteamDatagramGameServerSampleR\
    \x07servers\"\xb9\x06\n1CMsgSteamDatagramConnectionStatsP2PRouterToRoute\
    r\x12H\n\rquality_relay\x18\x01\x20\x01(\x0b2#.CMsgSteamDatagramConnecti\
    onQualityR\x0cqualityRelay\x12D\n\x0bquality_e2e\x18\x02\x20\x01(\x0b2#.\
    CMsgSteamDatagramConnectionQualityR\nqualityE2e\x12\x1b\n\tack_relay\x18\
    \x03\x20\x03(\x07R\x08ackRelay\x12$\n\x0elegacy_ack_e2e\x18\x04\x20\x03(\
    \x07R\x0clegacyAckE2e\x12\x14\n\x05flags\x18\x05\x20\x01(\rR\x05flags\
    \x12=\n\x1back_forward_target_revision\x18\x06\x20\x01(\rR\x18ackForward\
    TargetRevision\x12\x16\n\x06routes\x18\x07\x20\x01(\x0cR\x06routes\x127\
    \n\x18ack_peer_routes_revision\x18\x08\x20\x01(\rR\x15ackPeerRoutesRevis\
    ion\x12,\n\x12from_connection_id\x18\x15\x20\x01(\x07R\x10fromConnection\
    Id\x12(\n\x10to_connection_id\x18\x18\x20\x01(\x07R\x0etoConnectionId\
    \x121\n\x15from_relay_session_id\x18\x16\x20\x01(\x07R\x12fromRelaySessi\
    onId\x12\"\n\rseq_num_nonce\x18\x1c\x20\x01(\rR\x0bseqNumNonce\x12-\n\
    \x13to_relay_session_id\x18\x19\x20\x01(\x07R\x10toRelaySessionId\x12\
    \x1e\n\x0bseq_num_r2r\x18\x1a\x20\x01(\rR\tseqNumR2r\x12\x1e\n\x0bseq_nu\
    m_e2e\x18\x1b\x20\x01(\rR\tseqNumE2e\"m\n\x05Flags\x12\x15\n\x11ACK_REQU\
    EST_RELAY\x10\x01\x12\x13\n\x0fACK_REQUEST_E2E\x10\x02\x12\x19\n\x15ACK_\
    REQUEST_IMMEDIATE\x10\x04\x12\x1d\n\x19NOT_PRIMARY_TRANSPORT_E2E\x10\x10\
    \"\x8f\x01\n6CMsgSteamDatagramNetworkNextRouterPingRequestExtraData\x12\
    \x1b\n\tclient_id\x18\x03\x20\x01(\tR\x08clientId\x12\x15\n\x06app_id\
    \x18\x04\x20\x01(\rR\x05appId\x12!\n\x0cprotocol_ver\x18\x05\x20\x01(\rR\
    \x0bprotocolVer\"6\n4CMsgSteamDatagramNetworkNextRouterPingReplyExtraDat\
    a*\xcc\n\n\x13ESteamDatagramMsgID\x12\x1f\n\x1bk_ESteamDatagramMsg_Inval\
    id\x10\0\x12)\n%k_ESteamDatagramMsg_RouterPingRequest\x10\x01\x12'\n#k_E\
    SteamDatagramMsg_RouterPingReply\x10\x02\x12-\n)k_ESteamDatagramMsg_Game\
    serverPingRequest\x10\x03\x121\n-k_ESteamDatagramMsg_LegacyGameserverPin\
    gReply\x10\x04\x120\n,k_ESteamDatagramMsg_GameserverSessionRequest\x10\
    \x05\x124\n0k_ESteamDatagramMsg_GameserverSessionEstablished\x10\x06\x12\
    !\n\x1dk_ESteamDatagramMsg_NoSession\x10\x07\x12\"\n\x1ek_ESteamDatagram\
    Msg_Diagnostic\x10\x08\x12*\n&k_ESteamDatagramMsg_DataClientToRouter\x10\
    \t\x12*\n&k_ESteamDatagramMsg_DataRouterToServer\x10\n\x12*\n&k_ESteamDa\
    tagramMsg_DataServerToRouter\x10\x0b\x12*\n&k_ESteamDatagramMsg_DataRout\
    erToClient\x10\x0c\x12\x1d\n\x19k_ESteamDatagramMsg_Stats\x10\r\x12/\n+k\
    _ESteamDatagramMsg_ClientPingSampleRequest\x10\x0e\x12-\n)k_ESteamDatagr\
    amMsg_ClientPingSampleReply\x10\x0f\x125\n1k_ESteamDatagramMsg_ClientToR\
    outerSwitchedPrimary\x10\x10\x12#\n\x1fk_ESteamDatagramMsg_RelayHealth\
    \x10\x11\x12&\n\"k_ESteamDatagramMsg_ConnectRequest\x10\x12\x12!\n\x1dk_\
    ESteamDatagramMsg_ConnectOK\x10\x13\x12(\n$k_ESteamDatagramMsg_Connectio\
    nClosed\x10\x14\x12$\n\x20k_ESteamDatagramMsg_NoConnection\x10\x15\x12/\
    \n+k_ESteamDatagramMsg_RelayToRelayPingRequest\x10\x16\x12-\n)k_ESteamDa\
    tagramMsg_RelayToRelayPingReply\x10\x17\x12)\n%k_ESteamDatagramMsg_P2PSe\
    ssionRequest\x10\x18\x12-\n)k_ESteamDatagramMsg_P2PSessionEstablished\
    \x10\x19\x12&\n\"k_ESteamDatagramMsg_P2PStatsClient\x10\x1a\x12%\n!k_ESt\
    eamDatagramMsg_P2PStatsRelay\x10\x1b\x12#\n\x1fk_ESteamDatagramMsg_P2PBa\
    dRoute\x10\x1c\x12+\n'k_ESteamDatagramMsg_GameserverPingReply\x10\x1d\
    \x12.\n*k_ESteamDatagramMsg_GameserverRegistration\x10\x1eB\x05H\x01\x80\
    \x01\0J\xad\xdd\x01\n\x07\x12\x05\0\0\xaf\x04\x01\n\t\n\x02\x03\0\x12\
    \x03\0\05\n\t\n\x02\x03\x01\x12\x03\x01\0/\n\x08\n\x01\x08\x12\x03\x03\0\
    \x1c\n\t\n\x02\x08\t\x12\x03\x03\0\x1c\n\x08\n\x01\x08\x12\x03\x04\0#\n\
    \t\n\x02\x08\x10\x12\x03\x04\0#\n\n\n\x02\x05\0\x12\x04\x06\0&\x01\n\n\n\
    \x03\x05\0\x01\x12\x03\x06\x05\x18\n\x0b\n\x04\x05\0\x02\0\x12\x03\x07\
    \x08(\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\x07\x08#\n\x0c\n\x05\x05\0\x02\
    \0\x02\x12\x03\x07&'\n\x0b\n\x04\x05\0\x02\x01\x12\x03\x08\x082\n\x0c\n\
    \x05\x05\0\x02\x01\x01\x12\x03\x08\x08-\n\x0c\n\x05\x05\0\x02\x01\x02\
    \x12\x03\x0801\n\x0b\n\x04\x05\0\x02\x02\x12\x03\t\x080\n\x0c\n\x05\x05\
    \0\x02\x02\x01\x12\x03\t\x08+\n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03\t./\
    \n\x0b\n\x04\x05\0\x02\x03\x12\x03\n\x086\n\x0c\n\x05\x05\0\x02\x03\x01\
    \x12\x03\n\x081\n\x0c\n\x05\x05\0\x02\x03\x02\x12\x03\n45\n\x0b\n\x04\
    \x05\0\x02\x04\x12\x03\x0b\x08:\n\x0c\n\x05\x05\0\x02\x04\x01\x12\x03\
    \x0b\x085\n\x0c\n\x05\x05\0\x02\x04\x02\x12\x03\x0b89\n\x0b\n\x04\x05\0\
    \x02\x05\x12\x03\x0c\x089\n\x0c\n\x05\x05\0\x02\x05\x01\x12\x03\x0c\x084\
    \n\x0c\n\x05\x05\0\x02\x05\x02\x12\x03\x0c78\n\x0b\n\x04\x05\0\x02\x06\
    \x12\x03\r\x08=\n\x0c\n\x05\x05\0\x02\x06\x01\x12\x03\r\x088\n\x0c\n\x05\
    \x05\0\x02\x06\x02\x12\x03\r;<\n\x0b\n\x04\x05\0\x02\x07\x12\x03\x0e\x08\
    *\n\x0c\n\x05\x05\0\x02\x07\x01\x12\x03\x0e\x08%\n\x0c\n\x05\x05\0\x02\
    \x07\x02\x12\x03\x0e()\n\x0b\n\x04\x05\0\x02\x08\x12\x03\x0f\x08+\n\x0c\
    \n\x05\x05\0\x02\x08\x01\x12\x03\x0f\x08&\n\x0c\n\x05\x05\0\x02\x08\x02\
    \x12\x03\x0f)*\n\x0b\n\x04\x05\0\x02\t\x12\x03\x10\x083\n\x0c\n\x05\x05\
    \0\x02\t\x01\x12\x03\x10\x08.\n\x0c\n\x05\x05\0\x02\t\x02\x12\x03\x1012\
    \n\x0b\n\x04\x05\0\x02\n\x12\x03\x11\x084\n\x0c\n\x05\x05\0\x02\n\x01\
    \x12\x03\x11\x08.\n\x0c\n\x05\x05\0\x02\n\x02\x12\x03\x1113\n\x0b\n\x04\
    \x05\0\x02\x0b\x12\x03\x12\x084\n\x0c\n\x05\x05\0\x02\x0b\x01\x12\x03\
    \x12\x08.\n\x0c\n\x05\x05\0\x02\x0b\x02\x12\x03\x1213\n\x0b\n\x04\x05\0\
    \x02\x0c\x12\x03\x13\x084\n\x0c\n\x05\x05\0\x02\x0c\x01\x12\x03\x13\x08.\
    \n\x0c\n\x05\x05\0\x02\x0c\x02\x12\x03\x1313\n\x0b\n\x04\x05\0\x02\r\x12\
    \x03\x14\x08'\n\x0c\n\x05\x05\0\x02\r\x01\x12\x03\x14\x08!\n\x0c\n\x05\
    \x05\0\x02\r\x02\x12\x03\x14$&\n\x0b\n\x04\x05\0\x02\x0e\x12\x03\x15\x08\
    9\n\x0c\n\x05\x05\0\x02\x0e\x01\x12\x03\x15\x083\n\x0c\n\x05\x05\0\x02\
    \x0e\x02\x12\x03\x1568\n\x0b\n\x04\x05\0\x02\x0f\x12\x03\x16\x087\n\x0c\
    \n\x05\x05\0\x02\x0f\x01\x12\x03\x16\x081\n\x0c\n\x05\x05\0\x02\x0f\x02\
    \x12\x03\x1646\n\x0b\n\x04\x05\0\x02\x10\x12\x03\x17\x08?\n\x0c\n\x05\
    \x05\0\x02\x10\x01\x12\x03\x17\x089\n\x0c\n\x05\x05\0\x02\x10\x02\x12\
    \x03\x17<>\n\x0b\n\x04\x05\0\x02\x11\x12\x03\x18\x08-\n\x0c\n\x05\x05\0\
    \x02\x11\x01\x12\x03\x18\x08'\n\x0c\n\x05\x05\0\x02\x11\x02\x12\x03\x18*\
    ,\n\x0b\n\x04\x05\0\x02\x12\x12\x03\x19\x080\n\x0c\n\x05\x05\0\x02\x12\
    \x01\x12\x03\x19\x08*\n\x0c\n\x05\x05\0\x02\x12\x02\x12\x03\x19-/\n\x0b\
    \n\x04\x05\0\x02\x13\x12\x03\x1a\x08+\n\x0c\n\x05\x05\0\x02\x13\x01\x12\
    \x03\x1a\x08%\n\x0c\n\x05\x05\0\x02\x13\x02\x12\x03\x1a(*\n\x0b\n\x04\
    \x05\0\x02\x14\x12\x03\x1b\x082\n\x0c\n\x05\x05\0\x02\x14\x01\x12\x03\
    \x1b\x08,\n\x0c\n\x05\x05\0\x02\x14\x02\x12\x03\x1b/1\n\x0b\n\x04\x05\0\
    \x02\x15\x12\x03\x1c\x08.\n\x0c\n\x05\x05\0\x02\x15\x01\x12\x03\x1c\x08(\
    \n\x0c\n\x05\x05\0\x02\x15\x02\x12\x03\x1c+-\n\x0b\n\x04\x05\0\x02\x16\
    \x12\x03\x1d\x089\n\x0c\n\x05\x05\0\x02\x16\x01\x12\x03\x1d\x083\n\x0c\n\
    \x05\x05\0\x02\x16\x02\x12\x03\x1d68\n\x0b\n\x04\x05\0\x02\x17\x12\x03\
    \x1e\x087\n\x0c\n\x05\x05\0\x02\x17\x01\x12\x03\x1e\x081\n\x0c\n\x05\x05\
    \0\x02\x17\x02\x12\x03\x1e46\n\x0b\n\x04\x05\0\x02\x18\x12\x03\x1f\x083\
    \n\x0c\n\x05\x05\0\x02\x18\x01\x12\x03\x1f\x08-\n\x0c\n\x05\x05\0\x02\
    \x18\x02\x12\x03\x1f02\n\x0b\n\x04\x05\0\x02\x19\x12\x03\x20\x087\n\x0c\
    \n\x05\x05\0\x02\x19\x01\x12\x03\x20\x081\n\x0c\n\x05\x05\0\x02\x19\x02\
    \x12\x03\x2046\n\x0b\n\x04\x05\0\x02\x1a\x12\x03!\x080\n\x0c\n\x05\x05\0\
    \x02\x1a\x01\x12\x03!\x08*\n\x0c\n\x05\x05\0\x02\x1a\x02\x12\x03!-/\n\
    \x0b\n\x04\x05\0\x02\x1b\x12\x03\"\x08/\n\x0c\n\x05\x05\0\x02\x1b\x01\
    \x12\x03\"\x08)\n\x0c\n\x05\x05\0\x02\x1b\x02\x12\x03\",.\n\x0b\n\x04\
    \x05\0\x02\x1c\x12\x03#\x08-\n\x0c\n\x05\x05\0\x02\x1c\x01\x12\x03#\x08'\
    \n\x0c\n\x05\x05\0\x02\x1c\x02\x12\x03#*,\n\x0b\n\x04\x05\0\x02\x1d\x12\
    \x03$\x085\n\x0c\n\x05\x05\0\x02\x1d\x01\x12\x03$\x08/\n\x0c\n\x05\x05\0\
    \x02\x1d\x02\x12\x03$24\n\x0b\n\x04\x05\0\x02\x1e\x12\x03%\x088\n\x0c\n\
    \x05\x05\0\x02\x1e\x01\x12\x03%\x082\n\x0c\n\x05\x05\0\x02\x1e\x02\x12\
    \x03%57\n\n\n\x02\x04\0\x12\x04(\0N\x01\n\n\n\x03\x04\0\x01\x12\x03(\x08\
    (\n\x0c\n\x04\x04\0\x03\0\x12\x04)\x08-\t\n\x0c\n\x05\x04\0\x03\0\x01\
    \x12\x03)\x10\x1e\n\r\n\x06\x04\0\x03\0\x02\0\x12\x03*\x104\n\x0e\n\x07\
    \x04\0\x03\0\x02\0\x04\x12\x03*\x10\x18\n\x0e\n\x07\x04\0\x03\0\x02\0\
    \x05\x12\x03*\x19\x20\n\x0e\n\x07\x04\0\x03\0\x02\0\x01\x12\x03*!/\n\x0e\
    \n\x07\x04\0\x03\0\x02\0\x03\x12\x03*23\n\r\n\x06\x04\0\x03\0\x02\x01\
    \x12\x03+\x10*\n\x0e\n\x07\x04\0\x03\0\x02\x01\x04\x12\x03+\x10\x18\n\
    \x0e\n\x07\x04\0\x03\0\x02\x01\x05\x12\x03+\x19\x1f\n\x0e\n\x07\x04\0\
    \x03\0\x02\x01\x01\x12\x03+\x20%\n\x0e\n\x07\x04\0\x03\0\x02\x01\x03\x12\
    \x03+()\n\r\n\x06\x04\0\x03\0\x02\x02\x12\x03,\x10,\n\x0e\n\x07\x04\0\
    \x03\0\x02\x02\x04\x12\x03,\x10\x18\n\x0e\n\x07\x04\0\x03\0\x02\x02\x05\
    \x12\x03,\x19\x1f\n\x0e\n\x07\x04\0\x03\0\x02\x02\x01\x12\x03,\x20'\n\
    \x0e\n\x07\x04\0\x03\0\x02\x02\x03\x12\x03,*+\n\x0c\n\x04\x04\0\x03\x01\
    \x12\x04/\x08:\t\n\x0c\n\x05\x04\0\x03\x01\x01\x12\x03/\x10\x1a\n\x0e\n\
    \x06\x04\0\x03\x01\x04\0\x12\x040\x103\x11\n\x0e\n\x07\x04\0\x03\x01\x04\
    \0\x01\x12\x030\x15\x1d\n\x0f\n\x08\x04\0\x03\x01\x04\0\x02\0\x12\x031\
    \x18,\n\x10\n\t\x04\0\x03\x01\x04\0\x02\0\x01\x12\x031\x18'\n\x10\n\t\
    \x04\0\x03\x01\x04\0\x02\0\x02\x12\x031*+\n\x0f\n\x08\x04\0\x03\x01\x04\
    \0\x02\x01\x12\x032\x18(\n\x10\n\t\x04\0\x03\x01\x04\0\x02\x01\x01\x12\
    \x032\x18#\n\x10\n\t\x04\0\x03\x01\x04\0\x02\x01\x02\x12\x032&'\n\r\n\
    \x06\x04\0\x03\x01\x02\0\x12\x035\x10*\n\x0e\n\x07\x04\0\x03\x01\x02\0\
    \x04\x12\x035\x10\x18\n\x0e\n\x07\x04\0\x03\x01\x02\0\x05\x12\x035\x19\
    \x20\n\x0e\n\x07\x04\0\x03\x01\x02\0\x01\x12\x035!%\n\x0e\n\x07\x04\0\
    \x03\x01\x02\0\x03\x12\x035()\n\r\n\x06\x04\0\x03\x01\x02\x01\x12\x036\
    \x10)\n\x0e\n\x07\x04\0\x03\x01\x02\x01\x04\x12\x036\x10\x18\n\x0e\n\x07\
    \x04\0\x03\x01\x02\x01\x05\x12\x036\x19\x1f\n\x0e\n\x07\x04\0\x03\x01\
    \x02\x01\x01\x12\x036\x20$\n\x0e\n\x07\x04\0\x03\x01\x02\x01\x03\x12\x03\
    6'(\n\r\n\x06\x04\0\x03\x01\x02\x02\x12\x037\x10,\n\x0e\n\x07\x04\0\x03\
    \x01\x02\x02\x04\x12\x037\x10\x18\n\x0e\n\x07\x04\0\x03\x01\x02\x02\x05\
    \x12\x037\x19\x1f\n\x0e\n\x07\x04\0\x03\x01\x02\x02\x01\x12\x037\x20'\n\
    \x0e\n\x07\x04\0\x03\x01\x02\x02\x03\x12\x037*+\n\r\n\x06\x04\0\x03\x01\
    \x02\x03\x12\x038\x10x\n\x0e\n\x07\x04\0\x03\x01\x02\x03\x04\x12\x038\
    \x10\x18\n\x0e\n\x07\x04\0\x03\x01\x02\x03\x06\x12\x038\x19N\n\x0e\n\x07\
    \x04\0\x03\x01\x02\x03\x01\x12\x038OW\n\x0e\n\x07\x04\0\x03\x01\x02\x03\
    \x03\x12\x038Z[\n\x0e\n\x07\x04\0\x03\x01\x02\x03\x08\x12\x038\\w\n\x0e\
    \n\x07\x04\0\x03\x01\x02\x03\x07\x12\x038gv\n\r\n\x06\x04\0\x03\x01\x02\
    \x04\x12\x039\x10'\n\x0e\n\x07\x04\0\x03\x01\x02\x04\x04\x12\x039\x10\
    \x18\n\x0e\n\x07\x04\0\x03\x01\x02\x04\x05\x12\x039\x19\x1f\n\x0e\n\x07\
    \x04\0\x03\x01\x02\x04\x01\x12\x039\x20\"\n\x0e\n\x07\x04\0\x03\x01\x02\
    \x04\x03\x12\x039%&\n\x0c\n\x04\x04\0\x04\0\x12\x04<\x08?\t\n\x0c\n\x05\
    \x04\0\x04\0\x01\x12\x03<\r\x12\n\r\n\x06\x04\0\x04\0\x02\0\x12\x03=\x10\
    1\n\x0e\n\x07\x04\0\x04\0\x02\0\x01\x12\x03=\x10,\n\x0e\n\x07\x04\0\x04\
    \0\x02\0\x02\x12\x03=/0\n\r\n\x06\x04\0\x04\0\x02\x01\x12\x03>\x102\n\
    \x0e\n\x07\x04\0\x04\0\x02\x01\x01\x12\x03>\x10-\n\x0e\n\x07\x04\0\x04\0\
    \x02\x01\x02\x12\x03>01\n\x0b\n\x04\x04\0\x02\0\x12\x03A\x08.\n\x0c\n\
    \x05\x04\0\x02\0\x04\x12\x03A\x08\x10\n\x0c\n\x05\x04\0\x02\0\x05\x12\
    \x03A\x11\x18\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03A\x19)\n\x0c\n\x05\x04\
    \0\x02\0\x03\x12\x03A,-\n\x0b\n\x04\x04\0\x02\x01\x12\x03B\x08D\n\x0c\n\
    \x05\x04\0\x02\x01\x04\x12\x03B\x08\x10\n\x0c\n\x05\x04\0\x02\x01\x05\
    \x12\x03B\x11\x18\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03B\x19/\n\x0c\n\
    \x05\x04\0\x02\x01\x03\x12\x03B23\n\x0c\n\x05\x04\0\x02\x01\x08\x12\x03B\
    4C\n\r\n\x06\x04\0\x02\x01\x08\x02\x12\x03B5B\n\x0b\n\x04\x04\0\x02\x02\
    \x12\x03C\x08<\n\x0c\n\x05\x04\0\x02\x02\x04\x12\x03C\x08\x10\n\x0c\n\
    \x05\x04\0\x02\x02\x05\x12\x03C\x11\x17\n\x0c\n\x05\x04\0\x02\x02\x01\
    \x12\x03C\x18'\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03C*+\n\x0c\n\x05\x04\
    \0\x02\x02\x08\x12\x03C,;\n\r\n\x06\x04\0\x02\x02\x08\x02\x12\x03C-:\n\
    \x0b\n\x04\x04\0\x02\x03\x12\x03D\x08,\n\x0c\n\x05\x04\0\x02\x03\x04\x12\
    \x03D\x08\x10\n\x0c\n\x05\x04\0\x02\x03\x05\x12\x03D\x11\x18\n\x0c\n\x05\
    \x04\0\x02\x03\x01\x12\x03D\x19'\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03D*\
    +\n\x0b\n\x04\x04\0\x02\x04\x12\x03E\x08/\n\x0c\n\x05\x04\0\x02\x04\x04\
    \x12\x03E\x08\x10\n\x0c\n\x05\x04\0\x02\x04\x05\x12\x03E\x11\x18\n\x0c\n\
    \x05\x04\0\x02\x04\x01\x12\x03E\x19)\n\x0c\n\x05\x04\0\x02\x04\x03\x12\
    \x03E,.\n\x0b\n\x04\x04\0\x02\x05\x12\x03F\x08)\n\x0c\n\x05\x04\0\x02\
    \x05\x04\x12\x03F\x08\x10\n\x0c\n\x05\x04\0\x02\x05\x05\x12\x03F\x11\x18\
    \n\x0c\n\x05\x04\0\x02\x05\x01\x12\x03F\x19$\n\x0c\n\x05\x04\0\x02\x05\
    \x03\x12\x03F'(\n\x0b\n\x04\x04\0\x02\x06\x12\x03G\x08'\n\x0c\n\x05\x04\
    \0\x02\x06\x04\x12\x03G\x08\x10\n\x0c\n\x05\x04\0\x02\x06\x05\x12\x03G\
    \x11\x18\n\x0c\n\x05\x04\0\x02\x06\x01\x12\x03G\x19\"\n\x0c\n\x05\x04\0\
    \x02\x06\x03\x12\x03G%&\n\x0b\n\x04\x04\0\x02\x07\x12\x03H\x083\n\x0c\n\
    \x05\x04\0\x02\x07\x04\x12\x03H\x08\x10\n\x0c\n\x05\x04\0\x02\x07\x05\
    \x12\x03H\x11\x17\n\x0c\n\x05\x04\0\x02\x07\x01\x12\x03H\x18.\n\x0c\n\
    \x05\x04\0\x02\x07\x03\x12\x03H12\n\x0b\n\x04\x04\0\x02\x08\x12\x03I\x08\
    +\n\x0c\n\x05\x04\0\x02\x08\x04\x12\x03I\x08\x10\n\x0c\n\x05\x04\0\x02\
    \x08\x05\x12\x03I\x11\x18\n\x0c\n\x05\x04\0\x02\x08\x01\x12\x03I\x19&\n\
    \x0c\n\x05\x04\0\x02\x08\x03\x12\x03I)*\n\x0b\n\x04\x04\0\x02\t\x12\x03J\
    \x08:\n\x0c\n\x05\x04\0\x02\t\x04\x12\x03J\x08\x10\n\x0c\n\x05\x04\0\x02\
    \t\x05\x12\x03J\x11\x17\n\x0c\n\x05\x04\0\x02\t\x01\x12\x03J\x185\n\x0c\
    \n\x05\x04\0\x02\t\x03\x12\x03J89\n\x0b\n\x04\x04\0\x02\n\x12\x03K\x08#\
    \n\x0c\n\x05\x04\0\x02\n\x04\x12\x03K\x08\x10\n\x0c\n\x05\x04\0\x02\n\
    \x05\x12\x03K\x11\x17\n\x0c\n\x05\x04\0\x02\n\x01\x12\x03K\x18\x1d\n\x0c\
    \n\x05\x04\0\x02\n\x03\x12\x03K\x20\"\n\x0b\n\x04\x04\0\x02\x0b\x12\x03L\
    \x08X\n\x0c\n\x05\x04\0\x02\x0b\x04\x12\x03L\x08\x10\n\x0c\n\x05\x04\0\
    \x02\x0b\x06\x12\x03L\x11A\n\x0c\n\x05\x04\0\x02\x0b\x01\x12\x03LBR\n\
    \x0c\n\x05\x04\0\x02\x0b\x03\x12\x03LUW\n\x0b\n\x04\x04\0\x02\x0c\x12\
    \x03M\x08Q\n\x0c\n\x05\x04\0\x02\x0c\x04\x12\x03M\x08\x10\n\x0c\n\x05\
    \x04\0\x02\x0c\x06\x12\x03M\x11=\n\x0c\n\x05\x04\0\x02\x0c\x01\x12\x03M>\
    K\n\x0c\n\x05\x04\0\x02\x0c\x03\x12\x03MNP\n\n\n\x02\x04\x01\x12\x04P\0V\
    \x01\n\n\n\x03\x04\x01\x01\x12\x03P\x08.\n\x0b\n\x04\x04\x01\x02\0\x12\
    \x03Q\x08,\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03Q\x08\x10\n\x0c\n\x05\
    \x04\x01\x02\0\x05\x12\x03Q\x11\x18\n\x0c\n\x05\x04\x01\x02\0\x01\x12\
    \x03Q\x19'\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03Q*+\n\x0b\n\x04\x04\x01\
    \x02\x01\x12\x03R\x08.\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\x03R\x08\x10\
    \n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03R\x11\x18\n\x0c\n\x05\x04\x01\
    \x02\x01\x01\x12\x03R\x19)\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03R,-\n\
    \x0b\n\x04\x04\x01\x02\x02\x12\x03S\x08)\n\x0c\n\x05\x04\x01\x02\x02\x04\
    \x12\x03S\x08\x10\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03S\x11\x18\n\x0c\
    \n\x05\x04\x01\x02\x02\x01\x12\x03S\x19$\n\x0c\n\x05\x04\x01\x02\x02\x03\
    \x12\x03S'(\n\x0b\n\x04\x04\x01\x02\x03\x12\x03T\x08'\n\x0c\n\x05\x04\
    \x01\x02\x03\x04\x12\x03T\x08\x10\n\x0c\n\x05\x04\x01\x02\x03\x05\x12\
    \x03T\x11\x18\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x03T\x19\"\n\x0c\n\x05\
    \x04\x01\x02\x03\x03\x12\x03T%&\n\x0b\n\x04\x04\x01\x02\x04\x12\x03U\x08\
    .\n\x0c\n\x05\x04\x01\x02\x04\x04\x12\x03U\x08\x10\n\x0c\n\x05\x04\x01\
    \x02\x04\x05\x12\x03U\x11\x18\n\x0c\n\x05\x04\x01\x02\x04\x01\x12\x03U\
    \x19)\n\x0c\n\x05\x04\x01\x02\x04\x03\x12\x03U,-\n\n\n\x02\x04\x02\x12\
    \x04X\0[\x01\n\n\n\x03\x04\x02\x01\x12\x03X\x082\n\x0b\n\x04\x04\x02\x02\
    \0\x12\x03Y\x08.\n\x0c\n\x05\x04\x02\x02\0\x04\x12\x03Y\x08\x10\n\x0c\n\
    \x05\x04\x02\x02\0\x05\x12\x03Y\x11\x18\n\x0c\n\x05\x04\x02\x02\0\x01\
    \x12\x03Y\x19)\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03Y,-\n\x0b\n\x04\x04\
    \x02\x02\x01\x12\x03Z\x08(\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03Z\x08\
    \x10\n\x0c\n\x05\x04\x02\x02\x01\x05\x12\x03Z\x11\x18\n\x0c\n\x05\x04\
    \x02\x02\x01\x01\x12\x03Z\x19\"\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03Z\
    %'\n\n\n\x02\x04\x03\x12\x04]\0i\x01\n\n\n\x03\x04\x03\x01\x12\x03]\x08,\
    \n\x0c\n\x04\x04\x03\x03\0\x12\x04^\x08d\t\n\x0c\n\x05\x04\x03\x03\0\x01\
    \x12\x03^\x10\x1a\n\r\n\x06\x04\x03\x03\0\x02\0\x12\x03_\x104\n\x0e\n\
    \x07\x04\x03\x03\0\x02\0\x04\x12\x03_\x10\x18\n\x0e\n\x07\x04\x03\x03\0\
    \x02\0\x05\x12\x03_\x19\x20\n\x0e\n\x07\x04\x03\x03\0\x02\0\x01\x12\x03_\
    !/\n\x0e\n\x07\x04\x03\x03\0\x02\0\x03\x12\x03_23\n\r\n\x06\x04\x03\x03\
    \0\x02\x01\x12\x03`\x10/\n\x0e\n\x07\x04\x03\x03\0\x02\x01\x04\x12\x03`\
    \x10\x18\n\x0e\n\x07\x04\x03\x03\0\x02\x01\x05\x12\x03`\x19\x20\n\x0e\n\
    \x07\x04\x03\x03\0\x02\x01\x01\x12\x03`!*\n\x0e\n\x07\x04\x03\x03\0\x02\
    \x01\x03\x12\x03`-.\n\r\n\x06\x04\x03\x03\0\x02\x02\x12\x03a\x106\n\x0e\
    \n\x07\x04\x03\x03\0\x02\x02\x04\x12\x03a\x10\x18\n\x0e\n\x07\x04\x03\
    \x03\0\x02\x02\x05\x12\x03a\x19\x20\n\x0e\n\x07\x04\x03\x03\0\x02\x02\
    \x01\x12\x03a!1\n\x0e\n\x07\x04\x03\x03\0\x02\x02\x03\x12\x03a45\n\r\n\
    \x06\x04\x03\x03\0\x02\x03\x12\x03b\x104\n\x0e\n\x07\x04\x03\x03\0\x02\
    \x03\x04\x12\x03b\x10\x18\n\x0e\n\x07\x04\x03\x03\0\x02\x03\x05\x12\x03b\
    \x19\x20\n\x0e\n\x07\x04\x03\x03\0\x02\x03\x01\x12\x03b!/\n\x0e\n\x07\
    \x04\x03\x03\0\x02\x03\x03\x12\x03b23\n\r\n\x06\x04\x03\x03\0\x02\x04\
    \x12\x03c\x10*\n\x0e\n\x07\x04\x03\x03\0\x02\x04\x04\x12\x03c\x10\x18\n\
    \x0e\n\x07\x04\x03\x03\0\x02\x04\x05\x12\x03c\x19\x1f\n\x0e\n\x07\x04\
    \x03\x03\0\x02\x04\x01\x12\x03c\x20%\n\x0e\n\x07\x04\x03\x03\0\x02\x04\
    \x03\x12\x03c()\n\x0b\n\x04\x04\x03\x02\0\x12\x03f\x08>\n\x0c\n\x05\x04\
    \x03\x02\0\x04\x12\x03f\x08\x10\n\x0c\n\x05\x04\x03\x02\0\x06\x12\x03f\
    \x114\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03f59\n\x0c\n\x05\x04\x03\x02\0\
    \x03\x12\x03f<=\n\x0b\n\x04\x04\x03\x02\x01\x12\x03g\x08'\n\x0c\n\x05\
    \x04\x03\x02\x01\x04\x12\x03g\x08\x10\n\x0c\n\x05\x04\x03\x02\x01\x05\
    \x12\x03g\x11\x16\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03g\x17\"\n\x0c\n\
    \x05\x04\x03\x02\x01\x03\x12\x03g%&\n\x0b\n\x04\x04\x03\x02\x02\x12\x03h\
    \x08%\n\x0c\n\x05\x04\x03\x02\x02\x04\x12\x03h\x08\x10\n\x0c\n\x05\x04\
    \x03\x02\x02\x05\x12\x03h\x11\x16\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\
    \x03h\x17\x20\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x03h#$\n\n\n\x02\x04\
    \x04\x12\x04k\0r\x01\n\n\n\x03\x04\x04\x01\x12\x03k\x08/\n\x0b\n\x04\x04\
    \x04\x02\0\x12\x03l\x08+\n\x0c\n\x05\x04\x04\x02\0\x04\x12\x03l\x08\x10\
    \n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03l\x11\x18\n\x0c\n\x05\x04\x04\x02\
    \0\x01\x12\x03l\x19&\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03l)*\n\x0b\n\
    \x04\x04\x04\x02\x01\x12\x03m\x08,\n\x0c\n\x05\x04\x04\x02\x01\x04\x12\
    \x03m\x08\x10\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\x03m\x11\x18\n\x0c\n\
    \x05\x04\x04\x02\x01\x01\x12\x03m\x19'\n\x0c\n\x05\x04\x04\x02\x01\x03\
    \x12\x03m*+\n\x0b\n\x04\x04\x04\x02\x02\x12\x03n\x08.\n\x0c\n\x05\x04\
    \x04\x02\x02\x04\x12\x03n\x08\x10\n\x0c\n\x05\x04\x04\x02\x02\x05\x12\
    \x03n\x11\x18\n\x0c\n\x05\x04\x04\x02\x02\x01\x12\x03n\x19)\n\x0c\n\x05\
    \x04\x04\x02\x02\x03\x12\x03n,-\n\x0b\n\x04\x04\x04\x02\x03\x12\x03o\x08\
    )\n\x0c\n\x05\x04\x04\x02\x03\x04\x12\x03o\x08\x10\n\x0c\n\x05\x04\x04\
    \x02\x03\x05\x12\x03o\x11\x18\n\x0c\n\x05\x04\x04\x02\x03\x01\x12\x03o\
    \x19$\n\x0c\n\x05\x04\x04\x02\x03\x03\x12\x03o'(\n\x0b\n\x04\x04\x04\x02\
    \x04\x12\x03p\x08'\n\x0c\n\x05\x04\x04\x02\x04\x04\x12\x03p\x08\x10\n\
    \x0c\n\x05\x04\x04\x02\x04\x05\x12\x03p\x11\x18\n\x0c\n\x05\x04\x04\x02\
    \x04\x01\x12\x03p\x19\"\n\x0c\n\x05\x04\x04\x02\x04\x03\x12\x03p%&\n\x0b\
    \n\x04\x04\x04\x02\x05\x12\x03q\x083\n\x0c\n\x05\x04\x04\x02\x05\x04\x12\
    \x03q\x08\x10\n\x0c\n\x05\x04\x04\x02\x05\x05\x12\x03q\x11\x17\n\x0c\n\
    \x05\x04\x04\x02\x05\x01\x12\x03q\x18.\n\x0c\n\x05\x04\x04\x02\x05\x03\
    \x12\x03q12\n\n\n\x02\x04\x05\x12\x04t\0y\x01\n\n\n\x03\x04\x05\x01\x12\
    \x03t\x08-\n\x0b\n\x04\x04\x05\x02\0\x12\x03u\x084\n\x0c\n\x05\x04\x05\
    \x02\0\x04\x12\x03u\x08\x10\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03u\x11\
    \x17\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03u\x18/\n\x0c\n\x05\x04\x05\x02\
    \0\x03\x12\x03u23\n\x0b\n\x04\x04\x05\x02\x01\x12\x03v\x083\n\x0c\n\x05\
    \x04\x05\x02\x01\x04\x12\x03v\x08\x10\n\x0c\n\x05\x04\x05\x02\x01\x05\
    \x12\x03v\x11\x18\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x03v\x19.\n\x0c\n\
    \x05\x04\x05\x02\x01\x03\x12\x03v12\n\x0b\n\x04\x04\x05\x02\x02\x12\x03w\
    \x080\n\x0c\n\x05\x04\x05\x02\x02\x04\x12\x03w\x08\x10\n\x0c\n\x05\x04\
    \x05\x02\x02\x05\x12\x03w\x11\x18\n\x0c\n\x05\x04\x05\x02\x02\x01\x12\
    \x03w\x19+\n\x0c\n\x05\x04\x05\x02\x02\x03\x12\x03w./\n\x0b\n\x04\x04\
    \x05\x02\x03\x12\x03x\x08)\n\x0c\n\x05\x04\x05\x02\x03\x04\x12\x03x\x08\
    \x10\n\x0c\n\x05\x04\x05\x02\x03\x05\x12\x03x\x11\x18\n\x0c\n\x05\x04\
    \x05\x02\x03\x01\x12\x03x\x19#\n\x0c\n\x05\x04\x05\x02\x03\x03\x12\x03x&\
    (\n\n\n\x02\x04\x06\x12\x04{\0}\x01\n\n\n\x03\x04\x06\x01\x12\x03{\x080\
    \n\x0b\n\x04\x04\x06\x02\0\x12\x03|\x08+\n\x0c\n\x05\x04\x06\x02\0\x04\
    \x12\x03|\x08\x10\n\x0c\n\x05\x04\x06\x02\0\x05\x12\x03|\x11\x18\n\x0c\n\
    \x05\x04\x06\x02\0\x01\x12\x03|\x19&\n\x0c\n\x05\x04\x06\x02\0\x03\x12\
    \x03|)*\n\x0b\n\x02\x04\x07\x12\x05\x7f\0\xa3\x01\x01\n\n\n\x03\x04\x07\
    \x01\x12\x03\x7f\x08.\n\x0e\n\x04\x04\x07\x03\0\x12\x06\x80\x01\x08\x97\
    \x01\t\n\r\n\x05\x04\x07\x03\0\x01\x12\x04\x80\x01\x10\x13\n\x10\n\x06\
    \x04\x07\x03\0\x03\0\x12\x06\x81\x01\x10\x85\x01\x11\n\x0f\n\x07\x04\x07\
    \x03\0\x03\0\x01\x12\x04\x81\x01\x18\"\n\x10\n\x08\x04\x07\x03\0\x03\0\
    \x02\0\x12\x04\x82\x01\x18/\n\x11\n\t\x04\x07\x03\0\x03\0\x02\0\x04\x12\
    \x04\x82\x01\x18\x20\n\x11\n\t\x04\x07\x03\0\x03\0\x02\0\x05\x12\x04\x82\
    \x01!'\n\x11\n\t\x04\x07\x03\0\x03\0\x02\0\x01\x12\x04\x82\x01(*\n\x11\n\
    \t\x04\x07\x03\0\x03\0\x02\0\x03\x12\x04\x82\x01-.\n\x10\n\x08\x04\x07\
    \x03\0\x03\0\x02\x01\x12\x04\x83\x01\x18:\n\x11\n\t\x04\x07\x03\0\x03\0\
    \x02\x01\x04\x12\x04\x83\x01\x18\x20\n\x11\n\t\x04\x07\x03\0\x03\0\x02\
    \x01\x05\x12\x04\x83\x01!'\n\x11\n\t\x04\x07\x03\0\x03\0\x02\x01\x01\x12\
    \x04\x83\x01(5\n\x11\n\t\x04\x07\x03\0\x03\0\x02\x01\x03\x12\x04\x83\x01\
    89\n\x10\n\x08\x04\x07\x03\0\x03\0\x02\x02\x12\x04\x84\x01\x184\n\x11\n\
    \t\x04\x07\x03\0\x03\0\x02\x02\x04\x12\x04\x84\x01\x18\x20\n\x11\n\t\x04\
    \x07\x03\0\x03\0\x02\x02\x05\x12\x04\x84\x01!'\n\x11\n\t\x04\x07\x03\0\
    \x03\0\x02\x02\x01\x12\x04\x84\x01(/\n\x11\n\t\x04\x07\x03\0\x03\0\x02\
    \x02\x03\x12\x04\x84\x0123\n\x0e\n\x06\x04\x07\x03\0\x02\0\x12\x04\x87\
    \x01\x10,\n\x0f\n\x07\x04\x07\x03\0\x02\0\x04\x12\x04\x87\x01\x10\x18\n\
    \x0f\n\x07\x04\x07\x03\0\x02\0\x05\x12\x04\x87\x01\x19\x20\n\x0f\n\x07\
    \x04\x07\x03\0\x02\0\x01\x12\x04\x87\x01!'\n\x0f\n\x07\x04\x07\x03\0\x02\
    \0\x03\x12\x04\x87\x01*+\n\x0e\n\x06\x04\x07\x03\0\x02\x01\x12\x04\x88\
    \x01\x10:\n\x0f\n\x07\x04\x07\x03\0\x02\x01\x04\x12\x04\x88\x01\x10\x18\
    \n\x0f\n\x07\x04\x07\x03\0\x02\x01\x05\x12\x04\x88\x01\x19\x1f\n\x0f\n\
    \x07\x04\x07\x03\0\x02\x01\x01\x12\x04\x88\x01\x205\n\x0f\n\x07\x04\x07\
    \x03\0\x02\x01\x03\x12\x04\x88\x0189\n\x0e\n\x06\x04\x07\x03\0\x02\x02\
    \x12\x04\x89\x01\x104\n\x0f\n\x07\x04\x07\x03\0\x02\x02\x04\x12\x04\x89\
    \x01\x10\x18\n\x0f\n\x07\x04\x07\x03\0\x02\x02\x05\x12\x04\x89\x01\x19\
    \x1f\n\x0f\n\x07\x04\x07\x03\0\x02\x02\x01\x12\x04\x89\x01\x20/\n\x0f\n\
    \x07\x04\x07\x03\0\x02\x02\x03\x12\x04\x89\x0123\n\x0e\n\x06\x04\x07\x03\
    \0\x02\x03\x12\x04\x8a\x01\x10b\n\x0f\n\x07\x04\x07\x03\0\x02\x03\x04\
    \x12\x04\x8a\x01\x10\x18\n\x0f\n\x07\x04\x07\x03\0\x02\x03\x06\x12\x04\
    \x8a\x01\x19O\n\x0f\n\x07\x04\x07\x03\0\x02\x03\x01\x12\x04\x8a\x01P]\n\
    \x0f\n\x07\x04\x07\x03\0\x02\x03\x03\x12\x04\x8a\x01`a\n\x0e\n\x06\x04\
    \x07\x03\0\x02\x04\x12\x04\x8b\x01\x108\n\x0f\n\x07\x04\x07\x03\0\x02\
    \x04\x04\x12\x04\x8b\x01\x10\x18\n\x0f\n\x07\x04\x07\x03\0\x02\x04\x05\
    \x12\x04\x8b\x01\x19\x1f\n\x0f\n\x07\x04\x07\x03\0\x02\x04\x01\x12\x04\
    \x8b\x01\x203\n\x0f\n\x07\x04\x07\x03\0\x02\x04\x03\x12\x04\x8b\x0167\n\
    \x0e\n\x06\x04\x07\x03\0\x02\x05\x12\x04\x8c\x01\x106\n\x0f\n\x07\x04\
    \x07\x03\0\x02\x05\x04\x12\x04\x8c\x01\x10\x18\n\x0f\n\x07\x04\x07\x03\0\
    \x02\x05\x05\x12\x04\x8c\x01\x19\x1f\n\x0f\n\x07\x04\x07\x03\0\x02\x05\
    \x01\x12\x04\x8c\x01\x201\n\x0f\n\x07\x04\x07\x03\0\x02\x05\x03\x12\x04\
    \x8c\x0145\n\x0e\n\x06\x04\x07\x03\0\x02\x06\x12\x04\x8d\x01\x10?\n\x0f\
    \n\x07\x04\x07\x03\0\x02\x06\x04\x12\x04\x8d\x01\x10\x18\n\x0f\n\x07\x04\
    \x07\x03\0\x02\x06\x05\x12\x04\x8d\x01\x19\x20\n\x0f\n\x07\x04\x07\x03\0\
    \x02\x06\x01\x12\x04\x8d\x01!:\n\x0f\n\x07\x04\x07\x03\0\x02\x06\x03\x12\
    \x04\x8d\x01=>\n\x0e\n\x06\x04\x07\x03\0\x02\x07\x12\x04\x8e\x01\x104\n\
    \x0f\n\x07\x04\x07\x03\0\x02\x07\x04\x12\x04\x8e\x01\x10\x18\n\x0f\n\x07\
    \x04\x07\x03\0\x02\x07\x05\x12\x04\x8e\x01\x19\x1f\n\x0f\n\x07\x04\x07\
    \x03\0\x02\x07\x01\x12\x04\x8e\x01\x20/\n\x0f\n\x07\x04\x07\x03\0\x02\
    \x07\x03\x12\x04\x8e\x0123\n\x0e\n\x06\x04\x07\x03\0\x02\x08\x12\x04\x8f\
    \x01\x103\n\x0f\n\x07\x04\x07\x03\0\x02\x08\x04\x12\x04\x8f\x01\x10\x18\
    \n\x0f\n\x07\x04\x07\x03\0\x02\x08\x05\x12\x04\x8f\x01\x19\x1f\n\x0f\n\
    \x07\x04\x07\x03\0\x02\x08\x01\x12\x04\x8f\x01\x20-\n\x0f\n\x07\x04\x07\
    \x03\0\x02\x08\x03\x12\x04\x8f\x0102\n\x0e\n\x06\x04\x07\x03\0\x02\t\x12\
    \x04\x90\x01\x10?\n\x0f\n\x07\x04\x07\x03\0\x02\t\x04\x12\x04\x90\x01\
    \x10\x18\n\x0f\n\x07\x04\x07\x03\0\x02\t\x05\x12\x04\x90\x01\x19\x20\n\
    \x0f\n\x07\x04\x07\x03\0\x02\t\x01\x12\x04\x90\x01!9\n\x0f\n\x07\x04\x07\
    \x03\0\x02\t\x03\x12\x04\x90\x01<>\n\x0e\n\x06\x04\x07\x03\0\x02\n\x12\
    \x04\x91\x01\x108\n\x0f\n\x07\x04\x07\x03\0\x02\n\x04\x12\x04\x91\x01\
    \x10\x18\n\x0f\n\x07\x04\x07\x03\0\x02\n\x05\x12\x04\x91\x01\x19\x1f\n\
    \x0f\n\x07\x04\x07\x03\0\x02\n\x01\x12\x04\x91\x01\x202\n\x0f\n\x07\x04\
    \x07\x03\0\x02\n\x03\x12\x04\x91\x0157\n\x0e\n\x06\x04\x07\x03\0\x02\x0b\
    \x12\x04\x92\x01\x106\n\x0f\n\x07\x04\x07\x03\0\x02\x0b\x04\x12\x04\x92\
    \x01\x10\x18\n\x0f\n\x07\x04\x07\x03\0\x02\x0b\x05\x12\x04\x92\x01\x19\
    \x1f\n\x0f\n\x07\x04\x07\x03\0\x02\x0b\x01\x12\x04\x92\x01\x200\n\x0f\n\
    \x07\x04\x07\x03\0\x02\x0b\x03\x12\x04\x92\x0135\n\x0e\n\x06\x04\x07\x03\
    \0\x02\x0c\x12\x04\x93\x01\x10B\n\x0f\n\x07\x04\x07\x03\0\x02\x0c\x04\
    \x12\x04\x93\x01\x10\x18\n\x0f\n\x07\x04\x07\x03\0\x02\x0c\x05\x12\x04\
    \x93\x01\x19\x20\n\x0f\n\x07\x04\x07\x03\0\x02\x0c\x01\x12\x04\x93\x01!<\
    \n\x0f\n\x07\x04\x07\x03\0\x02\x0c\x03\x12\x04\x93\x01?A\n\x0e\n\x06\x04\
    \x07\x03\0\x02\r\x12\x04\x94\x01\x105\n\x0f\n\x07\x04\x07\x03\0\x02\r\
    \x04\x12\x04\x94\x01\x10\x18\n\x0f\n\x07\x04\x07\x03\0\x02\r\x05\x12\x04\
    \x94\x01\x19\x1f\n\x0f\n\x07\x04\x07\x03\0\x02\r\x01\x12\x04\x94\x01\x20\
    /\n\x0f\n\x07\x04\x07\x03\0\x02\r\x03\x12\x04\x94\x0124\n\x0e\n\x06\x04\
    \x07\x03\0\x02\x0e\x12\x04\x95\x01\x103\n\x0f\n\x07\x04\x07\x03\0\x02\
    \x0e\x04\x12\x04\x95\x01\x10\x18\n\x0f\n\x07\x04\x07\x03\0\x02\x0e\x05\
    \x12\x04\x95\x01\x19\x1f\n\x0f\n\x07\x04\x07\x03\0\x02\x0e\x01\x12\x04\
    \x95\x01\x20-\n\x0f\n\x07\x04\x07\x03\0\x02\x0e\x03\x12\x04\x95\x0102\n\
    \x0e\n\x06\x04\x07\x03\0\x02\x0f\x12\x04\x96\x01\x10?\n\x0f\n\x07\x04\
    \x07\x03\0\x02\x0f\x04\x12\x04\x96\x01\x10\x18\n\x0f\n\x07\x04\x07\x03\0\
    \x02\x0f\x05\x12\x04\x96\x01\x19\x20\n\x0f\n\x07\x04\x07\x03\0\x02\x0f\
    \x01\x12\x04\x96\x01!9\n\x0f\n\x07\x04\x07\x03\0\x02\x0f\x03\x12\x04\x96\
    \x01<>\n\x0e\n\x04\x04\x07\x03\x01\x12\x06\x99\x01\x08\x9d\x01\t\n\r\n\
    \x05\x04\x07\x03\x01\x01\x12\x04\x99\x01\x10\x20\n\x0e\n\x06\x04\x07\x03\
    \x01\x02\0\x12\x04\x9a\x01\x104\n\x0f\n\x07\x04\x07\x03\x01\x02\0\x04\
    \x12\x04\x9a\x01\x10\x18\n\x0f\n\x07\x04\x07\x03\x01\x02\0\x05\x12\x04\
    \x9a\x01\x19\x20\n\x0f\n\x07\x04\x07\x03\x01\x02\0\x01\x12\x04\x9a\x01!/\
    \n\x0f\n\x07\x04\x07\x03\x01\x02\0\x03\x12\x04\x9a\x0123\n\x0e\n\x06\x04\
    \x07\x03\x01\x02\x01\x12\x04\x9b\x01\x10>\n\x0f\n\x07\x04\x07\x03\x01\
    \x02\x01\x04\x12\x04\x9b\x01\x10\x18\n\x0f\n\x07\x04\x07\x03\x01\x02\x01\
    \x05\x12\x04\x9b\x01\x19\x20\n\x0f\n\x07\x04\x07\x03\x01\x02\x01\x01\x12\
    \x04\x9b\x01!9\n\x0f\n\x07\x04\x07\x03\x01\x02\x01\x03\x12\x04\x9b\x01<=\
    \n\x0e\n\x06\x04\x07\x03\x01\x02\x02\x12\x04\x9c\x01\x104\n\x0f\n\x07\
    \x04\x07\x03\x01\x02\x02\x04\x12\x04\x9c\x01\x10\x18\n\x0f\n\x07\x04\x07\
    \x03\x01\x02\x02\x05\x12\x04\x9c\x01\x19\x1f\n\x0f\n\x07\x04\x07\x03\x01\
    \x02\x02\x01\x12\x04\x9c\x01\x20/\n\x0f\n\x07\x04\x07\x03\x01\x02\x02\
    \x03\x12\x04\x9c\x0123\n\x0c\n\x04\x04\x07\x02\0\x12\x04\x9f\x01\x08+\n\
    \r\n\x05\x04\x07\x02\0\x04\x12\x04\x9f\x01\x08\x10\n\r\n\x05\x04\x07\x02\
    \0\x05\x12\x04\x9f\x01\x11\x18\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\x9f\
    \x01\x19&\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\x9f\x01)*\n\x0c\n\x04\x04\
    \x07\x02\x01\x12\x04\xa0\x01\x08*\n\r\n\x05\x04\x07\x02\x01\x04\x12\x04\
    \xa0\x01\x08\x10\n\r\n\x05\x04\x07\x02\x01\x05\x12\x04\xa0\x01\x11\x15\n\
    \r\n\x05\x04\x07\x02\x01\x01\x12\x04\xa0\x01\x16%\n\r\n\x05\x04\x07\x02\
    \x01\x03\x12\x04\xa0\x01()\n\x0c\n\x04\x04\x07\x02\x02\x12\x04\xa1\x01\
    \x08F\n\r\n\x05\x04\x07\x02\x02\x04\x12\x04\xa1\x01\x08\x10\n\r\n\x05\
    \x04\x07\x02\x02\x06\x12\x04\xa1\x01\x11<\n\r\n\x05\x04\x07\x02\x02\x01\
    \x12\x04\xa1\x01=A\n\r\n\x05\x04\x07\x02\x02\x03\x12\x04\xa1\x01DE\n\x0c\
    \n\x04\x04\x07\x02\x03\x12\x04\xa2\x01\x08b\n\r\n\x05\x04\x07\x02\x03\
    \x04\x12\x04\xa2\x01\x08\x10\n\r\n\x05\x04\x07\x02\x03\x06\x12\x04\xa2\
    \x01\x11I\n\r\n\x05\x04\x07\x02\x03\x01\x12\x04\xa2\x01J]\n\r\n\x05\x04\
    \x07\x02\x03\x03\x12\x04\xa2\x01`a\n\x0c\n\x02\x04\x08\x12\x06\xa5\x01\0\
    \xb9\x01\x01\n\x0b\n\x03\x04\x08\x01\x12\x04\xa5\x01\x08.\n\x0e\n\x04\
    \x04\x08\x03\0\x12\x06\xa6\x01\x08\xab\x01\t\n\r\n\x05\x04\x08\x03\0\x01\
    \x12\x04\xa6\x01\x10\x1d\n\x0e\n\x06\x04\x08\x03\0\x02\0\x12\x04\xa7\x01\
    \x10*\n\x0f\n\x07\x04\x08\x03\0\x02\0\x04\x12\x04\xa7\x01\x10\x18\n\x0f\
    \n\x07\x04\x08\x03\0\x02\0\x05\x12\x04\xa7\x01\x19\x1f\n\x0f\n\x07\x04\
    \x08\x03\0\x02\0\x01\x12\x04\xa7\x01\x20%\n\x0f\n\x07\x04\x08\x03\0\x02\
    \0\x03\x12\x04\xa7\x01()\n\x0e\n\x06\x04\x08\x03\0\x02\x01\x12\x04\xa8\
    \x01\x10/\n\x0f\n\x07\x04\x08\x03\0\x02\x01\x04\x12\x04\xa8\x01\x10\x18\
    \n\x0f\n\x07\x04\x08\x03\0\x02\x01\x05\x12\x04\xa8\x01\x19\x1f\n\x0f\n\
    \x07\x04\x08\x03\0\x02\x01\x01\x12\x04\xa8\x01\x20*\n\x0f\n\x07\x04\x08\
    \x03\0\x02\x01\x03\x12\x04\xa8\x01-.\n\x0e\n\x06\x04\x08\x03\0\x02\x02\
    \x12\x04\xa9\x01\x10.\n\x0f\n\x07\x04\x08\x03\0\x02\x02\x04\x12\x04\xa9\
    \x01\x10\x18\n\x0f\n\x07\x04\x08\x03\0\x02\x02\x05\x12\x04\xa9\x01\x19\
    \x1f\n\x0f\n\x07\x04\x08\x03\0\x02\x02\x01\x12\x04\xa9\x01\x20)\n\x0f\n\
    \x07\x04\x08\x03\0\x02\x02\x03\x12\x04\xa9\x01,-\n\x0e\n\x06\x04\x08\x03\
    \0\x02\x03\x12\x04\xaa\x01\x107\n\x0f\n\x07\x04\x08\x03\0\x02\x03\x04\
    \x12\x04\xaa\x01\x10\x18\n\x0f\n\x07\x04\x08\x03\0\x02\x03\x05\x12\x04\
    \xaa\x01\x19\x1f\n\x0f\n\x07\x04\x08\x03\0\x02\x03\x01\x12\x04\xaa\x01\
    \x202\n\x0f\n\x07\x04\x08\x03\0\x02\x03\x03\x12\x04\xaa\x0156\n\x0c\n\
    \x04\x04\x08\x02\0\x12\x04\xad\x01\x08+\n\r\n\x05\x04\x08\x02\0\x04\x12\
    \x04\xad\x01\x08\x10\n\r\n\x05\x04\x08\x02\0\x05\x12\x04\xad\x01\x11\x18\
    \n\r\n\x05\x04\x08\x02\0\x01\x12\x04\xad\x01\x19&\n\r\n\x05\x04\x08\x02\
    \0\x03\x12\x04\xad\x01)*\n\x0c\n\x04\x04\x08\x02\x01\x12\x04\xae\x01\x08\
    %\n\r\n\x05\x04\x08\x02\x01\x04\x12\x04\xae\x01\x08\x10\n\r\n\x05\x04\
    \x08\x02\x01\x05\x12\x04\xae\x01\x11\x18\n\r\n\x05\x04\x08\x02\x01\x01\
    \x12\x04\xae\x01\x19\x20\n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\xae\x01#$\
    \n\x0c\n\x04\x04\x08\x02\x02\x12\x04\xaf\x01\x08&\n\r\n\x05\x04\x08\x02\
    \x02\x04\x12\x04\xaf\x01\x08\x10\n\r\n\x05\x04\x08\x02\x02\x05\x12\x04\
    \xaf\x01\x11\x17\n\r\n\x05\x04\x08\x02\x02\x01\x12\x04\xaf\x01\x18!\n\r\
    \n\x05\x04\x08\x02\x02\x03\x12\x04\xaf\x01$%\n\x0c\n\x04\x04\x08\x02\x03\
    \x12\x04\xb0\x01\x081\n\r\n\x05\x04\x08\x02\x03\x04\x12\x04\xb0\x01\x08\
    \x10\n\r\n\x05\x04\x08\x02\x03\x05\x12\x04\xb0\x01\x11\x18\n\r\n\x05\x04\
    \x08\x02\x03\x01\x12\x04\xb0\x01\x19,\n\r\n\x05\x04\x08\x02\x03\x03\x12\
    \x04\xb0\x01/0\n\x0c\n\x04\x04\x08\x02\x04\x12\x04\xb1\x01\x08-\n\r\n\
    \x05\x04\x08\x02\x04\x04\x12\x04\xb1\x01\x08\x10\n\r\n\x05\x04\x08\x02\
    \x04\x05\x12\x04\xb1\x01\x11\x17\n\r\n\x05\x04\x08\x02\x04\x01\x12\x04\
    \xb1\x01\x18(\n\r\n\x05\x04\x08\x02\x04\x03\x12\x04\xb1\x01+,\n\x0c\n\
    \x04\x04\x08\x02\x05\x12\x04\xb2\x01\x085\n\r\n\x05\x04\x08\x02\x05\x04\
    \x12\x04\xb2\x01\x08\x10\n\r\n\x05\x04\x08\x02\x05\x05\x12\x04\xb2\x01\
    \x11\x17\n\r\n\x05\x04\x08\x02\x05\x01\x12\x04\xb2\x01\x180\n\r\n\x05\
    \x04\x08\x02\x05\x03\x12\x04\xb2\x0134\n\x0c\n\x04\x04\x08\x02\x06\x12\
    \x04\xb3\x01\x080\n\r\n\x05\x04\x08\x02\x06\x04\x12\x04\xb3\x01\x08\x10\
    \n\r\n\x05\x04\x08\x02\x06\x05\x12\x04\xb3\x01\x11\x17\n\r\n\x05\x04\x08\
    \x02\x06\x01\x12\x04\xb3\x01\x18+\n\r\n\x05\x04\x08\x02\x06\x03\x12\x04\
    \xb3\x01./\n\x0c\n\x04\x04\x08\x02\x07\x12\x04\xb4\x01\x08#\n\r\n\x05\
    \x04\x08\x02\x07\x04\x12\x04\xb4\x01\x08\x10\n\r\n\x05\x04\x08\x02\x07\
    \x05\x12\x04\xb4\x01\x11\x17\n\r\n\x05\x04\x08\x02\x07\x01\x12\x04\xb4\
    \x01\x18\x1e\n\r\n\x05\x04\x08\x02\x07\x03\x12\x04\xb4\x01!\"\n\x0c\n\
    \x04\x04\x08\x02\x08\x12\x04\xb5\x01\x08\\\n\r\n\x05\x04\x08\x02\x08\x04\
    \x12\x04\xb5\x01\x08\x10\n\r\n\x05\x04\x08\x02\x08\x06\x12\x04\xb5\x01\
    \x11F\n\r\n\x05\x04\x08\x02\x08\x01\x12\x04\xb5\x01GW\n\r\n\x05\x04\x08\
    \x02\x08\x03\x12\x04\xb5\x01Z[\n\x0c\n\x04\x04\x08\x02\t\x12\x04\xb6\x01\
    \x08[\n\r\n\x05\x04\x08\x02\t\x04\x12\x04\xb6\x01\x08\x10\n\r\n\x05\x04\
    \x08\x02\t\x06\x12\x04\xb6\x01\x11F\n\r\n\x05\x04\x08\x02\t\x01\x12\x04\
    \xb6\x01GU\n\r\n\x05\x04\x08\x02\t\x03\x12\x04\xb6\x01XZ\n\x0c\n\x04\x04\
    \x08\x02\n\x12\x04\xb7\x01\x08^\n\r\n\x05\x04\x08\x02\n\x04\x12\x04\xb7\
    \x01\x08\x10\n\r\n\x05\x04\x08\x02\n\x06\x12\x04\xb7\x01\x11F\n\r\n\x05\
    \x04\x08\x02\n\x01\x12\x04\xb7\x01GX\n\r\n\x05\x04\x08\x02\n\x03\x12\x04\
    \xb7\x01[]\n\x0c\n\x04\x04\x08\x02\x0b\x12\x04\xb8\x01\x08\\\n\r\n\x05\
    \x04\x08\x02\x0b\x04\x12\x04\xb8\x01\x08\x10\n\r\n\x05\x04\x08\x02\x0b\
    \x06\x12\x04\xb8\x01\x11F\n\r\n\x05\x04\x08\x02\x0b\x01\x12\x04\xb8\x01G\
    V\n\r\n\x05\x04\x08\x02\x0b\x03\x12\x04\xb8\x01Y[\n\x0c\n\x02\x04\t\x12\
    \x06\xbb\x01\0\xc5\x01\x01\n\x0b\n\x03\x04\t\x01\x12\x04\xbb\x01\x08'\n\
    \x0c\n\x04\x04\t\x02\0\x12\x04\xbc\x01\x08+\n\r\n\x05\x04\t\x02\0\x04\
    \x12\x04\xbc\x01\x08\x10\n\r\n\x05\x04\t\x02\0\x05\x12\x04\xbc\x01\x11\
    \x18\n\r\n\x05\x04\t\x02\0\x01\x12\x04\xbc\x01\x19&\n\r\n\x05\x04\t\x02\
    \0\x03\x12\x04\xbc\x01)*\n\x0c\n\x04\x04\t\x02\x01\x12\x04\xbd\x01\x08*\
    \n\r\n\x05\x04\t\x02\x01\x04\x12\x04\xbd\x01\x08\x10\n\r\n\x05\x04\t\x02\
    \x01\x05\x12\x04\xbd\x01\x11\x18\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\xbd\
    \x01\x19%\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\xbd\x01()\n\x0c\n\x04\x04\
    \t\x02\x02\x12\x04\xbe\x01\x08(\n\r\n\x05\x04\t\x02\x02\x04\x12\x04\xbe\
    \x01\x08\x10\n\r\n\x05\x04\t\x02\x02\x05\x12\x04\xbe\x01\x11\x17\n\r\n\
    \x05\x04\t\x02\x02\x01\x12\x04\xbe\x01\x18#\n\r\n\x05\x04\t\x02\x02\x03\
    \x12\x04\xbe\x01&'\n\x0c\n\x04\x04\t\x02\x03\x12\x04\xbf\x01\x08)\n\r\n\
    \x05\x04\t\x02\x03\x04\x12\x04\xbf\x01\x08\x10\n\r\n\x05\x04\t\x02\x03\
    \x05\x12\x04\xbf\x01\x11\x17\n\r\n\x05\x04\t\x02\x03\x01\x12\x04\xbf\x01\
    \x18$\n\r\n\x05\x04\t\x02\x03\x03\x12\x04\xbf\x01'(\n\x0c\n\x04\x04\t\
    \x02\x04\x12\x04\xc0\x01\x088\n\r\n\x05\x04\t\x02\x04\x04\x12\x04\xc0\
    \x01\x08\x10\n\r\n\x05\x04\t\x02\x04\x05\x12\x04\xc0\x01\x11\x17\n\r\n\
    \x05\x04\t\x02\x04\x01\x12\x04\xc0\x01\x183\n\r\n\x05\x04\t\x02\x04\x03\
    \x12\x04\xc0\x0167\n\x0c\n\x04\x04\t\x02\x05\x12\x04\xc1\x01\x08D\n\r\n\
    \x05\x04\t\x02\x05\x04\x12\x04\xc1\x01\x08\x10\n\r\n\x05\x04\t\x02\x05\
    \x06\x12\x04\xc1\x01\x119\n\r\n\x05\x04\t\x02\x05\x01\x12\x04\xc1\x01:?\
    \n\r\n\x05\x04\t\x02\x05\x03\x12\x04\xc1\x01BC\n\x0c\n\x04\x04\t\x02\x06\
    \x12\x04\xc2\x01\x08>\n\r\n\x05\x04\t\x02\x06\x04\x12\x04\xc2\x01\x08\
    \x10\n\r\n\x05\x04\t\x02\x06\x06\x12\x04\xc2\x01\x114\n\r\n\x05\x04\t\
    \x02\x06\x01\x12\x04\xc2\x0159\n\r\n\x05\x04\t\x02\x06\x03\x12\x04\xc2\
    \x01<=\n\x0c\n\x04\x04\t\x02\x07\x12\x04\xc3\x01\x08-\n\r\n\x05\x04\t\
    \x02\x07\x04\x12\x04\xc3\x01\x08\x10\n\r\n\x05\x04\t\x02\x07\x05\x12\x04\
    \xc3\x01\x11\x18\n\r\n\x05\x04\t\x02\x07\x01\x12\x04\xc3\x01\x19'\n\r\n\
    \x05\x04\t\x02\x07\x03\x12\x04\xc3\x01*,\n\x0c\n\x04\x04\t\x02\x08\x12\
    \x04\xc4\x01\x084\n\r\n\x05\x04\t\x02\x08\x04\x12\x04\xc4\x01\x08\x10\n\
    \r\n\x05\x04\t\x02\x08\x05\x12\x04\xc4\x01\x11\x18\n\r\n\x05\x04\t\x02\
    \x08\x01\x12\x04\xc4\x01\x19/\n\r\n\x05\x04\t\x02\x08\x03\x12\x04\xc4\
    \x0123\n\x0c\n\x02\x04\n\x12\x06\xc7\x01\0\xcf\x01\x01\n\x0b\n\x03\x04\n\
    \x01\x12\x04\xc7\x01\x08\"\n\x0c\n\x04\x04\n\x02\0\x12\x04\xc8\x01\x082\
    \n\r\n\x05\x04\n\x02\0\x04\x12\x04\xc8\x01\x08\x10\n\r\n\x05\x04\n\x02\0\
    \x05\x12\x04\xc8\x01\x11\x18\n\r\n\x05\x04\n\x02\0\x01\x12\x04\xc8\x01\
    \x19-\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xc8\x0101\n\x0c\n\x04\x04\n\x02\
    \x01\x12\x04\xc9\x01\x082\n\r\n\x05\x04\n\x02\x01\x04\x12\x04\xc9\x01\
    \x08\x10\n\r\n\x05\x04\n\x02\x01\x05\x12\x04\xc9\x01\x11\x18\n\r\n\x05\
    \x04\n\x02\x01\x01\x12\x04\xc9\x01\x19-\n\r\n\x05\x04\n\x02\x01\x03\x12\
    \x04\xc9\x0101\n\x0c\n\x04\x04\n\x02\x02\x12\x04\xca\x01\x08,\n\r\n\x05\
    \x04\n\x02\x02\x04\x12\x04\xca\x01\x08\x10\n\r\n\x05\x04\n\x02\x02\x05\
    \x12\x04\xca\x01\x11\x18\n\r\n\x05\x04\n\x02\x02\x01\x12\x04\xca\x01\x19\
    '\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\xca\x01*+\n\x0c\n\x04\x04\n\x02\
    \x03\x12\x04\xcb\x01\x08,\n\r\n\x05\x04\n\x02\x03\x04\x12\x04\xcb\x01\
    \x08\x10\n\r\n\x05\x04\n\x02\x03\x05\x12\x04\xcb\x01\x11\x17\n\r\n\x05\
    \x04\n\x02\x03\x01\x12\x04\xcb\x01\x18'\n\r\n\x05\x04\n\x02\x03\x03\x12\
    \x04\xcb\x01*+\n\x0c\n\x04\x04\n\x02\x04\x12\x04\xcc\x01\x088\n\r\n\x05\
    \x04\n\x02\x04\x04\x12\x04\xcc\x01\x08\x10\n\r\n\x05\x04\n\x02\x04\x05\
    \x12\x04\xcc\x01\x11\x17\n\r\n\x05\x04\n\x02\x04\x01\x12\x04\xcc\x01\x18\
    3\n\r\n\x05\x04\n\x02\x04\x03\x12\x04\xcc\x0167\n\x0c\n\x04\x04\n\x02\
    \x05\x12\x04\xcd\x01\x08D\n\r\n\x05\x04\n\x02\x05\x04\x12\x04\xcd\x01\
    \x08\x10\n\r\n\x05\x04\n\x02\x05\x06\x12\x04\xcd\x01\x119\n\r\n\x05\x04\
    \n\x02\x05\x01\x12\x04\xcd\x01:?\n\r\n\x05\x04\n\x02\x05\x03\x12\x04\xcd\
    \x01BC\n\x0c\n\x04\x04\n\x02\x06\x12\x04\xce\x01\x08>\n\r\n\x05\x04\n\
    \x02\x06\x04\x12\x04\xce\x01\x08\x10\n\r\n\x05\x04\n\x02\x06\x06\x12\x04\
    \xce\x01\x114\n\r\n\x05\x04\n\x02\x06\x01\x12\x04\xce\x0159\n\r\n\x05\
    \x04\n\x02\x06\x03\x12\x04\xce\x01<=\n\x0c\n\x02\x04\x0b\x12\x06\xd1\x01\
    \0\xda\x01\x01\n\x0b\n\x03\x04\x0b\x01\x12\x04\xd1\x01\x08/\n\x0c\n\x04\
    \x04\x0b\x02\0\x12\x04\xd2\x01\x08)\n\r\n\x05\x04\x0b\x02\0\x04\x12\x04\
    \xd2\x01\x08\x10\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\xd2\x01\x11\x17\n\r\
    \n\x05\x04\x0b\x02\0\x01\x12\x04\xd2\x01\x18$\n\r\n\x05\x04\x0b\x02\0\
    \x03\x12\x04\xd2\x01'(\n\x0c\n\x04\x04\x0b\x02\x01\x12\x04\xd3\x01\x085\
    \n\r\n\x05\x04\x0b\x02\x01\x04\x12\x04\xd3\x01\x08\x10\n\r\n\x05\x04\x0b\
    \x02\x01\x05\x12\x04\xd3\x01\x11\x17\n\r\n\x05\x04\x0b\x02\x01\x01\x12\
    \x04\xd3\x01\x180\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\xd3\x0134\n\x0c\
    \n\x04\x04\x0b\x02\x02\x12\x04\xd4\x01\x086\n\r\n\x05\x04\x0b\x02\x02\
    \x04\x12\x04\xd4\x01\x08\x10\n\r\n\x05\x04\x0b\x02\x02\x05\x12\x04\xd4\
    \x01\x11\x17\n\r\n\x05\x04\x0b\x02\x02\x01\x12\x04\xd4\x01\x181\n\r\n\
    \x05\x04\x0b\x02\x02\x03\x12\x04\xd4\x0145\n\x0c\n\x04\x04\x0b\x02\x03\
    \x12\x04\xd5\x01\x08*\n\r\n\x05\x04\x0b\x02\x03\x04\x12\x04\xd5\x01\x08\
    \x10\n\r\n\x05\x04\x0b\x02\x03\x05\x12\x04\xd5\x01\x11\x17\n\r\n\x05\x04\
    \x0b\x02\x03\x01\x12\x04\xd5\x01\x18%\n\r\n\x05\x04\x0b\x02\x03\x03\x12\
    \x04\xd5\x01()\n\x0c\n\x04\x04\x0b\x02\x04\x12\x04\xd6\x01\x08/\n\r\n\
    \x05\x04\x0b\x02\x04\x04\x12\x04\xd6\x01\x08\x10\n\r\n\x05\x04\x0b\x02\
    \x04\x05\x12\x04\xd6\x01\x11\x18\n\r\n\x05\x04\x0b\x02\x04\x01\x12\x04\
    \xd6\x01\x19*\n\r\n\x05\x04\x0b\x02\x04\x03\x12\x04\xd6\x01-.\n\x0c\n\
    \x04\x04\x0b\x02\x05\x12\x04\xd7\x01\x080\n\r\n\x05\x04\x0b\x02\x05\x04\
    \x12\x04\xd7\x01\x08\x10\n\r\n\x05\x04\x0b\x02\x05\x05\x12\x04\xd7\x01\
    \x11\x18\n\r\n\x05\x04\x0b\x02\x05\x01\x12\x04\xd7\x01\x19+\n\r\n\x05\
    \x04\x0b\x02\x05\x03\x12\x04\xd7\x01./\n\x0c\n\x04\x04\x0b\x02\x06\x12\
    \x04\xd8\x01\x08+\n\r\n\x05\x04\x0b\x02\x06\x04\x12\x04\xd8\x01\x08\x10\
    \n\r\n\x05\x04\x0b\x02\x06\x05\x12\x04\xd8\x01\x11\x17\n\r\n\x05\x04\x0b\
    \x02\x06\x01\x12\x04\xd8\x01\x18&\n\r\n\x05\x04\x0b\x02\x06\x03\x12\x04\
    \xd8\x01)*\n\x0c\n\x04\x04\x0b\x02\x07\x12\x04\xd9\x01\x08-\n\r\n\x05\
    \x04\x0b\x02\x07\x04\x12\x04\xd9\x01\x08\x10\n\r\n\x05\x04\x0b\x02\x07\
    \x05\x12\x04\xd9\x01\x11\x17\n\r\n\x05\x04\x0b\x02\x07\x01\x12\x04\xd9\
    \x01\x18(\n\r\n\x05\x04\x0b\x02\x07\x03\x12\x04\xd9\x01+,\n\x0c\n\x02\
    \x04\x0c\x12\x06\xdc\x01\0\xdf\x01\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\
    \xdc\x01\x08*\n\x0c\n\x04\x04\x0c\x02\0\x12\x04\xdd\x01\x08?\n\r\n\x05\
    \x04\x0c\x02\0\x04\x12\x04\xdd\x01\x08\x10\n\r\n\x05\x04\x0c\x02\0\x06\
    \x12\x04\xdd\x01\x116\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xdd\x017:\n\r\
    \n\x05\x04\x0c\x02\0\x03\x12\x04\xdd\x01=>\n\x0c\n\x04\x04\x0c\x02\x01\
    \x12\x04\xde\x01\x08B\n\r\n\x05\x04\x0c\x02\x01\x04\x12\x04\xde\x01\x08\
    \x10\n\r\n\x05\x04\x0c\x02\x01\x06\x12\x04\xde\x01\x119\n\r\n\x05\x04\
    \x0c\x02\x01\x01\x12\x04\xde\x01:=\n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\
    \xde\x01@A\n\x0c\n\x02\x04\r\x12\x06\xe1\x01\0\xfb\x01\x01\n\x0b\n\x03\
    \x04\r\x01\x12\x04\xe1\x01\x08)\n\x0e\n\x04\x04\r\x04\0\x12\x06\xe2\x01\
    \x08\xe6\x01\t\n\r\n\x05\x04\r\x04\0\x01\x12\x04\xe2\x01\r\x17\n\x0e\n\
    \x06\x04\r\x04\0\x02\0\x12\x04\xe3\x01\x10\x19\n\x0f\n\x07\x04\r\x04\0\
    \x02\0\x01\x12\x04\xe3\x01\x10\x14\n\x0f\n\x07\x04\r\x04\0\x02\0\x02\x12\
    \x04\xe3\x01\x17\x18\n\x0e\n\x06\x04\r\x04\0\x02\x01\x12\x04\xe4\x01\x10\
    \x1d\n\x0f\n\x07\x04\r\x04\0\x02\x01\x01\x12\x04\xe4\x01\x10\x18\n\x0f\n\
    \x07\x04\r\x04\0\x02\x01\x02\x12\x04\xe4\x01\x1b\x1c\n\x0e\n\x06\x04\r\
    \x04\0\x02\x02\x12\x04\xe5\x01\x10!\n\x0f\n\x07\x04\r\x04\0\x02\x02\x01\
    \x12\x04\xe5\x01\x10\x1c\n\x0f\n\x07\x04\r\x04\0\x02\x02\x02\x12\x04\xe5\
    \x01\x1f\x20\n\x0c\n\x04\x04\r\x02\0\x12\x04\xe8\x01\x08.\n\r\n\x05\x04\
    \r\x02\0\x04\x12\x04\xe8\x01\x08\x10\n\r\n\x05\x04\r\x02\0\x05\x12\x04\
    \xe8\x01\x11\x18\n\r\n\x05\x04\r\x02\0\x01\x12\x04\xe8\x01\x19)\n\r\n\
    \x05\x04\r\x02\0\x03\x12\x04\xe8\x01,-\n\x0c\n\x04\x04\r\x02\x01\x12\x04\
    \xe9\x01\x080\n\r\n\x05\x04\r\x02\x01\x04\x12\x04\xe9\x01\x08\x10\n\r\n\
    \x05\x04\r\x02\x01\x05\x12\x04\xe9\x01\x11\x18\n\r\n\x05\x04\r\x02\x01\
    \x01\x12\x04\xe9\x01\x19+\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\xe9\x01./\
    \n\x0c\n\x04\x04\r\x02\x02\x12\x04\xea\x01\x082\n\r\n\x05\x04\r\x02\x02\
    \x04\x12\x04\xea\x01\x08\x10\n\r\n\x05\x04\r\x02\x02\x05\x12\x04\xea\x01\
    \x11\x17\n\r\n\x05\x04\r\x02\x02\x01\x12\x04\xea\x01\x18,\n\r\n\x05\x04\
    \r\x02\x02\x03\x12\x04\xea\x01/1\n\x0c\n\x04\x04\r\x02\x03\x12\x04\xeb\
    \x01\x08[\n\r\n\x05\x04\r\x02\x03\x04\x12\x04\xeb\x01\x08\x10\n\r\n\x05\
    \x04\r\x02\x03\x06\x12\x04\xeb\x01\x119\n\r\n\x05\x04\r\x02\x03\x01\x12\
    \x04\xeb\x01:U\n\r\n\x05\x04\r\x02\x03\x03\x12\x04\xeb\x01XZ\n\x0c\n\x04\
    \x04\r\x02\x04\x12\x04\xec\x01\x082\n\r\n\x05\x04\r\x02\x04\x04\x12\x04\
    \xec\x01\x08\x10\n\r\n\x05\x04\r\x02\x04\x05\x12\x04\xec\x01\x11\x18\n\r\
    \n\x05\x04\r\x02\x04\x01\x12\x04\xec\x01\x19-\n\r\n\x05\x04\r\x02\x04\
    \x03\x12\x04\xec\x0101\n\x0c\n\x04\x04\r\x02\x05\x12\x04\xed\x01\x08?\n\
    \r\n\x05\x04\r\x02\x05\x04\x12\x04\xed\x01\x08\x10\n\r\n\x05\x04\r\x02\
    \x05\x05\x12\x04\xed\x01\x11\x17\n\r\n\x05\x04\r\x02\x05\x01\x12\x04\xed\
    \x01\x18:\n\r\n\x05\x04\r\x02\x05\x03\x12\x04\xed\x01=>\n\x0c\n\x04\x04\
    \r\x02\x06\x12\x04\xee\x01\x081\n\r\n\x05\x04\r\x02\x06\x04\x12\x04\xee\
    \x01\x08\x10\n\r\n\x05\x04\r\x02\x06\x05\x12\x04\xee\x01\x11\x18\n\r\n\
    \x05\x04\r\x02\x06\x01\x12\x04\xee\x01\x19,\n\r\n\x05\x04\r\x02\x06\x03\
    \x12\x04\xee\x01/0\n\x0c\n\x04\x04\r\x02\x07\x12\x04\xef\x01\x084\n\r\n\
    \x05\x04\r\x02\x07\x04\x12\x04\xef\x01\x08\x10\n\r\n\x05\x04\r\x02\x07\
    \x05\x12\x04\xef\x01\x11\x18\n\r\n\x05\x04\r\x02\x07\x01\x12\x04\xef\x01\
    \x19.\n\r\n\x05\x04\r\x02\x07\x03\x12\x04\xef\x0113\n\x0c\n\x04\x04\r\
    \x02\x08\x12\x04\xf0\x01\x08?\n\r\n\x05\x04\r\x02\x08\x04\x12\x04\xf0\
    \x01\x08\x10\n\r\n\x05\x04\r\x02\x08\x05\x12\x04\xf0\x01\x11\x16\n\r\n\
    \x05\x04\r\x02\x08\x01\x12\x04\xf0\x01\x179\n\r\n\x05\x04\r\x02\x08\x03\
    \x12\x04\xf0\x01<>\n\x0c\n\x04\x04\r\x02\t\x12\x04\xf1\x01\x085\n\r\n\
    \x05\x04\r\x02\t\x04\x12\x04\xf1\x01\x08\x10\n\r\n\x05\x04\r\x02\t\x05\
    \x12\x04\xf1\x01\x11\x17\n\r\n\x05\x04\r\x02\t\x01\x12\x04\xf1\x01\x18/\
    \n\r\n\x05\x04\r\x02\t\x03\x12\x04\xf1\x0124\n\x0c\n\x04\x04\r\x02\n\x12\
    \x04\xf2\x01\x08_\n\r\n\x05\x04\r\x02\n\x04\x12\x04\xf2\x01\x08\x10\n\r\
    \n\x05\x04\r\x02\n\x06\x12\x04\xf2\x01\x11>\n\r\n\x05\x04\r\x02\n\x01\
    \x12\x04\xf2\x01?I\n\r\n\x05\x04\r\x02\n\x03\x12\x04\xf2\x01LM\n\r\n\x05\
    \x04\r\x02\n\x08\x12\x04\xf2\x01N^\n\r\n\x05\x04\r\x02\n\x07\x12\x04\xf2\
    \x01Y]\n\x0c\n\x04\x04\r\x02\x0b\x12\x04\xf3\x01\x08\"\n\r\n\x05\x04\r\
    \x02\x0b\x04\x12\x04\xf3\x01\x08\x10\n\r\n\x05\x04\r\x02\x0b\x05\x12\x04\
    \xf3\x01\x11\x17\n\r\n\x05\x04\r\x02\x0b\x01\x12\x04\xf3\x01\x18\x1d\n\r\
    \n\x05\x04\r\x02\x0b\x03\x12\x04\xf3\x01\x20!\n\x0c\n\x04\x04\r\x02\x0c\
    \x12\x04\xf4\x01\x08(\n\r\n\x05\x04\r\x02\x0c\x04\x12\x04\xf4\x01\x08\
    \x10\n\r\n\x05\x04\r\x02\x0c\x05\x12\x04\xf4\x01\x11\x17\n\r\n\x05\x04\r\
    \x02\x0c\x01\x12\x04\xf4\x01\x18#\n\r\n\x05\x04\r\x02\x0c\x03\x12\x04\
    \xf4\x01&'\n\x0c\n\x04\x04\r\x02\r\x12\x04\xf5\x01\x08-\n\r\n\x05\x04\r\
    \x02\r\x04\x12\x04\xf5\x01\x08\x10\n\r\n\x05\x04\r\x02\r\x05\x12\x04\xf5\
    \x01\x11\x18\n\r\n\x05\x04\r\x02\r\x01\x12\x04\xf5\x01\x19'\n\r\n\x05\
    \x04\r\x02\r\x03\x12\x04\xf5\x01*,\n\x0c\n\x04\x04\r\x02\x0e\x12\x04\xf6\
    \x01\x08/\n\r\n\x05\x04\r\x02\x0e\x04\x12\x04\xf6\x01\x08\x10\n\r\n\x05\
    \x04\r\x02\x0e\x05\x12\x04\xf6\x01\x11\x15\n\r\n\x05\x04\r\x02\x0e\x01\
    \x12\x04\xf6\x01\x16)\n\r\n\x05\x04\r\x02\x0e\x03\x12\x04\xf6\x01,.\n\
    \x0c\n\x04\x04\r\x02\x0f\x12\x04\xf7\x01\x081\n\r\n\x05\x04\r\x02\x0f\
    \x04\x12\x04\xf7\x01\x08\x10\n\r\n\x05\x04\r\x02\x0f\x05\x12\x04\xf7\x01\
    \x11\x15\n\r\n\x05\x04\r\x02\x0f\x01\x12\x04\xf7\x01\x16+\n\r\n\x05\x04\
    \r\x02\x0f\x03\x12\x04\xf7\x01.0\n\x0c\n\x04\x04\r\x02\x10\x12\x04\xf8\
    \x01\x08H\n\r\n\x05\x04\r\x02\x10\x04\x12\x04\xf8\x01\x08\x10\n\r\n\x05\
    \x04\r\x02\x10\x06\x12\x04\xf8\x01\x114\n\r\n\x05\x04\r\x02\x10\x01\x12\
    \x04\xf8\x015B\n\r\n\x05\x04\r\x02\x10\x03\x12\x04\xf8\x01EG\n\x0c\n\x04\
    \x04\r\x02\x11\x12\x04\xf9\x01\x08F\n\r\n\x05\x04\r\x02\x11\x04\x12\x04\
    \xf9\x01\x08\x10\n\r\n\x05\x04\r\x02\x11\x06\x12\x04\xf9\x01\x114\n\r\n\
    \x05\x04\r\x02\x11\x01\x12\x04\xf9\x015@\n\r\n\x05\x04\r\x02\x11\x03\x12\
    \x04\xf9\x01CE\n\x0c\n\x04\x04\r\x02\x12\x12\x04\xfa\x01\x08N\n\r\n\x05\
    \x04\r\x02\x12\x04\x12\x04\xfa\x01\x08\x10\n\r\n\x05\x04\r\x02\x12\x06\
    \x12\x04\xfa\x01\x114\n\r\n\x05\x04\r\x02\x12\x01\x12\x04\xfa\x015H\n\r\
    \n\x05\x04\r\x02\x12\x03\x12\x04\xfa\x01KM\n\x0c\n\x02\x04\x0e\x12\x06\
    \xfd\x01\0\x8d\x02\x01\n\x0b\n\x03\x04\x0e\x01\x12\x04\xfd\x01\x08%\n\
    \x0c\n\x04\x04\x0e\x02\0\x12\x04\xfe\x01\x08.\n\r\n\x05\x04\x0e\x02\0\
    \x04\x12\x04\xfe\x01\x08\x10\n\r\n\x05\x04\x0e\x02\0\x05\x12\x04\xfe\x01\
    \x11\x18\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\xfe\x01\x19)\n\r\n\x05\x04\
    \x0e\x02\0\x03\x12\x04\xfe\x01,-\n\x0c\n\x04\x04\x0e\x02\x01\x12\x04\xff\
    \x01\x080\n\r\n\x05\x04\x0e\x02\x01\x04\x12\x04\xff\x01\x08\x10\n\r\n\
    \x05\x04\x0e\x02\x01\x05\x12\x04\xff\x01\x11\x18\n\r\n\x05\x04\x0e\x02\
    \x01\x01\x12\x04\xff\x01\x19+\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xff\
    \x01./\n\x0c\n\x04\x04\x0e\x02\x02\x12\x04\x80\x02\x08?\n\r\n\x05\x04\
    \x0e\x02\x02\x04\x12\x04\x80\x02\x08\x10\n\r\n\x05\x04\x0e\x02\x02\x05\
    \x12\x04\x80\x02\x11\x17\n\r\n\x05\x04\x0e\x02\x02\x01\x12\x04\x80\x02\
    \x18:\n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\x80\x02=>\n\x0c\n\x04\x04\
    \x0e\x02\x03\x12\x04\x81\x02\x081\n\r\n\x05\x04\x0e\x02\x03\x04\x12\x04\
    \x81\x02\x08\x10\n\r\n\x05\x04\x0e\x02\x03\x05\x12\x04\x81\x02\x11\x18\n\
    \r\n\x05\x04\x0e\x02\x03\x01\x12\x04\x81\x02\x19,\n\r\n\x05\x04\x0e\x02\
    \x03\x03\x12\x04\x81\x02/0\n\x0c\n\x04\x04\x0e\x02\x04\x12\x04\x82\x02\
    \x084\n\r\n\x05\x04\x0e\x02\x04\x04\x12\x04\x82\x02\x08\x10\n\r\n\x05\
    \x04\x0e\x02\x04\x05\x12\x04\x82\x02\x11\x18\n\r\n\x05\x04\x0e\x02\x04\
    \x01\x12\x04\x82\x02\x19.\n\r\n\x05\x04\x0e\x02\x04\x03\x12\x04\x82\x021\
    3\n\x0c\n\x04\x04\x0e\x02\x05\x12\x04\x83\x02\x081\n\r\n\x05\x04\x0e\x02\
    \x05\x04\x12\x04\x83\x02\x08\x10\n\r\n\x05\x04\x0e\x02\x05\x05\x12\x04\
    \x83\x02\x11\x17\n\r\n\x05\x04\x0e\x02\x05\x01\x12\x04\x83\x02\x18,\n\r\
    \n\x05\x04\x0e\x02\x05\x03\x12\x04\x83\x02/0\n\x0c\n\x04\x04\x0e\x02\x06\
    \x12\x04\x84\x02\x082\n\r\n\x05\x04\x0e\x02\x06\x04\x12\x04\x84\x02\x08\
    \x10\n\r\n\x05\x04\x0e\x02\x06\x05\x12\x04\x84\x02\x11\x18\n\r\n\x05\x04\
    \x0e\x02\x06\x01\x12\x04\x84\x02\x19-\n\r\n\x05\x04\x0e\x02\x06\x03\x12\
    \x04\x84\x0201\n\x0c\n\x04\x04\x0e\x02\x07\x12\x04\x85\x02\x08%\n\r\n\
    \x05\x04\x0e\x02\x07\x04\x12\x04\x85\x02\x08\x10\n\r\n\x05\x04\x0e\x02\
    \x07\x05\x12\x04\x85\x02\x11\x15\n\r\n\x05\x04\x0e\x02\x07\x01\x12\x04\
    \x85\x02\x16\x20\n\r\n\x05\x04\x0e\x02\x07\x03\x12\x04\x85\x02#$\n\x0c\n\
    \x04\x04\x0e\x02\x08\x12\x04\x86\x02\x08/\n\r\n\x05\x04\x0e\x02\x08\x04\
    \x12\x04\x86\x02\x08\x10\n\r\n\x05\x04\x0e\x02\x08\x05\x12\x04\x86\x02\
    \x11\x15\n\r\n\x05\x04\x0e\x02\x08\x01\x12\x04\x86\x02\x16)\n\r\n\x05\
    \x04\x0e\x02\x08\x03\x12\x04\x86\x02,.\n\x0c\n\x04\x04\x0e\x02\t\x12\x04\
    \x87\x02\x081\n\r\n\x05\x04\x0e\x02\t\x04\x12\x04\x87\x02\x08\x10\n\r\n\
    \x05\x04\x0e\x02\t\x05\x12\x04\x87\x02\x11\x15\n\r\n\x05\x04\x0e\x02\t\
    \x01\x12\x04\x87\x02\x16+\n\r\n\x05\x04\x0e\x02\t\x03\x12\x04\x87\x02.0\
    \n\x0c\n\x04\x04\x0e\x02\n\x12\x04\x88\x02\x08H\n\r\n\x05\x04\x0e\x02\n\
    \x04\x12\x04\x88\x02\x08\x10\n\r\n\x05\x04\x0e\x02\n\x06\x12\x04\x88\x02\
    \x114\n\r\n\x05\x04\x0e\x02\n\x01\x12\x04\x88\x025B\n\r\n\x05\x04\x0e\
    \x02\n\x03\x12\x04\x88\x02EG\n\x0c\n\x04\x04\x0e\x02\x0b\x12\x04\x89\x02\
    \x08F\n\r\n\x05\x04\x0e\x02\x0b\x04\x12\x04\x89\x02\x08\x10\n\r\n\x05\
    \x04\x0e\x02\x0b\x06\x12\x04\x89\x02\x114\n\r\n\x05\x04\x0e\x02\x0b\x01\
    \x12\x04\x89\x025@\n\r\n\x05\x04\x0e\x02\x0b\x03\x12\x04\x89\x02CE\n\x0c\
    \n\x04\x04\x0e\x02\x0c\x12\x04\x8a\x02\x08N\n\r\n\x05\x04\x0e\x02\x0c\
    \x04\x12\x04\x8a\x02\x08\x10\n\r\n\x05\x04\x0e\x02\x0c\x06\x12\x04\x8a\
    \x02\x114\n\r\n\x05\x04\x0e\x02\x0c\x01\x12\x04\x8a\x025H\n\r\n\x05\x04\
    \x0e\x02\x0c\x03\x12\x04\x8a\x02KM\n\x0c\n\x04\x04\x0e\x02\r\x12\x04\x8b\
    \x02\x08-\n\r\n\x05\x04\x0e\x02\r\x04\x12\x04\x8b\x02\x08\x10\n\r\n\x05\
    \x04\x0e\x02\r\x05\x12\x04\x8b\x02\x11\x18\n\r\n\x05\x04\x0e\x02\r\x01\
    \x12\x04\x8b\x02\x19'\n\r\n\x05\x04\x0e\x02\r\x03\x12\x04\x8b\x02*,\n\
    \x0c\n\x04\x04\x0e\x02\x0e\x12\x04\x8c\x02\x08*\n\r\n\x05\x04\x0e\x02\
    \x0e\x04\x12\x04\x8c\x02\x08\x10\n\r\n\x05\x04\x0e\x02\x0e\x05\x12\x04\
    \x8c\x02\x11\x18\n\r\n\x05\x04\x0e\x02\x0e\x01\x12\x04\x8c\x02\x19\"\n\r\
    \n\x05\x04\x0e\x02\x0e\x03\x12\x04\x8c\x02%)\n\x0c\n\x02\x04\x0f\x12\x06\
    \x8f\x02\0\x99\x02\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\x8f\x02\x081\n\
    \x0c\n\x04\x04\x0f\x02\0\x12\x04\x90\x02\x08\"\n\r\n\x05\x04\x0f\x02\0\
    \x04\x12\x04\x90\x02\x08\x10\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\x90\x02\
    \x11\x16\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\x90\x02\x17\x1d\n\r\n\x05\
    \x04\x0f\x02\0\x03\x12\x04\x90\x02\x20!\n\x0c\n\x04\x04\x0f\x02\x01\x12\
    \x04\x91\x02\x08,\n\r\n\x05\x04\x0f\x02\x01\x04\x12\x04\x91\x02\x08\x10\
    \n\r\n\x05\x04\x0f\x02\x01\x05\x12\x04\x91\x02\x11\x18\n\r\n\x05\x04\x0f\
    \x02\x01\x01\x12\x04\x91\x02\x19'\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\
    \x91\x02*+\n\x0c\n\x04\x04\x0f\x02\x02\x12\x04\x92\x02\x08'\n\r\n\x05\
    \x04\x0f\x02\x02\x04\x12\x04\x92\x02\x08\x10\n\r\n\x05\x04\x0f\x02\x02\
    \x05\x12\x04\x92\x02\x11\x18\n\r\n\x05\x04\x0f\x02\x02\x01\x12\x04\x92\
    \x02\x19\"\n\r\n\x05\x04\x0f\x02\x02\x03\x12\x04\x92\x02%&\n\x0c\n\x04\
    \x04\x0f\x02\x03\x12\x04\x93\x02\x082\n\r\n\x05\x04\x0f\x02\x03\x04\x12\
    \x04\x93\x02\x08\x10\n\r\n\x05\x04\x0f\x02\x03\x05\x12\x04\x93\x02\x11\
    \x18\n\r\n\x05\x04\x0f\x02\x03\x01\x12\x04\x93\x02\x19-\n\r\n\x05\x04\
    \x0f\x02\x03\x03\x12\x04\x93\x0201\n\x0c\n\x04\x04\x0f\x02\x04\x12\x04\
    \x94\x02\x082\n\r\n\x05\x04\x0f\x02\x04\x04\x12\x04\x94\x02\x08\x10\n\r\
    \n\x05\x04\x0f\x02\x04\x05\x12\x04\x94\x02\x11\x18\n\r\n\x05\x04\x0f\x02\
    \x04\x01\x12\x04\x94\x02\x19-\n\r\n\x05\x04\x0f\x02\x04\x03\x12\x04\x94\
    \x0201\n\x0c\n\x04\x04\x0f\x02\x05\x12\x04\x95\x02\x083\n\r\n\x05\x04\
    \x0f\x02\x05\x04\x12\x04\x95\x02\x08\x10\n\r\n\x05\x04\x0f\x02\x05\x05\
    \x12\x04\x95\x02\x11\x17\n\r\n\x05\x04\x0f\x02\x05\x01\x12\x04\x95\x02\
    \x18.\n\r\n\x05\x04\x0f\x02\x05\x03\x12\x04\x95\x0212\n\x0c\n\x04\x04\
    \x0f\x02\x06\x12\x04\x96\x02\x08-\n\r\n\x05\x04\x0f\x02\x06\x04\x12\x04\
    \x96\x02\x08\x10\n\r\n\x05\x04\x0f\x02\x06\x05\x12\x04\x96\x02\x11\x17\n\
    \r\n\x05\x04\x0f\x02\x06\x01\x12\x04\x96\x02\x18(\n\r\n\x05\x04\x0f\x02\
    \x06\x03\x12\x04\x96\x02+,\n\x0c\n\x04\x04\x0f\x02\x07\x12\x04\x97\x02\
    \x08%\n\r\n\x05\x04\x0f\x02\x07\x04\x12\x04\x97\x02\x08\x10\n\r\n\x05\
    \x04\x0f\x02\x07\x05\x12\x04\x97\x02\x11\x17\n\r\n\x05\x04\x0f\x02\x07\
    \x01\x12\x04\x97\x02\x18\x20\n\r\n\x05\x04\x0f\x02\x07\x03\x12\x04\x97\
    \x02#$\n\x0c\n\x04\x04\x0f\x02\x08\x12\x04\x98\x02\x08#\n\r\n\x05\x04\
    \x0f\x02\x08\x04\x12\x04\x98\x02\x08\x10\n\r\n\x05\x04\x0f\x02\x08\x05\
    \x12\x04\x98\x02\x11\x17\n\r\n\x05\x04\x0f\x02\x08\x01\x12\x04\x98\x02\
    \x18\x1d\n\r\n\x05\x04\x0f\x02\x08\x03\x12\x04\x98\x02\x20\"\n\x0c\n\x02\
    \x04\x10\x12\x06\x9b\x02\0\xa2\x02\x01\n\x0b\n\x03\x04\x10\x01\x12\x04\
    \x9b\x02\x085\n\x0c\n\x04\x04\x10\x02\0\x12\x04\x9c\x02\x08+\n\r\n\x05\
    \x04\x10\x02\0\x04\x12\x04\x9c\x02\x08\x10\n\r\n\x05\x04\x10\x02\0\x05\
    \x12\x04\x9c\x02\x11\x18\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\x9c\x02\x19\
    &\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\x9c\x02)*\n\x0c\n\x04\x04\x10\x02\
    \x01\x12\x04\x9d\x02\x087\n\r\n\x05\x04\x10\x02\x01\x04\x12\x04\x9d\x02\
    \x08\x10\n\r\n\x05\x04\x10\x02\x01\x05\x12\x04\x9d\x02\x11\x17\n\r\n\x05\
    \x04\x10\x02\x01\x01\x12\x04\x9d\x02\x182\n\r\n\x05\x04\x10\x02\x01\x03\
    \x12\x04\x9d\x0256\n\x0c\n\x04\x04\x10\x02\x02\x12\x04\x9e\x02\x083\n\r\
    \n\x05\x04\x10\x02\x02\x04\x12\x04\x9e\x02\x08\x10\n\r\n\x05\x04\x10\x02\
    \x02\x05\x12\x04\x9e\x02\x11\x17\n\r\n\x05\x04\x10\x02\x02\x01\x12\x04\
    \x9e\x02\x18.\n\r\n\x05\x04\x10\x02\x02\x03\x12\x04\x9e\x0212\n\x0c\n\
    \x04\x04\x10\x02\x03\x12\x04\x9f\x02\x08(\n\r\n\x05\x04\x10\x02\x03\x04\
    \x12\x04\x9f\x02\x08\x10\n\r\n\x05\x04\x10\x02\x03\x05\x12\x04\x9f\x02\
    \x11\x17\n\r\n\x05\x04\x10\x02\x03\x01\x12\x04\x9f\x02\x18#\n\r\n\x05\
    \x04\x10\x02\x03\x03\x12\x04\x9f\x02&'\n\x0c\n\x04\x04\x10\x02\x04\x12\
    \x04\xa0\x02\x088\n\r\n\x05\x04\x10\x02\x04\x04\x12\x04\xa0\x02\x08\x10\
    \n\r\n\x05\x04\x10\x02\x04\x05\x12\x04\xa0\x02\x11\x16\n\r\n\x05\x04\x10\
    \x02\x04\x01\x12\x04\xa0\x02\x173\n\r\n\x05\x04\x10\x02\x04\x03\x12\x04\
    \xa0\x0267\n\x0c\n\x04\x04\x10\x02\x05\x12\x04\xa1\x02\x087\n\r\n\x05\
    \x04\x10\x02\x05\x04\x12\x04\xa1\x02\x08\x10\n\r\n\x05\x04\x10\x02\x05\
    \x05\x12\x04\xa1\x02\x11\x18\n\r\n\x05\x04\x10\x02\x05\x01\x12\x04\xa1\
    \x02\x192\n\r\n\x05\x04\x10\x02\x05\x03\x12\x04\xa1\x0256\n\x0c\n\x02\
    \x04\x11\x12\x06\xa4\x02\0\xb4\x02\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\
    \xa4\x02\x086\n\x0e\n\x04\x04\x11\x04\0\x12\x06\xa5\x02\x08\xaa\x02\t\n\
    \r\n\x05\x04\x11\x04\0\x01\x12\x04\xa5\x02\r\x12\n\x0e\n\x06\x04\x11\x04\
    \0\x02\0\x12\x04\xa6\x02\x10&\n\x0f\n\x07\x04\x11\x04\0\x02\0\x01\x12\
    \x04\xa6\x02\x10!\n\x0f\n\x07\x04\x11\x04\0\x02\0\x02\x12\x04\xa6\x02$%\
    \n\x0e\n\x06\x04\x11\x04\0\x02\x01\x12\x04\xa7\x02\x10$\n\x0f\n\x07\x04\
    \x11\x04\0\x02\x01\x01\x12\x04\xa7\x02\x10\x1f\n\x0f\n\x07\x04\x11\x04\0\
    \x02\x01\x02\x12\x04\xa7\x02\"#\n\x0e\n\x06\x04\x11\x04\0\x02\x02\x12\
    \x04\xa8\x02\x10*\n\x0f\n\x07\x04\x11\x04\0\x02\x02\x01\x12\x04\xa8\x02\
    \x10%\n\x0f\n\x07\x04\x11\x04\0\x02\x02\x02\x12\x04\xa8\x02()\n\x0e\n\
    \x06\x04\x11\x04\0\x02\x03\x12\x04\xa9\x02\x10(\n\x0f\n\x07\x04\x11\x04\
    \0\x02\x03\x01\x12\x04\xa9\x02\x10#\n\x0f\n\x07\x04\x11\x04\0\x02\x03\
    \x02\x12\x04\xa9\x02&'\n\x0c\n\x04\x04\x11\x02\0\x12\x04\xac\x02\x08G\n\
    \r\n\x05\x04\x11\x02\0\x04\x12\x04\xac\x02\x08\x10\n\r\n\x05\x04\x11\x02\
    \0\x06\x12\x04\xac\x02\x114\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xac\x025\
    B\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xac\x02EF\n\x0c\n\x04\x04\x11\x02\
    \x01\x12\x04\xad\x02\x08E\n\r\n\x05\x04\x11\x02\x01\x04\x12\x04\xad\x02\
    \x08\x10\n\r\n\x05\x04\x11\x02\x01\x06\x12\x04\xad\x02\x114\n\r\n\x05\
    \x04\x11\x02\x01\x01\x12\x04\xad\x025@\n\r\n\x05\x04\x11\x02\x01\x03\x12\
    \x04\xad\x02CD\n\x0c\n\x04\x04\x11\x02\x02\x12\x04\xae\x02\x08'\n\r\n\
    \x05\x04\x11\x02\x02\x04\x12\x04\xae\x02\x08\x10\n\r\n\x05\x04\x11\x02\
    \x02\x05\x12\x04\xae\x02\x11\x18\n\r\n\x05\x04\x11\x02\x02\x01\x12\x04\
    \xae\x02\x19\"\n\r\n\x05\x04\x11\x02\x02\x03\x12\x04\xae\x02%&\n\x0c\n\
    \x04\x04\x11\x02\x03\x12\x04\xaf\x02\x08,\n\r\n\x05\x04\x11\x02\x03\x04\
    \x12\x04\xaf\x02\x08\x10\n\r\n\x05\x04\x11\x02\x03\x05\x12\x04\xaf\x02\
    \x11\x18\n\r\n\x05\x04\x11\x02\x03\x01\x12\x04\xaf\x02\x19'\n\r\n\x05\
    \x04\x11\x02\x03\x03\x12\x04\xaf\x02*+\n\x0c\n\x04\x04\x11\x02\x04\x12\
    \x04\xb0\x02\x08\"\n\r\n\x05\x04\x11\x02\x04\x04\x12\x04\xb0\x02\x08\x10\
    \n\r\n\x05\x04\x11\x02\x04\x05\x12\x04\xb0\x02\x11\x17\n\r\n\x05\x04\x11\
    \x02\x04\x01\x12\x04\xb0\x02\x18\x1d\n\r\n\x05\x04\x11\x02\x04\x03\x12\
    \x04\xb0\x02\x20!\n\x0c\n\x04\x04\x11\x02\x05\x12\x04\xb1\x02\x082\n\r\n\
    \x05\x04\x11\x02\x05\x04\x12\x04\xb1\x02\x08\x10\n\r\n\x05\x04\x11\x02\
    \x05\x05\x12\x04\xb1\x02\x11\x18\n\r\n\x05\x04\x11\x02\x05\x01\x12\x04\
    \xb1\x02\x19-\n\r\n\x05\x04\x11\x02\x05\x03\x12\x04\xb1\x0201\n\x0c\n\
    \x04\x04\x11\x02\x06\x12\x04\xb2\x02\x08(\n\r\n\x05\x04\x11\x02\x06\x04\
    \x12\x04\xb2\x02\x08\x10\n\r\n\x05\x04\x11\x02\x06\x05\x12\x04\xb2\x02\
    \x11\x17\n\r\n\x05\x04\x11\x02\x06\x01\x12\x04\xb2\x02\x18#\n\r\n\x05\
    \x04\x11\x02\x06\x03\x12\x04\xb2\x02&'\n\x0c\n\x04\x04\x11\x02\x07\x12\
    \x04\xb3\x02\x08)\n\r\n\x05\x04\x11\x02\x07\x04\x12\x04\xb3\x02\x08\x10\
    \n\r\n\x05\x04\x11\x02\x07\x05\x12\x04\xb3\x02\x11\x17\n\r\n\x05\x04\x11\
    \x02\x07\x01\x12\x04\xb3\x02\x18#\n\r\n\x05\x04\x11\x02\x07\x03\x12\x04\
    \xb3\x02&(\n\x0c\n\x02\x04\x12\x12\x06\xb6\x02\0\xc9\x02\x01\n\x0b\n\x03\
    \x04\x12\x01\x12\x04\xb6\x02\x086\n\x0e\n\x04\x04\x12\x04\0\x12\x06\xb7\
    \x02\x08\xbb\x02\t\n\r\n\x05\x04\x12\x04\0\x01\x12\x04\xb7\x02\r\x12\n\
    \x0e\n\x06\x04\x12\x04\0\x02\0\x12\x04\xb8\x02\x10&\n\x0f\n\x07\x04\x12\
    \x04\0\x02\0\x01\x12\x04\xb8\x02\x10!\n\x0f\n\x07\x04\x12\x04\0\x02\0\
    \x02\x12\x04\xb8\x02$%\n\x0e\n\x06\x04\x12\x04\0\x02\x01\x12\x04\xb9\x02\
    \x10$\n\x0f\n\x07\x04\x12\x04\0\x02\x01\x01\x12\x04\xb9\x02\x10\x1f\n\
    \x0f\n\x07\x04\x12\x04\0\x02\x01\x02\x12\x04\xb9\x02\"#\n\x0e\n\x06\x04\
    \x12\x04\0\x02\x02\x12\x04\xba\x02\x10*\n\x0f\n\x07\x04\x12\x04\0\x02\
    \x02\x01\x12\x04\xba\x02\x10%\n\x0f\n\x07\x04\x12\x04\0\x02\x02\x02\x12\
    \x04\xba\x02()\n\x0c\n\x04\x04\x12\x02\0\x12\x04\xbd\x02\x08G\n\r\n\x05\
    \x04\x12\x02\0\x04\x12\x04\xbd\x02\x08\x10\n\r\n\x05\x04\x12\x02\0\x06\
    \x12\x04\xbd\x02\x114\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xbd\x025B\n\r\
    \n\x05\x04\x12\x02\0\x03\x12\x04\xbd\x02EF\n\x0c\n\x04\x04\x12\x02\x01\
    \x12\x04\xbe\x02\x08E\n\r\n\x05\x04\x12\x02\x01\x04\x12\x04\xbe\x02\x08\
    \x10\n\r\n\x05\x04\x12\x02\x01\x06\x12\x04\xbe\x02\x114\n\r\n\x05\x04\
    \x12\x02\x01\x01\x12\x04\xbe\x025@\n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\
    \xbe\x02CD\n\x0c\n\x04\x04\x12\x02\x02\x12\x04\xbf\x02\x083\n\r\n\x05\
    \x04\x12\x02\x02\x04\x12\x04\xbf\x02\x08\x10\n\r\n\x05\x04\x12\x02\x02\
    \x05\x12\x04\xbf\x02\x11\x17\n\r\n\x05\x04\x12\x02\x02\x01\x12\x04\xbf\
    \x02\x18.\n\r\n\x05\x04\x12\x02\x02\x03\x12\x04\xbf\x0212\n\x0c\n\x04\
    \x04\x12\x02\x03\x12\x04\xc0\x02\x081\n\r\n\x05\x04\x12\x02\x03\x04\x12\
    \x04\xc0\x02\x08\x10\n\r\n\x05\x04\x12\x02\x03\x05\x12\x04\xc0\x02\x11\
    \x18\n\r\n\x05\x04\x12\x02\x03\x01\x12\x04\xc0\x02\x19+\n\r\n\x05\x04\
    \x12\x02\x03\x03\x12\x04\xc0\x02.0\n\x0c\n\x04\x04\x12\x02\x04\x12\x04\
    \xc1\x02\x082\n\r\n\x05\x04\x12\x02\x04\x04\x12\x04\xc1\x02\x08\x10\n\r\
    \n\x05\x04\x12\x02\x04\x05\x12\x04\xc1\x02\x11\x17\n\r\n\x05\x04\x12\x02\
    \x04\x01\x12\x04\xc1\x02\x18,\n\r\n\x05\x04\x12\x02\x04\x03\x12\x04\xc1\
    \x02/1\n\x0c\n\x04\x04\x12\x02\x05\x12\x04\xc2\x02\x08;\n\r\n\x05\x04\
    \x12\x02\x05\x04\x12\x04\xc2\x02\x08\x10\n\r\n\x05\x04\x12\x02\x05\x05\
    \x12\x04\xc2\x02\x11\x17\n\r\n\x05\x04\x12\x02\x05\x01\x12\x04\xc2\x02\
    \x185\n\r\n\x05\x04\x12\x02\x05\x03\x12\x04\xc2\x028:\n\x0c\n\x04\x04\
    \x12\x02\x06\x12\x04\xc3\x02\x08(\n\r\n\x05\x04\x12\x02\x06\x04\x12\x04\
    \xc3\x02\x08\x10\n\r\n\x05\x04\x12\x02\x06\x05\x12\x04\xc3\x02\x11\x18\n\
    \r\n\x05\x04\x12\x02\x06\x01\x12\x04\xc3\x02\x19\"\n\r\n\x05\x04\x12\x02\
    \x06\x03\x12\x04\xc3\x02%'\n\x0c\n\x04\x04\x12\x02\x07\x12\x04\xc4\x02\
    \x08-\n\r\n\x05\x04\x12\x02\x07\x04\x12\x04\xc4\x02\x08\x10\n\r\n\x05\
    \x04\x12\x02\x07\x05\x12\x04\xc4\x02\x11\x18\n\r\n\x05\x04\x12\x02\x07\
    \x01\x12\x04\xc4\x02\x19'\n\r\n\x05\x04\x12\x02\x07\x03\x12\x04\xc4\x02*\
    ,\n\x0c\n\x04\x04\x12\x02\x08\x12\x04\xc5\x02\x08#\n\r\n\x05\x04\x12\x02\
    \x08\x04\x12\x04\xc5\x02\x08\x10\n\r\n\x05\x04\x12\x02\x08\x05\x12\x04\
    \xc5\x02\x11\x17\n\r\n\x05\x04\x12\x02\x08\x01\x12\x04\xc5\x02\x18\x1d\n\
    \r\n\x05\x04\x12\x02\x08\x03\x12\x04\xc5\x02\x20\"\n\x0c\n\x04\x04\x12\
    \x02\t\x12\x04\xc6\x02\x082\n\r\n\x05\x04\x12\x02\t\x04\x12\x04\xc6\x02\
    \x08\x10\n\r\n\x05\x04\x12\x02\t\x05\x12\x04\xc6\x02\x11\x18\n\r\n\x05\
    \x04\x12\x02\t\x01\x12\x04\xc6\x02\x19-\n\r\n\x05\x04\x12\x02\t\x03\x12\
    \x04\xc6\x0201\n\x0c\n\x04\x04\x12\x02\n\x12\x04\xc7\x02\x08(\n\r\n\x05\
    \x04\x12\x02\n\x04\x12\x04\xc7\x02\x08\x10\n\r\n\x05\x04\x12\x02\n\x05\
    \x12\x04\xc7\x02\x11\x17\n\r\n\x05\x04\x12\x02\n\x01\x12\x04\xc7\x02\x18\
    #\n\r\n\x05\x04\x12\x02\n\x03\x12\x04\xc7\x02&'\n\x0c\n\x04\x04\x12\x02\
    \x0b\x12\x04\xc8\x02\x08(\n\r\n\x05\x04\x12\x02\x0b\x04\x12\x04\xc8\x02\
    \x08\x10\n\r\n\x05\x04\x12\x02\x0b\x05\x12\x04\xc8\x02\x11\x17\n\r\n\x05\
    \x04\x12\x02\x0b\x01\x12\x04\xc8\x02\x18#\n\r\n\x05\x04\x12\x02\x0b\x03\
    \x12\x04\xc8\x02&'\n\x0c\n\x02\x04\x13\x12\x06\xcb\x02\0\xdf\x02\x01\n\
    \x0b\n\x03\x04\x13\x01\x12\x04\xcb\x02\x086\n\x0e\n\x04\x04\x13\x04\0\
    \x12\x06\xcc\x02\x08\xd0\x02\t\n\r\n\x05\x04\x13\x04\0\x01\x12\x04\xcc\
    \x02\r\x12\n\x0e\n\x06\x04\x13\x04\0\x02\0\x12\x04\xcd\x02\x10&\n\x0f\n\
    \x07\x04\x13\x04\0\x02\0\x01\x12\x04\xcd\x02\x10!\n\x0f\n\x07\x04\x13\
    \x04\0\x02\0\x02\x12\x04\xcd\x02$%\n\x0e\n\x06\x04\x13\x04\0\x02\x01\x12\
    \x04\xce\x02\x10$\n\x0f\n\x07\x04\x13\x04\0\x02\x01\x01\x12\x04\xce\x02\
    \x10\x1f\n\x0f\n\x07\x04\x13\x04\0\x02\x01\x02\x12\x04\xce\x02\"#\n\x0e\
    \n\x06\x04\x13\x04\0\x02\x02\x12\x04\xcf\x02\x10*\n\x0f\n\x07\x04\x13\
    \x04\0\x02\x02\x01\x12\x04\xcf\x02\x10%\n\x0f\n\x07\x04\x13\x04\0\x02\
    \x02\x02\x12\x04\xcf\x02()\n\x0c\n\x04\x04\x13\x02\0\x12\x04\xd2\x02\x08\
    G\n\r\n\x05\x04\x13\x02\0\x04\x12\x04\xd2\x02\x08\x10\n\r\n\x05\x04\x13\
    \x02\0\x06\x12\x04\xd2\x02\x114\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\xd2\
    \x025B\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xd2\x02EF\n\x0c\n\x04\x04\x13\
    \x02\x01\x12\x04\xd3\x02\x08E\n\r\n\x05\x04\x13\x02\x01\x04\x12\x04\xd3\
    \x02\x08\x10\n\r\n\x05\x04\x13\x02\x01\x06\x12\x04\xd3\x02\x114\n\r\n\
    \x05\x04\x13\x02\x01\x01\x12\x04\xd3\x025@\n\r\n\x05\x04\x13\x02\x01\x03\
    \x12\x04\xd3\x02CD\n\x0c\n\x04\x04\x13\x02\x02\x12\x04\xd4\x02\x08(\n\r\
    \n\x05\x04\x13\x02\x02\x04\x12\x04\xd4\x02\x08\x10\n\r\n\x05\x04\x13\x02\
    \x02\x05\x12\x04\xd4\x02\x11\x18\n\r\n\x05\x04\x13\x02\x02\x01\x12\x04\
    \xd4\x02\x19\"\n\r\n\x05\x04\x13\x02\x02\x03\x12\x04\xd4\x02%'\n\x0c\n\
    \x04\x04\x13\x02\x03\x12\x04\xd5\x02\x08-\n\r\n\x05\x04\x13\x02\x03\x04\
    \x12\x04\xd5\x02\x08\x10\n\r\n\x05\x04\x13\x02\x03\x05\x12\x04\xd5\x02\
    \x11\x18\n\r\n\x05\x04\x13\x02\x03\x01\x12\x04\xd5\x02\x19'\n\r\n\x05\
    \x04\x13\x02\x03\x03\x12\x04\xd5\x02*,\n\x0c\n\x04\x04\x13\x02\x04\x12\
    \x04\xd6\x02\x08#\n\r\n\x05\x04\x13\x02\x04\x04\x12\x04\xd6\x02\x08\x10\
    \n\r\n\x05\x04\x13\x02\x04\x05\x12\x04\xd6\x02\x11\x17\n\r\n\x05\x04\x13\
    \x02\x04\x01\x12\x04\xd6\x02\x18\x1d\n\r\n\x05\x04\x13\x02\x04\x03\x12\
    \x04\xd6\x02\x20\"\n\x0c\n\x04\x04\x13\x02\x05\x12\x04\xd7\x02\x08(\n\r\
    \n\x05\x04\x13\x02\x05\x04\x12\x04\xd7\x02\x08\x10\n\r\n\x05\x04\x13\x02\
    \x05\x05\x12\x04\xd7\x02\x11\x17\n\r\n\x05\x04\x13\x02\x05\x01\x12\x04\
    \xd7\x02\x18#\n\r\n\x05\x04\x13\x02\x05\x03\x12\x04\xd7\x02&'\n\x0c\n\
    \x04\x04\x13\x02\x06\x12\x04\xd8\x02\x08(\n\r\n\x05\x04\x13\x02\x06\x04\
    \x12\x04\xd8\x02\x08\x10\n\r\n\x05\x04\x13\x02\x06\x05\x12\x04\xd8\x02\
    \x11\x17\n\r\n\x05\x04\x13\x02\x06\x01\x12\x04\xd8\x02\x18#\n\r\n\x05\
    \x04\x13\x02\x06\x03\x12\x04\xd8\x02&'\n\x0c\n\x04\x04\x13\x02\x07\x12\
    \x04\xd9\x02\x084\n\r\n\x05\x04\x13\x02\x07\x04\x12\x04\xd9\x02\x08\x10\
    \n\r\n\x05\x04\x13\x02\x07\x05\x12\x04\xd9\x02\x11\x17\n\r\n\x05\x04\x13\
    \x02\x07\x01\x12\x04\xd9\x02\x18.\n\r\n\x05\x04\x13\x02\x07\x03\x12\x04\
    \xd9\x0213\n\x0c\n\x04\x04\x13\x02\x08\x12\x04\xda\x02\x084\n\r\n\x05\
    \x04\x13\x02\x08\x04\x12\x04\xda\x02\x08\x10\n\r\n\x05\x04\x13\x02\x08\
    \x05\x12\x04\xda\x02\x11\x18\n\r\n\x05\x04\x13\x02\x08\x01\x12\x04\xda\
    \x02\x19/\n\r\n\x05\x04\x13\x02\x08\x03\x12\x04\xda\x0223\n\x0c\n\x04\
    \x04\x13\x02\t\x12\x04\xdb\x02\x08-\n\r\n\x05\x04\x13\x02\t\x04\x12\x04\
    \xdb\x02\x08\x10\n\r\n\x05\x04\x13\x02\t\x05\x12\x04\xdb\x02\x11\x17\n\r\
    \n\x05\x04\x13\x02\t\x01\x12\x04\xdb\x02\x18(\n\r\n\x05\x04\x13\x02\t\
    \x03\x12\x04\xdb\x02+,\n\x0c\n\x04\x04\x13\x02\n\x12\x04\xdc\x02\x082\n\
    \r\n\x05\x04\x13\x02\n\x04\x12\x04\xdc\x02\x08\x10\n\r\n\x05\x04\x13\x02\
    \n\x05\x12\x04\xdc\x02\x11\x18\n\r\n\x05\x04\x13\x02\n\x01\x12\x04\xdc\
    \x02\x19-\n\r\n\x05\x04\x13\x02\n\x03\x12\x04\xdc\x0201\n\x0c\n\x04\x04\
    \x13\x02\x0b\x12\x04\xdd\x02\x083\n\r\n\x05\x04\x13\x02\x0b\x04\x12\x04\
    \xdd\x02\x08\x10\n\r\n\x05\x04\x13\x02\x0b\x05\x12\x04\xdd\x02\x11\x18\n\
    \r\n\x05\x04\x13\x02\x0b\x01\x12\x04\xdd\x02\x19-\n\r\n\x05\x04\x13\x02\
    \x0b\x03\x12\x04\xdd\x0202\n\x0c\n\x04\x04\x13\x02\x0c\x12\x04\xde\x02\
    \x08-\n\r\n\x05\x04\x13\x02\x0c\x04\x12\x04\xde\x02\x08\x10\n\r\n\x05\
    \x04\x13\x02\x0c\x05\x12\x04\xde\x02\x11\x18\n\r\n\x05\x04\x13\x02\x0c\
    \x01\x12\x04\xde\x02\x19'\n\r\n\x05\x04\x13\x02\x0c\x03\x12\x04\xde\x02*\
    ,\n\x0c\n\x02\x04\x14\x12\x06\xe1\x02\0\xf2\x02\x01\n\x0b\n\x03\x04\x14\
    \x01\x12\x04\xe1\x02\x086\n\x0e\n\x04\x04\x14\x04\0\x12\x06\xe2\x02\x08\
    \xe6\x02\t\n\r\n\x05\x04\x14\x04\0\x01\x12\x04\xe2\x02\r\x12\n\x0e\n\x06\
    \x04\x14\x04\0\x02\0\x12\x04\xe3\x02\x10&\n\x0f\n\x07\x04\x14\x04\0\x02\
    \0\x01\x12\x04\xe3\x02\x10!\n\x0f\n\x07\x04\x14\x04\0\x02\0\x02\x12\x04\
    \xe3\x02$%\n\x0e\n\x06\x04\x14\x04\0\x02\x01\x12\x04\xe4\x02\x10$\n\x0f\
    \n\x07\x04\x14\x04\0\x02\x01\x01\x12\x04\xe4\x02\x10\x1f\n\x0f\n\x07\x04\
    \x14\x04\0\x02\x01\x02\x12\x04\xe4\x02\"#\n\x0e\n\x06\x04\x14\x04\0\x02\
    \x02\x12\x04\xe5\x02\x10*\n\x0f\n\x07\x04\x14\x04\0\x02\x02\x01\x12\x04\
    \xe5\x02\x10%\n\x0f\n\x07\x04\x14\x04\0\x02\x02\x02\x12\x04\xe5\x02()\n\
    \x0c\n\x04\x04\x14\x02\0\x12\x04\xe8\x02\x08G\n\r\n\x05\x04\x14\x02\0\
    \x04\x12\x04\xe8\x02\x08\x10\n\r\n\x05\x04\x14\x02\0\x06\x12\x04\xe8\x02\
    \x114\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\xe8\x025B\n\r\n\x05\x04\x14\
    \x02\0\x03\x12\x04\xe8\x02EF\n\x0c\n\x04\x04\x14\x02\x01\x12\x04\xe9\x02\
    \x08E\n\r\n\x05\x04\x14\x02\x01\x04\x12\x04\xe9\x02\x08\x10\n\r\n\x05\
    \x04\x14\x02\x01\x06\x12\x04\xe9\x02\x114\n\r\n\x05\x04\x14\x02\x01\x01\
    \x12\x04\xe9\x025@\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\xe9\x02CD\n\x0c\
    \n\x04\x04\x14\x02\x02\x12\x04\xea\x02\x08'\n\r\n\x05\x04\x14\x02\x02\
    \x04\x12\x04\xea\x02\x08\x10\n\r\n\x05\x04\x14\x02\x02\x05\x12\x04\xea\
    \x02\x11\x18\n\r\n\x05\x04\x14\x02\x02\x01\x12\x04\xea\x02\x19\"\n\r\n\
    \x05\x04\x14\x02\x02\x03\x12\x04\xea\x02%&\n\x0c\n\x04\x04\x14\x02\x03\
    \x12\x04\xeb\x02\x08,\n\r\n\x05\x04\x14\x02\x03\x04\x12\x04\xeb\x02\x08\
    \x10\n\r\n\x05\x04\x14\x02\x03\x05\x12\x04\xeb\x02\x11\x18\n\r\n\x05\x04\
    \x14\x02\x03\x01\x12\x04\xeb\x02\x19'\n\r\n\x05\x04\x14\x02\x03\x03\x12\
    \x04\xeb\x02*+\n\x0c\n\x04\x04\x14\x02\x04\x12\x04\xec\x02\x08#\n\r\n\
    \x05\x04\x14\x02\x04\x04\x12\x04\xec\x02\x08\x10\n\r\n\x05\x04\x14\x02\
    \x04\x05\x12\x04\xec\x02\x11\x17\n\r\n\x05\x04\x14\x02\x04\x01\x12\x04\
    \xec\x02\x18\x1d\n\r\n\x05\x04\x14\x02\x04\x03\x12\x04\xec\x02\x20\"\n\
    \x0c\n\x04\x04\x14\x02\x05\x12\x04\xed\x02\x08(\n\r\n\x05\x04\x14\x02\
    \x05\x04\x12\x04\xed\x02\x08\x10\n\r\n\x05\x04\x14\x02\x05\x05\x12\x04\
    \xed\x02\x11\x17\n\r\n\x05\x04\x14\x02\x05\x01\x12\x04\xed\x02\x18#\n\r\
    \n\x05\x04\x14\x02\x05\x03\x12\x04\xed\x02&'\n\x0c\n\x04\x04\x14\x02\x06\
    \x12\x04\xee\x02\x08(\n\r\n\x05\x04\x14\x02\x06\x04\x12\x04\xee\x02\x08\
    \x10\n\r\n\x05\x04\x14\x02\x06\x05\x12\x04\xee\x02\x11\x17\n\r\n\x05\x04\
    \x14\x02\x06\x01\x12\x04\xee\x02\x18#\n\r\n\x05\x04\x14\x02\x06\x03\x12\
    \x04\xee\x02&'\n\x0c\n\x04\x04\x14\x02\x07\x12\x04\xef\x02\x08-\n\r\n\
    \x05\x04\x14\x02\x07\x04\x12\x04\xef\x02\x08\x10\n\r\n\x05\x04\x14\x02\
    \x07\x05\x12\x04\xef\x02\x11\x17\n\r\n\x05\x04\x14\x02\x07\x01\x12\x04\
    \xef\x02\x18(\n\r\n\x05\x04\x14\x02\x07\x03\x12\x04\xef\x02+,\n\x0c\n\
    \x04\x04\x14\x02\x08\x12\x04\xf0\x02\x082\n\r\n\x05\x04\x14\x02\x08\x04\
    \x12\x04\xf0\x02\x08\x10\n\r\n\x05\x04\x14\x02\x08\x05\x12\x04\xf0\x02\
    \x11\x18\n\r\n\x05\x04\x14\x02\x08\x01\x12\x04\xf0\x02\x19-\n\r\n\x05\
    \x04\x14\x02\x08\x03\x12\x04\xf0\x0201\n\x0c\n\x04\x04\x14\x02\t\x12\x04\
    \xf1\x02\x083\n\r\n\x05\x04\x14\x02\t\x04\x12\x04\xf1\x02\x08\x10\n\r\n\
    \x05\x04\x14\x02\t\x05\x12\x04\xf1\x02\x11\x18\n\r\n\x05\x04\x14\x02\t\
    \x01\x12\x04\xf1\x02\x19-\n\r\n\x05\x04\x14\x02\t\x03\x12\x04\xf1\x0202\
    \n\x0c\n\x02\x04\x15\x12\x06\xf4\x02\0\x80\x03\x01\n\x0b\n\x03\x04\x15\
    \x01\x12\x04\xf4\x02\x08.\n\x0c\n\x04\x04\x15\x02\0\x12\x04\xf5\x02\x08,\
    \n\r\n\x05\x04\x15\x02\0\x04\x12\x04\xf5\x02\x08\x10\n\r\n\x05\x04\x15\
    \x02\0\x05\x12\x04\xf5\x02\x11\x18\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\
    \xf5\x02\x19'\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\xf5\x02*+\n\x0c\n\x04\
    \x04\x15\x02\x01\x12\x04\xf6\x02\x08'\n\r\n\x05\x04\x15\x02\x01\x04\x12\
    \x04\xf6\x02\x08\x10\n\r\n\x05\x04\x15\x02\x01\x05\x12\x04\xf6\x02\x11\
    \x18\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\xf6\x02\x19\"\n\r\n\x05\x04\
    \x15\x02\x01\x03\x12\x04\xf6\x02%&\n\x0c\n\x04\x04\x15\x02\x02\x12\x04\
    \xf7\x02\x082\n\r\n\x05\x04\x15\x02\x02\x04\x12\x04\xf7\x02\x08\x10\n\r\
    \n\x05\x04\x15\x02\x02\x05\x12\x04\xf7\x02\x11\x18\n\r\n\x05\x04\x15\x02\
    \x02\x01\x12\x04\xf7\x02\x19-\n\r\n\x05\x04\x15\x02\x02\x03\x12\x04\xf7\
    \x0201\n\x0c\n\x04\x04\x15\x02\x03\x12\x04\xf8\x02\x082\n\r\n\x05\x04\
    \x15\x02\x03\x04\x12\x04\xf8\x02\x08\x10\n\r\n\x05\x04\x15\x02\x03\x05\
    \x12\x04\xf8\x02\x11\x18\n\r\n\x05\x04\x15\x02\x03\x01\x12\x04\xf8\x02\
    \x19-\n\r\n\x05\x04\x15\x02\x03\x03\x12\x04\xf8\x0201\n\x0c\n\x04\x04\
    \x15\x02\x04\x12\x04\xf9\x02\x082\n\r\n\x05\x04\x15\x02\x04\x04\x12\x04\
    \xf9\x02\x08\x10\n\r\n\x05\x04\x15\x02\x04\x05\x12\x04\xf9\x02\x11\x17\n\
    \r\n\x05\x04\x15\x02\x04\x01\x12\x04\xf9\x02\x18,\n\r\n\x05\x04\x15\x02\
    \x04\x03\x12\x04\xf9\x02/1\n\x0c\n\x04\x04\x15\x02\x05\x12\x04\xfa\x02\
    \x080\n\r\n\x05\x04\x15\x02\x05\x04\x12\x04\xfa\x02\x08\x10\n\r\n\x05\
    \x04\x15\x02\x05\x05\x12\x04\xfa\x02\x11\x18\n\r\n\x05\x04\x15\x02\x05\
    \x01\x12\x04\xfa\x02\x19+\n\r\n\x05\x04\x15\x02\x05\x03\x12\x04\xfa\x02.\
    /\n\x0c\n\x04\x04\x15\x02\x06\x12\x04\xfb\x02\x08-\n\r\n\x05\x04\x15\x02\
    \x06\x04\x12\x04\xfb\x02\x08\x10\n\r\n\x05\x04\x15\x02\x06\x05\x12\x04\
    \xfb\x02\x11\x17\n\r\n\x05\x04\x15\x02\x06\x01\x12\x04\xfb\x02\x18(\n\r\
    \n\x05\x04\x15\x02\x06\x03\x12\x04\xfb\x02+,\n\x0c\n\x04\x04\x15\x02\x07\
    \x12\x04\xfc\x02\x083\n\r\n\x05\x04\x15\x02\x07\x04\x12\x04\xfc\x02\x08\
    \x10\n\r\n\x05\x04\x15\x02\x07\x05\x12\x04\xfc\x02\x11\x17\n\r\n\x05\x04\
    \x15\x02\x07\x01\x12\x04\xfc\x02\x18.\n\r\n\x05\x04\x15\x02\x07\x03\x12\
    \x04\xfc\x0212\n\x0c\n\x04\x04\x15\x02\x08\x12\x04\xfd\x02\x08/\n\r\n\
    \x05\x04\x15\x02\x08\x04\x12\x04\xfd\x02\x08\x10\n\r\n\x05\x04\x15\x02\
    \x08\x05\x12\x04\xfd\x02\x11\x18\n\r\n\x05\x04\x15\x02\x08\x01\x12\x04\
    \xfd\x02\x19)\n\r\n\x05\x04\x15\x02\x08\x03\x12\x04\xfd\x02,.\n\x0c\n\
    \x04\x04\x15\x02\t\x12\x04\xfe\x02\x08&\n\r\n\x05\x04\x15\x02\t\x04\x12\
    \x04\xfe\x02\x08\x10\n\r\n\x05\x04\x15\x02\t\x05\x12\x04\xfe\x02\x11\x17\
    \n\r\n\x05\x04\x15\x02\t\x01\x12\x04\xfe\x02\x18\x20\n\r\n\x05\x04\x15\
    \x02\t\x03\x12\x04\xfe\x02#%\n\x0c\n\x04\x04\x15\x02\n\x12\x04\xff\x02\
    \x08#\n\r\n\x05\x04\x15\x02\n\x04\x12\x04\xff\x02\x08\x10\n\r\n\x05\x04\
    \x15\x02\n\x05\x12\x04\xff\x02\x11\x17\n\r\n\x05\x04\x15\x02\n\x01\x12\
    \x04\xff\x02\x18\x1d\n\r\n\x05\x04\x15\x02\n\x03\x12\x04\xff\x02\x20\"\n\
    \x0c\n\x02\x04\x16\x12\x06\x82\x03\0\x86\x03\x01\n\x0b\n\x03\x04\x16\x01\
    \x12\x04\x82\x03\x08*\n\x0c\n\x04\x04\x16\x02\0\x12\x04\x83\x03\x08>\n\r\
    \n\x05\x04\x16\x02\0\x04\x12\x04\x83\x03\x08\x10\n\r\n\x05\x04\x16\x02\0\
    \x06\x12\x04\x83\x03\x114\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\x83\x0359\
    \n\r\n\x05\x04\x16\x02\0\x03\x12\x04\x83\x03<=\n\x0c\n\x04\x04\x16\x02\
    \x01\x12\x04\x84\x03\x08\x20\n\r\n\x05\x04\x16\x02\x01\x04\x12\x04\x84\
    \x03\x08\x10\n\r\n\x05\x04\x16\x02\x01\x05\x12\x04\x84\x03\x11\x16\n\r\n\
    \x05\x04\x16\x02\x01\x01\x12\x04\x84\x03\x17\x1b\n\r\n\x05\x04\x16\x02\
    \x01\x03\x12\x04\x84\x03\x1e\x1f\n\x0c\n\x04\x04\x16\x02\x02\x12\x04\x85\
    \x03\x08%\n\r\n\x05\x04\x16\x02\x02\x04\x12\x04\x85\x03\x08\x10\n\r\n\
    \x05\x04\x16\x02\x02\x05\x12\x04\x85\x03\x11\x16\n\r\n\x05\x04\x16\x02\
    \x02\x01\x12\x04\x85\x03\x17\x20\n\r\n\x05\x04\x16\x02\x02\x03\x12\x04\
    \x85\x03#$\n\x0c\n\x02\x04\x17\x12\x06\x88\x03\0\x8d\x03\x01\n\x0b\n\x03\
    \x04\x17\x01\x12\x04\x88\x03\x08.\n\x0c\n\x04\x04\x17\x02\0\x12\x04\x89\
    \x03\x08+\n\r\n\x05\x04\x17\x02\0\x04\x12\x04\x89\x03\x08\x10\n\r\n\x05\
    \x04\x17\x02\0\x05\x12\x04\x89\x03\x11\x18\n\r\n\x05\x04\x17\x02\0\x01\
    \x12\x04\x89\x03\x19&\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\x89\x03)*\n\
    \x0c\n\x04\x04\x17\x02\x01\x12\x04\x8a\x03\x083\n\r\n\x05\x04\x17\x02\
    \x01\x04\x12\x04\x8a\x03\x08\x10\n\r\n\x05\x04\x17\x02\x01\x05\x12\x04\
    \x8a\x03\x11\x17\n\r\n\x05\x04\x17\x02\x01\x01\x12\x04\x8a\x03\x18.\n\r\
    \n\x05\x04\x17\x02\x01\x03\x12\x04\x8a\x0312\n\x0c\n\x04\x04\x17\x02\x02\
    \x12\x04\x8b\x03\x08/\n\r\n\x05\x04\x17\x02\x02\x04\x12\x04\x8b\x03\x08\
    \x10\n\r\n\x05\x04\x17\x02\x02\x05\x12\x04\x8b\x03\x11\x16\n\r\n\x05\x04\
    \x17\x02\x02\x01\x12\x04\x8b\x03\x17*\n\r\n\x05\x04\x17\x02\x02\x03\x12\
    \x04\x8b\x03-.\n\x0c\n\x04\x04\x17\x02\x03\x12\x04\x8c\x03\x08(\n\r\n\
    \x05\x04\x17\x02\x03\x04\x12\x04\x8c\x03\x08\x10\n\r\n\x05\x04\x17\x02\
    \x03\x05\x12\x04\x8c\x03\x11\x17\n\r\n\x05\x04\x17\x02\x03\x01\x12\x04\
    \x8c\x03\x18#\n\r\n\x05\x04\x17\x02\x03\x03\x12\x04\x8c\x03&'\n\x0c\n\
    \x02\x04\x18\x12\x06\x8f\x03\0\xa5\x03\x01\n\x0b\n\x03\x04\x18\x01\x12\
    \x04\x8f\x03\x089\n\x0e\n\x04\x04\x18\x04\0\x12\x06\x90\x03\x08\x96\x03\
    \t\n\r\n\x05\x04\x18\x04\0\x01\x12\x04\x90\x03\r\x12\n\x0e\n\x06\x04\x18\
    \x04\0\x02\0\x12\x04\x91\x03\x10&\n\x0f\n\x07\x04\x18\x04\0\x02\0\x01\
    \x12\x04\x91\x03\x10!\n\x0f\n\x07\x04\x18\x04\0\x02\0\x02\x12\x04\x91\
    \x03$%\n\x0e\n\x06\x04\x18\x04\0\x02\x01\x12\x04\x92\x03\x10$\n\x0f\n\
    \x07\x04\x18\x04\0\x02\x01\x01\x12\x04\x92\x03\x10\x1f\n\x0f\n\x07\x04\
    \x18\x04\0\x02\x01\x02\x12\x04\x92\x03\"#\n\x0e\n\x06\x04\x18\x04\0\x02\
    \x02\x12\x04\x93\x03\x10*\n\x0f\n\x07\x04\x18\x04\0\x02\x02\x01\x12\x04\
    \x93\x03\x10%\n\x0f\n\x07\x04\x18\x04\0\x02\x02\x02\x12\x04\x93\x03()\n\
    \x0e\n\x06\x04\x18\x04\0\x02\x03\x12\x04\x94\x03\x10(\n\x0f\n\x07\x04\
    \x18\x04\0\x02\x03\x01\x12\x04\x94\x03\x10#\n\x0f\n\x07\x04\x18\x04\0\
    \x02\x03\x02\x12\x04\x94\x03&'\n\x0e\n\x06\x04\x18\x04\0\x02\x04\x12\x04\
    \x95\x03\x10/\n\x0f\n\x07\x04\x18\x04\0\x02\x04\x01\x12\x04\x95\x03\x10)\
    \n\x0f\n\x07\x04\x18\x04\0\x02\x04\x02\x12\x04\x95\x03,.\n\x0c\n\x04\x04\
    \x18\x02\0\x12\x04\x98\x03\x08G\n\r\n\x05\x04\x18\x02\0\x04\x12\x04\x98\
    \x03\x08\x10\n\r\n\x05\x04\x18\x02\0\x06\x12\x04\x98\x03\x114\n\r\n\x05\
    \x04\x18\x02\0\x01\x12\x04\x98\x035B\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\
    \x98\x03EF\n\x0c\n\x04\x04\x18\x02\x01\x12\x04\x99\x03\x08E\n\r\n\x05\
    \x04\x18\x02\x01\x04\x12\x04\x99\x03\x08\x10\n\r\n\x05\x04\x18\x02\x01\
    \x06\x12\x04\x99\x03\x114\n\r\n\x05\x04\x18\x02\x01\x01\x12\x04\x99\x035\
    @\n\r\n\x05\x04\x18\x02\x01\x03\x12\x04\x99\x03CD\n\x0c\n\x04\x04\x18\
    \x02\x02\x12\x04\x9a\x03\x08N\n\r\n\x05\x04\x18\x02\x02\x04\x12\x04\x9a\
    \x03\x08\x10\n\r\n\x05\x04\x18\x02\x02\x06\x12\x04\x9a\x03\x114\n\r\n\
    \x05\x04\x18\x02\x02\x01\x12\x04\x9a\x035H\n\r\n\x05\x04\x18\x02\x02\x03\
    \x12\x04\x9a\x03KM\n\x0c\n\x04\x04\x18\x02\x03\x12\x04\x9b\x03\x08'\n\r\
    \n\x05\x04\x18\x02\x03\x04\x12\x04\x9b\x03\x08\x10\n\r\n\x05\x04\x18\x02\
    \x03\x05\x12\x04\x9b\x03\x11\x18\n\r\n\x05\x04\x18\x02\x03\x01\x12\x04\
    \x9b\x03\x19\"\n\r\n\x05\x04\x18\x02\x03\x03\x12\x04\x9b\x03%&\n\x0c\n\
    \x04\x04\x18\x02\x04\x12\x04\x9c\x03\x08,\n\r\n\x05\x04\x18\x02\x04\x04\
    \x12\x04\x9c\x03\x08\x10\n\r\n\x05\x04\x18\x02\x04\x05\x12\x04\x9c\x03\
    \x11\x18\n\r\n\x05\x04\x18\x02\x04\x01\x12\x04\x9c\x03\x19'\n\r\n\x05\
    \x04\x18\x02\x04\x03\x12\x04\x9c\x03*+\n\x0c\n\x04\x04\x18\x02\x05\x12\
    \x04\x9d\x03\x08\"\n\r\n\x05\x04\x18\x02\x05\x04\x12\x04\x9d\x03\x08\x10\
    \n\r\n\x05\x04\x18\x02\x05\x05\x12\x04\x9d\x03\x11\x17\n\r\n\x05\x04\x18\
    \x02\x05\x01\x12\x04\x9d\x03\x18\x1d\n\r\n\x05\x04\x18\x02\x05\x03\x12\
    \x04\x9d\x03\x20!\n\x0c\n\x04\x04\x18\x02\x06\x12\x04\x9e\x03\x08>\n\r\n\
    \x05\x04\x18\x02\x06\x04\x12\x04\x9e\x03\x08\x10\n\r\n\x05\x04\x18\x02\
    \x06\x05\x12\x04\x9e\x03\x11\x16\n\r\n\x05\x04\x18\x02\x06\x01\x12\x04\
    \x9e\x03\x179\n\r\n\x05\x04\x18\x02\x06\x03\x12\x04\x9e\x03<=\n\x0c\n\
    \x04\x04\x18\x02\x07\x12\x04\x9f\x03\x084\n\r\n\x05\x04\x18\x02\x07\x04\
    \x12\x04\x9f\x03\x08\x10\n\r\n\x05\x04\x18\x02\x07\x05\x12\x04\x9f\x03\
    \x11\x17\n\r\n\x05\x04\x18\x02\x07\x01\x12\x04\x9f\x03\x18/\n\r\n\x05\
    \x04\x18\x02\x07\x03\x12\x04\x9f\x0323\n\x0c\n\x04\x04\x18\x02\x08\x12\
    \x04\xa0\x03\x08\"\n\r\n\x05\x04\x18\x02\x08\x04\x12\x04\xa0\x03\x08\x10\
    \n\r\n\x05\x04\x18\x02\x08\x05\x12\x04\xa0\x03\x11\x16\n\r\n\x05\x04\x18\
    \x02\x08\x01\x12\x04\xa0\x03\x17\x1d\n\r\n\x05\x04\x18\x02\x08\x03\x12\
    \x04\xa0\x03\x20!\n\x0c\n\x04\x04\x18\x02\t\x12\x04\xa1\x03\x085\n\r\n\
    \x05\x04\x18\x02\t\x04\x12\x04\xa1\x03\x08\x10\n\r\n\x05\x04\x18\x02\t\
    \x05\x12\x04\xa1\x03\x11\x17\n\r\n\x05\x04\x18\x02\t\x01\x12\x04\xa1\x03\
    \x180\n\r\n\x05\x04\x18\x02\t\x03\x12\x04\xa1\x0334\n\x0c\n\x04\x04\x18\
    \x02\n\x12\x04\xa2\x03\x08,\n\r\n\x05\x04\x18\x02\n\x04\x12\x04\xa2\x03\
    \x08\x10\n\r\n\x05\x04\x18\x02\n\x05\x12\x04\xa2\x03\x11\x18\n\r\n\x05\
    \x04\x18\x02\n\x01\x12\x04\xa2\x03\x19&\n\r\n\x05\x04\x18\x02\n\x03\x12\
    \x04\xa2\x03)+\n\x0c\n\x04\x04\x18\x02\x0b\x12\x04\xa3\x03\x08)\n\r\n\
    \x05\x04\x18\x02\x0b\x04\x12\x04\xa3\x03\x08\x10\n\r\n\x05\x04\x18\x02\
    \x0b\x05\x12\x04\xa3\x03\x11\x17\n\r\n\x05\x04\x18\x02\x0b\x01\x12\x04\
    \xa3\x03\x18#\n\r\n\x05\x04\x18\x02\x0b\x03\x12\x04\xa3\x03&(\n\x0c\n\
    \x04\x04\x18\x02\x0c\x12\x04\xa4\x03\x08)\n\r\n\x05\x04\x18\x02\x0c\x04\
    \x12\x04\xa4\x03\x08\x10\n\r\n\x05\x04\x18\x02\x0c\x05\x12\x04\xa4\x03\
    \x11\x17\n\r\n\x05\x04\x18\x02\x0c\x01\x12\x04\xa4\x03\x18#\n\r\n\x05\
    \x04\x18\x02\x0c\x03\x12\x04\xa4\x03&(\n\x0c\n\x02\x04\x19\x12\x06\xa7\
    \x03\0\xbe\x03\x01\n\x0b\n\x03\x04\x19\x01\x12\x04\xa7\x03\x089\n\x0e\n\
    \x04\x04\x19\x04\0\x12\x06\xa8\x03\x08\xad\x03\t\n\r\n\x05\x04\x19\x04\0\
    \x01\x12\x04\xa8\x03\r\x12\n\x0e\n\x06\x04\x19\x04\0\x02\0\x12\x04\xa9\
    \x03\x10&\n\x0f\n\x07\x04\x19\x04\0\x02\0\x01\x12\x04\xa9\x03\x10!\n\x0f\
    \n\x07\x04\x19\x04\0\x02\0\x02\x12\x04\xa9\x03$%\n\x0e\n\x06\x04\x19\x04\
    \0\x02\x01\x12\x04\xaa\x03\x10$\n\x0f\n\x07\x04\x19\x04\0\x02\x01\x01\
    \x12\x04\xaa\x03\x10\x1f\n\x0f\n\x07\x04\x19\x04\0\x02\x01\x02\x12\x04\
    \xaa\x03\"#\n\x0e\n\x06\x04\x19\x04\0\x02\x02\x12\x04\xab\x03\x10*\n\x0f\
    \n\x07\x04\x19\x04\0\x02\x02\x01\x12\x04\xab\x03\x10%\n\x0f\n\x07\x04\
    \x19\x04\0\x02\x02\x02\x12\x04\xab\x03()\n\x0e\n\x06\x04\x19\x04\0\x02\
    \x03\x12\x04\xac\x03\x10/\n\x0f\n\x07\x04\x19\x04\0\x02\x03\x01\x12\x04\
    \xac\x03\x10)\n\x0f\n\x07\x04\x19\x04\0\x02\x03\x02\x12\x04\xac\x03,.\n\
    \x0c\n\x04\x04\x19\x02\0\x12\x04\xaf\x03\x08G\n\r\n\x05\x04\x19\x02\0\
    \x04\x12\x04\xaf\x03\x08\x10\n\r\n\x05\x04\x19\x02\0\x06\x12\x04\xaf\x03\
    \x114\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\xaf\x035B\n\r\n\x05\x04\x19\
    \x02\0\x03\x12\x04\xaf\x03EF\n\x0c\n\x04\x04\x19\x02\x01\x12\x04\xb0\x03\
    \x08E\n\r\n\x05\x04\x19\x02\x01\x04\x12\x04\xb0\x03\x08\x10\n\r\n\x05\
    \x04\x19\x02\x01\x06\x12\x04\xb0\x03\x114\n\r\n\x05\x04\x19\x02\x01\x01\
    \x12\x04\xb0\x035@\n\r\n\x05\x04\x19\x02\x01\x03\x12\x04\xb0\x03CD\n\x0c\
    \n\x04\x04\x19\x02\x02\x12\x04\xb1\x03\x083\n\r\n\x05\x04\x19\x02\x02\
    \x04\x12\x04\xb1\x03\x08\x10\n\r\n\x05\x04\x19\x02\x02\x05\x12\x04\xb1\
    \x03\x11\x17\n\r\n\x05\x04\x19\x02\x02\x01\x12\x04\xb1\x03\x18.\n\r\n\
    \x05\x04\x19\x02\x02\x03\x12\x04\xb1\x0312\n\x0c\n\x04\x04\x19\x02\x03\
    \x12\x04\xb2\x03\x080\n\r\n\x05\x04\x19\x02\x03\x04\x12\x04\xb2\x03\x08\
    \x10\n\r\n\x05\x04\x19\x02\x03\x05\x12\x04\xb2\x03\x11\x18\n\r\n\x05\x04\
    \x19\x02\x03\x01\x12\x04\xb2\x03\x19+\n\r\n\x05\x04\x19\x02\x03\x03\x12\
    \x04\xb2\x03./\n\x0c\n\x04\x04\x19\x02\x04\x12\x04\xb3\x03\x081\n\r\n\
    \x05\x04\x19\x02\x04\x04\x12\x04\xb3\x03\x08\x10\n\r\n\x05\x04\x19\x02\
    \x04\x05\x12\x04\xb3\x03\x11\x17\n\r\n\x05\x04\x19\x02\x04\x01\x12\x04\
    \xb3\x03\x18,\n\r\n\x05\x04\x19\x02\x04\x03\x12\x04\xb3\x03/0\n\x0c\n\
    \x04\x04\x19\x02\x05\x12\x04\xb4\x03\x08:\n\r\n\x05\x04\x19\x02\x05\x04\
    \x12\x04\xb4\x03\x08\x10\n\r\n\x05\x04\x19\x02\x05\x05\x12\x04\xb4\x03\
    \x11\x17\n\r\n\x05\x04\x19\x02\x05\x01\x12\x04\xb4\x03\x185\n\r\n\x05\
    \x04\x19\x02\x05\x03\x12\x04\xb4\x0389\n\x0c\n\x04\x04\x19\x02\x06\x12\
    \x04\xb5\x03\x08'\n\r\n\x05\x04\x19\x02\x06\x04\x12\x04\xb5\x03\x08\x10\
    \n\r\n\x05\x04\x19\x02\x06\x05\x12\x04\xb5\x03\x11\x18\n\r\n\x05\x04\x19\
    \x02\x06\x01\x12\x04\xb5\x03\x19\"\n\r\n\x05\x04\x19\x02\x06\x03\x12\x04\
    \xb5\x03%&\n\x0c\n\x04\x04\x19\x02\x07\x12\x04\xb6\x03\x08,\n\r\n\x05\
    \x04\x19\x02\x07\x04\x12\x04\xb6\x03\x08\x10\n\r\n\x05\x04\x19\x02\x07\
    \x05\x12\x04\xb6\x03\x11\x18\n\r\n\x05\x04\x19\x02\x07\x01\x12\x04\xb6\
    \x03\x19'\n\r\n\x05\x04\x19\x02\x07\x03\x12\x04\xb6\x03*+\n\x0c\n\x04\
    \x04\x19\x02\x08\x12\x04\xb7\x03\x08\"\n\r\n\x05\x04\x19\x02\x08\x04\x12\
    \x04\xb7\x03\x08\x10\n\r\n\x05\x04\x19\x02\x08\x05\x12\x04\xb7\x03\x11\
    \x17\n\r\n\x05\x04\x19\x02\x08\x01\x12\x04\xb7\x03\x18\x1d\n\r\n\x05\x04\
    \x19\x02\x08\x03\x12\x04\xb7\x03\x20!\n\x0c\n\x04\x04\x19\x02\t\x12\x04\
    \xb8\x03\x089\n\r\n\x05\x04\x19\x02\t\x04\x12\x04\xb8\x03\x08\x10\n\r\n\
    \x05\x04\x19\x02\t\x05\x12\x04\xb8\x03\x11\x17\n\r\n\x05\x04\x19\x02\t\
    \x01\x12\x04\xb8\x03\x183\n\r\n\x05\x04\x19\x02\t\x03\x12\x04\xb8\x0368\
    \n\x0c\n\x04\x04\x19\x02\n\x12\x04\xb9\x03\x08#\n\r\n\x05\x04\x19\x02\n\
    \x04\x12\x04\xb9\x03\x08\x10\n\r\n\x05\x04\x19\x02\n\x05\x12\x04\xb9\x03\
    \x11\x16\n\r\n\x05\x04\x19\x02\n\x01\x12\x04\xb9\x03\x17\x1d\n\r\n\x05\
    \x04\x19\x02\n\x03\x12\x04\xb9\x03\x20\"\n\x0c\n\x04\x04\x19\x02\x0b\x12\
    \x04\xba\x03\x086\n\r\n\x05\x04\x19\x02\x0b\x04\x12\x04\xba\x03\x08\x10\
    \n\r\n\x05\x04\x19\x02\x0b\x05\x12\x04\xba\x03\x11\x17\n\r\n\x05\x04\x19\
    \x02\x0b\x01\x12\x04\xba\x03\x180\n\r\n\x05\x04\x19\x02\x0b\x03\x12\x04\
    \xba\x0335\n\x0c\n\x04\x04\x19\x02\x0c\x12\x04\xbb\x03\x08,\n\r\n\x05\
    \x04\x19\x02\x0c\x04\x12\x04\xbb\x03\x08\x10\n\r\n\x05\x04\x19\x02\x0c\
    \x05\x12\x04\xbb\x03\x11\x18\n\r\n\x05\x04\x19\x02\x0c\x01\x12\x04\xbb\
    \x03\x19&\n\r\n\x05\x04\x19\x02\x0c\x03\x12\x04\xbb\x03)+\n\x0c\n\x04\
    \x04\x19\x02\r\x12\x04\xbc\x03\x08)\n\r\n\x05\x04\x19\x02\r\x04\x12\x04\
    \xbc\x03\x08\x10\n\r\n\x05\x04\x19\x02\r\x05\x12\x04\xbc\x03\x11\x17\n\r\
    \n\x05\x04\x19\x02\r\x01\x12\x04\xbc\x03\x18#\n\r\n\x05\x04\x19\x02\r\
    \x03\x12\x04\xbc\x03&(\n\x0c\n\x04\x04\x19\x02\x0e\x12\x04\xbd\x03\x08)\
    \n\r\n\x05\x04\x19\x02\x0e\x04\x12\x04\xbd\x03\x08\x10\n\r\n\x05\x04\x19\
    \x02\x0e\x05\x12\x04\xbd\x03\x11\x17\n\r\n\x05\x04\x19\x02\x0e\x01\x12\
    \x04\xbd\x03\x18#\n\r\n\x05\x04\x19\x02\x0e\x03\x12\x04\xbd\x03&(\n\x0c\
    \n\x02\x04\x1a\x12\x06\xc0\x03\0\xc5\x03\x01\n\x0b\n\x03\x04\x1a\x01\x12\
    \x04\xc0\x03\x082\n\x0c\n\x04\x04\x1a\x02\0\x12\x04\xc1\x03\x08+\n\r\n\
    \x05\x04\x1a\x02\0\x04\x12\x04\xc1\x03\x08\x10\n\r\n\x05\x04\x1a\x02\0\
    \x05\x12\x04\xc1\x03\x11\x18\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\xc1\x03\
    \x19&\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\xc1\x03)*\n\x0c\n\x04\x04\x1a\
    \x02\x01\x12\x04\xc2\x03\x086\n\r\n\x05\x04\x1a\x02\x01\x04\x12\x04\xc2\
    \x03\x08\x10\n\r\n\x05\x04\x1a\x02\x01\x05\x12\x04\xc2\x03\x11\x16\n\r\n\
    \x05\x04\x1a\x02\x01\x01\x12\x04\xc2\x03\x171\n\r\n\x05\x04\x1a\x02\x01\
    \x03\x12\x04\xc2\x0345\n\x0c\n\x04\x04\x1a\x02\x02\x12\x04\xc3\x03\x088\
    \n\r\n\x05\x04\x1a\x02\x02\x04\x12\x04\xc3\x03\x08\x10\n\r\n\x05\x04\x1a\
    \x02\x02\x05\x12\x04\xc3\x03\x11\x17\n\r\n\x05\x04\x1a\x02\x02\x01\x12\
    \x04\xc3\x03\x183\n\r\n\x05\x04\x1a\x02\x02\x03\x12\x04\xc3\x0367\n\x0c\
    \n\x04\x04\x1a\x02\x03\x12\x04\xc4\x03\x08)\n\r\n\x05\x04\x1a\x02\x03\
    \x04\x12\x04\xc4\x03\x08\x10\n\r\n\x05\x04\x1a\x02\x03\x05\x12\x04\xc4\
    \x03\x11\x18\n\r\n\x05\x04\x1a\x02\x03\x01\x12\x04\xc4\x03\x19#\n\r\n\
    \x05\x04\x1a\x02\x03\x03\x12\x04\xc4\x03&(\n\x0c\n\x02\x04\x1b\x12\x06\
    \xc7\x03\0\xd8\x03\x01\n\x0b\n\x03\x04\x1b\x01\x12\x04\xc7\x03\x08\"\n\
    \x0e\n\x04\x04\x1b\x03\0\x12\x06\xc8\x03\x08\xcd\x03\t\n\r\n\x05\x04\x1b\
    \x03\0\x01\x12\x04\xc8\x03\x10\x1c\n\x0e\n\x06\x04\x1b\x03\0\x02\0\x12\
    \x04\xc9\x03\x10,\n\x0f\n\x07\x04\x1b\x03\0\x02\0\x04\x12\x04\xc9\x03\
    \x10\x18\n\x0f\n\x07\x04\x1b\x03\0\x02\0\x05\x12\x04\xc9\x03\x19\x20\n\
    \x0f\n\x07\x04\x1b\x03\0\x02\0\x01\x12\x04\xc9\x03!'\n\x0f\n\x07\x04\x1b\
    \x03\0\x02\0\x03\x12\x04\xc9\x03*+\n\x0e\n\x06\x04\x1b\x03\0\x02\x01\x12\
    \x04\xca\x03\x10,\n\x0f\n\x07\x04\x1b\x03\0\x02\x01\x04\x12\x04\xca\x03\
    \x10\x18\n\x0f\n\x07\x04\x1b\x03\0\x02\x01\x05\x12\x04\xca\x03\x19\x1f\n\
    \x0f\n\x07\x04\x1b\x03\0\x02\x01\x01\x12\x04\xca\x03\x20'\n\x0f\n\x07\
    \x04\x1b\x03\0\x02\x01\x03\x12\x04\xca\x03*+\n\x0e\n\x06\x04\x1b\x03\0\
    \x02\x02\x12\x04\xcb\x03\x102\n\x0f\n\x07\x04\x1b\x03\0\x02\x02\x04\x12\
    \x04\xcb\x03\x10\x18\n\x0f\n\x07\x04\x1b\x03\0\x02\x02\x05\x12\x04\xcb\
    \x03\x19\x1f\n\x0f\n\x07\x04\x1b\x03\0\x02\x02\x01\x12\x04\xcb\x03\x20-\
    \n\x0f\n\x07\x04\x1b\x03\0\x02\x02\x03\x12\x04\xcb\x0301\n\x0e\n\x06\x04\
    \x1b\x03\0\x02\x03\x12\x04\xcc\x03\x10?\n\x0f\n\x07\x04\x1b\x03\0\x02\
    \x03\x04\x12\x04\xcc\x03\x10\x18\n\x0f\n\x07\x04\x1b\x03\0\x02\x03\x05\
    \x12\x04\xcc\x03\x19\x1e\n\x0f\n\x07\x04\x1b\x03\0\x02\x03\x01\x12\x04\
    \xcc\x03\x1f:\n\x0f\n\x07\x04\x1b\x03\0\x02\x03\x03\x12\x04\xcc\x03=>\n\
    \x0e\n\x04\x04\x1b\x03\x01\x12\x06\xcf\x03\x08\xd3\x03\t\n\r\n\x05\x04\
    \x1b\x03\x01\x01\x12\x04\xcf\x03\x10\x15\n\x0e\n\x06\x04\x1b\x03\x01\x02\
    \0\x12\x04\xd0\x03\x10/\n\x0f\n\x07\x04\x1b\x03\x01\x02\0\x04\x12\x04\
    \xd0\x03\x10\x18\n\x0f\n\x07\x04\x1b\x03\x01\x02\0\x05\x12\x04\xd0\x03\
    \x19\x20\n\x0f\n\x07\x04\x1b\x03\x01\x02\0\x01\x12\x04\xd0\x03!*\n\x0f\n\
    \x07\x04\x1b\x03\x01\x02\0\x03\x12\x04\xd0\x03-.\n\x0e\n\x06\x04\x1b\x03\
    \x01\x02\x01\x12\x04\xd1\x03\x101\n\x0f\n\x07\x04\x1b\x03\x01\x02\x01\
    \x04\x12\x04\xd1\x03\x10\x18\n\x0f\n\x07\x04\x1b\x03\x01\x02\x01\x05\x12\
    \x04\xd1\x03\x19\x20\n\x0f\n\x07\x04\x1b\x03\x01\x02\x01\x01\x12\x04\xd1\
    \x03!,\n\x0f\n\x07\x04\x1b\x03\x01\x02\x01\x03\x12\x04\xd1\x03/0\n\x0e\n\
    \x06\x04\x1b\x03\x01\x02\x02\x12\x04\xd2\x03\x10*\n\x0f\n\x07\x04\x1b\
    \x03\x01\x02\x02\x04\x12\x04\xd2\x03\x10\x18\n\x0f\n\x07\x04\x1b\x03\x01\
    \x02\x02\x05\x12\x04\xd2\x03\x19\x1f\n\x0f\n\x07\x04\x1b\x03\x01\x02\x02\
    \x01\x12\x04\xd2\x03\x20%\n\x0f\n\x07\x04\x1b\x03\x01\x02\x02\x03\x12\
    \x04\xd2\x03()\n\x0c\n\x04\x04\x1b\x02\0\x12\x04\xd5\x03\x08M\n\r\n\x05\
    \x04\x1b\x02\0\x04\x12\x04\xd5\x03\x08\x10\n\r\n\x05\x04\x1b\x02\0\x06\
    \x12\x04\xd5\x03\x119\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\xd5\x03:H\n\r\
    \n\x05\x04\x1b\x02\0\x03\x12\x04\xd5\x03KL\n\x0c\n\x04\x04\x1b\x02\x01\
    \x12\x04\xd6\x03\x08>\n\r\n\x05\x04\x1b\x02\x01\x04\x12\x04\xd6\x03\x08\
    \x10\n\r\n\x05\x04\x1b\x02\x01\x06\x12\x04\xd6\x03\x112\n\r\n\x05\x04\
    \x1b\x02\x01\x01\x12\x04\xd6\x0339\n\r\n\x05\x04\x1b\x02\x01\x03\x12\x04\
    \xd6\x03<=\n\x0c\n\x04\x04\x1b\x02\x02\x12\x04\xd7\x03\x08%\n\r\n\x05\
    \x04\x1b\x02\x02\x04\x12\x04\xd7\x03\x08\x10\n\r\n\x05\x04\x1b\x02\x02\
    \x05\x12\x04\xd7\x03\x11\x17\n\r\n\x05\x04\x1b\x02\x02\x01\x12\x04\xd7\
    \x03\x18\x20\n\r\n\x05\x04\x1b\x02\x02\x03\x12\x04\xd7\x03#$\n\x0c\n\x02\
    \x04\x1c\x12\x06\xda\x03\0\xdd\x03\x01\n\x0b\n\x03\x04\x1c\x01\x12\x04\
    \xda\x03\x08)\n\x0c\n\x04\x04\x1c\x02\0\x12\x04\xdb\x03\x08\"\n\r\n\x05\
    \x04\x1c\x02\0\x04\x12\x04\xdb\x03\x08\x10\n\r\n\x05\x04\x1c\x02\0\x05\
    \x12\x04\xdb\x03\x11\x18\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\xdb\x03\x19\
    \x1d\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\xdb\x03\x20!\n\x0c\n\x04\x04\
    \x1c\x02\x01\x12\x04\xdc\x03\x08!\n\r\n\x05\x04\x1c\x02\x01\x04\x12\x04\
    \xdc\x03\x08\x10\n\r\n\x05\x04\x1c\x02\x01\x05\x12\x04\xdc\x03\x11\x17\n\
    \r\n\x05\x04\x1c\x02\x01\x01\x12\x04\xdc\x03\x18\x1c\n\r\n\x05\x04\x1c\
    \x02\x01\x03\x12\x04\xdc\x03\x1f\x20\n\x0c\n\x02\x04\x1d\x12\x06\xdf\x03\
    \0\xe2\x03\x01\n\x0b\n\x03\x04\x1d\x01\x12\x04\xdf\x03\x083\n\x0c\n\x04\
    \x04\x1d\x02\0\x12\x04\xe0\x03\x08+\n\r\n\x05\x04\x1d\x02\0\x04\x12\x04\
    \xe0\x03\x08\x10\n\r\n\x05\x04\x1d\x02\0\x05\x12\x04\xe0\x03\x11\x18\n\r\
    \n\x05\x04\x1d\x02\0\x01\x12\x04\xe0\x03\x19&\n\r\n\x05\x04\x1d\x02\0\
    \x03\x12\x04\xe0\x03)*\n\x0c\n\x04\x04\x1d\x02\x01\x12\x04\xe1\x03\x08@\
    \n\r\n\x05\x04\x1d\x02\x01\x04\x12\x04\xe1\x03\x08\x10\n\r\n\x05\x04\x1d\
    \x02\x01\x06\x12\x04\xe1\x03\x113\n\r\n\x05\x04\x1d\x02\x01\x01\x12\x04\
    \xe1\x034;\n\r\n\x05\x04\x1d\x02\x01\x03\x12\x04\xe1\x03>?\n\x0c\n\x02\
    \x04\x1e\x12\x06\xe4\x03\0\xeb\x03\x01\n\x0b\n\x03\x04\x1e\x01\x12\x04\
    \xe4\x03\x08)\n\x0c\n\x04\x04\x1e\x02\0\x12\x04\xe5\x03\x08/\n\r\n\x05\
    \x04\x1e\x02\0\x04\x12\x04\xe5\x03\x08\x10\n\r\n\x05\x04\x1e\x02\0\x05\
    \x12\x04\xe5\x03\x11\x18\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\xe5\x03\x19\
    *\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\xe5\x03-.\n\x0c\n\x04\x04\x1e\x02\
    \x01\x12\x04\xe6\x03\x08*\n\r\n\x05\x04\x1e\x02\x01\x04\x12\x04\xe6\x03\
    \x08\x10\n\r\n\x05\x04\x1e\x02\x01\x05\x12\x04\xe6\x03\x11\x18\n\r\n\x05\
    \x04\x1e\x02\x01\x01\x12\x04\xe6\x03\x19%\n\r\n\x05\x04\x1e\x02\x01\x03\
    \x12\x04\xe6\x03()\n\x0c\n\x04\x04\x1e\x02\x02\x12\x04\xe7\x03\x08'\n\r\
    \n\x05\x04\x1e\x02\x02\x04\x12\x04\xe7\x03\x08\x10\n\r\n\x05\x04\x1e\x02\
    \x02\x05\x12\x04\xe7\x03\x11\x18\n\r\n\x05\x04\x1e\x02\x02\x01\x12\x04\
    \xe7\x03\x19\"\n\r\n\x05\x04\x1e\x02\x02\x03\x12\x04\xe7\x03%&\n\x0c\n\
    \x04\x04\x1e\x02\x03\x12\x04\xe8\x03\x08)\n\r\n\x05\x04\x1e\x02\x03\x04\
    \x12\x04\xe8\x03\x08\x10\n\r\n\x05\x04\x1e\x02\x03\x05\x12\x04\xe8\x03\
    \x11\x18\n\r\n\x05\x04\x1e\x02\x03\x01\x12\x04\xe8\x03\x19$\n\r\n\x05\
    \x04\x1e\x02\x03\x03\x12\x04\xe8\x03'(\n\x0c\n\x04\x04\x1e\x02\x04\x12\
    \x04\xe9\x03\x08&\n\r\n\x05\x04\x1e\x02\x04\x04\x12\x04\xe9\x03\x08\x10\
    \n\r\n\x05\x04\x1e\x02\x04\x05\x12\x04\xe9\x03\x11\x18\n\r\n\x05\x04\x1e\
    \x02\x04\x01\x12\x04\xe9\x03\x19!\n\r\n\x05\x04\x1e\x02\x04\x03\x12\x04\
    \xe9\x03$%\n\x0c\n\x04\x04\x1e\x02\x05\x12\x04\xea\x03\x08O\n\r\n\x05\
    \x04\x1e\x02\x05\x04\x12\x04\xea\x03\x08\x10\n\r\n\x05\x04\x1e\x02\x05\
    \x06\x12\x04\xea\x03\x11=\n\r\n\x05\x04\x1e\x02\x05\x01\x12\x04\xea\x03>\
    J\n\r\n\x05\x04\x1e\x02\x05\x03\x12\x04\xea\x03MN\n\x0c\n\x02\x04\x1f\
    \x12\x06\xed\x03\0\xfa\x03\x01\n\x0b\n\x03\x04\x1f\x01\x12\x04\xed\x03\
    \x08(\n\x0e\n\x04\x04\x1f\x03\0\x12\x06\xee\x03\x08\xf1\x03\t\n\r\n\x05\
    \x04\x1f\x03\0\x01\x12\x04\xee\x03\x10\x16\n\x0e\n\x06\x04\x1f\x03\0\x02\
    \0\x12\x04\xef\x03\x10,\n\x0f\n\x07\x04\x1f\x03\0\x02\0\x04\x12\x04\xef\
    \x03\x10\x18\n\x0f\n\x07\x04\x1f\x03\0\x02\0\x05\x12\x04\xef\x03\x19\x1f\
    \n\x0f\n\x07\x04\x1f\x03\0\x02\0\x01\x12\x04\xef\x03\x20'\n\x0f\n\x07\
    \x04\x1f\x03\0\x02\0\x03\x12\x04\xef\x03*+\n\x0e\n\x06\x04\x1f\x03\0\x02\
    \x01\x12\x04\xf0\x03\x10,\n\x0f\n\x07\x04\x1f\x03\0\x02\x01\x04\x12\x04\
    \xf0\x03\x10\x18\n\x0f\n\x07\x04\x1f\x03\0\x02\x01\x05\x12\x04\xf0\x03\
    \x19\x1f\n\x0f\n\x07\x04\x1f\x03\0\x02\x01\x01\x12\x04\xf0\x03\x20'\n\
    \x0f\n\x07\x04\x1f\x03\0\x02\x01\x03\x12\x04\xf0\x03*+\n\x0e\n\x04\x04\
    \x1f\x03\x01\x12\x06\xf3\x03\x08\xf7\x03\t\n\r\n\x05\x04\x1f\x03\x01\x01\
    \x12\x04\xf3\x03\x10\x1a\n\x0e\n\x06\x04\x1f\x03\x01\x02\0\x12\x04\xf4\
    \x03\x10)\n\x0f\n\x07\x04\x1f\x03\x01\x02\0\x04\x12\x04\xf4\x03\x10\x18\
    \n\x0f\n\x07\x04\x1f\x03\x01\x02\0\x05\x12\x04\xf4\x03\x19\x1f\n\x0f\n\
    \x07\x04\x1f\x03\x01\x02\0\x01\x12\x04\xf4\x03\x20$\n\x0f\n\x07\x04\x1f\
    \x03\x01\x02\0\x03\x12\x04\xf4\x03'(\n\x0e\n\x06\x04\x1f\x03\x01\x02\x01\
    \x12\x04\xf5\x03\x10T\n\x0f\n\x07\x04\x1f\x03\x01\x02\x01\x04\x12\x04\
    \xf5\x03\x10\x18\n\x0f\n\x07\x04\x1f\x03\x01\x02\x01\x06\x12\x04\xf5\x03\
    \x19A\n\x0f\n\x07\x04\x1f\x03\x01\x02\x01\x01\x12\x04\xf5\x03BO\n\x0f\n\
    \x07\x04\x1f\x03\x01\x02\x01\x03\x12\x04\xf5\x03RS\n\x0e\n\x06\x04\x1f\
    \x03\x01\x02\x02\x12\x04\xf6\x03\x10S\n\x0f\n\x07\x04\x1f\x03\x01\x02\
    \x02\x04\x12\x04\xf6\x03\x10\x18\n\x0f\n\x07\x04\x1f\x03\x01\x02\x02\x06\
    \x12\x04\xf6\x03\x19A\n\x0f\n\x07\x04\x1f\x03\x01\x02\x02\x01\x12\x04\
    \xf6\x03BN\n\x0f\n\x07\x04\x1f\x03\x01\x02\x02\x03\x12\x04\xf6\x03QR\n\
    \x0c\n\x04\x04\x1f\x02\0\x12\x04\xf9\x03\x08O\n\r\n\x05\x04\x1f\x02\0\
    \x04\x12\x04\xf9\x03\x08\x10\n\r\n\x05\x04\x1f\x02\0\x06\x12\x04\xf9\x03\
    \x11=\n\r\n\x05\x04\x1f\x02\0\x01\x12\x04\xf9\x03>J\n\r\n\x05\x04\x1f\
    \x02\0\x03\x12\x04\xf9\x03MN\n\x0c\n\x02\x04\x20\x12\x06\xfc\x03\0\x8d\
    \x04\x01\n\x0b\n\x03\x04\x20\x01\x12\x04\xfc\x03\x08%\n\x0e\n\x04\x04\
    \x20\x03\0\x12\x06\xfd\x03\x08\x81\x04\t\n\r\n\x05\x04\x20\x03\0\x01\x12\
    \x04\xfd\x03\x10\x1a\n\x0e\n\x06\x04\x20\x03\0\x02\0\x12\x04\xfe\x03\x10\
    3\n\x0f\n\x07\x04\x20\x03\0\x02\0\x04\x12\x04\xfe\x03\x10\x18\n\x0f\n\
    \x07\x04\x20\x03\0\x02\0\x05\x12\x04\xfe\x03\x19\x20\n\x0f\n\x07\x04\x20\
    \x03\0\x02\0\x01\x12\x04\xfe\x03!.\n\x0f\n\x07\x04\x20\x03\0\x02\0\x03\
    \x12\x04\xfe\x0312\n\x0e\n\x06\x04\x20\x03\0\x02\x01\x12\x04\xff\x03\x10\
    *\n\x0f\n\x07\x04\x20\x03\0\x02\x01\x04\x12\x04\xff\x03\x10\x18\n\x0f\n\
    \x07\x04\x20\x03\0\x02\x01\x05\x12\x04\xff\x03\x19\x1f\n\x0f\n\x07\x04\
    \x20\x03\0\x02\x01\x01\x12\x04\xff\x03\x20%\n\x0f\n\x07\x04\x20\x03\0\
    \x02\x01\x03\x12\x04\xff\x03()\n\x0e\n\x06\x04\x20\x03\0\x02\x02\x12\x04\
    \x80\x04\x10H\n\x0f\n\x07\x04\x20\x03\0\x02\x02\x04\x12\x04\x80\x04\x10\
    \x18\n\x0f\n\x07\x04\x20\x03\0\x02\x02\x06\x12\x04\x80\x04\x19;\n\x0f\n\
    \x07\x04\x20\x03\0\x02\x02\x01\x12\x04\x80\x04<C\n\x0f\n\x07\x04\x20\x03\
    \0\x02\x02\x03\x12\x04\x80\x04FG\n\x0c\n\x04\x04\x20\x02\0\x12\x04\x83\
    \x04\x08$\n\r\n\x05\x04\x20\x02\0\x04\x12\x04\x83\x04\x08\x10\n\r\n\x05\
    \x04\x20\x02\0\x05\x12\x04\x83\x04\x11\x16\n\r\n\x05\x04\x20\x02\0\x01\
    \x12\x04\x83\x04\x17\x1f\n\r\n\x05\x04\x20\x02\0\x03\x12\x04\x83\x04\"#\
    \n\x0c\n\x04\x04\x20\x02\x01\x12\x04\x84\x04\x08)\n\r\n\x05\x04\x20\x02\
    \x01\x04\x12\x04\x84\x04\x08\x10\n\r\n\x05\x04\x20\x02\x01\x05\x12\x04\
    \x84\x04\x11\x16\n\r\n\x05\x04\x20\x02\x01\x01\x12\x04\x84\x04\x17#\n\r\
    \n\x05\x04\x20\x02\x01\x03\x12\x04\x84\x04&(\n\x0c\n\x04\x04\x20\x02\x02\
    \x12\x04\x85\x04\x08,\n\r\n\x05\x04\x20\x02\x02\x04\x12\x04\x85\x04\x08\
    \x10\n\r\n\x05\x04\x20\x02\x02\x05\x12\x04\x85\x04\x11\x17\n\r\n\x05\x04\
    \x20\x02\x02\x01\x12\x04\x85\x04\x18'\n\r\n\x05\x04\x20\x02\x02\x03\x12\
    \x04\x85\x04*+\n\x0c\n\x04\x04\x20\x02\x03\x12\x04\x86\x04\x08*\n\r\n\
    \x05\x04\x20\x02\x03\x04\x12\x04\x86\x04\x08\x10\n\r\n\x05\x04\x20\x02\
    \x03\x05\x12\x04\x86\x04\x11\x17\n\r\n\x05\x04\x20\x02\x03\x01\x12\x04\
    \x86\x04\x18%\n\r\n\x05\x04\x20\x02\x03\x03\x12\x04\x86\x04()\n\x0c\n\
    \x04\x04\x20\x02\x04\x12\x04\x87\x04\x08+\n\r\n\x05\x04\x20\x02\x04\x04\
    \x12\x04\x87\x04\x08\x10\n\r\n\x05\x04\x20\x02\x04\x05\x12\x04\x87\x04\
    \x11\x17\n\r\n\x05\x04\x20\x02\x04\x01\x12\x04\x87\x04\x18&\n\r\n\x05\
    \x04\x20\x02\x04\x03\x12\x04\x87\x04)*\n\x0c\n\x04\x04\x20\x02\x05\x12\
    \x04\x88\x04\x083\n\r\n\x05\x04\x20\x02\x05\x04\x12\x04\x88\x04\x08\x10\
    \n\r\n\x05\x04\x20\x02\x05\x05\x12\x04\x88\x04\x11\x17\n\r\n\x05\x04\x20\
    \x02\x05\x01\x12\x04\x88\x04\x18.\n\r\n\x05\x04\x20\x02\x05\x03\x12\x04\
    \x88\x0412\n\x0c\n\x04\x04\x20\x02\x06\x12\x04\x89\x04\x08-\n\r\n\x05\
    \x04\x20\x02\x06\x04\x12\x04\x89\x04\x08\x10\n\r\n\x05\x04\x20\x02\x06\
    \x05\x12\x04\x89\x04\x11\x16\n\r\n\x05\x04\x20\x02\x06\x01\x12\x04\x89\
    \x04\x17(\n\r\n\x05\x04\x20\x02\x06\x03\x12\x04\x89\x04+,\n\x0c\n\x04\
    \x04\x20\x02\x07\x12\x04\x8a\x04\x08/\n\r\n\x05\x04\x20\x02\x07\x04\x12\
    \x04\x8a\x04\x08\x10\n\r\n\x05\x04\x20\x02\x07\x05\x12\x04\x8a\x04\x11\
    \x16\n\r\n\x05\x04\x20\x02\x07\x01\x12\x04\x8a\x04\x17*\n\r\n\x05\x04\
    \x20\x02\x07\x03\x12\x04\x8a\x04-.\n\x0c\n\x04\x04\x20\x02\x08\x12\x04\
    \x8b\x04\x08L\n\r\n\x05\x04\x20\x02\x08\x04\x12\x04\x8b\x04\x08\x10\n\r\
    \n\x05\x04\x20\x02\x08\x06\x12\x04\x8b\x04\x11:\n\r\n\x05\x04\x20\x02\
    \x08\x01\x12\x04\x8b\x04;G\n\r\n\x05\x04\x20\x02\x08\x03\x12\x04\x8b\x04\
    JK\n\x0c\n\x04\x04\x20\x02\t\x12\x04\x8c\x04\x08#\n\r\n\x05\x04\x20\x02\
    \t\x04\x12\x04\x8c\x04\x08\x10\n\r\n\x05\x04\x20\x02\t\x05\x12\x04\x8c\
    \x04\x11\x18\n\r\n\x05\x04\x20\x02\t\x01\x12\x04\x8c\x04\x19\x1e\n\r\n\
    \x05\x04\x20\x02\t\x03\x12\x04\x8c\x04!\"\n\x0c\n\x02\x04!\x12\x06\x8f\
    \x04\0\xa6\x04\x01\n\x0b\n\x03\x04!\x01\x12\x04\x8f\x04\x089\n\x0e\n\x04\
    \x04!\x04\0\x12\x06\x90\x04\x08\x95\x04\t\n\r\n\x05\x04!\x04\0\x01\x12\
    \x04\x90\x04\r\x12\n\x0e\n\x06\x04!\x04\0\x02\0\x12\x04\x91\x04\x10&\n\
    \x0f\n\x07\x04!\x04\0\x02\0\x01\x12\x04\x91\x04\x10!\n\x0f\n\x07\x04!\
    \x04\0\x02\0\x02\x12\x04\x91\x04$%\n\x0e\n\x06\x04!\x04\0\x02\x01\x12\
    \x04\x92\x04\x10$\n\x0f\n\x07\x04!\x04\0\x02\x01\x01\x12\x04\x92\x04\x10\
    \x1f\n\x0f\n\x07\x04!\x04\0\x02\x01\x02\x12\x04\x92\x04\"#\n\x0e\n\x06\
    \x04!\x04\0\x02\x02\x12\x04\x93\x04\x10*\n\x0f\n\x07\x04!\x04\0\x02\x02\
    \x01\x12\x04\x93\x04\x10%\n\x0f\n\x07\x04!\x04\0\x02\x02\x02\x12\x04\x93\
    \x04()\n\x0e\n\x06\x04!\x04\0\x02\x03\x12\x04\x94\x04\x10/\n\x0f\n\x07\
    \x04!\x04\0\x02\x03\x01\x12\x04\x94\x04\x10)\n\x0f\n\x07\x04!\x04\0\x02\
    \x03\x02\x12\x04\x94\x04,.\n\x0c\n\x04\x04!\x02\0\x12\x04\x97\x04\x08G\n\
    \r\n\x05\x04!\x02\0\x04\x12\x04\x97\x04\x08\x10\n\r\n\x05\x04!\x02\0\x06\
    \x12\x04\x97\x04\x114\n\r\n\x05\x04!\x02\0\x01\x12\x04\x97\x045B\n\r\n\
    \x05\x04!\x02\0\x03\x12\x04\x97\x04EF\n\x0c\n\x04\x04!\x02\x01\x12\x04\
    \x98\x04\x08E\n\r\n\x05\x04!\x02\x01\x04\x12\x04\x98\x04\x08\x10\n\r\n\
    \x05\x04!\x02\x01\x06\x12\x04\x98\x04\x114\n\r\n\x05\x04!\x02\x01\x01\
    \x12\x04\x98\x045@\n\r\n\x05\x04!\x02\x01\x03\x12\x04\x98\x04CD\n\x0c\n\
    \x04\x04!\x02\x02\x12\x04\x99\x04\x08'\n\r\n\x05\x04!\x02\x02\x04\x12\
    \x04\x99\x04\x08\x10\n\r\n\x05\x04!\x02\x02\x05\x12\x04\x99\x04\x11\x18\
    \n\r\n\x05\x04!\x02\x02\x01\x12\x04\x99\x04\x19\"\n\r\n\x05\x04!\x02\x02\
    \x03\x12\x04\x99\x04%&\n\x0c\n\x04\x04!\x02\x03\x12\x04\x9a\x04\x08,\n\r\
    \n\x05\x04!\x02\x03\x04\x12\x04\x9a\x04\x08\x10\n\r\n\x05\x04!\x02\x03\
    \x05\x12\x04\x9a\x04\x11\x18\n\r\n\x05\x04!\x02\x03\x01\x12\x04\x9a\x04\
    \x19'\n\r\n\x05\x04!\x02\x03\x03\x12\x04\x9a\x04*+\n\x0c\n\x04\x04!\x02\
    \x04\x12\x04\x9b\x04\x08\"\n\r\n\x05\x04!\x02\x04\x04\x12\x04\x9b\x04\
    \x08\x10\n\r\n\x05\x04!\x02\x04\x05\x12\x04\x9b\x04\x11\x17\n\r\n\x05\
    \x04!\x02\x04\x01\x12\x04\x9b\x04\x18\x1d\n\r\n\x05\x04!\x02\x04\x03\x12\
    \x04\x9b\x04\x20!\n\x0c\n\x04\x04!\x02\x05\x12\x04\x9c\x04\x088\n\r\n\
    \x05\x04!\x02\x05\x04\x12\x04\x9c\x04\x08\x10\n\r\n\x05\x04!\x02\x05\x05\
    \x12\x04\x9c\x04\x11\x17\n\r\n\x05\x04!\x02\x05\x01\x12\x04\x9c\x04\x183\
    \n\r\n\x05\x04!\x02\x05\x03\x12\x04\x9c\x0467\n\x0c\n\x04\x04!\x02\x06\
    \x12\x04\x9d\x04\x08\"\n\r\n\x05\x04!\x02\x06\x04\x12\x04\x9d\x04\x08\
    \x10\n\r\n\x05\x04!\x02\x06\x05\x12\x04\x9d\x04\x11\x16\n\r\n\x05\x04!\
    \x02\x06\x01\x12\x04\x9d\x04\x17\x1d\n\r\n\x05\x04!\x02\x06\x03\x12\x04\
    \x9d\x04\x20!\n\x0c\n\x04\x04!\x02\x07\x12\x04\x9e\x04\x085\n\r\n\x05\
    \x04!\x02\x07\x04\x12\x04\x9e\x04\x08\x10\n\r\n\x05\x04!\x02\x07\x05\x12\
    \x04\x9e\x04\x11\x17\n\r\n\x05\x04!\x02\x07\x01\x12\x04\x9e\x04\x180\n\r\
    \n\x05\x04!\x02\x07\x03\x12\x04\x9e\x0434\n\x0c\n\x04\x04!\x02\x08\x12\
    \x04\x9f\x04\x081\n\r\n\x05\x04!\x02\x08\x04\x12\x04\x9f\x04\x08\x10\n\r\
    \n\x05\x04!\x02\x08\x05\x12\x04\x9f\x04\x11\x18\n\r\n\x05\x04!\x02\x08\
    \x01\x12\x04\x9f\x04\x19+\n\r\n\x05\x04!\x02\x08\x03\x12\x04\x9f\x04.0\n\
    \x0c\n\x04\x04!\x02\t\x12\x04\xa0\x04\x08/\n\r\n\x05\x04!\x02\t\x04\x12\
    \x04\xa0\x04\x08\x10\n\r\n\x05\x04!\x02\t\x05\x12\x04\xa0\x04\x11\x18\n\
    \r\n\x05\x04!\x02\t\x01\x12\x04\xa0\x04\x19)\n\r\n\x05\x04!\x02\t\x03\
    \x12\x04\xa0\x04,.\n\x0c\n\x04\x04!\x02\n\x12\x04\xa1\x04\x084\n\r\n\x05\
    \x04!\x02\n\x04\x12\x04\xa1\x04\x08\x10\n\r\n\x05\x04!\x02\n\x05\x12\x04\
    \xa1\x04\x11\x18\n\r\n\x05\x04!\x02\n\x01\x12\x04\xa1\x04\x19.\n\r\n\x05\
    \x04!\x02\n\x03\x12\x04\xa1\x0413\n\x0c\n\x04\x04!\x02\x0b\x12\x04\xa2\
    \x04\x08+\n\r\n\x05\x04!\x02\x0b\x04\x12\x04\xa2\x04\x08\x10\n\r\n\x05\
    \x04!\x02\x0b\x05\x12\x04\xa2\x04\x11\x17\n\r\n\x05\x04!\x02\x0b\x01\x12\
    \x04\xa2\x04\x18%\n\r\n\x05\x04!\x02\x0b\x03\x12\x04\xa2\x04(*\n\x0c\n\
    \x04\x04!\x02\x0c\x12\x04\xa3\x04\x082\n\r\n\x05\x04!\x02\x0c\x04\x12\
    \x04\xa3\x04\x08\x10\n\r\n\x05\x04!\x02\x0c\x05\x12\x04\xa3\x04\x11\x18\
    \n\r\n\x05\x04!\x02\x0c\x01\x12\x04\xa3\x04\x19,\n\r\n\x05\x04!\x02\x0c\
    \x03\x12\x04\xa3\x04/1\n\x0c\n\x04\x04!\x02\r\x12\x04\xa4\x04\x08)\n\r\n\
    \x05\x04!\x02\r\x04\x12\x04\xa4\x04\x08\x10\n\r\n\x05\x04!\x02\r\x05\x12\
    \x04\xa4\x04\x11\x17\n\r\n\x05\x04!\x02\r\x01\x12\x04\xa4\x04\x18#\n\r\n\
    \x05\x04!\x02\r\x03\x12\x04\xa4\x04&(\n\x0c\n\x04\x04!\x02\x0e\x12\x04\
    \xa5\x04\x08)\n\r\n\x05\x04!\x02\x0e\x04\x12\x04\xa5\x04\x08\x10\n\r\n\
    \x05\x04!\x02\x0e\x05\x12\x04\xa5\x04\x11\x17\n\r\n\x05\x04!\x02\x0e\x01\
    \x12\x04\xa5\x04\x18#\n\r\n\x05\x04!\x02\x0e\x03\x12\x04\xa5\x04&(\n\x0c\
    \n\x02\x04\"\x12\x06\xa8\x04\0\xac\x04\x01\n\x0b\n\x03\x04\"\x01\x12\x04\
    \xa8\x04\x08>\n\x0c\n\x04\x04\"\x02\0\x12\x04\xa9\x04\x08&\n\r\n\x05\x04\
    \"\x02\0\x04\x12\x04\xa9\x04\x08\x10\n\r\n\x05\x04\"\x02\0\x05\x12\x04\
    \xa9\x04\x11\x17\n\r\n\x05\x04\"\x02\0\x01\x12\x04\xa9\x04\x18!\n\r\n\
    \x05\x04\"\x02\0\x03\x12\x04\xa9\x04$%\n\x0c\n\x04\x04\"\x02\x01\x12\x04\
    \xaa\x04\x08#\n\r\n\x05\x04\"\x02\x01\x04\x12\x04\xaa\x04\x08\x10\n\r\n\
    \x05\x04\"\x02\x01\x05\x12\x04\xaa\x04\x11\x17\n\r\n\x05\x04\"\x02\x01\
    \x01\x12\x04\xaa\x04\x18\x1e\n\r\n\x05\x04\"\x02\x01\x03\x12\x04\xaa\x04\
    !\"\n\x0c\n\x04\x04\"\x02\x02\x12\x04\xab\x04\x08)\n\r\n\x05\x04\"\x02\
    \x02\x04\x12\x04\xab\x04\x08\x10\n\r\n\x05\x04\"\x02\x02\x05\x12\x04\xab\
    \x04\x11\x17\n\r\n\x05\x04\"\x02\x02\x01\x12\x04\xab\x04\x18$\n\r\n\x05\
    \x04\"\x02\x02\x03\x12\x04\xab\x04'(\n\x0c\n\x02\x04#\x12\x06\xae\x04\0\
    \xaf\x04\x01\n\x0b\n\x03\x04#\x01\x12\x04\xae\x04\x08<\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(super::steamnetworkingsockets_messages_certs::file_descriptor().clone());
            deps.push(super::steamnetworkingsockets_messages::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(48);
            messages.push(CMsgSteamDatagramRouterPingReply::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramGameserverPingRequest::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramLegacyGameserverPingReply::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramGameserverPingReply::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramNoSessionRelayToClient::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramNoSessionRelayToPeer::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramClientPingSampleRequest::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramClientPingSampleReply::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramClientSwitchedPrimary::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramConnectRequest::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramConnectOK::generated_message_descriptor_data());
            messages.push(CMsgSteamNetworkingP2PSDRRoutingSummary::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramP2PRoutingSummary::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramConnectionClosed::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramNoConnection::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramGameserverSessionRequest::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramGameserverSessionEstablished::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramConnectionStatsClientToRouter::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramConnectionStatsRouterToClient::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramConnectionStatsRouterToServer::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramConnectionStatsServerToRouter::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramP2PSessionRequestBody::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramP2PSessionRequest::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramP2PSessionEstablished::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramConnectionStatsP2PClientToRouter::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramConnectionStatsP2PRouterToClient::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramP2PBadRouteRouterToClient::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramP2PRoutes::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramGameServerSample::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramGameServerSampleDataCenter::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramRelayToRelayPing::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramDataCenterState::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramRouterHealth::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramConnectionStatsP2PRouterToRouter::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramNetworkNextRouterPingRequestExtraData::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramNetworkNextRouterPingReplyExtraData::generated_message_descriptor_data());
            messages.push(cmsg_steam_datagram_router_ping_reply::RouteException::generated_message_descriptor_data());
            messages.push(cmsg_steam_datagram_router_ping_reply::AltAddress::generated_message_descriptor_data());
            messages.push(cmsg_steam_datagram_gameserver_ping_reply::SignedData::generated_message_descriptor_data());
            messages.push(cmsg_steam_datagram_client_ping_sample_reply::POP::generated_message_descriptor_data());
            messages.push(cmsg_steam_datagram_client_ping_sample_reply::LegacyDataCenter::generated_message_descriptor_data());
            messages.push(cmsg_steam_datagram_client_ping_sample_reply::pop::AltAddress::generated_message_descriptor_data());
            messages.push(cmsg_steam_datagram_client_switched_primary::RouterQuality::generated_message_descriptor_data());
            messages.push(cmsg_steam_datagram_p2proutes::RelayCluster::generated_message_descriptor_data());
            messages.push(cmsg_steam_datagram_p2proutes::Route::generated_message_descriptor_data());
            messages.push(cmsg_steam_datagram_data_center_state::Server::generated_message_descriptor_data());
            messages.push(cmsg_steam_datagram_data_center_state::DataCenter::generated_message_descriptor_data());
            messages.push(cmsg_steam_datagram_router_health::DataCenter::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(11);
            enums.push(ESteamDatagramMsgID::generated_enum_descriptor_data());
            enums.push(cmsg_steam_datagram_router_ping_reply::Flags::generated_enum_descriptor_data());
            enums.push(cmsg_steam_datagram_router_ping_reply::alt_address::Protocol::generated_enum_descriptor_data());
            enums.push(cmsg_steam_datagram_connection_closed::ERelayMode::generated_enum_descriptor_data());
            enums.push(cmsg_steam_datagram_connection_stats_client_to_router::Flags::generated_enum_descriptor_data());
            enums.push(cmsg_steam_datagram_connection_stats_router_to_client::Flags::generated_enum_descriptor_data());
            enums.push(cmsg_steam_datagram_connection_stats_router_to_server::Flags::generated_enum_descriptor_data());
            enums.push(cmsg_steam_datagram_connection_stats_server_to_router::Flags::generated_enum_descriptor_data());
            enums.push(cmsg_steam_datagram_connection_stats_p2pclient_to_router::Flags::generated_enum_descriptor_data());
            enums.push(cmsg_steam_datagram_connection_stats_p2prouter_to_client::Flags::generated_enum_descriptor_data());
            enums.push(cmsg_steam_datagram_connection_stats_p2prouter_to_router::Flags::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
