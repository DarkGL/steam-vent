// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `renderer/rendermessages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:CMsgBeginFrame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBeginFrame {
    // message fields
    // @@protoc_insertion_point(field:CMsgBeginFrame.frame_paint_time)
    pub frame_paint_time: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgBeginFrame.surface_width)
    pub surface_width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBeginFrame.surface_height)
    pub surface_height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBeginFrame.render_target)
    pub render_target: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBeginFrame.ui_scale_factor)
    pub ui_scale_factor: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgBeginFrame.empty_frame)
    pub empty_frame: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgBeginFrame.clear_gpu_resources_before_frame)
    pub clear_gpu_resources_before_frame: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBeginFrame.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBeginFrame {
    fn default() -> &'a CMsgBeginFrame {
        <CMsgBeginFrame as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBeginFrame {
    pub fn new() -> CMsgBeginFrame {
        ::std::default::Default::default()
    }

    // optional double frame_paint_time = 1;

    pub fn frame_paint_time(&self) -> f64 {
        self.frame_paint_time.unwrap_or(0.)
    }

    pub fn clear_frame_paint_time(&mut self) {
        self.frame_paint_time = ::std::option::Option::None;
    }

    pub fn has_frame_paint_time(&self) -> bool {
        self.frame_paint_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frame_paint_time(&mut self, v: f64) {
        self.frame_paint_time = ::std::option::Option::Some(v);
    }

    // optional uint32 surface_width = 2;

    pub fn surface_width(&self) -> u32 {
        self.surface_width.unwrap_or(0)
    }

    pub fn clear_surface_width(&mut self) {
        self.surface_width = ::std::option::Option::None;
    }

    pub fn has_surface_width(&self) -> bool {
        self.surface_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_surface_width(&mut self, v: u32) {
        self.surface_width = ::std::option::Option::Some(v);
    }

    // optional uint32 surface_height = 3;

    pub fn surface_height(&self) -> u32 {
        self.surface_height.unwrap_or(0)
    }

    pub fn clear_surface_height(&mut self) {
        self.surface_height = ::std::option::Option::None;
    }

    pub fn has_surface_height(&self) -> bool {
        self.surface_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_surface_height(&mut self, v: u32) {
        self.surface_height = ::std::option::Option::Some(v);
    }

    // optional uint32 render_target = 4;

    pub fn render_target(&self) -> u32 {
        self.render_target.unwrap_or(0)
    }

    pub fn clear_render_target(&mut self) {
        self.render_target = ::std::option::Option::None;
    }

    pub fn has_render_target(&self) -> bool {
        self.render_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_render_target(&mut self, v: u32) {
        self.render_target = ::std::option::Option::Some(v);
    }

    // optional double ui_scale_factor = 5;

    pub fn ui_scale_factor(&self) -> f64 {
        self.ui_scale_factor.unwrap_or(0.)
    }

    pub fn clear_ui_scale_factor(&mut self) {
        self.ui_scale_factor = ::std::option::Option::None;
    }

    pub fn has_ui_scale_factor(&self) -> bool {
        self.ui_scale_factor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ui_scale_factor(&mut self, v: f64) {
        self.ui_scale_factor = ::std::option::Option::Some(v);
    }

    // optional bool empty_frame = 6;

    pub fn empty_frame(&self) -> bool {
        self.empty_frame.unwrap_or(false)
    }

    pub fn clear_empty_frame(&mut self) {
        self.empty_frame = ::std::option::Option::None;
    }

    pub fn has_empty_frame(&self) -> bool {
        self.empty_frame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_empty_frame(&mut self, v: bool) {
        self.empty_frame = ::std::option::Option::Some(v);
    }

    // optional bool clear_gpu_resources_before_frame = 7;

    pub fn clear_gpu_resources_before_frame(&self) -> bool {
        self.clear_gpu_resources_before_frame.unwrap_or(false)
    }

    pub fn clear_clear_gpu_resources_before_frame(&mut self) {
        self.clear_gpu_resources_before_frame = ::std::option::Option::None;
    }

    pub fn has_clear_gpu_resources_before_frame(&self) -> bool {
        self.clear_gpu_resources_before_frame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clear_gpu_resources_before_frame(&mut self, v: bool) {
        self.clear_gpu_resources_before_frame = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "frame_paint_time",
            |m: &CMsgBeginFrame| { &m.frame_paint_time },
            |m: &mut CMsgBeginFrame| { &mut m.frame_paint_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "surface_width",
            |m: &CMsgBeginFrame| { &m.surface_width },
            |m: &mut CMsgBeginFrame| { &mut m.surface_width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "surface_height",
            |m: &CMsgBeginFrame| { &m.surface_height },
            |m: &mut CMsgBeginFrame| { &mut m.surface_height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "render_target",
            |m: &CMsgBeginFrame| { &m.render_target },
            |m: &mut CMsgBeginFrame| { &mut m.render_target },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ui_scale_factor",
            |m: &CMsgBeginFrame| { &m.ui_scale_factor },
            |m: &mut CMsgBeginFrame| { &mut m.ui_scale_factor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "empty_frame",
            |m: &CMsgBeginFrame| { &m.empty_frame },
            |m: &mut CMsgBeginFrame| { &mut m.empty_frame },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "clear_gpu_resources_before_frame",
            |m: &CMsgBeginFrame| { &m.clear_gpu_resources_before_frame },
            |m: &mut CMsgBeginFrame| { &mut m.clear_gpu_resources_before_frame },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBeginFrame>(
            "CMsgBeginFrame",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgBeginFrame {
    const NAME: &'static str = "CMsgBeginFrame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.frame_paint_time = ::std::option::Option::Some(is.read_double()?);
                },
                16 => {
                    self.surface_width = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.surface_height = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.render_target = ::std::option::Option::Some(is.read_uint32()?);
                },
                41 => {
                    self.ui_scale_factor = ::std::option::Option::Some(is.read_double()?);
                },
                48 => {
                    self.empty_frame = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.clear_gpu_resources_before_frame = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.frame_paint_time {
            my_size += 1 + 8;
        }
        if let Some(v) = self.surface_width {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.surface_height {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.render_target {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.ui_scale_factor {
            my_size += 1 + 8;
        }
        if let Some(v) = self.empty_frame {
            my_size += 1 + 1;
        }
        if let Some(v) = self.clear_gpu_resources_before_frame {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.frame_paint_time {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.surface_width {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.surface_height {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.render_target {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.ui_scale_factor {
            os.write_double(5, v)?;
        }
        if let Some(v) = self.empty_frame {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.clear_gpu_resources_before_frame {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBeginFrame {
        CMsgBeginFrame::new()
    }

    fn clear(&mut self) {
        self.frame_paint_time = ::std::option::Option::None;
        self.surface_width = ::std::option::Option::None;
        self.surface_height = ::std::option::Option::None;
        self.render_target = ::std::option::Option::None;
        self.ui_scale_factor = ::std::option::Option::None;
        self.empty_frame = ::std::option::Option::None;
        self.clear_gpu_resources_before_frame = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBeginFrame {
        static instance: CMsgBeginFrame = CMsgBeginFrame {
            frame_paint_time: ::std::option::Option::None,
            surface_width: ::std::option::Option::None,
            surface_height: ::std::option::Option::None,
            render_target: ::std::option::Option::None,
            ui_scale_factor: ::std::option::Option::None,
            empty_frame: ::std::option::Option::None,
            clear_gpu_resources_before_frame: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgBeginFrame {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBeginFrame").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBeginFrame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBeginFrame {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgEndFrame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgEndFrame {
    // message fields
    // @@protoc_insertion_point(field:CMsgEndFrame.mouse_cursor_texture_id)
    pub mouse_cursor_texture_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgEndFrame.mouse_cursor_hotspot_x)
    pub mouse_cursor_hotspot_x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgEndFrame.mouse_cursor_hotspot_y)
    pub mouse_cursor_hotspot_y: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgEndFrame.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgEndFrame {
    fn default() -> &'a CMsgEndFrame {
        <CMsgEndFrame as ::protobuf::Message>::default_instance()
    }
}

impl CMsgEndFrame {
    pub fn new() -> CMsgEndFrame {
        ::std::default::Default::default()
    }

    // optional uint32 mouse_cursor_texture_id = 1;

    pub fn mouse_cursor_texture_id(&self) -> u32 {
        self.mouse_cursor_texture_id.unwrap_or(0)
    }

    pub fn clear_mouse_cursor_texture_id(&mut self) {
        self.mouse_cursor_texture_id = ::std::option::Option::None;
    }

    pub fn has_mouse_cursor_texture_id(&self) -> bool {
        self.mouse_cursor_texture_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mouse_cursor_texture_id(&mut self, v: u32) {
        self.mouse_cursor_texture_id = ::std::option::Option::Some(v);
    }

    // optional float mouse_cursor_hotspot_x = 2;

    pub fn mouse_cursor_hotspot_x(&self) -> f32 {
        self.mouse_cursor_hotspot_x.unwrap_or(0.)
    }

    pub fn clear_mouse_cursor_hotspot_x(&mut self) {
        self.mouse_cursor_hotspot_x = ::std::option::Option::None;
    }

    pub fn has_mouse_cursor_hotspot_x(&self) -> bool {
        self.mouse_cursor_hotspot_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mouse_cursor_hotspot_x(&mut self, v: f32) {
        self.mouse_cursor_hotspot_x = ::std::option::Option::Some(v);
    }

    // optional float mouse_cursor_hotspot_y = 3;

    pub fn mouse_cursor_hotspot_y(&self) -> f32 {
        self.mouse_cursor_hotspot_y.unwrap_or(0.)
    }

    pub fn clear_mouse_cursor_hotspot_y(&mut self) {
        self.mouse_cursor_hotspot_y = ::std::option::Option::None;
    }

    pub fn has_mouse_cursor_hotspot_y(&self) -> bool {
        self.mouse_cursor_hotspot_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mouse_cursor_hotspot_y(&mut self, v: f32) {
        self.mouse_cursor_hotspot_y = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mouse_cursor_texture_id",
            |m: &CMsgEndFrame| { &m.mouse_cursor_texture_id },
            |m: &mut CMsgEndFrame| { &mut m.mouse_cursor_texture_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mouse_cursor_hotspot_x",
            |m: &CMsgEndFrame| { &m.mouse_cursor_hotspot_x },
            |m: &mut CMsgEndFrame| { &mut m.mouse_cursor_hotspot_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mouse_cursor_hotspot_y",
            |m: &CMsgEndFrame| { &m.mouse_cursor_hotspot_y },
            |m: &mut CMsgEndFrame| { &mut m.mouse_cursor_hotspot_y },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgEndFrame>(
            "CMsgEndFrame",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgEndFrame {
    const NAME: &'static str = "CMsgEndFrame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mouse_cursor_texture_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.mouse_cursor_hotspot_x = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.mouse_cursor_hotspot_y = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mouse_cursor_texture_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.mouse_cursor_hotspot_x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.mouse_cursor_hotspot_y {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.mouse_cursor_texture_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.mouse_cursor_hotspot_x {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.mouse_cursor_hotspot_y {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgEndFrame {
        CMsgEndFrame::new()
    }

    fn clear(&mut self) {
        self.mouse_cursor_texture_id = ::std::option::Option::None;
        self.mouse_cursor_hotspot_x = ::std::option::Option::None;
        self.mouse_cursor_hotspot_y = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgEndFrame {
        static instance: CMsgEndFrame = CMsgEndFrame {
            mouse_cursor_texture_id: ::std::option::Option::None,
            mouse_cursor_hotspot_x: ::std::option::Option::None,
            mouse_cursor_hotspot_y: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgEndFrame {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgEndFrame").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgEndFrame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgEndFrame {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClearBackbuffer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClearBackbuffer {
    // message fields
    // @@protoc_insertion_point(field:CMsgClearBackbuffer.clear_color_rgba)
    pub clear_color_rgba: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClearBackbuffer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClearBackbuffer {
    fn default() -> &'a CMsgClearBackbuffer {
        <CMsgClearBackbuffer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClearBackbuffer {
    pub fn new() -> CMsgClearBackbuffer {
        ::std::default::Default::default()
    }

    // optional uint32 clear_color_rgba = 1;

    pub fn clear_color_rgba(&self) -> u32 {
        self.clear_color_rgba.unwrap_or(0)
    }

    pub fn clear_clear_color_rgba(&mut self) {
        self.clear_color_rgba = ::std::option::Option::None;
    }

    pub fn has_clear_color_rgba(&self) -> bool {
        self.clear_color_rgba.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clear_color_rgba(&mut self, v: u32) {
        self.clear_color_rgba = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "clear_color_rgba",
            |m: &CMsgClearBackbuffer| { &m.clear_color_rgba },
            |m: &mut CMsgClearBackbuffer| { &mut m.clear_color_rgba },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClearBackbuffer>(
            "CMsgClearBackbuffer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClearBackbuffer {
    const NAME: &'static str = "CMsgClearBackbuffer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.clear_color_rgba = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.clear_color_rgba {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.clear_color_rgba {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClearBackbuffer {
        CMsgClearBackbuffer::new()
    }

    fn clear(&mut self) {
        self.clear_color_rgba = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClearBackbuffer {
        static instance: CMsgClearBackbuffer = CMsgClearBackbuffer {
            clear_color_rgba: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClearBackbuffer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClearBackbuffer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClearBackbuffer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClearBackbuffer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgDeleteTexture)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDeleteTexture {
    // message fields
    // @@protoc_insertion_point(field:CMsgDeleteTexture.texture_pointer)
    pub texture_pointer: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDeleteTexture.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDeleteTexture {
    fn default() -> &'a CMsgDeleteTexture {
        <CMsgDeleteTexture as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDeleteTexture {
    pub fn new() -> CMsgDeleteTexture {
        ::std::default::Default::default()
    }

    // optional uint64 texture_pointer = 1;

    pub fn texture_pointer(&self) -> u64 {
        self.texture_pointer.unwrap_or(0)
    }

    pub fn clear_texture_pointer(&mut self) {
        self.texture_pointer = ::std::option::Option::None;
    }

    pub fn has_texture_pointer(&self) -> bool {
        self.texture_pointer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_texture_pointer(&mut self, v: u64) {
        self.texture_pointer = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "texture_pointer",
            |m: &CMsgDeleteTexture| { &m.texture_pointer },
            |m: &mut CMsgDeleteTexture| { &mut m.texture_pointer },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDeleteTexture>(
            "CMsgDeleteTexture",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDeleteTexture {
    const NAME: &'static str = "CMsgDeleteTexture";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.texture_pointer = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.texture_pointer {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.texture_pointer {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDeleteTexture {
        CMsgDeleteTexture::new()
    }

    fn clear(&mut self) {
        self.texture_pointer = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDeleteTexture {
        static instance: CMsgDeleteTexture = CMsgDeleteTexture {
            texture_pointer: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDeleteTexture {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDeleteTexture").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDeleteTexture {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDeleteTexture {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgDeletePanel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDeletePanel {
    // message fields
    // @@protoc_insertion_point(field:CMsgDeletePanel.context_id)
    pub context_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDeletePanel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDeletePanel {
    fn default() -> &'a CMsgDeletePanel {
        <CMsgDeletePanel as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDeletePanel {
    pub fn new() -> CMsgDeletePanel {
        ::std::default::Default::default()
    }

    // optional uint64 context_id = 1;

    pub fn context_id(&self) -> u64 {
        self.context_id.unwrap_or(0)
    }

    pub fn clear_context_id(&mut self) {
        self.context_id = ::std::option::Option::None;
    }

    pub fn has_context_id(&self) -> bool {
        self.context_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context_id(&mut self, v: u64) {
        self.context_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "context_id",
            |m: &CMsgDeletePanel| { &m.context_id },
            |m: &mut CMsgDeletePanel| { &mut m.context_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDeletePanel>(
            "CMsgDeletePanel",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDeletePanel {
    const NAME: &'static str = "CMsgDeletePanel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.context_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.context_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.context_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDeletePanel {
        CMsgDeletePanel::new()
    }

    fn clear(&mut self) {
        self.context_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDeletePanel {
        static instance: CMsgDeletePanel = CMsgDeletePanel {
            context_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDeletePanel {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDeletePanel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDeletePanel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDeletePanel {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgDeleteParticleSystem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDeleteParticleSystem {
    // message fields
    // @@protoc_insertion_point(field:CMsgDeleteParticleSystem.panel_handle)
    pub panel_handle: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgDeleteParticleSystem.brush_index)
    pub brush_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDeleteParticleSystem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDeleteParticleSystem {
    fn default() -> &'a CMsgDeleteParticleSystem {
        <CMsgDeleteParticleSystem as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDeleteParticleSystem {
    pub fn new() -> CMsgDeleteParticleSystem {
        ::std::default::Default::default()
    }

    // optional uint64 panel_handle = 1;

    pub fn panel_handle(&self) -> u64 {
        self.panel_handle.unwrap_or(0)
    }

    pub fn clear_panel_handle(&mut self) {
        self.panel_handle = ::std::option::Option::None;
    }

    pub fn has_panel_handle(&self) -> bool {
        self.panel_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_panel_handle(&mut self, v: u64) {
        self.panel_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 brush_index = 2;

    pub fn brush_index(&self) -> u32 {
        self.brush_index.unwrap_or(0)
    }

    pub fn clear_brush_index(&mut self) {
        self.brush_index = ::std::option::Option::None;
    }

    pub fn has_brush_index(&self) -> bool {
        self.brush_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_brush_index(&mut self, v: u32) {
        self.brush_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "panel_handle",
            |m: &CMsgDeleteParticleSystem| { &m.panel_handle },
            |m: &mut CMsgDeleteParticleSystem| { &mut m.panel_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "brush_index",
            |m: &CMsgDeleteParticleSystem| { &m.brush_index },
            |m: &mut CMsgDeleteParticleSystem| { &mut m.brush_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDeleteParticleSystem>(
            "CMsgDeleteParticleSystem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDeleteParticleSystem {
    const NAME: &'static str = "CMsgDeleteParticleSystem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.panel_handle = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.brush_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.panel_handle {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.brush_index {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.panel_handle {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.brush_index {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDeleteParticleSystem {
        CMsgDeleteParticleSystem::new()
    }

    fn clear(&mut self) {
        self.panel_handle = ::std::option::Option::None;
        self.brush_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDeleteParticleSystem {
        static instance: CMsgDeleteParticleSystem = CMsgDeleteParticleSystem {
            panel_handle: ::std::option::Option::None,
            brush_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDeleteParticleSystem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDeleteParticleSystem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDeleteParticleSystem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDeleteParticleSystem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPoint)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPoint {
    // message fields
    // @@protoc_insertion_point(field:CMsgPoint.x)
    pub x: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPoint.y)
    pub y: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPoint.z)
    pub z: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPoint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPoint {
    fn default() -> &'a CMsgPoint {
        <CMsgPoint as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPoint {
    pub fn new() -> CMsgPoint {
        ::std::default::Default::default()
    }

    // optional double x = 1;

    pub fn x(&self) -> f64 {
        self.x.unwrap_or(0.)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f64) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional double y = 2;

    pub fn y(&self) -> f64 {
        self.y.unwrap_or(0.)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f64) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional double z = 3;

    pub fn z(&self) -> f64 {
        self.z.unwrap_or(0.)
    }

    pub fn clear_z(&mut self) {
        self.z = ::std::option::Option::None;
    }

    pub fn has_z(&self) -> bool {
        self.z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_z(&mut self, v: f64) {
        self.z = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &CMsgPoint| { &m.x },
            |m: &mut CMsgPoint| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &CMsgPoint| { &m.y },
            |m: &mut CMsgPoint| { &mut m.y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "z",
            |m: &CMsgPoint| { &m.z },
            |m: &mut CMsgPoint| { &mut m.z },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPoint>(
            "CMsgPoint",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPoint {
    const NAME: &'static str = "CMsgPoint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.x = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.y = ::std::option::Option::Some(is.read_double()?);
                },
                25 => {
                    self.z = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.x {
            my_size += 1 + 8;
        }
        if let Some(v) = self.y {
            my_size += 1 + 8;
        }
        if let Some(v) = self.z {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.x {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.y {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.z {
            os.write_double(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPoint {
        CMsgPoint::new()
    }

    fn clear(&mut self) {
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.z = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPoint {
        static instance: CMsgPoint = CMsgPoint {
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            z: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPoint {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPoint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPoint {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgMatrix4x4)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMatrix4x4 {
    // message fields
    // @@protoc_insertion_point(field:CMsgMatrix4x4.m00)
    pub m00: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgMatrix4x4.m01)
    pub m01: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgMatrix4x4.m02)
    pub m02: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgMatrix4x4.m03)
    pub m03: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgMatrix4x4.m10)
    pub m10: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgMatrix4x4.m11)
    pub m11: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgMatrix4x4.m12)
    pub m12: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgMatrix4x4.m13)
    pub m13: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgMatrix4x4.m20)
    pub m20: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgMatrix4x4.m21)
    pub m21: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgMatrix4x4.m22)
    pub m22: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgMatrix4x4.m23)
    pub m23: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgMatrix4x4.m30)
    pub m30: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgMatrix4x4.m31)
    pub m31: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgMatrix4x4.m32)
    pub m32: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgMatrix4x4.m33)
    pub m33: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMatrix4x4.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMatrix4x4 {
    fn default() -> &'a CMsgMatrix4x4 {
        <CMsgMatrix4x4 as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMatrix4x4 {
    pub fn new() -> CMsgMatrix4x4 {
        ::std::default::Default::default()
    }

    // optional double m00 = 1;

    pub fn m00(&self) -> f64 {
        self.m00.unwrap_or(0.)
    }

    pub fn clear_m00(&mut self) {
        self.m00 = ::std::option::Option::None;
    }

    pub fn has_m00(&self) -> bool {
        self.m00.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m00(&mut self, v: f64) {
        self.m00 = ::std::option::Option::Some(v);
    }

    // optional double m01 = 2;

    pub fn m01(&self) -> f64 {
        self.m01.unwrap_or(0.)
    }

    pub fn clear_m01(&mut self) {
        self.m01 = ::std::option::Option::None;
    }

    pub fn has_m01(&self) -> bool {
        self.m01.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m01(&mut self, v: f64) {
        self.m01 = ::std::option::Option::Some(v);
    }

    // optional double m02 = 3;

    pub fn m02(&self) -> f64 {
        self.m02.unwrap_or(0.)
    }

    pub fn clear_m02(&mut self) {
        self.m02 = ::std::option::Option::None;
    }

    pub fn has_m02(&self) -> bool {
        self.m02.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m02(&mut self, v: f64) {
        self.m02 = ::std::option::Option::Some(v);
    }

    // optional double m03 = 4;

    pub fn m03(&self) -> f64 {
        self.m03.unwrap_or(0.)
    }

    pub fn clear_m03(&mut self) {
        self.m03 = ::std::option::Option::None;
    }

    pub fn has_m03(&self) -> bool {
        self.m03.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m03(&mut self, v: f64) {
        self.m03 = ::std::option::Option::Some(v);
    }

    // optional double m10 = 5;

    pub fn m10(&self) -> f64 {
        self.m10.unwrap_or(0.)
    }

    pub fn clear_m10(&mut self) {
        self.m10 = ::std::option::Option::None;
    }

    pub fn has_m10(&self) -> bool {
        self.m10.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m10(&mut self, v: f64) {
        self.m10 = ::std::option::Option::Some(v);
    }

    // optional double m11 = 6;

    pub fn m11(&self) -> f64 {
        self.m11.unwrap_or(0.)
    }

    pub fn clear_m11(&mut self) {
        self.m11 = ::std::option::Option::None;
    }

    pub fn has_m11(&self) -> bool {
        self.m11.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m11(&mut self, v: f64) {
        self.m11 = ::std::option::Option::Some(v);
    }

    // optional double m12 = 7;

    pub fn m12(&self) -> f64 {
        self.m12.unwrap_or(0.)
    }

    pub fn clear_m12(&mut self) {
        self.m12 = ::std::option::Option::None;
    }

    pub fn has_m12(&self) -> bool {
        self.m12.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m12(&mut self, v: f64) {
        self.m12 = ::std::option::Option::Some(v);
    }

    // optional double m13 = 8;

    pub fn m13(&self) -> f64 {
        self.m13.unwrap_or(0.)
    }

    pub fn clear_m13(&mut self) {
        self.m13 = ::std::option::Option::None;
    }

    pub fn has_m13(&self) -> bool {
        self.m13.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m13(&mut self, v: f64) {
        self.m13 = ::std::option::Option::Some(v);
    }

    // optional double m20 = 9;

    pub fn m20(&self) -> f64 {
        self.m20.unwrap_or(0.)
    }

    pub fn clear_m20(&mut self) {
        self.m20 = ::std::option::Option::None;
    }

    pub fn has_m20(&self) -> bool {
        self.m20.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m20(&mut self, v: f64) {
        self.m20 = ::std::option::Option::Some(v);
    }

    // optional double m21 = 10;

    pub fn m21(&self) -> f64 {
        self.m21.unwrap_or(0.)
    }

    pub fn clear_m21(&mut self) {
        self.m21 = ::std::option::Option::None;
    }

    pub fn has_m21(&self) -> bool {
        self.m21.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m21(&mut self, v: f64) {
        self.m21 = ::std::option::Option::Some(v);
    }

    // optional double m22 = 11;

    pub fn m22(&self) -> f64 {
        self.m22.unwrap_or(0.)
    }

    pub fn clear_m22(&mut self) {
        self.m22 = ::std::option::Option::None;
    }

    pub fn has_m22(&self) -> bool {
        self.m22.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m22(&mut self, v: f64) {
        self.m22 = ::std::option::Option::Some(v);
    }

    // optional double m23 = 12;

    pub fn m23(&self) -> f64 {
        self.m23.unwrap_or(0.)
    }

    pub fn clear_m23(&mut self) {
        self.m23 = ::std::option::Option::None;
    }

    pub fn has_m23(&self) -> bool {
        self.m23.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m23(&mut self, v: f64) {
        self.m23 = ::std::option::Option::Some(v);
    }

    // optional double m30 = 13;

    pub fn m30(&self) -> f64 {
        self.m30.unwrap_or(0.)
    }

    pub fn clear_m30(&mut self) {
        self.m30 = ::std::option::Option::None;
    }

    pub fn has_m30(&self) -> bool {
        self.m30.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m30(&mut self, v: f64) {
        self.m30 = ::std::option::Option::Some(v);
    }

    // optional double m31 = 14;

    pub fn m31(&self) -> f64 {
        self.m31.unwrap_or(0.)
    }

    pub fn clear_m31(&mut self) {
        self.m31 = ::std::option::Option::None;
    }

    pub fn has_m31(&self) -> bool {
        self.m31.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m31(&mut self, v: f64) {
        self.m31 = ::std::option::Option::Some(v);
    }

    // optional double m32 = 15;

    pub fn m32(&self) -> f64 {
        self.m32.unwrap_or(0.)
    }

    pub fn clear_m32(&mut self) {
        self.m32 = ::std::option::Option::None;
    }

    pub fn has_m32(&self) -> bool {
        self.m32.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m32(&mut self, v: f64) {
        self.m32 = ::std::option::Option::Some(v);
    }

    // optional double m33 = 16;

    pub fn m33(&self) -> f64 {
        self.m33.unwrap_or(0.)
    }

    pub fn clear_m33(&mut self) {
        self.m33 = ::std::option::Option::None;
    }

    pub fn has_m33(&self) -> bool {
        self.m33.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m33(&mut self, v: f64) {
        self.m33 = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(16);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "m00",
            |m: &CMsgMatrix4x4| { &m.m00 },
            |m: &mut CMsgMatrix4x4| { &mut m.m00 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "m01",
            |m: &CMsgMatrix4x4| { &m.m01 },
            |m: &mut CMsgMatrix4x4| { &mut m.m01 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "m02",
            |m: &CMsgMatrix4x4| { &m.m02 },
            |m: &mut CMsgMatrix4x4| { &mut m.m02 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "m03",
            |m: &CMsgMatrix4x4| { &m.m03 },
            |m: &mut CMsgMatrix4x4| { &mut m.m03 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "m10",
            |m: &CMsgMatrix4x4| { &m.m10 },
            |m: &mut CMsgMatrix4x4| { &mut m.m10 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "m11",
            |m: &CMsgMatrix4x4| { &m.m11 },
            |m: &mut CMsgMatrix4x4| { &mut m.m11 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "m12",
            |m: &CMsgMatrix4x4| { &m.m12 },
            |m: &mut CMsgMatrix4x4| { &mut m.m12 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "m13",
            |m: &CMsgMatrix4x4| { &m.m13 },
            |m: &mut CMsgMatrix4x4| { &mut m.m13 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "m20",
            |m: &CMsgMatrix4x4| { &m.m20 },
            |m: &mut CMsgMatrix4x4| { &mut m.m20 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "m21",
            |m: &CMsgMatrix4x4| { &m.m21 },
            |m: &mut CMsgMatrix4x4| { &mut m.m21 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "m22",
            |m: &CMsgMatrix4x4| { &m.m22 },
            |m: &mut CMsgMatrix4x4| { &mut m.m22 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "m23",
            |m: &CMsgMatrix4x4| { &m.m23 },
            |m: &mut CMsgMatrix4x4| { &mut m.m23 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "m30",
            |m: &CMsgMatrix4x4| { &m.m30 },
            |m: &mut CMsgMatrix4x4| { &mut m.m30 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "m31",
            |m: &CMsgMatrix4x4| { &m.m31 },
            |m: &mut CMsgMatrix4x4| { &mut m.m31 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "m32",
            |m: &CMsgMatrix4x4| { &m.m32 },
            |m: &mut CMsgMatrix4x4| { &mut m.m32 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "m33",
            |m: &CMsgMatrix4x4| { &m.m33 },
            |m: &mut CMsgMatrix4x4| { &mut m.m33 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgMatrix4x4>(
            "CMsgMatrix4x4",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgMatrix4x4 {
    const NAME: &'static str = "CMsgMatrix4x4";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.m00 = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.m01 = ::std::option::Option::Some(is.read_double()?);
                },
                25 => {
                    self.m02 = ::std::option::Option::Some(is.read_double()?);
                },
                33 => {
                    self.m03 = ::std::option::Option::Some(is.read_double()?);
                },
                41 => {
                    self.m10 = ::std::option::Option::Some(is.read_double()?);
                },
                49 => {
                    self.m11 = ::std::option::Option::Some(is.read_double()?);
                },
                57 => {
                    self.m12 = ::std::option::Option::Some(is.read_double()?);
                },
                65 => {
                    self.m13 = ::std::option::Option::Some(is.read_double()?);
                },
                73 => {
                    self.m20 = ::std::option::Option::Some(is.read_double()?);
                },
                81 => {
                    self.m21 = ::std::option::Option::Some(is.read_double()?);
                },
                89 => {
                    self.m22 = ::std::option::Option::Some(is.read_double()?);
                },
                97 => {
                    self.m23 = ::std::option::Option::Some(is.read_double()?);
                },
                105 => {
                    self.m30 = ::std::option::Option::Some(is.read_double()?);
                },
                113 => {
                    self.m31 = ::std::option::Option::Some(is.read_double()?);
                },
                121 => {
                    self.m32 = ::std::option::Option::Some(is.read_double()?);
                },
                129 => {
                    self.m33 = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.m00 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.m01 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.m02 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.m03 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.m10 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.m11 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.m12 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.m13 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.m20 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.m21 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.m22 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.m23 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.m30 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.m31 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.m32 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.m33 {
            my_size += 2 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.m00 {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.m01 {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.m02 {
            os.write_double(3, v)?;
        }
        if let Some(v) = self.m03 {
            os.write_double(4, v)?;
        }
        if let Some(v) = self.m10 {
            os.write_double(5, v)?;
        }
        if let Some(v) = self.m11 {
            os.write_double(6, v)?;
        }
        if let Some(v) = self.m12 {
            os.write_double(7, v)?;
        }
        if let Some(v) = self.m13 {
            os.write_double(8, v)?;
        }
        if let Some(v) = self.m20 {
            os.write_double(9, v)?;
        }
        if let Some(v) = self.m21 {
            os.write_double(10, v)?;
        }
        if let Some(v) = self.m22 {
            os.write_double(11, v)?;
        }
        if let Some(v) = self.m23 {
            os.write_double(12, v)?;
        }
        if let Some(v) = self.m30 {
            os.write_double(13, v)?;
        }
        if let Some(v) = self.m31 {
            os.write_double(14, v)?;
        }
        if let Some(v) = self.m32 {
            os.write_double(15, v)?;
        }
        if let Some(v) = self.m33 {
            os.write_double(16, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMatrix4x4 {
        CMsgMatrix4x4::new()
    }

    fn clear(&mut self) {
        self.m00 = ::std::option::Option::None;
        self.m01 = ::std::option::Option::None;
        self.m02 = ::std::option::Option::None;
        self.m03 = ::std::option::Option::None;
        self.m10 = ::std::option::Option::None;
        self.m11 = ::std::option::Option::None;
        self.m12 = ::std::option::Option::None;
        self.m13 = ::std::option::Option::None;
        self.m20 = ::std::option::Option::None;
        self.m21 = ::std::option::Option::None;
        self.m22 = ::std::option::Option::None;
        self.m23 = ::std::option::Option::None;
        self.m30 = ::std::option::Option::None;
        self.m31 = ::std::option::Option::None;
        self.m32 = ::std::option::Option::None;
        self.m33 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMatrix4x4 {
        static instance: CMsgMatrix4x4 = CMsgMatrix4x4 {
            m00: ::std::option::Option::None,
            m01: ::std::option::Option::None,
            m02: ::std::option::Option::None,
            m03: ::std::option::Option::None,
            m10: ::std::option::Option::None,
            m11: ::std::option::Option::None,
            m12: ::std::option::Option::None,
            m13: ::std::option::Option::None,
            m20: ::std::option::Option::None,
            m21: ::std::option::Option::None,
            m22: ::std::option::Option::None,
            m23: ::std::option::Option::None,
            m30: ::std::option::Option::None,
            m31: ::std::option::Option::None,
            m32: ::std::option::Option::None,
            m33: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgMatrix4x4 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgMatrix4x4").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgMatrix4x4 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMatrix4x4 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CRadiusData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CRadiusData {
    // message fields
    // @@protoc_insertion_point(field:CRadiusData.top_left)
    pub top_left: ::protobuf::MessageField<cradius_data::CCornerRadius>,
    // @@protoc_insertion_point(field:CRadiusData.top_right)
    pub top_right: ::protobuf::MessageField<cradius_data::CCornerRadius>,
    // @@protoc_insertion_point(field:CRadiusData.bottom_right)
    pub bottom_right: ::protobuf::MessageField<cradius_data::CCornerRadius>,
    // @@protoc_insertion_point(field:CRadiusData.bottom_left)
    pub bottom_left: ::protobuf::MessageField<cradius_data::CCornerRadius>,
    // special fields
    // @@protoc_insertion_point(special_field:CRadiusData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CRadiusData {
    fn default() -> &'a CRadiusData {
        <CRadiusData as ::protobuf::Message>::default_instance()
    }
}

impl CRadiusData {
    pub fn new() -> CRadiusData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cradius_data::CCornerRadius>(
            "top_left",
            |m: &CRadiusData| { &m.top_left },
            |m: &mut CRadiusData| { &mut m.top_left },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cradius_data::CCornerRadius>(
            "top_right",
            |m: &CRadiusData| { &m.top_right },
            |m: &mut CRadiusData| { &mut m.top_right },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cradius_data::CCornerRadius>(
            "bottom_right",
            |m: &CRadiusData| { &m.bottom_right },
            |m: &mut CRadiusData| { &mut m.bottom_right },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cradius_data::CCornerRadius>(
            "bottom_left",
            |m: &CRadiusData| { &m.bottom_left },
            |m: &mut CRadiusData| { &mut m.bottom_left },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CRadiusData>(
            "CRadiusData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CRadiusData {
    const NAME: &'static str = "CRadiusData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.top_left)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.top_right)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bottom_right)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bottom_left)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.top_left.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.top_right.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bottom_right.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bottom_left.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.top_left.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.top_right.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.bottom_right.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.bottom_left.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CRadiusData {
        CRadiusData::new()
    }

    fn clear(&mut self) {
        self.top_left.clear();
        self.top_right.clear();
        self.bottom_right.clear();
        self.bottom_left.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CRadiusData {
        static instance: CRadiusData = CRadiusData {
            top_left: ::protobuf::MessageField::none(),
            top_right: ::protobuf::MessageField::none(),
            bottom_right: ::protobuf::MessageField::none(),
            bottom_left: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CRadiusData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CRadiusData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CRadiusData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CRadiusData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CRadiusData`
pub mod cradius_data {
    // @@protoc_insertion_point(message:CRadiusData.CCornerRadius)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CCornerRadius {
        // message fields
        // @@protoc_insertion_point(field:CRadiusData.CCornerRadius.horizontal)
        pub horizontal: ::std::option::Option<f64>,
        // @@protoc_insertion_point(field:CRadiusData.CCornerRadius.vertical)
        pub vertical: ::std::option::Option<f64>,
        // special fields
        // @@protoc_insertion_point(special_field:CRadiusData.CCornerRadius.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CCornerRadius {
        fn default() -> &'a CCornerRadius {
            <CCornerRadius as ::protobuf::Message>::default_instance()
        }
    }

    impl CCornerRadius {
        pub fn new() -> CCornerRadius {
            ::std::default::Default::default()
        }

        // optional double horizontal = 1;

        pub fn horizontal(&self) -> f64 {
            self.horizontal.unwrap_or(0.)
        }

        pub fn clear_horizontal(&mut self) {
            self.horizontal = ::std::option::Option::None;
        }

        pub fn has_horizontal(&self) -> bool {
            self.horizontal.is_some()
        }

        // Param is passed by value, moved
        pub fn set_horizontal(&mut self, v: f64) {
            self.horizontal = ::std::option::Option::Some(v);
        }

        // optional double vertical = 2;

        pub fn vertical(&self) -> f64 {
            self.vertical.unwrap_or(0.)
        }

        pub fn clear_vertical(&mut self) {
            self.vertical = ::std::option::Option::None;
        }

        pub fn has_vertical(&self) -> bool {
            self.vertical.is_some()
        }

        // Param is passed by value, moved
        pub fn set_vertical(&mut self, v: f64) {
            self.vertical = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "horizontal",
                |m: &CCornerRadius| { &m.horizontal },
                |m: &mut CCornerRadius| { &mut m.horizontal },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "vertical",
                |m: &CCornerRadius| { &m.vertical },
                |m: &mut CCornerRadius| { &mut m.vertical },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCornerRadius>(
                "CRadiusData.CCornerRadius",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CCornerRadius {
        const NAME: &'static str = "CCornerRadius";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.horizontal = ::std::option::Option::Some(is.read_double()?);
                    },
                    17 => {
                        self.vertical = ::std::option::Option::Some(is.read_double()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.horizontal {
                my_size += 1 + 8;
            }
            if let Some(v) = self.vertical {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.horizontal {
                os.write_double(1, v)?;
            }
            if let Some(v) = self.vertical {
                os.write_double(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CCornerRadius {
            CCornerRadius::new()
        }

        fn clear(&mut self) {
            self.horizontal = ::std::option::Option::None;
            self.vertical = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CCornerRadius {
            static instance: CCornerRadius = CCornerRadius {
                horizontal: ::std::option::Option::None,
                vertical: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CCornerRadius {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CRadiusData.CCornerRadius").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CCornerRadius {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CCornerRadius {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CBorderData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBorderData {
    // message fields
    // @@protoc_insertion_point(field:CBorderData.top)
    pub top: ::protobuf::MessageField<cborder_data::CBorderSide>,
    // @@protoc_insertion_point(field:CBorderData.right)
    pub right: ::protobuf::MessageField<cborder_data::CBorderSide>,
    // @@protoc_insertion_point(field:CBorderData.bottom)
    pub bottom: ::protobuf::MessageField<cborder_data::CBorderSide>,
    // @@protoc_insertion_point(field:CBorderData.left)
    pub left: ::protobuf::MessageField<cborder_data::CBorderSide>,
    // special fields
    // @@protoc_insertion_point(special_field:CBorderData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBorderData {
    fn default() -> &'a CBorderData {
        <CBorderData as ::protobuf::Message>::default_instance()
    }
}

impl CBorderData {
    pub fn new() -> CBorderData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cborder_data::CBorderSide>(
            "top",
            |m: &CBorderData| { &m.top },
            |m: &mut CBorderData| { &mut m.top },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cborder_data::CBorderSide>(
            "right",
            |m: &CBorderData| { &m.right },
            |m: &mut CBorderData| { &mut m.right },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cborder_data::CBorderSide>(
            "bottom",
            |m: &CBorderData| { &m.bottom },
            |m: &mut CBorderData| { &mut m.bottom },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cborder_data::CBorderSide>(
            "left",
            |m: &CBorderData| { &m.left },
            |m: &mut CBorderData| { &mut m.left },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CBorderData>(
            "CBorderData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CBorderData {
    const NAME: &'static str = "CBorderData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.top)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.right)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bottom)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.left)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.top.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.right.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bottom.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.left.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.top.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.right.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.bottom.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.left.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBorderData {
        CBorderData::new()
    }

    fn clear(&mut self) {
        self.top.clear();
        self.right.clear();
        self.bottom.clear();
        self.left.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBorderData {
        static instance: CBorderData = CBorderData {
            top: ::protobuf::MessageField::none(),
            right: ::protobuf::MessageField::none(),
            bottom: ::protobuf::MessageField::none(),
            left: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CBorderData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CBorderData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CBorderData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBorderData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CBorderData`
pub mod cborder_data {
    // @@protoc_insertion_point(message:CBorderData.CBorderSide)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CBorderSide {
        // message fields
        // @@protoc_insertion_point(field:CBorderData.CBorderSide.style)
        pub style: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CBorderData.CBorderSide.width)
        pub width: ::std::option::Option<f64>,
        // @@protoc_insertion_point(field:CBorderData.CBorderSide.color)
        pub color: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CBorderData.CBorderSide.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CBorderSide {
        fn default() -> &'a CBorderSide {
            <CBorderSide as ::protobuf::Message>::default_instance()
        }
    }

    impl CBorderSide {
        pub fn new() -> CBorderSide {
            ::std::default::Default::default()
        }

        // optional uint32 style = 1;

        pub fn style(&self) -> u32 {
            self.style.unwrap_or(0)
        }

        pub fn clear_style(&mut self) {
            self.style = ::std::option::Option::None;
        }

        pub fn has_style(&self) -> bool {
            self.style.is_some()
        }

        // Param is passed by value, moved
        pub fn set_style(&mut self, v: u32) {
            self.style = ::std::option::Option::Some(v);
        }

        // optional double width = 2;

        pub fn width(&self) -> f64 {
            self.width.unwrap_or(0.)
        }

        pub fn clear_width(&mut self) {
            self.width = ::std::option::Option::None;
        }

        pub fn has_width(&self) -> bool {
            self.width.is_some()
        }

        // Param is passed by value, moved
        pub fn set_width(&mut self, v: f64) {
            self.width = ::std::option::Option::Some(v);
        }

        // optional uint32 color = 3;

        pub fn color(&self) -> u32 {
            self.color.unwrap_or(0)
        }

        pub fn clear_color(&mut self) {
            self.color = ::std::option::Option::None;
        }

        pub fn has_color(&self) -> bool {
            self.color.is_some()
        }

        // Param is passed by value, moved
        pub fn set_color(&mut self, v: u32) {
            self.color = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "style",
                |m: &CBorderSide| { &m.style },
                |m: &mut CBorderSide| { &mut m.style },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "width",
                |m: &CBorderSide| { &m.width },
                |m: &mut CBorderSide| { &mut m.width },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "color",
                |m: &CBorderSide| { &m.color },
                |m: &mut CBorderSide| { &mut m.color },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CBorderSide>(
                "CBorderData.CBorderSide",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CBorderSide {
        const NAME: &'static str = "CBorderSide";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.style = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    17 => {
                        self.width = ::std::option::Option::Some(is.read_double()?);
                    },
                    24 => {
                        self.color = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.style {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.width {
                my_size += 1 + 8;
            }
            if let Some(v) = self.color {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.style {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.width {
                os.write_double(2, v)?;
            }
            if let Some(v) = self.color {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CBorderSide {
            CBorderSide::new()
        }

        fn clear(&mut self) {
            self.style = ::std::option::Option::None;
            self.width = ::std::option::Option::None;
            self.color = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CBorderSide {
            static instance: CBorderSide = CBorderSide {
                style: ::std::option::Option::None,
                width: ::std::option::Option::None,
                color: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CBorderSide {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CBorderData.CBorderSide").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CBorderSide {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CBorderSide {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CBoxShadowData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBoxShadowData {
    // message fields
    // @@protoc_insertion_point(field:CBoxShadowData.inset)
    pub inset: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CBoxShadowData.horizontal_offset)
    pub horizontal_offset: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CBoxShadowData.vertical_offset)
    pub vertical_offset: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CBoxShadowData.blur_radius)
    pub blur_radius: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CBoxShadowData.spread_distance)
    pub spread_distance: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CBoxShadowData.color)
    pub color: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBoxShadowData.fill)
    pub fill: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CBoxShadowData.animating)
    pub animating: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CBoxShadowData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBoxShadowData {
    fn default() -> &'a CBoxShadowData {
        <CBoxShadowData as ::protobuf::Message>::default_instance()
    }
}

impl CBoxShadowData {
    pub fn new() -> CBoxShadowData {
        ::std::default::Default::default()
    }

    // optional bool inset = 1;

    pub fn inset(&self) -> bool {
        self.inset.unwrap_or(false)
    }

    pub fn clear_inset(&mut self) {
        self.inset = ::std::option::Option::None;
    }

    pub fn has_inset(&self) -> bool {
        self.inset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inset(&mut self, v: bool) {
        self.inset = ::std::option::Option::Some(v);
    }

    // optional double horizontal_offset = 2;

    pub fn horizontal_offset(&self) -> f64 {
        self.horizontal_offset.unwrap_or(0.)
    }

    pub fn clear_horizontal_offset(&mut self) {
        self.horizontal_offset = ::std::option::Option::None;
    }

    pub fn has_horizontal_offset(&self) -> bool {
        self.horizontal_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_horizontal_offset(&mut self, v: f64) {
        self.horizontal_offset = ::std::option::Option::Some(v);
    }

    // optional double vertical_offset = 3;

    pub fn vertical_offset(&self) -> f64 {
        self.vertical_offset.unwrap_or(0.)
    }

    pub fn clear_vertical_offset(&mut self) {
        self.vertical_offset = ::std::option::Option::None;
    }

    pub fn has_vertical_offset(&self) -> bool {
        self.vertical_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vertical_offset(&mut self, v: f64) {
        self.vertical_offset = ::std::option::Option::Some(v);
    }

    // optional double blur_radius = 4;

    pub fn blur_radius(&self) -> f64 {
        self.blur_radius.unwrap_or(0.)
    }

    pub fn clear_blur_radius(&mut self) {
        self.blur_radius = ::std::option::Option::None;
    }

    pub fn has_blur_radius(&self) -> bool {
        self.blur_radius.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blur_radius(&mut self, v: f64) {
        self.blur_radius = ::std::option::Option::Some(v);
    }

    // optional double spread_distance = 5;

    pub fn spread_distance(&self) -> f64 {
        self.spread_distance.unwrap_or(0.)
    }

    pub fn clear_spread_distance(&mut self) {
        self.spread_distance = ::std::option::Option::None;
    }

    pub fn has_spread_distance(&self) -> bool {
        self.spread_distance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spread_distance(&mut self, v: f64) {
        self.spread_distance = ::std::option::Option::Some(v);
    }

    // optional uint32 color = 6;

    pub fn color(&self) -> u32 {
        self.color.unwrap_or(0)
    }

    pub fn clear_color(&mut self) {
        self.color = ::std::option::Option::None;
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: u32) {
        self.color = ::std::option::Option::Some(v);
    }

    // optional bool fill = 7;

    pub fn fill(&self) -> bool {
        self.fill.unwrap_or(false)
    }

    pub fn clear_fill(&mut self) {
        self.fill = ::std::option::Option::None;
    }

    pub fn has_fill(&self) -> bool {
        self.fill.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fill(&mut self, v: bool) {
        self.fill = ::std::option::Option::Some(v);
    }

    // optional bool animating = 8;

    pub fn animating(&self) -> bool {
        self.animating.unwrap_or(false)
    }

    pub fn clear_animating(&mut self) {
        self.animating = ::std::option::Option::None;
    }

    pub fn has_animating(&self) -> bool {
        self.animating.is_some()
    }

    // Param is passed by value, moved
    pub fn set_animating(&mut self, v: bool) {
        self.animating = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "inset",
            |m: &CBoxShadowData| { &m.inset },
            |m: &mut CBoxShadowData| { &mut m.inset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "horizontal_offset",
            |m: &CBoxShadowData| { &m.horizontal_offset },
            |m: &mut CBoxShadowData| { &mut m.horizontal_offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vertical_offset",
            |m: &CBoxShadowData| { &m.vertical_offset },
            |m: &mut CBoxShadowData| { &mut m.vertical_offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "blur_radius",
            |m: &CBoxShadowData| { &m.blur_radius },
            |m: &mut CBoxShadowData| { &mut m.blur_radius },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "spread_distance",
            |m: &CBoxShadowData| { &m.spread_distance },
            |m: &mut CBoxShadowData| { &mut m.spread_distance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "color",
            |m: &CBoxShadowData| { &m.color },
            |m: &mut CBoxShadowData| { &mut m.color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fill",
            |m: &CBoxShadowData| { &m.fill },
            |m: &mut CBoxShadowData| { &mut m.fill },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "animating",
            |m: &CBoxShadowData| { &m.animating },
            |m: &mut CBoxShadowData| { &mut m.animating },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CBoxShadowData>(
            "CBoxShadowData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CBoxShadowData {
    const NAME: &'static str = "CBoxShadowData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.inset = ::std::option::Option::Some(is.read_bool()?);
                },
                17 => {
                    self.horizontal_offset = ::std::option::Option::Some(is.read_double()?);
                },
                25 => {
                    self.vertical_offset = ::std::option::Option::Some(is.read_double()?);
                },
                33 => {
                    self.blur_radius = ::std::option::Option::Some(is.read_double()?);
                },
                41 => {
                    self.spread_distance = ::std::option::Option::Some(is.read_double()?);
                },
                48 => {
                    self.color = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.fill = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.animating = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.inset {
            my_size += 1 + 1;
        }
        if let Some(v) = self.horizontal_offset {
            my_size += 1 + 8;
        }
        if let Some(v) = self.vertical_offset {
            my_size += 1 + 8;
        }
        if let Some(v) = self.blur_radius {
            my_size += 1 + 8;
        }
        if let Some(v) = self.spread_distance {
            my_size += 1 + 8;
        }
        if let Some(v) = self.color {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.fill {
            my_size += 1 + 1;
        }
        if let Some(v) = self.animating {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.inset {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.horizontal_offset {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.vertical_offset {
            os.write_double(3, v)?;
        }
        if let Some(v) = self.blur_radius {
            os.write_double(4, v)?;
        }
        if let Some(v) = self.spread_distance {
            os.write_double(5, v)?;
        }
        if let Some(v) = self.color {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.fill {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.animating {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBoxShadowData {
        CBoxShadowData::new()
    }

    fn clear(&mut self) {
        self.inset = ::std::option::Option::None;
        self.horizontal_offset = ::std::option::Option::None;
        self.vertical_offset = ::std::option::Option::None;
        self.blur_radius = ::std::option::Option::None;
        self.spread_distance = ::std::option::Option::None;
        self.color = ::std::option::Option::None;
        self.fill = ::std::option::Option::None;
        self.animating = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBoxShadowData {
        static instance: CBoxShadowData = CBoxShadowData {
            inset: ::std::option::Option::None,
            horizontal_offset: ::std::option::Option::None,
            vertical_offset: ::std::option::Option::None,
            blur_radius: ::std::option::Option::None,
            spread_distance: ::std::option::Option::None,
            color: ::std::option::Option::None,
            fill: ::std::option::Option::None,
            animating: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CBoxShadowData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CBoxShadowData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CBoxShadowData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBoxShadowData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CTextShadowData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CTextShadowData {
    // message fields
    // @@protoc_insertion_point(field:CTextShadowData.horizontal_offset)
    pub horizontal_offset: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CTextShadowData.vertical_offset)
    pub vertical_offset: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CTextShadowData.blur_radius)
    pub blur_radius: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CTextShadowData.color)
    pub color: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CTextShadowData.animating)
    pub animating: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CTextShadowData.strength)
    pub strength: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:CTextShadowData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CTextShadowData {
    fn default() -> &'a CTextShadowData {
        <CTextShadowData as ::protobuf::Message>::default_instance()
    }
}

impl CTextShadowData {
    pub fn new() -> CTextShadowData {
        ::std::default::Default::default()
    }

    // optional double horizontal_offset = 2;

    pub fn horizontal_offset(&self) -> f64 {
        self.horizontal_offset.unwrap_or(0.)
    }

    pub fn clear_horizontal_offset(&mut self) {
        self.horizontal_offset = ::std::option::Option::None;
    }

    pub fn has_horizontal_offset(&self) -> bool {
        self.horizontal_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_horizontal_offset(&mut self, v: f64) {
        self.horizontal_offset = ::std::option::Option::Some(v);
    }

    // optional double vertical_offset = 3;

    pub fn vertical_offset(&self) -> f64 {
        self.vertical_offset.unwrap_or(0.)
    }

    pub fn clear_vertical_offset(&mut self) {
        self.vertical_offset = ::std::option::Option::None;
    }

    pub fn has_vertical_offset(&self) -> bool {
        self.vertical_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vertical_offset(&mut self, v: f64) {
        self.vertical_offset = ::std::option::Option::Some(v);
    }

    // optional double blur_radius = 4;

    pub fn blur_radius(&self) -> f64 {
        self.blur_radius.unwrap_or(0.)
    }

    pub fn clear_blur_radius(&mut self) {
        self.blur_radius = ::std::option::Option::None;
    }

    pub fn has_blur_radius(&self) -> bool {
        self.blur_radius.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blur_radius(&mut self, v: f64) {
        self.blur_radius = ::std::option::Option::Some(v);
    }

    // optional uint32 color = 6;

    pub fn color(&self) -> u32 {
        self.color.unwrap_or(0)
    }

    pub fn clear_color(&mut self) {
        self.color = ::std::option::Option::None;
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: u32) {
        self.color = ::std::option::Option::Some(v);
    }

    // optional bool animating = 8;

    pub fn animating(&self) -> bool {
        self.animating.unwrap_or(false)
    }

    pub fn clear_animating(&mut self) {
        self.animating = ::std::option::Option::None;
    }

    pub fn has_animating(&self) -> bool {
        self.animating.is_some()
    }

    // Param is passed by value, moved
    pub fn set_animating(&mut self, v: bool) {
        self.animating = ::std::option::Option::Some(v);
    }

    // optional double strength = 9;

    pub fn strength(&self) -> f64 {
        self.strength.unwrap_or(0.)
    }

    pub fn clear_strength(&mut self) {
        self.strength = ::std::option::Option::None;
    }

    pub fn has_strength(&self) -> bool {
        self.strength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strength(&mut self, v: f64) {
        self.strength = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "horizontal_offset",
            |m: &CTextShadowData| { &m.horizontal_offset },
            |m: &mut CTextShadowData| { &mut m.horizontal_offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vertical_offset",
            |m: &CTextShadowData| { &m.vertical_offset },
            |m: &mut CTextShadowData| { &mut m.vertical_offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "blur_radius",
            |m: &CTextShadowData| { &m.blur_radius },
            |m: &mut CTextShadowData| { &mut m.blur_radius },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "color",
            |m: &CTextShadowData| { &m.color },
            |m: &mut CTextShadowData| { &mut m.color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "animating",
            |m: &CTextShadowData| { &m.animating },
            |m: &mut CTextShadowData| { &mut m.animating },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "strength",
            |m: &CTextShadowData| { &m.strength },
            |m: &mut CTextShadowData| { &mut m.strength },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CTextShadowData>(
            "CTextShadowData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CTextShadowData {
    const NAME: &'static str = "CTextShadowData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                17 => {
                    self.horizontal_offset = ::std::option::Option::Some(is.read_double()?);
                },
                25 => {
                    self.vertical_offset = ::std::option::Option::Some(is.read_double()?);
                },
                33 => {
                    self.blur_radius = ::std::option::Option::Some(is.read_double()?);
                },
                48 => {
                    self.color = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.animating = ::std::option::Option::Some(is.read_bool()?);
                },
                73 => {
                    self.strength = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.horizontal_offset {
            my_size += 1 + 8;
        }
        if let Some(v) = self.vertical_offset {
            my_size += 1 + 8;
        }
        if let Some(v) = self.blur_radius {
            my_size += 1 + 8;
        }
        if let Some(v) = self.color {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.animating {
            my_size += 1 + 1;
        }
        if let Some(v) = self.strength {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.horizontal_offset {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.vertical_offset {
            os.write_double(3, v)?;
        }
        if let Some(v) = self.blur_radius {
            os.write_double(4, v)?;
        }
        if let Some(v) = self.color {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.animating {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.strength {
            os.write_double(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CTextShadowData {
        CTextShadowData::new()
    }

    fn clear(&mut self) {
        self.horizontal_offset = ::std::option::Option::None;
        self.vertical_offset = ::std::option::Option::None;
        self.blur_radius = ::std::option::Option::None;
        self.color = ::std::option::Option::None;
        self.animating = ::std::option::Option::None;
        self.strength = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CTextShadowData {
        static instance: CTextShadowData = CTextShadowData {
            horizontal_offset: ::std::option::Option::None,
            vertical_offset: ::std::option::Option::None,
            blur_radius: ::std::option::Option::None,
            color: ::std::option::Option::None,
            animating: ::std::option::Option::None,
            strength: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CTextShadowData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CTextShadowData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CTextShadowData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CTextShadowData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CRadialClipData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CRadialClipData {
    // message fields
    // @@protoc_insertion_point(field:CRadialClipData.center_x)
    pub center_x: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CRadialClipData.center_y)
    pub center_y: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CRadialClipData.start_angle)
    pub start_angle: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CRadialClipData.sector_angle)
    pub sector_angle: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:CRadialClipData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CRadialClipData {
    fn default() -> &'a CRadialClipData {
        <CRadialClipData as ::protobuf::Message>::default_instance()
    }
}

impl CRadialClipData {
    pub fn new() -> CRadialClipData {
        ::std::default::Default::default()
    }

    // optional double center_x = 1;

    pub fn center_x(&self) -> f64 {
        self.center_x.unwrap_or(0.)
    }

    pub fn clear_center_x(&mut self) {
        self.center_x = ::std::option::Option::None;
    }

    pub fn has_center_x(&self) -> bool {
        self.center_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_center_x(&mut self, v: f64) {
        self.center_x = ::std::option::Option::Some(v);
    }

    // optional double center_y = 2;

    pub fn center_y(&self) -> f64 {
        self.center_y.unwrap_or(0.)
    }

    pub fn clear_center_y(&mut self) {
        self.center_y = ::std::option::Option::None;
    }

    pub fn has_center_y(&self) -> bool {
        self.center_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_center_y(&mut self, v: f64) {
        self.center_y = ::std::option::Option::Some(v);
    }

    // optional double start_angle = 3;

    pub fn start_angle(&self) -> f64 {
        self.start_angle.unwrap_or(0.)
    }

    pub fn clear_start_angle(&mut self) {
        self.start_angle = ::std::option::Option::None;
    }

    pub fn has_start_angle(&self) -> bool {
        self.start_angle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_angle(&mut self, v: f64) {
        self.start_angle = ::std::option::Option::Some(v);
    }

    // optional double sector_angle = 4;

    pub fn sector_angle(&self) -> f64 {
        self.sector_angle.unwrap_or(0.)
    }

    pub fn clear_sector_angle(&mut self) {
        self.sector_angle = ::std::option::Option::None;
    }

    pub fn has_sector_angle(&self) -> bool {
        self.sector_angle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sector_angle(&mut self, v: f64) {
        self.sector_angle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "center_x",
            |m: &CRadialClipData| { &m.center_x },
            |m: &mut CRadialClipData| { &mut m.center_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "center_y",
            |m: &CRadialClipData| { &m.center_y },
            |m: &mut CRadialClipData| { &mut m.center_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_angle",
            |m: &CRadialClipData| { &m.start_angle },
            |m: &mut CRadialClipData| { &mut m.start_angle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sector_angle",
            |m: &CRadialClipData| { &m.sector_angle },
            |m: &mut CRadialClipData| { &mut m.sector_angle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CRadialClipData>(
            "CRadialClipData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CRadialClipData {
    const NAME: &'static str = "CRadialClipData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.center_x = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.center_y = ::std::option::Option::Some(is.read_double()?);
                },
                25 => {
                    self.start_angle = ::std::option::Option::Some(is.read_double()?);
                },
                33 => {
                    self.sector_angle = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.center_x {
            my_size += 1 + 8;
        }
        if let Some(v) = self.center_y {
            my_size += 1 + 8;
        }
        if let Some(v) = self.start_angle {
            my_size += 1 + 8;
        }
        if let Some(v) = self.sector_angle {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.center_x {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.center_y {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.start_angle {
            os.write_double(3, v)?;
        }
        if let Some(v) = self.sector_angle {
            os.write_double(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CRadialClipData {
        CRadialClipData::new()
    }

    fn clear(&mut self) {
        self.center_x = ::std::option::Option::None;
        self.center_y = ::std::option::Option::None;
        self.start_angle = ::std::option::Option::None;
        self.sector_angle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CRadialClipData {
        static instance: CRadialClipData = CRadialClipData {
            center_x: ::std::option::Option::None,
            center_y: ::std::option::Option::None,
            start_angle: ::std::option::Option::None,
            sector_angle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CRadialClipData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CRadialClipData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CRadialClipData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CRadialClipData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClipData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClipData {
    // message fields
    // @@protoc_insertion_point(field:CMsgClipData.rect_clip)
    pub rect_clip: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClipData.left)
    pub left: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgClipData.top)
    pub top: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgClipData.right)
    pub right: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgClipData.bottom)
    pub bottom: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgClipData.radial_clip)
    pub radial_clip: ::protobuf::MessageField<CRadialClipData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClipData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClipData {
    fn default() -> &'a CMsgClipData {
        <CMsgClipData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClipData {
    pub fn new() -> CMsgClipData {
        ::std::default::Default::default()
    }

    // optional bool rect_clip = 1;

    pub fn rect_clip(&self) -> bool {
        self.rect_clip.unwrap_or(false)
    }

    pub fn clear_rect_clip(&mut self) {
        self.rect_clip = ::std::option::Option::None;
    }

    pub fn has_rect_clip(&self) -> bool {
        self.rect_clip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rect_clip(&mut self, v: bool) {
        self.rect_clip = ::std::option::Option::Some(v);
    }

    // optional double left = 2;

    pub fn left(&self) -> f64 {
        self.left.unwrap_or(0.)
    }

    pub fn clear_left(&mut self) {
        self.left = ::std::option::Option::None;
    }

    pub fn has_left(&self) -> bool {
        self.left.is_some()
    }

    // Param is passed by value, moved
    pub fn set_left(&mut self, v: f64) {
        self.left = ::std::option::Option::Some(v);
    }

    // optional double top = 3;

    pub fn top(&self) -> f64 {
        self.top.unwrap_or(0.)
    }

    pub fn clear_top(&mut self) {
        self.top = ::std::option::Option::None;
    }

    pub fn has_top(&self) -> bool {
        self.top.is_some()
    }

    // Param is passed by value, moved
    pub fn set_top(&mut self, v: f64) {
        self.top = ::std::option::Option::Some(v);
    }

    // optional double right = 4;

    pub fn right(&self) -> f64 {
        self.right.unwrap_or(0.)
    }

    pub fn clear_right(&mut self) {
        self.right = ::std::option::Option::None;
    }

    pub fn has_right(&self) -> bool {
        self.right.is_some()
    }

    // Param is passed by value, moved
    pub fn set_right(&mut self, v: f64) {
        self.right = ::std::option::Option::Some(v);
    }

    // optional double bottom = 5;

    pub fn bottom(&self) -> f64 {
        self.bottom.unwrap_or(0.)
    }

    pub fn clear_bottom(&mut self) {
        self.bottom = ::std::option::Option::None;
    }

    pub fn has_bottom(&self) -> bool {
        self.bottom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bottom(&mut self, v: f64) {
        self.bottom = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rect_clip",
            |m: &CMsgClipData| { &m.rect_clip },
            |m: &mut CMsgClipData| { &mut m.rect_clip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "left",
            |m: &CMsgClipData| { &m.left },
            |m: &mut CMsgClipData| { &mut m.left },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "top",
            |m: &CMsgClipData| { &m.top },
            |m: &mut CMsgClipData| { &mut m.top },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "right",
            |m: &CMsgClipData| { &m.right },
            |m: &mut CMsgClipData| { &mut m.right },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bottom",
            |m: &CMsgClipData| { &m.bottom },
            |m: &mut CMsgClipData| { &mut m.bottom },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CRadialClipData>(
            "radial_clip",
            |m: &CMsgClipData| { &m.radial_clip },
            |m: &mut CMsgClipData| { &mut m.radial_clip },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClipData>(
            "CMsgClipData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClipData {
    const NAME: &'static str = "CMsgClipData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.rect_clip = ::std::option::Option::Some(is.read_bool()?);
                },
                17 => {
                    self.left = ::std::option::Option::Some(is.read_double()?);
                },
                25 => {
                    self.top = ::std::option::Option::Some(is.read_double()?);
                },
                33 => {
                    self.right = ::std::option::Option::Some(is.read_double()?);
                },
                41 => {
                    self.bottom = ::std::option::Option::Some(is.read_double()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.radial_clip)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rect_clip {
            my_size += 1 + 1;
        }
        if let Some(v) = self.left {
            my_size += 1 + 8;
        }
        if let Some(v) = self.top {
            my_size += 1 + 8;
        }
        if let Some(v) = self.right {
            my_size += 1 + 8;
        }
        if let Some(v) = self.bottom {
            my_size += 1 + 8;
        }
        if let Some(v) = self.radial_clip.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.rect_clip {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.left {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.top {
            os.write_double(3, v)?;
        }
        if let Some(v) = self.right {
            os.write_double(4, v)?;
        }
        if let Some(v) = self.bottom {
            os.write_double(5, v)?;
        }
        if let Some(v) = self.radial_clip.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClipData {
        CMsgClipData::new()
    }

    fn clear(&mut self) {
        self.rect_clip = ::std::option::Option::None;
        self.left = ::std::option::Option::None;
        self.top = ::std::option::Option::None;
        self.right = ::std::option::Option::None;
        self.bottom = ::std::option::Option::None;
        self.radial_clip.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClipData {
        static instance: CMsgClipData = CMsgClipData {
            rect_clip: ::std::option::Option::None,
            left: ::std::option::Option::None,
            top: ::std::option::Option::None,
            right: ::std::option::Option::None,
            bottom: ::std::option::Option::None,
            radial_clip: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClipData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClipData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClipData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClipData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPushCompositingLayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPushCompositingLayer {
    // message fields
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.layer_id)
    pub layer_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.width)
    pub width: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.height)
    pub height: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.layer_quad_top_left_x)
    pub layer_quad_top_left_x: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.layer_quad_top_left_y)
    pub layer_quad_top_left_y: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.layer_quad_top_left_z)
    pub layer_quad_top_left_z: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.layer_quad_top_right_x)
    pub layer_quad_top_right_x: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.layer_quad_top_right_y)
    pub layer_quad_top_right_y: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.layer_quad_top_right_z)
    pub layer_quad_top_right_z: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.layer_quad_bottom_left_x)
    pub layer_quad_bottom_left_x: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.layer_quad_bottom_left_y)
    pub layer_quad_bottom_left_y: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.layer_quad_bottom_left_z)
    pub layer_quad_bottom_left_z: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.layer_quad_bottom_right_x)
    pub layer_quad_bottom_right_x: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.layer_quad_bottom_right_y)
    pub layer_quad_bottom_right_y: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.layer_quad_bottom_right_z)
    pub layer_quad_bottom_right_z: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.transform_m00)
    pub transform_m00: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.transform_m01)
    pub transform_m01: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.transform_m02)
    pub transform_m02: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.transform_m03)
    pub transform_m03: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.transform_m10)
    pub transform_m10: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.transform_m11)
    pub transform_m11: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.transform_m12)
    pub transform_m12: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.transform_m13)
    pub transform_m13: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.transform_m20)
    pub transform_m20: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.transform_m21)
    pub transform_m21: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.transform_m22)
    pub transform_m22: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.transform_m23)
    pub transform_m23: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.transform_m30)
    pub transform_m30: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.transform_m31)
    pub transform_m31: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.transform_m32)
    pub transform_m32: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.transform_m33)
    pub transform_m33: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.perspective_depth)
    pub perspective_depth: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.opacity)
    pub opacity: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.composition_color)
    pub composition_color: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.saturation)
    pub saturation: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.hue_shift)
    pub hue_shift: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.brightness)
    pub brightness: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.contrast)
    pub contrast: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.opacity_mask_texture_id)
    pub opacity_mask_texture_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.opacity_mask_opacity)
    pub opacity_mask_opacity: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.border)
    pub border: ::protobuf::MessageField<CBorderData>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.border_radius)
    pub border_radius: ::protobuf::MessageField<CRadiusData>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.box_shadow)
    pub box_shadow: ::protobuf::MessageField<CBoxShadowData>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.gaussianblur_passes)
    pub gaussianblur_passes: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.gaussianblur_stddevhor)
    pub gaussianblur_stddevhor: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.gaussianblur_stddevver)
    pub gaussianblur_stddevver: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.scale_2d_factors_x)
    pub scale_2d_factors_x: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.scale_2d_factors_y)
    pub scale_2d_factors_y: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.rotate_2d)
    pub rotate_2d: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.needs_clear)
    pub needs_clear: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.needs_depth)
    pub needs_depth: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.needs_intermediate_texture)
    pub needs_intermediate_texture: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.needs_redraw_every_frame)
    pub needs_redraw_every_frame: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.text_shadow)
    pub text_shadow: ::protobuf::MessageField<CTextShadowData>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.mix_blend_mode)
    pub mix_blend_mode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.occluded_left_edge)
    pub occluded_left_edge: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.occluded_top_edge)
    pub occluded_top_edge: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.occluded_right_edge)
    pub occluded_right_edge: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.occluded_bottom_edge)
    pub occluded_bottom_edge: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.radial_clip)
    pub radial_clip: ::protobuf::MessageField<CRadialClipData>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.motionblur_velocity)
    pub motionblur_velocity: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.motionblur_dirx)
    pub motionblur_dirx: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.motionblur_diry)
    pub motionblur_diry: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushCompositingLayer.composition_layer_texture_name)
    pub composition_layer_texture_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPushCompositingLayer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPushCompositingLayer {
    fn default() -> &'a CMsgPushCompositingLayer {
        <CMsgPushCompositingLayer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPushCompositingLayer {
    pub fn new() -> CMsgPushCompositingLayer {
        ::std::default::Default::default()
    }

    // optional uint64 layer_id = 1;

    pub fn layer_id(&self) -> u64 {
        self.layer_id.unwrap_or(0)
    }

    pub fn clear_layer_id(&mut self) {
        self.layer_id = ::std::option::Option::None;
    }

    pub fn has_layer_id(&self) -> bool {
        self.layer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layer_id(&mut self, v: u64) {
        self.layer_id = ::std::option::Option::Some(v);
    }

    // optional double width = 2;

    pub fn width(&self) -> f64 {
        self.width.unwrap_or(0.)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: f64) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional double height = 3;

    pub fn height(&self) -> f64 {
        self.height.unwrap_or(0.)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: f64) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional double layer_quad_top_left_x = 4;

    pub fn layer_quad_top_left_x(&self) -> f64 {
        self.layer_quad_top_left_x.unwrap_or(0.)
    }

    pub fn clear_layer_quad_top_left_x(&mut self) {
        self.layer_quad_top_left_x = ::std::option::Option::None;
    }

    pub fn has_layer_quad_top_left_x(&self) -> bool {
        self.layer_quad_top_left_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layer_quad_top_left_x(&mut self, v: f64) {
        self.layer_quad_top_left_x = ::std::option::Option::Some(v);
    }

    // optional double layer_quad_top_left_y = 5;

    pub fn layer_quad_top_left_y(&self) -> f64 {
        self.layer_quad_top_left_y.unwrap_or(0.)
    }

    pub fn clear_layer_quad_top_left_y(&mut self) {
        self.layer_quad_top_left_y = ::std::option::Option::None;
    }

    pub fn has_layer_quad_top_left_y(&self) -> bool {
        self.layer_quad_top_left_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layer_quad_top_left_y(&mut self, v: f64) {
        self.layer_quad_top_left_y = ::std::option::Option::Some(v);
    }

    // optional double layer_quad_top_left_z = 6;

    pub fn layer_quad_top_left_z(&self) -> f64 {
        self.layer_quad_top_left_z.unwrap_or(0.)
    }

    pub fn clear_layer_quad_top_left_z(&mut self) {
        self.layer_quad_top_left_z = ::std::option::Option::None;
    }

    pub fn has_layer_quad_top_left_z(&self) -> bool {
        self.layer_quad_top_left_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layer_quad_top_left_z(&mut self, v: f64) {
        self.layer_quad_top_left_z = ::std::option::Option::Some(v);
    }

    // optional double layer_quad_top_right_x = 7;

    pub fn layer_quad_top_right_x(&self) -> f64 {
        self.layer_quad_top_right_x.unwrap_or(0.)
    }

    pub fn clear_layer_quad_top_right_x(&mut self) {
        self.layer_quad_top_right_x = ::std::option::Option::None;
    }

    pub fn has_layer_quad_top_right_x(&self) -> bool {
        self.layer_quad_top_right_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layer_quad_top_right_x(&mut self, v: f64) {
        self.layer_quad_top_right_x = ::std::option::Option::Some(v);
    }

    // optional double layer_quad_top_right_y = 8;

    pub fn layer_quad_top_right_y(&self) -> f64 {
        self.layer_quad_top_right_y.unwrap_or(0.)
    }

    pub fn clear_layer_quad_top_right_y(&mut self) {
        self.layer_quad_top_right_y = ::std::option::Option::None;
    }

    pub fn has_layer_quad_top_right_y(&self) -> bool {
        self.layer_quad_top_right_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layer_quad_top_right_y(&mut self, v: f64) {
        self.layer_quad_top_right_y = ::std::option::Option::Some(v);
    }

    // optional double layer_quad_top_right_z = 9;

    pub fn layer_quad_top_right_z(&self) -> f64 {
        self.layer_quad_top_right_z.unwrap_or(0.)
    }

    pub fn clear_layer_quad_top_right_z(&mut self) {
        self.layer_quad_top_right_z = ::std::option::Option::None;
    }

    pub fn has_layer_quad_top_right_z(&self) -> bool {
        self.layer_quad_top_right_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layer_quad_top_right_z(&mut self, v: f64) {
        self.layer_quad_top_right_z = ::std::option::Option::Some(v);
    }

    // optional double layer_quad_bottom_left_x = 10;

    pub fn layer_quad_bottom_left_x(&self) -> f64 {
        self.layer_quad_bottom_left_x.unwrap_or(0.)
    }

    pub fn clear_layer_quad_bottom_left_x(&mut self) {
        self.layer_quad_bottom_left_x = ::std::option::Option::None;
    }

    pub fn has_layer_quad_bottom_left_x(&self) -> bool {
        self.layer_quad_bottom_left_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layer_quad_bottom_left_x(&mut self, v: f64) {
        self.layer_quad_bottom_left_x = ::std::option::Option::Some(v);
    }

    // optional double layer_quad_bottom_left_y = 11;

    pub fn layer_quad_bottom_left_y(&self) -> f64 {
        self.layer_quad_bottom_left_y.unwrap_or(0.)
    }

    pub fn clear_layer_quad_bottom_left_y(&mut self) {
        self.layer_quad_bottom_left_y = ::std::option::Option::None;
    }

    pub fn has_layer_quad_bottom_left_y(&self) -> bool {
        self.layer_quad_bottom_left_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layer_quad_bottom_left_y(&mut self, v: f64) {
        self.layer_quad_bottom_left_y = ::std::option::Option::Some(v);
    }

    // optional double layer_quad_bottom_left_z = 12;

    pub fn layer_quad_bottom_left_z(&self) -> f64 {
        self.layer_quad_bottom_left_z.unwrap_or(0.)
    }

    pub fn clear_layer_quad_bottom_left_z(&mut self) {
        self.layer_quad_bottom_left_z = ::std::option::Option::None;
    }

    pub fn has_layer_quad_bottom_left_z(&self) -> bool {
        self.layer_quad_bottom_left_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layer_quad_bottom_left_z(&mut self, v: f64) {
        self.layer_quad_bottom_left_z = ::std::option::Option::Some(v);
    }

    // optional double layer_quad_bottom_right_x = 13;

    pub fn layer_quad_bottom_right_x(&self) -> f64 {
        self.layer_quad_bottom_right_x.unwrap_or(0.)
    }

    pub fn clear_layer_quad_bottom_right_x(&mut self) {
        self.layer_quad_bottom_right_x = ::std::option::Option::None;
    }

    pub fn has_layer_quad_bottom_right_x(&self) -> bool {
        self.layer_quad_bottom_right_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layer_quad_bottom_right_x(&mut self, v: f64) {
        self.layer_quad_bottom_right_x = ::std::option::Option::Some(v);
    }

    // optional double layer_quad_bottom_right_y = 14;

    pub fn layer_quad_bottom_right_y(&self) -> f64 {
        self.layer_quad_bottom_right_y.unwrap_or(0.)
    }

    pub fn clear_layer_quad_bottom_right_y(&mut self) {
        self.layer_quad_bottom_right_y = ::std::option::Option::None;
    }

    pub fn has_layer_quad_bottom_right_y(&self) -> bool {
        self.layer_quad_bottom_right_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layer_quad_bottom_right_y(&mut self, v: f64) {
        self.layer_quad_bottom_right_y = ::std::option::Option::Some(v);
    }

    // optional double layer_quad_bottom_right_z = 15;

    pub fn layer_quad_bottom_right_z(&self) -> f64 {
        self.layer_quad_bottom_right_z.unwrap_or(0.)
    }

    pub fn clear_layer_quad_bottom_right_z(&mut self) {
        self.layer_quad_bottom_right_z = ::std::option::Option::None;
    }

    pub fn has_layer_quad_bottom_right_z(&self) -> bool {
        self.layer_quad_bottom_right_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layer_quad_bottom_right_z(&mut self, v: f64) {
        self.layer_quad_bottom_right_z = ::std::option::Option::Some(v);
    }

    // optional double transform_m00 = 16;

    pub fn transform_m00(&self) -> f64 {
        self.transform_m00.unwrap_or(0.)
    }

    pub fn clear_transform_m00(&mut self) {
        self.transform_m00 = ::std::option::Option::None;
    }

    pub fn has_transform_m00(&self) -> bool {
        self.transform_m00.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m00(&mut self, v: f64) {
        self.transform_m00 = ::std::option::Option::Some(v);
    }

    // optional double transform_m01 = 17;

    pub fn transform_m01(&self) -> f64 {
        self.transform_m01.unwrap_or(0.)
    }

    pub fn clear_transform_m01(&mut self) {
        self.transform_m01 = ::std::option::Option::None;
    }

    pub fn has_transform_m01(&self) -> bool {
        self.transform_m01.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m01(&mut self, v: f64) {
        self.transform_m01 = ::std::option::Option::Some(v);
    }

    // optional double transform_m02 = 18;

    pub fn transform_m02(&self) -> f64 {
        self.transform_m02.unwrap_or(0.)
    }

    pub fn clear_transform_m02(&mut self) {
        self.transform_m02 = ::std::option::Option::None;
    }

    pub fn has_transform_m02(&self) -> bool {
        self.transform_m02.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m02(&mut self, v: f64) {
        self.transform_m02 = ::std::option::Option::Some(v);
    }

    // optional double transform_m03 = 19;

    pub fn transform_m03(&self) -> f64 {
        self.transform_m03.unwrap_or(0.)
    }

    pub fn clear_transform_m03(&mut self) {
        self.transform_m03 = ::std::option::Option::None;
    }

    pub fn has_transform_m03(&self) -> bool {
        self.transform_m03.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m03(&mut self, v: f64) {
        self.transform_m03 = ::std::option::Option::Some(v);
    }

    // optional double transform_m10 = 20;

    pub fn transform_m10(&self) -> f64 {
        self.transform_m10.unwrap_or(0.)
    }

    pub fn clear_transform_m10(&mut self) {
        self.transform_m10 = ::std::option::Option::None;
    }

    pub fn has_transform_m10(&self) -> bool {
        self.transform_m10.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m10(&mut self, v: f64) {
        self.transform_m10 = ::std::option::Option::Some(v);
    }

    // optional double transform_m11 = 21;

    pub fn transform_m11(&self) -> f64 {
        self.transform_m11.unwrap_or(0.)
    }

    pub fn clear_transform_m11(&mut self) {
        self.transform_m11 = ::std::option::Option::None;
    }

    pub fn has_transform_m11(&self) -> bool {
        self.transform_m11.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m11(&mut self, v: f64) {
        self.transform_m11 = ::std::option::Option::Some(v);
    }

    // optional double transform_m12 = 22;

    pub fn transform_m12(&self) -> f64 {
        self.transform_m12.unwrap_or(0.)
    }

    pub fn clear_transform_m12(&mut self) {
        self.transform_m12 = ::std::option::Option::None;
    }

    pub fn has_transform_m12(&self) -> bool {
        self.transform_m12.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m12(&mut self, v: f64) {
        self.transform_m12 = ::std::option::Option::Some(v);
    }

    // optional double transform_m13 = 23;

    pub fn transform_m13(&self) -> f64 {
        self.transform_m13.unwrap_or(0.)
    }

    pub fn clear_transform_m13(&mut self) {
        self.transform_m13 = ::std::option::Option::None;
    }

    pub fn has_transform_m13(&self) -> bool {
        self.transform_m13.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m13(&mut self, v: f64) {
        self.transform_m13 = ::std::option::Option::Some(v);
    }

    // optional double transform_m20 = 24;

    pub fn transform_m20(&self) -> f64 {
        self.transform_m20.unwrap_or(0.)
    }

    pub fn clear_transform_m20(&mut self) {
        self.transform_m20 = ::std::option::Option::None;
    }

    pub fn has_transform_m20(&self) -> bool {
        self.transform_m20.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m20(&mut self, v: f64) {
        self.transform_m20 = ::std::option::Option::Some(v);
    }

    // optional double transform_m21 = 25;

    pub fn transform_m21(&self) -> f64 {
        self.transform_m21.unwrap_or(0.)
    }

    pub fn clear_transform_m21(&mut self) {
        self.transform_m21 = ::std::option::Option::None;
    }

    pub fn has_transform_m21(&self) -> bool {
        self.transform_m21.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m21(&mut self, v: f64) {
        self.transform_m21 = ::std::option::Option::Some(v);
    }

    // optional double transform_m22 = 26;

    pub fn transform_m22(&self) -> f64 {
        self.transform_m22.unwrap_or(0.)
    }

    pub fn clear_transform_m22(&mut self) {
        self.transform_m22 = ::std::option::Option::None;
    }

    pub fn has_transform_m22(&self) -> bool {
        self.transform_m22.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m22(&mut self, v: f64) {
        self.transform_m22 = ::std::option::Option::Some(v);
    }

    // optional double transform_m23 = 27;

    pub fn transform_m23(&self) -> f64 {
        self.transform_m23.unwrap_or(0.)
    }

    pub fn clear_transform_m23(&mut self) {
        self.transform_m23 = ::std::option::Option::None;
    }

    pub fn has_transform_m23(&self) -> bool {
        self.transform_m23.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m23(&mut self, v: f64) {
        self.transform_m23 = ::std::option::Option::Some(v);
    }

    // optional double transform_m30 = 28;

    pub fn transform_m30(&self) -> f64 {
        self.transform_m30.unwrap_or(0.)
    }

    pub fn clear_transform_m30(&mut self) {
        self.transform_m30 = ::std::option::Option::None;
    }

    pub fn has_transform_m30(&self) -> bool {
        self.transform_m30.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m30(&mut self, v: f64) {
        self.transform_m30 = ::std::option::Option::Some(v);
    }

    // optional double transform_m31 = 29;

    pub fn transform_m31(&self) -> f64 {
        self.transform_m31.unwrap_or(0.)
    }

    pub fn clear_transform_m31(&mut self) {
        self.transform_m31 = ::std::option::Option::None;
    }

    pub fn has_transform_m31(&self) -> bool {
        self.transform_m31.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m31(&mut self, v: f64) {
        self.transform_m31 = ::std::option::Option::Some(v);
    }

    // optional double transform_m32 = 30;

    pub fn transform_m32(&self) -> f64 {
        self.transform_m32.unwrap_or(0.)
    }

    pub fn clear_transform_m32(&mut self) {
        self.transform_m32 = ::std::option::Option::None;
    }

    pub fn has_transform_m32(&self) -> bool {
        self.transform_m32.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m32(&mut self, v: f64) {
        self.transform_m32 = ::std::option::Option::Some(v);
    }

    // optional double transform_m33 = 31;

    pub fn transform_m33(&self) -> f64 {
        self.transform_m33.unwrap_or(0.)
    }

    pub fn clear_transform_m33(&mut self) {
        self.transform_m33 = ::std::option::Option::None;
    }

    pub fn has_transform_m33(&self) -> bool {
        self.transform_m33.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m33(&mut self, v: f64) {
        self.transform_m33 = ::std::option::Option::Some(v);
    }

    // optional double perspective_depth = 32;

    pub fn perspective_depth(&self) -> f64 {
        self.perspective_depth.unwrap_or(0.)
    }

    pub fn clear_perspective_depth(&mut self) {
        self.perspective_depth = ::std::option::Option::None;
    }

    pub fn has_perspective_depth(&self) -> bool {
        self.perspective_depth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_perspective_depth(&mut self, v: f64) {
        self.perspective_depth = ::std::option::Option::Some(v);
    }

    // optional double opacity = 33;

    pub fn opacity(&self) -> f64 {
        self.opacity.unwrap_or(0.)
    }

    pub fn clear_opacity(&mut self) {
        self.opacity = ::std::option::Option::None;
    }

    pub fn has_opacity(&self) -> bool {
        self.opacity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_opacity(&mut self, v: f64) {
        self.opacity = ::std::option::Option::Some(v);
    }

    // optional uint32 composition_color = 34;

    pub fn composition_color(&self) -> u32 {
        self.composition_color.unwrap_or(0)
    }

    pub fn clear_composition_color(&mut self) {
        self.composition_color = ::std::option::Option::None;
    }

    pub fn has_composition_color(&self) -> bool {
        self.composition_color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_composition_color(&mut self, v: u32) {
        self.composition_color = ::std::option::Option::Some(v);
    }

    // optional double saturation = 35;

    pub fn saturation(&self) -> f64 {
        self.saturation.unwrap_or(0.)
    }

    pub fn clear_saturation(&mut self) {
        self.saturation = ::std::option::Option::None;
    }

    pub fn has_saturation(&self) -> bool {
        self.saturation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_saturation(&mut self, v: f64) {
        self.saturation = ::std::option::Option::Some(v);
    }

    // optional double hue_shift = 36;

    pub fn hue_shift(&self) -> f64 {
        self.hue_shift.unwrap_or(0.)
    }

    pub fn clear_hue_shift(&mut self) {
        self.hue_shift = ::std::option::Option::None;
    }

    pub fn has_hue_shift(&self) -> bool {
        self.hue_shift.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hue_shift(&mut self, v: f64) {
        self.hue_shift = ::std::option::Option::Some(v);
    }

    // optional double brightness = 37;

    pub fn brightness(&self) -> f64 {
        self.brightness.unwrap_or(0.)
    }

    pub fn clear_brightness(&mut self) {
        self.brightness = ::std::option::Option::None;
    }

    pub fn has_brightness(&self) -> bool {
        self.brightness.is_some()
    }

    // Param is passed by value, moved
    pub fn set_brightness(&mut self, v: f64) {
        self.brightness = ::std::option::Option::Some(v);
    }

    // optional double contrast = 38;

    pub fn contrast(&self) -> f64 {
        self.contrast.unwrap_or(0.)
    }

    pub fn clear_contrast(&mut self) {
        self.contrast = ::std::option::Option::None;
    }

    pub fn has_contrast(&self) -> bool {
        self.contrast.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contrast(&mut self, v: f64) {
        self.contrast = ::std::option::Option::Some(v);
    }

    // optional uint32 opacity_mask_texture_id = 39;

    pub fn opacity_mask_texture_id(&self) -> u32 {
        self.opacity_mask_texture_id.unwrap_or(0)
    }

    pub fn clear_opacity_mask_texture_id(&mut self) {
        self.opacity_mask_texture_id = ::std::option::Option::None;
    }

    pub fn has_opacity_mask_texture_id(&self) -> bool {
        self.opacity_mask_texture_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_opacity_mask_texture_id(&mut self, v: u32) {
        self.opacity_mask_texture_id = ::std::option::Option::Some(v);
    }

    // optional double opacity_mask_opacity = 40;

    pub fn opacity_mask_opacity(&self) -> f64 {
        self.opacity_mask_opacity.unwrap_or(0.)
    }

    pub fn clear_opacity_mask_opacity(&mut self) {
        self.opacity_mask_opacity = ::std::option::Option::None;
    }

    pub fn has_opacity_mask_opacity(&self) -> bool {
        self.opacity_mask_opacity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_opacity_mask_opacity(&mut self, v: f64) {
        self.opacity_mask_opacity = ::std::option::Option::Some(v);
    }

    // optional double gaussianblur_passes = 44;

    pub fn gaussianblur_passes(&self) -> f64 {
        self.gaussianblur_passes.unwrap_or(0.)
    }

    pub fn clear_gaussianblur_passes(&mut self) {
        self.gaussianblur_passes = ::std::option::Option::None;
    }

    pub fn has_gaussianblur_passes(&self) -> bool {
        self.gaussianblur_passes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gaussianblur_passes(&mut self, v: f64) {
        self.gaussianblur_passes = ::std::option::Option::Some(v);
    }

    // optional double gaussianblur_stddevhor = 45;

    pub fn gaussianblur_stddevhor(&self) -> f64 {
        self.gaussianblur_stddevhor.unwrap_or(0.)
    }

    pub fn clear_gaussianblur_stddevhor(&mut self) {
        self.gaussianblur_stddevhor = ::std::option::Option::None;
    }

    pub fn has_gaussianblur_stddevhor(&self) -> bool {
        self.gaussianblur_stddevhor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gaussianblur_stddevhor(&mut self, v: f64) {
        self.gaussianblur_stddevhor = ::std::option::Option::Some(v);
    }

    // optional double gaussianblur_stddevver = 46;

    pub fn gaussianblur_stddevver(&self) -> f64 {
        self.gaussianblur_stddevver.unwrap_or(0.)
    }

    pub fn clear_gaussianblur_stddevver(&mut self) {
        self.gaussianblur_stddevver = ::std::option::Option::None;
    }

    pub fn has_gaussianblur_stddevver(&self) -> bool {
        self.gaussianblur_stddevver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gaussianblur_stddevver(&mut self, v: f64) {
        self.gaussianblur_stddevver = ::std::option::Option::Some(v);
    }

    // optional double scale_2d_factors_x = 47;

    pub fn scale_2d_factors_x(&self) -> f64 {
        self.scale_2d_factors_x.unwrap_or(0.)
    }

    pub fn clear_scale_2d_factors_x(&mut self) {
        self.scale_2d_factors_x = ::std::option::Option::None;
    }

    pub fn has_scale_2d_factors_x(&self) -> bool {
        self.scale_2d_factors_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale_2d_factors_x(&mut self, v: f64) {
        self.scale_2d_factors_x = ::std::option::Option::Some(v);
    }

    // optional double scale_2d_factors_y = 48;

    pub fn scale_2d_factors_y(&self) -> f64 {
        self.scale_2d_factors_y.unwrap_or(0.)
    }

    pub fn clear_scale_2d_factors_y(&mut self) {
        self.scale_2d_factors_y = ::std::option::Option::None;
    }

    pub fn has_scale_2d_factors_y(&self) -> bool {
        self.scale_2d_factors_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale_2d_factors_y(&mut self, v: f64) {
        self.scale_2d_factors_y = ::std::option::Option::Some(v);
    }

    // optional double rotate_2d = 49;

    pub fn rotate_2d(&self) -> f64 {
        self.rotate_2d.unwrap_or(0.)
    }

    pub fn clear_rotate_2d(&mut self) {
        self.rotate_2d = ::std::option::Option::None;
    }

    pub fn has_rotate_2d(&self) -> bool {
        self.rotate_2d.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rotate_2d(&mut self, v: f64) {
        self.rotate_2d = ::std::option::Option::Some(v);
    }

    // optional bool needs_clear = 50;

    pub fn needs_clear(&self) -> bool {
        self.needs_clear.unwrap_or(false)
    }

    pub fn clear_needs_clear(&mut self) {
        self.needs_clear = ::std::option::Option::None;
    }

    pub fn has_needs_clear(&self) -> bool {
        self.needs_clear.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needs_clear(&mut self, v: bool) {
        self.needs_clear = ::std::option::Option::Some(v);
    }

    // optional bool needs_depth = 51;

    pub fn needs_depth(&self) -> bool {
        self.needs_depth.unwrap_or(false)
    }

    pub fn clear_needs_depth(&mut self) {
        self.needs_depth = ::std::option::Option::None;
    }

    pub fn has_needs_depth(&self) -> bool {
        self.needs_depth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needs_depth(&mut self, v: bool) {
        self.needs_depth = ::std::option::Option::Some(v);
    }

    // optional bool needs_intermediate_texture = 52;

    pub fn needs_intermediate_texture(&self) -> bool {
        self.needs_intermediate_texture.unwrap_or(false)
    }

    pub fn clear_needs_intermediate_texture(&mut self) {
        self.needs_intermediate_texture = ::std::option::Option::None;
    }

    pub fn has_needs_intermediate_texture(&self) -> bool {
        self.needs_intermediate_texture.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needs_intermediate_texture(&mut self, v: bool) {
        self.needs_intermediate_texture = ::std::option::Option::Some(v);
    }

    // optional bool needs_redraw_every_frame = 53;

    pub fn needs_redraw_every_frame(&self) -> bool {
        self.needs_redraw_every_frame.unwrap_or(false)
    }

    pub fn clear_needs_redraw_every_frame(&mut self) {
        self.needs_redraw_every_frame = ::std::option::Option::None;
    }

    pub fn has_needs_redraw_every_frame(&self) -> bool {
        self.needs_redraw_every_frame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needs_redraw_every_frame(&mut self, v: bool) {
        self.needs_redraw_every_frame = ::std::option::Option::Some(v);
    }

    // optional uint32 mix_blend_mode = 55;

    pub fn mix_blend_mode(&self) -> u32 {
        self.mix_blend_mode.unwrap_or(0)
    }

    pub fn clear_mix_blend_mode(&mut self) {
        self.mix_blend_mode = ::std::option::Option::None;
    }

    pub fn has_mix_blend_mode(&self) -> bool {
        self.mix_blend_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mix_blend_mode(&mut self, v: u32) {
        self.mix_blend_mode = ::std::option::Option::Some(v);
    }

    // optional double occluded_left_edge = 56;

    pub fn occluded_left_edge(&self) -> f64 {
        self.occluded_left_edge.unwrap_or(0.)
    }

    pub fn clear_occluded_left_edge(&mut self) {
        self.occluded_left_edge = ::std::option::Option::None;
    }

    pub fn has_occluded_left_edge(&self) -> bool {
        self.occluded_left_edge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_occluded_left_edge(&mut self, v: f64) {
        self.occluded_left_edge = ::std::option::Option::Some(v);
    }

    // optional double occluded_top_edge = 57;

    pub fn occluded_top_edge(&self) -> f64 {
        self.occluded_top_edge.unwrap_or(0.)
    }

    pub fn clear_occluded_top_edge(&mut self) {
        self.occluded_top_edge = ::std::option::Option::None;
    }

    pub fn has_occluded_top_edge(&self) -> bool {
        self.occluded_top_edge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_occluded_top_edge(&mut self, v: f64) {
        self.occluded_top_edge = ::std::option::Option::Some(v);
    }

    // optional double occluded_right_edge = 58;

    pub fn occluded_right_edge(&self) -> f64 {
        self.occluded_right_edge.unwrap_or(0.)
    }

    pub fn clear_occluded_right_edge(&mut self) {
        self.occluded_right_edge = ::std::option::Option::None;
    }

    pub fn has_occluded_right_edge(&self) -> bool {
        self.occluded_right_edge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_occluded_right_edge(&mut self, v: f64) {
        self.occluded_right_edge = ::std::option::Option::Some(v);
    }

    // optional double occluded_bottom_edge = 59;

    pub fn occluded_bottom_edge(&self) -> f64 {
        self.occluded_bottom_edge.unwrap_or(0.)
    }

    pub fn clear_occluded_bottom_edge(&mut self) {
        self.occluded_bottom_edge = ::std::option::Option::None;
    }

    pub fn has_occluded_bottom_edge(&self) -> bool {
        self.occluded_bottom_edge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_occluded_bottom_edge(&mut self, v: f64) {
        self.occluded_bottom_edge = ::std::option::Option::Some(v);
    }

    // optional double motionblur_velocity = 61;

    pub fn motionblur_velocity(&self) -> f64 {
        self.motionblur_velocity.unwrap_or(0.)
    }

    pub fn clear_motionblur_velocity(&mut self) {
        self.motionblur_velocity = ::std::option::Option::None;
    }

    pub fn has_motionblur_velocity(&self) -> bool {
        self.motionblur_velocity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_motionblur_velocity(&mut self, v: f64) {
        self.motionblur_velocity = ::std::option::Option::Some(v);
    }

    // optional double motionblur_dirx = 62;

    pub fn motionblur_dirx(&self) -> f64 {
        self.motionblur_dirx.unwrap_or(0.)
    }

    pub fn clear_motionblur_dirx(&mut self) {
        self.motionblur_dirx = ::std::option::Option::None;
    }

    pub fn has_motionblur_dirx(&self) -> bool {
        self.motionblur_dirx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_motionblur_dirx(&mut self, v: f64) {
        self.motionblur_dirx = ::std::option::Option::Some(v);
    }

    // optional double motionblur_diry = 63;

    pub fn motionblur_diry(&self) -> f64 {
        self.motionblur_diry.unwrap_or(0.)
    }

    pub fn clear_motionblur_diry(&mut self) {
        self.motionblur_diry = ::std::option::Option::None;
    }

    pub fn has_motionblur_diry(&self) -> bool {
        self.motionblur_diry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_motionblur_diry(&mut self, v: f64) {
        self.motionblur_diry = ::std::option::Option::Some(v);
    }

    // optional string composition_layer_texture_name = 64;

    pub fn composition_layer_texture_name(&self) -> &str {
        match self.composition_layer_texture_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_composition_layer_texture_name(&mut self) {
        self.composition_layer_texture_name = ::std::option::Option::None;
    }

    pub fn has_composition_layer_texture_name(&self) -> bool {
        self.composition_layer_texture_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_composition_layer_texture_name(&mut self, v: ::std::string::String) {
        self.composition_layer_texture_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_composition_layer_texture_name(&mut self) -> &mut ::std::string::String {
        if self.composition_layer_texture_name.is_none() {
            self.composition_layer_texture_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.composition_layer_texture_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_composition_layer_texture_name(&mut self) -> ::std::string::String {
        self.composition_layer_texture_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(64);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "layer_id",
            |m: &CMsgPushCompositingLayer| { &m.layer_id },
            |m: &mut CMsgPushCompositingLayer| { &mut m.layer_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &CMsgPushCompositingLayer| { &m.width },
            |m: &mut CMsgPushCompositingLayer| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &CMsgPushCompositingLayer| { &m.height },
            |m: &mut CMsgPushCompositingLayer| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "layer_quad_top_left_x",
            |m: &CMsgPushCompositingLayer| { &m.layer_quad_top_left_x },
            |m: &mut CMsgPushCompositingLayer| { &mut m.layer_quad_top_left_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "layer_quad_top_left_y",
            |m: &CMsgPushCompositingLayer| { &m.layer_quad_top_left_y },
            |m: &mut CMsgPushCompositingLayer| { &mut m.layer_quad_top_left_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "layer_quad_top_left_z",
            |m: &CMsgPushCompositingLayer| { &m.layer_quad_top_left_z },
            |m: &mut CMsgPushCompositingLayer| { &mut m.layer_quad_top_left_z },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "layer_quad_top_right_x",
            |m: &CMsgPushCompositingLayer| { &m.layer_quad_top_right_x },
            |m: &mut CMsgPushCompositingLayer| { &mut m.layer_quad_top_right_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "layer_quad_top_right_y",
            |m: &CMsgPushCompositingLayer| { &m.layer_quad_top_right_y },
            |m: &mut CMsgPushCompositingLayer| { &mut m.layer_quad_top_right_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "layer_quad_top_right_z",
            |m: &CMsgPushCompositingLayer| { &m.layer_quad_top_right_z },
            |m: &mut CMsgPushCompositingLayer| { &mut m.layer_quad_top_right_z },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "layer_quad_bottom_left_x",
            |m: &CMsgPushCompositingLayer| { &m.layer_quad_bottom_left_x },
            |m: &mut CMsgPushCompositingLayer| { &mut m.layer_quad_bottom_left_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "layer_quad_bottom_left_y",
            |m: &CMsgPushCompositingLayer| { &m.layer_quad_bottom_left_y },
            |m: &mut CMsgPushCompositingLayer| { &mut m.layer_quad_bottom_left_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "layer_quad_bottom_left_z",
            |m: &CMsgPushCompositingLayer| { &m.layer_quad_bottom_left_z },
            |m: &mut CMsgPushCompositingLayer| { &mut m.layer_quad_bottom_left_z },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "layer_quad_bottom_right_x",
            |m: &CMsgPushCompositingLayer| { &m.layer_quad_bottom_right_x },
            |m: &mut CMsgPushCompositingLayer| { &mut m.layer_quad_bottom_right_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "layer_quad_bottom_right_y",
            |m: &CMsgPushCompositingLayer| { &m.layer_quad_bottom_right_y },
            |m: &mut CMsgPushCompositingLayer| { &mut m.layer_quad_bottom_right_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "layer_quad_bottom_right_z",
            |m: &CMsgPushCompositingLayer| { &m.layer_quad_bottom_right_z },
            |m: &mut CMsgPushCompositingLayer| { &mut m.layer_quad_bottom_right_z },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transform_m00",
            |m: &CMsgPushCompositingLayer| { &m.transform_m00 },
            |m: &mut CMsgPushCompositingLayer| { &mut m.transform_m00 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transform_m01",
            |m: &CMsgPushCompositingLayer| { &m.transform_m01 },
            |m: &mut CMsgPushCompositingLayer| { &mut m.transform_m01 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transform_m02",
            |m: &CMsgPushCompositingLayer| { &m.transform_m02 },
            |m: &mut CMsgPushCompositingLayer| { &mut m.transform_m02 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transform_m03",
            |m: &CMsgPushCompositingLayer| { &m.transform_m03 },
            |m: &mut CMsgPushCompositingLayer| { &mut m.transform_m03 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transform_m10",
            |m: &CMsgPushCompositingLayer| { &m.transform_m10 },
            |m: &mut CMsgPushCompositingLayer| { &mut m.transform_m10 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transform_m11",
            |m: &CMsgPushCompositingLayer| { &m.transform_m11 },
            |m: &mut CMsgPushCompositingLayer| { &mut m.transform_m11 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transform_m12",
            |m: &CMsgPushCompositingLayer| { &m.transform_m12 },
            |m: &mut CMsgPushCompositingLayer| { &mut m.transform_m12 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transform_m13",
            |m: &CMsgPushCompositingLayer| { &m.transform_m13 },
            |m: &mut CMsgPushCompositingLayer| { &mut m.transform_m13 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transform_m20",
            |m: &CMsgPushCompositingLayer| { &m.transform_m20 },
            |m: &mut CMsgPushCompositingLayer| { &mut m.transform_m20 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transform_m21",
            |m: &CMsgPushCompositingLayer| { &m.transform_m21 },
            |m: &mut CMsgPushCompositingLayer| { &mut m.transform_m21 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transform_m22",
            |m: &CMsgPushCompositingLayer| { &m.transform_m22 },
            |m: &mut CMsgPushCompositingLayer| { &mut m.transform_m22 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transform_m23",
            |m: &CMsgPushCompositingLayer| { &m.transform_m23 },
            |m: &mut CMsgPushCompositingLayer| { &mut m.transform_m23 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transform_m30",
            |m: &CMsgPushCompositingLayer| { &m.transform_m30 },
            |m: &mut CMsgPushCompositingLayer| { &mut m.transform_m30 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transform_m31",
            |m: &CMsgPushCompositingLayer| { &m.transform_m31 },
            |m: &mut CMsgPushCompositingLayer| { &mut m.transform_m31 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transform_m32",
            |m: &CMsgPushCompositingLayer| { &m.transform_m32 },
            |m: &mut CMsgPushCompositingLayer| { &mut m.transform_m32 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transform_m33",
            |m: &CMsgPushCompositingLayer| { &m.transform_m33 },
            |m: &mut CMsgPushCompositingLayer| { &mut m.transform_m33 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "perspective_depth",
            |m: &CMsgPushCompositingLayer| { &m.perspective_depth },
            |m: &mut CMsgPushCompositingLayer| { &mut m.perspective_depth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "opacity",
            |m: &CMsgPushCompositingLayer| { &m.opacity },
            |m: &mut CMsgPushCompositingLayer| { &mut m.opacity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "composition_color",
            |m: &CMsgPushCompositingLayer| { &m.composition_color },
            |m: &mut CMsgPushCompositingLayer| { &mut m.composition_color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "saturation",
            |m: &CMsgPushCompositingLayer| { &m.saturation },
            |m: &mut CMsgPushCompositingLayer| { &mut m.saturation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hue_shift",
            |m: &CMsgPushCompositingLayer| { &m.hue_shift },
            |m: &mut CMsgPushCompositingLayer| { &mut m.hue_shift },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "brightness",
            |m: &CMsgPushCompositingLayer| { &m.brightness },
            |m: &mut CMsgPushCompositingLayer| { &mut m.brightness },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "contrast",
            |m: &CMsgPushCompositingLayer| { &m.contrast },
            |m: &mut CMsgPushCompositingLayer| { &mut m.contrast },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "opacity_mask_texture_id",
            |m: &CMsgPushCompositingLayer| { &m.opacity_mask_texture_id },
            |m: &mut CMsgPushCompositingLayer| { &mut m.opacity_mask_texture_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "opacity_mask_opacity",
            |m: &CMsgPushCompositingLayer| { &m.opacity_mask_opacity },
            |m: &mut CMsgPushCompositingLayer| { &mut m.opacity_mask_opacity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CBorderData>(
            "border",
            |m: &CMsgPushCompositingLayer| { &m.border },
            |m: &mut CMsgPushCompositingLayer| { &mut m.border },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CRadiusData>(
            "border_radius",
            |m: &CMsgPushCompositingLayer| { &m.border_radius },
            |m: &mut CMsgPushCompositingLayer| { &mut m.border_radius },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CBoxShadowData>(
            "box_shadow",
            |m: &CMsgPushCompositingLayer| { &m.box_shadow },
            |m: &mut CMsgPushCompositingLayer| { &mut m.box_shadow },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gaussianblur_passes",
            |m: &CMsgPushCompositingLayer| { &m.gaussianblur_passes },
            |m: &mut CMsgPushCompositingLayer| { &mut m.gaussianblur_passes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gaussianblur_stddevhor",
            |m: &CMsgPushCompositingLayer| { &m.gaussianblur_stddevhor },
            |m: &mut CMsgPushCompositingLayer| { &mut m.gaussianblur_stddevhor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gaussianblur_stddevver",
            |m: &CMsgPushCompositingLayer| { &m.gaussianblur_stddevver },
            |m: &mut CMsgPushCompositingLayer| { &mut m.gaussianblur_stddevver },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scale_2d_factors_x",
            |m: &CMsgPushCompositingLayer| { &m.scale_2d_factors_x },
            |m: &mut CMsgPushCompositingLayer| { &mut m.scale_2d_factors_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scale_2d_factors_y",
            |m: &CMsgPushCompositingLayer| { &m.scale_2d_factors_y },
            |m: &mut CMsgPushCompositingLayer| { &mut m.scale_2d_factors_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rotate_2d",
            |m: &CMsgPushCompositingLayer| { &m.rotate_2d },
            |m: &mut CMsgPushCompositingLayer| { &mut m.rotate_2d },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "needs_clear",
            |m: &CMsgPushCompositingLayer| { &m.needs_clear },
            |m: &mut CMsgPushCompositingLayer| { &mut m.needs_clear },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "needs_depth",
            |m: &CMsgPushCompositingLayer| { &m.needs_depth },
            |m: &mut CMsgPushCompositingLayer| { &mut m.needs_depth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "needs_intermediate_texture",
            |m: &CMsgPushCompositingLayer| { &m.needs_intermediate_texture },
            |m: &mut CMsgPushCompositingLayer| { &mut m.needs_intermediate_texture },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "needs_redraw_every_frame",
            |m: &CMsgPushCompositingLayer| { &m.needs_redraw_every_frame },
            |m: &mut CMsgPushCompositingLayer| { &mut m.needs_redraw_every_frame },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CTextShadowData>(
            "text_shadow",
            |m: &CMsgPushCompositingLayer| { &m.text_shadow },
            |m: &mut CMsgPushCompositingLayer| { &mut m.text_shadow },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mix_blend_mode",
            |m: &CMsgPushCompositingLayer| { &m.mix_blend_mode },
            |m: &mut CMsgPushCompositingLayer| { &mut m.mix_blend_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "occluded_left_edge",
            |m: &CMsgPushCompositingLayer| { &m.occluded_left_edge },
            |m: &mut CMsgPushCompositingLayer| { &mut m.occluded_left_edge },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "occluded_top_edge",
            |m: &CMsgPushCompositingLayer| { &m.occluded_top_edge },
            |m: &mut CMsgPushCompositingLayer| { &mut m.occluded_top_edge },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "occluded_right_edge",
            |m: &CMsgPushCompositingLayer| { &m.occluded_right_edge },
            |m: &mut CMsgPushCompositingLayer| { &mut m.occluded_right_edge },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "occluded_bottom_edge",
            |m: &CMsgPushCompositingLayer| { &m.occluded_bottom_edge },
            |m: &mut CMsgPushCompositingLayer| { &mut m.occluded_bottom_edge },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CRadialClipData>(
            "radial_clip",
            |m: &CMsgPushCompositingLayer| { &m.radial_clip },
            |m: &mut CMsgPushCompositingLayer| { &mut m.radial_clip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "motionblur_velocity",
            |m: &CMsgPushCompositingLayer| { &m.motionblur_velocity },
            |m: &mut CMsgPushCompositingLayer| { &mut m.motionblur_velocity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "motionblur_dirx",
            |m: &CMsgPushCompositingLayer| { &m.motionblur_dirx },
            |m: &mut CMsgPushCompositingLayer| { &mut m.motionblur_dirx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "motionblur_diry",
            |m: &CMsgPushCompositingLayer| { &m.motionblur_diry },
            |m: &mut CMsgPushCompositingLayer| { &mut m.motionblur_diry },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "composition_layer_texture_name",
            |m: &CMsgPushCompositingLayer| { &m.composition_layer_texture_name },
            |m: &mut CMsgPushCompositingLayer| { &mut m.composition_layer_texture_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPushCompositingLayer>(
            "CMsgPushCompositingLayer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPushCompositingLayer {
    const NAME: &'static str = "CMsgPushCompositingLayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.layer_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.width = ::std::option::Option::Some(is.read_double()?);
                },
                25 => {
                    self.height = ::std::option::Option::Some(is.read_double()?);
                },
                33 => {
                    self.layer_quad_top_left_x = ::std::option::Option::Some(is.read_double()?);
                },
                41 => {
                    self.layer_quad_top_left_y = ::std::option::Option::Some(is.read_double()?);
                },
                49 => {
                    self.layer_quad_top_left_z = ::std::option::Option::Some(is.read_double()?);
                },
                57 => {
                    self.layer_quad_top_right_x = ::std::option::Option::Some(is.read_double()?);
                },
                65 => {
                    self.layer_quad_top_right_y = ::std::option::Option::Some(is.read_double()?);
                },
                73 => {
                    self.layer_quad_top_right_z = ::std::option::Option::Some(is.read_double()?);
                },
                81 => {
                    self.layer_quad_bottom_left_x = ::std::option::Option::Some(is.read_double()?);
                },
                89 => {
                    self.layer_quad_bottom_left_y = ::std::option::Option::Some(is.read_double()?);
                },
                97 => {
                    self.layer_quad_bottom_left_z = ::std::option::Option::Some(is.read_double()?);
                },
                105 => {
                    self.layer_quad_bottom_right_x = ::std::option::Option::Some(is.read_double()?);
                },
                113 => {
                    self.layer_quad_bottom_right_y = ::std::option::Option::Some(is.read_double()?);
                },
                121 => {
                    self.layer_quad_bottom_right_z = ::std::option::Option::Some(is.read_double()?);
                },
                129 => {
                    self.transform_m00 = ::std::option::Option::Some(is.read_double()?);
                },
                137 => {
                    self.transform_m01 = ::std::option::Option::Some(is.read_double()?);
                },
                145 => {
                    self.transform_m02 = ::std::option::Option::Some(is.read_double()?);
                },
                153 => {
                    self.transform_m03 = ::std::option::Option::Some(is.read_double()?);
                },
                161 => {
                    self.transform_m10 = ::std::option::Option::Some(is.read_double()?);
                },
                169 => {
                    self.transform_m11 = ::std::option::Option::Some(is.read_double()?);
                },
                177 => {
                    self.transform_m12 = ::std::option::Option::Some(is.read_double()?);
                },
                185 => {
                    self.transform_m13 = ::std::option::Option::Some(is.read_double()?);
                },
                193 => {
                    self.transform_m20 = ::std::option::Option::Some(is.read_double()?);
                },
                201 => {
                    self.transform_m21 = ::std::option::Option::Some(is.read_double()?);
                },
                209 => {
                    self.transform_m22 = ::std::option::Option::Some(is.read_double()?);
                },
                217 => {
                    self.transform_m23 = ::std::option::Option::Some(is.read_double()?);
                },
                225 => {
                    self.transform_m30 = ::std::option::Option::Some(is.read_double()?);
                },
                233 => {
                    self.transform_m31 = ::std::option::Option::Some(is.read_double()?);
                },
                241 => {
                    self.transform_m32 = ::std::option::Option::Some(is.read_double()?);
                },
                249 => {
                    self.transform_m33 = ::std::option::Option::Some(is.read_double()?);
                },
                257 => {
                    self.perspective_depth = ::std::option::Option::Some(is.read_double()?);
                },
                265 => {
                    self.opacity = ::std::option::Option::Some(is.read_double()?);
                },
                272 => {
                    self.composition_color = ::std::option::Option::Some(is.read_uint32()?);
                },
                281 => {
                    self.saturation = ::std::option::Option::Some(is.read_double()?);
                },
                289 => {
                    self.hue_shift = ::std::option::Option::Some(is.read_double()?);
                },
                297 => {
                    self.brightness = ::std::option::Option::Some(is.read_double()?);
                },
                305 => {
                    self.contrast = ::std::option::Option::Some(is.read_double()?);
                },
                312 => {
                    self.opacity_mask_texture_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                321 => {
                    self.opacity_mask_opacity = ::std::option::Option::Some(is.read_double()?);
                },
                330 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.border)?;
                },
                338 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.border_radius)?;
                },
                346 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.box_shadow)?;
                },
                353 => {
                    self.gaussianblur_passes = ::std::option::Option::Some(is.read_double()?);
                },
                361 => {
                    self.gaussianblur_stddevhor = ::std::option::Option::Some(is.read_double()?);
                },
                369 => {
                    self.gaussianblur_stddevver = ::std::option::Option::Some(is.read_double()?);
                },
                377 => {
                    self.scale_2d_factors_x = ::std::option::Option::Some(is.read_double()?);
                },
                385 => {
                    self.scale_2d_factors_y = ::std::option::Option::Some(is.read_double()?);
                },
                393 => {
                    self.rotate_2d = ::std::option::Option::Some(is.read_double()?);
                },
                400 => {
                    self.needs_clear = ::std::option::Option::Some(is.read_bool()?);
                },
                408 => {
                    self.needs_depth = ::std::option::Option::Some(is.read_bool()?);
                },
                416 => {
                    self.needs_intermediate_texture = ::std::option::Option::Some(is.read_bool()?);
                },
                424 => {
                    self.needs_redraw_every_frame = ::std::option::Option::Some(is.read_bool()?);
                },
                434 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.text_shadow)?;
                },
                440 => {
                    self.mix_blend_mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                449 => {
                    self.occluded_left_edge = ::std::option::Option::Some(is.read_double()?);
                },
                457 => {
                    self.occluded_top_edge = ::std::option::Option::Some(is.read_double()?);
                },
                465 => {
                    self.occluded_right_edge = ::std::option::Option::Some(is.read_double()?);
                },
                473 => {
                    self.occluded_bottom_edge = ::std::option::Option::Some(is.read_double()?);
                },
                482 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.radial_clip)?;
                },
                489 => {
                    self.motionblur_velocity = ::std::option::Option::Some(is.read_double()?);
                },
                497 => {
                    self.motionblur_dirx = ::std::option::Option::Some(is.read_double()?);
                },
                505 => {
                    self.motionblur_diry = ::std::option::Option::Some(is.read_double()?);
                },
                514 => {
                    self.composition_layer_texture_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.layer_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.width {
            my_size += 1 + 8;
        }
        if let Some(v) = self.height {
            my_size += 1 + 8;
        }
        if let Some(v) = self.layer_quad_top_left_x {
            my_size += 1 + 8;
        }
        if let Some(v) = self.layer_quad_top_left_y {
            my_size += 1 + 8;
        }
        if let Some(v) = self.layer_quad_top_left_z {
            my_size += 1 + 8;
        }
        if let Some(v) = self.layer_quad_top_right_x {
            my_size += 1 + 8;
        }
        if let Some(v) = self.layer_quad_top_right_y {
            my_size += 1 + 8;
        }
        if let Some(v) = self.layer_quad_top_right_z {
            my_size += 1 + 8;
        }
        if let Some(v) = self.layer_quad_bottom_left_x {
            my_size += 1 + 8;
        }
        if let Some(v) = self.layer_quad_bottom_left_y {
            my_size += 1 + 8;
        }
        if let Some(v) = self.layer_quad_bottom_left_z {
            my_size += 1 + 8;
        }
        if let Some(v) = self.layer_quad_bottom_right_x {
            my_size += 1 + 8;
        }
        if let Some(v) = self.layer_quad_bottom_right_y {
            my_size += 1 + 8;
        }
        if let Some(v) = self.layer_quad_bottom_right_z {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transform_m00 {
            my_size += 2 + 8;
        }
        if let Some(v) = self.transform_m01 {
            my_size += 2 + 8;
        }
        if let Some(v) = self.transform_m02 {
            my_size += 2 + 8;
        }
        if let Some(v) = self.transform_m03 {
            my_size += 2 + 8;
        }
        if let Some(v) = self.transform_m10 {
            my_size += 2 + 8;
        }
        if let Some(v) = self.transform_m11 {
            my_size += 2 + 8;
        }
        if let Some(v) = self.transform_m12 {
            my_size += 2 + 8;
        }
        if let Some(v) = self.transform_m13 {
            my_size += 2 + 8;
        }
        if let Some(v) = self.transform_m20 {
            my_size += 2 + 8;
        }
        if let Some(v) = self.transform_m21 {
            my_size += 2 + 8;
        }
        if let Some(v) = self.transform_m22 {
            my_size += 2 + 8;
        }
        if let Some(v) = self.transform_m23 {
            my_size += 2 + 8;
        }
        if let Some(v) = self.transform_m30 {
            my_size += 2 + 8;
        }
        if let Some(v) = self.transform_m31 {
            my_size += 2 + 8;
        }
        if let Some(v) = self.transform_m32 {
            my_size += 2 + 8;
        }
        if let Some(v) = self.transform_m33 {
            my_size += 2 + 8;
        }
        if let Some(v) = self.perspective_depth {
            my_size += 2 + 8;
        }
        if let Some(v) = self.opacity {
            my_size += 2 + 8;
        }
        if let Some(v) = self.composition_color {
            my_size += ::protobuf::rt::uint32_size(34, v);
        }
        if let Some(v) = self.saturation {
            my_size += 2 + 8;
        }
        if let Some(v) = self.hue_shift {
            my_size += 2 + 8;
        }
        if let Some(v) = self.brightness {
            my_size += 2 + 8;
        }
        if let Some(v) = self.contrast {
            my_size += 2 + 8;
        }
        if let Some(v) = self.opacity_mask_texture_id {
            my_size += ::protobuf::rt::uint32_size(39, v);
        }
        if let Some(v) = self.opacity_mask_opacity {
            my_size += 2 + 8;
        }
        if let Some(v) = self.border.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.border_radius.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.box_shadow.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.gaussianblur_passes {
            my_size += 2 + 8;
        }
        if let Some(v) = self.gaussianblur_stddevhor {
            my_size += 2 + 8;
        }
        if let Some(v) = self.gaussianblur_stddevver {
            my_size += 2 + 8;
        }
        if let Some(v) = self.scale_2d_factors_x {
            my_size += 2 + 8;
        }
        if let Some(v) = self.scale_2d_factors_y {
            my_size += 2 + 8;
        }
        if let Some(v) = self.rotate_2d {
            my_size += 2 + 8;
        }
        if let Some(v) = self.needs_clear {
            my_size += 2 + 1;
        }
        if let Some(v) = self.needs_depth {
            my_size += 2 + 1;
        }
        if let Some(v) = self.needs_intermediate_texture {
            my_size += 2 + 1;
        }
        if let Some(v) = self.needs_redraw_every_frame {
            my_size += 2 + 1;
        }
        if let Some(v) = self.text_shadow.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.mix_blend_mode {
            my_size += ::protobuf::rt::uint32_size(55, v);
        }
        if let Some(v) = self.occluded_left_edge {
            my_size += 2 + 8;
        }
        if let Some(v) = self.occluded_top_edge {
            my_size += 2 + 8;
        }
        if let Some(v) = self.occluded_right_edge {
            my_size += 2 + 8;
        }
        if let Some(v) = self.occluded_bottom_edge {
            my_size += 2 + 8;
        }
        if let Some(v) = self.radial_clip.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.motionblur_velocity {
            my_size += 2 + 8;
        }
        if let Some(v) = self.motionblur_dirx {
            my_size += 2 + 8;
        }
        if let Some(v) = self.motionblur_diry {
            my_size += 2 + 8;
        }
        if let Some(v) = self.composition_layer_texture_name.as_ref() {
            my_size += ::protobuf::rt::string_size(64, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.layer_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.width {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.height {
            os.write_double(3, v)?;
        }
        if let Some(v) = self.layer_quad_top_left_x {
            os.write_double(4, v)?;
        }
        if let Some(v) = self.layer_quad_top_left_y {
            os.write_double(5, v)?;
        }
        if let Some(v) = self.layer_quad_top_left_z {
            os.write_double(6, v)?;
        }
        if let Some(v) = self.layer_quad_top_right_x {
            os.write_double(7, v)?;
        }
        if let Some(v) = self.layer_quad_top_right_y {
            os.write_double(8, v)?;
        }
        if let Some(v) = self.layer_quad_top_right_z {
            os.write_double(9, v)?;
        }
        if let Some(v) = self.layer_quad_bottom_left_x {
            os.write_double(10, v)?;
        }
        if let Some(v) = self.layer_quad_bottom_left_y {
            os.write_double(11, v)?;
        }
        if let Some(v) = self.layer_quad_bottom_left_z {
            os.write_double(12, v)?;
        }
        if let Some(v) = self.layer_quad_bottom_right_x {
            os.write_double(13, v)?;
        }
        if let Some(v) = self.layer_quad_bottom_right_y {
            os.write_double(14, v)?;
        }
        if let Some(v) = self.layer_quad_bottom_right_z {
            os.write_double(15, v)?;
        }
        if let Some(v) = self.transform_m00 {
            os.write_double(16, v)?;
        }
        if let Some(v) = self.transform_m01 {
            os.write_double(17, v)?;
        }
        if let Some(v) = self.transform_m02 {
            os.write_double(18, v)?;
        }
        if let Some(v) = self.transform_m03 {
            os.write_double(19, v)?;
        }
        if let Some(v) = self.transform_m10 {
            os.write_double(20, v)?;
        }
        if let Some(v) = self.transform_m11 {
            os.write_double(21, v)?;
        }
        if let Some(v) = self.transform_m12 {
            os.write_double(22, v)?;
        }
        if let Some(v) = self.transform_m13 {
            os.write_double(23, v)?;
        }
        if let Some(v) = self.transform_m20 {
            os.write_double(24, v)?;
        }
        if let Some(v) = self.transform_m21 {
            os.write_double(25, v)?;
        }
        if let Some(v) = self.transform_m22 {
            os.write_double(26, v)?;
        }
        if let Some(v) = self.transform_m23 {
            os.write_double(27, v)?;
        }
        if let Some(v) = self.transform_m30 {
            os.write_double(28, v)?;
        }
        if let Some(v) = self.transform_m31 {
            os.write_double(29, v)?;
        }
        if let Some(v) = self.transform_m32 {
            os.write_double(30, v)?;
        }
        if let Some(v) = self.transform_m33 {
            os.write_double(31, v)?;
        }
        if let Some(v) = self.perspective_depth {
            os.write_double(32, v)?;
        }
        if let Some(v) = self.opacity {
            os.write_double(33, v)?;
        }
        if let Some(v) = self.composition_color {
            os.write_uint32(34, v)?;
        }
        if let Some(v) = self.saturation {
            os.write_double(35, v)?;
        }
        if let Some(v) = self.hue_shift {
            os.write_double(36, v)?;
        }
        if let Some(v) = self.brightness {
            os.write_double(37, v)?;
        }
        if let Some(v) = self.contrast {
            os.write_double(38, v)?;
        }
        if let Some(v) = self.opacity_mask_texture_id {
            os.write_uint32(39, v)?;
        }
        if let Some(v) = self.opacity_mask_opacity {
            os.write_double(40, v)?;
        }
        if let Some(v) = self.border.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(41, v, os)?;
        }
        if let Some(v) = self.border_radius.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(42, v, os)?;
        }
        if let Some(v) = self.box_shadow.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(43, v, os)?;
        }
        if let Some(v) = self.gaussianblur_passes {
            os.write_double(44, v)?;
        }
        if let Some(v) = self.gaussianblur_stddevhor {
            os.write_double(45, v)?;
        }
        if let Some(v) = self.gaussianblur_stddevver {
            os.write_double(46, v)?;
        }
        if let Some(v) = self.scale_2d_factors_x {
            os.write_double(47, v)?;
        }
        if let Some(v) = self.scale_2d_factors_y {
            os.write_double(48, v)?;
        }
        if let Some(v) = self.rotate_2d {
            os.write_double(49, v)?;
        }
        if let Some(v) = self.needs_clear {
            os.write_bool(50, v)?;
        }
        if let Some(v) = self.needs_depth {
            os.write_bool(51, v)?;
        }
        if let Some(v) = self.needs_intermediate_texture {
            os.write_bool(52, v)?;
        }
        if let Some(v) = self.needs_redraw_every_frame {
            os.write_bool(53, v)?;
        }
        if let Some(v) = self.text_shadow.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(54, v, os)?;
        }
        if let Some(v) = self.mix_blend_mode {
            os.write_uint32(55, v)?;
        }
        if let Some(v) = self.occluded_left_edge {
            os.write_double(56, v)?;
        }
        if let Some(v) = self.occluded_top_edge {
            os.write_double(57, v)?;
        }
        if let Some(v) = self.occluded_right_edge {
            os.write_double(58, v)?;
        }
        if let Some(v) = self.occluded_bottom_edge {
            os.write_double(59, v)?;
        }
        if let Some(v) = self.radial_clip.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(60, v, os)?;
        }
        if let Some(v) = self.motionblur_velocity {
            os.write_double(61, v)?;
        }
        if let Some(v) = self.motionblur_dirx {
            os.write_double(62, v)?;
        }
        if let Some(v) = self.motionblur_diry {
            os.write_double(63, v)?;
        }
        if let Some(v) = self.composition_layer_texture_name.as_ref() {
            os.write_string(64, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPushCompositingLayer {
        CMsgPushCompositingLayer::new()
    }

    fn clear(&mut self) {
        self.layer_id = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.layer_quad_top_left_x = ::std::option::Option::None;
        self.layer_quad_top_left_y = ::std::option::Option::None;
        self.layer_quad_top_left_z = ::std::option::Option::None;
        self.layer_quad_top_right_x = ::std::option::Option::None;
        self.layer_quad_top_right_y = ::std::option::Option::None;
        self.layer_quad_top_right_z = ::std::option::Option::None;
        self.layer_quad_bottom_left_x = ::std::option::Option::None;
        self.layer_quad_bottom_left_y = ::std::option::Option::None;
        self.layer_quad_bottom_left_z = ::std::option::Option::None;
        self.layer_quad_bottom_right_x = ::std::option::Option::None;
        self.layer_quad_bottom_right_y = ::std::option::Option::None;
        self.layer_quad_bottom_right_z = ::std::option::Option::None;
        self.transform_m00 = ::std::option::Option::None;
        self.transform_m01 = ::std::option::Option::None;
        self.transform_m02 = ::std::option::Option::None;
        self.transform_m03 = ::std::option::Option::None;
        self.transform_m10 = ::std::option::Option::None;
        self.transform_m11 = ::std::option::Option::None;
        self.transform_m12 = ::std::option::Option::None;
        self.transform_m13 = ::std::option::Option::None;
        self.transform_m20 = ::std::option::Option::None;
        self.transform_m21 = ::std::option::Option::None;
        self.transform_m22 = ::std::option::Option::None;
        self.transform_m23 = ::std::option::Option::None;
        self.transform_m30 = ::std::option::Option::None;
        self.transform_m31 = ::std::option::Option::None;
        self.transform_m32 = ::std::option::Option::None;
        self.transform_m33 = ::std::option::Option::None;
        self.perspective_depth = ::std::option::Option::None;
        self.opacity = ::std::option::Option::None;
        self.composition_color = ::std::option::Option::None;
        self.saturation = ::std::option::Option::None;
        self.hue_shift = ::std::option::Option::None;
        self.brightness = ::std::option::Option::None;
        self.contrast = ::std::option::Option::None;
        self.opacity_mask_texture_id = ::std::option::Option::None;
        self.opacity_mask_opacity = ::std::option::Option::None;
        self.border.clear();
        self.border_radius.clear();
        self.box_shadow.clear();
        self.gaussianblur_passes = ::std::option::Option::None;
        self.gaussianblur_stddevhor = ::std::option::Option::None;
        self.gaussianblur_stddevver = ::std::option::Option::None;
        self.scale_2d_factors_x = ::std::option::Option::None;
        self.scale_2d_factors_y = ::std::option::Option::None;
        self.rotate_2d = ::std::option::Option::None;
        self.needs_clear = ::std::option::Option::None;
        self.needs_depth = ::std::option::Option::None;
        self.needs_intermediate_texture = ::std::option::Option::None;
        self.needs_redraw_every_frame = ::std::option::Option::None;
        self.text_shadow.clear();
        self.mix_blend_mode = ::std::option::Option::None;
        self.occluded_left_edge = ::std::option::Option::None;
        self.occluded_top_edge = ::std::option::Option::None;
        self.occluded_right_edge = ::std::option::Option::None;
        self.occluded_bottom_edge = ::std::option::Option::None;
        self.radial_clip.clear();
        self.motionblur_velocity = ::std::option::Option::None;
        self.motionblur_dirx = ::std::option::Option::None;
        self.motionblur_diry = ::std::option::Option::None;
        self.composition_layer_texture_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPushCompositingLayer {
        static instance: CMsgPushCompositingLayer = CMsgPushCompositingLayer {
            layer_id: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            layer_quad_top_left_x: ::std::option::Option::None,
            layer_quad_top_left_y: ::std::option::Option::None,
            layer_quad_top_left_z: ::std::option::Option::None,
            layer_quad_top_right_x: ::std::option::Option::None,
            layer_quad_top_right_y: ::std::option::Option::None,
            layer_quad_top_right_z: ::std::option::Option::None,
            layer_quad_bottom_left_x: ::std::option::Option::None,
            layer_quad_bottom_left_y: ::std::option::Option::None,
            layer_quad_bottom_left_z: ::std::option::Option::None,
            layer_quad_bottom_right_x: ::std::option::Option::None,
            layer_quad_bottom_right_y: ::std::option::Option::None,
            layer_quad_bottom_right_z: ::std::option::Option::None,
            transform_m00: ::std::option::Option::None,
            transform_m01: ::std::option::Option::None,
            transform_m02: ::std::option::Option::None,
            transform_m03: ::std::option::Option::None,
            transform_m10: ::std::option::Option::None,
            transform_m11: ::std::option::Option::None,
            transform_m12: ::std::option::Option::None,
            transform_m13: ::std::option::Option::None,
            transform_m20: ::std::option::Option::None,
            transform_m21: ::std::option::Option::None,
            transform_m22: ::std::option::Option::None,
            transform_m23: ::std::option::Option::None,
            transform_m30: ::std::option::Option::None,
            transform_m31: ::std::option::Option::None,
            transform_m32: ::std::option::Option::None,
            transform_m33: ::std::option::Option::None,
            perspective_depth: ::std::option::Option::None,
            opacity: ::std::option::Option::None,
            composition_color: ::std::option::Option::None,
            saturation: ::std::option::Option::None,
            hue_shift: ::std::option::Option::None,
            brightness: ::std::option::Option::None,
            contrast: ::std::option::Option::None,
            opacity_mask_texture_id: ::std::option::Option::None,
            opacity_mask_opacity: ::std::option::Option::None,
            border: ::protobuf::MessageField::none(),
            border_radius: ::protobuf::MessageField::none(),
            box_shadow: ::protobuf::MessageField::none(),
            gaussianblur_passes: ::std::option::Option::None,
            gaussianblur_stddevhor: ::std::option::Option::None,
            gaussianblur_stddevver: ::std::option::Option::None,
            scale_2d_factors_x: ::std::option::Option::None,
            scale_2d_factors_y: ::std::option::Option::None,
            rotate_2d: ::std::option::Option::None,
            needs_clear: ::std::option::Option::None,
            needs_depth: ::std::option::Option::None,
            needs_intermediate_texture: ::std::option::Option::None,
            needs_redraw_every_frame: ::std::option::Option::None,
            text_shadow: ::protobuf::MessageField::none(),
            mix_blend_mode: ::std::option::Option::None,
            occluded_left_edge: ::std::option::Option::None,
            occluded_top_edge: ::std::option::Option::None,
            occluded_right_edge: ::std::option::Option::None,
            occluded_bottom_edge: ::std::option::Option::None,
            radial_clip: ::protobuf::MessageField::none(),
            motionblur_velocity: ::std::option::Option::None,
            motionblur_dirx: ::std::option::Option::None,
            motionblur_diry: ::std::option::Option::None,
            composition_layer_texture_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPushCompositingLayer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPushCompositingLayer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPushCompositingLayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPushCompositingLayer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPopCompositingLayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPopCompositingLayer {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPopCompositingLayer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPopCompositingLayer {
    fn default() -> &'a CMsgPopCompositingLayer {
        <CMsgPopCompositingLayer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPopCompositingLayer {
    pub fn new() -> CMsgPopCompositingLayer {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPopCompositingLayer>(
            "CMsgPopCompositingLayer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPopCompositingLayer {
    const NAME: &'static str = "CMsgPopCompositingLayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPopCompositingLayer {
        CMsgPopCompositingLayer::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPopCompositingLayer {
        static instance: CMsgPopCompositingLayer = CMsgPopCompositingLayer {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPopCompositingLayer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPopCompositingLayer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPopCompositingLayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPopCompositingLayer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgFreeCompositingLayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFreeCompositingLayer {
    // message fields
    // @@protoc_insertion_point(field:CMsgFreeCompositingLayer.layer_id)
    pub layer_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFreeCompositingLayer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFreeCompositingLayer {
    fn default() -> &'a CMsgFreeCompositingLayer {
        <CMsgFreeCompositingLayer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFreeCompositingLayer {
    pub fn new() -> CMsgFreeCompositingLayer {
        ::std::default::Default::default()
    }

    // optional uint64 layer_id = 1;

    pub fn layer_id(&self) -> u64 {
        self.layer_id.unwrap_or(0)
    }

    pub fn clear_layer_id(&mut self) {
        self.layer_id = ::std::option::Option::None;
    }

    pub fn has_layer_id(&self) -> bool {
        self.layer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layer_id(&mut self, v: u64) {
        self.layer_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "layer_id",
            |m: &CMsgFreeCompositingLayer| { &m.layer_id },
            |m: &mut CMsgFreeCompositingLayer| { &mut m.layer_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgFreeCompositingLayer>(
            "CMsgFreeCompositingLayer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgFreeCompositingLayer {
    const NAME: &'static str = "CMsgFreeCompositingLayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.layer_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.layer_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.layer_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFreeCompositingLayer {
        CMsgFreeCompositingLayer::new()
    }

    fn clear(&mut self) {
        self.layer_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFreeCompositingLayer {
        static instance: CMsgFreeCompositingLayer = CMsgFreeCompositingLayer {
            layer_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgFreeCompositingLayer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgFreeCompositingLayer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgFreeCompositingLayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFreeCompositingLayer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTransitionData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTransitionData {
    // message fields
    // @@protoc_insertion_point(field:CMsgTransitionData.start_time)
    pub start_time: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgTransitionData.delay_seconds)
    pub delay_seconds: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgTransitionData.duration_seconds)
    pub duration_seconds: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgTransitionData.timing_func)
    pub timing_func: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTransitionData.cubic_bezier_0)
    pub cubic_bezier_0: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTransitionData.cubic_bezier_1)
    pub cubic_bezier_1: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTransitionData.cubic_bezier_2)
    pub cubic_bezier_2: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTransitionData.cubic_bezier_3)
    pub cubic_bezier_3: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTransitionData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTransitionData {
    fn default() -> &'a CMsgTransitionData {
        <CMsgTransitionData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTransitionData {
    pub fn new() -> CMsgTransitionData {
        ::std::default::Default::default()
    }

    // optional double start_time = 1;

    pub fn start_time(&self) -> f64 {
        self.start_time.unwrap_or(0.)
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: f64) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional double delay_seconds = 2;

    pub fn delay_seconds(&self) -> f64 {
        self.delay_seconds.unwrap_or(0.)
    }

    pub fn clear_delay_seconds(&mut self) {
        self.delay_seconds = ::std::option::Option::None;
    }

    pub fn has_delay_seconds(&self) -> bool {
        self.delay_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delay_seconds(&mut self, v: f64) {
        self.delay_seconds = ::std::option::Option::Some(v);
    }

    // optional double duration_seconds = 3;

    pub fn duration_seconds(&self) -> f64 {
        self.duration_seconds.unwrap_or(0.)
    }

    pub fn clear_duration_seconds(&mut self) {
        self.duration_seconds = ::std::option::Option::None;
    }

    pub fn has_duration_seconds(&self) -> bool {
        self.duration_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration_seconds(&mut self, v: f64) {
        self.duration_seconds = ::std::option::Option::Some(v);
    }

    // optional uint32 timing_func = 4;

    pub fn timing_func(&self) -> u32 {
        self.timing_func.unwrap_or(0u32)
    }

    pub fn clear_timing_func(&mut self) {
        self.timing_func = ::std::option::Option::None;
    }

    pub fn has_timing_func(&self) -> bool {
        self.timing_func.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timing_func(&mut self, v: u32) {
        self.timing_func = ::std::option::Option::Some(v);
    }

    // optional float cubic_bezier_0 = 5;

    pub fn cubic_bezier_0(&self) -> f32 {
        self.cubic_bezier_0.unwrap_or(0.)
    }

    pub fn clear_cubic_bezier_0(&mut self) {
        self.cubic_bezier_0 = ::std::option::Option::None;
    }

    pub fn has_cubic_bezier_0(&self) -> bool {
        self.cubic_bezier_0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubic_bezier_0(&mut self, v: f32) {
        self.cubic_bezier_0 = ::std::option::Option::Some(v);
    }

    // optional float cubic_bezier_1 = 6;

    pub fn cubic_bezier_1(&self) -> f32 {
        self.cubic_bezier_1.unwrap_or(0.)
    }

    pub fn clear_cubic_bezier_1(&mut self) {
        self.cubic_bezier_1 = ::std::option::Option::None;
    }

    pub fn has_cubic_bezier_1(&self) -> bool {
        self.cubic_bezier_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubic_bezier_1(&mut self, v: f32) {
        self.cubic_bezier_1 = ::std::option::Option::Some(v);
    }

    // optional float cubic_bezier_2 = 7;

    pub fn cubic_bezier_2(&self) -> f32 {
        self.cubic_bezier_2.unwrap_or(0.)
    }

    pub fn clear_cubic_bezier_2(&mut self) {
        self.cubic_bezier_2 = ::std::option::Option::None;
    }

    pub fn has_cubic_bezier_2(&self) -> bool {
        self.cubic_bezier_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubic_bezier_2(&mut self, v: f32) {
        self.cubic_bezier_2 = ::std::option::Option::Some(v);
    }

    // optional float cubic_bezier_3 = 8;

    pub fn cubic_bezier_3(&self) -> f32 {
        self.cubic_bezier_3.unwrap_or(0.)
    }

    pub fn clear_cubic_bezier_3(&mut self) {
        self.cubic_bezier_3 = ::std::option::Option::None;
    }

    pub fn has_cubic_bezier_3(&self) -> bool {
        self.cubic_bezier_3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubic_bezier_3(&mut self, v: f32) {
        self.cubic_bezier_3 = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_time",
            |m: &CMsgTransitionData| { &m.start_time },
            |m: &mut CMsgTransitionData| { &mut m.start_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "delay_seconds",
            |m: &CMsgTransitionData| { &m.delay_seconds },
            |m: &mut CMsgTransitionData| { &mut m.delay_seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration_seconds",
            |m: &CMsgTransitionData| { &m.duration_seconds },
            |m: &mut CMsgTransitionData| { &mut m.duration_seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timing_func",
            |m: &CMsgTransitionData| { &m.timing_func },
            |m: &mut CMsgTransitionData| { &mut m.timing_func },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cubic_bezier_0",
            |m: &CMsgTransitionData| { &m.cubic_bezier_0 },
            |m: &mut CMsgTransitionData| { &mut m.cubic_bezier_0 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cubic_bezier_1",
            |m: &CMsgTransitionData| { &m.cubic_bezier_1 },
            |m: &mut CMsgTransitionData| { &mut m.cubic_bezier_1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cubic_bezier_2",
            |m: &CMsgTransitionData| { &m.cubic_bezier_2 },
            |m: &mut CMsgTransitionData| { &mut m.cubic_bezier_2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cubic_bezier_3",
            |m: &CMsgTransitionData| { &m.cubic_bezier_3 },
            |m: &mut CMsgTransitionData| { &mut m.cubic_bezier_3 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTransitionData>(
            "CMsgTransitionData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTransitionData {
    const NAME: &'static str = "CMsgTransitionData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.start_time = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.delay_seconds = ::std::option::Option::Some(is.read_double()?);
                },
                25 => {
                    self.duration_seconds = ::std::option::Option::Some(is.read_double()?);
                },
                32 => {
                    self.timing_func = ::std::option::Option::Some(is.read_uint32()?);
                },
                45 => {
                    self.cubic_bezier_0 = ::std::option::Option::Some(is.read_float()?);
                },
                53 => {
                    self.cubic_bezier_1 = ::std::option::Option::Some(is.read_float()?);
                },
                61 => {
                    self.cubic_bezier_2 = ::std::option::Option::Some(is.read_float()?);
                },
                69 => {
                    self.cubic_bezier_3 = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.start_time {
            my_size += 1 + 8;
        }
        if let Some(v) = self.delay_seconds {
            my_size += 1 + 8;
        }
        if let Some(v) = self.duration_seconds {
            my_size += 1 + 8;
        }
        if let Some(v) = self.timing_func {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.cubic_bezier_0 {
            my_size += 1 + 4;
        }
        if let Some(v) = self.cubic_bezier_1 {
            my_size += 1 + 4;
        }
        if let Some(v) = self.cubic_bezier_2 {
            my_size += 1 + 4;
        }
        if let Some(v) = self.cubic_bezier_3 {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.start_time {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.delay_seconds {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.duration_seconds {
            os.write_double(3, v)?;
        }
        if let Some(v) = self.timing_func {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.cubic_bezier_0 {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.cubic_bezier_1 {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.cubic_bezier_2 {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.cubic_bezier_3 {
            os.write_float(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTransitionData {
        CMsgTransitionData::new()
    }

    fn clear(&mut self) {
        self.start_time = ::std::option::Option::None;
        self.delay_seconds = ::std::option::Option::None;
        self.duration_seconds = ::std::option::Option::None;
        self.timing_func = ::std::option::Option::None;
        self.cubic_bezier_0 = ::std::option::Option::None;
        self.cubic_bezier_1 = ::std::option::Option::None;
        self.cubic_bezier_2 = ::std::option::Option::None;
        self.cubic_bezier_3 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTransitionData {
        static instance: CMsgTransitionData = CMsgTransitionData {
            start_time: ::std::option::Option::None,
            delay_seconds: ::std::option::Option::None,
            duration_seconds: ::std::option::Option::None,
            timing_func: ::std::option::Option::None,
            cubic_bezier_0: ::std::option::Option::None,
            cubic_bezier_1: ::std::option::Option::None,
            cubic_bezier_2: ::std::option::Option::None,
            cubic_bezier_3: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTransitionData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTransitionData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTransitionData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTransitionData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgAnimationData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAnimationData {
    // message fields
    // @@protoc_insertion_point(field:CMsgAnimationData.start_time)
    pub start_time: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgAnimationData.delay_seconds)
    pub delay_seconds: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgAnimationData.duration_seconds)
    pub duration_seconds: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgAnimationData.timing_func)
    pub timing_func: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAnimationData.cubic_bezier_0)
    pub cubic_bezier_0: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgAnimationData.cubic_bezier_1)
    pub cubic_bezier_1: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgAnimationData.cubic_bezier_2)
    pub cubic_bezier_2: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgAnimationData.cubic_bezier_3)
    pub cubic_bezier_3: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgAnimationData.direction)
    pub direction: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAnimationData.iteration)
    pub iteration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgAnimationData.frames)
    pub frames: ::std::vec::Vec<CMsgAnimationFrameData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAnimationData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAnimationData {
    fn default() -> &'a CMsgAnimationData {
        <CMsgAnimationData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAnimationData {
    pub fn new() -> CMsgAnimationData {
        ::std::default::Default::default()
    }

    // optional double start_time = 1;

    pub fn start_time(&self) -> f64 {
        self.start_time.unwrap_or(0.)
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: f64) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional double delay_seconds = 2;

    pub fn delay_seconds(&self) -> f64 {
        self.delay_seconds.unwrap_or(0.)
    }

    pub fn clear_delay_seconds(&mut self) {
        self.delay_seconds = ::std::option::Option::None;
    }

    pub fn has_delay_seconds(&self) -> bool {
        self.delay_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delay_seconds(&mut self, v: f64) {
        self.delay_seconds = ::std::option::Option::Some(v);
    }

    // optional double duration_seconds = 3;

    pub fn duration_seconds(&self) -> f64 {
        self.duration_seconds.unwrap_or(0.)
    }

    pub fn clear_duration_seconds(&mut self) {
        self.duration_seconds = ::std::option::Option::None;
    }

    pub fn has_duration_seconds(&self) -> bool {
        self.duration_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration_seconds(&mut self, v: f64) {
        self.duration_seconds = ::std::option::Option::Some(v);
    }

    // optional uint32 timing_func = 4;

    pub fn timing_func(&self) -> u32 {
        self.timing_func.unwrap_or(0)
    }

    pub fn clear_timing_func(&mut self) {
        self.timing_func = ::std::option::Option::None;
    }

    pub fn has_timing_func(&self) -> bool {
        self.timing_func.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timing_func(&mut self, v: u32) {
        self.timing_func = ::std::option::Option::Some(v);
    }

    // optional float cubic_bezier_0 = 5;

    pub fn cubic_bezier_0(&self) -> f32 {
        self.cubic_bezier_0.unwrap_or(0.)
    }

    pub fn clear_cubic_bezier_0(&mut self) {
        self.cubic_bezier_0 = ::std::option::Option::None;
    }

    pub fn has_cubic_bezier_0(&self) -> bool {
        self.cubic_bezier_0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubic_bezier_0(&mut self, v: f32) {
        self.cubic_bezier_0 = ::std::option::Option::Some(v);
    }

    // optional float cubic_bezier_1 = 6;

    pub fn cubic_bezier_1(&self) -> f32 {
        self.cubic_bezier_1.unwrap_or(0.)
    }

    pub fn clear_cubic_bezier_1(&mut self) {
        self.cubic_bezier_1 = ::std::option::Option::None;
    }

    pub fn has_cubic_bezier_1(&self) -> bool {
        self.cubic_bezier_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubic_bezier_1(&mut self, v: f32) {
        self.cubic_bezier_1 = ::std::option::Option::Some(v);
    }

    // optional float cubic_bezier_2 = 7;

    pub fn cubic_bezier_2(&self) -> f32 {
        self.cubic_bezier_2.unwrap_or(0.)
    }

    pub fn clear_cubic_bezier_2(&mut self) {
        self.cubic_bezier_2 = ::std::option::Option::None;
    }

    pub fn has_cubic_bezier_2(&self) -> bool {
        self.cubic_bezier_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubic_bezier_2(&mut self, v: f32) {
        self.cubic_bezier_2 = ::std::option::Option::Some(v);
    }

    // optional float cubic_bezier_3 = 8;

    pub fn cubic_bezier_3(&self) -> f32 {
        self.cubic_bezier_3.unwrap_or(0.)
    }

    pub fn clear_cubic_bezier_3(&mut self) {
        self.cubic_bezier_3 = ::std::option::Option::None;
    }

    pub fn has_cubic_bezier_3(&self) -> bool {
        self.cubic_bezier_3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubic_bezier_3(&mut self, v: f32) {
        self.cubic_bezier_3 = ::std::option::Option::Some(v);
    }

    // optional uint32 direction = 9;

    pub fn direction(&self) -> u32 {
        self.direction.unwrap_or(0)
    }

    pub fn clear_direction(&mut self) {
        self.direction = ::std::option::Option::None;
    }

    pub fn has_direction(&self) -> bool {
        self.direction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: u32) {
        self.direction = ::std::option::Option::Some(v);
    }

    // optional float iteration = 10;

    pub fn iteration(&self) -> f32 {
        self.iteration.unwrap_or(0.)
    }

    pub fn clear_iteration(&mut self) {
        self.iteration = ::std::option::Option::None;
    }

    pub fn has_iteration(&self) -> bool {
        self.iteration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iteration(&mut self, v: f32) {
        self.iteration = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_time",
            |m: &CMsgAnimationData| { &m.start_time },
            |m: &mut CMsgAnimationData| { &mut m.start_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "delay_seconds",
            |m: &CMsgAnimationData| { &m.delay_seconds },
            |m: &mut CMsgAnimationData| { &mut m.delay_seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration_seconds",
            |m: &CMsgAnimationData| { &m.duration_seconds },
            |m: &mut CMsgAnimationData| { &mut m.duration_seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timing_func",
            |m: &CMsgAnimationData| { &m.timing_func },
            |m: &mut CMsgAnimationData| { &mut m.timing_func },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cubic_bezier_0",
            |m: &CMsgAnimationData| { &m.cubic_bezier_0 },
            |m: &mut CMsgAnimationData| { &mut m.cubic_bezier_0 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cubic_bezier_1",
            |m: &CMsgAnimationData| { &m.cubic_bezier_1 },
            |m: &mut CMsgAnimationData| { &mut m.cubic_bezier_1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cubic_bezier_2",
            |m: &CMsgAnimationData| { &m.cubic_bezier_2 },
            |m: &mut CMsgAnimationData| { &mut m.cubic_bezier_2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cubic_bezier_3",
            |m: &CMsgAnimationData| { &m.cubic_bezier_3 },
            |m: &mut CMsgAnimationData| { &mut m.cubic_bezier_3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "direction",
            |m: &CMsgAnimationData| { &m.direction },
            |m: &mut CMsgAnimationData| { &mut m.direction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "iteration",
            |m: &CMsgAnimationData| { &m.iteration },
            |m: &mut CMsgAnimationData| { &mut m.iteration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "frames",
            |m: &CMsgAnimationData| { &m.frames },
            |m: &mut CMsgAnimationData| { &mut m.frames },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAnimationData>(
            "CMsgAnimationData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgAnimationData {
    const NAME: &'static str = "CMsgAnimationData";

    fn is_initialized(&self) -> bool {
        for v in &self.frames {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.start_time = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.delay_seconds = ::std::option::Option::Some(is.read_double()?);
                },
                25 => {
                    self.duration_seconds = ::std::option::Option::Some(is.read_double()?);
                },
                32 => {
                    self.timing_func = ::std::option::Option::Some(is.read_uint32()?);
                },
                45 => {
                    self.cubic_bezier_0 = ::std::option::Option::Some(is.read_float()?);
                },
                53 => {
                    self.cubic_bezier_1 = ::std::option::Option::Some(is.read_float()?);
                },
                61 => {
                    self.cubic_bezier_2 = ::std::option::Option::Some(is.read_float()?);
                },
                69 => {
                    self.cubic_bezier_3 = ::std::option::Option::Some(is.read_float()?);
                },
                72 => {
                    self.direction = ::std::option::Option::Some(is.read_uint32()?);
                },
                85 => {
                    self.iteration = ::std::option::Option::Some(is.read_float()?);
                },
                90 => {
                    self.frames.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.start_time {
            my_size += 1 + 8;
        }
        if let Some(v) = self.delay_seconds {
            my_size += 1 + 8;
        }
        if let Some(v) = self.duration_seconds {
            my_size += 1 + 8;
        }
        if let Some(v) = self.timing_func {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.cubic_bezier_0 {
            my_size += 1 + 4;
        }
        if let Some(v) = self.cubic_bezier_1 {
            my_size += 1 + 4;
        }
        if let Some(v) = self.cubic_bezier_2 {
            my_size += 1 + 4;
        }
        if let Some(v) = self.cubic_bezier_3 {
            my_size += 1 + 4;
        }
        if let Some(v) = self.direction {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.iteration {
            my_size += 1 + 4;
        }
        for value in &self.frames {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.start_time {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.delay_seconds {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.duration_seconds {
            os.write_double(3, v)?;
        }
        if let Some(v) = self.timing_func {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.cubic_bezier_0 {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.cubic_bezier_1 {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.cubic_bezier_2 {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.cubic_bezier_3 {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.direction {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.iteration {
            os.write_float(10, v)?;
        }
        for v in &self.frames {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAnimationData {
        CMsgAnimationData::new()
    }

    fn clear(&mut self) {
        self.start_time = ::std::option::Option::None;
        self.delay_seconds = ::std::option::Option::None;
        self.duration_seconds = ::std::option::Option::None;
        self.timing_func = ::std::option::Option::None;
        self.cubic_bezier_0 = ::std::option::Option::None;
        self.cubic_bezier_1 = ::std::option::Option::None;
        self.cubic_bezier_2 = ::std::option::Option::None;
        self.cubic_bezier_3 = ::std::option::Option::None;
        self.direction = ::std::option::Option::None;
        self.iteration = ::std::option::Option::None;
        self.frames.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAnimationData {
        static instance: CMsgAnimationData = CMsgAnimationData {
            start_time: ::std::option::Option::None,
            delay_seconds: ::std::option::Option::None,
            duration_seconds: ::std::option::Option::None,
            timing_func: ::std::option::Option::None,
            cubic_bezier_0: ::std::option::Option::None,
            cubic_bezier_1: ::std::option::Option::None,
            cubic_bezier_2: ::std::option::Option::None,
            cubic_bezier_3: ::std::option::Option::None,
            direction: ::std::option::Option::None,
            iteration: ::std::option::Option::None,
            frames: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgAnimationData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAnimationData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAnimationData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAnimationData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgAnimationFrameData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAnimationFrameData {
    // message fields
    // @@protoc_insertion_point(field:CMsgAnimationFrameData.percent)
    pub percent: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgAnimationFrameData.timing_func)
    pub timing_func: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAnimationFrameData.cubic_bezier_0)
    pub cubic_bezier_0: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgAnimationFrameData.cubic_bezier_1)
    pub cubic_bezier_1: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgAnimationFrameData.cubic_bezier_2)
    pub cubic_bezier_2: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgAnimationFrameData.cubic_bezier_3)
    pub cubic_bezier_3: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAnimationFrameData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAnimationFrameData {
    fn default() -> &'a CMsgAnimationFrameData {
        <CMsgAnimationFrameData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAnimationFrameData {
    pub fn new() -> CMsgAnimationFrameData {
        ::std::default::Default::default()
    }

    // optional float percent = 1;

    pub fn percent(&self) -> f32 {
        self.percent.unwrap_or(0.)
    }

    pub fn clear_percent(&mut self) {
        self.percent = ::std::option::Option::None;
    }

    pub fn has_percent(&self) -> bool {
        self.percent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_percent(&mut self, v: f32) {
        self.percent = ::std::option::Option::Some(v);
    }

    // optional uint32 timing_func = 2;

    pub fn timing_func(&self) -> u32 {
        self.timing_func.unwrap_or(0u32)
    }

    pub fn clear_timing_func(&mut self) {
        self.timing_func = ::std::option::Option::None;
    }

    pub fn has_timing_func(&self) -> bool {
        self.timing_func.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timing_func(&mut self, v: u32) {
        self.timing_func = ::std::option::Option::Some(v);
    }

    // optional float cubic_bezier_0 = 3;

    pub fn cubic_bezier_0(&self) -> f32 {
        self.cubic_bezier_0.unwrap_or(0.)
    }

    pub fn clear_cubic_bezier_0(&mut self) {
        self.cubic_bezier_0 = ::std::option::Option::None;
    }

    pub fn has_cubic_bezier_0(&self) -> bool {
        self.cubic_bezier_0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubic_bezier_0(&mut self, v: f32) {
        self.cubic_bezier_0 = ::std::option::Option::Some(v);
    }

    // optional float cubic_bezier_1 = 4;

    pub fn cubic_bezier_1(&self) -> f32 {
        self.cubic_bezier_1.unwrap_or(0.)
    }

    pub fn clear_cubic_bezier_1(&mut self) {
        self.cubic_bezier_1 = ::std::option::Option::None;
    }

    pub fn has_cubic_bezier_1(&self) -> bool {
        self.cubic_bezier_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubic_bezier_1(&mut self, v: f32) {
        self.cubic_bezier_1 = ::std::option::Option::Some(v);
    }

    // optional float cubic_bezier_2 = 5;

    pub fn cubic_bezier_2(&self) -> f32 {
        self.cubic_bezier_2.unwrap_or(0.)
    }

    pub fn clear_cubic_bezier_2(&mut self) {
        self.cubic_bezier_2 = ::std::option::Option::None;
    }

    pub fn has_cubic_bezier_2(&self) -> bool {
        self.cubic_bezier_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubic_bezier_2(&mut self, v: f32) {
        self.cubic_bezier_2 = ::std::option::Option::Some(v);
    }

    // optional float cubic_bezier_3 = 6;

    pub fn cubic_bezier_3(&self) -> f32 {
        self.cubic_bezier_3.unwrap_or(0.)
    }

    pub fn clear_cubic_bezier_3(&mut self) {
        self.cubic_bezier_3 = ::std::option::Option::None;
    }

    pub fn has_cubic_bezier_3(&self) -> bool {
        self.cubic_bezier_3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubic_bezier_3(&mut self, v: f32) {
        self.cubic_bezier_3 = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "percent",
            |m: &CMsgAnimationFrameData| { &m.percent },
            |m: &mut CMsgAnimationFrameData| { &mut m.percent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timing_func",
            |m: &CMsgAnimationFrameData| { &m.timing_func },
            |m: &mut CMsgAnimationFrameData| { &mut m.timing_func },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cubic_bezier_0",
            |m: &CMsgAnimationFrameData| { &m.cubic_bezier_0 },
            |m: &mut CMsgAnimationFrameData| { &mut m.cubic_bezier_0 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cubic_bezier_1",
            |m: &CMsgAnimationFrameData| { &m.cubic_bezier_1 },
            |m: &mut CMsgAnimationFrameData| { &mut m.cubic_bezier_1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cubic_bezier_2",
            |m: &CMsgAnimationFrameData| { &m.cubic_bezier_2 },
            |m: &mut CMsgAnimationFrameData| { &mut m.cubic_bezier_2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cubic_bezier_3",
            |m: &CMsgAnimationFrameData| { &m.cubic_bezier_3 },
            |m: &mut CMsgAnimationFrameData| { &mut m.cubic_bezier_3 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAnimationFrameData>(
            "CMsgAnimationFrameData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgAnimationFrameData {
    const NAME: &'static str = "CMsgAnimationFrameData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.percent = ::std::option::Option::Some(is.read_float()?);
                },
                16 => {
                    self.timing_func = ::std::option::Option::Some(is.read_uint32()?);
                },
                29 => {
                    self.cubic_bezier_0 = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.cubic_bezier_1 = ::std::option::Option::Some(is.read_float()?);
                },
                45 => {
                    self.cubic_bezier_2 = ::std::option::Option::Some(is.read_float()?);
                },
                53 => {
                    self.cubic_bezier_3 = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.percent {
            my_size += 1 + 4;
        }
        if let Some(v) = self.timing_func {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.cubic_bezier_0 {
            my_size += 1 + 4;
        }
        if let Some(v) = self.cubic_bezier_1 {
            my_size += 1 + 4;
        }
        if let Some(v) = self.cubic_bezier_2 {
            my_size += 1 + 4;
        }
        if let Some(v) = self.cubic_bezier_3 {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.percent {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.timing_func {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.cubic_bezier_0 {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.cubic_bezier_1 {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.cubic_bezier_2 {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.cubic_bezier_3 {
            os.write_float(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAnimationFrameData {
        CMsgAnimationFrameData::new()
    }

    fn clear(&mut self) {
        self.percent = ::std::option::Option::None;
        self.timing_func = ::std::option::Option::None;
        self.cubic_bezier_0 = ::std::option::Option::None;
        self.cubic_bezier_1 = ::std::option::Option::None;
        self.cubic_bezier_2 = ::std::option::Option::None;
        self.cubic_bezier_3 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAnimationFrameData {
        static instance: CMsgAnimationFrameData = CMsgAnimationFrameData {
            percent: ::std::option::Option::None,
            timing_func: ::std::option::Option::None,
            cubic_bezier_0: ::std::option::Option::None,
            cubic_bezier_1: ::std::option::Option::None,
            cubic_bezier_2: ::std::option::Option::None,
            cubic_bezier_3: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgAnimationFrameData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAnimationFrameData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAnimationFrameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAnimationFrameData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPointWithTransition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPointWithTransition {
    // message fields
    // @@protoc_insertion_point(field:CMsgPointWithTransition.base)
    pub base: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgPointWithTransition.transition)
    pub transition: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgPointWithTransition.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsgPointWithTransition.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPointWithTransition.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPointWithTransition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPointWithTransition {
    fn default() -> &'a CMsgPointWithTransition {
        <CMsgPointWithTransition as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPointWithTransition {
    pub fn new() -> CMsgPointWithTransition {
        ::std::default::Default::default()
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "base",
            |m: &CMsgPointWithTransition| { &m.base },
            |m: &mut CMsgPointWithTransition| { &mut m.base },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "transition",
            |m: &CMsgPointWithTransition| { &m.transition },
            |m: &mut CMsgPointWithTransition| { &mut m.transition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgTransitionData>(
            "transition_data",
            |m: &CMsgPointWithTransition| { &m.transition_data },
            |m: &mut CMsgPointWithTransition| { &mut m.transition_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "style_symbol",
            |m: &CMsgPointWithTransition| { &m.style_symbol },
            |m: &mut CMsgPointWithTransition| { &mut m.style_symbol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "animations",
            |m: &CMsgPointWithTransition| { &m.animations },
            |m: &mut CMsgPointWithTransition| { &mut m.animations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPointWithTransition>(
            "CMsgPointWithTransition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPointWithTransition {
    const NAME: &'static str = "CMsgPointWithTransition";

    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.transition.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPointWithTransition {
        CMsgPointWithTransition::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.transition.clear();
        self.transition_data.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPointWithTransition {
        static instance: CMsgPointWithTransition = CMsgPointWithTransition {
            base: ::protobuf::MessageField::none(),
            transition: ::protobuf::MessageField::none(),
            transition_data: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPointWithTransition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPointWithTransition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPointWithTransition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPointWithTransition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgPointWithTransition`
pub mod cmsg_point_with_transition {
    // @@protoc_insertion_point(message:CMsgPointWithTransition.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsgPointWithTransition.AnimationFrameData.data)
        pub data: ::protobuf::MessageField<super::CMsgPoint>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgPointWithTransition.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::CMsgPoint>(
                "data",
                |m: &AnimationFrameData| { &m.data },
                |m: &mut AnimationFrameData| { &mut m.data },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AnimationFrameData>(
                "CMsgPointWithTransition.AnimationFrameData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AnimationFrameData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgPointWithTransition.AnimationFrameData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AnimationFrameData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AnimationFrameData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgColor)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgColor {
    // message fields
    // @@protoc_insertion_point(field:CMsgColor.base)
    pub base: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgColor.transition)
    pub transition: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgColor.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsgColor.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgColor.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgColor.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgColor {
    fn default() -> &'a CMsgColor {
        <CMsgColor as ::protobuf::Message>::default_instance()
    }
}

impl CMsgColor {
    pub fn new() -> CMsgColor {
        ::std::default::Default::default()
    }

    // optional uint32 base = 1;

    pub fn base(&self) -> u32 {
        self.base.unwrap_or(0)
    }

    pub fn clear_base(&mut self) {
        self.base = ::std::option::Option::None;
    }

    pub fn has_base(&self) -> bool {
        self.base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base(&mut self, v: u32) {
        self.base = ::std::option::Option::Some(v);
    }

    // optional uint32 transition = 2;

    pub fn transition(&self) -> u32 {
        self.transition.unwrap_or(0)
    }

    pub fn clear_transition(&mut self) {
        self.transition = ::std::option::Option::None;
    }

    pub fn has_transition(&self) -> bool {
        self.transition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transition(&mut self, v: u32) {
        self.transition = ::std::option::Option::Some(v);
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "base",
            |m: &CMsgColor| { &m.base },
            |m: &mut CMsgColor| { &mut m.base },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transition",
            |m: &CMsgColor| { &m.transition },
            |m: &mut CMsgColor| { &mut m.transition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgTransitionData>(
            "transition_data",
            |m: &CMsgColor| { &m.transition_data },
            |m: &mut CMsgColor| { &mut m.transition_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "style_symbol",
            |m: &CMsgColor| { &m.style_symbol },
            |m: &mut CMsgColor| { &mut m.style_symbol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "animations",
            |m: &CMsgColor| { &m.animations },
            |m: &mut CMsgColor| { &mut m.animations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgColor>(
            "CMsgColor",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgColor {
    const NAME: &'static str = "CMsgColor";

    fn is_initialized(&self) -> bool {
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.base = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.transition = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.transition {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.transition {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgColor {
        CMsgColor::new()
    }

    fn clear(&mut self) {
        self.base = ::std::option::Option::None;
        self.transition = ::std::option::Option::None;
        self.transition_data.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgColor {
        static instance: CMsgColor = CMsgColor {
            base: ::std::option::Option::None,
            transition: ::std::option::Option::None,
            transition_data: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgColor {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgColor").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgColor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgColor {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgColor`
pub mod cmsg_color {
    // @@protoc_insertion_point(message:CMsgColor.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsgColor.AnimationFrameData.data)
        pub data: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgColor.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }

        // optional uint32 data = 1;

        pub fn data(&self) -> u32 {
            self.data.unwrap_or(0)
        }

        pub fn clear_data(&mut self) {
            self.data = ::std::option::Option::None;
        }

        pub fn has_data(&self) -> bool {
            self.data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data(&mut self, v: u32) {
            self.data = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "data",
                |m: &AnimationFrameData| { &m.data },
                |m: &mut AnimationFrameData| { &mut m.data },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AnimationFrameData>(
                "CMsgColor.AnimationFrameData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.data = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data {
                os.write_uint32(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AnimationFrameData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgColor.AnimationFrameData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AnimationFrameData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AnimationFrameData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgColorStop)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgColorStop {
    // message fields
    // @@protoc_insertion_point(field:CMsgColorStop.position)
    pub position: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgColorStop.color_rgba)
    pub color_rgba: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgColorStop.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgColorStop {
    fn default() -> &'a CMsgColorStop {
        <CMsgColorStop as ::protobuf::Message>::default_instance()
    }
}

impl CMsgColorStop {
    pub fn new() -> CMsgColorStop {
        ::std::default::Default::default()
    }

    // optional double position = 1;

    pub fn position(&self) -> f64 {
        self.position.unwrap_or(0.)
    }

    pub fn clear_position(&mut self) {
        self.position = ::std::option::Option::None;
    }

    pub fn has_position(&self) -> bool {
        self.position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: f64) {
        self.position = ::std::option::Option::Some(v);
    }

    // optional uint32 color_rgba = 2;

    pub fn color_rgba(&self) -> u32 {
        self.color_rgba.unwrap_or(0)
    }

    pub fn clear_color_rgba(&mut self) {
        self.color_rgba = ::std::option::Option::None;
    }

    pub fn has_color_rgba(&self) -> bool {
        self.color_rgba.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color_rgba(&mut self, v: u32) {
        self.color_rgba = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "position",
            |m: &CMsgColorStop| { &m.position },
            |m: &mut CMsgColorStop| { &mut m.position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "color_rgba",
            |m: &CMsgColorStop| { &m.color_rgba },
            |m: &mut CMsgColorStop| { &mut m.color_rgba },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgColorStop>(
            "CMsgColorStop",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgColorStop {
    const NAME: &'static str = "CMsgColorStop";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.position = ::std::option::Option::Some(is.read_double()?);
                },
                16 => {
                    self.color_rgba = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.position {
            my_size += 1 + 8;
        }
        if let Some(v) = self.color_rgba {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.position {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.color_rgba {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgColorStop {
        CMsgColorStop::new()
    }

    fn clear(&mut self) {
        self.position = ::std::option::Option::None;
        self.color_rgba = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgColorStop {
        static instance: CMsgColorStop = CMsgColorStop {
            position: ::std::option::Option::None,
            color_rgba: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgColorStop {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgColorStop").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgColorStop {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgColorStop {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgLinearGradient)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLinearGradient {
    // message fields
    // @@protoc_insertion_point(field:CMsgLinearGradient.start_position)
    pub start_position: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgLinearGradient.end_position)
    pub end_position: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgLinearGradient.color_stop)
    pub color_stop: ::std::vec::Vec<CMsgColorStop>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLinearGradient.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLinearGradient {
    fn default() -> &'a CMsgLinearGradient {
        <CMsgLinearGradient as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLinearGradient {
    pub fn new() -> CMsgLinearGradient {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "start_position",
            |m: &CMsgLinearGradient| { &m.start_position },
            |m: &mut CMsgLinearGradient| { &mut m.start_position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "end_position",
            |m: &CMsgLinearGradient| { &m.end_position },
            |m: &mut CMsgLinearGradient| { &mut m.end_position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "color_stop",
            |m: &CMsgLinearGradient| { &m.color_stop },
            |m: &mut CMsgLinearGradient| { &mut m.color_stop },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLinearGradient>(
            "CMsgLinearGradient",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgLinearGradient {
    const NAME: &'static str = "CMsgLinearGradient";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.start_position)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.end_position)?;
                },
                26 => {
                    self.color_stop.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.start_position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.end_position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.color_stop {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.start_position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.end_position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.color_stop {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLinearGradient {
        CMsgLinearGradient::new()
    }

    fn clear(&mut self) {
        self.start_position.clear();
        self.end_position.clear();
        self.color_stop.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLinearGradient {
        static instance: CMsgLinearGradient = CMsgLinearGradient {
            start_position: ::protobuf::MessageField::none(),
            end_position: ::protobuf::MessageField::none(),
            color_stop: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgLinearGradient {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLinearGradient").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLinearGradient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLinearGradient {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgRadialGradient)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRadialGradient {
    // message fields
    // @@protoc_insertion_point(field:CMsgRadialGradient.center_position)
    pub center_position: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgRadialGradient.offset_distance)
    pub offset_distance: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgRadialGradient.radii)
    pub radii: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgRadialGradient.color_stop)
    pub color_stop: ::std::vec::Vec<CMsgColorStop>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRadialGradient.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRadialGradient {
    fn default() -> &'a CMsgRadialGradient {
        <CMsgRadialGradient as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRadialGradient {
    pub fn new() -> CMsgRadialGradient {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "center_position",
            |m: &CMsgRadialGradient| { &m.center_position },
            |m: &mut CMsgRadialGradient| { &mut m.center_position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "offset_distance",
            |m: &CMsgRadialGradient| { &m.offset_distance },
            |m: &mut CMsgRadialGradient| { &mut m.offset_distance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "radii",
            |m: &CMsgRadialGradient| { &m.radii },
            |m: &mut CMsgRadialGradient| { &mut m.radii },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "color_stop",
            |m: &CMsgRadialGradient| { &m.color_stop },
            |m: &mut CMsgRadialGradient| { &mut m.color_stop },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRadialGradient>(
            "CMsgRadialGradient",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRadialGradient {
    const NAME: &'static str = "CMsgRadialGradient";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.center_position)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.offset_distance)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.radii)?;
                },
                34 => {
                    self.color_stop.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.center_position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.offset_distance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.radii.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.color_stop {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.center_position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.offset_distance.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.radii.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.color_stop {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRadialGradient {
        CMsgRadialGradient::new()
    }

    fn clear(&mut self) {
        self.center_position.clear();
        self.offset_distance.clear();
        self.radii.clear();
        self.color_stop.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRadialGradient {
        static instance: CMsgRadialGradient = CMsgRadialGradient {
            center_position: ::protobuf::MessageField::none(),
            offset_distance: ::protobuf::MessageField::none(),
            radii: ::protobuf::MessageField::none(),
            color_stop: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRadialGradient {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRadialGradient").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRadialGradient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRadialGradient {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgParticle)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgParticle {
    // message fields
    // @@protoc_insertion_point(field:CMsgParticle.particle_position)
    pub particle_position: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgParticle.particle_size)
    pub particle_size: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgParticle.particle_sharpness)
    pub particle_sharpness: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgParticle.color_rgba)
    pub color_rgba: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgParticle.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgParticle {
    fn default() -> &'a CMsgParticle {
        <CMsgParticle as ::protobuf::Message>::default_instance()
    }
}

impl CMsgParticle {
    pub fn new() -> CMsgParticle {
        ::std::default::Default::default()
    }

    // optional float particle_size = 2;

    pub fn particle_size(&self) -> f32 {
        self.particle_size.unwrap_or(0.)
    }

    pub fn clear_particle_size(&mut self) {
        self.particle_size = ::std::option::Option::None;
    }

    pub fn has_particle_size(&self) -> bool {
        self.particle_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_particle_size(&mut self, v: f32) {
        self.particle_size = ::std::option::Option::Some(v);
    }

    // optional float particle_sharpness = 3;

    pub fn particle_sharpness(&self) -> f32 {
        self.particle_sharpness.unwrap_or(0.)
    }

    pub fn clear_particle_sharpness(&mut self) {
        self.particle_sharpness = ::std::option::Option::None;
    }

    pub fn has_particle_sharpness(&self) -> bool {
        self.particle_sharpness.is_some()
    }

    // Param is passed by value, moved
    pub fn set_particle_sharpness(&mut self, v: f32) {
        self.particle_sharpness = ::std::option::Option::Some(v);
    }

    // optional uint32 color_rgba = 4;

    pub fn color_rgba(&self) -> u32 {
        self.color_rgba.unwrap_or(0)
    }

    pub fn clear_color_rgba(&mut self) {
        self.color_rgba = ::std::option::Option::None;
    }

    pub fn has_color_rgba(&self) -> bool {
        self.color_rgba.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color_rgba(&mut self, v: u32) {
        self.color_rgba = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "particle_position",
            |m: &CMsgParticle| { &m.particle_position },
            |m: &mut CMsgParticle| { &mut m.particle_position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "particle_size",
            |m: &CMsgParticle| { &m.particle_size },
            |m: &mut CMsgParticle| { &mut m.particle_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "particle_sharpness",
            |m: &CMsgParticle| { &m.particle_sharpness },
            |m: &mut CMsgParticle| { &mut m.particle_sharpness },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "color_rgba",
            |m: &CMsgParticle| { &m.color_rgba },
            |m: &mut CMsgParticle| { &mut m.color_rgba },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgParticle>(
            "CMsgParticle",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgParticle {
    const NAME: &'static str = "CMsgParticle";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.particle_position)?;
                },
                21 => {
                    self.particle_size = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.particle_sharpness = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.color_rgba = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.particle_position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.particle_size {
            my_size += 1 + 4;
        }
        if let Some(v) = self.particle_sharpness {
            my_size += 1 + 4;
        }
        if let Some(v) = self.color_rgba {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.particle_position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.particle_size {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.particle_sharpness {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.color_rgba {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgParticle {
        CMsgParticle::new()
    }

    fn clear(&mut self) {
        self.particle_position.clear();
        self.particle_size = ::std::option::Option::None;
        self.particle_sharpness = ::std::option::Option::None;
        self.color_rgba = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgParticle {
        static instance: CMsgParticle = CMsgParticle {
            particle_position: ::protobuf::MessageField::none(),
            particle_size: ::std::option::Option::None,
            particle_sharpness: ::std::option::Option::None,
            color_rgba: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgParticle {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgParticle").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgParticle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgParticle {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgParticleSystem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgParticleSystem {
    // message fields
    // @@protoc_insertion_point(field:CMsgParticleSystem.base_position)
    pub base_position: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.base_position_variance)
    pub base_position_variance: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.particle_size)
    pub particle_size: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.particle_size_variance)
    pub particle_size_variance: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.particles_per_second)
    pub particles_per_second: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.particles_per_second_variance)
    pub particles_per_second_variance: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.particle_lifespan_seconds)
    pub particle_lifespan_seconds: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.particle_lifespan_seconds_variance)
    pub particle_lifespan_seconds_variance: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.particle_initial_velocity)
    pub particle_initial_velocity: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.particle_initial_velocity_variance)
    pub particle_initial_velocity_variance: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.gravity_acceleration)
    pub gravity_acceleration: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.gravity_acceleration_particle_variance)
    pub gravity_acceleration_particle_variance: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.color_start_rgba)
    pub color_start_rgba: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.color_start_rgba_variance)
    pub color_start_rgba_variance: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.color_end_rgba)
    pub color_end_rgba: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.color_end_rgba_variance)
    pub color_end_rgba_variance: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.parent_panel_handle)
    pub parent_panel_handle: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.parent_brush_index)
    pub parent_brush_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.particle_sharpness)
    pub particle_sharpness: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.particle_sharpness_variance)
    pub particle_sharpness_variance: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.particle_flicker)
    pub particle_flicker: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.particle_flicker_variance)
    pub particle_flicker_variance: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.particle_velocity_min)
    pub particle_velocity_min: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.particle_velocity_max)
    pub particle_velocity_max: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgParticleSystem.particles)
    pub particles: ::std::vec::Vec<CMsgParticle>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgParticleSystem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgParticleSystem {
    fn default() -> &'a CMsgParticleSystem {
        <CMsgParticleSystem as ::protobuf::Message>::default_instance()
    }
}

impl CMsgParticleSystem {
    pub fn new() -> CMsgParticleSystem {
        ::std::default::Default::default()
    }

    // optional double particle_size = 3;

    pub fn particle_size(&self) -> f64 {
        self.particle_size.unwrap_or(0.)
    }

    pub fn clear_particle_size(&mut self) {
        self.particle_size = ::std::option::Option::None;
    }

    pub fn has_particle_size(&self) -> bool {
        self.particle_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_particle_size(&mut self, v: f64) {
        self.particle_size = ::std::option::Option::Some(v);
    }

    // optional double particle_size_variance = 4;

    pub fn particle_size_variance(&self) -> f64 {
        self.particle_size_variance.unwrap_or(0.)
    }

    pub fn clear_particle_size_variance(&mut self) {
        self.particle_size_variance = ::std::option::Option::None;
    }

    pub fn has_particle_size_variance(&self) -> bool {
        self.particle_size_variance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_particle_size_variance(&mut self, v: f64) {
        self.particle_size_variance = ::std::option::Option::Some(v);
    }

    // optional double particles_per_second = 5;

    pub fn particles_per_second(&self) -> f64 {
        self.particles_per_second.unwrap_or(0.)
    }

    pub fn clear_particles_per_second(&mut self) {
        self.particles_per_second = ::std::option::Option::None;
    }

    pub fn has_particles_per_second(&self) -> bool {
        self.particles_per_second.is_some()
    }

    // Param is passed by value, moved
    pub fn set_particles_per_second(&mut self, v: f64) {
        self.particles_per_second = ::std::option::Option::Some(v);
    }

    // optional double particles_per_second_variance = 6;

    pub fn particles_per_second_variance(&self) -> f64 {
        self.particles_per_second_variance.unwrap_or(0.)
    }

    pub fn clear_particles_per_second_variance(&mut self) {
        self.particles_per_second_variance = ::std::option::Option::None;
    }

    pub fn has_particles_per_second_variance(&self) -> bool {
        self.particles_per_second_variance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_particles_per_second_variance(&mut self, v: f64) {
        self.particles_per_second_variance = ::std::option::Option::Some(v);
    }

    // optional double particle_lifespan_seconds = 7;

    pub fn particle_lifespan_seconds(&self) -> f64 {
        self.particle_lifespan_seconds.unwrap_or(0.)
    }

    pub fn clear_particle_lifespan_seconds(&mut self) {
        self.particle_lifespan_seconds = ::std::option::Option::None;
    }

    pub fn has_particle_lifespan_seconds(&self) -> bool {
        self.particle_lifespan_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_particle_lifespan_seconds(&mut self, v: f64) {
        self.particle_lifespan_seconds = ::std::option::Option::Some(v);
    }

    // optional double particle_lifespan_seconds_variance = 8;

    pub fn particle_lifespan_seconds_variance(&self) -> f64 {
        self.particle_lifespan_seconds_variance.unwrap_or(0.)
    }

    pub fn clear_particle_lifespan_seconds_variance(&mut self) {
        self.particle_lifespan_seconds_variance = ::std::option::Option::None;
    }

    pub fn has_particle_lifespan_seconds_variance(&self) -> bool {
        self.particle_lifespan_seconds_variance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_particle_lifespan_seconds_variance(&mut self, v: f64) {
        self.particle_lifespan_seconds_variance = ::std::option::Option::Some(v);
    }

    // optional uint32 color_start_rgba = 13;

    pub fn color_start_rgba(&self) -> u32 {
        self.color_start_rgba.unwrap_or(0)
    }

    pub fn clear_color_start_rgba(&mut self) {
        self.color_start_rgba = ::std::option::Option::None;
    }

    pub fn has_color_start_rgba(&self) -> bool {
        self.color_start_rgba.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color_start_rgba(&mut self, v: u32) {
        self.color_start_rgba = ::std::option::Option::Some(v);
    }

    // optional uint32 color_start_rgba_variance = 14;

    pub fn color_start_rgba_variance(&self) -> u32 {
        self.color_start_rgba_variance.unwrap_or(0)
    }

    pub fn clear_color_start_rgba_variance(&mut self) {
        self.color_start_rgba_variance = ::std::option::Option::None;
    }

    pub fn has_color_start_rgba_variance(&self) -> bool {
        self.color_start_rgba_variance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color_start_rgba_variance(&mut self, v: u32) {
        self.color_start_rgba_variance = ::std::option::Option::Some(v);
    }

    // optional uint32 color_end_rgba = 15;

    pub fn color_end_rgba(&self) -> u32 {
        self.color_end_rgba.unwrap_or(0)
    }

    pub fn clear_color_end_rgba(&mut self) {
        self.color_end_rgba = ::std::option::Option::None;
    }

    pub fn has_color_end_rgba(&self) -> bool {
        self.color_end_rgba.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color_end_rgba(&mut self, v: u32) {
        self.color_end_rgba = ::std::option::Option::Some(v);
    }

    // optional uint32 color_end_rgba_variance = 16;

    pub fn color_end_rgba_variance(&self) -> u32 {
        self.color_end_rgba_variance.unwrap_or(0)
    }

    pub fn clear_color_end_rgba_variance(&mut self) {
        self.color_end_rgba_variance = ::std::option::Option::None;
    }

    pub fn has_color_end_rgba_variance(&self) -> bool {
        self.color_end_rgba_variance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color_end_rgba_variance(&mut self, v: u32) {
        self.color_end_rgba_variance = ::std::option::Option::Some(v);
    }

    // optional uint64 parent_panel_handle = 17;

    pub fn parent_panel_handle(&self) -> u64 {
        self.parent_panel_handle.unwrap_or(0)
    }

    pub fn clear_parent_panel_handle(&mut self) {
        self.parent_panel_handle = ::std::option::Option::None;
    }

    pub fn has_parent_panel_handle(&self) -> bool {
        self.parent_panel_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent_panel_handle(&mut self, v: u64) {
        self.parent_panel_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 parent_brush_index = 18;

    pub fn parent_brush_index(&self) -> u32 {
        self.parent_brush_index.unwrap_or(0)
    }

    pub fn clear_parent_brush_index(&mut self) {
        self.parent_brush_index = ::std::option::Option::None;
    }

    pub fn has_parent_brush_index(&self) -> bool {
        self.parent_brush_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent_brush_index(&mut self, v: u32) {
        self.parent_brush_index = ::std::option::Option::Some(v);
    }

    // optional float particle_sharpness = 19;

    pub fn particle_sharpness(&self) -> f32 {
        self.particle_sharpness.unwrap_or(0.)
    }

    pub fn clear_particle_sharpness(&mut self) {
        self.particle_sharpness = ::std::option::Option::None;
    }

    pub fn has_particle_sharpness(&self) -> bool {
        self.particle_sharpness.is_some()
    }

    // Param is passed by value, moved
    pub fn set_particle_sharpness(&mut self, v: f32) {
        self.particle_sharpness = ::std::option::Option::Some(v);
    }

    // optional float particle_sharpness_variance = 20;

    pub fn particle_sharpness_variance(&self) -> f32 {
        self.particle_sharpness_variance.unwrap_or(0.)
    }

    pub fn clear_particle_sharpness_variance(&mut self) {
        self.particle_sharpness_variance = ::std::option::Option::None;
    }

    pub fn has_particle_sharpness_variance(&self) -> bool {
        self.particle_sharpness_variance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_particle_sharpness_variance(&mut self, v: f32) {
        self.particle_sharpness_variance = ::std::option::Option::Some(v);
    }

    // optional float particle_flicker = 21;

    pub fn particle_flicker(&self) -> f32 {
        self.particle_flicker.unwrap_or(0.)
    }

    pub fn clear_particle_flicker(&mut self) {
        self.particle_flicker = ::std::option::Option::None;
    }

    pub fn has_particle_flicker(&self) -> bool {
        self.particle_flicker.is_some()
    }

    // Param is passed by value, moved
    pub fn set_particle_flicker(&mut self, v: f32) {
        self.particle_flicker = ::std::option::Option::Some(v);
    }

    // optional float particle_flicker_variance = 22;

    pub fn particle_flicker_variance(&self) -> f32 {
        self.particle_flicker_variance.unwrap_or(0.)
    }

    pub fn clear_particle_flicker_variance(&mut self) {
        self.particle_flicker_variance = ::std::option::Option::None;
    }

    pub fn has_particle_flicker_variance(&self) -> bool {
        self.particle_flicker_variance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_particle_flicker_variance(&mut self, v: f32) {
        self.particle_flicker_variance = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(25);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "base_position",
            |m: &CMsgParticleSystem| { &m.base_position },
            |m: &mut CMsgParticleSystem| { &mut m.base_position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "base_position_variance",
            |m: &CMsgParticleSystem| { &m.base_position_variance },
            |m: &mut CMsgParticleSystem| { &mut m.base_position_variance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "particle_size",
            |m: &CMsgParticleSystem| { &m.particle_size },
            |m: &mut CMsgParticleSystem| { &mut m.particle_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "particle_size_variance",
            |m: &CMsgParticleSystem| { &m.particle_size_variance },
            |m: &mut CMsgParticleSystem| { &mut m.particle_size_variance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "particles_per_second",
            |m: &CMsgParticleSystem| { &m.particles_per_second },
            |m: &mut CMsgParticleSystem| { &mut m.particles_per_second },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "particles_per_second_variance",
            |m: &CMsgParticleSystem| { &m.particles_per_second_variance },
            |m: &mut CMsgParticleSystem| { &mut m.particles_per_second_variance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "particle_lifespan_seconds",
            |m: &CMsgParticleSystem| { &m.particle_lifespan_seconds },
            |m: &mut CMsgParticleSystem| { &mut m.particle_lifespan_seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "particle_lifespan_seconds_variance",
            |m: &CMsgParticleSystem| { &m.particle_lifespan_seconds_variance },
            |m: &mut CMsgParticleSystem| { &mut m.particle_lifespan_seconds_variance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "particle_initial_velocity",
            |m: &CMsgParticleSystem| { &m.particle_initial_velocity },
            |m: &mut CMsgParticleSystem| { &mut m.particle_initial_velocity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "particle_initial_velocity_variance",
            |m: &CMsgParticleSystem| { &m.particle_initial_velocity_variance },
            |m: &mut CMsgParticleSystem| { &mut m.particle_initial_velocity_variance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "gravity_acceleration",
            |m: &CMsgParticleSystem| { &m.gravity_acceleration },
            |m: &mut CMsgParticleSystem| { &mut m.gravity_acceleration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "gravity_acceleration_particle_variance",
            |m: &CMsgParticleSystem| { &m.gravity_acceleration_particle_variance },
            |m: &mut CMsgParticleSystem| { &mut m.gravity_acceleration_particle_variance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "color_start_rgba",
            |m: &CMsgParticleSystem| { &m.color_start_rgba },
            |m: &mut CMsgParticleSystem| { &mut m.color_start_rgba },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "color_start_rgba_variance",
            |m: &CMsgParticleSystem| { &m.color_start_rgba_variance },
            |m: &mut CMsgParticleSystem| { &mut m.color_start_rgba_variance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "color_end_rgba",
            |m: &CMsgParticleSystem| { &m.color_end_rgba },
            |m: &mut CMsgParticleSystem| { &mut m.color_end_rgba },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "color_end_rgba_variance",
            |m: &CMsgParticleSystem| { &m.color_end_rgba_variance },
            |m: &mut CMsgParticleSystem| { &mut m.color_end_rgba_variance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "parent_panel_handle",
            |m: &CMsgParticleSystem| { &m.parent_panel_handle },
            |m: &mut CMsgParticleSystem| { &mut m.parent_panel_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "parent_brush_index",
            |m: &CMsgParticleSystem| { &m.parent_brush_index },
            |m: &mut CMsgParticleSystem| { &mut m.parent_brush_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "particle_sharpness",
            |m: &CMsgParticleSystem| { &m.particle_sharpness },
            |m: &mut CMsgParticleSystem| { &mut m.particle_sharpness },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "particle_sharpness_variance",
            |m: &CMsgParticleSystem| { &m.particle_sharpness_variance },
            |m: &mut CMsgParticleSystem| { &mut m.particle_sharpness_variance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "particle_flicker",
            |m: &CMsgParticleSystem| { &m.particle_flicker },
            |m: &mut CMsgParticleSystem| { &mut m.particle_flicker },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "particle_flicker_variance",
            |m: &CMsgParticleSystem| { &m.particle_flicker_variance },
            |m: &mut CMsgParticleSystem| { &mut m.particle_flicker_variance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "particle_velocity_min",
            |m: &CMsgParticleSystem| { &m.particle_velocity_min },
            |m: &mut CMsgParticleSystem| { &mut m.particle_velocity_min },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "particle_velocity_max",
            |m: &CMsgParticleSystem| { &m.particle_velocity_max },
            |m: &mut CMsgParticleSystem| { &mut m.particle_velocity_max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "particles",
            |m: &CMsgParticleSystem| { &m.particles },
            |m: &mut CMsgParticleSystem| { &mut m.particles },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgParticleSystem>(
            "CMsgParticleSystem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgParticleSystem {
    const NAME: &'static str = "CMsgParticleSystem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base_position)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base_position_variance)?;
                },
                25 => {
                    self.particle_size = ::std::option::Option::Some(is.read_double()?);
                },
                33 => {
                    self.particle_size_variance = ::std::option::Option::Some(is.read_double()?);
                },
                41 => {
                    self.particles_per_second = ::std::option::Option::Some(is.read_double()?);
                },
                49 => {
                    self.particles_per_second_variance = ::std::option::Option::Some(is.read_double()?);
                },
                57 => {
                    self.particle_lifespan_seconds = ::std::option::Option::Some(is.read_double()?);
                },
                65 => {
                    self.particle_lifespan_seconds_variance = ::std::option::Option::Some(is.read_double()?);
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.particle_initial_velocity)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.particle_initial_velocity_variance)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.gravity_acceleration)?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.gravity_acceleration_particle_variance)?;
                },
                104 => {
                    self.color_start_rgba = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.color_start_rgba_variance = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.color_end_rgba = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.color_end_rgba_variance = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.parent_panel_handle = ::std::option::Option::Some(is.read_uint64()?);
                },
                144 => {
                    self.parent_brush_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                157 => {
                    self.particle_sharpness = ::std::option::Option::Some(is.read_float()?);
                },
                165 => {
                    self.particle_sharpness_variance = ::std::option::Option::Some(is.read_float()?);
                },
                173 => {
                    self.particle_flicker = ::std::option::Option::Some(is.read_float()?);
                },
                181 => {
                    self.particle_flicker_variance = ::std::option::Option::Some(is.read_float()?);
                },
                186 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.particle_velocity_min)?;
                },
                194 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.particle_velocity_max)?;
                },
                402 => {
                    self.particles.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base_position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.base_position_variance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.particle_size {
            my_size += 1 + 8;
        }
        if let Some(v) = self.particle_size_variance {
            my_size += 1 + 8;
        }
        if let Some(v) = self.particles_per_second {
            my_size += 1 + 8;
        }
        if let Some(v) = self.particles_per_second_variance {
            my_size += 1 + 8;
        }
        if let Some(v) = self.particle_lifespan_seconds {
            my_size += 1 + 8;
        }
        if let Some(v) = self.particle_lifespan_seconds_variance {
            my_size += 1 + 8;
        }
        if let Some(v) = self.particle_initial_velocity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.particle_initial_velocity_variance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.gravity_acceleration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.gravity_acceleration_particle_variance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.color_start_rgba {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.color_start_rgba_variance {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.color_end_rgba {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.color_end_rgba_variance {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.parent_panel_handle {
            my_size += ::protobuf::rt::uint64_size(17, v);
        }
        if let Some(v) = self.parent_brush_index {
            my_size += ::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.particle_sharpness {
            my_size += 2 + 4;
        }
        if let Some(v) = self.particle_sharpness_variance {
            my_size += 2 + 4;
        }
        if let Some(v) = self.particle_flicker {
            my_size += 2 + 4;
        }
        if let Some(v) = self.particle_flicker_variance {
            my_size += 2 + 4;
        }
        if let Some(v) = self.particle_velocity_min.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.particle_velocity_max.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.particles {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base_position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.base_position_variance.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.particle_size {
            os.write_double(3, v)?;
        }
        if let Some(v) = self.particle_size_variance {
            os.write_double(4, v)?;
        }
        if let Some(v) = self.particles_per_second {
            os.write_double(5, v)?;
        }
        if let Some(v) = self.particles_per_second_variance {
            os.write_double(6, v)?;
        }
        if let Some(v) = self.particle_lifespan_seconds {
            os.write_double(7, v)?;
        }
        if let Some(v) = self.particle_lifespan_seconds_variance {
            os.write_double(8, v)?;
        }
        if let Some(v) = self.particle_initial_velocity.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.particle_initial_velocity_variance.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.gravity_acceleration.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.gravity_acceleration_particle_variance.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.color_start_rgba {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.color_start_rgba_variance {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.color_end_rgba {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.color_end_rgba_variance {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.parent_panel_handle {
            os.write_uint64(17, v)?;
        }
        if let Some(v) = self.parent_brush_index {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.particle_sharpness {
            os.write_float(19, v)?;
        }
        if let Some(v) = self.particle_sharpness_variance {
            os.write_float(20, v)?;
        }
        if let Some(v) = self.particle_flicker {
            os.write_float(21, v)?;
        }
        if let Some(v) = self.particle_flicker_variance {
            os.write_float(22, v)?;
        }
        if let Some(v) = self.particle_velocity_min.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        }
        if let Some(v) = self.particle_velocity_max.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        for v in &self.particles {
            ::protobuf::rt::write_message_field_with_cached_size(50, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgParticleSystem {
        CMsgParticleSystem::new()
    }

    fn clear(&mut self) {
        self.base_position.clear();
        self.base_position_variance.clear();
        self.particle_size = ::std::option::Option::None;
        self.particle_size_variance = ::std::option::Option::None;
        self.particles_per_second = ::std::option::Option::None;
        self.particles_per_second_variance = ::std::option::Option::None;
        self.particle_lifespan_seconds = ::std::option::Option::None;
        self.particle_lifespan_seconds_variance = ::std::option::Option::None;
        self.particle_initial_velocity.clear();
        self.particle_initial_velocity_variance.clear();
        self.gravity_acceleration.clear();
        self.gravity_acceleration_particle_variance.clear();
        self.color_start_rgba = ::std::option::Option::None;
        self.color_start_rgba_variance = ::std::option::Option::None;
        self.color_end_rgba = ::std::option::Option::None;
        self.color_end_rgba_variance = ::std::option::Option::None;
        self.parent_panel_handle = ::std::option::Option::None;
        self.parent_brush_index = ::std::option::Option::None;
        self.particle_sharpness = ::std::option::Option::None;
        self.particle_sharpness_variance = ::std::option::Option::None;
        self.particle_flicker = ::std::option::Option::None;
        self.particle_flicker_variance = ::std::option::Option::None;
        self.particle_velocity_min.clear();
        self.particle_velocity_max.clear();
        self.particles.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgParticleSystem {
        static instance: CMsgParticleSystem = CMsgParticleSystem {
            base_position: ::protobuf::MessageField::none(),
            base_position_variance: ::protobuf::MessageField::none(),
            particle_size: ::std::option::Option::None,
            particle_size_variance: ::std::option::Option::None,
            particles_per_second: ::std::option::Option::None,
            particles_per_second_variance: ::std::option::Option::None,
            particle_lifespan_seconds: ::std::option::Option::None,
            particle_lifespan_seconds_variance: ::std::option::Option::None,
            particle_initial_velocity: ::protobuf::MessageField::none(),
            particle_initial_velocity_variance: ::protobuf::MessageField::none(),
            gravity_acceleration: ::protobuf::MessageField::none(),
            gravity_acceleration_particle_variance: ::protobuf::MessageField::none(),
            color_start_rgba: ::std::option::Option::None,
            color_start_rgba_variance: ::std::option::Option::None,
            color_end_rgba: ::std::option::Option::None,
            color_end_rgba_variance: ::std::option::Option::None,
            parent_panel_handle: ::std::option::Option::None,
            parent_brush_index: ::std::option::Option::None,
            particle_sharpness: ::std::option::Option::None,
            particle_sharpness_variance: ::std::option::Option::None,
            particle_flicker: ::std::option::Option::None,
            particle_flicker_variance: ::std::option::Option::None,
            particle_velocity_min: ::protobuf::MessageField::none(),
            particle_velocity_max: ::protobuf::MessageField::none(),
            particles: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgParticleSystem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgParticleSystem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgParticleSystem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgParticleSystem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgFillBrush)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFillBrush {
    // message fields
    // @@protoc_insertion_point(field:CMsgFillBrush.opacity)
    pub opacity: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgFillBrush.color_rgba)
    pub color_rgba: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgFillBrush.linear_gradient)
    pub linear_gradient: ::protobuf::MessageField<CMsgLinearGradient>,
    // @@protoc_insertion_point(field:CMsgFillBrush.radial_gradient)
    pub radial_gradient: ::protobuf::MessageField<CMsgRadialGradient>,
    // @@protoc_insertion_point(field:CMsgFillBrush.particle_system)
    pub particle_system: ::protobuf::MessageField<CMsgParticleSystem>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFillBrush.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFillBrush {
    fn default() -> &'a CMsgFillBrush {
        <CMsgFillBrush as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFillBrush {
    pub fn new() -> CMsgFillBrush {
        ::std::default::Default::default()
    }

    // optional double opacity = 1;

    pub fn opacity(&self) -> f64 {
        self.opacity.unwrap_or(0.)
    }

    pub fn clear_opacity(&mut self) {
        self.opacity = ::std::option::Option::None;
    }

    pub fn has_opacity(&self) -> bool {
        self.opacity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_opacity(&mut self, v: f64) {
        self.opacity = ::std::option::Option::Some(v);
    }

    // optional uint32 color_rgba = 2;

    pub fn color_rgba(&self) -> u32 {
        self.color_rgba.unwrap_or(0)
    }

    pub fn clear_color_rgba(&mut self) {
        self.color_rgba = ::std::option::Option::None;
    }

    pub fn has_color_rgba(&self) -> bool {
        self.color_rgba.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color_rgba(&mut self, v: u32) {
        self.color_rgba = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "opacity",
            |m: &CMsgFillBrush| { &m.opacity },
            |m: &mut CMsgFillBrush| { &mut m.opacity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "color_rgba",
            |m: &CMsgFillBrush| { &m.color_rgba },
            |m: &mut CMsgFillBrush| { &mut m.color_rgba },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgLinearGradient>(
            "linear_gradient",
            |m: &CMsgFillBrush| { &m.linear_gradient },
            |m: &mut CMsgFillBrush| { &mut m.linear_gradient },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgRadialGradient>(
            "radial_gradient",
            |m: &CMsgFillBrush| { &m.radial_gradient },
            |m: &mut CMsgFillBrush| { &mut m.radial_gradient },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgParticleSystem>(
            "particle_system",
            |m: &CMsgFillBrush| { &m.particle_system },
            |m: &mut CMsgFillBrush| { &mut m.particle_system },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgFillBrush>(
            "CMsgFillBrush",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgFillBrush {
    const NAME: &'static str = "CMsgFillBrush";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.opacity = ::std::option::Option::Some(is.read_double()?);
                },
                16 => {
                    self.color_rgba = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.linear_gradient)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.radial_gradient)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.particle_system)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.opacity {
            my_size += 1 + 8;
        }
        if let Some(v) = self.color_rgba {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.linear_gradient.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.radial_gradient.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.particle_system.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.opacity {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.color_rgba {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.linear_gradient.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.radial_gradient.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.particle_system.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFillBrush {
        CMsgFillBrush::new()
    }

    fn clear(&mut self) {
        self.opacity = ::std::option::Option::None;
        self.color_rgba = ::std::option::Option::None;
        self.linear_gradient.clear();
        self.radial_gradient.clear();
        self.particle_system.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFillBrush {
        static instance: CMsgFillBrush = CMsgFillBrush {
            opacity: ::std::option::Option::None,
            color_rgba: ::std::option::Option::None,
            linear_gradient: ::protobuf::MessageField::none(),
            radial_gradient: ::protobuf::MessageField::none(),
            particle_system: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgFillBrush {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgFillBrush").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgFillBrush {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFillBrush {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgFillBrushCollection)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFillBrushCollection {
    // message fields
    // @@protoc_insertion_point(field:CMsgFillBrushCollection.base)
    pub base: ::std::vec::Vec<CMsgFillBrush>,
    // @@protoc_insertion_point(field:CMsgFillBrushCollection.transition)
    pub transition: ::std::vec::Vec<CMsgFillBrush>,
    // @@protoc_insertion_point(field:CMsgFillBrushCollection.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsgFillBrushCollection.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgFillBrushCollection.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFillBrushCollection.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFillBrushCollection {
    fn default() -> &'a CMsgFillBrushCollection {
        <CMsgFillBrushCollection as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFillBrushCollection {
    pub fn new() -> CMsgFillBrushCollection {
        ::std::default::Default::default()
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "base",
            |m: &CMsgFillBrushCollection| { &m.base },
            |m: &mut CMsgFillBrushCollection| { &mut m.base },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "transition",
            |m: &CMsgFillBrushCollection| { &m.transition },
            |m: &mut CMsgFillBrushCollection| { &mut m.transition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgTransitionData>(
            "transition_data",
            |m: &CMsgFillBrushCollection| { &m.transition_data },
            |m: &mut CMsgFillBrushCollection| { &mut m.transition_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "style_symbol",
            |m: &CMsgFillBrushCollection| { &m.style_symbol },
            |m: &mut CMsgFillBrushCollection| { &mut m.style_symbol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "animations",
            |m: &CMsgFillBrushCollection| { &m.animations },
            |m: &mut CMsgFillBrushCollection| { &mut m.animations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgFillBrushCollection>(
            "CMsgFillBrushCollection",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgFillBrushCollection {
    const NAME: &'static str = "CMsgFillBrushCollection";

    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.base.push(is.read_message()?);
                },
                18 => {
                    self.transition.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.base {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.transition {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.base {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.transition {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFillBrushCollection {
        CMsgFillBrushCollection::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.transition.clear();
        self.transition_data.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFillBrushCollection {
        static instance: CMsgFillBrushCollection = CMsgFillBrushCollection {
            base: ::std::vec::Vec::new(),
            transition: ::std::vec::Vec::new(),
            transition_data: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgFillBrushCollection {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgFillBrushCollection").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgFillBrushCollection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFillBrushCollection {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgFillBrushCollection`
pub mod cmsg_fill_brush_collection {
    // @@protoc_insertion_point(message:CMsgFillBrushCollection.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsgFillBrushCollection.AnimationFrameData.data)
        pub data: ::std::vec::Vec<super::CMsgFillBrush>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgFillBrushCollection.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "data",
                |m: &AnimationFrameData| { &m.data },
                |m: &mut AnimationFrameData| { &mut m.data },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AnimationFrameData>(
                "CMsgFillBrushCollection.AnimationFrameData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.data.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.data {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.data {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AnimationFrameData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgFillBrushCollection.AnimationFrameData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AnimationFrameData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AnimationFrameData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgRenderFillBrushCollection)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRenderFillBrushCollection {
    // message fields
    // @@protoc_insertion_point(field:CMsgRenderFillBrushCollection.fill_brush)
    pub fill_brush: ::std::vec::Vec<CMsgFillBrush>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRenderFillBrushCollection.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRenderFillBrushCollection {
    fn default() -> &'a CMsgRenderFillBrushCollection {
        <CMsgRenderFillBrushCollection as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRenderFillBrushCollection {
    pub fn new() -> CMsgRenderFillBrushCollection {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "fill_brush",
            |m: &CMsgRenderFillBrushCollection| { &m.fill_brush },
            |m: &mut CMsgRenderFillBrushCollection| { &mut m.fill_brush },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRenderFillBrushCollection>(
            "CMsgRenderFillBrushCollection",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRenderFillBrushCollection {
    const NAME: &'static str = "CMsgRenderFillBrushCollection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.fill_brush.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.fill_brush {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.fill_brush {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRenderFillBrushCollection {
        CMsgRenderFillBrushCollection::new()
    }

    fn clear(&mut self) {
        self.fill_brush.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRenderFillBrushCollection {
        static instance: CMsgRenderFillBrushCollection = CMsgRenderFillBrushCollection {
            fill_brush: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRenderFillBrushCollection {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRenderFillBrushCollection").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRenderFillBrushCollection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRenderFillBrushCollection {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPanelPosition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPanelPosition {
    // message fields
    // @@protoc_insertion_point(field:CMsgPanelPosition.base)
    pub base: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgPanelPosition.transition)
    pub transition: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgPanelPosition.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsgPanelPosition.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPanelPosition.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // @@protoc_insertion_point(field:CMsgPanelPosition.scroll_offset)
    pub scroll_offset: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgPanelPosition.scroll_offset_target)
    pub scroll_offset_target: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgPanelPosition.scroll_transition_x)
    pub scroll_transition_x: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsgPanelPosition.scroll_transition_y)
    pub scroll_transition_y: ::protobuf::MessageField<CMsgTransitionData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPanelPosition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPanelPosition {
    fn default() -> &'a CMsgPanelPosition {
        <CMsgPanelPosition as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPanelPosition {
    pub fn new() -> CMsgPanelPosition {
        ::std::default::Default::default()
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "base",
            |m: &CMsgPanelPosition| { &m.base },
            |m: &mut CMsgPanelPosition| { &mut m.base },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "transition",
            |m: &CMsgPanelPosition| { &m.transition },
            |m: &mut CMsgPanelPosition| { &mut m.transition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgTransitionData>(
            "transition_data",
            |m: &CMsgPanelPosition| { &m.transition_data },
            |m: &mut CMsgPanelPosition| { &mut m.transition_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "style_symbol",
            |m: &CMsgPanelPosition| { &m.style_symbol },
            |m: &mut CMsgPanelPosition| { &mut m.style_symbol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "animations",
            |m: &CMsgPanelPosition| { &m.animations },
            |m: &mut CMsgPanelPosition| { &mut m.animations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "scroll_offset",
            |m: &CMsgPanelPosition| { &m.scroll_offset },
            |m: &mut CMsgPanelPosition| { &mut m.scroll_offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "scroll_offset_target",
            |m: &CMsgPanelPosition| { &m.scroll_offset_target },
            |m: &mut CMsgPanelPosition| { &mut m.scroll_offset_target },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgTransitionData>(
            "scroll_transition_x",
            |m: &CMsgPanelPosition| { &m.scroll_transition_x },
            |m: &mut CMsgPanelPosition| { &mut m.scroll_transition_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgTransitionData>(
            "scroll_transition_y",
            |m: &CMsgPanelPosition| { &m.scroll_transition_y },
            |m: &mut CMsgPanelPosition| { &mut m.scroll_transition_y },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPanelPosition>(
            "CMsgPanelPosition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPanelPosition {
    const NAME: &'static str = "CMsgPanelPosition";

    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scroll_offset {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scroll_offset_target {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scroll_transition_x {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scroll_transition_y {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.scroll_offset)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.scroll_offset_target)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.scroll_transition_x)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.scroll_transition_y)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.scroll_offset.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.scroll_offset_target.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.scroll_transition_x.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.scroll_transition_y.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.transition.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.scroll_offset.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.scroll_offset_target.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.scroll_transition_x.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.scroll_transition_y.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPanelPosition {
        CMsgPanelPosition::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.transition.clear();
        self.transition_data.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.scroll_offset.clear();
        self.scroll_offset_target.clear();
        self.scroll_transition_x.clear();
        self.scroll_transition_y.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPanelPosition {
        static instance: CMsgPanelPosition = CMsgPanelPosition {
            base: ::protobuf::MessageField::none(),
            transition: ::protobuf::MessageField::none(),
            transition_data: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            scroll_offset: ::protobuf::MessageField::none(),
            scroll_offset_target: ::protobuf::MessageField::none(),
            scroll_transition_x: ::protobuf::MessageField::none(),
            scroll_transition_y: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPanelPosition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPanelPosition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPanelPosition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPanelPosition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgPanelPosition`
pub mod cmsg_panel_position {
    // @@protoc_insertion_point(message:CMsgPanelPosition.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsgPanelPosition.AnimationFrameData.data)
        pub data: ::protobuf::MessageField<super::CMsgPoint>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgPanelPosition.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::CMsgPoint>(
                "data",
                |m: &AnimationFrameData| { &m.data },
                |m: &mut AnimationFrameData| { &mut m.data },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AnimationFrameData>(
                "CMsgPanelPosition.AnimationFrameData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AnimationFrameData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgPanelPosition.AnimationFrameData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AnimationFrameData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AnimationFrameData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgOpacity)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgOpacity {
    // message fields
    // @@protoc_insertion_point(field:CMsgOpacity.base)
    pub base: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgOpacity.transition)
    pub transition: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgOpacity.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsgOpacity.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgOpacity.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgOpacity.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgOpacity {
    fn default() -> &'a CMsgOpacity {
        <CMsgOpacity as ::protobuf::Message>::default_instance()
    }
}

impl CMsgOpacity {
    pub fn new() -> CMsgOpacity {
        ::std::default::Default::default()
    }

    // optional double base = 1;

    pub fn base(&self) -> f64 {
        self.base.unwrap_or(0.)
    }

    pub fn clear_base(&mut self) {
        self.base = ::std::option::Option::None;
    }

    pub fn has_base(&self) -> bool {
        self.base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base(&mut self, v: f64) {
        self.base = ::std::option::Option::Some(v);
    }

    // optional double transition = 2;

    pub fn transition(&self) -> f64 {
        self.transition.unwrap_or(0.)
    }

    pub fn clear_transition(&mut self) {
        self.transition = ::std::option::Option::None;
    }

    pub fn has_transition(&self) -> bool {
        self.transition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transition(&mut self, v: f64) {
        self.transition = ::std::option::Option::Some(v);
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "base",
            |m: &CMsgOpacity| { &m.base },
            |m: &mut CMsgOpacity| { &mut m.base },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transition",
            |m: &CMsgOpacity| { &m.transition },
            |m: &mut CMsgOpacity| { &mut m.transition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgTransitionData>(
            "transition_data",
            |m: &CMsgOpacity| { &m.transition_data },
            |m: &mut CMsgOpacity| { &mut m.transition_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "style_symbol",
            |m: &CMsgOpacity| { &m.style_symbol },
            |m: &mut CMsgOpacity| { &mut m.style_symbol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "animations",
            |m: &CMsgOpacity| { &m.animations },
            |m: &mut CMsgOpacity| { &mut m.animations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgOpacity>(
            "CMsgOpacity",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgOpacity {
    const NAME: &'static str = "CMsgOpacity";

    fn is_initialized(&self) -> bool {
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.base = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.transition = ::std::option::Option::Some(is.read_double()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transition {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.transition {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgOpacity {
        CMsgOpacity::new()
    }

    fn clear(&mut self) {
        self.base = ::std::option::Option::None;
        self.transition = ::std::option::Option::None;
        self.transition_data.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgOpacity {
        static instance: CMsgOpacity = CMsgOpacity {
            base: ::std::option::Option::None,
            transition: ::std::option::Option::None,
            transition_data: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgOpacity {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgOpacity").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgOpacity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgOpacity {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgOpacity`
pub mod cmsg_opacity {
    // @@protoc_insertion_point(message:CMsgOpacity.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsgOpacity.AnimationFrameData.data)
        pub data: ::std::option::Option<f64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgOpacity.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }

        // optional double data = 1;

        pub fn data(&self) -> f64 {
            self.data.unwrap_or(0.)
        }

        pub fn clear_data(&mut self) {
            self.data = ::std::option::Option::None;
        }

        pub fn has_data(&self) -> bool {
            self.data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data(&mut self, v: f64) {
            self.data = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "data",
                |m: &AnimationFrameData| { &m.data },
                |m: &mut AnimationFrameData| { &mut m.data },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AnimationFrameData>(
                "CMsgOpacity.AnimationFrameData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.data = ::std::option::Option::Some(is.read_double()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data {
                os.write_double(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AnimationFrameData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgOpacity.AnimationFrameData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AnimationFrameData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AnimationFrameData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgRotate2D)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRotate2D {
    // message fields
    // @@protoc_insertion_point(field:CMsgRotate2D.base)
    pub base: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgRotate2D.transition)
    pub transition: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgRotate2D.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsgRotate2D.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRotate2D.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRotate2D.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRotate2D {
    fn default() -> &'a CMsgRotate2D {
        <CMsgRotate2D as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRotate2D {
    pub fn new() -> CMsgRotate2D {
        ::std::default::Default::default()
    }

    // optional double base = 1;

    pub fn base(&self) -> f64 {
        self.base.unwrap_or(0.)
    }

    pub fn clear_base(&mut self) {
        self.base = ::std::option::Option::None;
    }

    pub fn has_base(&self) -> bool {
        self.base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base(&mut self, v: f64) {
        self.base = ::std::option::Option::Some(v);
    }

    // optional double transition = 2;

    pub fn transition(&self) -> f64 {
        self.transition.unwrap_or(0.)
    }

    pub fn clear_transition(&mut self) {
        self.transition = ::std::option::Option::None;
    }

    pub fn has_transition(&self) -> bool {
        self.transition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transition(&mut self, v: f64) {
        self.transition = ::std::option::Option::Some(v);
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "base",
            |m: &CMsgRotate2D| { &m.base },
            |m: &mut CMsgRotate2D| { &mut m.base },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transition",
            |m: &CMsgRotate2D| { &m.transition },
            |m: &mut CMsgRotate2D| { &mut m.transition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgTransitionData>(
            "transition_data",
            |m: &CMsgRotate2D| { &m.transition_data },
            |m: &mut CMsgRotate2D| { &mut m.transition_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "style_symbol",
            |m: &CMsgRotate2D| { &m.style_symbol },
            |m: &mut CMsgRotate2D| { &mut m.style_symbol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "animations",
            |m: &CMsgRotate2D| { &m.animations },
            |m: &mut CMsgRotate2D| { &mut m.animations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRotate2D>(
            "CMsgRotate2D",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRotate2D {
    const NAME: &'static str = "CMsgRotate2D";

    fn is_initialized(&self) -> bool {
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.base = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.transition = ::std::option::Option::Some(is.read_double()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transition {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.transition {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRotate2D {
        CMsgRotate2D::new()
    }

    fn clear(&mut self) {
        self.base = ::std::option::Option::None;
        self.transition = ::std::option::Option::None;
        self.transition_data.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRotate2D {
        static instance: CMsgRotate2D = CMsgRotate2D {
            base: ::std::option::Option::None,
            transition: ::std::option::Option::None,
            transition_data: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRotate2D {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRotate2D").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRotate2D {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRotate2D {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgRotate2D`
pub mod cmsg_rotate2d {
    // @@protoc_insertion_point(message:CMsgRotate2D.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsgRotate2D.AnimationFrameData.data)
        pub data: ::std::option::Option<f64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgRotate2D.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }

        // optional double data = 1;

        pub fn data(&self) -> f64 {
            self.data.unwrap_or(0.)
        }

        pub fn clear_data(&mut self) {
            self.data = ::std::option::Option::None;
        }

        pub fn has_data(&self) -> bool {
            self.data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data(&mut self, v: f64) {
            self.data = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "data",
                |m: &AnimationFrameData| { &m.data },
                |m: &mut AnimationFrameData| { &mut m.data },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AnimationFrameData>(
                "CMsgRotate2D.AnimationFrameData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.data = ::std::option::Option::Some(is.read_double()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data {
                os.write_double(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AnimationFrameData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgRotate2D.AnimationFrameData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AnimationFrameData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AnimationFrameData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgOpacityMaskData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgOpacityMaskData {
    // message fields
    // @@protoc_insertion_point(field:CMsgOpacityMaskData.opacity_mask_texture_id)
    pub opacity_mask_texture_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgOpacityMaskData.opacity_mask_opacity)
    pub opacity_mask_opacity: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgOpacityMaskData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgOpacityMaskData {
    fn default() -> &'a CMsgOpacityMaskData {
        <CMsgOpacityMaskData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgOpacityMaskData {
    pub fn new() -> CMsgOpacityMaskData {
        ::std::default::Default::default()
    }

    // optional uint32 opacity_mask_texture_id = 1;

    pub fn opacity_mask_texture_id(&self) -> u32 {
        self.opacity_mask_texture_id.unwrap_or(0)
    }

    pub fn clear_opacity_mask_texture_id(&mut self) {
        self.opacity_mask_texture_id = ::std::option::Option::None;
    }

    pub fn has_opacity_mask_texture_id(&self) -> bool {
        self.opacity_mask_texture_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_opacity_mask_texture_id(&mut self, v: u32) {
        self.opacity_mask_texture_id = ::std::option::Option::Some(v);
    }

    // optional double opacity_mask_opacity = 2;

    pub fn opacity_mask_opacity(&self) -> f64 {
        self.opacity_mask_opacity.unwrap_or(0.)
    }

    pub fn clear_opacity_mask_opacity(&mut self) {
        self.opacity_mask_opacity = ::std::option::Option::None;
    }

    pub fn has_opacity_mask_opacity(&self) -> bool {
        self.opacity_mask_opacity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_opacity_mask_opacity(&mut self, v: f64) {
        self.opacity_mask_opacity = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "opacity_mask_texture_id",
            |m: &CMsgOpacityMaskData| { &m.opacity_mask_texture_id },
            |m: &mut CMsgOpacityMaskData| { &mut m.opacity_mask_texture_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "opacity_mask_opacity",
            |m: &CMsgOpacityMaskData| { &m.opacity_mask_opacity },
            |m: &mut CMsgOpacityMaskData| { &mut m.opacity_mask_opacity },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgOpacityMaskData>(
            "CMsgOpacityMaskData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgOpacityMaskData {
    const NAME: &'static str = "CMsgOpacityMaskData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.opacity_mask_texture_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.opacity_mask_opacity = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.opacity_mask_texture_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.opacity_mask_opacity {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.opacity_mask_texture_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.opacity_mask_opacity {
            os.write_double(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgOpacityMaskData {
        CMsgOpacityMaskData::new()
    }

    fn clear(&mut self) {
        self.opacity_mask_texture_id = ::std::option::Option::None;
        self.opacity_mask_opacity = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgOpacityMaskData {
        static instance: CMsgOpacityMaskData = CMsgOpacityMaskData {
            opacity_mask_texture_id: ::std::option::Option::None,
            opacity_mask_opacity: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgOpacityMaskData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgOpacityMaskData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgOpacityMaskData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgOpacityMaskData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgOpacityMask)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgOpacityMask {
    // message fields
    // @@protoc_insertion_point(field:CMsgOpacityMask.base)
    pub base: ::protobuf::MessageField<CMsgOpacityMaskData>,
    // @@protoc_insertion_point(field:CMsgOpacityMask.transition)
    pub transition: ::protobuf::MessageField<CMsgOpacityMaskData>,
    // @@protoc_insertion_point(field:CMsgOpacityMask.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsgOpacityMask.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgOpacityMask.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgOpacityMask.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgOpacityMask {
    fn default() -> &'a CMsgOpacityMask {
        <CMsgOpacityMask as ::protobuf::Message>::default_instance()
    }
}

impl CMsgOpacityMask {
    pub fn new() -> CMsgOpacityMask {
        ::std::default::Default::default()
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgOpacityMaskData>(
            "base",
            |m: &CMsgOpacityMask| { &m.base },
            |m: &mut CMsgOpacityMask| { &mut m.base },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgOpacityMaskData>(
            "transition",
            |m: &CMsgOpacityMask| { &m.transition },
            |m: &mut CMsgOpacityMask| { &mut m.transition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgTransitionData>(
            "transition_data",
            |m: &CMsgOpacityMask| { &m.transition_data },
            |m: &mut CMsgOpacityMask| { &mut m.transition_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "style_symbol",
            |m: &CMsgOpacityMask| { &m.style_symbol },
            |m: &mut CMsgOpacityMask| { &mut m.style_symbol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "animations",
            |m: &CMsgOpacityMask| { &m.animations },
            |m: &mut CMsgOpacityMask| { &mut m.animations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgOpacityMask>(
            "CMsgOpacityMask",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgOpacityMask {
    const NAME: &'static str = "CMsgOpacityMask";

    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.transition.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgOpacityMask {
        CMsgOpacityMask::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.transition.clear();
        self.transition_data.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgOpacityMask {
        static instance: CMsgOpacityMask = CMsgOpacityMask {
            base: ::protobuf::MessageField::none(),
            transition: ::protobuf::MessageField::none(),
            transition_data: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgOpacityMask {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgOpacityMask").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgOpacityMask {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgOpacityMask {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgOpacityMask`
pub mod cmsg_opacity_mask {
    // @@protoc_insertion_point(message:CMsgOpacityMask.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsgOpacityMask.AnimationFrameData.data)
        pub data: ::protobuf::MessageField<super::CMsgOpacityMaskData>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgOpacityMask.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::CMsgOpacityMaskData>(
                "data",
                |m: &AnimationFrameData| { &m.data },
                |m: &mut AnimationFrameData| { &mut m.data },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AnimationFrameData>(
                "CMsgOpacityMask.AnimationFrameData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AnimationFrameData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgOpacityMask.AnimationFrameData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AnimationFrameData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AnimationFrameData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgHueShift)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHueShift {
    // message fields
    // @@protoc_insertion_point(field:CMsgHueShift.base)
    pub base: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgHueShift.transition)
    pub transition: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgHueShift.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsgHueShift.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHueShift.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgHueShift.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHueShift {
    fn default() -> &'a CMsgHueShift {
        <CMsgHueShift as ::protobuf::Message>::default_instance()
    }
}

impl CMsgHueShift {
    pub fn new() -> CMsgHueShift {
        ::std::default::Default::default()
    }

    // optional double base = 1;

    pub fn base(&self) -> f64 {
        self.base.unwrap_or(0.)
    }

    pub fn clear_base(&mut self) {
        self.base = ::std::option::Option::None;
    }

    pub fn has_base(&self) -> bool {
        self.base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base(&mut self, v: f64) {
        self.base = ::std::option::Option::Some(v);
    }

    // optional double transition = 2;

    pub fn transition(&self) -> f64 {
        self.transition.unwrap_or(0.)
    }

    pub fn clear_transition(&mut self) {
        self.transition = ::std::option::Option::None;
    }

    pub fn has_transition(&self) -> bool {
        self.transition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transition(&mut self, v: f64) {
        self.transition = ::std::option::Option::Some(v);
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "base",
            |m: &CMsgHueShift| { &m.base },
            |m: &mut CMsgHueShift| { &mut m.base },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transition",
            |m: &CMsgHueShift| { &m.transition },
            |m: &mut CMsgHueShift| { &mut m.transition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgTransitionData>(
            "transition_data",
            |m: &CMsgHueShift| { &m.transition_data },
            |m: &mut CMsgHueShift| { &mut m.transition_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "style_symbol",
            |m: &CMsgHueShift| { &m.style_symbol },
            |m: &mut CMsgHueShift| { &mut m.style_symbol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "animations",
            |m: &CMsgHueShift| { &m.animations },
            |m: &mut CMsgHueShift| { &mut m.animations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgHueShift>(
            "CMsgHueShift",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgHueShift {
    const NAME: &'static str = "CMsgHueShift";

    fn is_initialized(&self) -> bool {
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.base = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.transition = ::std::option::Option::Some(is.read_double()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transition {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.transition {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHueShift {
        CMsgHueShift::new()
    }

    fn clear(&mut self) {
        self.base = ::std::option::Option::None;
        self.transition = ::std::option::Option::None;
        self.transition_data.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHueShift {
        static instance: CMsgHueShift = CMsgHueShift {
            base: ::std::option::Option::None,
            transition: ::std::option::Option::None,
            transition_data: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgHueShift {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgHueShift").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgHueShift {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgHueShift {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgHueShift`
pub mod cmsg_hue_shift {
    // @@protoc_insertion_point(message:CMsgHueShift.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsgHueShift.AnimationFrameData.data)
        pub data: ::std::option::Option<f64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgHueShift.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }

        // optional double data = 1;

        pub fn data(&self) -> f64 {
            self.data.unwrap_or(0.)
        }

        pub fn clear_data(&mut self) {
            self.data = ::std::option::Option::None;
        }

        pub fn has_data(&self) -> bool {
            self.data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data(&mut self, v: f64) {
            self.data = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "data",
                |m: &AnimationFrameData| { &m.data },
                |m: &mut AnimationFrameData| { &mut m.data },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AnimationFrameData>(
                "CMsgHueShift.AnimationFrameData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.data = ::std::option::Option::Some(is.read_double()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data {
                os.write_double(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AnimationFrameData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgHueShift.AnimationFrameData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AnimationFrameData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AnimationFrameData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgSaturation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSaturation {
    // message fields
    // @@protoc_insertion_point(field:CMsgSaturation.base)
    pub base: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgSaturation.transition)
    pub transition: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgSaturation.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsgSaturation.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSaturation.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSaturation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSaturation {
    fn default() -> &'a CMsgSaturation {
        <CMsgSaturation as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSaturation {
    pub fn new() -> CMsgSaturation {
        ::std::default::Default::default()
    }

    // optional double base = 1;

    pub fn base(&self) -> f64 {
        self.base.unwrap_or(0.)
    }

    pub fn clear_base(&mut self) {
        self.base = ::std::option::Option::None;
    }

    pub fn has_base(&self) -> bool {
        self.base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base(&mut self, v: f64) {
        self.base = ::std::option::Option::Some(v);
    }

    // optional double transition = 2;

    pub fn transition(&self) -> f64 {
        self.transition.unwrap_or(0.)
    }

    pub fn clear_transition(&mut self) {
        self.transition = ::std::option::Option::None;
    }

    pub fn has_transition(&self) -> bool {
        self.transition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transition(&mut self, v: f64) {
        self.transition = ::std::option::Option::Some(v);
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "base",
            |m: &CMsgSaturation| { &m.base },
            |m: &mut CMsgSaturation| { &mut m.base },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transition",
            |m: &CMsgSaturation| { &m.transition },
            |m: &mut CMsgSaturation| { &mut m.transition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgTransitionData>(
            "transition_data",
            |m: &CMsgSaturation| { &m.transition_data },
            |m: &mut CMsgSaturation| { &mut m.transition_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "style_symbol",
            |m: &CMsgSaturation| { &m.style_symbol },
            |m: &mut CMsgSaturation| { &mut m.style_symbol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "animations",
            |m: &CMsgSaturation| { &m.animations },
            |m: &mut CMsgSaturation| { &mut m.animations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSaturation>(
            "CMsgSaturation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSaturation {
    const NAME: &'static str = "CMsgSaturation";

    fn is_initialized(&self) -> bool {
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.base = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.transition = ::std::option::Option::Some(is.read_double()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transition {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.transition {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSaturation {
        CMsgSaturation::new()
    }

    fn clear(&mut self) {
        self.base = ::std::option::Option::None;
        self.transition = ::std::option::Option::None;
        self.transition_data.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSaturation {
        static instance: CMsgSaturation = CMsgSaturation {
            base: ::std::option::Option::None,
            transition: ::std::option::Option::None,
            transition_data: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSaturation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSaturation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSaturation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSaturation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSaturation`
pub mod cmsg_saturation {
    // @@protoc_insertion_point(message:CMsgSaturation.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsgSaturation.AnimationFrameData.data)
        pub data: ::std::option::Option<f64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSaturation.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }

        // optional double data = 1;

        pub fn data(&self) -> f64 {
            self.data.unwrap_or(0.)
        }

        pub fn clear_data(&mut self) {
            self.data = ::std::option::Option::None;
        }

        pub fn has_data(&self) -> bool {
            self.data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data(&mut self, v: f64) {
            self.data = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "data",
                |m: &AnimationFrameData| { &m.data },
                |m: &mut AnimationFrameData| { &mut m.data },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AnimationFrameData>(
                "CMsgSaturation.AnimationFrameData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.data = ::std::option::Option::Some(is.read_double()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data {
                os.write_double(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AnimationFrameData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSaturation.AnimationFrameData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AnimationFrameData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AnimationFrameData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgBrightness)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBrightness {
    // message fields
    // @@protoc_insertion_point(field:CMsgBrightness.base)
    pub base: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgBrightness.transition)
    pub transition: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgBrightness.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsgBrightness.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrightness.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBrightness.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBrightness {
    fn default() -> &'a CMsgBrightness {
        <CMsgBrightness as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBrightness {
    pub fn new() -> CMsgBrightness {
        ::std::default::Default::default()
    }

    // optional double base = 1;

    pub fn base(&self) -> f64 {
        self.base.unwrap_or(0.)
    }

    pub fn clear_base(&mut self) {
        self.base = ::std::option::Option::None;
    }

    pub fn has_base(&self) -> bool {
        self.base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base(&mut self, v: f64) {
        self.base = ::std::option::Option::Some(v);
    }

    // optional double transition = 2;

    pub fn transition(&self) -> f64 {
        self.transition.unwrap_or(0.)
    }

    pub fn clear_transition(&mut self) {
        self.transition = ::std::option::Option::None;
    }

    pub fn has_transition(&self) -> bool {
        self.transition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transition(&mut self, v: f64) {
        self.transition = ::std::option::Option::Some(v);
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "base",
            |m: &CMsgBrightness| { &m.base },
            |m: &mut CMsgBrightness| { &mut m.base },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transition",
            |m: &CMsgBrightness| { &m.transition },
            |m: &mut CMsgBrightness| { &mut m.transition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgTransitionData>(
            "transition_data",
            |m: &CMsgBrightness| { &m.transition_data },
            |m: &mut CMsgBrightness| { &mut m.transition_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "style_symbol",
            |m: &CMsgBrightness| { &m.style_symbol },
            |m: &mut CMsgBrightness| { &mut m.style_symbol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "animations",
            |m: &CMsgBrightness| { &m.animations },
            |m: &mut CMsgBrightness| { &mut m.animations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBrightness>(
            "CMsgBrightness",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgBrightness {
    const NAME: &'static str = "CMsgBrightness";

    fn is_initialized(&self) -> bool {
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.base = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.transition = ::std::option::Option::Some(is.read_double()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transition {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.transition {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBrightness {
        CMsgBrightness::new()
    }

    fn clear(&mut self) {
        self.base = ::std::option::Option::None;
        self.transition = ::std::option::Option::None;
        self.transition_data.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBrightness {
        static instance: CMsgBrightness = CMsgBrightness {
            base: ::std::option::Option::None,
            transition: ::std::option::Option::None,
            transition_data: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgBrightness {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBrightness").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBrightness {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBrightness {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgBrightness`
pub mod cmsg_brightness {
    // @@protoc_insertion_point(message:CMsgBrightness.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsgBrightness.AnimationFrameData.data)
        pub data: ::std::option::Option<f64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgBrightness.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }

        // optional double data = 1;

        pub fn data(&self) -> f64 {
            self.data.unwrap_or(0.)
        }

        pub fn clear_data(&mut self) {
            self.data = ::std::option::Option::None;
        }

        pub fn has_data(&self) -> bool {
            self.data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data(&mut self, v: f64) {
            self.data = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "data",
                |m: &AnimationFrameData| { &m.data },
                |m: &mut AnimationFrameData| { &mut m.data },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AnimationFrameData>(
                "CMsgBrightness.AnimationFrameData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.data = ::std::option::Option::Some(is.read_double()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data {
                os.write_double(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AnimationFrameData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgBrightness.AnimationFrameData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AnimationFrameData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AnimationFrameData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgContrast)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgContrast {
    // message fields
    // @@protoc_insertion_point(field:CMsgContrast.base)
    pub base: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgContrast.transition)
    pub transition: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgContrast.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsgContrast.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgContrast.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgContrast.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgContrast {
    fn default() -> &'a CMsgContrast {
        <CMsgContrast as ::protobuf::Message>::default_instance()
    }
}

impl CMsgContrast {
    pub fn new() -> CMsgContrast {
        ::std::default::Default::default()
    }

    // optional double base = 1;

    pub fn base(&self) -> f64 {
        self.base.unwrap_or(0.)
    }

    pub fn clear_base(&mut self) {
        self.base = ::std::option::Option::None;
    }

    pub fn has_base(&self) -> bool {
        self.base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base(&mut self, v: f64) {
        self.base = ::std::option::Option::Some(v);
    }

    // optional double transition = 2;

    pub fn transition(&self) -> f64 {
        self.transition.unwrap_or(0.)
    }

    pub fn clear_transition(&mut self) {
        self.transition = ::std::option::Option::None;
    }

    pub fn has_transition(&self) -> bool {
        self.transition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transition(&mut self, v: f64) {
        self.transition = ::std::option::Option::Some(v);
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "base",
            |m: &CMsgContrast| { &m.base },
            |m: &mut CMsgContrast| { &mut m.base },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transition",
            |m: &CMsgContrast| { &m.transition },
            |m: &mut CMsgContrast| { &mut m.transition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgTransitionData>(
            "transition_data",
            |m: &CMsgContrast| { &m.transition_data },
            |m: &mut CMsgContrast| { &mut m.transition_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "style_symbol",
            |m: &CMsgContrast| { &m.style_symbol },
            |m: &mut CMsgContrast| { &mut m.style_symbol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "animations",
            |m: &CMsgContrast| { &m.animations },
            |m: &mut CMsgContrast| { &mut m.animations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgContrast>(
            "CMsgContrast",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgContrast {
    const NAME: &'static str = "CMsgContrast";

    fn is_initialized(&self) -> bool {
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.base = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.transition = ::std::option::Option::Some(is.read_double()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transition {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.transition {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgContrast {
        CMsgContrast::new()
    }

    fn clear(&mut self) {
        self.base = ::std::option::Option::None;
        self.transition = ::std::option::Option::None;
        self.transition_data.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgContrast {
        static instance: CMsgContrast = CMsgContrast {
            base: ::std::option::Option::None,
            transition: ::std::option::Option::None,
            transition_data: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgContrast {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgContrast").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgContrast {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgContrast {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgContrast`
pub mod cmsg_contrast {
    // @@protoc_insertion_point(message:CMsgContrast.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsgContrast.AnimationFrameData.data)
        pub data: ::std::option::Option<f64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgContrast.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }

        // optional double data = 1;

        pub fn data(&self) -> f64 {
            self.data.unwrap_or(0.)
        }

        pub fn clear_data(&mut self) {
            self.data = ::std::option::Option::None;
        }

        pub fn has_data(&self) -> bool {
            self.data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data(&mut self, v: f64) {
            self.data = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "data",
                |m: &AnimationFrameData| { &m.data },
                |m: &mut AnimationFrameData| { &mut m.data },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AnimationFrameData>(
                "CMsgContrast.AnimationFrameData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.data = ::std::option::Option::Some(is.read_double()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data {
                os.write_double(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AnimationFrameData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgContrast.AnimationFrameData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AnimationFrameData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AnimationFrameData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgGaussianValues)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGaussianValues {
    // message fields
    // @@protoc_insertion_point(field:CMsgGaussianValues.passes)
    pub passes: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgGaussianValues.stddev_hor)
    pub stddev_hor: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgGaussianValues.stddev_ver)
    pub stddev_ver: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGaussianValues.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGaussianValues {
    fn default() -> &'a CMsgGaussianValues {
        <CMsgGaussianValues as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGaussianValues {
    pub fn new() -> CMsgGaussianValues {
        ::std::default::Default::default()
    }

    // optional double passes = 1;

    pub fn passes(&self) -> f64 {
        self.passes.unwrap_or(0.)
    }

    pub fn clear_passes(&mut self) {
        self.passes = ::std::option::Option::None;
    }

    pub fn has_passes(&self) -> bool {
        self.passes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passes(&mut self, v: f64) {
        self.passes = ::std::option::Option::Some(v);
    }

    // optional double stddev_hor = 2;

    pub fn stddev_hor(&self) -> f64 {
        self.stddev_hor.unwrap_or(0.)
    }

    pub fn clear_stddev_hor(&mut self) {
        self.stddev_hor = ::std::option::Option::None;
    }

    pub fn has_stddev_hor(&self) -> bool {
        self.stddev_hor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stddev_hor(&mut self, v: f64) {
        self.stddev_hor = ::std::option::Option::Some(v);
    }

    // optional double stddev_ver = 3;

    pub fn stddev_ver(&self) -> f64 {
        self.stddev_ver.unwrap_or(0.)
    }

    pub fn clear_stddev_ver(&mut self) {
        self.stddev_ver = ::std::option::Option::None;
    }

    pub fn has_stddev_ver(&self) -> bool {
        self.stddev_ver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stddev_ver(&mut self, v: f64) {
        self.stddev_ver = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "passes",
            |m: &CMsgGaussianValues| { &m.passes },
            |m: &mut CMsgGaussianValues| { &mut m.passes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stddev_hor",
            |m: &CMsgGaussianValues| { &m.stddev_hor },
            |m: &mut CMsgGaussianValues| { &mut m.stddev_hor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stddev_ver",
            |m: &CMsgGaussianValues| { &m.stddev_ver },
            |m: &mut CMsgGaussianValues| { &mut m.stddev_ver },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGaussianValues>(
            "CMsgGaussianValues",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGaussianValues {
    const NAME: &'static str = "CMsgGaussianValues";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.passes = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.stddev_hor = ::std::option::Option::Some(is.read_double()?);
                },
                25 => {
                    self.stddev_ver = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.passes {
            my_size += 1 + 8;
        }
        if let Some(v) = self.stddev_hor {
            my_size += 1 + 8;
        }
        if let Some(v) = self.stddev_ver {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.passes {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.stddev_hor {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.stddev_ver {
            os.write_double(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGaussianValues {
        CMsgGaussianValues::new()
    }

    fn clear(&mut self) {
        self.passes = ::std::option::Option::None;
        self.stddev_hor = ::std::option::Option::None;
        self.stddev_ver = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGaussianValues {
        static instance: CMsgGaussianValues = CMsgGaussianValues {
            passes: ::std::option::Option::None,
            stddev_hor: ::std::option::Option::None,
            stddev_ver: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGaussianValues {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGaussianValues").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGaussianValues {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGaussianValues {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGaussianBlur)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGaussianBlur {
    // message fields
    // @@protoc_insertion_point(field:CMsgGaussianBlur.base)
    pub base: ::protobuf::MessageField<CMsgGaussianValues>,
    // @@protoc_insertion_point(field:CMsgGaussianBlur.transition)
    pub transition: ::protobuf::MessageField<CMsgGaussianValues>,
    // @@protoc_insertion_point(field:CMsgGaussianBlur.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsgGaussianBlur.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGaussianBlur.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGaussianBlur.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGaussianBlur {
    fn default() -> &'a CMsgGaussianBlur {
        <CMsgGaussianBlur as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGaussianBlur {
    pub fn new() -> CMsgGaussianBlur {
        ::std::default::Default::default()
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGaussianValues>(
            "base",
            |m: &CMsgGaussianBlur| { &m.base },
            |m: &mut CMsgGaussianBlur| { &mut m.base },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGaussianValues>(
            "transition",
            |m: &CMsgGaussianBlur| { &m.transition },
            |m: &mut CMsgGaussianBlur| { &mut m.transition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgTransitionData>(
            "transition_data",
            |m: &CMsgGaussianBlur| { &m.transition_data },
            |m: &mut CMsgGaussianBlur| { &mut m.transition_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "style_symbol",
            |m: &CMsgGaussianBlur| { &m.style_symbol },
            |m: &mut CMsgGaussianBlur| { &mut m.style_symbol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "animations",
            |m: &CMsgGaussianBlur| { &m.animations },
            |m: &mut CMsgGaussianBlur| { &mut m.animations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGaussianBlur>(
            "CMsgGaussianBlur",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGaussianBlur {
    const NAME: &'static str = "CMsgGaussianBlur";

    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.transition.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGaussianBlur {
        CMsgGaussianBlur::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.transition.clear();
        self.transition_data.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGaussianBlur {
        static instance: CMsgGaussianBlur = CMsgGaussianBlur {
            base: ::protobuf::MessageField::none(),
            transition: ::protobuf::MessageField::none(),
            transition_data: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGaussianBlur {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGaussianBlur").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGaussianBlur {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGaussianBlur {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGaussianBlur`
pub mod cmsg_gaussian_blur {
    // @@protoc_insertion_point(message:CMsgGaussianBlur.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsgGaussianBlur.AnimationFrameData.data)
        pub data: ::protobuf::MessageField<super::CMsgGaussianValues>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGaussianBlur.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::CMsgGaussianValues>(
                "data",
                |m: &AnimationFrameData| { &m.data },
                |m: &mut AnimationFrameData| { &mut m.data },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AnimationFrameData>(
                "CMsgGaussianBlur.AnimationFrameData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AnimationFrameData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGaussianBlur.AnimationFrameData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AnimationFrameData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AnimationFrameData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgMotionBlurValues)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMotionBlurValues {
    // message fields
    // @@protoc_insertion_point(field:CMsgMotionBlurValues.velocity)
    pub velocity: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgMotionBlurValues.dirx)
    pub dirx: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgMotionBlurValues.diry)
    pub diry: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMotionBlurValues.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMotionBlurValues {
    fn default() -> &'a CMsgMotionBlurValues {
        <CMsgMotionBlurValues as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMotionBlurValues {
    pub fn new() -> CMsgMotionBlurValues {
        ::std::default::Default::default()
    }

    // optional double velocity = 1;

    pub fn velocity(&self) -> f64 {
        self.velocity.unwrap_or(0.)
    }

    pub fn clear_velocity(&mut self) {
        self.velocity = ::std::option::Option::None;
    }

    pub fn has_velocity(&self) -> bool {
        self.velocity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_velocity(&mut self, v: f64) {
        self.velocity = ::std::option::Option::Some(v);
    }

    // optional double dirx = 2;

    pub fn dirx(&self) -> f64 {
        self.dirx.unwrap_or(0.)
    }

    pub fn clear_dirx(&mut self) {
        self.dirx = ::std::option::Option::None;
    }

    pub fn has_dirx(&self) -> bool {
        self.dirx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dirx(&mut self, v: f64) {
        self.dirx = ::std::option::Option::Some(v);
    }

    // optional double diry = 3;

    pub fn diry(&self) -> f64 {
        self.diry.unwrap_or(0.)
    }

    pub fn clear_diry(&mut self) {
        self.diry = ::std::option::Option::None;
    }

    pub fn has_diry(&self) -> bool {
        self.diry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_diry(&mut self, v: f64) {
        self.diry = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "velocity",
            |m: &CMsgMotionBlurValues| { &m.velocity },
            |m: &mut CMsgMotionBlurValues| { &mut m.velocity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dirx",
            |m: &CMsgMotionBlurValues| { &m.dirx },
            |m: &mut CMsgMotionBlurValues| { &mut m.dirx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "diry",
            |m: &CMsgMotionBlurValues| { &m.diry },
            |m: &mut CMsgMotionBlurValues| { &mut m.diry },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgMotionBlurValues>(
            "CMsgMotionBlurValues",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgMotionBlurValues {
    const NAME: &'static str = "CMsgMotionBlurValues";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.velocity = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.dirx = ::std::option::Option::Some(is.read_double()?);
                },
                25 => {
                    self.diry = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.velocity {
            my_size += 1 + 8;
        }
        if let Some(v) = self.dirx {
            my_size += 1 + 8;
        }
        if let Some(v) = self.diry {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.velocity {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.dirx {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.diry {
            os.write_double(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMotionBlurValues {
        CMsgMotionBlurValues::new()
    }

    fn clear(&mut self) {
        self.velocity = ::std::option::Option::None;
        self.dirx = ::std::option::Option::None;
        self.diry = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMotionBlurValues {
        static instance: CMsgMotionBlurValues = CMsgMotionBlurValues {
            velocity: ::std::option::Option::None,
            dirx: ::std::option::Option::None,
            diry: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgMotionBlurValues {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgMotionBlurValues").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgMotionBlurValues {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMotionBlurValues {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgMotionBlur)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMotionBlur {
    // message fields
    // @@protoc_insertion_point(field:CMsgMotionBlur.base)
    pub base: ::protobuf::MessageField<CMsgMotionBlurValues>,
    // @@protoc_insertion_point(field:CMsgMotionBlur.transition)
    pub transition: ::protobuf::MessageField<CMsgMotionBlurValues>,
    // @@protoc_insertion_point(field:CMsgMotionBlur.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsgMotionBlur.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // @@protoc_insertion_point(field:CMsgMotionBlur.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMotionBlur.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMotionBlur {
    fn default() -> &'a CMsgMotionBlur {
        <CMsgMotionBlur as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMotionBlur {
    pub fn new() -> CMsgMotionBlur {
        ::std::default::Default::default()
    }

    // optional uint32 style_symbol = 5;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgMotionBlurValues>(
            "base",
            |m: &CMsgMotionBlur| { &m.base },
            |m: &mut CMsgMotionBlur| { &mut m.base },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgMotionBlurValues>(
            "transition",
            |m: &CMsgMotionBlur| { &m.transition },
            |m: &mut CMsgMotionBlur| { &mut m.transition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgTransitionData>(
            "transition_data",
            |m: &CMsgMotionBlur| { &m.transition_data },
            |m: &mut CMsgMotionBlur| { &mut m.transition_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "animations",
            |m: &CMsgMotionBlur| { &m.animations },
            |m: &mut CMsgMotionBlur| { &mut m.animations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "style_symbol",
            |m: &CMsgMotionBlur| { &m.style_symbol },
            |m: &mut CMsgMotionBlur| { &mut m.style_symbol },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgMotionBlur>(
            "CMsgMotionBlur",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgMotionBlur {
    const NAME: &'static str = "CMsgMotionBlur";

    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                34 => {
                    self.animations.push(is.read_message()?);
                },
                40 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.transition.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.style_symbol {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMotionBlur {
        CMsgMotionBlur::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.transition.clear();
        self.transition_data.clear();
        self.animations.clear();
        self.style_symbol = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMotionBlur {
        static instance: CMsgMotionBlur = CMsgMotionBlur {
            base: ::protobuf::MessageField::none(),
            transition: ::protobuf::MessageField::none(),
            transition_data: ::protobuf::MessageField::none(),
            animations: ::std::vec::Vec::new(),
            style_symbol: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgMotionBlur {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgMotionBlur").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgMotionBlur {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMotionBlur {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgMotionBlur`
pub mod cmsg_motion_blur {
    // @@protoc_insertion_point(message:CMsgMotionBlur.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsgMotionBlur.AnimationFrameData.data)
        pub data: ::protobuf::MessageField<super::CMsgMotionBlurValues>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgMotionBlur.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::CMsgMotionBlurValues>(
                "data",
                |m: &AnimationFrameData| { &m.data },
                |m: &mut AnimationFrameData| { &mut m.data },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AnimationFrameData>(
                "CMsgMotionBlur.AnimationFrameData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AnimationFrameData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgMotionBlur.AnimationFrameData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AnimationFrameData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AnimationFrameData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsg3DTransformPerspective)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsg3DTransformPerspective {
    // message fields
    // @@protoc_insertion_point(field:CMsg3DTransformPerspective.base)
    pub base: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsg3DTransformPerspective.transition)
    pub transition: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsg3DTransformPerspective.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsg3DTransformPerspective.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsg3DTransformPerspective.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsg3DTransformPerspective.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsg3DTransformPerspective {
    fn default() -> &'a CMsg3DTransformPerspective {
        <CMsg3DTransformPerspective as ::protobuf::Message>::default_instance()
    }
}

impl CMsg3DTransformPerspective {
    pub fn new() -> CMsg3DTransformPerspective {
        ::std::default::Default::default()
    }

    // optional double base = 1;

    pub fn base(&self) -> f64 {
        self.base.unwrap_or(0.)
    }

    pub fn clear_base(&mut self) {
        self.base = ::std::option::Option::None;
    }

    pub fn has_base(&self) -> bool {
        self.base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base(&mut self, v: f64) {
        self.base = ::std::option::Option::Some(v);
    }

    // optional double transition = 2;

    pub fn transition(&self) -> f64 {
        self.transition.unwrap_or(0.)
    }

    pub fn clear_transition(&mut self) {
        self.transition = ::std::option::Option::None;
    }

    pub fn has_transition(&self) -> bool {
        self.transition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transition(&mut self, v: f64) {
        self.transition = ::std::option::Option::Some(v);
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "base",
            |m: &CMsg3DTransformPerspective| { &m.base },
            |m: &mut CMsg3DTransformPerspective| { &mut m.base },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transition",
            |m: &CMsg3DTransformPerspective| { &m.transition },
            |m: &mut CMsg3DTransformPerspective| { &mut m.transition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgTransitionData>(
            "transition_data",
            |m: &CMsg3DTransformPerspective| { &m.transition_data },
            |m: &mut CMsg3DTransformPerspective| { &mut m.transition_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "style_symbol",
            |m: &CMsg3DTransformPerspective| { &m.style_symbol },
            |m: &mut CMsg3DTransformPerspective| { &mut m.style_symbol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "animations",
            |m: &CMsg3DTransformPerspective| { &m.animations },
            |m: &mut CMsg3DTransformPerspective| { &mut m.animations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsg3DTransformPerspective>(
            "CMsg3DTransformPerspective",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsg3DTransformPerspective {
    const NAME: &'static str = "CMsg3DTransformPerspective";

    fn is_initialized(&self) -> bool {
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.base = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.transition = ::std::option::Option::Some(is.read_double()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transition {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.transition {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsg3DTransformPerspective {
        CMsg3DTransformPerspective::new()
    }

    fn clear(&mut self) {
        self.base = ::std::option::Option::None;
        self.transition = ::std::option::Option::None;
        self.transition_data.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsg3DTransformPerspective {
        static instance: CMsg3DTransformPerspective = CMsg3DTransformPerspective {
            base: ::std::option::Option::None,
            transition: ::std::option::Option::None,
            transition_data: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsg3DTransformPerspective {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsg3DTransformPerspective").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsg3DTransformPerspective {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsg3DTransformPerspective {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsg3DTransformPerspective`
pub mod cmsg3dtransform_perspective {
    // @@protoc_insertion_point(message:CMsg3DTransformPerspective.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsg3DTransformPerspective.AnimationFrameData.data)
        pub data: ::std::option::Option<f64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsg3DTransformPerspective.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }

        // optional double data = 1;

        pub fn data(&self) -> f64 {
            self.data.unwrap_or(0.)
        }

        pub fn clear_data(&mut self) {
            self.data = ::std::option::Option::None;
        }

        pub fn has_data(&self) -> bool {
            self.data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data(&mut self, v: f64) {
            self.data = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "data",
                |m: &AnimationFrameData| { &m.data },
                |m: &mut AnimationFrameData| { &mut m.data },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AnimationFrameData>(
                "CMsg3DTransformPerspective.AnimationFrameData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.data = ::std::option::Option::Some(is.read_double()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data {
                os.write_double(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AnimationFrameData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsg3DTransformPerspective.AnimationFrameData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AnimationFrameData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AnimationFrameData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsg3DTransformPerspectiveOrigin)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsg3DTransformPerspectiveOrigin {
    // message fields
    // @@protoc_insertion_point(field:CMsg3DTransformPerspectiveOrigin.base)
    pub base: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsg3DTransformPerspectiveOrigin.transition)
    pub transition: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsg3DTransformPerspectiveOrigin.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsg3DTransformPerspectiveOrigin.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsg3DTransformPerspectiveOrigin.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsg3DTransformPerspectiveOrigin.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsg3DTransformPerspectiveOrigin {
    fn default() -> &'a CMsg3DTransformPerspectiveOrigin {
        <CMsg3DTransformPerspectiveOrigin as ::protobuf::Message>::default_instance()
    }
}

impl CMsg3DTransformPerspectiveOrigin {
    pub fn new() -> CMsg3DTransformPerspectiveOrigin {
        ::std::default::Default::default()
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "base",
            |m: &CMsg3DTransformPerspectiveOrigin| { &m.base },
            |m: &mut CMsg3DTransformPerspectiveOrigin| { &mut m.base },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "transition",
            |m: &CMsg3DTransformPerspectiveOrigin| { &m.transition },
            |m: &mut CMsg3DTransformPerspectiveOrigin| { &mut m.transition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgTransitionData>(
            "transition_data",
            |m: &CMsg3DTransformPerspectiveOrigin| { &m.transition_data },
            |m: &mut CMsg3DTransformPerspectiveOrigin| { &mut m.transition_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "style_symbol",
            |m: &CMsg3DTransformPerspectiveOrigin| { &m.style_symbol },
            |m: &mut CMsg3DTransformPerspectiveOrigin| { &mut m.style_symbol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "animations",
            |m: &CMsg3DTransformPerspectiveOrigin| { &m.animations },
            |m: &mut CMsg3DTransformPerspectiveOrigin| { &mut m.animations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsg3DTransformPerspectiveOrigin>(
            "CMsg3DTransformPerspectiveOrigin",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsg3DTransformPerspectiveOrigin {
    const NAME: &'static str = "CMsg3DTransformPerspectiveOrigin";

    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.transition.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsg3DTransformPerspectiveOrigin {
        CMsg3DTransformPerspectiveOrigin::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.transition.clear();
        self.transition_data.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsg3DTransformPerspectiveOrigin {
        static instance: CMsg3DTransformPerspectiveOrigin = CMsg3DTransformPerspectiveOrigin {
            base: ::protobuf::MessageField::none(),
            transition: ::protobuf::MessageField::none(),
            transition_data: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsg3DTransformPerspectiveOrigin {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsg3DTransformPerspectiveOrigin").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsg3DTransformPerspectiveOrigin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsg3DTransformPerspectiveOrigin {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsg3DTransformPerspectiveOrigin`
pub mod cmsg3dtransform_perspective_origin {
    // @@protoc_insertion_point(message:CMsg3DTransformPerspectiveOrigin.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsg3DTransformPerspectiveOrigin.AnimationFrameData.data)
        pub data: ::protobuf::MessageField<super::CMsgPoint>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsg3DTransformPerspectiveOrigin.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::CMsgPoint>(
                "data",
                |m: &AnimationFrameData| { &m.data },
                |m: &mut AnimationFrameData| { &mut m.data },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AnimationFrameData>(
                "CMsg3DTransformPerspectiveOrigin.AnimationFrameData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AnimationFrameData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsg3DTransformPerspectiveOrigin.AnimationFrameData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AnimationFrameData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AnimationFrameData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgTransformOriginData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTransformOriginData {
    // message fields
    // @@protoc_insertion_point(field:CMsgTransformOriginData.x)
    pub x: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgTransformOriginData.y)
    pub y: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgTransformOriginData.x_is_percent)
    pub x_is_percent: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgTransformOriginData.y_is_percent)
    pub y_is_percent: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgTransformOriginData.is_parent_relative)
    pub is_parent_relative: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTransformOriginData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTransformOriginData {
    fn default() -> &'a CMsgTransformOriginData {
        <CMsgTransformOriginData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTransformOriginData {
    pub fn new() -> CMsgTransformOriginData {
        ::std::default::Default::default()
    }

    // optional double x = 1;

    pub fn x(&self) -> f64 {
        self.x.unwrap_or(0.)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f64) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional double y = 2;

    pub fn y(&self) -> f64 {
        self.y.unwrap_or(0.)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f64) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional bool x_is_percent = 3;

    pub fn x_is_percent(&self) -> bool {
        self.x_is_percent.unwrap_or(false)
    }

    pub fn clear_x_is_percent(&mut self) {
        self.x_is_percent = ::std::option::Option::None;
    }

    pub fn has_x_is_percent(&self) -> bool {
        self.x_is_percent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x_is_percent(&mut self, v: bool) {
        self.x_is_percent = ::std::option::Option::Some(v);
    }

    // optional bool y_is_percent = 4;

    pub fn y_is_percent(&self) -> bool {
        self.y_is_percent.unwrap_or(false)
    }

    pub fn clear_y_is_percent(&mut self) {
        self.y_is_percent = ::std::option::Option::None;
    }

    pub fn has_y_is_percent(&self) -> bool {
        self.y_is_percent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y_is_percent(&mut self, v: bool) {
        self.y_is_percent = ::std::option::Option::Some(v);
    }

    // optional bool is_parent_relative = 5;

    pub fn is_parent_relative(&self) -> bool {
        self.is_parent_relative.unwrap_or(false)
    }

    pub fn clear_is_parent_relative(&mut self) {
        self.is_parent_relative = ::std::option::Option::None;
    }

    pub fn has_is_parent_relative(&self) -> bool {
        self.is_parent_relative.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_parent_relative(&mut self, v: bool) {
        self.is_parent_relative = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &CMsgTransformOriginData| { &m.x },
            |m: &mut CMsgTransformOriginData| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &CMsgTransformOriginData| { &m.y },
            |m: &mut CMsgTransformOriginData| { &mut m.y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "x_is_percent",
            |m: &CMsgTransformOriginData| { &m.x_is_percent },
            |m: &mut CMsgTransformOriginData| { &mut m.x_is_percent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "y_is_percent",
            |m: &CMsgTransformOriginData| { &m.y_is_percent },
            |m: &mut CMsgTransformOriginData| { &mut m.y_is_percent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_parent_relative",
            |m: &CMsgTransformOriginData| { &m.is_parent_relative },
            |m: &mut CMsgTransformOriginData| { &mut m.is_parent_relative },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTransformOriginData>(
            "CMsgTransformOriginData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTransformOriginData {
    const NAME: &'static str = "CMsgTransformOriginData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.x = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.y = ::std::option::Option::Some(is.read_double()?);
                },
                24 => {
                    self.x_is_percent = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.y_is_percent = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.is_parent_relative = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.x {
            my_size += 1 + 8;
        }
        if let Some(v) = self.y {
            my_size += 1 + 8;
        }
        if let Some(v) = self.x_is_percent {
            my_size += 1 + 1;
        }
        if let Some(v) = self.y_is_percent {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_parent_relative {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.x {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.y {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.x_is_percent {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.y_is_percent {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.is_parent_relative {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTransformOriginData {
        CMsgTransformOriginData::new()
    }

    fn clear(&mut self) {
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.x_is_percent = ::std::option::Option::None;
        self.y_is_percent = ::std::option::Option::None;
        self.is_parent_relative = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTransformOriginData {
        static instance: CMsgTransformOriginData = CMsgTransformOriginData {
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            x_is_percent: ::std::option::Option::None,
            y_is_percent: ::std::option::Option::None,
            is_parent_relative: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTransformOriginData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTransformOriginData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTransformOriginData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTransformOriginData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsg3DTransformOrigin)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsg3DTransformOrigin {
    // message fields
    // @@protoc_insertion_point(field:CMsg3DTransformOrigin.base)
    pub base: ::protobuf::MessageField<CMsgTransformOriginData>,
    // @@protoc_insertion_point(field:CMsg3DTransformOrigin.transition)
    pub transition: ::protobuf::MessageField<CMsgTransformOriginData>,
    // @@protoc_insertion_point(field:CMsg3DTransformOrigin.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsg3DTransformOrigin.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsg3DTransformOrigin.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsg3DTransformOrigin.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsg3DTransformOrigin {
    fn default() -> &'a CMsg3DTransformOrigin {
        <CMsg3DTransformOrigin as ::protobuf::Message>::default_instance()
    }
}

impl CMsg3DTransformOrigin {
    pub fn new() -> CMsg3DTransformOrigin {
        ::std::default::Default::default()
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgTransformOriginData>(
            "base",
            |m: &CMsg3DTransformOrigin| { &m.base },
            |m: &mut CMsg3DTransformOrigin| { &mut m.base },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgTransformOriginData>(
            "transition",
            |m: &CMsg3DTransformOrigin| { &m.transition },
            |m: &mut CMsg3DTransformOrigin| { &mut m.transition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgTransitionData>(
            "transition_data",
            |m: &CMsg3DTransformOrigin| { &m.transition_data },
            |m: &mut CMsg3DTransformOrigin| { &mut m.transition_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "style_symbol",
            |m: &CMsg3DTransformOrigin| { &m.style_symbol },
            |m: &mut CMsg3DTransformOrigin| { &mut m.style_symbol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "animations",
            |m: &CMsg3DTransformOrigin| { &m.animations },
            |m: &mut CMsg3DTransformOrigin| { &mut m.animations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsg3DTransformOrigin>(
            "CMsg3DTransformOrigin",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsg3DTransformOrigin {
    const NAME: &'static str = "CMsg3DTransformOrigin";

    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.transition.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsg3DTransformOrigin {
        CMsg3DTransformOrigin::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.transition.clear();
        self.transition_data.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsg3DTransformOrigin {
        static instance: CMsg3DTransformOrigin = CMsg3DTransformOrigin {
            base: ::protobuf::MessageField::none(),
            transition: ::protobuf::MessageField::none(),
            transition_data: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsg3DTransformOrigin {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsg3DTransformOrigin").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsg3DTransformOrigin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsg3DTransformOrigin {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsg3DTransformOrigin`
pub mod cmsg3dtransform_origin {
    // @@protoc_insertion_point(message:CMsg3DTransformOrigin.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsg3DTransformOrigin.AnimationFrameData.data)
        pub data: ::protobuf::MessageField<super::CMsgTransformOriginData>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsg3DTransformOrigin.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::CMsgTransformOriginData>(
                "data",
                |m: &AnimationFrameData| { &m.data },
                |m: &mut AnimationFrameData| { &mut m.data },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AnimationFrameData>(
                "CMsg3DTransformOrigin.AnimationFrameData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AnimationFrameData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsg3DTransformOrigin.AnimationFrameData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AnimationFrameData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AnimationFrameData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsg3DTransformMatrix)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsg3DTransformMatrix {
    // message fields
    // @@protoc_insertion_point(field:CMsg3DTransformMatrix.base)
    pub base: ::protobuf::MessageField<CMsgMatrix4x4>,
    // @@protoc_insertion_point(field:CMsg3DTransformMatrix.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsg3DTransformMatrix.transition)
    pub transition: ::protobuf::MessageField<CMsgMatrix4x4>,
    // @@protoc_insertion_point(field:CMsg3DTransformMatrix.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsg3DTransformMatrix.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsg3DTransformMatrix.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsg3DTransformMatrix {
    fn default() -> &'a CMsg3DTransformMatrix {
        <CMsg3DTransformMatrix as ::protobuf::Message>::default_instance()
    }
}

impl CMsg3DTransformMatrix {
    pub fn new() -> CMsg3DTransformMatrix {
        ::std::default::Default::default()
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgMatrix4x4>(
            "base",
            |m: &CMsg3DTransformMatrix| { &m.base },
            |m: &mut CMsg3DTransformMatrix| { &mut m.base },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgTransitionData>(
            "transition_data",
            |m: &CMsg3DTransformMatrix| { &m.transition_data },
            |m: &mut CMsg3DTransformMatrix| { &mut m.transition_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgMatrix4x4>(
            "transition",
            |m: &CMsg3DTransformMatrix| { &m.transition },
            |m: &mut CMsg3DTransformMatrix| { &mut m.transition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "style_symbol",
            |m: &CMsg3DTransformMatrix| { &m.style_symbol },
            |m: &mut CMsg3DTransformMatrix| { &mut m.style_symbol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "animations",
            |m: &CMsg3DTransformMatrix| { &m.animations },
            |m: &mut CMsg3DTransformMatrix| { &mut m.animations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsg3DTransformMatrix>(
            "CMsg3DTransformMatrix",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsg3DTransformMatrix {
    const NAME: &'static str = "CMsg3DTransformMatrix";

    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.transition.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsg3DTransformMatrix {
        CMsg3DTransformMatrix::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.transition_data.clear();
        self.transition.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsg3DTransformMatrix {
        static instance: CMsg3DTransformMatrix = CMsg3DTransformMatrix {
            base: ::protobuf::MessageField::none(),
            transition_data: ::protobuf::MessageField::none(),
            transition: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsg3DTransformMatrix {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsg3DTransformMatrix").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsg3DTransformMatrix {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsg3DTransformMatrix {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsg3DTransformMatrix`
pub mod cmsg3dtransform_matrix {
    // @@protoc_insertion_point(message:CMsg3DTransformMatrix.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsg3DTransformMatrix.AnimationFrameData.data)
        pub data: ::protobuf::MessageField<super::CMsgMatrix4x4>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsg3DTransformMatrix.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::CMsgMatrix4x4>(
                "data",
                |m: &AnimationFrameData| { &m.data },
                |m: &mut AnimationFrameData| { &mut m.data },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AnimationFrameData>(
                "CMsg3DTransformMatrix.AnimationFrameData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AnimationFrameData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsg3DTransformMatrix.AnimationFrameData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AnimationFrameData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AnimationFrameData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgBorderRadius)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBorderRadius {
    // message fields
    // @@protoc_insertion_point(field:CMsgBorderRadius.base)
    pub base: ::protobuf::MessageField<CRadiusData>,
    // @@protoc_insertion_point(field:CMsgBorderRadius.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsgBorderRadius.transition)
    pub transition: ::protobuf::MessageField<CRadiusData>,
    // @@protoc_insertion_point(field:CMsgBorderRadius.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBorderRadius.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBorderRadius.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBorderRadius {
    fn default() -> &'a CMsgBorderRadius {
        <CMsgBorderRadius as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBorderRadius {
    pub fn new() -> CMsgBorderRadius {
        ::std::default::Default::default()
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CRadiusData>(
            "base",
            |m: &CMsgBorderRadius| { &m.base },
            |m: &mut CMsgBorderRadius| { &mut m.base },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgTransitionData>(
            "transition_data",
            |m: &CMsgBorderRadius| { &m.transition_data },
            |m: &mut CMsgBorderRadius| { &mut m.transition_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CRadiusData>(
            "transition",
            |m: &CMsgBorderRadius| { &m.transition },
            |m: &mut CMsgBorderRadius| { &mut m.transition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "style_symbol",
            |m: &CMsgBorderRadius| { &m.style_symbol },
            |m: &mut CMsgBorderRadius| { &mut m.style_symbol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "animations",
            |m: &CMsgBorderRadius| { &m.animations },
            |m: &mut CMsgBorderRadius| { &mut m.animations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBorderRadius>(
            "CMsgBorderRadius",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgBorderRadius {
    const NAME: &'static str = "CMsgBorderRadius";

    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.transition.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBorderRadius {
        CMsgBorderRadius::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.transition_data.clear();
        self.transition.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBorderRadius {
        static instance: CMsgBorderRadius = CMsgBorderRadius {
            base: ::protobuf::MessageField::none(),
            transition_data: ::protobuf::MessageField::none(),
            transition: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgBorderRadius {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBorderRadius").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBorderRadius {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBorderRadius {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgBorderRadius`
pub mod cmsg_border_radius {
    // @@protoc_insertion_point(message:CMsgBorderRadius.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsgBorderRadius.AnimationFrameData.data)
        pub data: ::protobuf::MessageField<super::CRadiusData>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgBorderRadius.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::CRadiusData>(
                "data",
                |m: &AnimationFrameData| { &m.data },
                |m: &mut AnimationFrameData| { &mut m.data },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AnimationFrameData>(
                "CMsgBorderRadius.AnimationFrameData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AnimationFrameData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgBorderRadius.AnimationFrameData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AnimationFrameData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AnimationFrameData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgBorder)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBorder {
    // message fields
    // @@protoc_insertion_point(field:CMsgBorder.base)
    pub base: ::protobuf::MessageField<CBorderData>,
    // @@protoc_insertion_point(field:CMsgBorder.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsgBorder.transition)
    pub transition: ::protobuf::MessageField<CBorderData>,
    // @@protoc_insertion_point(field:CMsgBorder.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBorder.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBorder.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBorder {
    fn default() -> &'a CMsgBorder {
        <CMsgBorder as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBorder {
    pub fn new() -> CMsgBorder {
        ::std::default::Default::default()
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CBorderData>(
            "base",
            |m: &CMsgBorder| { &m.base },
            |m: &mut CMsgBorder| { &mut m.base },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgTransitionData>(
            "transition_data",
            |m: &CMsgBorder| { &m.transition_data },
            |m: &mut CMsgBorder| { &mut m.transition_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CBorderData>(
            "transition",
            |m: &CMsgBorder| { &m.transition },
            |m: &mut CMsgBorder| { &mut m.transition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "style_symbol",
            |m: &CMsgBorder| { &m.style_symbol },
            |m: &mut CMsgBorder| { &mut m.style_symbol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "animations",
            |m: &CMsgBorder| { &m.animations },
            |m: &mut CMsgBorder| { &mut m.animations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBorder>(
            "CMsgBorder",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgBorder {
    const NAME: &'static str = "CMsgBorder";

    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.transition.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBorder {
        CMsgBorder::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.transition_data.clear();
        self.transition.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBorder {
        static instance: CMsgBorder = CMsgBorder {
            base: ::protobuf::MessageField::none(),
            transition_data: ::protobuf::MessageField::none(),
            transition: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgBorder {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBorder").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBorder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBorder {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgBorder`
pub mod cmsg_border {
    // @@protoc_insertion_point(message:CMsgBorder.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsgBorder.AnimationFrameData.data)
        pub data: ::protobuf::MessageField<super::CBorderData>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgBorder.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::CBorderData>(
                "data",
                |m: &AnimationFrameData| { &m.data },
                |m: &mut AnimationFrameData| { &mut m.data },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AnimationFrameData>(
                "CMsgBorder.AnimationFrameData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AnimationFrameData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgBorder.AnimationFrameData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AnimationFrameData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AnimationFrameData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgBoxShadow)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBoxShadow {
    // message fields
    // @@protoc_insertion_point(field:CMsgBoxShadow.base)
    pub base: ::protobuf::MessageField<CBoxShadowData>,
    // @@protoc_insertion_point(field:CMsgBoxShadow.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsgBoxShadow.transition)
    pub transition: ::protobuf::MessageField<CBoxShadowData>,
    // @@protoc_insertion_point(field:CMsgBoxShadow.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBoxShadow.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBoxShadow.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBoxShadow {
    fn default() -> &'a CMsgBoxShadow {
        <CMsgBoxShadow as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBoxShadow {
    pub fn new() -> CMsgBoxShadow {
        ::std::default::Default::default()
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CBoxShadowData>(
            "base",
            |m: &CMsgBoxShadow| { &m.base },
            |m: &mut CMsgBoxShadow| { &mut m.base },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgTransitionData>(
            "transition_data",
            |m: &CMsgBoxShadow| { &m.transition_data },
            |m: &mut CMsgBoxShadow| { &mut m.transition_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CBoxShadowData>(
            "transition",
            |m: &CMsgBoxShadow| { &m.transition },
            |m: &mut CMsgBoxShadow| { &mut m.transition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "style_symbol",
            |m: &CMsgBoxShadow| { &m.style_symbol },
            |m: &mut CMsgBoxShadow| { &mut m.style_symbol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "animations",
            |m: &CMsgBoxShadow| { &m.animations },
            |m: &mut CMsgBoxShadow| { &mut m.animations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBoxShadow>(
            "CMsgBoxShadow",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgBoxShadow {
    const NAME: &'static str = "CMsgBoxShadow";

    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.transition.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBoxShadow {
        CMsgBoxShadow::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.transition_data.clear();
        self.transition.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBoxShadow {
        static instance: CMsgBoxShadow = CMsgBoxShadow {
            base: ::protobuf::MessageField::none(),
            transition_data: ::protobuf::MessageField::none(),
            transition: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgBoxShadow {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBoxShadow").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBoxShadow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBoxShadow {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgBoxShadow`
pub mod cmsg_box_shadow {
    // @@protoc_insertion_point(message:CMsgBoxShadow.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsgBoxShadow.AnimationFrameData.data)
        pub data: ::protobuf::MessageField<super::CBoxShadowData>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgBoxShadow.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::CBoxShadowData>(
                "data",
                |m: &AnimationFrameData| { &m.data },
                |m: &mut AnimationFrameData| { &mut m.data },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AnimationFrameData>(
                "CMsgBoxShadow.AnimationFrameData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AnimationFrameData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgBoxShadow.AnimationFrameData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AnimationFrameData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AnimationFrameData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgTextShadow)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTextShadow {
    // message fields
    // @@protoc_insertion_point(field:CMsgTextShadow.base)
    pub base: ::protobuf::MessageField<CTextShadowData>,
    // @@protoc_insertion_point(field:CMsgTextShadow.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsgTextShadow.transition)
    pub transition: ::protobuf::MessageField<CTextShadowData>,
    // @@protoc_insertion_point(field:CMsgTextShadow.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTextShadow.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTextShadow.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTextShadow {
    fn default() -> &'a CMsgTextShadow {
        <CMsgTextShadow as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTextShadow {
    pub fn new() -> CMsgTextShadow {
        ::std::default::Default::default()
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CTextShadowData>(
            "base",
            |m: &CMsgTextShadow| { &m.base },
            |m: &mut CMsgTextShadow| { &mut m.base },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgTransitionData>(
            "transition_data",
            |m: &CMsgTextShadow| { &m.transition_data },
            |m: &mut CMsgTextShadow| { &mut m.transition_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CTextShadowData>(
            "transition",
            |m: &CMsgTextShadow| { &m.transition },
            |m: &mut CMsgTextShadow| { &mut m.transition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "style_symbol",
            |m: &CMsgTextShadow| { &m.style_symbol },
            |m: &mut CMsgTextShadow| { &mut m.style_symbol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "animations",
            |m: &CMsgTextShadow| { &m.animations },
            |m: &mut CMsgTextShadow| { &mut m.animations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTextShadow>(
            "CMsgTextShadow",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTextShadow {
    const NAME: &'static str = "CMsgTextShadow";

    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.transition.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTextShadow {
        CMsgTextShadow::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.transition_data.clear();
        self.transition.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTextShadow {
        static instance: CMsgTextShadow = CMsgTextShadow {
            base: ::protobuf::MessageField::none(),
            transition_data: ::protobuf::MessageField::none(),
            transition: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTextShadow {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTextShadow").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTextShadow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTextShadow {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgTextShadow`
pub mod cmsg_text_shadow {
    // @@protoc_insertion_point(message:CMsgTextShadow.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsgTextShadow.AnimationFrameData.data)
        pub data: ::protobuf::MessageField<super::CTextShadowData>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgTextShadow.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::CTextShadowData>(
                "data",
                |m: &AnimationFrameData| { &m.data },
                |m: &mut AnimationFrameData| { &mut m.data },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AnimationFrameData>(
                "CMsgTextShadow.AnimationFrameData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AnimationFrameData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgTextShadow.AnimationFrameData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AnimationFrameData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AnimationFrameData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClip)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClip {
    // message fields
    // @@protoc_insertion_point(field:CMsgClip.base)
    pub base: ::protobuf::MessageField<CMsgClipData>,
    // @@protoc_insertion_point(field:CMsgClip.transition_data)
    pub transition_data: ::protobuf::MessageField<CMsgTransitionData>,
    // @@protoc_insertion_point(field:CMsgClip.transition)
    pub transition: ::protobuf::MessageField<CMsgClipData>,
    // @@protoc_insertion_point(field:CMsgClip.style_symbol)
    pub style_symbol: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClip.animations)
    pub animations: ::std::vec::Vec<CMsgAnimationData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClip.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClip {
    fn default() -> &'a CMsgClip {
        <CMsgClip as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClip {
    pub fn new() -> CMsgClip {
        ::std::default::Default::default()
    }

    // optional uint32 style_symbol = 4;

    pub fn style_symbol(&self) -> u32 {
        self.style_symbol.unwrap_or(0)
    }

    pub fn clear_style_symbol(&mut self) {
        self.style_symbol = ::std::option::Option::None;
    }

    pub fn has_style_symbol(&self) -> bool {
        self.style_symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_symbol(&mut self, v: u32) {
        self.style_symbol = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgClipData>(
            "base",
            |m: &CMsgClip| { &m.base },
            |m: &mut CMsgClip| { &mut m.base },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgTransitionData>(
            "transition_data",
            |m: &CMsgClip| { &m.transition_data },
            |m: &mut CMsgClip| { &mut m.transition_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgClipData>(
            "transition",
            |m: &CMsgClip| { &m.transition },
            |m: &mut CMsgClip| { &mut m.transition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "style_symbol",
            |m: &CMsgClip| { &m.style_symbol },
            |m: &mut CMsgClip| { &mut m.style_symbol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "animations",
            |m: &CMsgClip| { &m.animations },
            |m: &mut CMsgClip| { &mut m.animations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClip>(
            "CMsgClip",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClip {
    const NAME: &'static str = "CMsgClip";

    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition_data)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transition)?;
                },
                32 => {
                    self.style_symbol = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.animations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style_symbol {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.animations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.transition_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.transition.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.style_symbol {
            os.write_uint32(4, v)?;
        }
        for v in &self.animations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClip {
        CMsgClip::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.transition_data.clear();
        self.transition.clear();
        self.style_symbol = ::std::option::Option::None;
        self.animations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClip {
        static instance: CMsgClip = CMsgClip {
            base: ::protobuf::MessageField::none(),
            transition_data: ::protobuf::MessageField::none(),
            transition: ::protobuf::MessageField::none(),
            style_symbol: ::std::option::Option::None,
            animations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClip {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClip").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClip {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClip {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClip`
pub mod cmsg_clip {
    // @@protoc_insertion_point(message:CMsgClip.AnimationFrameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimationFrameData {
        // message fields
        // @@protoc_insertion_point(field:CMsgClip.AnimationFrameData.data)
        pub data: ::protobuf::MessageField<super::CMsgClipData>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClip.AnimationFrameData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimationFrameData {
        fn default() -> &'a AnimationFrameData {
            <AnimationFrameData as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimationFrameData {
        pub fn new() -> AnimationFrameData {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::CMsgClipData>(
                "data",
                |m: &AnimationFrameData| { &m.data },
                |m: &mut AnimationFrameData| { &mut m.data },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AnimationFrameData>(
                "CMsgClip.AnimationFrameData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AnimationFrameData {
        const NAME: &'static str = "AnimationFrameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimationFrameData {
            AnimationFrameData::new()
        }

        fn clear(&mut self) {
            self.data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimationFrameData {
            static instance: AnimationFrameData = AnimationFrameData {
                data: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AnimationFrameData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClip.AnimationFrameData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AnimationFrameData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AnimationFrameData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgPushClipLayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPushClipLayer {
    // message fields
    // @@protoc_insertion_point(field:CMsgPushClipLayer.top_left)
    pub top_left: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgPushClipLayer.bottom_right)
    pub bottom_right: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgPushClipLayer.border_radius)
    pub border_radius: ::protobuf::MessageField<CRadiusData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPushClipLayer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPushClipLayer {
    fn default() -> &'a CMsgPushClipLayer {
        <CMsgPushClipLayer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPushClipLayer {
    pub fn new() -> CMsgPushClipLayer {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "top_left",
            |m: &CMsgPushClipLayer| { &m.top_left },
            |m: &mut CMsgPushClipLayer| { &mut m.top_left },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "bottom_right",
            |m: &CMsgPushClipLayer| { &m.bottom_right },
            |m: &mut CMsgPushClipLayer| { &mut m.bottom_right },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CRadiusData>(
            "border_radius",
            |m: &CMsgPushClipLayer| { &m.border_radius },
            |m: &mut CMsgPushClipLayer| { &mut m.border_radius },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPushClipLayer>(
            "CMsgPushClipLayer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPushClipLayer {
    const NAME: &'static str = "CMsgPushClipLayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.top_left)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bottom_right)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.border_radius)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.top_left.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bottom_right.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.border_radius.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.top_left.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.bottom_right.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.border_radius.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPushClipLayer {
        CMsgPushClipLayer::new()
    }

    fn clear(&mut self) {
        self.top_left.clear();
        self.bottom_right.clear();
        self.border_radius.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPushClipLayer {
        static instance: CMsgPushClipLayer = CMsgPushClipLayer {
            top_left: ::protobuf::MessageField::none(),
            bottom_right: ::protobuf::MessageField::none(),
            border_radius: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPushClipLayer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPushClipLayer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPushClipLayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPushClipLayer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPopClipLayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPopClipLayer {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPopClipLayer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPopClipLayer {
    fn default() -> &'a CMsgPopClipLayer {
        <CMsgPopClipLayer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPopClipLayer {
    pub fn new() -> CMsgPopClipLayer {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPopClipLayer>(
            "CMsgPopClipLayer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPopClipLayer {
    const NAME: &'static str = "CMsgPopClipLayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPopClipLayer {
        CMsgPopClipLayer::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPopClipLayer {
        static instance: CMsgPopClipLayer = CMsgPopClipLayer {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPopClipLayer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPopClipLayer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPopClipLayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPopClipLayer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPushPanelContextInLayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPushPanelContextInLayer {
    // message fields
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.transform_m00)
    pub transform_m00: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.transform_m01)
    pub transform_m01: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.transform_m02)
    pub transform_m02: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.transform_m03)
    pub transform_m03: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.transform_m10)
    pub transform_m10: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.transform_m11)
    pub transform_m11: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.transform_m12)
    pub transform_m12: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.transform_m13)
    pub transform_m13: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.transform_m20)
    pub transform_m20: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.transform_m21)
    pub transform_m21: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.transform_m22)
    pub transform_m22: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.transform_m23)
    pub transform_m23: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.transform_m30)
    pub transform_m30: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.transform_m31)
    pub transform_m31: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.transform_m32)
    pub transform_m32: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.transform_m33)
    pub transform_m33: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.box_shadow)
    pub box_shadow: ::protobuf::MessageField<CBoxShadowData>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.width)
    pub width: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.height)
    pub height: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.position_x)
    pub position_x: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.position_y)
    pub position_y: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.position_z)
    pub position_z: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.border)
    pub border: ::protobuf::MessageField<CBorderData>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.scroll_x)
    pub scroll_x: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushPanelContextInLayer.scroll_y)
    pub scroll_y: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPushPanelContextInLayer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPushPanelContextInLayer {
    fn default() -> &'a CMsgPushPanelContextInLayer {
        <CMsgPushPanelContextInLayer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPushPanelContextInLayer {
    pub fn new() -> CMsgPushPanelContextInLayer {
        ::std::default::Default::default()
    }

    // optional double transform_m00 = 1;

    pub fn transform_m00(&self) -> f64 {
        self.transform_m00.unwrap_or(0.)
    }

    pub fn clear_transform_m00(&mut self) {
        self.transform_m00 = ::std::option::Option::None;
    }

    pub fn has_transform_m00(&self) -> bool {
        self.transform_m00.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m00(&mut self, v: f64) {
        self.transform_m00 = ::std::option::Option::Some(v);
    }

    // optional double transform_m01 = 2;

    pub fn transform_m01(&self) -> f64 {
        self.transform_m01.unwrap_or(0.)
    }

    pub fn clear_transform_m01(&mut self) {
        self.transform_m01 = ::std::option::Option::None;
    }

    pub fn has_transform_m01(&self) -> bool {
        self.transform_m01.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m01(&mut self, v: f64) {
        self.transform_m01 = ::std::option::Option::Some(v);
    }

    // optional double transform_m02 = 3;

    pub fn transform_m02(&self) -> f64 {
        self.transform_m02.unwrap_or(0.)
    }

    pub fn clear_transform_m02(&mut self) {
        self.transform_m02 = ::std::option::Option::None;
    }

    pub fn has_transform_m02(&self) -> bool {
        self.transform_m02.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m02(&mut self, v: f64) {
        self.transform_m02 = ::std::option::Option::Some(v);
    }

    // optional double transform_m03 = 4;

    pub fn transform_m03(&self) -> f64 {
        self.transform_m03.unwrap_or(0.)
    }

    pub fn clear_transform_m03(&mut self) {
        self.transform_m03 = ::std::option::Option::None;
    }

    pub fn has_transform_m03(&self) -> bool {
        self.transform_m03.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m03(&mut self, v: f64) {
        self.transform_m03 = ::std::option::Option::Some(v);
    }

    // optional double transform_m10 = 5;

    pub fn transform_m10(&self) -> f64 {
        self.transform_m10.unwrap_or(0.)
    }

    pub fn clear_transform_m10(&mut self) {
        self.transform_m10 = ::std::option::Option::None;
    }

    pub fn has_transform_m10(&self) -> bool {
        self.transform_m10.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m10(&mut self, v: f64) {
        self.transform_m10 = ::std::option::Option::Some(v);
    }

    // optional double transform_m11 = 6;

    pub fn transform_m11(&self) -> f64 {
        self.transform_m11.unwrap_or(0.)
    }

    pub fn clear_transform_m11(&mut self) {
        self.transform_m11 = ::std::option::Option::None;
    }

    pub fn has_transform_m11(&self) -> bool {
        self.transform_m11.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m11(&mut self, v: f64) {
        self.transform_m11 = ::std::option::Option::Some(v);
    }

    // optional double transform_m12 = 7;

    pub fn transform_m12(&self) -> f64 {
        self.transform_m12.unwrap_or(0.)
    }

    pub fn clear_transform_m12(&mut self) {
        self.transform_m12 = ::std::option::Option::None;
    }

    pub fn has_transform_m12(&self) -> bool {
        self.transform_m12.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m12(&mut self, v: f64) {
        self.transform_m12 = ::std::option::Option::Some(v);
    }

    // optional double transform_m13 = 8;

    pub fn transform_m13(&self) -> f64 {
        self.transform_m13.unwrap_or(0.)
    }

    pub fn clear_transform_m13(&mut self) {
        self.transform_m13 = ::std::option::Option::None;
    }

    pub fn has_transform_m13(&self) -> bool {
        self.transform_m13.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m13(&mut self, v: f64) {
        self.transform_m13 = ::std::option::Option::Some(v);
    }

    // optional double transform_m20 = 9;

    pub fn transform_m20(&self) -> f64 {
        self.transform_m20.unwrap_or(0.)
    }

    pub fn clear_transform_m20(&mut self) {
        self.transform_m20 = ::std::option::Option::None;
    }

    pub fn has_transform_m20(&self) -> bool {
        self.transform_m20.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m20(&mut self, v: f64) {
        self.transform_m20 = ::std::option::Option::Some(v);
    }

    // optional double transform_m21 = 10;

    pub fn transform_m21(&self) -> f64 {
        self.transform_m21.unwrap_or(0.)
    }

    pub fn clear_transform_m21(&mut self) {
        self.transform_m21 = ::std::option::Option::None;
    }

    pub fn has_transform_m21(&self) -> bool {
        self.transform_m21.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m21(&mut self, v: f64) {
        self.transform_m21 = ::std::option::Option::Some(v);
    }

    // optional double transform_m22 = 11;

    pub fn transform_m22(&self) -> f64 {
        self.transform_m22.unwrap_or(0.)
    }

    pub fn clear_transform_m22(&mut self) {
        self.transform_m22 = ::std::option::Option::None;
    }

    pub fn has_transform_m22(&self) -> bool {
        self.transform_m22.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m22(&mut self, v: f64) {
        self.transform_m22 = ::std::option::Option::Some(v);
    }

    // optional double transform_m23 = 12;

    pub fn transform_m23(&self) -> f64 {
        self.transform_m23.unwrap_or(0.)
    }

    pub fn clear_transform_m23(&mut self) {
        self.transform_m23 = ::std::option::Option::None;
    }

    pub fn has_transform_m23(&self) -> bool {
        self.transform_m23.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m23(&mut self, v: f64) {
        self.transform_m23 = ::std::option::Option::Some(v);
    }

    // optional double transform_m30 = 13;

    pub fn transform_m30(&self) -> f64 {
        self.transform_m30.unwrap_or(0.)
    }

    pub fn clear_transform_m30(&mut self) {
        self.transform_m30 = ::std::option::Option::None;
    }

    pub fn has_transform_m30(&self) -> bool {
        self.transform_m30.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m30(&mut self, v: f64) {
        self.transform_m30 = ::std::option::Option::Some(v);
    }

    // optional double transform_m31 = 14;

    pub fn transform_m31(&self) -> f64 {
        self.transform_m31.unwrap_or(0.)
    }

    pub fn clear_transform_m31(&mut self) {
        self.transform_m31 = ::std::option::Option::None;
    }

    pub fn has_transform_m31(&self) -> bool {
        self.transform_m31.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m31(&mut self, v: f64) {
        self.transform_m31 = ::std::option::Option::Some(v);
    }

    // optional double transform_m32 = 15;

    pub fn transform_m32(&self) -> f64 {
        self.transform_m32.unwrap_or(0.)
    }

    pub fn clear_transform_m32(&mut self) {
        self.transform_m32 = ::std::option::Option::None;
    }

    pub fn has_transform_m32(&self) -> bool {
        self.transform_m32.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m32(&mut self, v: f64) {
        self.transform_m32 = ::std::option::Option::Some(v);
    }

    // optional double transform_m33 = 16;

    pub fn transform_m33(&self) -> f64 {
        self.transform_m33.unwrap_or(0.)
    }

    pub fn clear_transform_m33(&mut self) {
        self.transform_m33 = ::std::option::Option::None;
    }

    pub fn has_transform_m33(&self) -> bool {
        self.transform_m33.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform_m33(&mut self, v: f64) {
        self.transform_m33 = ::std::option::Option::Some(v);
    }

    // optional double width = 18;

    pub fn width(&self) -> f64 {
        self.width.unwrap_or(0.)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: f64) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional double height = 19;

    pub fn height(&self) -> f64 {
        self.height.unwrap_or(0.)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: f64) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional double position_x = 20;

    pub fn position_x(&self) -> f64 {
        self.position_x.unwrap_or(0.)
    }

    pub fn clear_position_x(&mut self) {
        self.position_x = ::std::option::Option::None;
    }

    pub fn has_position_x(&self) -> bool {
        self.position_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position_x(&mut self, v: f64) {
        self.position_x = ::std::option::Option::Some(v);
    }

    // optional double position_y = 21;

    pub fn position_y(&self) -> f64 {
        self.position_y.unwrap_or(0.)
    }

    pub fn clear_position_y(&mut self) {
        self.position_y = ::std::option::Option::None;
    }

    pub fn has_position_y(&self) -> bool {
        self.position_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position_y(&mut self, v: f64) {
        self.position_y = ::std::option::Option::Some(v);
    }

    // optional double position_z = 22;

    pub fn position_z(&self) -> f64 {
        self.position_z.unwrap_or(0.)
    }

    pub fn clear_position_z(&mut self) {
        self.position_z = ::std::option::Option::None;
    }

    pub fn has_position_z(&self) -> bool {
        self.position_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position_z(&mut self, v: f64) {
        self.position_z = ::std::option::Option::Some(v);
    }

    // optional double scroll_x = 24;

    pub fn scroll_x(&self) -> f64 {
        self.scroll_x.unwrap_or(0.)
    }

    pub fn clear_scroll_x(&mut self) {
        self.scroll_x = ::std::option::Option::None;
    }

    pub fn has_scroll_x(&self) -> bool {
        self.scroll_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scroll_x(&mut self, v: f64) {
        self.scroll_x = ::std::option::Option::Some(v);
    }

    // optional double scroll_y = 25;

    pub fn scroll_y(&self) -> f64 {
        self.scroll_y.unwrap_or(0.)
    }

    pub fn clear_scroll_y(&mut self) {
        self.scroll_y = ::std::option::Option::None;
    }

    pub fn has_scroll_y(&self) -> bool {
        self.scroll_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scroll_y(&mut self, v: f64) {
        self.scroll_y = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(25);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transform_m00",
            |m: &CMsgPushPanelContextInLayer| { &m.transform_m00 },
            |m: &mut CMsgPushPanelContextInLayer| { &mut m.transform_m00 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transform_m01",
            |m: &CMsgPushPanelContextInLayer| { &m.transform_m01 },
            |m: &mut CMsgPushPanelContextInLayer| { &mut m.transform_m01 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transform_m02",
            |m: &CMsgPushPanelContextInLayer| { &m.transform_m02 },
            |m: &mut CMsgPushPanelContextInLayer| { &mut m.transform_m02 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transform_m03",
            |m: &CMsgPushPanelContextInLayer| { &m.transform_m03 },
            |m: &mut CMsgPushPanelContextInLayer| { &mut m.transform_m03 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transform_m10",
            |m: &CMsgPushPanelContextInLayer| { &m.transform_m10 },
            |m: &mut CMsgPushPanelContextInLayer| { &mut m.transform_m10 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transform_m11",
            |m: &CMsgPushPanelContextInLayer| { &m.transform_m11 },
            |m: &mut CMsgPushPanelContextInLayer| { &mut m.transform_m11 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transform_m12",
            |m: &CMsgPushPanelContextInLayer| { &m.transform_m12 },
            |m: &mut CMsgPushPanelContextInLayer| { &mut m.transform_m12 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transform_m13",
            |m: &CMsgPushPanelContextInLayer| { &m.transform_m13 },
            |m: &mut CMsgPushPanelContextInLayer| { &mut m.transform_m13 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transform_m20",
            |m: &CMsgPushPanelContextInLayer| { &m.transform_m20 },
            |m: &mut CMsgPushPanelContextInLayer| { &mut m.transform_m20 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transform_m21",
            |m: &CMsgPushPanelContextInLayer| { &m.transform_m21 },
            |m: &mut CMsgPushPanelContextInLayer| { &mut m.transform_m21 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transform_m22",
            |m: &CMsgPushPanelContextInLayer| { &m.transform_m22 },
            |m: &mut CMsgPushPanelContextInLayer| { &mut m.transform_m22 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transform_m23",
            |m: &CMsgPushPanelContextInLayer| { &m.transform_m23 },
            |m: &mut CMsgPushPanelContextInLayer| { &mut m.transform_m23 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transform_m30",
            |m: &CMsgPushPanelContextInLayer| { &m.transform_m30 },
            |m: &mut CMsgPushPanelContextInLayer| { &mut m.transform_m30 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transform_m31",
            |m: &CMsgPushPanelContextInLayer| { &m.transform_m31 },
            |m: &mut CMsgPushPanelContextInLayer| { &mut m.transform_m31 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transform_m32",
            |m: &CMsgPushPanelContextInLayer| { &m.transform_m32 },
            |m: &mut CMsgPushPanelContextInLayer| { &mut m.transform_m32 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transform_m33",
            |m: &CMsgPushPanelContextInLayer| { &m.transform_m33 },
            |m: &mut CMsgPushPanelContextInLayer| { &mut m.transform_m33 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CBoxShadowData>(
            "box_shadow",
            |m: &CMsgPushPanelContextInLayer| { &m.box_shadow },
            |m: &mut CMsgPushPanelContextInLayer| { &mut m.box_shadow },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &CMsgPushPanelContextInLayer| { &m.width },
            |m: &mut CMsgPushPanelContextInLayer| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &CMsgPushPanelContextInLayer| { &m.height },
            |m: &mut CMsgPushPanelContextInLayer| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "position_x",
            |m: &CMsgPushPanelContextInLayer| { &m.position_x },
            |m: &mut CMsgPushPanelContextInLayer| { &mut m.position_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "position_y",
            |m: &CMsgPushPanelContextInLayer| { &m.position_y },
            |m: &mut CMsgPushPanelContextInLayer| { &mut m.position_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "position_z",
            |m: &CMsgPushPanelContextInLayer| { &m.position_z },
            |m: &mut CMsgPushPanelContextInLayer| { &mut m.position_z },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CBorderData>(
            "border",
            |m: &CMsgPushPanelContextInLayer| { &m.border },
            |m: &mut CMsgPushPanelContextInLayer| { &mut m.border },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scroll_x",
            |m: &CMsgPushPanelContextInLayer| { &m.scroll_x },
            |m: &mut CMsgPushPanelContextInLayer| { &mut m.scroll_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scroll_y",
            |m: &CMsgPushPanelContextInLayer| { &m.scroll_y },
            |m: &mut CMsgPushPanelContextInLayer| { &mut m.scroll_y },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPushPanelContextInLayer>(
            "CMsgPushPanelContextInLayer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPushPanelContextInLayer {
    const NAME: &'static str = "CMsgPushPanelContextInLayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.transform_m00 = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.transform_m01 = ::std::option::Option::Some(is.read_double()?);
                },
                25 => {
                    self.transform_m02 = ::std::option::Option::Some(is.read_double()?);
                },
                33 => {
                    self.transform_m03 = ::std::option::Option::Some(is.read_double()?);
                },
                41 => {
                    self.transform_m10 = ::std::option::Option::Some(is.read_double()?);
                },
                49 => {
                    self.transform_m11 = ::std::option::Option::Some(is.read_double()?);
                },
                57 => {
                    self.transform_m12 = ::std::option::Option::Some(is.read_double()?);
                },
                65 => {
                    self.transform_m13 = ::std::option::Option::Some(is.read_double()?);
                },
                73 => {
                    self.transform_m20 = ::std::option::Option::Some(is.read_double()?);
                },
                81 => {
                    self.transform_m21 = ::std::option::Option::Some(is.read_double()?);
                },
                89 => {
                    self.transform_m22 = ::std::option::Option::Some(is.read_double()?);
                },
                97 => {
                    self.transform_m23 = ::std::option::Option::Some(is.read_double()?);
                },
                105 => {
                    self.transform_m30 = ::std::option::Option::Some(is.read_double()?);
                },
                113 => {
                    self.transform_m31 = ::std::option::Option::Some(is.read_double()?);
                },
                121 => {
                    self.transform_m32 = ::std::option::Option::Some(is.read_double()?);
                },
                129 => {
                    self.transform_m33 = ::std::option::Option::Some(is.read_double()?);
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.box_shadow)?;
                },
                145 => {
                    self.width = ::std::option::Option::Some(is.read_double()?);
                },
                153 => {
                    self.height = ::std::option::Option::Some(is.read_double()?);
                },
                161 => {
                    self.position_x = ::std::option::Option::Some(is.read_double()?);
                },
                169 => {
                    self.position_y = ::std::option::Option::Some(is.read_double()?);
                },
                177 => {
                    self.position_z = ::std::option::Option::Some(is.read_double()?);
                },
                186 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.border)?;
                },
                193 => {
                    self.scroll_x = ::std::option::Option::Some(is.read_double()?);
                },
                201 => {
                    self.scroll_y = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.transform_m00 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transform_m01 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transform_m02 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transform_m03 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transform_m10 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transform_m11 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transform_m12 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transform_m13 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transform_m20 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transform_m21 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transform_m22 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transform_m23 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transform_m30 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transform_m31 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transform_m32 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transform_m33 {
            my_size += 2 + 8;
        }
        if let Some(v) = self.box_shadow.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.width {
            my_size += 2 + 8;
        }
        if let Some(v) = self.height {
            my_size += 2 + 8;
        }
        if let Some(v) = self.position_x {
            my_size += 2 + 8;
        }
        if let Some(v) = self.position_y {
            my_size += 2 + 8;
        }
        if let Some(v) = self.position_z {
            my_size += 2 + 8;
        }
        if let Some(v) = self.border.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.scroll_x {
            my_size += 2 + 8;
        }
        if let Some(v) = self.scroll_y {
            my_size += 2 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.transform_m00 {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.transform_m01 {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.transform_m02 {
            os.write_double(3, v)?;
        }
        if let Some(v) = self.transform_m03 {
            os.write_double(4, v)?;
        }
        if let Some(v) = self.transform_m10 {
            os.write_double(5, v)?;
        }
        if let Some(v) = self.transform_m11 {
            os.write_double(6, v)?;
        }
        if let Some(v) = self.transform_m12 {
            os.write_double(7, v)?;
        }
        if let Some(v) = self.transform_m13 {
            os.write_double(8, v)?;
        }
        if let Some(v) = self.transform_m20 {
            os.write_double(9, v)?;
        }
        if let Some(v) = self.transform_m21 {
            os.write_double(10, v)?;
        }
        if let Some(v) = self.transform_m22 {
            os.write_double(11, v)?;
        }
        if let Some(v) = self.transform_m23 {
            os.write_double(12, v)?;
        }
        if let Some(v) = self.transform_m30 {
            os.write_double(13, v)?;
        }
        if let Some(v) = self.transform_m31 {
            os.write_double(14, v)?;
        }
        if let Some(v) = self.transform_m32 {
            os.write_double(15, v)?;
        }
        if let Some(v) = self.transform_m33 {
            os.write_double(16, v)?;
        }
        if let Some(v) = self.box_shadow.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.width {
            os.write_double(18, v)?;
        }
        if let Some(v) = self.height {
            os.write_double(19, v)?;
        }
        if let Some(v) = self.position_x {
            os.write_double(20, v)?;
        }
        if let Some(v) = self.position_y {
            os.write_double(21, v)?;
        }
        if let Some(v) = self.position_z {
            os.write_double(22, v)?;
        }
        if let Some(v) = self.border.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        }
        if let Some(v) = self.scroll_x {
            os.write_double(24, v)?;
        }
        if let Some(v) = self.scroll_y {
            os.write_double(25, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPushPanelContextInLayer {
        CMsgPushPanelContextInLayer::new()
    }

    fn clear(&mut self) {
        self.transform_m00 = ::std::option::Option::None;
        self.transform_m01 = ::std::option::Option::None;
        self.transform_m02 = ::std::option::Option::None;
        self.transform_m03 = ::std::option::Option::None;
        self.transform_m10 = ::std::option::Option::None;
        self.transform_m11 = ::std::option::Option::None;
        self.transform_m12 = ::std::option::Option::None;
        self.transform_m13 = ::std::option::Option::None;
        self.transform_m20 = ::std::option::Option::None;
        self.transform_m21 = ::std::option::Option::None;
        self.transform_m22 = ::std::option::Option::None;
        self.transform_m23 = ::std::option::Option::None;
        self.transform_m30 = ::std::option::Option::None;
        self.transform_m31 = ::std::option::Option::None;
        self.transform_m32 = ::std::option::Option::None;
        self.transform_m33 = ::std::option::Option::None;
        self.box_shadow.clear();
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.position_x = ::std::option::Option::None;
        self.position_y = ::std::option::Option::None;
        self.position_z = ::std::option::Option::None;
        self.border.clear();
        self.scroll_x = ::std::option::Option::None;
        self.scroll_y = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPushPanelContextInLayer {
        static instance: CMsgPushPanelContextInLayer = CMsgPushPanelContextInLayer {
            transform_m00: ::std::option::Option::None,
            transform_m01: ::std::option::Option::None,
            transform_m02: ::std::option::Option::None,
            transform_m03: ::std::option::Option::None,
            transform_m10: ::std::option::Option::None,
            transform_m11: ::std::option::Option::None,
            transform_m12: ::std::option::Option::None,
            transform_m13: ::std::option::Option::None,
            transform_m20: ::std::option::Option::None,
            transform_m21: ::std::option::Option::None,
            transform_m22: ::std::option::Option::None,
            transform_m23: ::std::option::Option::None,
            transform_m30: ::std::option::Option::None,
            transform_m31: ::std::option::Option::None,
            transform_m32: ::std::option::Option::None,
            transform_m33: ::std::option::Option::None,
            box_shadow: ::protobuf::MessageField::none(),
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            position_x: ::std::option::Option::None,
            position_y: ::std::option::Option::None,
            position_z: ::std::option::Option::None,
            border: ::protobuf::MessageField::none(),
            scroll_x: ::std::option::Option::None,
            scroll_y: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPushPanelContextInLayer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPushPanelContextInLayer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPushPanelContextInLayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPushPanelContextInLayer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPopPanelContextInLayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPopPanelContextInLayer {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPopPanelContextInLayer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPopPanelContextInLayer {
    fn default() -> &'a CMsgPopPanelContextInLayer {
        <CMsgPopPanelContextInLayer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPopPanelContextInLayer {
    pub fn new() -> CMsgPopPanelContextInLayer {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPopPanelContextInLayer>(
            "CMsgPopPanelContextInLayer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPopPanelContextInLayer {
    const NAME: &'static str = "CMsgPopPanelContextInLayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPopPanelContextInLayer {
        CMsgPopPanelContextInLayer::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPopPanelContextInLayer {
        static instance: CMsgPopPanelContextInLayer = CMsgPopPanelContextInLayer {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPopPanelContextInLayer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPopPanelContextInLayer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPopPanelContextInLayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPopPanelContextInLayer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPushAAndTContext)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPushAAndTContext {
    // message fields
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.context_id)
    pub context_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.width)
    pub width: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.height)
    pub height: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.chilren_have_3dtransforms)
    pub chilren_have_3dtransforms: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.zindex)
    pub zindex: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.panel_position)
    pub panel_position: ::protobuf::MessageField<CMsgPanelPosition>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.transform_matrix)
    pub transform_matrix: ::protobuf::MessageField<CMsg3DTransformMatrix>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.transform_origin)
    pub transform_origin: ::protobuf::MessageField<CMsg3DTransformOrigin>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.transform_perspective)
    pub transform_perspective: ::protobuf::MessageField<CMsg3DTransformPerspective>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.transform_perspective_origin)
    pub transform_perspective_origin: ::protobuf::MessageField<CMsg3DTransformPerspectiveOrigin>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.opacity)
    pub opacity: ::protobuf::MessageField<CMsgOpacity>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.wash_color)
    pub wash_color: ::protobuf::MessageField<CMsgColor>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.hue_shift)
    pub hue_shift: ::protobuf::MessageField<CMsgHueShift>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.saturation)
    pub saturation: ::protobuf::MessageField<CMsgSaturation>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.brightness)
    pub brightness: ::protobuf::MessageField<CMsgBrightness>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.contrast)
    pub contrast: ::protobuf::MessageField<CMsgContrast>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.opacity_mask)
    pub opacity_mask: ::protobuf::MessageField<CMsgOpacityMask>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.border_radius)
    pub border_radius: ::protobuf::MessageField<CMsgBorderRadius>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.gaussian_blur)
    pub gaussian_blur: ::protobuf::MessageField<CMsgGaussianBlur>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.border)
    pub border: ::protobuf::MessageField<CMsgBorder>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.box_shadow)
    pub box_shadow: ::protobuf::MessageField<CMsgBoxShadow>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.scale_2d_centered)
    pub scale_2d_centered: ::protobuf::MessageField<CMsgPointWithTransition>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.rotate_2d_centered)
    pub rotate_2d_centered: ::protobuf::MessageField<CMsgRotate2D>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.text_shadow)
    pub text_shadow: ::protobuf::MessageField<CMsgTextShadow>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.clip)
    pub clip: ::protobuf::MessageField<CMsgClip>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.suppress_clip_to_bounds)
    pub suppress_clip_to_bounds: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.needs_full_repaint)
    pub needs_full_repaint: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.needs_intermediate_texture)
    pub needs_intermediate_texture: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.clip_after_transform)
    pub clip_after_transform: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.wants_hit_test)
    pub wants_hit_test: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.wants_hit_test_children)
    pub wants_hit_test_children: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.mix_blend_mode)
    pub mix_blend_mode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.opaque_background)
    pub opaque_background: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.child_panel_count)
    pub child_panel_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.wants_screenspace_quad_output)
    pub wants_screenspace_quad_output: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.motion_blur)
    pub motion_blur: ::protobuf::MessageField<CMsgMotionBlur>,
    // @@protoc_insertion_point(field:CMsgPushAAndTContext.composition_layer_texture_name)
    pub composition_layer_texture_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPushAAndTContext.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPushAAndTContext {
    fn default() -> &'a CMsgPushAAndTContext {
        <CMsgPushAAndTContext as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPushAAndTContext {
    pub fn new() -> CMsgPushAAndTContext {
        ::std::default::Default::default()
    }

    // optional uint64 context_id = 1;

    pub fn context_id(&self) -> u64 {
        self.context_id.unwrap_or(0)
    }

    pub fn clear_context_id(&mut self) {
        self.context_id = ::std::option::Option::None;
    }

    pub fn has_context_id(&self) -> bool {
        self.context_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context_id(&mut self, v: u64) {
        self.context_id = ::std::option::Option::Some(v);
    }

    // optional double width = 3;

    pub fn width(&self) -> f64 {
        self.width.unwrap_or(0.)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: f64) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional double height = 4;

    pub fn height(&self) -> f64 {
        self.height.unwrap_or(0.)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: f64) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional bool chilren_have_3dtransforms = 5;

    pub fn chilren_have_3dtransforms(&self) -> bool {
        self.chilren_have_3dtransforms.unwrap_or(false)
    }

    pub fn clear_chilren_have_3dtransforms(&mut self) {
        self.chilren_have_3dtransforms = ::std::option::Option::None;
    }

    pub fn has_chilren_have_3dtransforms(&self) -> bool {
        self.chilren_have_3dtransforms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chilren_have_3dtransforms(&mut self, v: bool) {
        self.chilren_have_3dtransforms = ::std::option::Option::Some(v);
    }

    // optional float zindex = 6;

    pub fn zindex(&self) -> f32 {
        self.zindex.unwrap_or(0.)
    }

    pub fn clear_zindex(&mut self) {
        self.zindex = ::std::option::Option::None;
    }

    pub fn has_zindex(&self) -> bool {
        self.zindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zindex(&mut self, v: f32) {
        self.zindex = ::std::option::Option::Some(v);
    }

    // optional bool suppress_clip_to_bounds = 27;

    pub fn suppress_clip_to_bounds(&self) -> bool {
        self.suppress_clip_to_bounds.unwrap_or(false)
    }

    pub fn clear_suppress_clip_to_bounds(&mut self) {
        self.suppress_clip_to_bounds = ::std::option::Option::None;
    }

    pub fn has_suppress_clip_to_bounds(&self) -> bool {
        self.suppress_clip_to_bounds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suppress_clip_to_bounds(&mut self, v: bool) {
        self.suppress_clip_to_bounds = ::std::option::Option::Some(v);
    }

    // optional int32 needs_full_repaint = 28;

    pub fn needs_full_repaint(&self) -> i32 {
        self.needs_full_repaint.unwrap_or(0)
    }

    pub fn clear_needs_full_repaint(&mut self) {
        self.needs_full_repaint = ::std::option::Option::None;
    }

    pub fn has_needs_full_repaint(&self) -> bool {
        self.needs_full_repaint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needs_full_repaint(&mut self, v: i32) {
        self.needs_full_repaint = ::std::option::Option::Some(v);
    }

    // optional bool needs_intermediate_texture = 29;

    pub fn needs_intermediate_texture(&self) -> bool {
        self.needs_intermediate_texture.unwrap_or(false)
    }

    pub fn clear_needs_intermediate_texture(&mut self) {
        self.needs_intermediate_texture = ::std::option::Option::None;
    }

    pub fn has_needs_intermediate_texture(&self) -> bool {
        self.needs_intermediate_texture.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needs_intermediate_texture(&mut self, v: bool) {
        self.needs_intermediate_texture = ::std::option::Option::Some(v);
    }

    // optional bool clip_after_transform = 30;

    pub fn clip_after_transform(&self) -> bool {
        self.clip_after_transform.unwrap_or(false)
    }

    pub fn clear_clip_after_transform(&mut self) {
        self.clip_after_transform = ::std::option::Option::None;
    }

    pub fn has_clip_after_transform(&self) -> bool {
        self.clip_after_transform.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clip_after_transform(&mut self, v: bool) {
        self.clip_after_transform = ::std::option::Option::Some(v);
    }

    // optional bool wants_hit_test = 31;

    pub fn wants_hit_test(&self) -> bool {
        self.wants_hit_test.unwrap_or(false)
    }

    pub fn clear_wants_hit_test(&mut self) {
        self.wants_hit_test = ::std::option::Option::None;
    }

    pub fn has_wants_hit_test(&self) -> bool {
        self.wants_hit_test.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wants_hit_test(&mut self, v: bool) {
        self.wants_hit_test = ::std::option::Option::Some(v);
    }

    // optional bool wants_hit_test_children = 32;

    pub fn wants_hit_test_children(&self) -> bool {
        self.wants_hit_test_children.unwrap_or(false)
    }

    pub fn clear_wants_hit_test_children(&mut self) {
        self.wants_hit_test_children = ::std::option::Option::None;
    }

    pub fn has_wants_hit_test_children(&self) -> bool {
        self.wants_hit_test_children.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wants_hit_test_children(&mut self, v: bool) {
        self.wants_hit_test_children = ::std::option::Option::Some(v);
    }

    // optional uint32 mix_blend_mode = 33;

    pub fn mix_blend_mode(&self) -> u32 {
        self.mix_blend_mode.unwrap_or(0)
    }

    pub fn clear_mix_blend_mode(&mut self) {
        self.mix_blend_mode = ::std::option::Option::None;
    }

    pub fn has_mix_blend_mode(&self) -> bool {
        self.mix_blend_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mix_blend_mode(&mut self, v: u32) {
        self.mix_blend_mode = ::std::option::Option::Some(v);
    }

    // optional bool opaque_background = 34;

    pub fn opaque_background(&self) -> bool {
        self.opaque_background.unwrap_or(false)
    }

    pub fn clear_opaque_background(&mut self) {
        self.opaque_background = ::std::option::Option::None;
    }

    pub fn has_opaque_background(&self) -> bool {
        self.opaque_background.is_some()
    }

    // Param is passed by value, moved
    pub fn set_opaque_background(&mut self, v: bool) {
        self.opaque_background = ::std::option::Option::Some(v);
    }

    // optional uint32 child_panel_count = 35;

    pub fn child_panel_count(&self) -> u32 {
        self.child_panel_count.unwrap_or(0)
    }

    pub fn clear_child_panel_count(&mut self) {
        self.child_panel_count = ::std::option::Option::None;
    }

    pub fn has_child_panel_count(&self) -> bool {
        self.child_panel_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_child_panel_count(&mut self, v: u32) {
        self.child_panel_count = ::std::option::Option::Some(v);
    }

    // optional bool wants_screenspace_quad_output = 36;

    pub fn wants_screenspace_quad_output(&self) -> bool {
        self.wants_screenspace_quad_output.unwrap_or(false)
    }

    pub fn clear_wants_screenspace_quad_output(&mut self) {
        self.wants_screenspace_quad_output = ::std::option::Option::None;
    }

    pub fn has_wants_screenspace_quad_output(&self) -> bool {
        self.wants_screenspace_quad_output.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wants_screenspace_quad_output(&mut self, v: bool) {
        self.wants_screenspace_quad_output = ::std::option::Option::Some(v);
    }

    // optional string composition_layer_texture_name = 38;

    pub fn composition_layer_texture_name(&self) -> &str {
        match self.composition_layer_texture_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_composition_layer_texture_name(&mut self) {
        self.composition_layer_texture_name = ::std::option::Option::None;
    }

    pub fn has_composition_layer_texture_name(&self) -> bool {
        self.composition_layer_texture_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_composition_layer_texture_name(&mut self, v: ::std::string::String) {
        self.composition_layer_texture_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_composition_layer_texture_name(&mut self) -> &mut ::std::string::String {
        if self.composition_layer_texture_name.is_none() {
            self.composition_layer_texture_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.composition_layer_texture_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_composition_layer_texture_name(&mut self) -> ::std::string::String {
        self.composition_layer_texture_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(37);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "context_id",
            |m: &CMsgPushAAndTContext| { &m.context_id },
            |m: &mut CMsgPushAAndTContext| { &mut m.context_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &CMsgPushAAndTContext| { &m.width },
            |m: &mut CMsgPushAAndTContext| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &CMsgPushAAndTContext| { &m.height },
            |m: &mut CMsgPushAAndTContext| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chilren_have_3dtransforms",
            |m: &CMsgPushAAndTContext| { &m.chilren_have_3dtransforms },
            |m: &mut CMsgPushAAndTContext| { &mut m.chilren_have_3dtransforms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "zindex",
            |m: &CMsgPushAAndTContext| { &m.zindex },
            |m: &mut CMsgPushAAndTContext| { &mut m.zindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPanelPosition>(
            "panel_position",
            |m: &CMsgPushAAndTContext| { &m.panel_position },
            |m: &mut CMsgPushAAndTContext| { &mut m.panel_position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsg3DTransformMatrix>(
            "transform_matrix",
            |m: &CMsgPushAAndTContext| { &m.transform_matrix },
            |m: &mut CMsgPushAAndTContext| { &mut m.transform_matrix },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsg3DTransformOrigin>(
            "transform_origin",
            |m: &CMsgPushAAndTContext| { &m.transform_origin },
            |m: &mut CMsgPushAAndTContext| { &mut m.transform_origin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsg3DTransformPerspective>(
            "transform_perspective",
            |m: &CMsgPushAAndTContext| { &m.transform_perspective },
            |m: &mut CMsgPushAAndTContext| { &mut m.transform_perspective },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsg3DTransformPerspectiveOrigin>(
            "transform_perspective_origin",
            |m: &CMsgPushAAndTContext| { &m.transform_perspective_origin },
            |m: &mut CMsgPushAAndTContext| { &mut m.transform_perspective_origin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgOpacity>(
            "opacity",
            |m: &CMsgPushAAndTContext| { &m.opacity },
            |m: &mut CMsgPushAAndTContext| { &mut m.opacity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgColor>(
            "wash_color",
            |m: &CMsgPushAAndTContext| { &m.wash_color },
            |m: &mut CMsgPushAAndTContext| { &mut m.wash_color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgHueShift>(
            "hue_shift",
            |m: &CMsgPushAAndTContext| { &m.hue_shift },
            |m: &mut CMsgPushAAndTContext| { &mut m.hue_shift },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSaturation>(
            "saturation",
            |m: &CMsgPushAAndTContext| { &m.saturation },
            |m: &mut CMsgPushAAndTContext| { &mut m.saturation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgBrightness>(
            "brightness",
            |m: &CMsgPushAAndTContext| { &m.brightness },
            |m: &mut CMsgPushAAndTContext| { &mut m.brightness },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgContrast>(
            "contrast",
            |m: &CMsgPushAAndTContext| { &m.contrast },
            |m: &mut CMsgPushAAndTContext| { &mut m.contrast },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgOpacityMask>(
            "opacity_mask",
            |m: &CMsgPushAAndTContext| { &m.opacity_mask },
            |m: &mut CMsgPushAAndTContext| { &mut m.opacity_mask },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgBorderRadius>(
            "border_radius",
            |m: &CMsgPushAAndTContext| { &m.border_radius },
            |m: &mut CMsgPushAAndTContext| { &mut m.border_radius },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGaussianBlur>(
            "gaussian_blur",
            |m: &CMsgPushAAndTContext| { &m.gaussian_blur },
            |m: &mut CMsgPushAAndTContext| { &mut m.gaussian_blur },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgBorder>(
            "border",
            |m: &CMsgPushAAndTContext| { &m.border },
            |m: &mut CMsgPushAAndTContext| { &mut m.border },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgBoxShadow>(
            "box_shadow",
            |m: &CMsgPushAAndTContext| { &m.box_shadow },
            |m: &mut CMsgPushAAndTContext| { &mut m.box_shadow },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPointWithTransition>(
            "scale_2d_centered",
            |m: &CMsgPushAAndTContext| { &m.scale_2d_centered },
            |m: &mut CMsgPushAAndTContext| { &mut m.scale_2d_centered },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgRotate2D>(
            "rotate_2d_centered",
            |m: &CMsgPushAAndTContext| { &m.rotate_2d_centered },
            |m: &mut CMsgPushAAndTContext| { &mut m.rotate_2d_centered },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgTextShadow>(
            "text_shadow",
            |m: &CMsgPushAAndTContext| { &m.text_shadow },
            |m: &mut CMsgPushAAndTContext| { &mut m.text_shadow },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgClip>(
            "clip",
            |m: &CMsgPushAAndTContext| { &m.clip },
            |m: &mut CMsgPushAAndTContext| { &mut m.clip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "suppress_clip_to_bounds",
            |m: &CMsgPushAAndTContext| { &m.suppress_clip_to_bounds },
            |m: &mut CMsgPushAAndTContext| { &mut m.suppress_clip_to_bounds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "needs_full_repaint",
            |m: &CMsgPushAAndTContext| { &m.needs_full_repaint },
            |m: &mut CMsgPushAAndTContext| { &mut m.needs_full_repaint },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "needs_intermediate_texture",
            |m: &CMsgPushAAndTContext| { &m.needs_intermediate_texture },
            |m: &mut CMsgPushAAndTContext| { &mut m.needs_intermediate_texture },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "clip_after_transform",
            |m: &CMsgPushAAndTContext| { &m.clip_after_transform },
            |m: &mut CMsgPushAAndTContext| { &mut m.clip_after_transform },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "wants_hit_test",
            |m: &CMsgPushAAndTContext| { &m.wants_hit_test },
            |m: &mut CMsgPushAAndTContext| { &mut m.wants_hit_test },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "wants_hit_test_children",
            |m: &CMsgPushAAndTContext| { &m.wants_hit_test_children },
            |m: &mut CMsgPushAAndTContext| { &mut m.wants_hit_test_children },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mix_blend_mode",
            |m: &CMsgPushAAndTContext| { &m.mix_blend_mode },
            |m: &mut CMsgPushAAndTContext| { &mut m.mix_blend_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "opaque_background",
            |m: &CMsgPushAAndTContext| { &m.opaque_background },
            |m: &mut CMsgPushAAndTContext| { &mut m.opaque_background },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "child_panel_count",
            |m: &CMsgPushAAndTContext| { &m.child_panel_count },
            |m: &mut CMsgPushAAndTContext| { &mut m.child_panel_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "wants_screenspace_quad_output",
            |m: &CMsgPushAAndTContext| { &m.wants_screenspace_quad_output },
            |m: &mut CMsgPushAAndTContext| { &mut m.wants_screenspace_quad_output },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgMotionBlur>(
            "motion_blur",
            |m: &CMsgPushAAndTContext| { &m.motion_blur },
            |m: &mut CMsgPushAAndTContext| { &mut m.motion_blur },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "composition_layer_texture_name",
            |m: &CMsgPushAAndTContext| { &m.composition_layer_texture_name },
            |m: &mut CMsgPushAAndTContext| { &mut m.composition_layer_texture_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPushAAndTContext>(
            "CMsgPushAAndTContext",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPushAAndTContext {
    const NAME: &'static str = "CMsgPushAAndTContext";

    fn is_initialized(&self) -> bool {
        for v in &self.panel_position {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transform_matrix {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transform_origin {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transform_perspective {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transform_perspective_origin {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.opacity {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.wash_color {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.hue_shift {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.saturation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.brightness {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.contrast {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.opacity_mask {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.border_radius {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.gaussian_blur {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.border {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.box_shadow {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scale_2d_centered {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rotate_2d_centered {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.text_shadow {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.clip {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.motion_blur {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.context_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                25 => {
                    self.width = ::std::option::Option::Some(is.read_double()?);
                },
                33 => {
                    self.height = ::std::option::Option::Some(is.read_double()?);
                },
                40 => {
                    self.chilren_have_3dtransforms = ::std::option::Option::Some(is.read_bool()?);
                },
                53 => {
                    self.zindex = ::std::option::Option::Some(is.read_float()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.panel_position)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transform_matrix)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transform_origin)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transform_perspective)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transform_perspective_origin)?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.opacity)?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.wash_color)?;
                },
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.hue_shift)?;
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.saturation)?;
                },
                130 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.brightness)?;
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contrast)?;
                },
                146 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.opacity_mask)?;
                },
                154 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.border_radius)?;
                },
                162 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.gaussian_blur)?;
                },
                170 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.border)?;
                },
                178 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.box_shadow)?;
                },
                186 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.scale_2d_centered)?;
                },
                194 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rotate_2d_centered)?;
                },
                202 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.text_shadow)?;
                },
                210 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.clip)?;
                },
                216 => {
                    self.suppress_clip_to_bounds = ::std::option::Option::Some(is.read_bool()?);
                },
                224 => {
                    self.needs_full_repaint = ::std::option::Option::Some(is.read_int32()?);
                },
                232 => {
                    self.needs_intermediate_texture = ::std::option::Option::Some(is.read_bool()?);
                },
                240 => {
                    self.clip_after_transform = ::std::option::Option::Some(is.read_bool()?);
                },
                248 => {
                    self.wants_hit_test = ::std::option::Option::Some(is.read_bool()?);
                },
                256 => {
                    self.wants_hit_test_children = ::std::option::Option::Some(is.read_bool()?);
                },
                264 => {
                    self.mix_blend_mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                272 => {
                    self.opaque_background = ::std::option::Option::Some(is.read_bool()?);
                },
                280 => {
                    self.child_panel_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                288 => {
                    self.wants_screenspace_quad_output = ::std::option::Option::Some(is.read_bool()?);
                },
                298 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.motion_blur)?;
                },
                306 => {
                    self.composition_layer_texture_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.context_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.width {
            my_size += 1 + 8;
        }
        if let Some(v) = self.height {
            my_size += 1 + 8;
        }
        if let Some(v) = self.chilren_have_3dtransforms {
            my_size += 1 + 1;
        }
        if let Some(v) = self.zindex {
            my_size += 1 + 4;
        }
        if let Some(v) = self.panel_position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transform_matrix.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transform_origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transform_perspective.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transform_perspective_origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.opacity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.wash_color.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.hue_shift.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.saturation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.brightness.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.contrast.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.opacity_mask.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.border_radius.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.gaussian_blur.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.border.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.box_shadow.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.scale_2d_centered.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.rotate_2d_centered.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.text_shadow.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.clip.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.suppress_clip_to_bounds {
            my_size += 2 + 1;
        }
        if let Some(v) = self.needs_full_repaint {
            my_size += ::protobuf::rt::int32_size(28, v);
        }
        if let Some(v) = self.needs_intermediate_texture {
            my_size += 2 + 1;
        }
        if let Some(v) = self.clip_after_transform {
            my_size += 2 + 1;
        }
        if let Some(v) = self.wants_hit_test {
            my_size += 2 + 1;
        }
        if let Some(v) = self.wants_hit_test_children {
            my_size += 2 + 1;
        }
        if let Some(v) = self.mix_blend_mode {
            my_size += ::protobuf::rt::uint32_size(33, v);
        }
        if let Some(v) = self.opaque_background {
            my_size += 2 + 1;
        }
        if let Some(v) = self.child_panel_count {
            my_size += ::protobuf::rt::uint32_size(35, v);
        }
        if let Some(v) = self.wants_screenspace_quad_output {
            my_size += 2 + 1;
        }
        if let Some(v) = self.motion_blur.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.composition_layer_texture_name.as_ref() {
            my_size += ::protobuf::rt::string_size(38, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.context_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.width {
            os.write_double(3, v)?;
        }
        if let Some(v) = self.height {
            os.write_double(4, v)?;
        }
        if let Some(v) = self.chilren_have_3dtransforms {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.zindex {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.panel_position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.transform_matrix.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.transform_origin.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.transform_perspective.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.transform_perspective_origin.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.opacity.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.wash_color.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.hue_shift.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        if let Some(v) = self.saturation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.brightness.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if let Some(v) = self.contrast.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.opacity_mask.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        if let Some(v) = self.border_radius.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        }
        if let Some(v) = self.gaussian_blur.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        }
        if let Some(v) = self.border.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        }
        if let Some(v) = self.box_shadow.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        }
        if let Some(v) = self.scale_2d_centered.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        }
        if let Some(v) = self.rotate_2d_centered.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        if let Some(v) = self.text_shadow.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
        }
        if let Some(v) = self.clip.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
        }
        if let Some(v) = self.suppress_clip_to_bounds {
            os.write_bool(27, v)?;
        }
        if let Some(v) = self.needs_full_repaint {
            os.write_int32(28, v)?;
        }
        if let Some(v) = self.needs_intermediate_texture {
            os.write_bool(29, v)?;
        }
        if let Some(v) = self.clip_after_transform {
            os.write_bool(30, v)?;
        }
        if let Some(v) = self.wants_hit_test {
            os.write_bool(31, v)?;
        }
        if let Some(v) = self.wants_hit_test_children {
            os.write_bool(32, v)?;
        }
        if let Some(v) = self.mix_blend_mode {
            os.write_uint32(33, v)?;
        }
        if let Some(v) = self.opaque_background {
            os.write_bool(34, v)?;
        }
        if let Some(v) = self.child_panel_count {
            os.write_uint32(35, v)?;
        }
        if let Some(v) = self.wants_screenspace_quad_output {
            os.write_bool(36, v)?;
        }
        if let Some(v) = self.motion_blur.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(37, v, os)?;
        }
        if let Some(v) = self.composition_layer_texture_name.as_ref() {
            os.write_string(38, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPushAAndTContext {
        CMsgPushAAndTContext::new()
    }

    fn clear(&mut self) {
        self.context_id = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.chilren_have_3dtransforms = ::std::option::Option::None;
        self.zindex = ::std::option::Option::None;
        self.panel_position.clear();
        self.transform_matrix.clear();
        self.transform_origin.clear();
        self.transform_perspective.clear();
        self.transform_perspective_origin.clear();
        self.opacity.clear();
        self.wash_color.clear();
        self.hue_shift.clear();
        self.saturation.clear();
        self.brightness.clear();
        self.contrast.clear();
        self.opacity_mask.clear();
        self.border_radius.clear();
        self.gaussian_blur.clear();
        self.border.clear();
        self.box_shadow.clear();
        self.scale_2d_centered.clear();
        self.rotate_2d_centered.clear();
        self.text_shadow.clear();
        self.clip.clear();
        self.suppress_clip_to_bounds = ::std::option::Option::None;
        self.needs_full_repaint = ::std::option::Option::None;
        self.needs_intermediate_texture = ::std::option::Option::None;
        self.clip_after_transform = ::std::option::Option::None;
        self.wants_hit_test = ::std::option::Option::None;
        self.wants_hit_test_children = ::std::option::Option::None;
        self.mix_blend_mode = ::std::option::Option::None;
        self.opaque_background = ::std::option::Option::None;
        self.child_panel_count = ::std::option::Option::None;
        self.wants_screenspace_quad_output = ::std::option::Option::None;
        self.motion_blur.clear();
        self.composition_layer_texture_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPushAAndTContext {
        static instance: CMsgPushAAndTContext = CMsgPushAAndTContext {
            context_id: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            chilren_have_3dtransforms: ::std::option::Option::None,
            zindex: ::std::option::Option::None,
            panel_position: ::protobuf::MessageField::none(),
            transform_matrix: ::protobuf::MessageField::none(),
            transform_origin: ::protobuf::MessageField::none(),
            transform_perspective: ::protobuf::MessageField::none(),
            transform_perspective_origin: ::protobuf::MessageField::none(),
            opacity: ::protobuf::MessageField::none(),
            wash_color: ::protobuf::MessageField::none(),
            hue_shift: ::protobuf::MessageField::none(),
            saturation: ::protobuf::MessageField::none(),
            brightness: ::protobuf::MessageField::none(),
            contrast: ::protobuf::MessageField::none(),
            opacity_mask: ::protobuf::MessageField::none(),
            border_radius: ::protobuf::MessageField::none(),
            gaussian_blur: ::protobuf::MessageField::none(),
            border: ::protobuf::MessageField::none(),
            box_shadow: ::protobuf::MessageField::none(),
            scale_2d_centered: ::protobuf::MessageField::none(),
            rotate_2d_centered: ::protobuf::MessageField::none(),
            text_shadow: ::protobuf::MessageField::none(),
            clip: ::protobuf::MessageField::none(),
            suppress_clip_to_bounds: ::std::option::Option::None,
            needs_full_repaint: ::std::option::Option::None,
            needs_intermediate_texture: ::std::option::Option::None,
            clip_after_transform: ::std::option::Option::None,
            wants_hit_test: ::std::option::Option::None,
            wants_hit_test_children: ::std::option::Option::None,
            mix_blend_mode: ::std::option::Option::None,
            opaque_background: ::std::option::Option::None,
            child_panel_count: ::std::option::Option::None,
            wants_screenspace_quad_output: ::std::option::Option::None,
            motion_blur: ::protobuf::MessageField::none(),
            composition_layer_texture_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPushAAndTContext {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPushAAndTContext").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPushAAndTContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPushAAndTContext {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPopAAndTContext)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPopAAndTContext {
    // message fields
    // @@protoc_insertion_point(field:CMsgPopAAndTContext.context_id)
    pub context_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPopAAndTContext.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPopAAndTContext {
    fn default() -> &'a CMsgPopAAndTContext {
        <CMsgPopAAndTContext as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPopAAndTContext {
    pub fn new() -> CMsgPopAAndTContext {
        ::std::default::Default::default()
    }

    // optional uint64 context_id = 1;

    pub fn context_id(&self) -> u64 {
        self.context_id.unwrap_or(0)
    }

    pub fn clear_context_id(&mut self) {
        self.context_id = ::std::option::Option::None;
    }

    pub fn has_context_id(&self) -> bool {
        self.context_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context_id(&mut self, v: u64) {
        self.context_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "context_id",
            |m: &CMsgPopAAndTContext| { &m.context_id },
            |m: &mut CMsgPopAAndTContext| { &mut m.context_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPopAAndTContext>(
            "CMsgPopAAndTContext",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPopAAndTContext {
    const NAME: &'static str = "CMsgPopAAndTContext";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.context_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.context_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.context_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPopAAndTContext {
        CMsgPopAAndTContext::new()
    }

    fn clear(&mut self) {
        self.context_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPopAAndTContext {
        static instance: CMsgPopAAndTContext = CMsgPopAAndTContext {
            context_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPopAAndTContext {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPopAAndTContext").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPopAAndTContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPopAAndTContext {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgBeginPaintBackground)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBeginPaintBackground {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBeginPaintBackground.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBeginPaintBackground {
    fn default() -> &'a CMsgBeginPaintBackground {
        <CMsgBeginPaintBackground as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBeginPaintBackground {
    pub fn new() -> CMsgBeginPaintBackground {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBeginPaintBackground>(
            "CMsgBeginPaintBackground",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgBeginPaintBackground {
    const NAME: &'static str = "CMsgBeginPaintBackground";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBeginPaintBackground {
        CMsgBeginPaintBackground::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBeginPaintBackground {
        static instance: CMsgBeginPaintBackground = CMsgBeginPaintBackground {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgBeginPaintBackground {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBeginPaintBackground").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBeginPaintBackground {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBeginPaintBackground {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgEndPaintBackground)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgEndPaintBackground {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgEndPaintBackground.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgEndPaintBackground {
    fn default() -> &'a CMsgEndPaintBackground {
        <CMsgEndPaintBackground as ::protobuf::Message>::default_instance()
    }
}

impl CMsgEndPaintBackground {
    pub fn new() -> CMsgEndPaintBackground {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgEndPaintBackground>(
            "CMsgEndPaintBackground",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgEndPaintBackground {
    const NAME: &'static str = "CMsgEndPaintBackground";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgEndPaintBackground {
        CMsgEndPaintBackground::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgEndPaintBackground {
        static instance: CMsgEndPaintBackground = CMsgEndPaintBackground {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgEndPaintBackground {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgEndPaintBackground").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgEndPaintBackground {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgEndPaintBackground {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgBeginPaintLast)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBeginPaintLast {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBeginPaintLast.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBeginPaintLast {
    fn default() -> &'a CMsgBeginPaintLast {
        <CMsgBeginPaintLast as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBeginPaintLast {
    pub fn new() -> CMsgBeginPaintLast {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBeginPaintLast>(
            "CMsgBeginPaintLast",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgBeginPaintLast {
    const NAME: &'static str = "CMsgBeginPaintLast";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBeginPaintLast {
        CMsgBeginPaintLast::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBeginPaintLast {
        static instance: CMsgBeginPaintLast = CMsgBeginPaintLast {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgBeginPaintLast {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBeginPaintLast").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBeginPaintLast {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBeginPaintLast {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgEndPaintLast)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgEndPaintLast {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgEndPaintLast.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgEndPaintLast {
    fn default() -> &'a CMsgEndPaintLast {
        <CMsgEndPaintLast as ::protobuf::Message>::default_instance()
    }
}

impl CMsgEndPaintLast {
    pub fn new() -> CMsgEndPaintLast {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgEndPaintLast>(
            "CMsgEndPaintLast",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgEndPaintLast {
    const NAME: &'static str = "CMsgEndPaintLast";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgEndPaintLast {
        CMsgEndPaintLast::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgEndPaintLast {
        static instance: CMsgEndPaintLast = CMsgEndPaintLast {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgEndPaintLast {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgEndPaintLast").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgEndPaintLast {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgEndPaintLast {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgDrawFilledRect)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDrawFilledRect {
    // message fields
    // @@protoc_insertion_point(field:CMsgDrawFilledRect.top_left)
    pub top_left: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgDrawFilledRect.bottom_right)
    pub bottom_right: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgDrawFilledRect.fill_brush_collection)
    pub fill_brush_collection: ::protobuf::MessageField<CMsgFillBrushCollection>,
    // @@protoc_insertion_point(field:CMsgDrawFilledRect.antialiasing)
    pub antialiasing: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDrawFilledRect.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDrawFilledRect {
    fn default() -> &'a CMsgDrawFilledRect {
        <CMsgDrawFilledRect as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDrawFilledRect {
    pub fn new() -> CMsgDrawFilledRect {
        ::std::default::Default::default()
    }

    // optional uint32 antialiasing = 4;

    pub fn antialiasing(&self) -> u32 {
        self.antialiasing.unwrap_or(0)
    }

    pub fn clear_antialiasing(&mut self) {
        self.antialiasing = ::std::option::Option::None;
    }

    pub fn has_antialiasing(&self) -> bool {
        self.antialiasing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_antialiasing(&mut self, v: u32) {
        self.antialiasing = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "top_left",
            |m: &CMsgDrawFilledRect| { &m.top_left },
            |m: &mut CMsgDrawFilledRect| { &mut m.top_left },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "bottom_right",
            |m: &CMsgDrawFilledRect| { &m.bottom_right },
            |m: &mut CMsgDrawFilledRect| { &mut m.bottom_right },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgFillBrushCollection>(
            "fill_brush_collection",
            |m: &CMsgDrawFilledRect| { &m.fill_brush_collection },
            |m: &mut CMsgDrawFilledRect| { &mut m.fill_brush_collection },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "antialiasing",
            |m: &CMsgDrawFilledRect| { &m.antialiasing },
            |m: &mut CMsgDrawFilledRect| { &mut m.antialiasing },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDrawFilledRect>(
            "CMsgDrawFilledRect",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDrawFilledRect {
    const NAME: &'static str = "CMsgDrawFilledRect";

    fn is_initialized(&self) -> bool {
        for v in &self.top_left {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bottom_right {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fill_brush_collection {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.top_left)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bottom_right)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fill_brush_collection)?;
                },
                32 => {
                    self.antialiasing = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.top_left.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bottom_right.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.fill_brush_collection.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.antialiasing {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.top_left.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.bottom_right.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.fill_brush_collection.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.antialiasing {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDrawFilledRect {
        CMsgDrawFilledRect::new()
    }

    fn clear(&mut self) {
        self.top_left.clear();
        self.bottom_right.clear();
        self.fill_brush_collection.clear();
        self.antialiasing = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDrawFilledRect {
        static instance: CMsgDrawFilledRect = CMsgDrawFilledRect {
            top_left: ::protobuf::MessageField::none(),
            bottom_right: ::protobuf::MessageField::none(),
            fill_brush_collection: ::protobuf::MessageField::none(),
            antialiasing: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDrawFilledRect {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDrawFilledRect").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDrawFilledRect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDrawFilledRect {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgRenderFilledRect)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRenderFilledRect {
    // message fields
    // @@protoc_insertion_point(field:CMsgRenderFilledRect.top_left)
    pub top_left: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgRenderFilledRect.bottom_right)
    pub bottom_right: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgRenderFilledRect.fill_brush_collection)
    pub fill_brush_collection: ::protobuf::MessageField<CMsgRenderFillBrushCollection>,
    // @@protoc_insertion_point(field:CMsgRenderFilledRect.antialiasing)
    pub antialiasing: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRenderFilledRect.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRenderFilledRect {
    fn default() -> &'a CMsgRenderFilledRect {
        <CMsgRenderFilledRect as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRenderFilledRect {
    pub fn new() -> CMsgRenderFilledRect {
        ::std::default::Default::default()
    }

    // optional uint32 antialiasing = 4;

    pub fn antialiasing(&self) -> u32 {
        self.antialiasing.unwrap_or(0)
    }

    pub fn clear_antialiasing(&mut self) {
        self.antialiasing = ::std::option::Option::None;
    }

    pub fn has_antialiasing(&self) -> bool {
        self.antialiasing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_antialiasing(&mut self, v: u32) {
        self.antialiasing = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "top_left",
            |m: &CMsgRenderFilledRect| { &m.top_left },
            |m: &mut CMsgRenderFilledRect| { &mut m.top_left },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "bottom_right",
            |m: &CMsgRenderFilledRect| { &m.bottom_right },
            |m: &mut CMsgRenderFilledRect| { &mut m.bottom_right },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgRenderFillBrushCollection>(
            "fill_brush_collection",
            |m: &CMsgRenderFilledRect| { &m.fill_brush_collection },
            |m: &mut CMsgRenderFilledRect| { &mut m.fill_brush_collection },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "antialiasing",
            |m: &CMsgRenderFilledRect| { &m.antialiasing },
            |m: &mut CMsgRenderFilledRect| { &mut m.antialiasing },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRenderFilledRect>(
            "CMsgRenderFilledRect",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRenderFilledRect {
    const NAME: &'static str = "CMsgRenderFilledRect";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.top_left)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bottom_right)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fill_brush_collection)?;
                },
                32 => {
                    self.antialiasing = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.top_left.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bottom_right.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.fill_brush_collection.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.antialiasing {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.top_left.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.bottom_right.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.fill_brush_collection.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.antialiasing {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRenderFilledRect {
        CMsgRenderFilledRect::new()
    }

    fn clear(&mut self) {
        self.top_left.clear();
        self.bottom_right.clear();
        self.fill_brush_collection.clear();
        self.antialiasing = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRenderFilledRect {
        static instance: CMsgRenderFilledRect = CMsgRenderFilledRect {
            top_left: ::protobuf::MessageField::none(),
            bottom_right: ::protobuf::MessageField::none(),
            fill_brush_collection: ::protobuf::MessageField::none(),
            antialiasing: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRenderFilledRect {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRenderFilledRect").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRenderFilledRect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRenderFilledRect {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgDrawTexturedRect)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDrawTexturedRect {
    // message fields
    // @@protoc_insertion_point(field:CMsgDrawTexturedRect.top_left)
    pub top_left: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgDrawTexturedRect.bottom_right)
    pub bottom_right: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgDrawTexturedRect.texture_id)
    pub texture_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDrawTexturedRect.texture_top_left)
    pub texture_top_left: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgDrawTexturedRect.texture_bottom_right)
    pub texture_bottom_right: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgDrawTexturedRect.texture_serial)
    pub texture_serial: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgDrawTexturedRect.texture_sample_mode)
    pub texture_sample_mode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDrawTexturedRect.texture_opacity)
    pub texture_opacity: ::protobuf::MessageField<CMsgOpacity>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDrawTexturedRect.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDrawTexturedRect {
    fn default() -> &'a CMsgDrawTexturedRect {
        <CMsgDrawTexturedRect as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDrawTexturedRect {
    pub fn new() -> CMsgDrawTexturedRect {
        ::std::default::Default::default()
    }

    // optional uint32 texture_id = 3;

    pub fn texture_id(&self) -> u32 {
        self.texture_id.unwrap_or(0)
    }

    pub fn clear_texture_id(&mut self) {
        self.texture_id = ::std::option::Option::None;
    }

    pub fn has_texture_id(&self) -> bool {
        self.texture_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_texture_id(&mut self, v: u32) {
        self.texture_id = ::std::option::Option::Some(v);
    }

    // optional int32 texture_serial = 6;

    pub fn texture_serial(&self) -> i32 {
        self.texture_serial.unwrap_or(0i32)
    }

    pub fn clear_texture_serial(&mut self) {
        self.texture_serial = ::std::option::Option::None;
    }

    pub fn has_texture_serial(&self) -> bool {
        self.texture_serial.is_some()
    }

    // Param is passed by value, moved
    pub fn set_texture_serial(&mut self, v: i32) {
        self.texture_serial = ::std::option::Option::Some(v);
    }

    // optional uint32 texture_sample_mode = 7;

    pub fn texture_sample_mode(&self) -> u32 {
        self.texture_sample_mode.unwrap_or(0u32)
    }

    pub fn clear_texture_sample_mode(&mut self) {
        self.texture_sample_mode = ::std::option::Option::None;
    }

    pub fn has_texture_sample_mode(&self) -> bool {
        self.texture_sample_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_texture_sample_mode(&mut self, v: u32) {
        self.texture_sample_mode = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "top_left",
            |m: &CMsgDrawTexturedRect| { &m.top_left },
            |m: &mut CMsgDrawTexturedRect| { &mut m.top_left },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "bottom_right",
            |m: &CMsgDrawTexturedRect| { &m.bottom_right },
            |m: &mut CMsgDrawTexturedRect| { &mut m.bottom_right },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "texture_id",
            |m: &CMsgDrawTexturedRect| { &m.texture_id },
            |m: &mut CMsgDrawTexturedRect| { &mut m.texture_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "texture_top_left",
            |m: &CMsgDrawTexturedRect| { &m.texture_top_left },
            |m: &mut CMsgDrawTexturedRect| { &mut m.texture_top_left },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "texture_bottom_right",
            |m: &CMsgDrawTexturedRect| { &m.texture_bottom_right },
            |m: &mut CMsgDrawTexturedRect| { &mut m.texture_bottom_right },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "texture_serial",
            |m: &CMsgDrawTexturedRect| { &m.texture_serial },
            |m: &mut CMsgDrawTexturedRect| { &mut m.texture_serial },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "texture_sample_mode",
            |m: &CMsgDrawTexturedRect| { &m.texture_sample_mode },
            |m: &mut CMsgDrawTexturedRect| { &mut m.texture_sample_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgOpacity>(
            "texture_opacity",
            |m: &CMsgDrawTexturedRect| { &m.texture_opacity },
            |m: &mut CMsgDrawTexturedRect| { &mut m.texture_opacity },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDrawTexturedRect>(
            "CMsgDrawTexturedRect",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDrawTexturedRect {
    const NAME: &'static str = "CMsgDrawTexturedRect";

    fn is_initialized(&self) -> bool {
        for v in &self.top_left {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bottom_right {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.texture_top_left {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.texture_bottom_right {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.texture_opacity {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.top_left)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bottom_right)?;
                },
                24 => {
                    self.texture_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.texture_top_left)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.texture_bottom_right)?;
                },
                48 => {
                    self.texture_serial = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.texture_sample_mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.texture_opacity)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.top_left.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bottom_right.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.texture_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.texture_top_left.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.texture_bottom_right.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.texture_serial {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.texture_sample_mode {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.texture_opacity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.top_left.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.bottom_right.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.texture_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.texture_top_left.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.texture_bottom_right.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.texture_serial {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.texture_sample_mode {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.texture_opacity.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDrawTexturedRect {
        CMsgDrawTexturedRect::new()
    }

    fn clear(&mut self) {
        self.top_left.clear();
        self.bottom_right.clear();
        self.texture_id = ::std::option::Option::None;
        self.texture_top_left.clear();
        self.texture_bottom_right.clear();
        self.texture_serial = ::std::option::Option::None;
        self.texture_sample_mode = ::std::option::Option::None;
        self.texture_opacity.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDrawTexturedRect {
        static instance: CMsgDrawTexturedRect = CMsgDrawTexturedRect {
            top_left: ::protobuf::MessageField::none(),
            bottom_right: ::protobuf::MessageField::none(),
            texture_id: ::std::option::Option::None,
            texture_top_left: ::protobuf::MessageField::none(),
            texture_bottom_right: ::protobuf::MessageField::none(),
            texture_serial: ::std::option::Option::None,
            texture_sample_mode: ::std::option::Option::None,
            texture_opacity: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDrawTexturedRect {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDrawTexturedRect").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDrawTexturedRect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDrawTexturedRect {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgRenderTexturedRect)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRenderTexturedRect {
    // message fields
    // @@protoc_insertion_point(field:CMsgRenderTexturedRect.top_left)
    pub top_left: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgRenderTexturedRect.bottom_right)
    pub bottom_right: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgRenderTexturedRect.texture_id)
    pub texture_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRenderTexturedRect.texture_top_left)
    pub texture_top_left: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgRenderTexturedRect.texture_bottom_right)
    pub texture_bottom_right: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgRenderTexturedRect.texture_serial)
    pub texture_serial: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRenderTexturedRect.texture_sample_mode)
    pub texture_sample_mode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRenderTexturedRect.texture_opacity)
    pub texture_opacity: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRenderTexturedRect.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRenderTexturedRect {
    fn default() -> &'a CMsgRenderTexturedRect {
        <CMsgRenderTexturedRect as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRenderTexturedRect {
    pub fn new() -> CMsgRenderTexturedRect {
        ::std::default::Default::default()
    }

    // optional uint32 texture_id = 3;

    pub fn texture_id(&self) -> u32 {
        self.texture_id.unwrap_or(0)
    }

    pub fn clear_texture_id(&mut self) {
        self.texture_id = ::std::option::Option::None;
    }

    pub fn has_texture_id(&self) -> bool {
        self.texture_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_texture_id(&mut self, v: u32) {
        self.texture_id = ::std::option::Option::Some(v);
    }

    // optional int32 texture_serial = 6;

    pub fn texture_serial(&self) -> i32 {
        self.texture_serial.unwrap_or(0i32)
    }

    pub fn clear_texture_serial(&mut self) {
        self.texture_serial = ::std::option::Option::None;
    }

    pub fn has_texture_serial(&self) -> bool {
        self.texture_serial.is_some()
    }

    // Param is passed by value, moved
    pub fn set_texture_serial(&mut self, v: i32) {
        self.texture_serial = ::std::option::Option::Some(v);
    }

    // optional uint32 texture_sample_mode = 7;

    pub fn texture_sample_mode(&self) -> u32 {
        self.texture_sample_mode.unwrap_or(0u32)
    }

    pub fn clear_texture_sample_mode(&mut self) {
        self.texture_sample_mode = ::std::option::Option::None;
    }

    pub fn has_texture_sample_mode(&self) -> bool {
        self.texture_sample_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_texture_sample_mode(&mut self, v: u32) {
        self.texture_sample_mode = ::std::option::Option::Some(v);
    }

    // optional float texture_opacity = 8;

    pub fn texture_opacity(&self) -> f32 {
        self.texture_opacity.unwrap_or(1.0f32)
    }

    pub fn clear_texture_opacity(&mut self) {
        self.texture_opacity = ::std::option::Option::None;
    }

    pub fn has_texture_opacity(&self) -> bool {
        self.texture_opacity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_texture_opacity(&mut self, v: f32) {
        self.texture_opacity = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "top_left",
            |m: &CMsgRenderTexturedRect| { &m.top_left },
            |m: &mut CMsgRenderTexturedRect| { &mut m.top_left },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "bottom_right",
            |m: &CMsgRenderTexturedRect| { &m.bottom_right },
            |m: &mut CMsgRenderTexturedRect| { &mut m.bottom_right },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "texture_id",
            |m: &CMsgRenderTexturedRect| { &m.texture_id },
            |m: &mut CMsgRenderTexturedRect| { &mut m.texture_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "texture_top_left",
            |m: &CMsgRenderTexturedRect| { &m.texture_top_left },
            |m: &mut CMsgRenderTexturedRect| { &mut m.texture_top_left },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "texture_bottom_right",
            |m: &CMsgRenderTexturedRect| { &m.texture_bottom_right },
            |m: &mut CMsgRenderTexturedRect| { &mut m.texture_bottom_right },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "texture_serial",
            |m: &CMsgRenderTexturedRect| { &m.texture_serial },
            |m: &mut CMsgRenderTexturedRect| { &mut m.texture_serial },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "texture_sample_mode",
            |m: &CMsgRenderTexturedRect| { &m.texture_sample_mode },
            |m: &mut CMsgRenderTexturedRect| { &mut m.texture_sample_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "texture_opacity",
            |m: &CMsgRenderTexturedRect| { &m.texture_opacity },
            |m: &mut CMsgRenderTexturedRect| { &mut m.texture_opacity },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRenderTexturedRect>(
            "CMsgRenderTexturedRect",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRenderTexturedRect {
    const NAME: &'static str = "CMsgRenderTexturedRect";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.top_left)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bottom_right)?;
                },
                24 => {
                    self.texture_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.texture_top_left)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.texture_bottom_right)?;
                },
                48 => {
                    self.texture_serial = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.texture_sample_mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                69 => {
                    self.texture_opacity = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.top_left.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bottom_right.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.texture_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.texture_top_left.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.texture_bottom_right.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.texture_serial {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.texture_sample_mode {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.texture_opacity {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.top_left.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.bottom_right.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.texture_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.texture_top_left.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.texture_bottom_right.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.texture_serial {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.texture_sample_mode {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.texture_opacity {
            os.write_float(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRenderTexturedRect {
        CMsgRenderTexturedRect::new()
    }

    fn clear(&mut self) {
        self.top_left.clear();
        self.bottom_right.clear();
        self.texture_id = ::std::option::Option::None;
        self.texture_top_left.clear();
        self.texture_bottom_right.clear();
        self.texture_serial = ::std::option::Option::None;
        self.texture_sample_mode = ::std::option::Option::None;
        self.texture_opacity = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRenderTexturedRect {
        static instance: CMsgRenderTexturedRect = CMsgRenderTexturedRect {
            top_left: ::protobuf::MessageField::none(),
            bottom_right: ::protobuf::MessageField::none(),
            texture_id: ::std::option::Option::None,
            texture_top_left: ::protobuf::MessageField::none(),
            texture_bottom_right: ::protobuf::MessageField::none(),
            texture_serial: ::std::option::Option::None,
            texture_sample_mode: ::std::option::Option::None,
            texture_opacity: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRenderTexturedRect {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRenderTexturedRect").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRenderTexturedRect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRenderTexturedRect {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgLockTexture)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLockTexture {
    // message fields
    // @@protoc_insertion_point(field:CMsgLockTexture.texture_id)
    pub texture_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLockTexture.texture_serial)
    pub texture_serial: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLockTexture.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLockTexture {
    fn default() -> &'a CMsgLockTexture {
        <CMsgLockTexture as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLockTexture {
    pub fn new() -> CMsgLockTexture {
        ::std::default::Default::default()
    }

    // optional uint32 texture_id = 1;

    pub fn texture_id(&self) -> u32 {
        self.texture_id.unwrap_or(0)
    }

    pub fn clear_texture_id(&mut self) {
        self.texture_id = ::std::option::Option::None;
    }

    pub fn has_texture_id(&self) -> bool {
        self.texture_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_texture_id(&mut self, v: u32) {
        self.texture_id = ::std::option::Option::Some(v);
    }

    // optional int32 texture_serial = 2;

    pub fn texture_serial(&self) -> i32 {
        self.texture_serial.unwrap_or(0i32)
    }

    pub fn clear_texture_serial(&mut self) {
        self.texture_serial = ::std::option::Option::None;
    }

    pub fn has_texture_serial(&self) -> bool {
        self.texture_serial.is_some()
    }

    // Param is passed by value, moved
    pub fn set_texture_serial(&mut self, v: i32) {
        self.texture_serial = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "texture_id",
            |m: &CMsgLockTexture| { &m.texture_id },
            |m: &mut CMsgLockTexture| { &mut m.texture_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "texture_serial",
            |m: &CMsgLockTexture| { &m.texture_serial },
            |m: &mut CMsgLockTexture| { &mut m.texture_serial },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLockTexture>(
            "CMsgLockTexture",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgLockTexture {
    const NAME: &'static str = "CMsgLockTexture";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.texture_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.texture_serial = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.texture_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.texture_serial {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.texture_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.texture_serial {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLockTexture {
        CMsgLockTexture::new()
    }

    fn clear(&mut self) {
        self.texture_id = ::std::option::Option::None;
        self.texture_serial = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLockTexture {
        static instance: CMsgLockTexture = CMsgLockTexture {
            texture_id: ::std::option::Option::None,
            texture_serial: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgLockTexture {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLockTexture").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLockTexture {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLockTexture {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTextInlineObject)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTextInlineObject {
    // message fields
    // @@protoc_insertion_point(field:CMsgTextInlineObject.width)
    pub width: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTextInlineObject.height)
    pub height: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTextInlineObject.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTextInlineObject {
    fn default() -> &'a CMsgTextInlineObject {
        <CMsgTextInlineObject as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTextInlineObject {
    pub fn new() -> CMsgTextInlineObject {
        ::std::default::Default::default()
    }

    // optional float width = 1;

    pub fn width(&self) -> f32 {
        self.width.unwrap_or(0.)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: f32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional float height = 2;

    pub fn height(&self) -> f32 {
        self.height.unwrap_or(0.)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: f32) {
        self.height = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &CMsgTextInlineObject| { &m.width },
            |m: &mut CMsgTextInlineObject| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &CMsgTextInlineObject| { &m.height },
            |m: &mut CMsgTextInlineObject| { &mut m.height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTextInlineObject>(
            "CMsgTextInlineObject",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTextInlineObject {
    const NAME: &'static str = "CMsgTextInlineObject";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.width = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.height = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.width {
            my_size += 1 + 4;
        }
        if let Some(v) = self.height {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.width {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.height {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTextInlineObject {
        CMsgTextInlineObject::new()
    }

    fn clear(&mut self) {
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTextInlineObject {
        static instance: CMsgTextInlineObject = CMsgTextInlineObject {
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTextInlineObject {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTextInlineObject").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTextInlineObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTextInlineObject {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTextFormat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTextFormat {
    // message fields
    // @@protoc_insertion_point(field:CMsgTextFormat.font_name)
    pub font_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgTextFormat.font_size)
    pub font_size: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgTextFormat.font_weight)
    pub font_weight: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgTextFormat.font_style)
    pub font_style: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgTextFormat.underline)
    pub underline: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgTextFormat.strikethrough)
    pub strikethrough: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgTextFormat.fill_brush_collection)
    pub fill_brush_collection: ::protobuf::MessageField<CMsgFillBrushCollection>,
    // @@protoc_insertion_point(field:CMsgTextFormat.letter_spacing)
    pub letter_spacing: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgTextFormat.inline_object)
    pub inline_object: ::protobuf::MessageField<CMsgTextInlineObject>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTextFormat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTextFormat {
    fn default() -> &'a CMsgTextFormat {
        <CMsgTextFormat as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTextFormat {
    pub fn new() -> CMsgTextFormat {
        ::std::default::Default::default()
    }

    // optional string font_name = 1;

    pub fn font_name(&self) -> &str {
        match self.font_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_font_name(&mut self) {
        self.font_name = ::std::option::Option::None;
    }

    pub fn has_font_name(&self) -> bool {
        self.font_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_font_name(&mut self, v: ::std::string::String) {
        self.font_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_font_name(&mut self) -> &mut ::std::string::String {
        if self.font_name.is_none() {
            self.font_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.font_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_font_name(&mut self) -> ::std::string::String {
        self.font_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional double font_size = 2;

    pub fn font_size(&self) -> f64 {
        self.font_size.unwrap_or(0.)
    }

    pub fn clear_font_size(&mut self) {
        self.font_size = ::std::option::Option::None;
    }

    pub fn has_font_size(&self) -> bool {
        self.font_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_font_size(&mut self, v: f64) {
        self.font_size = ::std::option::Option::Some(v);
    }

    // optional int32 font_weight = 3;

    pub fn font_weight(&self) -> i32 {
        self.font_weight.unwrap_or(-1i32)
    }

    pub fn clear_font_weight(&mut self) {
        self.font_weight = ::std::option::Option::None;
    }

    pub fn has_font_weight(&self) -> bool {
        self.font_weight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_font_weight(&mut self, v: i32) {
        self.font_weight = ::std::option::Option::Some(v);
    }

    // optional int32 font_style = 4;

    pub fn font_style(&self) -> i32 {
        self.font_style.unwrap_or(-1i32)
    }

    pub fn clear_font_style(&mut self) {
        self.font_style = ::std::option::Option::None;
    }

    pub fn has_font_style(&self) -> bool {
        self.font_style.is_some()
    }

    // Param is passed by value, moved
    pub fn set_font_style(&mut self, v: i32) {
        self.font_style = ::std::option::Option::Some(v);
    }

    // optional bool underline = 5;

    pub fn underline(&self) -> bool {
        self.underline.unwrap_or(false)
    }

    pub fn clear_underline(&mut self) {
        self.underline = ::std::option::Option::None;
    }

    pub fn has_underline(&self) -> bool {
        self.underline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_underline(&mut self, v: bool) {
        self.underline = ::std::option::Option::Some(v);
    }

    // optional bool strikethrough = 6;

    pub fn strikethrough(&self) -> bool {
        self.strikethrough.unwrap_or(false)
    }

    pub fn clear_strikethrough(&mut self) {
        self.strikethrough = ::std::option::Option::None;
    }

    pub fn has_strikethrough(&self) -> bool {
        self.strikethrough.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strikethrough(&mut self, v: bool) {
        self.strikethrough = ::std::option::Option::Some(v);
    }

    // optional int32 letter_spacing = 8;

    pub fn letter_spacing(&self) -> i32 {
        self.letter_spacing.unwrap_or(0i32)
    }

    pub fn clear_letter_spacing(&mut self) {
        self.letter_spacing = ::std::option::Option::None;
    }

    pub fn has_letter_spacing(&self) -> bool {
        self.letter_spacing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_letter_spacing(&mut self, v: i32) {
        self.letter_spacing = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "font_name",
            |m: &CMsgTextFormat| { &m.font_name },
            |m: &mut CMsgTextFormat| { &mut m.font_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "font_size",
            |m: &CMsgTextFormat| { &m.font_size },
            |m: &mut CMsgTextFormat| { &mut m.font_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "font_weight",
            |m: &CMsgTextFormat| { &m.font_weight },
            |m: &mut CMsgTextFormat| { &mut m.font_weight },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "font_style",
            |m: &CMsgTextFormat| { &m.font_style },
            |m: &mut CMsgTextFormat| { &mut m.font_style },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "underline",
            |m: &CMsgTextFormat| { &m.underline },
            |m: &mut CMsgTextFormat| { &mut m.underline },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "strikethrough",
            |m: &CMsgTextFormat| { &m.strikethrough },
            |m: &mut CMsgTextFormat| { &mut m.strikethrough },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgFillBrushCollection>(
            "fill_brush_collection",
            |m: &CMsgTextFormat| { &m.fill_brush_collection },
            |m: &mut CMsgTextFormat| { &mut m.fill_brush_collection },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "letter_spacing",
            |m: &CMsgTextFormat| { &m.letter_spacing },
            |m: &mut CMsgTextFormat| { &mut m.letter_spacing },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgTextInlineObject>(
            "inline_object",
            |m: &CMsgTextFormat| { &m.inline_object },
            |m: &mut CMsgTextFormat| { &mut m.inline_object },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTextFormat>(
            "CMsgTextFormat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTextFormat {
    const NAME: &'static str = "CMsgTextFormat";

    fn is_initialized(&self) -> bool {
        for v in &self.fill_brush_collection {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inline_object {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.font_name = ::std::option::Option::Some(is.read_string()?);
                },
                17 => {
                    self.font_size = ::std::option::Option::Some(is.read_double()?);
                },
                24 => {
                    self.font_weight = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.font_style = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.underline = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.strikethrough = ::std::option::Option::Some(is.read_bool()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fill_brush_collection)?;
                },
                64 => {
                    self.letter_spacing = ::std::option::Option::Some(is.read_int32()?);
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.inline_object)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.font_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.font_size {
            my_size += 1 + 8;
        }
        if let Some(v) = self.font_weight {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.font_style {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.underline {
            my_size += 1 + 1;
        }
        if let Some(v) = self.strikethrough {
            my_size += 1 + 1;
        }
        if let Some(v) = self.fill_brush_collection.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.letter_spacing {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.inline_object.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.font_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.font_size {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.font_weight {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.font_style {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.underline {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.strikethrough {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.fill_brush_collection.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.letter_spacing {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.inline_object.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTextFormat {
        CMsgTextFormat::new()
    }

    fn clear(&mut self) {
        self.font_name = ::std::option::Option::None;
        self.font_size = ::std::option::Option::None;
        self.font_weight = ::std::option::Option::None;
        self.font_style = ::std::option::Option::None;
        self.underline = ::std::option::Option::None;
        self.strikethrough = ::std::option::Option::None;
        self.fill_brush_collection.clear();
        self.letter_spacing = ::std::option::Option::None;
        self.inline_object.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTextFormat {
        static instance: CMsgTextFormat = CMsgTextFormat {
            font_name: ::std::option::Option::None,
            font_size: ::std::option::Option::None,
            font_weight: ::std::option::Option::None,
            font_style: ::std::option::Option::None,
            underline: ::std::option::Option::None,
            strikethrough: ::std::option::Option::None,
            fill_brush_collection: ::protobuf::MessageField::none(),
            letter_spacing: ::std::option::Option::None,
            inline_object: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTextFormat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTextFormat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTextFormat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTextFormat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTextRangeFormat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTextRangeFormat {
    // message fields
    // @@protoc_insertion_point(field:CMsgTextRangeFormat.start_index)
    pub start_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTextRangeFormat.end_index)
    pub end_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTextRangeFormat.format)
    pub format: ::protobuf::MessageField<CMsgTextFormat>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTextRangeFormat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTextRangeFormat {
    fn default() -> &'a CMsgTextRangeFormat {
        <CMsgTextRangeFormat as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTextRangeFormat {
    pub fn new() -> CMsgTextRangeFormat {
        ::std::default::Default::default()
    }

    // optional uint32 start_index = 1;

    pub fn start_index(&self) -> u32 {
        self.start_index.unwrap_or(0)
    }

    pub fn clear_start_index(&mut self) {
        self.start_index = ::std::option::Option::None;
    }

    pub fn has_start_index(&self) -> bool {
        self.start_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_index(&mut self, v: u32) {
        self.start_index = ::std::option::Option::Some(v);
    }

    // optional uint32 end_index = 2;

    pub fn end_index(&self) -> u32 {
        self.end_index.unwrap_or(0)
    }

    pub fn clear_end_index(&mut self) {
        self.end_index = ::std::option::Option::None;
    }

    pub fn has_end_index(&self) -> bool {
        self.end_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_index(&mut self, v: u32) {
        self.end_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_index",
            |m: &CMsgTextRangeFormat| { &m.start_index },
            |m: &mut CMsgTextRangeFormat| { &mut m.start_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "end_index",
            |m: &CMsgTextRangeFormat| { &m.end_index },
            |m: &mut CMsgTextRangeFormat| { &mut m.end_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgTextFormat>(
            "format",
            |m: &CMsgTextRangeFormat| { &m.format },
            |m: &mut CMsgTextRangeFormat| { &mut m.format },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTextRangeFormat>(
            "CMsgTextRangeFormat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTextRangeFormat {
    const NAME: &'static str = "CMsgTextRangeFormat";

    fn is_initialized(&self) -> bool {
        for v in &self.format {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.start_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.end_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.format)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.start_index {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.end_index {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.format.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.start_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.end_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.format.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTextRangeFormat {
        CMsgTextRangeFormat::new()
    }

    fn clear(&mut self) {
        self.start_index = ::std::option::Option::None;
        self.end_index = ::std::option::Option::None;
        self.format.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTextRangeFormat {
        static instance: CMsgTextRangeFormat = CMsgTextRangeFormat {
            start_index: ::std::option::Option::None,
            end_index: ::std::option::Option::None,
            format: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTextRangeFormat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTextRangeFormat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTextRangeFormat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTextRangeFormat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgRenderTextFormat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRenderTextFormat {
    // message fields
    // @@protoc_insertion_point(field:CMsgRenderTextFormat.font_name)
    pub font_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgRenderTextFormat.font_size)
    pub font_size: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgRenderTextFormat.font_weight)
    pub font_weight: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRenderTextFormat.font_style)
    pub font_style: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRenderTextFormat.underline)
    pub underline: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRenderTextFormat.strikethrough)
    pub strikethrough: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRenderTextFormat.fill_brush_collection)
    pub fill_brush_collection: ::protobuf::MessageField<CMsgRenderFillBrushCollection>,
    // @@protoc_insertion_point(field:CMsgRenderTextFormat.letter_spacing)
    pub letter_spacing: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRenderTextFormat.inline_object)
    pub inline_object: ::protobuf::MessageField<CMsgTextInlineObject>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRenderTextFormat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRenderTextFormat {
    fn default() -> &'a CMsgRenderTextFormat {
        <CMsgRenderTextFormat as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRenderTextFormat {
    pub fn new() -> CMsgRenderTextFormat {
        ::std::default::Default::default()
    }

    // optional string font_name = 1;

    pub fn font_name(&self) -> &str {
        match self.font_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_font_name(&mut self) {
        self.font_name = ::std::option::Option::None;
    }

    pub fn has_font_name(&self) -> bool {
        self.font_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_font_name(&mut self, v: ::std::string::String) {
        self.font_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_font_name(&mut self) -> &mut ::std::string::String {
        if self.font_name.is_none() {
            self.font_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.font_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_font_name(&mut self) -> ::std::string::String {
        self.font_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional double font_size = 2;

    pub fn font_size(&self) -> f64 {
        self.font_size.unwrap_or(0.)
    }

    pub fn clear_font_size(&mut self) {
        self.font_size = ::std::option::Option::None;
    }

    pub fn has_font_size(&self) -> bool {
        self.font_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_font_size(&mut self, v: f64) {
        self.font_size = ::std::option::Option::Some(v);
    }

    // optional int32 font_weight = 3;

    pub fn font_weight(&self) -> i32 {
        self.font_weight.unwrap_or(-1i32)
    }

    pub fn clear_font_weight(&mut self) {
        self.font_weight = ::std::option::Option::None;
    }

    pub fn has_font_weight(&self) -> bool {
        self.font_weight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_font_weight(&mut self, v: i32) {
        self.font_weight = ::std::option::Option::Some(v);
    }

    // optional int32 font_style = 4;

    pub fn font_style(&self) -> i32 {
        self.font_style.unwrap_or(-1i32)
    }

    pub fn clear_font_style(&mut self) {
        self.font_style = ::std::option::Option::None;
    }

    pub fn has_font_style(&self) -> bool {
        self.font_style.is_some()
    }

    // Param is passed by value, moved
    pub fn set_font_style(&mut self, v: i32) {
        self.font_style = ::std::option::Option::Some(v);
    }

    // optional bool underline = 5;

    pub fn underline(&self) -> bool {
        self.underline.unwrap_or(false)
    }

    pub fn clear_underline(&mut self) {
        self.underline = ::std::option::Option::None;
    }

    pub fn has_underline(&self) -> bool {
        self.underline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_underline(&mut self, v: bool) {
        self.underline = ::std::option::Option::Some(v);
    }

    // optional bool strikethrough = 6;

    pub fn strikethrough(&self) -> bool {
        self.strikethrough.unwrap_or(false)
    }

    pub fn clear_strikethrough(&mut self) {
        self.strikethrough = ::std::option::Option::None;
    }

    pub fn has_strikethrough(&self) -> bool {
        self.strikethrough.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strikethrough(&mut self, v: bool) {
        self.strikethrough = ::std::option::Option::Some(v);
    }

    // optional int32 letter_spacing = 8;

    pub fn letter_spacing(&self) -> i32 {
        self.letter_spacing.unwrap_or(0i32)
    }

    pub fn clear_letter_spacing(&mut self) {
        self.letter_spacing = ::std::option::Option::None;
    }

    pub fn has_letter_spacing(&self) -> bool {
        self.letter_spacing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_letter_spacing(&mut self, v: i32) {
        self.letter_spacing = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "font_name",
            |m: &CMsgRenderTextFormat| { &m.font_name },
            |m: &mut CMsgRenderTextFormat| { &mut m.font_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "font_size",
            |m: &CMsgRenderTextFormat| { &m.font_size },
            |m: &mut CMsgRenderTextFormat| { &mut m.font_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "font_weight",
            |m: &CMsgRenderTextFormat| { &m.font_weight },
            |m: &mut CMsgRenderTextFormat| { &mut m.font_weight },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "font_style",
            |m: &CMsgRenderTextFormat| { &m.font_style },
            |m: &mut CMsgRenderTextFormat| { &mut m.font_style },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "underline",
            |m: &CMsgRenderTextFormat| { &m.underline },
            |m: &mut CMsgRenderTextFormat| { &mut m.underline },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "strikethrough",
            |m: &CMsgRenderTextFormat| { &m.strikethrough },
            |m: &mut CMsgRenderTextFormat| { &mut m.strikethrough },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgRenderFillBrushCollection>(
            "fill_brush_collection",
            |m: &CMsgRenderTextFormat| { &m.fill_brush_collection },
            |m: &mut CMsgRenderTextFormat| { &mut m.fill_brush_collection },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "letter_spacing",
            |m: &CMsgRenderTextFormat| { &m.letter_spacing },
            |m: &mut CMsgRenderTextFormat| { &mut m.letter_spacing },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgTextInlineObject>(
            "inline_object",
            |m: &CMsgRenderTextFormat| { &m.inline_object },
            |m: &mut CMsgRenderTextFormat| { &mut m.inline_object },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRenderTextFormat>(
            "CMsgRenderTextFormat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRenderTextFormat {
    const NAME: &'static str = "CMsgRenderTextFormat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.font_name = ::std::option::Option::Some(is.read_string()?);
                },
                17 => {
                    self.font_size = ::std::option::Option::Some(is.read_double()?);
                },
                24 => {
                    self.font_weight = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.font_style = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.underline = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.strikethrough = ::std::option::Option::Some(is.read_bool()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fill_brush_collection)?;
                },
                64 => {
                    self.letter_spacing = ::std::option::Option::Some(is.read_int32()?);
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.inline_object)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.font_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.font_size {
            my_size += 1 + 8;
        }
        if let Some(v) = self.font_weight {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.font_style {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.underline {
            my_size += 1 + 1;
        }
        if let Some(v) = self.strikethrough {
            my_size += 1 + 1;
        }
        if let Some(v) = self.fill_brush_collection.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.letter_spacing {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.inline_object.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.font_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.font_size {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.font_weight {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.font_style {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.underline {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.strikethrough {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.fill_brush_collection.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.letter_spacing {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.inline_object.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRenderTextFormat {
        CMsgRenderTextFormat::new()
    }

    fn clear(&mut self) {
        self.font_name = ::std::option::Option::None;
        self.font_size = ::std::option::Option::None;
        self.font_weight = ::std::option::Option::None;
        self.font_style = ::std::option::Option::None;
        self.underline = ::std::option::Option::None;
        self.strikethrough = ::std::option::Option::None;
        self.fill_brush_collection.clear();
        self.letter_spacing = ::std::option::Option::None;
        self.inline_object.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRenderTextFormat {
        static instance: CMsgRenderTextFormat = CMsgRenderTextFormat {
            font_name: ::std::option::Option::None,
            font_size: ::std::option::Option::None,
            font_weight: ::std::option::Option::None,
            font_style: ::std::option::Option::None,
            underline: ::std::option::Option::None,
            strikethrough: ::std::option::Option::None,
            fill_brush_collection: ::protobuf::MessageField::none(),
            letter_spacing: ::std::option::Option::None,
            inline_object: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRenderTextFormat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRenderTextFormat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRenderTextFormat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRenderTextFormat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgRenderTextRangeFormat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRenderTextRangeFormat {
    // message fields
    // @@protoc_insertion_point(field:CMsgRenderTextRangeFormat.start_index)
    pub start_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRenderTextRangeFormat.end_index)
    pub end_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRenderTextRangeFormat.format)
    pub format: ::protobuf::MessageField<CMsgRenderTextFormat>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRenderTextRangeFormat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRenderTextRangeFormat {
    fn default() -> &'a CMsgRenderTextRangeFormat {
        <CMsgRenderTextRangeFormat as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRenderTextRangeFormat {
    pub fn new() -> CMsgRenderTextRangeFormat {
        ::std::default::Default::default()
    }

    // optional uint32 start_index = 1;

    pub fn start_index(&self) -> u32 {
        self.start_index.unwrap_or(0)
    }

    pub fn clear_start_index(&mut self) {
        self.start_index = ::std::option::Option::None;
    }

    pub fn has_start_index(&self) -> bool {
        self.start_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_index(&mut self, v: u32) {
        self.start_index = ::std::option::Option::Some(v);
    }

    // optional uint32 end_index = 2;

    pub fn end_index(&self) -> u32 {
        self.end_index.unwrap_or(0)
    }

    pub fn clear_end_index(&mut self) {
        self.end_index = ::std::option::Option::None;
    }

    pub fn has_end_index(&self) -> bool {
        self.end_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_index(&mut self, v: u32) {
        self.end_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_index",
            |m: &CMsgRenderTextRangeFormat| { &m.start_index },
            |m: &mut CMsgRenderTextRangeFormat| { &mut m.start_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "end_index",
            |m: &CMsgRenderTextRangeFormat| { &m.end_index },
            |m: &mut CMsgRenderTextRangeFormat| { &mut m.end_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgRenderTextFormat>(
            "format",
            |m: &CMsgRenderTextRangeFormat| { &m.format },
            |m: &mut CMsgRenderTextRangeFormat| { &mut m.format },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRenderTextRangeFormat>(
            "CMsgRenderTextRangeFormat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRenderTextRangeFormat {
    const NAME: &'static str = "CMsgRenderTextRangeFormat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.start_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.end_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.format)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.start_index {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.end_index {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.format.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.start_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.end_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.format.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRenderTextRangeFormat {
        CMsgRenderTextRangeFormat::new()
    }

    fn clear(&mut self) {
        self.start_index = ::std::option::Option::None;
        self.end_index = ::std::option::Option::None;
        self.format.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRenderTextRangeFormat {
        static instance: CMsgRenderTextRangeFormat = CMsgRenderTextRangeFormat {
            start_index: ::std::option::Option::None,
            end_index: ::std::option::Option::None,
            format: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRenderTextRangeFormat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRenderTextRangeFormat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRenderTextRangeFormat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRenderTextRangeFormat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgDrawTextRegion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDrawTextRegion {
    // message fields
    // @@protoc_insertion_point(field:CMsgDrawTextRegion.raw_text)
    pub raw_text: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgDrawTextRegion.text_chars)
    pub text_chars: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgDrawTextRegion.text_encoding)
    pub text_encoding: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgDrawTextRegion.default_format)
    pub default_format: ::protobuf::MessageField<CMsgTextFormat>,
    // @@protoc_insertion_point(field:CMsgDrawTextRegion.text_align)
    pub text_align: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDrawTextRegion.line_height)
    pub line_height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDrawTextRegion.top_left)
    pub top_left: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgDrawTextRegion.bottom_right)
    pub bottom_right: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgDrawTextRegion.wrapping)
    pub wrapping: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDrawTextRegion.ellipsis)
    pub ellipsis: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDrawTextRegion.range_formats)
    pub range_formats: ::std::vec::Vec<CMsgTextRangeFormat>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDrawTextRegion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDrawTextRegion {
    fn default() -> &'a CMsgDrawTextRegion {
        <CMsgDrawTextRegion as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDrawTextRegion {
    pub fn new() -> CMsgDrawTextRegion {
        ::std::default::Default::default()
    }

    // optional bytes raw_text = 11;

    pub fn raw_text(&self) -> &[u8] {
        match self.raw_text.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_raw_text(&mut self) {
        self.raw_text = ::std::option::Option::None;
    }

    pub fn has_raw_text(&self) -> bool {
        self.raw_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_text(&mut self, v: ::std::vec::Vec<u8>) {
        self.raw_text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_raw_text(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.raw_text.is_none() {
            self.raw_text = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.raw_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_raw_text(&mut self) -> ::std::vec::Vec<u8> {
        self.raw_text.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 text_chars = 12;

    pub fn text_chars(&self) -> i32 {
        self.text_chars.unwrap_or(0)
    }

    pub fn clear_text_chars(&mut self) {
        self.text_chars = ::std::option::Option::None;
    }

    pub fn has_text_chars(&self) -> bool {
        self.text_chars.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text_chars(&mut self, v: i32) {
        self.text_chars = ::std::option::Option::Some(v);
    }

    // optional int32 text_encoding = 13;

    pub fn text_encoding(&self) -> i32 {
        self.text_encoding.unwrap_or(0)
    }

    pub fn clear_text_encoding(&mut self) {
        self.text_encoding = ::std::option::Option::None;
    }

    pub fn has_text_encoding(&self) -> bool {
        self.text_encoding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text_encoding(&mut self, v: i32) {
        self.text_encoding = ::std::option::Option::Some(v);
    }

    // optional uint32 text_align = 4;

    pub fn text_align(&self) -> u32 {
        self.text_align.unwrap_or(0)
    }

    pub fn clear_text_align(&mut self) {
        self.text_align = ::std::option::Option::None;
    }

    pub fn has_text_align(&self) -> bool {
        self.text_align.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text_align(&mut self, v: u32) {
        self.text_align = ::std::option::Option::Some(v);
    }

    // optional uint32 line_height = 5;

    pub fn line_height(&self) -> u32 {
        self.line_height.unwrap_or(0)
    }

    pub fn clear_line_height(&mut self) {
        self.line_height = ::std::option::Option::None;
    }

    pub fn has_line_height(&self) -> bool {
        self.line_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_line_height(&mut self, v: u32) {
        self.line_height = ::std::option::Option::Some(v);
    }

    // optional bool wrapping = 8;

    pub fn wrapping(&self) -> bool {
        self.wrapping.unwrap_or(false)
    }

    pub fn clear_wrapping(&mut self) {
        self.wrapping = ::std::option::Option::None;
    }

    pub fn has_wrapping(&self) -> bool {
        self.wrapping.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wrapping(&mut self, v: bool) {
        self.wrapping = ::std::option::Option::Some(v);
    }

    // optional bool ellipsis = 9;

    pub fn ellipsis(&self) -> bool {
        self.ellipsis.unwrap_or(false)
    }

    pub fn clear_ellipsis(&mut self) {
        self.ellipsis = ::std::option::Option::None;
    }

    pub fn has_ellipsis(&self) -> bool {
        self.ellipsis.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ellipsis(&mut self, v: bool) {
        self.ellipsis = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "raw_text",
            |m: &CMsgDrawTextRegion| { &m.raw_text },
            |m: &mut CMsgDrawTextRegion| { &mut m.raw_text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text_chars",
            |m: &CMsgDrawTextRegion| { &m.text_chars },
            |m: &mut CMsgDrawTextRegion| { &mut m.text_chars },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text_encoding",
            |m: &CMsgDrawTextRegion| { &m.text_encoding },
            |m: &mut CMsgDrawTextRegion| { &mut m.text_encoding },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgTextFormat>(
            "default_format",
            |m: &CMsgDrawTextRegion| { &m.default_format },
            |m: &mut CMsgDrawTextRegion| { &mut m.default_format },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text_align",
            |m: &CMsgDrawTextRegion| { &m.text_align },
            |m: &mut CMsgDrawTextRegion| { &mut m.text_align },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "line_height",
            |m: &CMsgDrawTextRegion| { &m.line_height },
            |m: &mut CMsgDrawTextRegion| { &mut m.line_height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "top_left",
            |m: &CMsgDrawTextRegion| { &m.top_left },
            |m: &mut CMsgDrawTextRegion| { &mut m.top_left },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "bottom_right",
            |m: &CMsgDrawTextRegion| { &m.bottom_right },
            |m: &mut CMsgDrawTextRegion| { &mut m.bottom_right },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "wrapping",
            |m: &CMsgDrawTextRegion| { &m.wrapping },
            |m: &mut CMsgDrawTextRegion| { &mut m.wrapping },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ellipsis",
            |m: &CMsgDrawTextRegion| { &m.ellipsis },
            |m: &mut CMsgDrawTextRegion| { &mut m.ellipsis },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "range_formats",
            |m: &CMsgDrawTextRegion| { &m.range_formats },
            |m: &mut CMsgDrawTextRegion| { &mut m.range_formats },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDrawTextRegion>(
            "CMsgDrawTextRegion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDrawTextRegion {
    const NAME: &'static str = "CMsgDrawTextRegion";

    fn is_initialized(&self) -> bool {
        for v in &self.default_format {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.top_left {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bottom_right {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.range_formats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                90 => {
                    self.raw_text = ::std::option::Option::Some(is.read_bytes()?);
                },
                96 => {
                    self.text_chars = ::std::option::Option::Some(is.read_int32()?);
                },
                104 => {
                    self.text_encoding = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.default_format)?;
                },
                32 => {
                    self.text_align = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.line_height = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.top_left)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bottom_right)?;
                },
                64 => {
                    self.wrapping = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.ellipsis = ::std::option::Option::Some(is.read_bool()?);
                },
                82 => {
                    self.range_formats.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.raw_text.as_ref() {
            my_size += ::protobuf::rt::bytes_size(11, &v);
        }
        if let Some(v) = self.text_chars {
            my_size += ::protobuf::rt::int32_size(12, v);
        }
        if let Some(v) = self.text_encoding {
            my_size += ::protobuf::rt::int32_size(13, v);
        }
        if let Some(v) = self.default_format.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.text_align {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.line_height {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.top_left.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bottom_right.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.wrapping {
            my_size += 1 + 1;
        }
        if let Some(v) = self.ellipsis {
            my_size += 1 + 1;
        }
        for value in &self.range_formats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.raw_text.as_ref() {
            os.write_bytes(11, v)?;
        }
        if let Some(v) = self.text_chars {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.text_encoding {
            os.write_int32(13, v)?;
        }
        if let Some(v) = self.default_format.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.text_align {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.line_height {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.top_left.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.bottom_right.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.wrapping {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.ellipsis {
            os.write_bool(9, v)?;
        }
        for v in &self.range_formats {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDrawTextRegion {
        CMsgDrawTextRegion::new()
    }

    fn clear(&mut self) {
        self.raw_text = ::std::option::Option::None;
        self.text_chars = ::std::option::Option::None;
        self.text_encoding = ::std::option::Option::None;
        self.default_format.clear();
        self.text_align = ::std::option::Option::None;
        self.line_height = ::std::option::Option::None;
        self.top_left.clear();
        self.bottom_right.clear();
        self.wrapping = ::std::option::Option::None;
        self.ellipsis = ::std::option::Option::None;
        self.range_formats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDrawTextRegion {
        static instance: CMsgDrawTextRegion = CMsgDrawTextRegion {
            raw_text: ::std::option::Option::None,
            text_chars: ::std::option::Option::None,
            text_encoding: ::std::option::Option::None,
            default_format: ::protobuf::MessageField::none(),
            text_align: ::std::option::Option::None,
            line_height: ::std::option::Option::None,
            top_left: ::protobuf::MessageField::none(),
            bottom_right: ::protobuf::MessageField::none(),
            wrapping: ::std::option::Option::None,
            ellipsis: ::std::option::Option::None,
            range_formats: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDrawTextRegion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDrawTextRegion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDrawTextRegion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDrawTextRegion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgRenderTextRegion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRenderTextRegion {
    // message fields
    // @@protoc_insertion_point(field:CMsgRenderTextRegion.raw_text)
    pub raw_text: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgRenderTextRegion.text_chars)
    pub text_chars: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRenderTextRegion.text_encoding)
    pub text_encoding: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRenderTextRegion.default_format)
    pub default_format: ::protobuf::MessageField<CMsgRenderTextFormat>,
    // @@protoc_insertion_point(field:CMsgRenderTextRegion.text_align)
    pub text_align: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRenderTextRegion.line_height)
    pub line_height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRenderTextRegion.top_left)
    pub top_left: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgRenderTextRegion.bottom_right)
    pub bottom_right: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgRenderTextRegion.wrapping)
    pub wrapping: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRenderTextRegion.ellipsis)
    pub ellipsis: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRenderTextRegion.range_formats)
    pub range_formats: ::std::vec::Vec<CMsgRenderTextRangeFormat>,
    // @@protoc_insertion_point(field:CMsgRenderTextRegion.text_shadow)
    pub text_shadow: ::protobuf::MessageField<CTextShadowData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRenderTextRegion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRenderTextRegion {
    fn default() -> &'a CMsgRenderTextRegion {
        <CMsgRenderTextRegion as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRenderTextRegion {
    pub fn new() -> CMsgRenderTextRegion {
        ::std::default::Default::default()
    }

    // optional bytes raw_text = 12;

    pub fn raw_text(&self) -> &[u8] {
        match self.raw_text.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_raw_text(&mut self) {
        self.raw_text = ::std::option::Option::None;
    }

    pub fn has_raw_text(&self) -> bool {
        self.raw_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_text(&mut self, v: ::std::vec::Vec<u8>) {
        self.raw_text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_raw_text(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.raw_text.is_none() {
            self.raw_text = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.raw_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_raw_text(&mut self) -> ::std::vec::Vec<u8> {
        self.raw_text.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 text_chars = 13;

    pub fn text_chars(&self) -> i32 {
        self.text_chars.unwrap_or(0)
    }

    pub fn clear_text_chars(&mut self) {
        self.text_chars = ::std::option::Option::None;
    }

    pub fn has_text_chars(&self) -> bool {
        self.text_chars.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text_chars(&mut self, v: i32) {
        self.text_chars = ::std::option::Option::Some(v);
    }

    // optional int32 text_encoding = 14;

    pub fn text_encoding(&self) -> i32 {
        self.text_encoding.unwrap_or(0)
    }

    pub fn clear_text_encoding(&mut self) {
        self.text_encoding = ::std::option::Option::None;
    }

    pub fn has_text_encoding(&self) -> bool {
        self.text_encoding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text_encoding(&mut self, v: i32) {
        self.text_encoding = ::std::option::Option::Some(v);
    }

    // optional uint32 text_align = 4;

    pub fn text_align(&self) -> u32 {
        self.text_align.unwrap_or(0)
    }

    pub fn clear_text_align(&mut self) {
        self.text_align = ::std::option::Option::None;
    }

    pub fn has_text_align(&self) -> bool {
        self.text_align.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text_align(&mut self, v: u32) {
        self.text_align = ::std::option::Option::Some(v);
    }

    // optional uint32 line_height = 5;

    pub fn line_height(&self) -> u32 {
        self.line_height.unwrap_or(0)
    }

    pub fn clear_line_height(&mut self) {
        self.line_height = ::std::option::Option::None;
    }

    pub fn has_line_height(&self) -> bool {
        self.line_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_line_height(&mut self, v: u32) {
        self.line_height = ::std::option::Option::Some(v);
    }

    // optional bool wrapping = 8;

    pub fn wrapping(&self) -> bool {
        self.wrapping.unwrap_or(false)
    }

    pub fn clear_wrapping(&mut self) {
        self.wrapping = ::std::option::Option::None;
    }

    pub fn has_wrapping(&self) -> bool {
        self.wrapping.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wrapping(&mut self, v: bool) {
        self.wrapping = ::std::option::Option::Some(v);
    }

    // optional bool ellipsis = 9;

    pub fn ellipsis(&self) -> bool {
        self.ellipsis.unwrap_or(false)
    }

    pub fn clear_ellipsis(&mut self) {
        self.ellipsis = ::std::option::Option::None;
    }

    pub fn has_ellipsis(&self) -> bool {
        self.ellipsis.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ellipsis(&mut self, v: bool) {
        self.ellipsis = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "raw_text",
            |m: &CMsgRenderTextRegion| { &m.raw_text },
            |m: &mut CMsgRenderTextRegion| { &mut m.raw_text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text_chars",
            |m: &CMsgRenderTextRegion| { &m.text_chars },
            |m: &mut CMsgRenderTextRegion| { &mut m.text_chars },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text_encoding",
            |m: &CMsgRenderTextRegion| { &m.text_encoding },
            |m: &mut CMsgRenderTextRegion| { &mut m.text_encoding },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgRenderTextFormat>(
            "default_format",
            |m: &CMsgRenderTextRegion| { &m.default_format },
            |m: &mut CMsgRenderTextRegion| { &mut m.default_format },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text_align",
            |m: &CMsgRenderTextRegion| { &m.text_align },
            |m: &mut CMsgRenderTextRegion| { &mut m.text_align },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "line_height",
            |m: &CMsgRenderTextRegion| { &m.line_height },
            |m: &mut CMsgRenderTextRegion| { &mut m.line_height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "top_left",
            |m: &CMsgRenderTextRegion| { &m.top_left },
            |m: &mut CMsgRenderTextRegion| { &mut m.top_left },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "bottom_right",
            |m: &CMsgRenderTextRegion| { &m.bottom_right },
            |m: &mut CMsgRenderTextRegion| { &mut m.bottom_right },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "wrapping",
            |m: &CMsgRenderTextRegion| { &m.wrapping },
            |m: &mut CMsgRenderTextRegion| { &mut m.wrapping },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ellipsis",
            |m: &CMsgRenderTextRegion| { &m.ellipsis },
            |m: &mut CMsgRenderTextRegion| { &mut m.ellipsis },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "range_formats",
            |m: &CMsgRenderTextRegion| { &m.range_formats },
            |m: &mut CMsgRenderTextRegion| { &mut m.range_formats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CTextShadowData>(
            "text_shadow",
            |m: &CMsgRenderTextRegion| { &m.text_shadow },
            |m: &mut CMsgRenderTextRegion| { &mut m.text_shadow },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRenderTextRegion>(
            "CMsgRenderTextRegion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRenderTextRegion {
    const NAME: &'static str = "CMsgRenderTextRegion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                98 => {
                    self.raw_text = ::std::option::Option::Some(is.read_bytes()?);
                },
                104 => {
                    self.text_chars = ::std::option::Option::Some(is.read_int32()?);
                },
                112 => {
                    self.text_encoding = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.default_format)?;
                },
                32 => {
                    self.text_align = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.line_height = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.top_left)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bottom_right)?;
                },
                64 => {
                    self.wrapping = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.ellipsis = ::std::option::Option::Some(is.read_bool()?);
                },
                82 => {
                    self.range_formats.push(is.read_message()?);
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.text_shadow)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.raw_text.as_ref() {
            my_size += ::protobuf::rt::bytes_size(12, &v);
        }
        if let Some(v) = self.text_chars {
            my_size += ::protobuf::rt::int32_size(13, v);
        }
        if let Some(v) = self.text_encoding {
            my_size += ::protobuf::rt::int32_size(14, v);
        }
        if let Some(v) = self.default_format.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.text_align {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.line_height {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.top_left.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bottom_right.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.wrapping {
            my_size += 1 + 1;
        }
        if let Some(v) = self.ellipsis {
            my_size += 1 + 1;
        }
        for value in &self.range_formats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.text_shadow.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.raw_text.as_ref() {
            os.write_bytes(12, v)?;
        }
        if let Some(v) = self.text_chars {
            os.write_int32(13, v)?;
        }
        if let Some(v) = self.text_encoding {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.default_format.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.text_align {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.line_height {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.top_left.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.bottom_right.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.wrapping {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.ellipsis {
            os.write_bool(9, v)?;
        }
        for v in &self.range_formats {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        if let Some(v) = self.text_shadow.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRenderTextRegion {
        CMsgRenderTextRegion::new()
    }

    fn clear(&mut self) {
        self.raw_text = ::std::option::Option::None;
        self.text_chars = ::std::option::Option::None;
        self.text_encoding = ::std::option::Option::None;
        self.default_format.clear();
        self.text_align = ::std::option::Option::None;
        self.line_height = ::std::option::Option::None;
        self.top_left.clear();
        self.bottom_right.clear();
        self.wrapping = ::std::option::Option::None;
        self.ellipsis = ::std::option::Option::None;
        self.range_formats.clear();
        self.text_shadow.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRenderTextRegion {
        static instance: CMsgRenderTextRegion = CMsgRenderTextRegion {
            raw_text: ::std::option::Option::None,
            text_chars: ::std::option::Option::None,
            text_encoding: ::std::option::Option::None,
            default_format: ::protobuf::MessageField::none(),
            text_align: ::std::option::Option::None,
            line_height: ::std::option::Option::None,
            top_left: ::protobuf::MessageField::none(),
            bottom_right: ::protobuf::MessageField::none(),
            wrapping: ::std::option::Option::None,
            ellipsis: ::std::option::Option::None,
            range_formats: ::std::vec::Vec::new(),
            text_shadow: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRenderTextRegion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRenderTextRegion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRenderTextRegion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRenderTextRegion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgRequestRenderCallback)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRequestRenderCallback {
    // message fields
    // @@protoc_insertion_point(field:CMsgRequestRenderCallback.callback_obj)
    pub callback_obj: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgRequestRenderCallback.top_left)
    pub top_left: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgRequestRenderCallback.bottom_right)
    pub bottom_right: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgRequestRenderCallback.top_left_padding)
    pub top_left_padding: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgRequestRenderCallback.bottom_right_padding)
    pub bottom_right_padding: ::protobuf::MessageField<CMsgPoint>,
    // @@protoc_insertion_point(field:CMsgRequestRenderCallback.needs_redraw_every_frame)
    pub needs_redraw_every_frame: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRequestRenderCallback.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRequestRenderCallback {
    fn default() -> &'a CMsgRequestRenderCallback {
        <CMsgRequestRenderCallback as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRequestRenderCallback {
    pub fn new() -> CMsgRequestRenderCallback {
        ::std::default::Default::default()
    }

    // optional bytes callback_obj = 1;

    pub fn callback_obj(&self) -> &[u8] {
        match self.callback_obj.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_callback_obj(&mut self) {
        self.callback_obj = ::std::option::Option::None;
    }

    pub fn has_callback_obj(&self) -> bool {
        self.callback_obj.is_some()
    }

    // Param is passed by value, moved
    pub fn set_callback_obj(&mut self, v: ::std::vec::Vec<u8>) {
        self.callback_obj = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_callback_obj(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.callback_obj.is_none() {
            self.callback_obj = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.callback_obj.as_mut().unwrap()
    }

    // Take field
    pub fn take_callback_obj(&mut self) -> ::std::vec::Vec<u8> {
        self.callback_obj.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool needs_redraw_every_frame = 6;

    pub fn needs_redraw_every_frame(&self) -> bool {
        self.needs_redraw_every_frame.unwrap_or(false)
    }

    pub fn clear_needs_redraw_every_frame(&mut self) {
        self.needs_redraw_every_frame = ::std::option::Option::None;
    }

    pub fn has_needs_redraw_every_frame(&self) -> bool {
        self.needs_redraw_every_frame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needs_redraw_every_frame(&mut self, v: bool) {
        self.needs_redraw_every_frame = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "callback_obj",
            |m: &CMsgRequestRenderCallback| { &m.callback_obj },
            |m: &mut CMsgRequestRenderCallback| { &mut m.callback_obj },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "top_left",
            |m: &CMsgRequestRenderCallback| { &m.top_left },
            |m: &mut CMsgRequestRenderCallback| { &mut m.top_left },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "bottom_right",
            |m: &CMsgRequestRenderCallback| { &m.bottom_right },
            |m: &mut CMsgRequestRenderCallback| { &mut m.bottom_right },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "top_left_padding",
            |m: &CMsgRequestRenderCallback| { &m.top_left_padding },
            |m: &mut CMsgRequestRenderCallback| { &mut m.top_left_padding },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgPoint>(
            "bottom_right_padding",
            |m: &CMsgRequestRenderCallback| { &m.bottom_right_padding },
            |m: &mut CMsgRequestRenderCallback| { &mut m.bottom_right_padding },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "needs_redraw_every_frame",
            |m: &CMsgRequestRenderCallback| { &m.needs_redraw_every_frame },
            |m: &mut CMsgRequestRenderCallback| { &mut m.needs_redraw_every_frame },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRequestRenderCallback>(
            "CMsgRequestRenderCallback",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRequestRenderCallback {
    const NAME: &'static str = "CMsgRequestRenderCallback";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.callback_obj = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.top_left)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bottom_right)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.top_left_padding)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bottom_right_padding)?;
                },
                48 => {
                    self.needs_redraw_every_frame = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.callback_obj.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.top_left.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bottom_right.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.top_left_padding.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bottom_right_padding.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.needs_redraw_every_frame {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.callback_obj.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.top_left.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.bottom_right.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.top_left_padding.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.bottom_right_padding.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.needs_redraw_every_frame {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRequestRenderCallback {
        CMsgRequestRenderCallback::new()
    }

    fn clear(&mut self) {
        self.callback_obj = ::std::option::Option::None;
        self.top_left.clear();
        self.bottom_right.clear();
        self.top_left_padding.clear();
        self.bottom_right_padding.clear();
        self.needs_redraw_every_frame = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRequestRenderCallback {
        static instance: CMsgRequestRenderCallback = CMsgRequestRenderCallback {
            callback_obj: ::std::option::Option::None,
            top_left: ::protobuf::MessageField::none(),
            bottom_right: ::protobuf::MessageField::none(),
            top_left_padding: ::protobuf::MessageField::none(),
            bottom_right_padding: ::protobuf::MessageField::none(),
            needs_redraw_every_frame: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRequestRenderCallback {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRequestRenderCallback").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRequestRenderCallback {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRequestRenderCallback {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1drenderer/rendermessages.proto\"\xbc\x02\n\x0eCMsgBeginFrame\x12(\n\
    \x10frame_paint_time\x18\x01\x20\x01(\x01R\x0eframePaintTime\x12#\n\rsur\
    face_width\x18\x02\x20\x01(\rR\x0csurfaceWidth\x12%\n\x0esurface_height\
    \x18\x03\x20\x01(\rR\rsurfaceHeight\x12#\n\rrender_target\x18\x04\x20\
    \x01(\rR\x0crenderTarget\x12&\n\x0fui_scale_factor\x18\x05\x20\x01(\x01R\
    \ruiScaleFactor\x12\x1f\n\x0bempty_frame\x18\x06\x20\x01(\x08R\nemptyFra\
    me\x12F\n\x20clear_gpu_resources_before_frame\x18\x07\x20\x01(\x08R\x1cc\
    learGpuResourcesBeforeFrame\"\xaf\x01\n\x0cCMsgEndFrame\x125\n\x17mouse_\
    cursor_texture_id\x18\x01\x20\x01(\rR\x14mouseCursorTextureId\x123\n\x16\
    mouse_cursor_hotspot_x\x18\x02\x20\x01(\x02R\x13mouseCursorHotspotX\x123\
    \n\x16mouse_cursor_hotspot_y\x18\x03\x20\x01(\x02R\x13mouseCursorHotspot\
    Y\"?\n\x13CMsgClearBackbuffer\x12(\n\x10clear_color_rgba\x18\x01\x20\x01\
    (\rR\x0eclearColorRgba\"<\n\x11CMsgDeleteTexture\x12'\n\x0ftexture_point\
    er\x18\x01\x20\x01(\x04R\x0etexturePointer\"0\n\x0fCMsgDeletePanel\x12\
    \x1d\n\ncontext_id\x18\x01\x20\x01(\x04R\tcontextId\"^\n\x18CMsgDeletePa\
    rticleSystem\x12!\n\x0cpanel_handle\x18\x01\x20\x01(\x04R\x0bpanelHandle\
    \x12\x1f\n\x0bbrush_index\x18\x02\x20\x01(\rR\nbrushIndex\"5\n\tCMsgPoin\
    t\x12\x0c\n\x01x\x18\x01\x20\x01(\x01R\x01x\x12\x0c\n\x01y\x18\x02\x20\
    \x01(\x01R\x01y\x12\x0c\n\x01z\x18\x03\x20\x01(\x01R\x01z\"\xaf\x02\n\rC\
    MsgMatrix4x4\x12\x10\n\x03m00\x18\x01\x20\x01(\x01R\x03m00\x12\x10\n\x03\
    m01\x18\x02\x20\x01(\x01R\x03m01\x12\x10\n\x03m02\x18\x03\x20\x01(\x01R\
    \x03m02\x12\x10\n\x03m03\x18\x04\x20\x01(\x01R\x03m03\x12\x10\n\x03m10\
    \x18\x05\x20\x01(\x01R\x03m10\x12\x10\n\x03m11\x18\x06\x20\x01(\x01R\x03\
    m11\x12\x10\n\x03m12\x18\x07\x20\x01(\x01R\x03m12\x12\x10\n\x03m13\x18\
    \x08\x20\x01(\x01R\x03m13\x12\x10\n\x03m20\x18\t\x20\x01(\x01R\x03m20\
    \x12\x10\n\x03m21\x18\n\x20\x01(\x01R\x03m21\x12\x10\n\x03m22\x18\x0b\
    \x20\x01(\x01R\x03m22\x12\x10\n\x03m23\x18\x0c\x20\x01(\x01R\x03m23\x12\
    \x10\n\x03m30\x18\r\x20\x01(\x01R\x03m30\x12\x10\n\x03m31\x18\x0e\x20\
    \x01(\x01R\x03m31\x12\x10\n\x03m32\x18\x0f\x20\x01(\x01R\x03m32\x12\x10\
    \n\x03m33\x18\x10\x20\x01(\x01R\x03m33\"\xc6\x02\n\x0bCRadiusData\x125\n\
    \x08top_left\x18\x01\x20\x01(\x0b2\x1a.CRadiusData.CCornerRadiusR\x07top\
    Left\x127\n\ttop_right\x18\x02\x20\x01(\x0b2\x1a.CRadiusData.CCornerRadi\
    usR\x08topRight\x12=\n\x0cbottom_right\x18\x03\x20\x01(\x0b2\x1a.CRadius\
    Data.CCornerRadiusR\x0bbottomRight\x12;\n\x0bbottom_left\x18\x04\x20\x01\
    (\x0b2\x1a.CRadiusData.CCornerRadiusR\nbottomLeft\x1aK\n\rCCornerRadius\
    \x12\x1e\n\nhorizontal\x18\x01\x20\x01(\x01R\nhorizontal\x12\x1a\n\x08ve\
    rtical\x18\x02\x20\x01(\x01R\x08vertical\"\x9a\x02\n\x0bCBorderData\x12*\
    \n\x03top\x18\x01\x20\x01(\x0b2\x18.CBorderData.CBorderSideR\x03top\x12.\
    \n\x05right\x18\x02\x20\x01(\x0b2\x18.CBorderData.CBorderSideR\x05right\
    \x120\n\x06bottom\x18\x03\x20\x01(\x0b2\x18.CBorderData.CBorderSideR\x06\
    bottom\x12,\n\x04left\x18\x04\x20\x01(\x0b2\x18.CBorderData.CBorderSideR\
    \x04left\x1aO\n\x0bCBorderSide\x12\x14\n\x05style\x18\x01\x20\x01(\rR\
    \x05style\x12\x14\n\x05width\x18\x02\x20\x01(\x01R\x05width\x12\x14\n\
    \x05color\x18\x03\x20\x01(\rR\x05color\"\x8e\x02\n\x0eCBoxShadowData\x12\
    \x14\n\x05inset\x18\x01\x20\x01(\x08R\x05inset\x12+\n\x11horizontal_offs\
    et\x18\x02\x20\x01(\x01R\x10horizontalOffset\x12'\n\x0fvertical_offset\
    \x18\x03\x20\x01(\x01R\x0everticalOffset\x12\x1f\n\x0bblur_radius\x18\
    \x04\x20\x01(\x01R\nblurRadius\x12'\n\x0fspread_distance\x18\x05\x20\x01\
    (\x01R\x0espreadDistance\x12\x14\n\x05color\x18\x06\x20\x01(\rR\x05color\
    \x12\x12\n\x04fill\x18\x07\x20\x01(\x08R\x04fill\x12\x1c\n\tanimating\
    \x18\x08\x20\x01(\x08R\tanimating\"\xd8\x01\n\x0fCTextShadowData\x12+\n\
    \x11horizontal_offset\x18\x02\x20\x01(\x01R\x10horizontalOffset\x12'\n\
    \x0fvertical_offset\x18\x03\x20\x01(\x01R\x0everticalOffset\x12\x1f\n\
    \x0bblur_radius\x18\x04\x20\x01(\x01R\nblurRadius\x12\x14\n\x05color\x18\
    \x06\x20\x01(\rR\x05color\x12\x1c\n\tanimating\x18\x08\x20\x01(\x08R\tan\
    imating\x12\x1a\n\x08strength\x18\t\x20\x01(\x01R\x08strength\"\x8b\x01\
    \n\x0fCRadialClipData\x12\x19\n\x08center_x\x18\x01\x20\x01(\x01R\x07cen\
    terX\x12\x19\n\x08center_y\x18\x02\x20\x01(\x01R\x07centerY\x12\x1f\n\
    \x0bstart_angle\x18\x03\x20\x01(\x01R\nstartAngle\x12!\n\x0csector_angle\
    \x18\x04\x20\x01(\x01R\x0bsectorAngle\"\xb2\x01\n\x0cCMsgClipData\x12\
    \x1b\n\trect_clip\x18\x01\x20\x01(\x08R\x08rectClip\x12\x12\n\x04left\
    \x18\x02\x20\x01(\x01R\x04left\x12\x10\n\x03top\x18\x03\x20\x01(\x01R\
    \x03top\x12\x14\n\x05right\x18\x04\x20\x01(\x01R\x05right\x12\x16\n\x06b\
    ottom\x18\x05\x20\x01(\x01R\x06bottom\x121\n\x0bradial_clip\x18\x06\x20\
    \x01(\x0b2\x10.CRadialClipDataR\nradialClip\"\xf9\x15\n\x18CMsgPushCompo\
    sitingLayer\x12\x19\n\x08layer_id\x18\x01\x20\x01(\x04R\x07layerId\x12\
    \x14\n\x05width\x18\x02\x20\x01(\x01R\x05width\x12\x16\n\x06height\x18\
    \x03\x20\x01(\x01R\x06height\x120\n\x15layer_quad_top_left_x\x18\x04\x20\
    \x01(\x01R\x11layerQuadTopLeftX\x120\n\x15layer_quad_top_left_y\x18\x05\
    \x20\x01(\x01R\x11layerQuadTopLeftY\x120\n\x15layer_quad_top_left_z\x18\
    \x06\x20\x01(\x01R\x11layerQuadTopLeftZ\x122\n\x16layer_quad_top_right_x\
    \x18\x07\x20\x01(\x01R\x12layerQuadTopRightX\x122\n\x16layer_quad_top_ri\
    ght_y\x18\x08\x20\x01(\x01R\x12layerQuadTopRightY\x122\n\x16layer_quad_t\
    op_right_z\x18\t\x20\x01(\x01R\x12layerQuadTopRightZ\x126\n\x18layer_qua\
    d_bottom_left_x\x18\n\x20\x01(\x01R\x14layerQuadBottomLeftX\x126\n\x18la\
    yer_quad_bottom_left_y\x18\x0b\x20\x01(\x01R\x14layerQuadBottomLeftY\x12\
    6\n\x18layer_quad_bottom_left_z\x18\x0c\x20\x01(\x01R\x14layerQuadBottom\
    LeftZ\x128\n\x19layer_quad_bottom_right_x\x18\r\x20\x01(\x01R\x15layerQu\
    adBottomRightX\x128\n\x19layer_quad_bottom_right_y\x18\x0e\x20\x01(\x01R\
    \x15layerQuadBottomRightY\x128\n\x19layer_quad_bottom_right_z\x18\x0f\
    \x20\x01(\x01R\x15layerQuadBottomRightZ\x12#\n\rtransform_m00\x18\x10\
    \x20\x01(\x01R\x0ctransformM00\x12#\n\rtransform_m01\x18\x11\x20\x01(\
    \x01R\x0ctransformM01\x12#\n\rtransform_m02\x18\x12\x20\x01(\x01R\x0ctra\
    nsformM02\x12#\n\rtransform_m03\x18\x13\x20\x01(\x01R\x0ctransformM03\
    \x12#\n\rtransform_m10\x18\x14\x20\x01(\x01R\x0ctransformM10\x12#\n\rtra\
    nsform_m11\x18\x15\x20\x01(\x01R\x0ctransformM11\x12#\n\rtransform_m12\
    \x18\x16\x20\x01(\x01R\x0ctransformM12\x12#\n\rtransform_m13\x18\x17\x20\
    \x01(\x01R\x0ctransformM13\x12#\n\rtransform_m20\x18\x18\x20\x01(\x01R\
    \x0ctransformM20\x12#\n\rtransform_m21\x18\x19\x20\x01(\x01R\x0ctransfor\
    mM21\x12#\n\rtransform_m22\x18\x1a\x20\x01(\x01R\x0ctransformM22\x12#\n\
    \rtransform_m23\x18\x1b\x20\x01(\x01R\x0ctransformM23\x12#\n\rtransform_\
    m30\x18\x1c\x20\x01(\x01R\x0ctransformM30\x12#\n\rtransform_m31\x18\x1d\
    \x20\x01(\x01R\x0ctransformM31\x12#\n\rtransform_m32\x18\x1e\x20\x01(\
    \x01R\x0ctransformM32\x12#\n\rtransform_m33\x18\x1f\x20\x01(\x01R\x0ctra\
    nsformM33\x12+\n\x11perspective_depth\x18\x20\x20\x01(\x01R\x10perspecti\
    veDepth\x12\x18\n\x07opacity\x18!\x20\x01(\x01R\x07opacity\x12+\n\x11com\
    position_color\x18\"\x20\x01(\rR\x10compositionColor\x12\x1e\n\nsaturati\
    on\x18#\x20\x01(\x01R\nsaturation\x12\x1b\n\thue_shift\x18$\x20\x01(\x01\
    R\x08hueShift\x12\x1e\n\nbrightness\x18%\x20\x01(\x01R\nbrightness\x12\
    \x1a\n\x08contrast\x18&\x20\x01(\x01R\x08contrast\x125\n\x17opacity_mask\
    _texture_id\x18'\x20\x01(\rR\x14opacityMaskTextureId\x120\n\x14opacity_m\
    ask_opacity\x18(\x20\x01(\x01R\x12opacityMaskOpacity\x12$\n\x06border\
    \x18)\x20\x01(\x0b2\x0c.CBorderDataR\x06border\x121\n\rborder_radius\x18\
    *\x20\x01(\x0b2\x0c.CRadiusDataR\x0cborderRadius\x12.\n\nbox_shadow\x18+\
    \x20\x01(\x0b2\x0f.CBoxShadowDataR\tboxShadow\x12/\n\x13gaussianblur_pas\
    ses\x18,\x20\x01(\x01R\x12gaussianblurPasses\x125\n\x16gaussianblur_stdd\
    evhor\x18-\x20\x01(\x01R\x15gaussianblurStddevhor\x125\n\x16gaussianblur\
    _stddevver\x18.\x20\x01(\x01R\x15gaussianblurStddevver\x12+\n\x12scale_2\
    d_factors_x\x18/\x20\x01(\x01R\x0fscale2dFactorsX\x12+\n\x12scale_2d_fac\
    tors_y\x180\x20\x01(\x01R\x0fscale2dFactorsY\x12\x1b\n\trotate_2d\x181\
    \x20\x01(\x01R\x08rotate2d\x12\x1f\n\x0bneeds_clear\x182\x20\x01(\x08R\n\
    needsClear\x12\x1f\n\x0bneeds_depth\x183\x20\x01(\x08R\nneedsDepth\x12<\
    \n\x1aneeds_intermediate_texture\x184\x20\x01(\x08R\x18needsIntermediate\
    Texture\x127\n\x18needs_redraw_every_frame\x185\x20\x01(\x08R\x15needsRe\
    drawEveryFrame\x121\n\x0btext_shadow\x186\x20\x01(\x0b2\x10.CTextShadowD\
    ataR\ntextShadow\x12$\n\x0emix_blend_mode\x187\x20\x01(\rR\x0cmixBlendMo\
    de\x12,\n\x12occluded_left_edge\x188\x20\x01(\x01R\x10occludedLeftEdge\
    \x12*\n\x11occluded_top_edge\x189\x20\x01(\x01R\x0foccludedTopEdge\x12.\
    \n\x13occluded_right_edge\x18:\x20\x01(\x01R\x11occludedRightEdge\x120\n\
    \x14occluded_bottom_edge\x18;\x20\x01(\x01R\x12occludedBottomEdge\x121\n\
    \x0bradial_clip\x18<\x20\x01(\x0b2\x10.CRadialClipDataR\nradialClip\x12/\
    \n\x13motionblur_velocity\x18=\x20\x01(\x01R\x12motionblurVelocity\x12'\
    \n\x0fmotionblur_dirx\x18>\x20\x01(\x01R\x0emotionblurDirx\x12'\n\x0fmot\
    ionblur_diry\x18?\x20\x01(\x01R\x0emotionblurDiry\x12C\n\x1ecomposition_\
    layer_texture_name\x18@\x20\x01(\tR\x1bcompositionLayerTextureName\"\x19\
    \n\x17CMsgPopCompositingLayer\"5\n\x18CMsgFreeCompositingLayer\x12\x19\n\
    \x08layer_id\x18\x01\x20\x01(\x04R\x07layerId\"\xbf\x02\n\x12CMsgTransit\
    ionData\x12\x1d\n\nstart_time\x18\x01\x20\x01(\x01R\tstartTime\x12#\n\rd\
    elay_seconds\x18\x02\x20\x01(\x01R\x0cdelaySeconds\x12)\n\x10duration_se\
    conds\x18\x03\x20\x01(\x01R\x0fdurationSeconds\x12\"\n\x0btiming_func\
    \x18\x04\x20\x01(\r:\x010R\ntimingFunc\x12$\n\x0ecubic_bezier_0\x18\x05\
    \x20\x01(\x02R\x0ccubicBezier0\x12$\n\x0ecubic_bezier_1\x18\x06\x20\x01(\
    \x02R\x0ccubicBezier1\x12$\n\x0ecubic_bezier_2\x18\x07\x20\x01(\x02R\x0c\
    cubicBezier2\x12$\n\x0ecubic_bezier_3\x18\x08\x20\x01(\x02R\x0ccubicBezi\
    er3\"\xa8\x03\n\x11CMsgAnimationData\x12\x1d\n\nstart_time\x18\x01\x20\
    \x01(\x01R\tstartTime\x12#\n\rdelay_seconds\x18\x02\x20\x01(\x01R\x0cdel\
    aySeconds\x12)\n\x10duration_seconds\x18\x03\x20\x01(\x01R\x0fdurationSe\
    conds\x12\x1f\n\x0btiming_func\x18\x04\x20\x01(\rR\ntimingFunc\x12$\n\
    \x0ecubic_bezier_0\x18\x05\x20\x01(\x02R\x0ccubicBezier0\x12$\n\x0ecubic\
    _bezier_1\x18\x06\x20\x01(\x02R\x0ccubicBezier1\x12$\n\x0ecubic_bezier_2\
    \x18\x07\x20\x01(\x02R\x0ccubicBezier2\x12$\n\x0ecubic_bezier_3\x18\x08\
    \x20\x01(\x02R\x0ccubicBezier3\x12\x1c\n\tdirection\x18\t\x20\x01(\rR\td\
    irection\x12\x1c\n\titeration\x18\n\x20\x01(\x02R\titeration\x12/\n\x06f\
    rames\x18\x0b\x20\x03(\x0b2\x17.CMsgAnimationFrameDataR\x06frames\"\xf9\
    \x01\n\x16CMsgAnimationFrameData\x12\x18\n\x07percent\x18\x01\x20\x01(\
    \x02R\x07percent\x12\"\n\x0btiming_func\x18\x02\x20\x01(\r:\x010R\ntimin\
    gFunc\x12$\n\x0ecubic_bezier_0\x18\x03\x20\x01(\x02R\x0ccubicBezier0\x12\
    $\n\x0ecubic_bezier_1\x18\x04\x20\x01(\x02R\x0ccubicBezier1\x12$\n\x0ecu\
    bic_bezier_2\x18\x05\x20\x01(\x02R\x0ccubicBezier2\x12$\n\x0ecubic_bezie\
    r_3\x18\x06\x20\x01(\x02R\x0ccubicBezier3*\t\x08\xe8\x07\x10\x80\x80\x80\
    \x80\x02\"\xa9\x03\n\x17CMsgPointWithTransition\x12\x1e\n\x04base\x18\
    \x01\x20\x01(\x0b2\n.CMsgPointR\x04base\x12*\n\ntransition\x18\x02\x20\
    \x01(\x0b2\n.CMsgPointR\ntransition\x12<\n\x0ftransition_data\x18\x03\
    \x20\x01(\x0b2\x13.CMsgTransitionDataR\x0etransitionData\x12!\n\x0cstyle\
    _symbol\x18\x04\x20\x01(\rR\x0bstyleSymbol\x122\n\nanimations\x18\x05\
    \x20\x03(\x0b2\x12.CMsgAnimationDataR\nanimations2w\n\x14animation_frame\
    _data\x18\xf4\x07\x20\x01(\x0b2+.CMsgPointWithTransition.AnimationFrameD\
    ata\x12\x17.CMsgAnimationFrameDataR\x12animationFrameData\x1a4\n\x12Anim\
    ationFrameData\x12\x1e\n\x04data\x18\x01\x20\x01(\x0b2\n.CMsgPointR\x04d\
    ata\"\xe9\x02\n\tCMsgColor\x12\x12\n\x04base\x18\x01\x20\x01(\rR\x04base\
    \x12\x1e\n\ntransition\x18\x02\x20\x01(\rR\ntransition\x12<\n\x0ftransit\
    ion_data\x18\x03\x20\x01(\x0b2\x13.CMsgTransitionDataR\x0etransitionData\
    \x12!\n\x0cstyle_symbol\x18\x04\x20\x01(\rR\x0bstyleSymbol\x122\n\nanima\
    tions\x18\x05\x20\x03(\x0b2\x12.CMsgAnimationDataR\nanimations2i\n\x14an\
    imation_frame_data\x18\xe9\x07\x20\x01(\x0b2\x1d.CMsgColor.AnimationFram\
    eData\x12\x17.CMsgAnimationFrameDataR\x12animationFrameData\x1a(\n\x12An\
    imationFrameData\x12\x12\n\x04data\x18\x01\x20\x01(\rR\x04data\"J\n\rCMs\
    gColorStop\x12\x1a\n\x08position\x18\x01\x20\x01(\x01R\x08position\x12\
    \x1d\n\ncolor_rgba\x18\x02\x20\x01(\rR\tcolorRgba\"\xa5\x01\n\x12CMsgLin\
    earGradient\x121\n\x0estart_position\x18\x01\x20\x01(\x0b2\n.CMsgPointR\
    \rstartPosition\x12-\n\x0cend_position\x18\x02\x20\x01(\x0b2\n.CMsgPoint\
    R\x0bendPosition\x12-\n\ncolor_stop\x18\x03\x20\x03(\x0b2\x0e.CMsgColorS\
    topR\tcolorStop\"\xcf\x01\n\x12CMsgRadialGradient\x123\n\x0fcenter_posit\
    ion\x18\x01\x20\x01(\x0b2\n.CMsgPointR\x0ecenterPosition\x123\n\x0foffse\
    t_distance\x18\x02\x20\x01(\x0b2\n.CMsgPointR\x0eoffsetDistance\x12\x20\
    \n\x05radii\x18\x03\x20\x01(\x0b2\n.CMsgPointR\x05radii\x12-\n\ncolor_st\
    op\x18\x04\x20\x03(\x0b2\x0e.CMsgColorStopR\tcolorStop\"\xba\x01\n\x0cCM\
    sgParticle\x127\n\x11particle_position\x18\x01\x20\x01(\x0b2\n.CMsgPoint\
    R\x10particlePosition\x12#\n\rparticle_size\x18\x02\x20\x01(\x02R\x0cpar\
    ticleSize\x12-\n\x12particle_sharpness\x18\x03\x20\x01(\x02R\x11particle\
    Sharpness\x12\x1d\n\ncolor_rgba\x18\x04\x20\x01(\rR\tcolorRgba\"\xc4\x0b\
    \n\x12CMsgParticleSystem\x12/\n\rbase_position\x18\x01\x20\x01(\x0b2\n.C\
    MsgPointR\x0cbasePosition\x12@\n\x16base_position_variance\x18\x02\x20\
    \x01(\x0b2\n.CMsgPointR\x14basePositionVariance\x12#\n\rparticle_size\
    \x18\x03\x20\x01(\x01R\x0cparticleSize\x124\n\x16particle_size_variance\
    \x18\x04\x20\x01(\x01R\x14particleSizeVariance\x120\n\x14particles_per_s\
    econd\x18\x05\x20\x01(\x01R\x12particlesPerSecond\x12A\n\x1dparticles_pe\
    r_second_variance\x18\x06\x20\x01(\x01R\x1aparticlesPerSecondVariance\
    \x12:\n\x19particle_lifespan_seconds\x18\x07\x20\x01(\x01R\x17particleLi\
    fespanSeconds\x12K\n\"particle_lifespan_seconds_variance\x18\x08\x20\x01\
    (\x01R\x1fparticleLifespanSecondsVariance\x12F\n\x19particle_initial_vel\
    ocity\x18\t\x20\x01(\x0b2\n.CMsgPointR\x17particleInitialVelocity\x12W\n\
    \"particle_initial_velocity_variance\x18\n\x20\x01(\x0b2\n.CMsgPointR\
    \x1fparticleInitialVelocityVariance\x12=\n\x14gravity_acceleration\x18\
    \x0b\x20\x01(\x0b2\n.CMsgPointR\x13gravityAcceleration\x12_\n&gravity_ac\
    celeration_particle_variance\x18\x0c\x20\x01(\x0b2\n.CMsgPointR#gravityA\
    ccelerationParticleVariance\x12(\n\x10color_start_rgba\x18\r\x20\x01(\rR\
    \x0ecolorStartRgba\x129\n\x19color_start_rgba_variance\x18\x0e\x20\x01(\
    \rR\x16colorStartRgbaVariance\x12$\n\x0ecolor_end_rgba\x18\x0f\x20\x01(\
    \rR\x0ccolorEndRgba\x125\n\x17color_end_rgba_variance\x18\x10\x20\x01(\r\
    R\x14colorEndRgbaVariance\x12.\n\x13parent_panel_handle\x18\x11\x20\x01(\
    \x04R\x11parentPanelHandle\x12,\n\x12parent_brush_index\x18\x12\x20\x01(\
    \rR\x10parentBrushIndex\x12-\n\x12particle_sharpness\x18\x13\x20\x01(\
    \x02R\x11particleSharpness\x12>\n\x1bparticle_sharpness_variance\x18\x14\
    \x20\x01(\x02R\x19particleSharpnessVariance\x12)\n\x10particle_flicker\
    \x18\x15\x20\x01(\x02R\x0fparticleFlicker\x12:\n\x19particle_flicker_var\
    iance\x18\x16\x20\x01(\x02R\x17particleFlickerVariance\x12>\n\x15particl\
    e_velocity_min\x18\x17\x20\x01(\x0b2\n.CMsgPointR\x13particleVelocityMin\
    \x12>\n\x15particle_velocity_max\x18\x18\x20\x01(\x0b2\n.CMsgPointR\x13p\
    articleVelocityMax\x12+\n\tparticles\x182\x20\x03(\x0b2\r.CMsgParticleR\
    \tparticles\"\x82\x02\n\rCMsgFillBrush\x12\x18\n\x07opacity\x18\x01\x20\
    \x01(\x01R\x07opacity\x12\x1d\n\ncolor_rgba\x18\x02\x20\x01(\rR\tcolorRg\
    ba\x12<\n\x0flinear_gradient\x18\x03\x20\x01(\x0b2\x13.CMsgLinearGradien\
    tR\x0elinearGradient\x12<\n\x0fradial_gradient\x18\x04\x20\x01(\x0b2\x13\
    .CMsgRadialGradientR\x0eradialGradient\x12<\n\x0fparticle_system\x18\x05\
    \x20\x01(\x0b2\x13.CMsgParticleSystemR\x0eparticleSystem\"\xb5\x03\n\x17\
    CMsgFillBrushCollection\x12\"\n\x04base\x18\x01\x20\x03(\x0b2\x0e.CMsgFi\
    llBrushR\x04base\x12.\n\ntransition\x18\x02\x20\x03(\x0b2\x0e.CMsgFillBr\
    ushR\ntransition\x12<\n\x0ftransition_data\x18\x03\x20\x01(\x0b2\x13.CMs\
    gTransitionDataR\x0etransitionData\x12!\n\x0cstyle_symbol\x18\x04\x20\
    \x01(\rR\x0bstyleSymbol\x122\n\nanimations\x18\x05\x20\x03(\x0b2\x12.CMs\
    gAnimationDataR\nanimations2w\n\x14animation_frame_data\x18\xef\x07\x20\
    \x01(\x0b2+.CMsgFillBrushCollection.AnimationFrameData\x12\x17.CMsgAnima\
    tionFrameDataR\x12animationFrameData\x1a8\n\x12AnimationFrameData\x12\"\
    \n\x04data\x18\x01\x20\x03(\x0b2\x0e.CMsgFillBrushR\x04data\"N\n\x1dCMsg\
    RenderFillBrushCollection\x12-\n\nfill_brush\x18\x01\x20\x03(\x0b2\x0e.C\
    MsgFillBrushR\tfillBrush\"\x96\x05\n\x11CMsgPanelPosition\x12\x1e\n\x04b\
    ase\x18\x01\x20\x01(\x0b2\n.CMsgPointR\x04base\x12*\n\ntransition\x18\
    \x02\x20\x01(\x0b2\n.CMsgPointR\ntransition\x12<\n\x0ftransition_data\
    \x18\x03\x20\x01(\x0b2\x13.CMsgTransitionDataR\x0etransitionData\x12!\n\
    \x0cstyle_symbol\x18\x04\x20\x01(\rR\x0bstyleSymbol\x122\n\nanimations\
    \x18\x05\x20\x03(\x0b2\x12.CMsgAnimationDataR\nanimations\x12/\n\rscroll\
    _offset\x18\x06\x20\x01(\x0b2\n.CMsgPointR\x0cscrollOffset\x12<\n\x14scr\
    oll_offset_target\x18\x07\x20\x01(\x0b2\n.CMsgPointR\x12scrollOffsetTarg\
    et\x12C\n\x13scroll_transition_x\x18\x08\x20\x01(\x0b2\x13.CMsgTransitio\
    nDataR\x11scrollTransitionX\x12C\n\x13scroll_transition_y\x18\t\x20\x01(\
    \x0b2\x13.CMsgTransitionDataR\x11scrollTransitionY2q\n\x14animation_fram\
    e_data\x18\xf3\x07\x20\x01(\x0b2%.CMsgPanelPosition.AnimationFrameData\
    \x12\x17.CMsgAnimationFrameDataR\x12animationFrameData\x1a4\n\x12Animati\
    onFrameData\x12\x1e\n\x04data\x18\x01\x20\x01(\x0b2\n.CMsgPointR\x04data\
    \"\xed\x02\n\x0bCMsgOpacity\x12\x12\n\x04base\x18\x01\x20\x01(\x01R\x04b\
    ase\x12\x1e\n\ntransition\x18\x02\x20\x01(\x01R\ntransition\x12<\n\x0ftr\
    ansition_data\x18\x03\x20\x01(\x0b2\x13.CMsgTransitionDataR\x0etransitio\
    nData\x12!\n\x0cstyle_symbol\x18\x04\x20\x01(\rR\x0bstyleSymbol\x122\n\n\
    animations\x18\x05\x20\x03(\x0b2\x12.CMsgAnimationDataR\nanimations2k\n\
    \x14animation_frame_data\x18\xec\x07\x20\x01(\x0b2\x1f.CMsgOpacity.Anima\
    tionFrameData\x12\x17.CMsgAnimationFrameDataR\x12animationFrameData\x1a(\
    \n\x12AnimationFrameData\x12\x12\n\x04data\x18\x01\x20\x01(\x01R\x04data\
    \"\xef\x02\n\x0cCMsgRotate2D\x12\x12\n\x04base\x18\x01\x20\x01(\x01R\x04\
    base\x12\x1e\n\ntransition\x18\x02\x20\x01(\x01R\ntransition\x12<\n\x0ft\
    ransition_data\x18\x03\x20\x01(\x0b2\x13.CMsgTransitionDataR\x0etransiti\
    onData\x12!\n\x0cstyle_symbol\x18\x04\x20\x01(\rR\x0bstyleSymbol\x122\n\
    \nanimations\x18\x05\x20\x03(\x0b2\x12.CMsgAnimationDataR\nanimations2l\
    \n\x14animation_frame_data\x18\xf6\x07\x20\x01(\x0b2\x20.CMsgRotate2D.An\
    imationFrameData\x12\x17.CMsgAnimationFrameDataR\x12animationFrameData\
    \x1a(\n\x12AnimationFrameData\x12\x12\n\x04data\x18\x01\x20\x01(\x01R\
    \x04data\"~\n\x13CMsgOpacityMaskData\x125\n\x17opacity_mask_texture_id\
    \x18\x01\x20\x01(\rR\x14opacityMaskTextureId\x120\n\x14opacity_mask_opac\
    ity\x18\x02\x20\x01(\x01R\x12opacityMaskOpacity\"\xb7\x03\n\x0fCMsgOpaci\
    tyMask\x12(\n\x04base\x18\x01\x20\x01(\x0b2\x14.CMsgOpacityMaskDataR\x04\
    base\x124\n\ntransition\x18\x02\x20\x01(\x0b2\x14.CMsgOpacityMaskDataR\n\
    transition\x12<\n\x0ftransition_data\x18\x03\x20\x01(\x0b2\x13.CMsgTrans\
    itionDataR\x0etransitionData\x12!\n\x0cstyle_symbol\x18\x04\x20\x01(\rR\
    \x0bstyleSymbol\x122\n\nanimations\x18\x05\x20\x03(\x0b2\x12.CMsgAnimati\
    onDataR\nanimations2o\n\x14animation_frame_data\x18\xf5\x07\x20\x01(\x0b\
    2#.CMsgOpacityMask.AnimationFrameData\x12\x17.CMsgAnimationFrameDataR\
    \x12animationFrameData\x1a>\n\x12AnimationFrameData\x12(\n\x04data\x18\
    \x01\x20\x01(\x0b2\x14.CMsgOpacityMaskDataR\x04data\"\xef\x02\n\x0cCMsgH\
    ueShift\x12\x12\n\x04base\x18\x01\x20\x01(\x01R\x04base\x12\x1e\n\ntrans\
    ition\x18\x02\x20\x01(\x01R\ntransition\x12<\n\x0ftransition_data\x18\
    \x03\x20\x01(\x0b2\x13.CMsgTransitionDataR\x0etransitionData\x12!\n\x0cs\
    tyle_symbol\x18\x04\x20\x01(\rR\x0bstyleSymbol\x122\n\nanimations\x18\
    \x05\x20\x03(\x0b2\x12.CMsgAnimationDataR\nanimations2l\n\x14animation_f\
    rame_data\x18\xfb\x07\x20\x01(\x0b2\x20.CMsgHueShift.AnimationFrameData\
    \x12\x17.CMsgAnimationFrameDataR\x12animationFrameData\x1a(\n\x12Animati\
    onFrameData\x12\x12\n\x04data\x18\x01\x20\x01(\x01R\x04data\"\xf3\x02\n\
    \x0eCMsgSaturation\x12\x12\n\x04base\x18\x01\x20\x01(\x01R\x04base\x12\
    \x1e\n\ntransition\x18\x02\x20\x01(\x01R\ntransition\x12<\n\x0ftransitio\
    n_data\x18\x03\x20\x01(\x0b2\x13.CMsgTransitionDataR\x0etransitionData\
    \x12!\n\x0cstyle_symbol\x18\x04\x20\x01(\rR\x0bstyleSymbol\x122\n\nanima\
    tions\x18\x05\x20\x03(\x0b2\x12.CMsgAnimationDataR\nanimations2n\n\x14an\
    imation_frame_data\x18\xed\x07\x20\x01(\x0b2\".CMsgSaturation.AnimationF\
    rameData\x12\x17.CMsgAnimationFrameDataR\x12animationFrameData\x1a(\n\
    \x12AnimationFrameData\x12\x12\n\x04data\x18\x01\x20\x01(\x01R\x04data\"\
    \xf3\x02\n\x0eCMsgBrightness\x12\x12\n\x04base\x18\x01\x20\x01(\x01R\x04\
    base\x12\x1e\n\ntransition\x18\x02\x20\x01(\x01R\ntransition\x12<\n\x0ft\
    ransition_data\x18\x03\x20\x01(\x0b2\x13.CMsgTransitionDataR\x0etransiti\
    onData\x12!\n\x0cstyle_symbol\x18\x04\x20\x01(\rR\x0bstyleSymbol\x122\n\
    \nanimations\x18\x05\x20\x03(\x0b2\x12.CMsgAnimationDataR\nanimations2n\
    \n\x14animation_frame_data\x18\xfc\x07\x20\x01(\x0b2\".CMsgBrightness.An\
    imationFrameData\x12\x17.CMsgAnimationFrameDataR\x12animationFrameData\
    \x1a(\n\x12AnimationFrameData\x12\x12\n\x04data\x18\x01\x20\x01(\x01R\
    \x04data\"\xef\x02\n\x0cCMsgContrast\x12\x12\n\x04base\x18\x01\x20\x01(\
    \x01R\x04base\x12\x1e\n\ntransition\x18\x02\x20\x01(\x01R\ntransition\
    \x12<\n\x0ftransition_data\x18\x03\x20\x01(\x0b2\x13.CMsgTransitionDataR\
    \x0etransitionData\x12!\n\x0cstyle_symbol\x18\x04\x20\x01(\rR\x0bstyleSy\
    mbol\x122\n\nanimations\x18\x05\x20\x03(\x0b2\x12.CMsgAnimationDataR\nan\
    imations2l\n\x14animation_frame_data\x18\xfd\x07\x20\x01(\x0b2\x20.CMsgC\
    ontrast.AnimationFrameData\x12\x17.CMsgAnimationFrameDataR\x12animationF\
    rameData\x1a(\n\x12AnimationFrameData\x12\x12\n\x04data\x18\x01\x20\x01(\
    \x01R\x04data\"j\n\x12CMsgGaussianValues\x12\x16\n\x06passes\x18\x01\x20\
    \x01(\x01R\x06passes\x12\x1d\n\nstddev_hor\x18\x02\x20\x01(\x01R\tstddev\
    Hor\x12\x1d\n\nstddev_ver\x18\x03\x20\x01(\x01R\tstddevVer\"\xb6\x03\n\
    \x10CMsgGaussianBlur\x12'\n\x04base\x18\x01\x20\x01(\x0b2\x13.CMsgGaussi\
    anValuesR\x04base\x123\n\ntransition\x18\x02\x20\x01(\x0b2\x13.CMsgGauss\
    ianValuesR\ntransition\x12<\n\x0ftransition_data\x18\x03\x20\x01(\x0b2\
    \x13.CMsgTransitionDataR\x0etransitionData\x12!\n\x0cstyle_symbol\x18\
    \x04\x20\x01(\rR\x0bstyleSymbol\x122\n\nanimations\x18\x05\x20\x03(\x0b2\
    \x12.CMsgAnimationDataR\nanimations2p\n\x14animation_frame_data\x18\xf0\
    \x07\x20\x01(\x0b2$.CMsgGaussianBlur.AnimationFrameData\x12\x17.CMsgAnim\
    ationFrameDataR\x12animationFrameData\x1a=\n\x12AnimationFrameData\x12'\
    \n\x04data\x18\x01\x20\x01(\x0b2\x13.CMsgGaussianValuesR\x04data\"Z\n\
    \x14CMsgMotionBlurValues\x12\x1a\n\x08velocity\x18\x01\x20\x01(\x01R\x08\
    velocity\x12\x12\n\x04dirx\x18\x02\x20\x01(\x01R\x04dirx\x12\x12\n\x04di\
    ry\x18\x03\x20\x01(\x01R\x04diry\"\xb8\x03\n\x0eCMsgMotionBlur\x12)\n\
    \x04base\x18\x01\x20\x01(\x0b2\x15.CMsgMotionBlurValuesR\x04base\x125\n\
    \ntransition\x18\x02\x20\x01(\x0b2\x15.CMsgMotionBlurValuesR\ntransition\
    \x12<\n\x0ftransition_data\x18\x03\x20\x01(\x0b2\x13.CMsgTransitionDataR\
    \x0etransitionData\x122\n\nanimations\x18\x04\x20\x03(\x0b2\x12.CMsgAnim\
    ationDataR\nanimations\x12!\n\x0cstyle_symbol\x18\x05\x20\x01(\rR\x0bsty\
    leSymbol2n\n\x14animation_frame_data\x18\xfe\x07\x20\x01(\x0b2\".CMsgMot\
    ionBlur.AnimationFrameData\x12\x17.CMsgAnimationFrameDataR\x12animationF\
    rameData\x1a?\n\x12AnimationFrameData\x12)\n\x04data\x18\x01\x20\x01(\
    \x0b2\x15.CMsgMotionBlurValuesR\x04data\"\x8b\x03\n\x1aCMsg3DTransformPe\
    rspective\x12\x12\n\x04base\x18\x01\x20\x01(\x01R\x04base\x12\x1e\n\ntra\
    nsition\x18\x02\x20\x01(\x01R\ntransition\x12<\n\x0ftransition_data\x18\
    \x03\x20\x01(\x0b2\x13.CMsgTransitionDataR\x0etransitionData\x12!\n\x0cs\
    tyle_symbol\x18\x04\x20\x01(\rR\x0bstyleSymbol\x122\n\nanimations\x18\
    \x05\x20\x03(\x0b2\x12.CMsgAnimationDataR\nanimations2z\n\x14animation_f\
    rame_data\x18\xeb\x07\x20\x01(\x0b2..CMsg3DTransformPerspective.Animatio\
    nFrameData\x12\x17.CMsgAnimationFrameDataR\x12animationFrameData\x1a(\n\
    \x12AnimationFrameData\x12\x12\n\x04data\x18\x01\x20\x01(\x01R\x04data\"\
    \xbc\x03\n\x20CMsg3DTransformPerspectiveOrigin\x12\x1e\n\x04base\x18\x01\
    \x20\x01(\x0b2\n.CMsgPointR\x04base\x12*\n\ntransition\x18\x02\x20\x01(\
    \x0b2\n.CMsgPointR\ntransition\x12<\n\x0ftransition_data\x18\x03\x20\x01\
    (\x0b2\x13.CMsgTransitionDataR\x0etransitionData\x12!\n\x0cstyle_symbol\
    \x18\x04\x20\x01(\rR\x0bstyleSymbol\x122\n\nanimations\x18\x05\x20\x03(\
    \x0b2\x12.CMsgAnimationDataR\nanimations2\x80\x01\n\x14animation_frame_d\
    ata\x18\xea\x07\x20\x01(\x0b24.CMsg3DTransformPerspectiveOrigin.Animatio\
    nFrameData\x12\x17.CMsgAnimationFrameDataR\x12animationFrameData\x1a4\n\
    \x12AnimationFrameData\x12\x1e\n\x04data\x18\x01\x20\x01(\x0b2\n.CMsgPoi\
    ntR\x04data\"\xa7\x01\n\x17CMsgTransformOriginData\x12\x0c\n\x01x\x18\
    \x01\x20\x01(\x01R\x01x\x12\x0c\n\x01y\x18\x02\x20\x01(\x01R\x01y\x12\
    \x20\n\x0cx_is_percent\x18\x03\x20\x01(\x08R\nxIsPercent\x12\x20\n\x0cy_\
    is_percent\x18\x04\x20\x01(\x08R\nyIsPercent\x12,\n\x12is_parent_relativ\
    e\x18\x05\x20\x01(\x08R\x10isParentRelative\"\xcf\x03\n\x15CMsg3DTransfo\
    rmOrigin\x12,\n\x04base\x18\x01\x20\x01(\x0b2\x18.CMsgTransformOriginDat\
    aR\x04base\x128\n\ntransition\x18\x02\x20\x01(\x0b2\x18.CMsgTransformOri\
    ginDataR\ntransition\x12<\n\x0ftransition_data\x18\x03\x20\x01(\x0b2\x13\
    .CMsgTransitionDataR\x0etransitionData\x12!\n\x0cstyle_symbol\x18\x04\
    \x20\x01(\rR\x0bstyleSymbol\x122\n\nanimations\x18\x05\x20\x03(\x0b2\x12\
    .CMsgAnimationDataR\nanimations2u\n\x14animation_frame_data\x18\xf7\x07\
    \x20\x01(\x0b2).CMsg3DTransformOrigin.AnimationFrameData\x12\x17.CMsgAni\
    mationFrameDataR\x12animationFrameData\x1aB\n\x12AnimationFrameData\x12,\
    \n\x04data\x18\x01\x20\x01(\x0b2\x18.CMsgTransformOriginDataR\x04data\"\
    \xb1\x03\n\x15CMsg3DTransformMatrix\x12\"\n\x04base\x18\x01\x20\x01(\x0b\
    2\x0e.CMsgMatrix4x4R\x04base\x12<\n\x0ftransition_data\x18\x02\x20\x01(\
    \x0b2\x13.CMsgTransitionDataR\x0etransitionData\x12.\n\ntransition\x18\
    \x03\x20\x01(\x0b2\x0e.CMsgMatrix4x4R\ntransition\x12!\n\x0cstyle_symbol\
    \x18\x04\x20\x01(\rR\x0bstyleSymbol\x122\n\nanimations\x18\x05\x20\x03(\
    \x0b2\x12.CMsgAnimationDataR\nanimations2u\n\x14animation_frame_data\x18\
    \xe8\x07\x20\x01(\x0b2).CMsg3DTransformMatrix.AnimationFrameData\x12\x17\
    .CMsgAnimationFrameDataR\x12animationFrameData\x1a8\n\x12AnimationFrameD\
    ata\x12\"\n\x04data\x18\x01\x20\x01(\x0b2\x0e.CMsgMatrix4x4R\x04data\"\
    \xa1\x03\n\x10CMsgBorderRadius\x12\x20\n\x04base\x18\x01\x20\x01(\x0b2\
    \x0c.CRadiusDataR\x04base\x12<\n\x0ftransition_data\x18\x02\x20\x01(\x0b\
    2\x13.CMsgTransitionDataR\x0etransitionData\x12,\n\ntransition\x18\x03\
    \x20\x01(\x0b2\x0c.CRadiusDataR\ntransition\x12!\n\x0cstyle_symbol\x18\
    \x04\x20\x01(\rR\x0bstyleSymbol\x122\n\nanimations\x18\x05\x20\x03(\x0b2\
    \x12.CMsgAnimationDataR\nanimations2p\n\x14animation_frame_data\x18\xee\
    \x07\x20\x01(\x0b2$.CMsgBorderRadius.AnimationFrameData\x12\x17.CMsgAnim\
    ationFrameDataR\x12animationFrameData\x1a6\n\x12AnimationFrameData\x12\
    \x20\n\x04data\x18\x01\x20\x01(\x0b2\x0c.CRadiusDataR\x04data\"\x95\x03\
    \n\nCMsgBorder\x12\x20\n\x04base\x18\x01\x20\x01(\x0b2\x0c.CBorderDataR\
    \x04base\x12<\n\x0ftransition_data\x18\x02\x20\x01(\x0b2\x13.CMsgTransit\
    ionDataR\x0etransitionData\x12,\n\ntransition\x18\x03\x20\x01(\x0b2\x0c.\
    CBorderDataR\ntransition\x12!\n\x0cstyle_symbol\x18\x04\x20\x01(\rR\x0bs\
    tyleSymbol\x122\n\nanimations\x18\x05\x20\x03(\x0b2\x12.CMsgAnimationDat\
    aR\nanimations2j\n\x14animation_frame_data\x18\xf1\x07\x20\x01(\x0b2\x1e\
    .CMsgBorder.AnimationFrameData\x12\x17.CMsgAnimationFrameDataR\x12animat\
    ionFrameData\x1a6\n\x12AnimationFrameData\x12\x20\n\x04data\x18\x01\x20\
    \x01(\x0b2\x0c.CBorderDataR\x04data\"\xa4\x03\n\rCMsgBoxShadow\x12#\n\
    \x04base\x18\x01\x20\x01(\x0b2\x0f.CBoxShadowDataR\x04base\x12<\n\x0ftra\
    nsition_data\x18\x02\x20\x01(\x0b2\x13.CMsgTransitionDataR\x0etransition\
    Data\x12/\n\ntransition\x18\x03\x20\x01(\x0b2\x0f.CBoxShadowDataR\ntrans\
    ition\x12!\n\x0cstyle_symbol\x18\x04\x20\x01(\rR\x0bstyleSymbol\x122\n\n\
    animations\x18\x05\x20\x03(\x0b2\x12.CMsgAnimationDataR\nanimations2m\n\
    \x14animation_frame_data\x18\xf2\x07\x20\x01(\x0b2!.CMsgBoxShadow.Animat\
    ionFrameData\x12\x17.CMsgAnimationFrameDataR\x12animationFrameData\x1a9\
    \n\x12AnimationFrameData\x12#\n\x04data\x18\x01\x20\x01(\x0b2\x0f.CBoxSh\
    adowDataR\x04data\"\xa9\x03\n\x0eCMsgTextShadow\x12$\n\x04base\x18\x01\
    \x20\x01(\x0b2\x10.CTextShadowDataR\x04base\x12<\n\x0ftransition_data\
    \x18\x02\x20\x01(\x0b2\x13.CMsgTransitionDataR\x0etransitionData\x120\n\
    \ntransition\x18\x03\x20\x01(\x0b2\x10.CTextShadowDataR\ntransition\x12!\
    \n\x0cstyle_symbol\x18\x04\x20\x01(\rR\x0bstyleSymbol\x122\n\nanimations\
    \x18\x05\x20\x03(\x0b2\x12.CMsgAnimationDataR\nanimations2n\n\x14animati\
    on_frame_data\x18\xf9\x07\x20\x01(\x0b2\".CMsgTextShadow.AnimationFrameD\
    ata\x12\x17.CMsgAnimationFrameDataR\x12animationFrameData\x1a:\n\x12Anim\
    ationFrameData\x12$\n\x04data\x18\x01\x20\x01(\x0b2\x10.CTextShadowDataR\
    \x04data\"\x94\x03\n\x08CMsgClip\x12!\n\x04base\x18\x01\x20\x01(\x0b2\r.\
    CMsgClipDataR\x04base\x12<\n\x0ftransition_data\x18\x02\x20\x01(\x0b2\
    \x13.CMsgTransitionDataR\x0etransitionData\x12-\n\ntransition\x18\x03\
    \x20\x01(\x0b2\r.CMsgClipDataR\ntransition\x12!\n\x0cstyle_symbol\x18\
    \x04\x20\x01(\rR\x0bstyleSymbol\x122\n\nanimations\x18\x05\x20\x03(\x0b2\
    \x12.CMsgAnimationDataR\nanimations2h\n\x14animation_frame_data\x18\xfa\
    \x07\x20\x01(\x0b2\x1c.CMsgClip.AnimationFrameData\x12\x17.CMsgAnimation\
    FrameDataR\x12animationFrameData\x1a7\n\x12AnimationFrameData\x12!\n\x04\
    data\x18\x01\x20\x01(\x0b2\r.CMsgClipDataR\x04data\"\x9c\x01\n\x11CMsgPu\
    shClipLayer\x12%\n\x08top_left\x18\x01\x20\x01(\x0b2\n.CMsgPointR\x07top\
    Left\x12-\n\x0cbottom_right\x18\x02\x20\x01(\x0b2\n.CMsgPointR\x0bbottom\
    Right\x121\n\rborder_radius\x18\x03\x20\x01(\x0b2\x0c.CRadiusDataR\x0cbo\
    rderRadius\"\x12\n\x10CMsgPopClipLayer\"\x84\x07\n\x1bCMsgPushPanelConte\
    xtInLayer\x12#\n\rtransform_m00\x18\x01\x20\x01(\x01R\x0ctransformM00\
    \x12#\n\rtransform_m01\x18\x02\x20\x01(\x01R\x0ctransformM01\x12#\n\rtra\
    nsform_m02\x18\x03\x20\x01(\x01R\x0ctransformM02\x12#\n\rtransform_m03\
    \x18\x04\x20\x01(\x01R\x0ctransformM03\x12#\n\rtransform_m10\x18\x05\x20\
    \x01(\x01R\x0ctransformM10\x12#\n\rtransform_m11\x18\x06\x20\x01(\x01R\
    \x0ctransformM11\x12#\n\rtransform_m12\x18\x07\x20\x01(\x01R\x0ctransfor\
    mM12\x12#\n\rtransform_m13\x18\x08\x20\x01(\x01R\x0ctransformM13\x12#\n\
    \rtransform_m20\x18\t\x20\x01(\x01R\x0ctransformM20\x12#\n\rtransform_m2\
    1\x18\n\x20\x01(\x01R\x0ctransformM21\x12#\n\rtransform_m22\x18\x0b\x20\
    \x01(\x01R\x0ctransformM22\x12#\n\rtransform_m23\x18\x0c\x20\x01(\x01R\
    \x0ctransformM23\x12#\n\rtransform_m30\x18\r\x20\x01(\x01R\x0ctransformM\
    30\x12#\n\rtransform_m31\x18\x0e\x20\x01(\x01R\x0ctransformM31\x12#\n\rt\
    ransform_m32\x18\x0f\x20\x01(\x01R\x0ctransformM32\x12#\n\rtransform_m33\
    \x18\x10\x20\x01(\x01R\x0ctransformM33\x12.\n\nbox_shadow\x18\x11\x20\
    \x01(\x0b2\x0f.CBoxShadowDataR\tboxShadow\x12\x14\n\x05width\x18\x12\x20\
    \x01(\x01R\x05width\x12\x16\n\x06height\x18\x13\x20\x01(\x01R\x06height\
    \x12\x1d\n\nposition_x\x18\x14\x20\x01(\x01R\tpositionX\x12\x1d\n\nposit\
    ion_y\x18\x15\x20\x01(\x01R\tpositionY\x12\x1d\n\nposition_z\x18\x16\x20\
    \x01(\x01R\tpositionZ\x12$\n\x06border\x18\x17\x20\x01(\x0b2\x0c.CBorder\
    DataR\x06border\x12\x19\n\x08scroll_x\x18\x18\x20\x01(\x01R\x07scrollX\
    \x12\x19\n\x08scroll_y\x18\x19\x20\x01(\x01R\x07scrollY\"\x1c\n\x1aCMsgP\
    opPanelContextInLayer\"\xf3\x0e\n\x14CMsgPushAAndTContext\x12\x1d\n\ncon\
    text_id\x18\x01\x20\x01(\x04R\tcontextId\x12\x14\n\x05width\x18\x03\x20\
    \x01(\x01R\x05width\x12\x16\n\x06height\x18\x04\x20\x01(\x01R\x06height\
    \x12:\n\x19chilren_have_3dtransforms\x18\x05\x20\x01(\x08R\x17chilrenHav\
    e3dtransforms\x12\x16\n\x06zindex\x18\x06\x20\x01(\x02R\x06zindex\x129\n\
    \x0epanel_position\x18\x07\x20\x01(\x0b2\x12.CMsgPanelPositionR\rpanelPo\
    sition\x12A\n\x10transform_matrix\x18\x08\x20\x01(\x0b2\x16.CMsg3DTransf\
    ormMatrixR\x0ftransformMatrix\x12A\n\x10transform_origin\x18\t\x20\x01(\
    \x0b2\x16.CMsg3DTransformOriginR\x0ftransformOrigin\x12P\n\x15transform_\
    perspective\x18\n\x20\x01(\x0b2\x1b.CMsg3DTransformPerspectiveR\x14trans\
    formPerspective\x12c\n\x1ctransform_perspective_origin\x18\x0b\x20\x01(\
    \x0b2!.CMsg3DTransformPerspectiveOriginR\x1atransformPerspectiveOrigin\
    \x12&\n\x07opacity\x18\x0c\x20\x01(\x0b2\x0c.CMsgOpacityR\x07opacity\x12\
    )\n\nwash_color\x18\r\x20\x01(\x0b2\n.CMsgColorR\twashColor\x12*\n\thue_\
    shift\x18\x0e\x20\x01(\x0b2\r.CMsgHueShiftR\x08hueShift\x12/\n\nsaturati\
    on\x18\x0f\x20\x01(\x0b2\x0f.CMsgSaturationR\nsaturation\x12/\n\nbrightn\
    ess\x18\x10\x20\x01(\x0b2\x0f.CMsgBrightnessR\nbrightness\x12)\n\x08cont\
    rast\x18\x11\x20\x01(\x0b2\r.CMsgContrastR\x08contrast\x123\n\x0copacity\
    _mask\x18\x12\x20\x01(\x0b2\x10.CMsgOpacityMaskR\x0bopacityMask\x126\n\r\
    border_radius\x18\x13\x20\x01(\x0b2\x11.CMsgBorderRadiusR\x0cborderRadiu\
    s\x126\n\rgaussian_blur\x18\x14\x20\x01(\x0b2\x11.CMsgGaussianBlurR\x0cg\
    aussianBlur\x12#\n\x06border\x18\x15\x20\x01(\x0b2\x0b.CMsgBorderR\x06bo\
    rder\x12-\n\nbox_shadow\x18\x16\x20\x01(\x0b2\x0e.CMsgBoxShadowR\tboxSha\
    dow\x12D\n\x11scale_2d_centered\x18\x17\x20\x01(\x0b2\x18.CMsgPointWithT\
    ransitionR\x0fscale2dCentered\x12;\n\x12rotate_2d_centered\x18\x18\x20\
    \x01(\x0b2\r.CMsgRotate2DR\x10rotate2dCentered\x120\n\x0btext_shadow\x18\
    \x19\x20\x01(\x0b2\x0f.CMsgTextShadowR\ntextShadow\x12\x1d\n\x04clip\x18\
    \x1a\x20\x01(\x0b2\t.CMsgClipR\x04clip\x125\n\x17suppress_clip_to_bounds\
    \x18\x1b\x20\x01(\x08R\x14suppressClipToBounds\x12,\n\x12needs_full_repa\
    int\x18\x1c\x20\x01(\x05R\x10needsFullRepaint\x12<\n\x1aneeds_intermedia\
    te_texture\x18\x1d\x20\x01(\x08R\x18needsIntermediateTexture\x120\n\x14c\
    lip_after_transform\x18\x1e\x20\x01(\x08R\x12clipAfterTransform\x12$\n\
    \x0ewants_hit_test\x18\x1f\x20\x01(\x08R\x0cwantsHitTest\x125\n\x17wants\
    _hit_test_children\x18\x20\x20\x01(\x08R\x14wantsHitTestChildren\x12$\n\
    \x0emix_blend_mode\x18!\x20\x01(\rR\x0cmixBlendMode\x12+\n\x11opaque_bac\
    kground\x18\"\x20\x01(\x08R\x10opaqueBackground\x12*\n\x11child_panel_co\
    unt\x18#\x20\x01(\rR\x0fchildPanelCount\x12A\n\x1dwants_screenspace_quad\
    _output\x18$\x20\x01(\x08R\x1awantsScreenspaceQuadOutput\x120\n\x0bmotio\
    n_blur\x18%\x20\x01(\x0b2\x0f.CMsgMotionBlurR\nmotionBlur\x12C\n\x1ecomp\
    osition_layer_texture_name\x18&\x20\x01(\tR\x1bcompositionLayerTextureNa\
    me\"4\n\x13CMsgPopAAndTContext\x12\x1d\n\ncontext_id\x18\x01\x20\x01(\
    \x04R\tcontextId\"\x1a\n\x18CMsgBeginPaintBackground\"\x18\n\x16CMsgEndP\
    aintBackground\"\x14\n\x12CMsgBeginPaintLast\"\x12\n\x10CMsgEndPaintLast\
    \"\xdc\x01\n\x12CMsgDrawFilledRect\x12%\n\x08top_left\x18\x01\x20\x01(\
    \x0b2\n.CMsgPointR\x07topLeft\x12-\n\x0cbottom_right\x18\x02\x20\x01(\
    \x0b2\n.CMsgPointR\x0bbottomRight\x12L\n\x15fill_brush_collection\x18\
    \x03\x20\x01(\x0b2\x18.CMsgFillBrushCollectionR\x13fillBrushCollection\
    \x12\"\n\x0cantialiasing\x18\x04\x20\x01(\rR\x0cantialiasing\"\xe4\x01\n\
    \x14CMsgRenderFilledRect\x12%\n\x08top_left\x18\x01\x20\x01(\x0b2\n.CMsg\
    PointR\x07topLeft\x12-\n\x0cbottom_right\x18\x02\x20\x01(\x0b2\n.CMsgPoi\
    ntR\x0bbottomRight\x12R\n\x15fill_brush_collection\x18\x03\x20\x01(\x0b2\
    \x1e.CMsgRenderFillBrushCollectionR\x13fillBrushCollection\x12\"\n\x0can\
    tialiasing\x18\x04\x20\x01(\rR\x0cantialiasing\"\x93\x03\n\x14CMsgDrawTe\
    xturedRect\x12%\n\x08top_left\x18\x01\x20\x01(\x0b2\n.CMsgPointR\x07topL\
    eft\x12-\n\x0cbottom_right\x18\x02\x20\x01(\x0b2\n.CMsgPointR\x0bbottomR\
    ight\x12\x1d\n\ntexture_id\x18\x03\x20\x01(\rR\ttextureId\x124\n\x10text\
    ure_top_left\x18\x04\x20\x01(\x0b2\n.CMsgPointR\x0etextureTopLeft\x12<\n\
    \x14texture_bottom_right\x18\x05\x20\x01(\x0b2\n.CMsgPointR\x12textureBo\
    ttomRight\x12(\n\x0etexture_serial\x18\x06\x20\x01(\x05:\x010R\rtextureS\
    erial\x121\n\x13texture_sample_mode\x18\x07\x20\x01(\r:\x010R\x11texture\
    SampleMode\x125\n\x0ftexture_opacity\x18\x08\x20\x01(\x0b2\x0c.CMsgOpaci\
    tyR\x0etextureOpacity\"\x8a\x03\n\x16CMsgRenderTexturedRect\x12%\n\x08to\
    p_left\x18\x01\x20\x01(\x0b2\n.CMsgPointR\x07topLeft\x12-\n\x0cbottom_ri\
    ght\x18\x02\x20\x01(\x0b2\n.CMsgPointR\x0bbottomRight\x12\x1d\n\ntexture\
    _id\x18\x03\x20\x01(\rR\ttextureId\x124\n\x10texture_top_left\x18\x04\
    \x20\x01(\x0b2\n.CMsgPointR\x0etextureTopLeft\x12<\n\x14texture_bottom_r\
    ight\x18\x05\x20\x01(\x0b2\n.CMsgPointR\x12textureBottomRight\x12(\n\x0e\
    texture_serial\x18\x06\x20\x01(\x05:\x010R\rtextureSerial\x121\n\x13text\
    ure_sample_mode\x18\x07\x20\x01(\r:\x010R\x11textureSampleMode\x12*\n\
    \x0ftexture_opacity\x18\x08\x20\x01(\x02:\x011R\x0etextureOpacity\"Z\n\
    \x0fCMsgLockTexture\x12\x1d\n\ntexture_id\x18\x01\x20\x01(\rR\ttextureId\
    \x12(\n\x0etexture_serial\x18\x02\x20\x01(\x05:\x010R\rtextureSerial\"D\
    \n\x14CMsgTextInlineObject\x12\x14\n\x05width\x18\x01\x20\x01(\x02R\x05w\
    idth\x12\x16\n\x06height\x18\x02\x20\x01(\x02R\x06height\"\x8a\x03\n\x0e\
    CMsgTextFormat\x12\x1b\n\tfont_name\x18\x01\x20\x01(\tR\x08fontName\x12\
    \x1b\n\tfont_size\x18\x02\x20\x01(\x01R\x08fontSize\x12#\n\x0bfont_weigh\
    t\x18\x03\x20\x01(\x05:\x02-1R\nfontWeight\x12!\n\nfont_style\x18\x04\
    \x20\x01(\x05:\x02-1R\tfontStyle\x12\x1c\n\tunderline\x18\x05\x20\x01(\
    \x08R\tunderline\x12$\n\rstrikethrough\x18\x06\x20\x01(\x08R\rstrikethro\
    ugh\x12L\n\x15fill_brush_collection\x18\x07\x20\x01(\x0b2\x18.CMsgFillBr\
    ushCollectionR\x13fillBrushCollection\x12(\n\x0eletter_spacing\x18\x08\
    \x20\x01(\x05:\x010R\rletterSpacing\x12:\n\rinline_object\x18\t\x20\x01(\
    \x0b2\x15.CMsgTextInlineObjectR\x0cinlineObject\"|\n\x13CMsgTextRangeFor\
    mat\x12\x1f\n\x0bstart_index\x18\x01\x20\x01(\rR\nstartIndex\x12\x1b\n\t\
    end_index\x18\x02\x20\x01(\rR\x08endIndex\x12'\n\x06format\x18\x03\x20\
    \x01(\x0b2\x0f.CMsgTextFormatR\x06format\"\x96\x03\n\x14CMsgRenderTextFo\
    rmat\x12\x1b\n\tfont_name\x18\x01\x20\x01(\tR\x08fontName\x12\x1b\n\tfon\
    t_size\x18\x02\x20\x01(\x01R\x08fontSize\x12#\n\x0bfont_weight\x18\x03\
    \x20\x01(\x05:\x02-1R\nfontWeight\x12!\n\nfont_style\x18\x04\x20\x01(\
    \x05:\x02-1R\tfontStyle\x12\x1c\n\tunderline\x18\x05\x20\x01(\x08R\tunde\
    rline\x12$\n\rstrikethrough\x18\x06\x20\x01(\x08R\rstrikethrough\x12R\n\
    \x15fill_brush_collection\x18\x07\x20\x01(\x0b2\x1e.CMsgRenderFillBrushC\
    ollectionR\x13fillBrushCollection\x12(\n\x0eletter_spacing\x18\x08\x20\
    \x01(\x05:\x010R\rletterSpacing\x12:\n\rinline_object\x18\t\x20\x01(\x0b\
    2\x15.CMsgTextInlineObjectR\x0cinlineObject\"\x88\x01\n\x19CMsgRenderTex\
    tRangeFormat\x12\x1f\n\x0bstart_index\x18\x01\x20\x01(\rR\nstartIndex\
    \x12\x1b\n\tend_index\x18\x02\x20\x01(\rR\x08endIndex\x12-\n\x06format\
    \x18\x03\x20\x01(\x0b2\x15.CMsgRenderTextFormatR\x06format\"\xb4\x03\n\
    \x12CMsgDrawTextRegion\x12\x19\n\x08raw_text\x18\x0b\x20\x01(\x0cR\x07ra\
    wText\x12\x1d\n\ntext_chars\x18\x0c\x20\x01(\x05R\ttextChars\x12#\n\rtex\
    t_encoding\x18\r\x20\x01(\x05R\x0ctextEncoding\x126\n\x0edefault_format\
    \x18\x03\x20\x01(\x0b2\x0f.CMsgTextFormatR\rdefaultFormat\x12\x1d\n\ntex\
    t_align\x18\x04\x20\x01(\rR\ttextAlign\x12\x1f\n\x0bline_height\x18\x05\
    \x20\x01(\rR\nlineHeight\x12%\n\x08top_left\x18\x06\x20\x01(\x0b2\n.CMsg\
    PointR\x07topLeft\x12-\n\x0cbottom_right\x18\x07\x20\x01(\x0b2\n.CMsgPoi\
    ntR\x0bbottomRight\x12\x1a\n\x08wrapping\x18\x08\x20\x01(\x08R\x08wrappi\
    ng\x12\x1a\n\x08ellipsis\x18\t\x20\x01(\x08R\x08ellipsis\x129\n\rrange_f\
    ormats\x18\n\x20\x03(\x0b2\x14.CMsgTextRangeFormatR\x0crangeFormats\"\
    \xf5\x03\n\x14CMsgRenderTextRegion\x12\x19\n\x08raw_text\x18\x0c\x20\x01\
    (\x0cR\x07rawText\x12\x1d\n\ntext_chars\x18\r\x20\x01(\x05R\ttextChars\
    \x12#\n\rtext_encoding\x18\x0e\x20\x01(\x05R\x0ctextEncoding\x12<\n\x0ed\
    efault_format\x18\x03\x20\x01(\x0b2\x15.CMsgRenderTextFormatR\rdefaultFo\
    rmat\x12\x1d\n\ntext_align\x18\x04\x20\x01(\rR\ttextAlign\x12\x1f\n\x0bl\
    ine_height\x18\x05\x20\x01(\rR\nlineHeight\x12%\n\x08top_left\x18\x06\
    \x20\x01(\x0b2\n.CMsgPointR\x07topLeft\x12-\n\x0cbottom_right\x18\x07\
    \x20\x01(\x0b2\n.CMsgPointR\x0bbottomRight\x12\x1a\n\x08wrapping\x18\x08\
    \x20\x01(\x08R\x08wrapping\x12\x1a\n\x08ellipsis\x18\t\x20\x01(\x08R\x08\
    ellipsis\x12?\n\rrange_formats\x18\n\x20\x03(\x0b2\x1a.CMsgRenderTextRan\
    geFormatR\x0crangeFormats\x121\n\x0btext_shadow\x18\x0b\x20\x01(\x0b2\
    \x10.CTextShadowDataR\ntextShadow\"\xc1\x02\n\x19CMsgRequestRenderCallba\
    ck\x12!\n\x0ccallback_obj\x18\x01\x20\x01(\x0cR\x0bcallbackObj\x12%\n\
    \x08top_left\x18\x02\x20\x01(\x0b2\n.CMsgPointR\x07topLeft\x12-\n\x0cbot\
    tom_right\x18\x03\x20\x01(\x0b2\n.CMsgPointR\x0bbottomRight\x124\n\x10to\
    p_left_padding\x18\x04\x20\x01(\x0b2\n.CMsgPointR\x0etopLeftPadding\x12<\
    \n\x14bottom_right_padding\x18\x05\x20\x01(\x0b2\n.CMsgPointR\x12bottomR\
    ightPadding\x127\n\x18needs_redraw_every_frame\x18\x06\x20\x01(\x08R\x15\
    needsRedrawEveryFrameB\x05H\x01\x80\x01\0J\x9e\xcc\x02\n\x07\x12\x05\0\0\
    \xfc\x06\x01\n\x08\n\x01\x08\x12\x03\0\0\x1c\n\t\n\x02\x08\t\x12\x03\0\0\
    \x1c\n\x08\n\x01\x08\x12\x03\x01\0#\n\t\n\x02\x08\x10\x12\x03\x01\0#\n\n\
    \n\x02\x04\0\x12\x04\x03\0\x0b\x01\n\n\n\x03\x04\0\x01\x12\x03\x03\x08\
    \x16\n\x0b\n\x04\x04\0\x02\0\x12\x03\x04\x08-\n\x0c\n\x05\x04\0\x02\0\
    \x04\x12\x03\x04\x08\x10\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x04\x11\x17\
    \n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x04\x18(\n\x0c\n\x05\x04\0\x02\0\
    \x03\x12\x03\x04+,\n\x0b\n\x04\x04\0\x02\x01\x12\x03\x05\x08*\n\x0c\n\
    \x05\x04\0\x02\x01\x04\x12\x03\x05\x08\x10\n\x0c\n\x05\x04\0\x02\x01\x05\
    \x12\x03\x05\x11\x17\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x05\x18%\n\
    \x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x05()\n\x0b\n\x04\x04\0\x02\x02\x12\
    \x03\x06\x08+\n\x0c\n\x05\x04\0\x02\x02\x04\x12\x03\x06\x08\x10\n\x0c\n\
    \x05\x04\0\x02\x02\x05\x12\x03\x06\x11\x17\n\x0c\n\x05\x04\0\x02\x02\x01\
    \x12\x03\x06\x18&\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03\x06)*\n\x0b\n\
    \x04\x04\0\x02\x03\x12\x03\x07\x08*\n\x0c\n\x05\x04\0\x02\x03\x04\x12\
    \x03\x07\x08\x10\n\x0c\n\x05\x04\0\x02\x03\x05\x12\x03\x07\x11\x17\n\x0c\
    \n\x05\x04\0\x02\x03\x01\x12\x03\x07\x18%\n\x0c\n\x05\x04\0\x02\x03\x03\
    \x12\x03\x07()\n\x0b\n\x04\x04\0\x02\x04\x12\x03\x08\x08,\n\x0c\n\x05\
    \x04\0\x02\x04\x04\x12\x03\x08\x08\x10\n\x0c\n\x05\x04\0\x02\x04\x05\x12\
    \x03\x08\x11\x17\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03\x08\x18'\n\x0c\n\
    \x05\x04\0\x02\x04\x03\x12\x03\x08*+\n\x0b\n\x04\x04\0\x02\x05\x12\x03\t\
    \x08&\n\x0c\n\x05\x04\0\x02\x05\x04\x12\x03\t\x08\x10\n\x0c\n\x05\x04\0\
    \x02\x05\x05\x12\x03\t\x11\x15\n\x0c\n\x05\x04\0\x02\x05\x01\x12\x03\t\
    \x16!\n\x0c\n\x05\x04\0\x02\x05\x03\x12\x03\t$%\n\x0b\n\x04\x04\0\x02\
    \x06\x12\x03\n\x08;\n\x0c\n\x05\x04\0\x02\x06\x04\x12\x03\n\x08\x10\n\
    \x0c\n\x05\x04\0\x02\x06\x05\x12\x03\n\x11\x15\n\x0c\n\x05\x04\0\x02\x06\
    \x01\x12\x03\n\x166\n\x0c\n\x05\x04\0\x02\x06\x03\x12\x03\n9:\n\n\n\x02\
    \x04\x01\x12\x04\r\0\x11\x01\n\n\n\x03\x04\x01\x01\x12\x03\r\x08\x14\n\
    \x0b\n\x04\x04\x01\x02\0\x12\x03\x0e\x084\n\x0c\n\x05\x04\x01\x02\0\x04\
    \x12\x03\x0e\x08\x10\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03\x0e\x11\x17\n\
    \x0c\n\x05\x04\x01\x02\0\x01\x12\x03\x0e\x18/\n\x0c\n\x05\x04\x01\x02\0\
    \x03\x12\x03\x0e23\n\x0b\n\x04\x04\x01\x02\x01\x12\x03\x0f\x082\n\x0c\n\
    \x05\x04\x01\x02\x01\x04\x12\x03\x0f\x08\x10\n\x0c\n\x05\x04\x01\x02\x01\
    \x05\x12\x03\x0f\x11\x16\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\x0f\x17\
    -\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03\x0f01\n\x0b\n\x04\x04\x01\x02\
    \x02\x12\x03\x10\x082\n\x0c\n\x05\x04\x01\x02\x02\x04\x12\x03\x10\x08\
    \x10\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03\x10\x11\x16\n\x0c\n\x05\x04\
    \x01\x02\x02\x01\x12\x03\x10\x17-\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\
    \x03\x1001\n\n\n\x02\x04\x02\x12\x04\x13\0\x15\x01\n\n\n\x03\x04\x02\x01\
    \x12\x03\x13\x08\x1b\n\x0b\n\x04\x04\x02\x02\0\x12\x03\x14\x08-\n\x0c\n\
    \x05\x04\x02\x02\0\x04\x12\x03\x14\x08\x10\n\x0c\n\x05\x04\x02\x02\0\x05\
    \x12\x03\x14\x11\x17\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03\x14\x18(\n\
    \x0c\n\x05\x04\x02\x02\0\x03\x12\x03\x14+,\n\n\n\x02\x04\x03\x12\x04\x17\
    \0\x19\x01\n\n\n\x03\x04\x03\x01\x12\x03\x17\x08\x19\n\x0b\n\x04\x04\x03\
    \x02\0\x12\x03\x18\x08,\n\x0c\n\x05\x04\x03\x02\0\x04\x12\x03\x18\x08\
    \x10\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03\x18\x11\x17\n\x0c\n\x05\x04\
    \x03\x02\0\x01\x12\x03\x18\x18'\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03\
    \x18*+\n\n\n\x02\x04\x04\x12\x04\x1b\0\x1d\x01\n\n\n\x03\x04\x04\x01\x12\
    \x03\x1b\x08\x17\n\x0b\n\x04\x04\x04\x02\0\x12\x03\x1c\x08'\n\x0c\n\x05\
    \x04\x04\x02\0\x04\x12\x03\x1c\x08\x10\n\x0c\n\x05\x04\x04\x02\0\x05\x12\
    \x03\x1c\x11\x17\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03\x1c\x18\"\n\x0c\n\
    \x05\x04\x04\x02\0\x03\x12\x03\x1c%&\n\n\n\x02\x04\x05\x12\x04\x1f\0\"\
    \x01\n\n\n\x03\x04\x05\x01\x12\x03\x1f\x08\x20\n\x0b\n\x04\x04\x05\x02\0\
    \x12\x03\x20\x08)\n\x0c\n\x05\x04\x05\x02\0\x04\x12\x03\x20\x08\x10\n\
    \x0c\n\x05\x04\x05\x02\0\x05\x12\x03\x20\x11\x17\n\x0c\n\x05\x04\x05\x02\
    \0\x01\x12\x03\x20\x18$\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03\x20'(\n\
    \x0b\n\x04\x04\x05\x02\x01\x12\x03!\x08(\n\x0c\n\x05\x04\x05\x02\x01\x04\
    \x12\x03!\x08\x10\n\x0c\n\x05\x04\x05\x02\x01\x05\x12\x03!\x11\x17\n\x0c\
    \n\x05\x04\x05\x02\x01\x01\x12\x03!\x18#\n\x0c\n\x05\x04\x05\x02\x01\x03\
    \x12\x03!&'\n\n\n\x02\x04\x06\x12\x04$\0(\x01\n\n\n\x03\x04\x06\x01\x12\
    \x03$\x08\x11\n\x0b\n\x04\x04\x06\x02\0\x12\x03%\x08\x1e\n\x0c\n\x05\x04\
    \x06\x02\0\x04\x12\x03%\x08\x10\n\x0c\n\x05\x04\x06\x02\0\x05\x12\x03%\
    \x11\x17\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03%\x18\x19\n\x0c\n\x05\x04\
    \x06\x02\0\x03\x12\x03%\x1c\x1d\n\x0b\n\x04\x04\x06\x02\x01\x12\x03&\x08\
    \x1e\n\x0c\n\x05\x04\x06\x02\x01\x04\x12\x03&\x08\x10\n\x0c\n\x05\x04\
    \x06\x02\x01\x05\x12\x03&\x11\x17\n\x0c\n\x05\x04\x06\x02\x01\x01\x12\
    \x03&\x18\x19\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03&\x1c\x1d\n\x0b\n\
    \x04\x04\x06\x02\x02\x12\x03'\x08\x1e\n\x0c\n\x05\x04\x06\x02\x02\x04\
    \x12\x03'\x08\x10\n\x0c\n\x05\x04\x06\x02\x02\x05\x12\x03'\x11\x17\n\x0c\
    \n\x05\x04\x06\x02\x02\x01\x12\x03'\x18\x19\n\x0c\n\x05\x04\x06\x02\x02\
    \x03\x12\x03'\x1c\x1d\n\n\n\x02\x04\x07\x12\x04*\0;\x01\n\n\n\x03\x04\
    \x07\x01\x12\x03*\x08\x15\n\x0b\n\x04\x04\x07\x02\0\x12\x03+\x08\x20\n\
    \x0c\n\x05\x04\x07\x02\0\x04\x12\x03+\x08\x10\n\x0c\n\x05\x04\x07\x02\0\
    \x05\x12\x03+\x11\x17\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03+\x18\x1b\n\
    \x0c\n\x05\x04\x07\x02\0\x03\x12\x03+\x1e\x1f\n\x0b\n\x04\x04\x07\x02\
    \x01\x12\x03,\x08\x20\n\x0c\n\x05\x04\x07\x02\x01\x04\x12\x03,\x08\x10\n\
    \x0c\n\x05\x04\x07\x02\x01\x05\x12\x03,\x11\x17\n\x0c\n\x05\x04\x07\x02\
    \x01\x01\x12\x03,\x18\x1b\n\x0c\n\x05\x04\x07\x02\x01\x03\x12\x03,\x1e\
    \x1f\n\x0b\n\x04\x04\x07\x02\x02\x12\x03-\x08\x20\n\x0c\n\x05\x04\x07\
    \x02\x02\x04\x12\x03-\x08\x10\n\x0c\n\x05\x04\x07\x02\x02\x05\x12\x03-\
    \x11\x17\n\x0c\n\x05\x04\x07\x02\x02\x01\x12\x03-\x18\x1b\n\x0c\n\x05\
    \x04\x07\x02\x02\x03\x12\x03-\x1e\x1f\n\x0b\n\x04\x04\x07\x02\x03\x12\
    \x03.\x08\x20\n\x0c\n\x05\x04\x07\x02\x03\x04\x12\x03.\x08\x10\n\x0c\n\
    \x05\x04\x07\x02\x03\x05\x12\x03.\x11\x17\n\x0c\n\x05\x04\x07\x02\x03\
    \x01\x12\x03.\x18\x1b\n\x0c\n\x05\x04\x07\x02\x03\x03\x12\x03.\x1e\x1f\n\
    \x0b\n\x04\x04\x07\x02\x04\x12\x03/\x08\x20\n\x0c\n\x05\x04\x07\x02\x04\
    \x04\x12\x03/\x08\x10\n\x0c\n\x05\x04\x07\x02\x04\x05\x12\x03/\x11\x17\n\
    \x0c\n\x05\x04\x07\x02\x04\x01\x12\x03/\x18\x1b\n\x0c\n\x05\x04\x07\x02\
    \x04\x03\x12\x03/\x1e\x1f\n\x0b\n\x04\x04\x07\x02\x05\x12\x030\x08\x20\n\
    \x0c\n\x05\x04\x07\x02\x05\x04\x12\x030\x08\x10\n\x0c\n\x05\x04\x07\x02\
    \x05\x05\x12\x030\x11\x17\n\x0c\n\x05\x04\x07\x02\x05\x01\x12\x030\x18\
    \x1b\n\x0c\n\x05\x04\x07\x02\x05\x03\x12\x030\x1e\x1f\n\x0b\n\x04\x04\
    \x07\x02\x06\x12\x031\x08\x20\n\x0c\n\x05\x04\x07\x02\x06\x04\x12\x031\
    \x08\x10\n\x0c\n\x05\x04\x07\x02\x06\x05\x12\x031\x11\x17\n\x0c\n\x05\
    \x04\x07\x02\x06\x01\x12\x031\x18\x1b\n\x0c\n\x05\x04\x07\x02\x06\x03\
    \x12\x031\x1e\x1f\n\x0b\n\x04\x04\x07\x02\x07\x12\x032\x08\x20\n\x0c\n\
    \x05\x04\x07\x02\x07\x04\x12\x032\x08\x10\n\x0c\n\x05\x04\x07\x02\x07\
    \x05\x12\x032\x11\x17\n\x0c\n\x05\x04\x07\x02\x07\x01\x12\x032\x18\x1b\n\
    \x0c\n\x05\x04\x07\x02\x07\x03\x12\x032\x1e\x1f\n\x0b\n\x04\x04\x07\x02\
    \x08\x12\x033\x08\x20\n\x0c\n\x05\x04\x07\x02\x08\x04\x12\x033\x08\x10\n\
    \x0c\n\x05\x04\x07\x02\x08\x05\x12\x033\x11\x17\n\x0c\n\x05\x04\x07\x02\
    \x08\x01\x12\x033\x18\x1b\n\x0c\n\x05\x04\x07\x02\x08\x03\x12\x033\x1e\
    \x1f\n\x0b\n\x04\x04\x07\x02\t\x12\x034\x08!\n\x0c\n\x05\x04\x07\x02\t\
    \x04\x12\x034\x08\x10\n\x0c\n\x05\x04\x07\x02\t\x05\x12\x034\x11\x17\n\
    \x0c\n\x05\x04\x07\x02\t\x01\x12\x034\x18\x1b\n\x0c\n\x05\x04\x07\x02\t\
    \x03\x12\x034\x1e\x20\n\x0b\n\x04\x04\x07\x02\n\x12\x035\x08!\n\x0c\n\
    \x05\x04\x07\x02\n\x04\x12\x035\x08\x10\n\x0c\n\x05\x04\x07\x02\n\x05\
    \x12\x035\x11\x17\n\x0c\n\x05\x04\x07\x02\n\x01\x12\x035\x18\x1b\n\x0c\n\
    \x05\x04\x07\x02\n\x03\x12\x035\x1e\x20\n\x0b\n\x04\x04\x07\x02\x0b\x12\
    \x036\x08!\n\x0c\n\x05\x04\x07\x02\x0b\x04\x12\x036\x08\x10\n\x0c\n\x05\
    \x04\x07\x02\x0b\x05\x12\x036\x11\x17\n\x0c\n\x05\x04\x07\x02\x0b\x01\
    \x12\x036\x18\x1b\n\x0c\n\x05\x04\x07\x02\x0b\x03\x12\x036\x1e\x20\n\x0b\
    \n\x04\x04\x07\x02\x0c\x12\x037\x08!\n\x0c\n\x05\x04\x07\x02\x0c\x04\x12\
    \x037\x08\x10\n\x0c\n\x05\x04\x07\x02\x0c\x05\x12\x037\x11\x17\n\x0c\n\
    \x05\x04\x07\x02\x0c\x01\x12\x037\x18\x1b\n\x0c\n\x05\x04\x07\x02\x0c\
    \x03\x12\x037\x1e\x20\n\x0b\n\x04\x04\x07\x02\r\x12\x038\x08!\n\x0c\n\
    \x05\x04\x07\x02\r\x04\x12\x038\x08\x10\n\x0c\n\x05\x04\x07\x02\r\x05\
    \x12\x038\x11\x17\n\x0c\n\x05\x04\x07\x02\r\x01\x12\x038\x18\x1b\n\x0c\n\
    \x05\x04\x07\x02\r\x03\x12\x038\x1e\x20\n\x0b\n\x04\x04\x07\x02\x0e\x12\
    \x039\x08!\n\x0c\n\x05\x04\x07\x02\x0e\x04\x12\x039\x08\x10\n\x0c\n\x05\
    \x04\x07\x02\x0e\x05\x12\x039\x11\x17\n\x0c\n\x05\x04\x07\x02\x0e\x01\
    \x12\x039\x18\x1b\n\x0c\n\x05\x04\x07\x02\x0e\x03\x12\x039\x1e\x20\n\x0b\
    \n\x04\x04\x07\x02\x0f\x12\x03:\x08!\n\x0c\n\x05\x04\x07\x02\x0f\x04\x12\
    \x03:\x08\x10\n\x0c\n\x05\x04\x07\x02\x0f\x05\x12\x03:\x11\x17\n\x0c\n\
    \x05\x04\x07\x02\x0f\x01\x12\x03:\x18\x1b\n\x0c\n\x05\x04\x07\x02\x0f\
    \x03\x12\x03:\x1e\x20\n\n\n\x02\x04\x08\x12\x04=\0G\x01\n\n\n\x03\x04\
    \x08\x01\x12\x03=\x08\x13\n\x0c\n\x04\x04\x08\x03\0\x12\x04>\x08A\t\n\
    \x0c\n\x05\x04\x08\x03\0\x01\x12\x03>\x10\x1d\n\r\n\x06\x04\x08\x03\0\
    \x02\0\x12\x03?\x10/\n\x0e\n\x07\x04\x08\x03\0\x02\0\x04\x12\x03?\x10\
    \x18\n\x0e\n\x07\x04\x08\x03\0\x02\0\x05\x12\x03?\x19\x1f\n\x0e\n\x07\
    \x04\x08\x03\0\x02\0\x01\x12\x03?\x20*\n\x0e\n\x07\x04\x08\x03\0\x02\0\
    \x03\x12\x03?-.\n\r\n\x06\x04\x08\x03\0\x02\x01\x12\x03@\x10-\n\x0e\n\
    \x07\x04\x08\x03\0\x02\x01\x04\x12\x03@\x10\x18\n\x0e\n\x07\x04\x08\x03\
    \0\x02\x01\x05\x12\x03@\x19\x1f\n\x0e\n\x07\x04\x08\x03\0\x02\x01\x01\
    \x12\x03@\x20(\n\x0e\n\x07\x04\x08\x03\0\x02\x01\x03\x12\x03@+,\n\x0b\n\
    \x04\x04\x08\x02\0\x12\x03C\x089\n\x0c\n\x05\x04\x08\x02\0\x04\x12\x03C\
    \x08\x10\n\x0c\n\x05\x04\x08\x02\0\x06\x12\x03C\x11+\n\x0c\n\x05\x04\x08\
    \x02\0\x01\x12\x03C,4\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03C78\n\x0b\n\
    \x04\x04\x08\x02\x01\x12\x03D\x08:\n\x0c\n\x05\x04\x08\x02\x01\x04\x12\
    \x03D\x08\x10\n\x0c\n\x05\x04\x08\x02\x01\x06\x12\x03D\x11+\n\x0c\n\x05\
    \x04\x08\x02\x01\x01\x12\x03D,5\n\x0c\n\x05\x04\x08\x02\x01\x03\x12\x03D\
    89\n\x0b\n\x04\x04\x08\x02\x02\x12\x03E\x08=\n\x0c\n\x05\x04\x08\x02\x02\
    \x04\x12\x03E\x08\x10\n\x0c\n\x05\x04\x08\x02\x02\x06\x12\x03E\x11+\n\
    \x0c\n\x05\x04\x08\x02\x02\x01\x12\x03E,8\n\x0c\n\x05\x04\x08\x02\x02\
    \x03\x12\x03E;<\n\x0b\n\x04\x04\x08\x02\x03\x12\x03F\x08<\n\x0c\n\x05\
    \x04\x08\x02\x03\x04\x12\x03F\x08\x10\n\x0c\n\x05\x04\x08\x02\x03\x06\
    \x12\x03F\x11+\n\x0c\n\x05\x04\x08\x02\x03\x01\x12\x03F,7\n\x0c\n\x05\
    \x04\x08\x02\x03\x03\x12\x03F:;\n\n\n\x02\x04\t\x12\x04I\0T\x01\n\n\n\
    \x03\x04\t\x01\x12\x03I\x08\x13\n\x0c\n\x04\x04\t\x03\0\x12\x04J\x08N\t\
    \n\x0c\n\x05\x04\t\x03\0\x01\x12\x03J\x10\x1b\n\r\n\x06\x04\t\x03\0\x02\
    \0\x12\x03K\x10*\n\x0e\n\x07\x04\t\x03\0\x02\0\x04\x12\x03K\x10\x18\n\
    \x0e\n\x07\x04\t\x03\0\x02\0\x05\x12\x03K\x19\x1f\n\x0e\n\x07\x04\t\x03\
    \0\x02\0\x01\x12\x03K\x20%\n\x0e\n\x07\x04\t\x03\0\x02\0\x03\x12\x03K()\
    \n\r\n\x06\x04\t\x03\0\x02\x01\x12\x03L\x10*\n\x0e\n\x07\x04\t\x03\0\x02\
    \x01\x04\x12\x03L\x10\x18\n\x0e\n\x07\x04\t\x03\0\x02\x01\x05\x12\x03L\
    \x19\x1f\n\x0e\n\x07\x04\t\x03\0\x02\x01\x01\x12\x03L\x20%\n\x0e\n\x07\
    \x04\t\x03\0\x02\x01\x03\x12\x03L()\n\r\n\x06\x04\t\x03\0\x02\x02\x12\
    \x03M\x10*\n\x0e\n\x07\x04\t\x03\0\x02\x02\x04\x12\x03M\x10\x18\n\x0e\n\
    \x07\x04\t\x03\0\x02\x02\x05\x12\x03M\x19\x1f\n\x0e\n\x07\x04\t\x03\0\
    \x02\x02\x01\x12\x03M\x20%\n\x0e\n\x07\x04\t\x03\0\x02\x02\x03\x12\x03M(\
    )\n\x0b\n\x04\x04\t\x02\0\x12\x03P\x082\n\x0c\n\x05\x04\t\x02\0\x04\x12\
    \x03P\x08\x10\n\x0c\n\x05\x04\t\x02\0\x06\x12\x03P\x11)\n\x0c\n\x05\x04\
    \t\x02\0\x01\x12\x03P*-\n\x0c\n\x05\x04\t\x02\0\x03\x12\x03P01\n\x0b\n\
    \x04\x04\t\x02\x01\x12\x03Q\x084\n\x0c\n\x05\x04\t\x02\x01\x04\x12\x03Q\
    \x08\x10\n\x0c\n\x05\x04\t\x02\x01\x06\x12\x03Q\x11)\n\x0c\n\x05\x04\t\
    \x02\x01\x01\x12\x03Q*/\n\x0c\n\x05\x04\t\x02\x01\x03\x12\x03Q23\n\x0b\n\
    \x04\x04\t\x02\x02\x12\x03R\x085\n\x0c\n\x05\x04\t\x02\x02\x04\x12\x03R\
    \x08\x10\n\x0c\n\x05\x04\t\x02\x02\x06\x12\x03R\x11)\n\x0c\n\x05\x04\t\
    \x02\x02\x01\x12\x03R*0\n\x0c\n\x05\x04\t\x02\x02\x03\x12\x03R34\n\x0b\n\
    \x04\x04\t\x02\x03\x12\x03S\x083\n\x0c\n\x05\x04\t\x02\x03\x04\x12\x03S\
    \x08\x10\n\x0c\n\x05\x04\t\x02\x03\x06\x12\x03S\x11)\n\x0c\n\x05\x04\t\
    \x02\x03\x01\x12\x03S*.\n\x0c\n\x05\x04\t\x02\x03\x03\x12\x03S12\n\n\n\
    \x02\x04\n\x12\x04V\0_\x01\n\n\n\x03\x04\n\x01\x12\x03V\x08\x16\n\x0b\n\
    \x04\x04\n\x02\0\x12\x03W\x08\x20\n\x0c\n\x05\x04\n\x02\0\x04\x12\x03W\
    \x08\x10\n\x0c\n\x05\x04\n\x02\0\x05\x12\x03W\x11\x15\n\x0c\n\x05\x04\n\
    \x02\0\x01\x12\x03W\x16\x1b\n\x0c\n\x05\x04\n\x02\0\x03\x12\x03W\x1e\x1f\
    \n\x0b\n\x04\x04\n\x02\x01\x12\x03X\x08.\n\x0c\n\x05\x04\n\x02\x01\x04\
    \x12\x03X\x08\x10\n\x0c\n\x05\x04\n\x02\x01\x05\x12\x03X\x11\x17\n\x0c\n\
    \x05\x04\n\x02\x01\x01\x12\x03X\x18)\n\x0c\n\x05\x04\n\x02\x01\x03\x12\
    \x03X,-\n\x0b\n\x04\x04\n\x02\x02\x12\x03Y\x08,\n\x0c\n\x05\x04\n\x02\
    \x02\x04\x12\x03Y\x08\x10\n\x0c\n\x05\x04\n\x02\x02\x05\x12\x03Y\x11\x17\
    \n\x0c\n\x05\x04\n\x02\x02\x01\x12\x03Y\x18'\n\x0c\n\x05\x04\n\x02\x02\
    \x03\x12\x03Y*+\n\x0b\n\x04\x04\n\x02\x03\x12\x03Z\x08(\n\x0c\n\x05\x04\
    \n\x02\x03\x04\x12\x03Z\x08\x10\n\x0c\n\x05\x04\n\x02\x03\x05\x12\x03Z\
    \x11\x17\n\x0c\n\x05\x04\n\x02\x03\x01\x12\x03Z\x18#\n\x0c\n\x05\x04\n\
    \x02\x03\x03\x12\x03Z&'\n\x0b\n\x04\x04\n\x02\x04\x12\x03[\x08,\n\x0c\n\
    \x05\x04\n\x02\x04\x04\x12\x03[\x08\x10\n\x0c\n\x05\x04\n\x02\x04\x05\
    \x12\x03[\x11\x17\n\x0c\n\x05\x04\n\x02\x04\x01\x12\x03[\x18'\n\x0c\n\
    \x05\x04\n\x02\x04\x03\x12\x03[*+\n\x0b\n\x04\x04\n\x02\x05\x12\x03\\\
    \x08\"\n\x0c\n\x05\x04\n\x02\x05\x04\x12\x03\\\x08\x10\n\x0c\n\x05\x04\n\
    \x02\x05\x05\x12\x03\\\x11\x17\n\x0c\n\x05\x04\n\x02\x05\x01\x12\x03\\\
    \x18\x1d\n\x0c\n\x05\x04\n\x02\x05\x03\x12\x03\\\x20!\n\x0b\n\x04\x04\n\
    \x02\x06\x12\x03]\x08\x1f\n\x0c\n\x05\x04\n\x02\x06\x04\x12\x03]\x08\x10\
    \n\x0c\n\x05\x04\n\x02\x06\x05\x12\x03]\x11\x15\n\x0c\n\x05\x04\n\x02\
    \x06\x01\x12\x03]\x16\x1a\n\x0c\n\x05\x04\n\x02\x06\x03\x12\x03]\x1d\x1e\
    \n\x0b\n\x04\x04\n\x02\x07\x12\x03^\x08$\n\x0c\n\x05\x04\n\x02\x07\x04\
    \x12\x03^\x08\x10\n\x0c\n\x05\x04\n\x02\x07\x05\x12\x03^\x11\x15\n\x0c\n\
    \x05\x04\n\x02\x07\x01\x12\x03^\x16\x1f\n\x0c\n\x05\x04\n\x02\x07\x03\
    \x12\x03^\"#\n\n\n\x02\x04\x0b\x12\x04a\0h\x01\n\n\n\x03\x04\x0b\x01\x12\
    \x03a\x08\x17\n\x0b\n\x04\x04\x0b\x02\0\x12\x03b\x08.\n\x0c\n\x05\x04\
    \x0b\x02\0\x04\x12\x03b\x08\x10\n\x0c\n\x05\x04\x0b\x02\0\x05\x12\x03b\
    \x11\x17\n\x0c\n\x05\x04\x0b\x02\0\x01\x12\x03b\x18)\n\x0c\n\x05\x04\x0b\
    \x02\0\x03\x12\x03b,-\n\x0b\n\x04\x04\x0b\x02\x01\x12\x03c\x08,\n\x0c\n\
    \x05\x04\x0b\x02\x01\x04\x12\x03c\x08\x10\n\x0c\n\x05\x04\x0b\x02\x01\
    \x05\x12\x03c\x11\x17\n\x0c\n\x05\x04\x0b\x02\x01\x01\x12\x03c\x18'\n\
    \x0c\n\x05\x04\x0b\x02\x01\x03\x12\x03c*+\n\x0b\n\x04\x04\x0b\x02\x02\
    \x12\x03d\x08(\n\x0c\n\x05\x04\x0b\x02\x02\x04\x12\x03d\x08\x10\n\x0c\n\
    \x05\x04\x0b\x02\x02\x05\x12\x03d\x11\x17\n\x0c\n\x05\x04\x0b\x02\x02\
    \x01\x12\x03d\x18#\n\x0c\n\x05\x04\x0b\x02\x02\x03\x12\x03d&'\n\x0b\n\
    \x04\x04\x0b\x02\x03\x12\x03e\x08\"\n\x0c\n\x05\x04\x0b\x02\x03\x04\x12\
    \x03e\x08\x10\n\x0c\n\x05\x04\x0b\x02\x03\x05\x12\x03e\x11\x17\n\x0c\n\
    \x05\x04\x0b\x02\x03\x01\x12\x03e\x18\x1d\n\x0c\n\x05\x04\x0b\x02\x03\
    \x03\x12\x03e\x20!\n\x0b\n\x04\x04\x0b\x02\x04\x12\x03f\x08$\n\x0c\n\x05\
    \x04\x0b\x02\x04\x04\x12\x03f\x08\x10\n\x0c\n\x05\x04\x0b\x02\x04\x05\
    \x12\x03f\x11\x15\n\x0c\n\x05\x04\x0b\x02\x04\x01\x12\x03f\x16\x1f\n\x0c\
    \n\x05\x04\x0b\x02\x04\x03\x12\x03f\"#\n\x0b\n\x04\x04\x0b\x02\x05\x12\
    \x03g\x08%\n\x0c\n\x05\x04\x0b\x02\x05\x04\x12\x03g\x08\x10\n\x0c\n\x05\
    \x04\x0b\x02\x05\x05\x12\x03g\x11\x17\n\x0c\n\x05\x04\x0b\x02\x05\x01\
    \x12\x03g\x18\x20\n\x0c\n\x05\x04\x0b\x02\x05\x03\x12\x03g#$\n\n\n\x02\
    \x04\x0c\x12\x04j\0o\x01\n\n\n\x03\x04\x0c\x01\x12\x03j\x08\x17\n\x0b\n\
    \x04\x04\x0c\x02\0\x12\x03k\x08%\n\x0c\n\x05\x04\x0c\x02\0\x04\x12\x03k\
    \x08\x10\n\x0c\n\x05\x04\x0c\x02\0\x05\x12\x03k\x11\x17\n\x0c\n\x05\x04\
    \x0c\x02\0\x01\x12\x03k\x18\x20\n\x0c\n\x05\x04\x0c\x02\0\x03\x12\x03k#$\
    \n\x0b\n\x04\x04\x0c\x02\x01\x12\x03l\x08%\n\x0c\n\x05\x04\x0c\x02\x01\
    \x04\x12\x03l\x08\x10\n\x0c\n\x05\x04\x0c\x02\x01\x05\x12\x03l\x11\x17\n\
    \x0c\n\x05\x04\x0c\x02\x01\x01\x12\x03l\x18\x20\n\x0c\n\x05\x04\x0c\x02\
    \x01\x03\x12\x03l#$\n\x0b\n\x04\x04\x0c\x02\x02\x12\x03m\x08(\n\x0c\n\
    \x05\x04\x0c\x02\x02\x04\x12\x03m\x08\x10\n\x0c\n\x05\x04\x0c\x02\x02\
    \x05\x12\x03m\x11\x17\n\x0c\n\x05\x04\x0c\x02\x02\x01\x12\x03m\x18#\n\
    \x0c\n\x05\x04\x0c\x02\x02\x03\x12\x03m&'\n\x0b\n\x04\x04\x0c\x02\x03\
    \x12\x03n\x08)\n\x0c\n\x05\x04\x0c\x02\x03\x04\x12\x03n\x08\x10\n\x0c\n\
    \x05\x04\x0c\x02\x03\x05\x12\x03n\x11\x17\n\x0c\n\x05\x04\x0c\x02\x03\
    \x01\x12\x03n\x18$\n\x0c\n\x05\x04\x0c\x02\x03\x03\x12\x03n'(\n\n\n\x02\
    \x04\r\x12\x04q\0x\x01\n\n\n\x03\x04\r\x01\x12\x03q\x08\x14\n\x0b\n\x04\
    \x04\r\x02\0\x12\x03r\x08$\n\x0c\n\x05\x04\r\x02\0\x04\x12\x03r\x08\x10\
    \n\x0c\n\x05\x04\r\x02\0\x05\x12\x03r\x11\x15\n\x0c\n\x05\x04\r\x02\0\
    \x01\x12\x03r\x16\x1f\n\x0c\n\x05\x04\r\x02\0\x03\x12\x03r\"#\n\x0b\n\
    \x04\x04\r\x02\x01\x12\x03s\x08!\n\x0c\n\x05\x04\r\x02\x01\x04\x12\x03s\
    \x08\x10\n\x0c\n\x05\x04\r\x02\x01\x05\x12\x03s\x11\x17\n\x0c\n\x05\x04\
    \r\x02\x01\x01\x12\x03s\x18\x1c\n\x0c\n\x05\x04\r\x02\x01\x03\x12\x03s\
    \x1f\x20\n\x0b\n\x04\x04\r\x02\x02\x12\x03t\x08\x20\n\x0c\n\x05\x04\r\
    \x02\x02\x04\x12\x03t\x08\x10\n\x0c\n\x05\x04\r\x02\x02\x05\x12\x03t\x11\
    \x17\n\x0c\n\x05\x04\r\x02\x02\x01\x12\x03t\x18\x1b\n\x0c\n\x05\x04\r\
    \x02\x02\x03\x12\x03t\x1e\x1f\n\x0b\n\x04\x04\r\x02\x03\x12\x03u\x08\"\n\
    \x0c\n\x05\x04\r\x02\x03\x04\x12\x03u\x08\x10\n\x0c\n\x05\x04\r\x02\x03\
    \x05\x12\x03u\x11\x17\n\x0c\n\x05\x04\r\x02\x03\x01\x12\x03u\x18\x1d\n\
    \x0c\n\x05\x04\r\x02\x03\x03\x12\x03u\x20!\n\x0b\n\x04\x04\r\x02\x04\x12\
    \x03v\x08#\n\x0c\n\x05\x04\r\x02\x04\x04\x12\x03v\x08\x10\n\x0c\n\x05\
    \x04\r\x02\x04\x05\x12\x03v\x11\x17\n\x0c\n\x05\x04\r\x02\x04\x01\x12\
    \x03v\x18\x1e\n\x0c\n\x05\x04\r\x02\x04\x03\x12\x03v!\"\n\x0b\n\x04\x04\
    \r\x02\x05\x12\x03w\x082\n\x0c\n\x05\x04\r\x02\x05\x04\x12\x03w\x08\x10\
    \n\x0c\n\x05\x04\r\x02\x05\x06\x12\x03w\x11!\n\x0c\n\x05\x04\r\x02\x05\
    \x01\x12\x03w\"-\n\x0c\n\x05\x04\r\x02\x05\x03\x12\x03w01\n\x0b\n\x02\
    \x04\x0e\x12\x05z\0\xbb\x01\x01\n\n\n\x03\x04\x0e\x01\x12\x03z\x08\x20\n\
    \x0b\n\x04\x04\x0e\x02\0\x12\x03{\x08%\n\x0c\n\x05\x04\x0e\x02\0\x04\x12\
    \x03{\x08\x10\n\x0c\n\x05\x04\x0e\x02\0\x05\x12\x03{\x11\x17\n\x0c\n\x05\
    \x04\x0e\x02\0\x01\x12\x03{\x18\x20\n\x0c\n\x05\x04\x0e\x02\0\x03\x12\
    \x03{#$\n\x0b\n\x04\x04\x0e\x02\x01\x12\x03|\x08\"\n\x0c\n\x05\x04\x0e\
    \x02\x01\x04\x12\x03|\x08\x10\n\x0c\n\x05\x04\x0e\x02\x01\x05\x12\x03|\
    \x11\x17\n\x0c\n\x05\x04\x0e\x02\x01\x01\x12\x03|\x18\x1d\n\x0c\n\x05\
    \x04\x0e\x02\x01\x03\x12\x03|\x20!\n\x0b\n\x04\x04\x0e\x02\x02\x12\x03}\
    \x08#\n\x0c\n\x05\x04\x0e\x02\x02\x04\x12\x03}\x08\x10\n\x0c\n\x05\x04\
    \x0e\x02\x02\x05\x12\x03}\x11\x17\n\x0c\n\x05\x04\x0e\x02\x02\x01\x12\
    \x03}\x18\x1e\n\x0c\n\x05\x04\x0e\x02\x02\x03\x12\x03}!\"\n\x0b\n\x04\
    \x04\x0e\x02\x03\x12\x03~\x082\n\x0c\n\x05\x04\x0e\x02\x03\x04\x12\x03~\
    \x08\x10\n\x0c\n\x05\x04\x0e\x02\x03\x05\x12\x03~\x11\x17\n\x0c\n\x05\
    \x04\x0e\x02\x03\x01\x12\x03~\x18-\n\x0c\n\x05\x04\x0e\x02\x03\x03\x12\
    \x03~01\n\x0b\n\x04\x04\x0e\x02\x04\x12\x03\x7f\x082\n\x0c\n\x05\x04\x0e\
    \x02\x04\x04\x12\x03\x7f\x08\x10\n\x0c\n\x05\x04\x0e\x02\x04\x05\x12\x03\
    \x7f\x11\x17\n\x0c\n\x05\x04\x0e\x02\x04\x01\x12\x03\x7f\x18-\n\x0c\n\
    \x05\x04\x0e\x02\x04\x03\x12\x03\x7f01\n\x0c\n\x04\x04\x0e\x02\x05\x12\
    \x04\x80\x01\x082\n\r\n\x05\x04\x0e\x02\x05\x04\x12\x04\x80\x01\x08\x10\
    \n\r\n\x05\x04\x0e\x02\x05\x05\x12\x04\x80\x01\x11\x17\n\r\n\x05\x04\x0e\
    \x02\x05\x01\x12\x04\x80\x01\x18-\n\r\n\x05\x04\x0e\x02\x05\x03\x12\x04\
    \x80\x0101\n\x0c\n\x04\x04\x0e\x02\x06\x12\x04\x81\x01\x083\n\r\n\x05\
    \x04\x0e\x02\x06\x04\x12\x04\x81\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x06\
    \x05\x12\x04\x81\x01\x11\x17\n\r\n\x05\x04\x0e\x02\x06\x01\x12\x04\x81\
    \x01\x18.\n\r\n\x05\x04\x0e\x02\x06\x03\x12\x04\x81\x0112\n\x0c\n\x04\
    \x04\x0e\x02\x07\x12\x04\x82\x01\x083\n\r\n\x05\x04\x0e\x02\x07\x04\x12\
    \x04\x82\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x07\x05\x12\x04\x82\x01\x11\
    \x17\n\r\n\x05\x04\x0e\x02\x07\x01\x12\x04\x82\x01\x18.\n\r\n\x05\x04\
    \x0e\x02\x07\x03\x12\x04\x82\x0112\n\x0c\n\x04\x04\x0e\x02\x08\x12\x04\
    \x83\x01\x083\n\r\n\x05\x04\x0e\x02\x08\x04\x12\x04\x83\x01\x08\x10\n\r\
    \n\x05\x04\x0e\x02\x08\x05\x12\x04\x83\x01\x11\x17\n\r\n\x05\x04\x0e\x02\
    \x08\x01\x12\x04\x83\x01\x18.\n\r\n\x05\x04\x0e\x02\x08\x03\x12\x04\x83\
    \x0112\n\x0c\n\x04\x04\x0e\x02\t\x12\x04\x84\x01\x086\n\r\n\x05\x04\x0e\
    \x02\t\x04\x12\x04\x84\x01\x08\x10\n\r\n\x05\x04\x0e\x02\t\x05\x12\x04\
    \x84\x01\x11\x17\n\r\n\x05\x04\x0e\x02\t\x01\x12\x04\x84\x01\x180\n\r\n\
    \x05\x04\x0e\x02\t\x03\x12\x04\x84\x0135\n\x0c\n\x04\x04\x0e\x02\n\x12\
    \x04\x85\x01\x086\n\r\n\x05\x04\x0e\x02\n\x04\x12\x04\x85\x01\x08\x10\n\
    \r\n\x05\x04\x0e\x02\n\x05\x12\x04\x85\x01\x11\x17\n\r\n\x05\x04\x0e\x02\
    \n\x01\x12\x04\x85\x01\x180\n\r\n\x05\x04\x0e\x02\n\x03\x12\x04\x85\x013\
    5\n\x0c\n\x04\x04\x0e\x02\x0b\x12\x04\x86\x01\x086\n\r\n\x05\x04\x0e\x02\
    \x0b\x04\x12\x04\x86\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x0b\x05\x12\x04\
    \x86\x01\x11\x17\n\r\n\x05\x04\x0e\x02\x0b\x01\x12\x04\x86\x01\x180\n\r\
    \n\x05\x04\x0e\x02\x0b\x03\x12\x04\x86\x0135\n\x0c\n\x04\x04\x0e\x02\x0c\
    \x12\x04\x87\x01\x087\n\r\n\x05\x04\x0e\x02\x0c\x04\x12\x04\x87\x01\x08\
    \x10\n\r\n\x05\x04\x0e\x02\x0c\x05\x12\x04\x87\x01\x11\x17\n\r\n\x05\x04\
    \x0e\x02\x0c\x01\x12\x04\x87\x01\x181\n\r\n\x05\x04\x0e\x02\x0c\x03\x12\
    \x04\x87\x0146\n\x0c\n\x04\x04\x0e\x02\r\x12\x04\x88\x01\x087\n\r\n\x05\
    \x04\x0e\x02\r\x04\x12\x04\x88\x01\x08\x10\n\r\n\x05\x04\x0e\x02\r\x05\
    \x12\x04\x88\x01\x11\x17\n\r\n\x05\x04\x0e\x02\r\x01\x12\x04\x88\x01\x18\
    1\n\r\n\x05\x04\x0e\x02\r\x03\x12\x04\x88\x0146\n\x0c\n\x04\x04\x0e\x02\
    \x0e\x12\x04\x89\x01\x087\n\r\n\x05\x04\x0e\x02\x0e\x04\x12\x04\x89\x01\
    \x08\x10\n\r\n\x05\x04\x0e\x02\x0e\x05\x12\x04\x89\x01\x11\x17\n\r\n\x05\
    \x04\x0e\x02\x0e\x01\x12\x04\x89\x01\x181\n\r\n\x05\x04\x0e\x02\x0e\x03\
    \x12\x04\x89\x0146\n\x0c\n\x04\x04\x0e\x02\x0f\x12\x04\x8a\x01\x08+\n\r\
    \n\x05\x04\x0e\x02\x0f\x04\x12\x04\x8a\x01\x08\x10\n\r\n\x05\x04\x0e\x02\
    \x0f\x05\x12\x04\x8a\x01\x11\x17\n\r\n\x05\x04\x0e\x02\x0f\x01\x12\x04\
    \x8a\x01\x18%\n\r\n\x05\x04\x0e\x02\x0f\x03\x12\x04\x8a\x01(*\n\x0c\n\
    \x04\x04\x0e\x02\x10\x12\x04\x8b\x01\x08+\n\r\n\x05\x04\x0e\x02\x10\x04\
    \x12\x04\x8b\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x10\x05\x12\x04\x8b\x01\
    \x11\x17\n\r\n\x05\x04\x0e\x02\x10\x01\x12\x04\x8b\x01\x18%\n\r\n\x05\
    \x04\x0e\x02\x10\x03\x12\x04\x8b\x01(*\n\x0c\n\x04\x04\x0e\x02\x11\x12\
    \x04\x8c\x01\x08+\n\r\n\x05\x04\x0e\x02\x11\x04\x12\x04\x8c\x01\x08\x10\
    \n\r\n\x05\x04\x0e\x02\x11\x05\x12\x04\x8c\x01\x11\x17\n\r\n\x05\x04\x0e\
    \x02\x11\x01\x12\x04\x8c\x01\x18%\n\r\n\x05\x04\x0e\x02\x11\x03\x12\x04\
    \x8c\x01(*\n\x0c\n\x04\x04\x0e\x02\x12\x12\x04\x8d\x01\x08+\n\r\n\x05\
    \x04\x0e\x02\x12\x04\x12\x04\x8d\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x12\
    \x05\x12\x04\x8d\x01\x11\x17\n\r\n\x05\x04\x0e\x02\x12\x01\x12\x04\x8d\
    \x01\x18%\n\r\n\x05\x04\x0e\x02\x12\x03\x12\x04\x8d\x01(*\n\x0c\n\x04\
    \x04\x0e\x02\x13\x12\x04\x8e\x01\x08+\n\r\n\x05\x04\x0e\x02\x13\x04\x12\
    \x04\x8e\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x13\x05\x12\x04\x8e\x01\x11\
    \x17\n\r\n\x05\x04\x0e\x02\x13\x01\x12\x04\x8e\x01\x18%\n\r\n\x05\x04\
    \x0e\x02\x13\x03\x12\x04\x8e\x01(*\n\x0c\n\x04\x04\x0e\x02\x14\x12\x04\
    \x8f\x01\x08+\n\r\n\x05\x04\x0e\x02\x14\x04\x12\x04\x8f\x01\x08\x10\n\r\
    \n\x05\x04\x0e\x02\x14\x05\x12\x04\x8f\x01\x11\x17\n\r\n\x05\x04\x0e\x02\
    \x14\x01\x12\x04\x8f\x01\x18%\n\r\n\x05\x04\x0e\x02\x14\x03\x12\x04\x8f\
    \x01(*\n\x0c\n\x04\x04\x0e\x02\x15\x12\x04\x90\x01\x08+\n\r\n\x05\x04\
    \x0e\x02\x15\x04\x12\x04\x90\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x15\x05\
    \x12\x04\x90\x01\x11\x17\n\r\n\x05\x04\x0e\x02\x15\x01\x12\x04\x90\x01\
    \x18%\n\r\n\x05\x04\x0e\x02\x15\x03\x12\x04\x90\x01(*\n\x0c\n\x04\x04\
    \x0e\x02\x16\x12\x04\x91\x01\x08+\n\r\n\x05\x04\x0e\x02\x16\x04\x12\x04\
    \x91\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x16\x05\x12\x04\x91\x01\x11\x17\n\
    \r\n\x05\x04\x0e\x02\x16\x01\x12\x04\x91\x01\x18%\n\r\n\x05\x04\x0e\x02\
    \x16\x03\x12\x04\x91\x01(*\n\x0c\n\x04\x04\x0e\x02\x17\x12\x04\x92\x01\
    \x08+\n\r\n\x05\x04\x0e\x02\x17\x04\x12\x04\x92\x01\x08\x10\n\r\n\x05\
    \x04\x0e\x02\x17\x05\x12\x04\x92\x01\x11\x17\n\r\n\x05\x04\x0e\x02\x17\
    \x01\x12\x04\x92\x01\x18%\n\r\n\x05\x04\x0e\x02\x17\x03\x12\x04\x92\x01(\
    *\n\x0c\n\x04\x04\x0e\x02\x18\x12\x04\x93\x01\x08+\n\r\n\x05\x04\x0e\x02\
    \x18\x04\x12\x04\x93\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x18\x05\x12\x04\
    \x93\x01\x11\x17\n\r\n\x05\x04\x0e\x02\x18\x01\x12\x04\x93\x01\x18%\n\r\
    \n\x05\x04\x0e\x02\x18\x03\x12\x04\x93\x01(*\n\x0c\n\x04\x04\x0e\x02\x19\
    \x12\x04\x94\x01\x08+\n\r\n\x05\x04\x0e\x02\x19\x04\x12\x04\x94\x01\x08\
    \x10\n\r\n\x05\x04\x0e\x02\x19\x05\x12\x04\x94\x01\x11\x17\n\r\n\x05\x04\
    \x0e\x02\x19\x01\x12\x04\x94\x01\x18%\n\r\n\x05\x04\x0e\x02\x19\x03\x12\
    \x04\x94\x01(*\n\x0c\n\x04\x04\x0e\x02\x1a\x12\x04\x95\x01\x08+\n\r\n\
    \x05\x04\x0e\x02\x1a\x04\x12\x04\x95\x01\x08\x10\n\r\n\x05\x04\x0e\x02\
    \x1a\x05\x12\x04\x95\x01\x11\x17\n\r\n\x05\x04\x0e\x02\x1a\x01\x12\x04\
    \x95\x01\x18%\n\r\n\x05\x04\x0e\x02\x1a\x03\x12\x04\x95\x01(*\n\x0c\n\
    \x04\x04\x0e\x02\x1b\x12\x04\x96\x01\x08+\n\r\n\x05\x04\x0e\x02\x1b\x04\
    \x12\x04\x96\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x1b\x05\x12\x04\x96\x01\
    \x11\x17\n\r\n\x05\x04\x0e\x02\x1b\x01\x12\x04\x96\x01\x18%\n\r\n\x05\
    \x04\x0e\x02\x1b\x03\x12\x04\x96\x01(*\n\x0c\n\x04\x04\x0e\x02\x1c\x12\
    \x04\x97\x01\x08+\n\r\n\x05\x04\x0e\x02\x1c\x04\x12\x04\x97\x01\x08\x10\
    \n\r\n\x05\x04\x0e\x02\x1c\x05\x12\x04\x97\x01\x11\x17\n\r\n\x05\x04\x0e\
    \x02\x1c\x01\x12\x04\x97\x01\x18%\n\r\n\x05\x04\x0e\x02\x1c\x03\x12\x04\
    \x97\x01(*\n\x0c\n\x04\x04\x0e\x02\x1d\x12\x04\x98\x01\x08+\n\r\n\x05\
    \x04\x0e\x02\x1d\x04\x12\x04\x98\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x1d\
    \x05\x12\x04\x98\x01\x11\x17\n\r\n\x05\x04\x0e\x02\x1d\x01\x12\x04\x98\
    \x01\x18%\n\r\n\x05\x04\x0e\x02\x1d\x03\x12\x04\x98\x01(*\n\x0c\n\x04\
    \x04\x0e\x02\x1e\x12\x04\x99\x01\x08+\n\r\n\x05\x04\x0e\x02\x1e\x04\x12\
    \x04\x99\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x1e\x05\x12\x04\x99\x01\x11\
    \x17\n\r\n\x05\x04\x0e\x02\x1e\x01\x12\x04\x99\x01\x18%\n\r\n\x05\x04\
    \x0e\x02\x1e\x03\x12\x04\x99\x01(*\n\x0c\n\x04\x04\x0e\x02\x1f\x12\x04\
    \x9a\x01\x08/\n\r\n\x05\x04\x0e\x02\x1f\x04\x12\x04\x9a\x01\x08\x10\n\r\
    \n\x05\x04\x0e\x02\x1f\x05\x12\x04\x9a\x01\x11\x17\n\r\n\x05\x04\x0e\x02\
    \x1f\x01\x12\x04\x9a\x01\x18)\n\r\n\x05\x04\x0e\x02\x1f\x03\x12\x04\x9a\
    \x01,.\n\x0c\n\x04\x04\x0e\x02\x20\x12\x04\x9b\x01\x08%\n\r\n\x05\x04\
    \x0e\x02\x20\x04\x12\x04\x9b\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x20\x05\
    \x12\x04\x9b\x01\x11\x17\n\r\n\x05\x04\x0e\x02\x20\x01\x12\x04\x9b\x01\
    \x18\x1f\n\r\n\x05\x04\x0e\x02\x20\x03\x12\x04\x9b\x01\"$\n\x0c\n\x04\
    \x04\x0e\x02!\x12\x04\x9c\x01\x08/\n\r\n\x05\x04\x0e\x02!\x04\x12\x04\
    \x9c\x01\x08\x10\n\r\n\x05\x04\x0e\x02!\x05\x12\x04\x9c\x01\x11\x17\n\r\
    \n\x05\x04\x0e\x02!\x01\x12\x04\x9c\x01\x18)\n\r\n\x05\x04\x0e\x02!\x03\
    \x12\x04\x9c\x01,.\n\x0c\n\x04\x04\x0e\x02\"\x12\x04\x9d\x01\x08(\n\r\n\
    \x05\x04\x0e\x02\"\x04\x12\x04\x9d\x01\x08\x10\n\r\n\x05\x04\x0e\x02\"\
    \x05\x12\x04\x9d\x01\x11\x17\n\r\n\x05\x04\x0e\x02\"\x01\x12\x04\x9d\x01\
    \x18\"\n\r\n\x05\x04\x0e\x02\"\x03\x12\x04\x9d\x01%'\n\x0c\n\x04\x04\x0e\
    \x02#\x12\x04\x9e\x01\x08'\n\r\n\x05\x04\x0e\x02#\x04\x12\x04\x9e\x01\
    \x08\x10\n\r\n\x05\x04\x0e\x02#\x05\x12\x04\x9e\x01\x11\x17\n\r\n\x05\
    \x04\x0e\x02#\x01\x12\x04\x9e\x01\x18!\n\r\n\x05\x04\x0e\x02#\x03\x12\
    \x04\x9e\x01$&\n\x0c\n\x04\x04\x0e\x02$\x12\x04\x9f\x01\x08(\n\r\n\x05\
    \x04\x0e\x02$\x04\x12\x04\x9f\x01\x08\x10\n\r\n\x05\x04\x0e\x02$\x05\x12\
    \x04\x9f\x01\x11\x17\n\r\n\x05\x04\x0e\x02$\x01\x12\x04\x9f\x01\x18\"\n\
    \r\n\x05\x04\x0e\x02$\x03\x12\x04\x9f\x01%'\n\x0c\n\x04\x04\x0e\x02%\x12\
    \x04\xa0\x01\x08&\n\r\n\x05\x04\x0e\x02%\x04\x12\x04\xa0\x01\x08\x10\n\r\
    \n\x05\x04\x0e\x02%\x05\x12\x04\xa0\x01\x11\x17\n\r\n\x05\x04\x0e\x02%\
    \x01\x12\x04\xa0\x01\x18\x20\n\r\n\x05\x04\x0e\x02%\x03\x12\x04\xa0\x01#\
    %\n\x0c\n\x04\x04\x0e\x02&\x12\x04\xa1\x01\x085\n\r\n\x05\x04\x0e\x02&\
    \x04\x12\x04\xa1\x01\x08\x10\n\r\n\x05\x04\x0e\x02&\x05\x12\x04\xa1\x01\
    \x11\x17\n\r\n\x05\x04\x0e\x02&\x01\x12\x04\xa1\x01\x18/\n\r\n\x05\x04\
    \x0e\x02&\x03\x12\x04\xa1\x0124\n\x0c\n\x04\x04\x0e\x02'\x12\x04\xa2\x01\
    \x082\n\r\n\x05\x04\x0e\x02'\x04\x12\x04\xa2\x01\x08\x10\n\r\n\x05\x04\
    \x0e\x02'\x05\x12\x04\xa2\x01\x11\x17\n\r\n\x05\x04\x0e\x02'\x01\x12\x04\
    \xa2\x01\x18,\n\r\n\x05\x04\x0e\x02'\x03\x12\x04\xa2\x01/1\n\x0c\n\x04\
    \x04\x0e\x02(\x12\x04\xa3\x01\x08*\n\r\n\x05\x04\x0e\x02(\x04\x12\x04\
    \xa3\x01\x08\x10\n\r\n\x05\x04\x0e\x02(\x06\x12\x04\xa3\x01\x11\x1d\n\r\
    \n\x05\x04\x0e\x02(\x01\x12\x04\xa3\x01\x1e$\n\r\n\x05\x04\x0e\x02(\x03\
    \x12\x04\xa3\x01')\n\x0c\n\x04\x04\x0e\x02)\x12\x04\xa4\x01\x081\n\r\n\
    \x05\x04\x0e\x02)\x04\x12\x04\xa4\x01\x08\x10\n\r\n\x05\x04\x0e\x02)\x06\
    \x12\x04\xa4\x01\x11\x1d\n\r\n\x05\x04\x0e\x02)\x01\x12\x04\xa4\x01\x1e+\
    \n\r\n\x05\x04\x0e\x02)\x03\x12\x04\xa4\x01.0\n\x0c\n\x04\x04\x0e\x02*\
    \x12\x04\xa5\x01\x081\n\r\n\x05\x04\x0e\x02*\x04\x12\x04\xa5\x01\x08\x10\
    \n\r\n\x05\x04\x0e\x02*\x06\x12\x04\xa5\x01\x11\x20\n\r\n\x05\x04\x0e\
    \x02*\x01\x12\x04\xa5\x01!+\n\r\n\x05\x04\x0e\x02*\x03\x12\x04\xa5\x01.0\
    \n\x0c\n\x04\x04\x0e\x02+\x12\x04\xa6\x01\x081\n\r\n\x05\x04\x0e\x02+\
    \x04\x12\x04\xa6\x01\x08\x10\n\r\n\x05\x04\x0e\x02+\x05\x12\x04\xa6\x01\
    \x11\x17\n\r\n\x05\x04\x0e\x02+\x01\x12\x04\xa6\x01\x18+\n\r\n\x05\x04\
    \x0e\x02+\x03\x12\x04\xa6\x01.0\n\x0c\n\x04\x04\x0e\x02,\x12\x04\xa7\x01\
    \x084\n\r\n\x05\x04\x0e\x02,\x04\x12\x04\xa7\x01\x08\x10\n\r\n\x05\x04\
    \x0e\x02,\x05\x12\x04\xa7\x01\x11\x17\n\r\n\x05\x04\x0e\x02,\x01\x12\x04\
    \xa7\x01\x18.\n\r\n\x05\x04\x0e\x02,\x03\x12\x04\xa7\x0113\n\x0c\n\x04\
    \x04\x0e\x02-\x12\x04\xa8\x01\x084\n\r\n\x05\x04\x0e\x02-\x04\x12\x04\
    \xa8\x01\x08\x10\n\r\n\x05\x04\x0e\x02-\x05\x12\x04\xa8\x01\x11\x17\n\r\
    \n\x05\x04\x0e\x02-\x01\x12\x04\xa8\x01\x18.\n\r\n\x05\x04\x0e\x02-\x03\
    \x12\x04\xa8\x0113\n\x0c\n\x04\x04\x0e\x02.\x12\x04\xa9\x01\x080\n\r\n\
    \x05\x04\x0e\x02.\x04\x12\x04\xa9\x01\x08\x10\n\r\n\x05\x04\x0e\x02.\x05\
    \x12\x04\xa9\x01\x11\x17\n\r\n\x05\x04\x0e\x02.\x01\x12\x04\xa9\x01\x18*\
    \n\r\n\x05\x04\x0e\x02.\x03\x12\x04\xa9\x01-/\n\x0c\n\x04\x04\x0e\x02/\
    \x12\x04\xaa\x01\x080\n\r\n\x05\x04\x0e\x02/\x04\x12\x04\xaa\x01\x08\x10\
    \n\r\n\x05\x04\x0e\x02/\x05\x12\x04\xaa\x01\x11\x17\n\r\n\x05\x04\x0e\
    \x02/\x01\x12\x04\xaa\x01\x18*\n\r\n\x05\x04\x0e\x02/\x03\x12\x04\xaa\
    \x01-/\n\x0c\n\x04\x04\x0e\x020\x12\x04\xab\x01\x08'\n\r\n\x05\x04\x0e\
    \x020\x04\x12\x04\xab\x01\x08\x10\n\r\n\x05\x04\x0e\x020\x05\x12\x04\xab\
    \x01\x11\x17\n\r\n\x05\x04\x0e\x020\x01\x12\x04\xab\x01\x18!\n\r\n\x05\
    \x04\x0e\x020\x03\x12\x04\xab\x01$&\n\x0c\n\x04\x04\x0e\x021\x12\x04\xac\
    \x01\x08'\n\r\n\x05\x04\x0e\x021\x04\x12\x04\xac\x01\x08\x10\n\r\n\x05\
    \x04\x0e\x021\x05\x12\x04\xac\x01\x11\x15\n\r\n\x05\x04\x0e\x021\x01\x12\
    \x04\xac\x01\x16!\n\r\n\x05\x04\x0e\x021\x03\x12\x04\xac\x01$&\n\x0c\n\
    \x04\x04\x0e\x022\x12\x04\xad\x01\x08'\n\r\n\x05\x04\x0e\x022\x04\x12\
    \x04\xad\x01\x08\x10\n\r\n\x05\x04\x0e\x022\x05\x12\x04\xad\x01\x11\x15\
    \n\r\n\x05\x04\x0e\x022\x01\x12\x04\xad\x01\x16!\n\r\n\x05\x04\x0e\x022\
    \x03\x12\x04\xad\x01$&\n\x0c\n\x04\x04\x0e\x023\x12\x04\xae\x01\x086\n\r\
    \n\x05\x04\x0e\x023\x04\x12\x04\xae\x01\x08\x10\n\r\n\x05\x04\x0e\x023\
    \x05\x12\x04\xae\x01\x11\x15\n\r\n\x05\x04\x0e\x023\x01\x12\x04\xae\x01\
    \x160\n\r\n\x05\x04\x0e\x023\x03\x12\x04\xae\x0135\n\x0c\n\x04\x04\x0e\
    \x024\x12\x04\xaf\x01\x084\n\r\n\x05\x04\x0e\x024\x04\x12\x04\xaf\x01\
    \x08\x10\n\r\n\x05\x04\x0e\x024\x05\x12\x04\xaf\x01\x11\x15\n\r\n\x05\
    \x04\x0e\x024\x01\x12\x04\xaf\x01\x16.\n\r\n\x05\x04\x0e\x024\x03\x12\
    \x04\xaf\x0113\n\x0c\n\x04\x04\x0e\x025\x12\x04\xb0\x01\x083\n\r\n\x05\
    \x04\x0e\x025\x04\x12\x04\xb0\x01\x08\x10\n\r\n\x05\x04\x0e\x025\x06\x12\
    \x04\xb0\x01\x11!\n\r\n\x05\x04\x0e\x025\x01\x12\x04\xb0\x01\"-\n\r\n\
    \x05\x04\x0e\x025\x03\x12\x04\xb0\x0102\n\x0c\n\x04\x04\x0e\x026\x12\x04\
    \xb1\x01\x08,\n\r\n\x05\x04\x0e\x026\x04\x12\x04\xb1\x01\x08\x10\n\r\n\
    \x05\x04\x0e\x026\x05\x12\x04\xb1\x01\x11\x17\n\r\n\x05\x04\x0e\x026\x01\
    \x12\x04\xb1\x01\x18&\n\r\n\x05\x04\x0e\x026\x03\x12\x04\xb1\x01)+\n\x0c\
    \n\x04\x04\x0e\x027\x12\x04\xb2\x01\x080\n\r\n\x05\x04\x0e\x027\x04\x12\
    \x04\xb2\x01\x08\x10\n\r\n\x05\x04\x0e\x027\x05\x12\x04\xb2\x01\x11\x17\
    \n\r\n\x05\x04\x0e\x027\x01\x12\x04\xb2\x01\x18*\n\r\n\x05\x04\x0e\x027\
    \x03\x12\x04\xb2\x01-/\n\x0c\n\x04\x04\x0e\x028\x12\x04\xb3\x01\x08/\n\r\
    \n\x05\x04\x0e\x028\x04\x12\x04\xb3\x01\x08\x10\n\r\n\x05\x04\x0e\x028\
    \x05\x12\x04\xb3\x01\x11\x17\n\r\n\x05\x04\x0e\x028\x01\x12\x04\xb3\x01\
    \x18)\n\r\n\x05\x04\x0e\x028\x03\x12\x04\xb3\x01,.\n\x0c\n\x04\x04\x0e\
    \x029\x12\x04\xb4\x01\x081\n\r\n\x05\x04\x0e\x029\x04\x12\x04\xb4\x01\
    \x08\x10\n\r\n\x05\x04\x0e\x029\x05\x12\x04\xb4\x01\x11\x17\n\r\n\x05\
    \x04\x0e\x029\x01\x12\x04\xb4\x01\x18+\n\r\n\x05\x04\x0e\x029\x03\x12\
    \x04\xb4\x01.0\n\x0c\n\x04\x04\x0e\x02:\x12\x04\xb5\x01\x082\n\r\n\x05\
    \x04\x0e\x02:\x04\x12\x04\xb5\x01\x08\x10\n\r\n\x05\x04\x0e\x02:\x05\x12\
    \x04\xb5\x01\x11\x17\n\r\n\x05\x04\x0e\x02:\x01\x12\x04\xb5\x01\x18,\n\r\
    \n\x05\x04\x0e\x02:\x03\x12\x04\xb5\x01/1\n\x0c\n\x04\x04\x0e\x02;\x12\
    \x04\xb6\x01\x083\n\r\n\x05\x04\x0e\x02;\x04\x12\x04\xb6\x01\x08\x10\n\r\
    \n\x05\x04\x0e\x02;\x06\x12\x04\xb6\x01\x11!\n\r\n\x05\x04\x0e\x02;\x01\
    \x12\x04\xb6\x01\"-\n\r\n\x05\x04\x0e\x02;\x03\x12\x04\xb6\x0102\n\x0c\n\
    \x04\x04\x0e\x02<\x12\x04\xb7\x01\x081\n\r\n\x05\x04\x0e\x02<\x04\x12\
    \x04\xb7\x01\x08\x10\n\r\n\x05\x04\x0e\x02<\x05\x12\x04\xb7\x01\x11\x17\
    \n\r\n\x05\x04\x0e\x02<\x01\x12\x04\xb7\x01\x18+\n\r\n\x05\x04\x0e\x02<\
    \x03\x12\x04\xb7\x01.0\n\x0c\n\x04\x04\x0e\x02=\x12\x04\xb8\x01\x08-\n\r\
    \n\x05\x04\x0e\x02=\x04\x12\x04\xb8\x01\x08\x10\n\r\n\x05\x04\x0e\x02=\
    \x05\x12\x04\xb8\x01\x11\x17\n\r\n\x05\x04\x0e\x02=\x01\x12\x04\xb8\x01\
    \x18'\n\r\n\x05\x04\x0e\x02=\x03\x12\x04\xb8\x01*,\n\x0c\n\x04\x04\x0e\
    \x02>\x12\x04\xb9\x01\x08-\n\r\n\x05\x04\x0e\x02>\x04\x12\x04\xb9\x01\
    \x08\x10\n\r\n\x05\x04\x0e\x02>\x05\x12\x04\xb9\x01\x11\x17\n\r\n\x05\
    \x04\x0e\x02>\x01\x12\x04\xb9\x01\x18'\n\r\n\x05\x04\x0e\x02>\x03\x12\
    \x04\xb9\x01*,\n\x0c\n\x04\x04\x0e\x02?\x12\x04\xba\x01\x08<\n\r\n\x05\
    \x04\x0e\x02?\x04\x12\x04\xba\x01\x08\x10\n\r\n\x05\x04\x0e\x02?\x05\x12\
    \x04\xba\x01\x11\x17\n\r\n\x05\x04\x0e\x02?\x01\x12\x04\xba\x01\x186\n\r\
    \n\x05\x04\x0e\x02?\x03\x12\x04\xba\x019;\n\x0c\n\x02\x04\x0f\x12\x06\
    \xbd\x01\0\xbe\x01\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\xbd\x01\x08\x1f\n\
    \x0c\n\x02\x04\x10\x12\x06\xc0\x01\0\xc2\x01\x01\n\x0b\n\x03\x04\x10\x01\
    \x12\x04\xc0\x01\x08\x20\n\x0c\n\x04\x04\x10\x02\0\x12\x04\xc1\x01\x08%\
    \n\r\n\x05\x04\x10\x02\0\x04\x12\x04\xc1\x01\x08\x10\n\r\n\x05\x04\x10\
    \x02\0\x05\x12\x04\xc1\x01\x11\x17\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\
    \xc1\x01\x18\x20\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xc1\x01#$\n\x0c\n\
    \x02\x04\x11\x12\x06\xc4\x01\0\xcd\x01\x01\n\x0b\n\x03\x04\x11\x01\x12\
    \x04\xc4\x01\x08\x1a\n\x0c\n\x04\x04\x11\x02\0\x12\x04\xc5\x01\x08'\n\r\
    \n\x05\x04\x11\x02\0\x04\x12\x04\xc5\x01\x08\x10\n\r\n\x05\x04\x11\x02\0\
    \x05\x12\x04\xc5\x01\x11\x17\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xc5\x01\
    \x18\"\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xc5\x01%&\n\x0c\n\x04\x04\x11\
    \x02\x01\x12\x04\xc6\x01\x08*\n\r\n\x05\x04\x11\x02\x01\x04\x12\x04\xc6\
    \x01\x08\x10\n\r\n\x05\x04\x11\x02\x01\x05\x12\x04\xc6\x01\x11\x17\n\r\n\
    \x05\x04\x11\x02\x01\x01\x12\x04\xc6\x01\x18%\n\r\n\x05\x04\x11\x02\x01\
    \x03\x12\x04\xc6\x01()\n\x0c\n\x04\x04\x11\x02\x02\x12\x04\xc7\x01\x08-\
    \n\r\n\x05\x04\x11\x02\x02\x04\x12\x04\xc7\x01\x08\x10\n\r\n\x05\x04\x11\
    \x02\x02\x05\x12\x04\xc7\x01\x11\x17\n\r\n\x05\x04\x11\x02\x02\x01\x12\
    \x04\xc7\x01\x18(\n\r\n\x05\x04\x11\x02\x02\x03\x12\x04\xc7\x01+,\n\x0c\
    \n\x04\x04\x11\x02\x03\x12\x04\xc8\x01\x086\n\r\n\x05\x04\x11\x02\x03\
    \x04\x12\x04\xc8\x01\x08\x10\n\r\n\x05\x04\x11\x02\x03\x05\x12\x04\xc8\
    \x01\x11\x17\n\r\n\x05\x04\x11\x02\x03\x01\x12\x04\xc8\x01\x18#\n\r\n\
    \x05\x04\x11\x02\x03\x03\x12\x04\xc8\x01&'\n\r\n\x05\x04\x11\x02\x03\x08\
    \x12\x04\xc8\x01(5\n\r\n\x05\x04\x11\x02\x03\x07\x12\x04\xc8\x0134\n\x0c\
    \n\x04\x04\x11\x02\x04\x12\x04\xc9\x01\x08*\n\r\n\x05\x04\x11\x02\x04\
    \x04\x12\x04\xc9\x01\x08\x10\n\r\n\x05\x04\x11\x02\x04\x05\x12\x04\xc9\
    \x01\x11\x16\n\r\n\x05\x04\x11\x02\x04\x01\x12\x04\xc9\x01\x17%\n\r\n\
    \x05\x04\x11\x02\x04\x03\x12\x04\xc9\x01()\n\x0c\n\x04\x04\x11\x02\x05\
    \x12\x04\xca\x01\x08*\n\r\n\x05\x04\x11\x02\x05\x04\x12\x04\xca\x01\x08\
    \x10\n\r\n\x05\x04\x11\x02\x05\x05\x12\x04\xca\x01\x11\x16\n\r\n\x05\x04\
    \x11\x02\x05\x01\x12\x04\xca\x01\x17%\n\r\n\x05\x04\x11\x02\x05\x03\x12\
    \x04\xca\x01()\n\x0c\n\x04\x04\x11\x02\x06\x12\x04\xcb\x01\x08*\n\r\n\
    \x05\x04\x11\x02\x06\x04\x12\x04\xcb\x01\x08\x10\n\r\n\x05\x04\x11\x02\
    \x06\x05\x12\x04\xcb\x01\x11\x16\n\r\n\x05\x04\x11\x02\x06\x01\x12\x04\
    \xcb\x01\x17%\n\r\n\x05\x04\x11\x02\x06\x03\x12\x04\xcb\x01()\n\x0c\n\
    \x04\x04\x11\x02\x07\x12\x04\xcc\x01\x08*\n\r\n\x05\x04\x11\x02\x07\x04\
    \x12\x04\xcc\x01\x08\x10\n\r\n\x05\x04\x11\x02\x07\x05\x12\x04\xcc\x01\
    \x11\x16\n\r\n\x05\x04\x11\x02\x07\x01\x12\x04\xcc\x01\x17%\n\r\n\x05\
    \x04\x11\x02\x07\x03\x12\x04\xcc\x01()\n\x0c\n\x02\x04\x12\x12\x06\xcf\
    \x01\0\xdb\x01\x01\n\x0b\n\x03\x04\x12\x01\x12\x04\xcf\x01\x08\x19\n\x0c\
    \n\x04\x04\x12\x02\0\x12\x04\xd0\x01\x08'\n\r\n\x05\x04\x12\x02\0\x04\
    \x12\x04\xd0\x01\x08\x10\n\r\n\x05\x04\x12\x02\0\x05\x12\x04\xd0\x01\x11\
    \x17\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xd0\x01\x18\"\n\r\n\x05\x04\x12\
    \x02\0\x03\x12\x04\xd0\x01%&\n\x0c\n\x04\x04\x12\x02\x01\x12\x04\xd1\x01\
    \x08*\n\r\n\x05\x04\x12\x02\x01\x04\x12\x04\xd1\x01\x08\x10\n\r\n\x05\
    \x04\x12\x02\x01\x05\x12\x04\xd1\x01\x11\x17\n\r\n\x05\x04\x12\x02\x01\
    \x01\x12\x04\xd1\x01\x18%\n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\xd1\x01(\
    )\n\x0c\n\x04\x04\x12\x02\x02\x12\x04\xd2\x01\x08-\n\r\n\x05\x04\x12\x02\
    \x02\x04\x12\x04\xd2\x01\x08\x10\n\r\n\x05\x04\x12\x02\x02\x05\x12\x04\
    \xd2\x01\x11\x17\n\r\n\x05\x04\x12\x02\x02\x01\x12\x04\xd2\x01\x18(\n\r\
    \n\x05\x04\x12\x02\x02\x03\x12\x04\xd2\x01+,\n\x0c\n\x04\x04\x12\x02\x03\
    \x12\x04\xd3\x01\x08(\n\r\n\x05\x04\x12\x02\x03\x04\x12\x04\xd3\x01\x08\
    \x10\n\r\n\x05\x04\x12\x02\x03\x05\x12\x04\xd3\x01\x11\x17\n\r\n\x05\x04\
    \x12\x02\x03\x01\x12\x04\xd3\x01\x18#\n\r\n\x05\x04\x12\x02\x03\x03\x12\
    \x04\xd3\x01&'\n\x0c\n\x04\x04\x12\x02\x04\x12\x04\xd4\x01\x08*\n\r\n\
    \x05\x04\x12\x02\x04\x04\x12\x04\xd4\x01\x08\x10\n\r\n\x05\x04\x12\x02\
    \x04\x05\x12\x04\xd4\x01\x11\x16\n\r\n\x05\x04\x12\x02\x04\x01\x12\x04\
    \xd4\x01\x17%\n\r\n\x05\x04\x12\x02\x04\x03\x12\x04\xd4\x01()\n\x0c\n\
    \x04\x04\x12\x02\x05\x12\x04\xd5\x01\x08*\n\r\n\x05\x04\x12\x02\x05\x04\
    \x12\x04\xd5\x01\x08\x10\n\r\n\x05\x04\x12\x02\x05\x05\x12\x04\xd5\x01\
    \x11\x16\n\r\n\x05\x04\x12\x02\x05\x01\x12\x04\xd5\x01\x17%\n\r\n\x05\
    \x04\x12\x02\x05\x03\x12\x04\xd5\x01()\n\x0c\n\x04\x04\x12\x02\x06\x12\
    \x04\xd6\x01\x08*\n\r\n\x05\x04\x12\x02\x06\x04\x12\x04\xd6\x01\x08\x10\
    \n\r\n\x05\x04\x12\x02\x06\x05\x12\x04\xd6\x01\x11\x16\n\r\n\x05\x04\x12\
    \x02\x06\x01\x12\x04\xd6\x01\x17%\n\r\n\x05\x04\x12\x02\x06\x03\x12\x04\
    \xd6\x01()\n\x0c\n\x04\x04\x12\x02\x07\x12\x04\xd7\x01\x08*\n\r\n\x05\
    \x04\x12\x02\x07\x04\x12\x04\xd7\x01\x08\x10\n\r\n\x05\x04\x12\x02\x07\
    \x05\x12\x04\xd7\x01\x11\x16\n\r\n\x05\x04\x12\x02\x07\x01\x12\x04\xd7\
    \x01\x17%\n\r\n\x05\x04\x12\x02\x07\x03\x12\x04\xd7\x01()\n\x0c\n\x04\
    \x04\x12\x02\x08\x12\x04\xd8\x01\x08&\n\r\n\x05\x04\x12\x02\x08\x04\x12\
    \x04\xd8\x01\x08\x10\n\r\n\x05\x04\x12\x02\x08\x05\x12\x04\xd8\x01\x11\
    \x17\n\r\n\x05\x04\x12\x02\x08\x01\x12\x04\xd8\x01\x18!\n\r\n\x05\x04\
    \x12\x02\x08\x03\x12\x04\xd8\x01$%\n\x0c\n\x04\x04\x12\x02\t\x12\x04\xd9\
    \x01\x08&\n\r\n\x05\x04\x12\x02\t\x04\x12\x04\xd9\x01\x08\x10\n\r\n\x05\
    \x04\x12\x02\t\x05\x12\x04\xd9\x01\x11\x16\n\r\n\x05\x04\x12\x02\t\x01\
    \x12\x04\xd9\x01\x17\x20\n\r\n\x05\x04\x12\x02\t\x03\x12\x04\xd9\x01#%\n\
    \x0c\n\x04\x04\x12\x02\n\x12\x04\xda\x01\x085\n\r\n\x05\x04\x12\x02\n\
    \x04\x12\x04\xda\x01\x08\x10\n\r\n\x05\x04\x12\x02\n\x06\x12\x04\xda\x01\
    \x11(\n\r\n\x05\x04\x12\x02\n\x01\x12\x04\xda\x01)/\n\r\n\x05\x04\x12\
    \x02\n\x03\x12\x04\xda\x0124\n\x0c\n\x02\x04\x13\x12\x06\xdd\x01\0\xe6\
    \x01\x01\n\x0b\n\x03\x04\x13\x01\x12\x04\xdd\x01\x08\x1e\n\x0c\n\x04\x04\
    \x13\x02\0\x12\x04\xde\x01\x08#\n\r\n\x05\x04\x13\x02\0\x04\x12\x04\xde\
    \x01\x08\x10\n\r\n\x05\x04\x13\x02\0\x05\x12\x04\xde\x01\x11\x16\n\r\n\
    \x05\x04\x13\x02\0\x01\x12\x04\xde\x01\x17\x1e\n\r\n\x05\x04\x13\x02\0\
    \x03\x12\x04\xde\x01!\"\n\x0c\n\x04\x04\x13\x02\x01\x12\x04\xdf\x01\x086\
    \n\r\n\x05\x04\x13\x02\x01\x04\x12\x04\xdf\x01\x08\x10\n\r\n\x05\x04\x13\
    \x02\x01\x05\x12\x04\xdf\x01\x11\x17\n\r\n\x05\x04\x13\x02\x01\x01\x12\
    \x04\xdf\x01\x18#\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\xdf\x01&'\n\r\n\
    \x05\x04\x13\x02\x01\x08\x12\x04\xdf\x01(5\n\r\n\x05\x04\x13\x02\x01\x07\
    \x12\x04\xdf\x0134\n\x0c\n\x04\x04\x13\x02\x02\x12\x04\xe0\x01\x08*\n\r\
    \n\x05\x04\x13\x02\x02\x04\x12\x04\xe0\x01\x08\x10\n\r\n\x05\x04\x13\x02\
    \x02\x05\x12\x04\xe0\x01\x11\x16\n\r\n\x05\x04\x13\x02\x02\x01\x12\x04\
    \xe0\x01\x17%\n\r\n\x05\x04\x13\x02\x02\x03\x12\x04\xe0\x01()\n\x0c\n\
    \x04\x04\x13\x02\x03\x12\x04\xe1\x01\x08*\n\r\n\x05\x04\x13\x02\x03\x04\
    \x12\x04\xe1\x01\x08\x10\n\r\n\x05\x04\x13\x02\x03\x05\x12\x04\xe1\x01\
    \x11\x16\n\r\n\x05\x04\x13\x02\x03\x01\x12\x04\xe1\x01\x17%\n\r\n\x05\
    \x04\x13\x02\x03\x03\x12\x04\xe1\x01()\n\x0c\n\x04\x04\x13\x02\x04\x12\
    \x04\xe2\x01\x08*\n\r\n\x05\x04\x13\x02\x04\x04\x12\x04\xe2\x01\x08\x10\
    \n\r\n\x05\x04\x13\x02\x04\x05\x12\x04\xe2\x01\x11\x16\n\r\n\x05\x04\x13\
    \x02\x04\x01\x12\x04\xe2\x01\x17%\n\r\n\x05\x04\x13\x02\x04\x03\x12\x04\
    \xe2\x01()\n\x0c\n\x04\x04\x13\x02\x05\x12\x04\xe3\x01\x08*\n\r\n\x05\
    \x04\x13\x02\x05\x04\x12\x04\xe3\x01\x08\x10\n\r\n\x05\x04\x13\x02\x05\
    \x05\x12\x04\xe3\x01\x11\x16\n\r\n\x05\x04\x13\x02\x05\x01\x12\x04\xe3\
    \x01\x17%\n\r\n\x05\x04\x13\x02\x05\x03\x12\x04\xe3\x01()\n\x0b\n\x03\
    \x04\x13\x05\x12\x04\xe5\x01\x08\x1f\n\x0c\n\x04\x04\x13\x05\0\x12\x04\
    \xe5\x01\x13\x1e\n\r\n\x05\x04\x13\x05\0\x01\x12\x04\xe5\x01\x13\x17\n\r\
    \n\x05\x04\x13\x05\0\x02\x12\x04\xe5\x01\x1b\x1e\n\x0c\n\x02\x04\x14\x12\
    \x06\xe8\x01\0\xf6\x01\x01\n\x0b\n\x03\x04\x14\x01\x12\x04\xe8\x01\x08\
    \x1f\n\r\n\x03\x04\x14\x06\x12\x06\xe9\x01\x08\xeb\x01\t\n\x0c\n\x04\x04\
    \x14\x06\0\x12\x04\xea\x01\x10a\n\r\n\x05\x04\x14\x06\0\x02\x12\x04\xe9\
    \x01\x0f&\n\r\n\x05\x04\x14\x06\0\x04\x12\x04\xea\x01\x10\x18\n\r\n\x05\
    \x04\x14\x06\0\x06\x12\x04\xea\x01\x19D\n\r\n\x05\x04\x14\x06\0\x01\x12\
    \x04\xea\x01EY\n\r\n\x05\x04\x14\x06\0\x03\x12\x04\xea\x01\\`\n\x0e\n\
    \x04\x04\x14\x03\0\x12\x06\xed\x01\x08\xef\x01\t\n\r\n\x05\x04\x14\x03\0\
    \x01\x12\x04\xed\x01\x10\"\n\x0e\n\x06\x04\x14\x03\0\x02\0\x12\x04\xee\
    \x01\x10-\n\x0f\n\x07\x04\x14\x03\0\x02\0\x04\x12\x04\xee\x01\x10\x18\n\
    \x0f\n\x07\x04\x14\x03\0\x02\0\x06\x12\x04\xee\x01\x19#\n\x0f\n\x07\x04\
    \x14\x03\0\x02\0\x01\x12\x04\xee\x01$(\n\x0f\n\x07\x04\x14\x03\0\x02\0\
    \x03\x12\x04\xee\x01+,\n\x0c\n\x04\x04\x14\x02\0\x12\x04\xf1\x01\x08%\n\
    \r\n\x05\x04\x14\x02\0\x04\x12\x04\xf1\x01\x08\x10\n\r\n\x05\x04\x14\x02\
    \0\x06\x12\x04\xf1\x01\x11\x1b\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\xf1\
    \x01\x1c\x20\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xf1\x01#$\n\x0c\n\x04\
    \x04\x14\x02\x01\x12\x04\xf2\x01\x08+\n\r\n\x05\x04\x14\x02\x01\x04\x12\
    \x04\xf2\x01\x08\x10\n\r\n\x05\x04\x14\x02\x01\x06\x12\x04\xf2\x01\x11\
    \x1b\n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\xf2\x01\x1c&\n\r\n\x05\x04\
    \x14\x02\x01\x03\x12\x04\xf2\x01)*\n\x0c\n\x04\x04\x14\x02\x02\x12\x04\
    \xf3\x01\x089\n\r\n\x05\x04\x14\x02\x02\x04\x12\x04\xf3\x01\x08\x10\n\r\
    \n\x05\x04\x14\x02\x02\x06\x12\x04\xf3\x01\x11$\n\r\n\x05\x04\x14\x02\
    \x02\x01\x12\x04\xf3\x01%4\n\r\n\x05\x04\x14\x02\x02\x03\x12\x04\xf3\x01\
    78\n\x0c\n\x04\x04\x14\x02\x03\x12\x04\xf4\x01\x08)\n\r\n\x05\x04\x14\
    \x02\x03\x04\x12\x04\xf4\x01\x08\x10\n\r\n\x05\x04\x14\x02\x03\x05\x12\
    \x04\xf4\x01\x11\x17\n\r\n\x05\x04\x14\x02\x03\x01\x12\x04\xf4\x01\x18$\
    \n\r\n\x05\x04\x14\x02\x03\x03\x12\x04\xf4\x01'(\n\x0c\n\x04\x04\x14\x02\
    \x04\x12\x04\xf5\x01\x083\n\r\n\x05\x04\x14\x02\x04\x04\x12\x04\xf5\x01\
    \x08\x10\n\r\n\x05\x04\x14\x02\x04\x06\x12\x04\xf5\x01\x11#\n\r\n\x05\
    \x04\x14\x02\x04\x01\x12\x04\xf5\x01$.\n\r\n\x05\x04\x14\x02\x04\x03\x12\
    \x04\xf5\x0112\n\x0c\n\x02\x04\x15\x12\x06\xf8\x01\0\x86\x02\x01\n\x0b\n\
    \x03\x04\x15\x01\x12\x04\xf8\x01\x08\x11\n\r\n\x03\x04\x15\x06\x12\x06\
    \xf9\x01\x08\xfb\x01\t\n\x0c\n\x04\x04\x15\x06\0\x12\x04\xfa\x01\x10S\n\
    \r\n\x05\x04\x15\x06\0\x02\x12\x04\xf9\x01\x0f&\n\r\n\x05\x04\x15\x06\0\
    \x04\x12\x04\xfa\x01\x10\x18\n\r\n\x05\x04\x15\x06\0\x06\x12\x04\xfa\x01\
    \x196\n\r\n\x05\x04\x15\x06\0\x01\x12\x04\xfa\x017K\n\r\n\x05\x04\x15\
    \x06\0\x03\x12\x04\xfa\x01NR\n\x0e\n\x04\x04\x15\x03\0\x12\x06\xfd\x01\
    \x08\xff\x01\t\n\r\n\x05\x04\x15\x03\0\x01\x12\x04\xfd\x01\x10\"\n\x0e\n\
    \x06\x04\x15\x03\0\x02\0\x12\x04\xfe\x01\x10)\n\x0f\n\x07\x04\x15\x03\0\
    \x02\0\x04\x12\x04\xfe\x01\x10\x18\n\x0f\n\x07\x04\x15\x03\0\x02\0\x05\
    \x12\x04\xfe\x01\x19\x1f\n\x0f\n\x07\x04\x15\x03\0\x02\0\x01\x12\x04\xfe\
    \x01\x20$\n\x0f\n\x07\x04\x15\x03\0\x02\0\x03\x12\x04\xfe\x01'(\n\x0c\n\
    \x04\x04\x15\x02\0\x12\x04\x81\x02\x08!\n\r\n\x05\x04\x15\x02\0\x04\x12\
    \x04\x81\x02\x08\x10\n\r\n\x05\x04\x15\x02\0\x05\x12\x04\x81\x02\x11\x17\
    \n\r\n\x05\x04\x15\x02\0\x01\x12\x04\x81\x02\x18\x1c\n\r\n\x05\x04\x15\
    \x02\0\x03\x12\x04\x81\x02\x1f\x20\n\x0c\n\x04\x04\x15\x02\x01\x12\x04\
    \x82\x02\x08'\n\r\n\x05\x04\x15\x02\x01\x04\x12\x04\x82\x02\x08\x10\n\r\
    \n\x05\x04\x15\x02\x01\x05\x12\x04\x82\x02\x11\x17\n\r\n\x05\x04\x15\x02\
    \x01\x01\x12\x04\x82\x02\x18\"\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\x82\
    \x02%&\n\x0c\n\x04\x04\x15\x02\x02\x12\x04\x83\x02\x089\n\r\n\x05\x04\
    \x15\x02\x02\x04\x12\x04\x83\x02\x08\x10\n\r\n\x05\x04\x15\x02\x02\x06\
    \x12\x04\x83\x02\x11$\n\r\n\x05\x04\x15\x02\x02\x01\x12\x04\x83\x02%4\n\
    \r\n\x05\x04\x15\x02\x02\x03\x12\x04\x83\x0278\n\x0c\n\x04\x04\x15\x02\
    \x03\x12\x04\x84\x02\x08)\n\r\n\x05\x04\x15\x02\x03\x04\x12\x04\x84\x02\
    \x08\x10\n\r\n\x05\x04\x15\x02\x03\x05\x12\x04\x84\x02\x11\x17\n\r\n\x05\
    \x04\x15\x02\x03\x01\x12\x04\x84\x02\x18$\n\r\n\x05\x04\x15\x02\x03\x03\
    \x12\x04\x84\x02'(\n\x0c\n\x04\x04\x15\x02\x04\x12\x04\x85\x02\x083\n\r\
    \n\x05\x04\x15\x02\x04\x04\x12\x04\x85\x02\x08\x10\n\r\n\x05\x04\x15\x02\
    \x04\x06\x12\x04\x85\x02\x11#\n\r\n\x05\x04\x15\x02\x04\x01\x12\x04\x85\
    \x02$.\n\r\n\x05\x04\x15\x02\x04\x03\x12\x04\x85\x0212\n\x0c\n\x02\x04\
    \x16\x12\x06\x88\x02\0\x8b\x02\x01\n\x0b\n\x03\x04\x16\x01\x12\x04\x88\
    \x02\x08\x15\n\x0c\n\x04\x04\x16\x02\0\x12\x04\x89\x02\x08%\n\r\n\x05\
    \x04\x16\x02\0\x04\x12\x04\x89\x02\x08\x10\n\r\n\x05\x04\x16\x02\0\x05\
    \x12\x04\x89\x02\x11\x17\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\x89\x02\x18\
    \x20\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\x89\x02#$\n\x0c\n\x04\x04\x16\
    \x02\x01\x12\x04\x8a\x02\x08'\n\r\n\x05\x04\x16\x02\x01\x04\x12\x04\x8a\
    \x02\x08\x10\n\r\n\x05\x04\x16\x02\x01\x05\x12\x04\x8a\x02\x11\x17\n\r\n\
    \x05\x04\x16\x02\x01\x01\x12\x04\x8a\x02\x18\"\n\r\n\x05\x04\x16\x02\x01\
    \x03\x12\x04\x8a\x02%&\n\x0c\n\x02\x04\x17\x12\x06\x8d\x02\0\x91\x02\x01\
    \n\x0b\n\x03\x04\x17\x01\x12\x04\x8d\x02\x08\x1a\n\x0c\n\x04\x04\x17\x02\
    \0\x12\x04\x8e\x02\x08/\n\r\n\x05\x04\x17\x02\0\x04\x12\x04\x8e\x02\x08\
    \x10\n\r\n\x05\x04\x17\x02\0\x06\x12\x04\x8e\x02\x11\x1b\n\r\n\x05\x04\
    \x17\x02\0\x01\x12\x04\x8e\x02\x1c*\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\
    \x8e\x02-.\n\x0c\n\x04\x04\x17\x02\x01\x12\x04\x8f\x02\x08-\n\r\n\x05\
    \x04\x17\x02\x01\x04\x12\x04\x8f\x02\x08\x10\n\r\n\x05\x04\x17\x02\x01\
    \x06\x12\x04\x8f\x02\x11\x1b\n\r\n\x05\x04\x17\x02\x01\x01\x12\x04\x8f\
    \x02\x1c(\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\x8f\x02+,\n\x0c\n\x04\
    \x04\x17\x02\x02\x12\x04\x90\x02\x08/\n\r\n\x05\x04\x17\x02\x02\x04\x12\
    \x04\x90\x02\x08\x10\n\r\n\x05\x04\x17\x02\x02\x06\x12\x04\x90\x02\x11\
    \x1f\n\r\n\x05\x04\x17\x02\x02\x01\x12\x04\x90\x02\x20*\n\r\n\x05\x04\
    \x17\x02\x02\x03\x12\x04\x90\x02-.\n\x0c\n\x02\x04\x18\x12\x06\x93\x02\0\
    \x98\x02\x01\n\x0b\n\x03\x04\x18\x01\x12\x04\x93\x02\x08\x1a\n\x0c\n\x04\
    \x04\x18\x02\0\x12\x04\x94\x02\x080\n\r\n\x05\x04\x18\x02\0\x04\x12\x04\
    \x94\x02\x08\x10\n\r\n\x05\x04\x18\x02\0\x06\x12\x04\x94\x02\x11\x1b\n\r\
    \n\x05\x04\x18\x02\0\x01\x12\x04\x94\x02\x1c+\n\r\n\x05\x04\x18\x02\0\
    \x03\x12\x04\x94\x02./\n\x0c\n\x04\x04\x18\x02\x01\x12\x04\x95\x02\x080\
    \n\r\n\x05\x04\x18\x02\x01\x04\x12\x04\x95\x02\x08\x10\n\r\n\x05\x04\x18\
    \x02\x01\x06\x12\x04\x95\x02\x11\x1b\n\r\n\x05\x04\x18\x02\x01\x01\x12\
    \x04\x95\x02\x1c+\n\r\n\x05\x04\x18\x02\x01\x03\x12\x04\x95\x02./\n\x0c\
    \n\x04\x04\x18\x02\x02\x12\x04\x96\x02\x08&\n\r\n\x05\x04\x18\x02\x02\
    \x04\x12\x04\x96\x02\x08\x10\n\r\n\x05\x04\x18\x02\x02\x06\x12\x04\x96\
    \x02\x11\x1b\n\r\n\x05\x04\x18\x02\x02\x01\x12\x04\x96\x02\x1c!\n\r\n\
    \x05\x04\x18\x02\x02\x03\x12\x04\x96\x02$%\n\x0c\n\x04\x04\x18\x02\x03\
    \x12\x04\x97\x02\x08/\n\r\n\x05\x04\x18\x02\x03\x04\x12\x04\x97\x02\x08\
    \x10\n\r\n\x05\x04\x18\x02\x03\x06\x12\x04\x97\x02\x11\x1f\n\r\n\x05\x04\
    \x18\x02\x03\x01\x12\x04\x97\x02\x20*\n\r\n\x05\x04\x18\x02\x03\x03\x12\
    \x04\x97\x02-.\n\x0c\n\x02\x04\x19\x12\x06\x9a\x02\0\x9f\x02\x01\n\x0b\n\
    \x03\x04\x19\x01\x12\x04\x9a\x02\x08\x14\n\x0c\n\x04\x04\x19\x02\0\x12\
    \x04\x9b\x02\x082\n\r\n\x05\x04\x19\x02\0\x04\x12\x04\x9b\x02\x08\x10\n\
    \r\n\x05\x04\x19\x02\0\x06\x12\x04\x9b\x02\x11\x1b\n\r\n\x05\x04\x19\x02\
    \0\x01\x12\x04\x9b\x02\x1c-\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\x9b\x020\
    1\n\x0c\n\x04\x04\x19\x02\x01\x12\x04\x9c\x02\x08)\n\r\n\x05\x04\x19\x02\
    \x01\x04\x12\x04\x9c\x02\x08\x10\n\r\n\x05\x04\x19\x02\x01\x05\x12\x04\
    \x9c\x02\x11\x16\n\r\n\x05\x04\x19\x02\x01\x01\x12\x04\x9c\x02\x17$\n\r\
    \n\x05\x04\x19\x02\x01\x03\x12\x04\x9c\x02'(\n\x0c\n\x04\x04\x19\x02\x02\
    \x12\x04\x9d\x02\x08.\n\r\n\x05\x04\x19\x02\x02\x04\x12\x04\x9d\x02\x08\
    \x10\n\r\n\x05\x04\x19\x02\x02\x05\x12\x04\x9d\x02\x11\x16\n\r\n\x05\x04\
    \x19\x02\x02\x01\x12\x04\x9d\x02\x17)\n\r\n\x05\x04\x19\x02\x02\x03\x12\
    \x04\x9d\x02,-\n\x0c\n\x04\x04\x19\x02\x03\x12\x04\x9e\x02\x08'\n\r\n\
    \x05\x04\x19\x02\x03\x04\x12\x04\x9e\x02\x08\x10\n\r\n\x05\x04\x19\x02\
    \x03\x05\x12\x04\x9e\x02\x11\x17\n\r\n\x05\x04\x19\x02\x03\x01\x12\x04\
    \x9e\x02\x18\"\n\r\n\x05\x04\x19\x02\x03\x03\x12\x04\x9e\x02%&\n\x0c\n\
    \x02\x04\x1a\x12\x06\xa1\x02\0\xbb\x02\x01\n\x0b\n\x03\x04\x1a\x01\x12\
    \x04\xa1\x02\x08\x1a\n\x0c\n\x04\x04\x1a\x02\0\x12\x04\xa2\x02\x08.\n\r\
    \n\x05\x04\x1a\x02\0\x04\x12\x04\xa2\x02\x08\x10\n\r\n\x05\x04\x1a\x02\0\
    \x06\x12\x04\xa2\x02\x11\x1b\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\xa2\x02\
    \x1c)\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\xa2\x02,-\n\x0c\n\x04\x04\x1a\
    \x02\x01\x12\x04\xa3\x02\x087\n\r\n\x05\x04\x1a\x02\x01\x04\x12\x04\xa3\
    \x02\x08\x10\n\r\n\x05\x04\x1a\x02\x01\x06\x12\x04\xa3\x02\x11\x1b\n\r\n\
    \x05\x04\x1a\x02\x01\x01\x12\x04\xa3\x02\x1c2\n\r\n\x05\x04\x1a\x02\x01\
    \x03\x12\x04\xa3\x0256\n\x0c\n\x04\x04\x1a\x02\x02\x12\x04\xa4\x02\x08*\
    \n\r\n\x05\x04\x1a\x02\x02\x04\x12\x04\xa4\x02\x08\x10\n\r\n\x05\x04\x1a\
    \x02\x02\x05\x12\x04\xa4\x02\x11\x17\n\r\n\x05\x04\x1a\x02\x02\x01\x12\
    \x04\xa4\x02\x18%\n\r\n\x05\x04\x1a\x02\x02\x03\x12\x04\xa4\x02()\n\x0c\
    \n\x04\x04\x1a\x02\x03\x12\x04\xa5\x02\x083\n\r\n\x05\x04\x1a\x02\x03\
    \x04\x12\x04\xa5\x02\x08\x10\n\r\n\x05\x04\x1a\x02\x03\x05\x12\x04\xa5\
    \x02\x11\x17\n\r\n\x05\x04\x1a\x02\x03\x01\x12\x04\xa5\x02\x18.\n\r\n\
    \x05\x04\x1a\x02\x03\x03\x12\x04\xa5\x0212\n\x0c\n\x04\x04\x1a\x02\x04\
    \x12\x04\xa6\x02\x081\n\r\n\x05\x04\x1a\x02\x04\x04\x12\x04\xa6\x02\x08\
    \x10\n\r\n\x05\x04\x1a\x02\x04\x05\x12\x04\xa6\x02\x11\x17\n\r\n\x05\x04\
    \x1a\x02\x04\x01\x12\x04\xa6\x02\x18,\n\r\n\x05\x04\x1a\x02\x04\x03\x12\
    \x04\xa6\x02/0\n\x0c\n\x04\x04\x1a\x02\x05\x12\x04\xa7\x02\x08:\n\r\n\
    \x05\x04\x1a\x02\x05\x04\x12\x04\xa7\x02\x08\x10\n\r\n\x05\x04\x1a\x02\
    \x05\x05\x12\x04\xa7\x02\x11\x17\n\r\n\x05\x04\x1a\x02\x05\x01\x12\x04\
    \xa7\x02\x185\n\r\n\x05\x04\x1a\x02\x05\x03\x12\x04\xa7\x0289\n\x0c\n\
    \x04\x04\x1a\x02\x06\x12\x04\xa8\x02\x086\n\r\n\x05\x04\x1a\x02\x06\x04\
    \x12\x04\xa8\x02\x08\x10\n\r\n\x05\x04\x1a\x02\x06\x05\x12\x04\xa8\x02\
    \x11\x17\n\r\n\x05\x04\x1a\x02\x06\x01\x12\x04\xa8\x02\x181\n\r\n\x05\
    \x04\x1a\x02\x06\x03\x12\x04\xa8\x0245\n\x0c\n\x04\x04\x1a\x02\x07\x12\
    \x04\xa9\x02\x08?\n\r\n\x05\x04\x1a\x02\x07\x04\x12\x04\xa9\x02\x08\x10\
    \n\r\n\x05\x04\x1a\x02\x07\x05\x12\x04\xa9\x02\x11\x17\n\r\n\x05\x04\x1a\
    \x02\x07\x01\x12\x04\xa9\x02\x18:\n\r\n\x05\x04\x1a\x02\x07\x03\x12\x04\
    \xa9\x02=>\n\x0c\n\x04\x04\x1a\x02\x08\x12\x04\xaa\x02\x08:\n\r\n\x05\
    \x04\x1a\x02\x08\x04\x12\x04\xaa\x02\x08\x10\n\r\n\x05\x04\x1a\x02\x08\
    \x06\x12\x04\xaa\x02\x11\x1b\n\r\n\x05\x04\x1a\x02\x08\x01\x12\x04\xaa\
    \x02\x1c5\n\r\n\x05\x04\x1a\x02\x08\x03\x12\x04\xaa\x0289\n\x0c\n\x04\
    \x04\x1a\x02\t\x12\x04\xab\x02\x08D\n\r\n\x05\x04\x1a\x02\t\x04\x12\x04\
    \xab\x02\x08\x10\n\r\n\x05\x04\x1a\x02\t\x06\x12\x04\xab\x02\x11\x1b\n\r\
    \n\x05\x04\x1a\x02\t\x01\x12\x04\xab\x02\x1c>\n\r\n\x05\x04\x1a\x02\t\
    \x03\x12\x04\xab\x02AC\n\x0c\n\x04\x04\x1a\x02\n\x12\x04\xac\x02\x086\n\
    \r\n\x05\x04\x1a\x02\n\x04\x12\x04\xac\x02\x08\x10\n\r\n\x05\x04\x1a\x02\
    \n\x06\x12\x04\xac\x02\x11\x1b\n\r\n\x05\x04\x1a\x02\n\x01\x12\x04\xac\
    \x02\x1c0\n\r\n\x05\x04\x1a\x02\n\x03\x12\x04\xac\x0235\n\x0c\n\x04\x04\
    \x1a\x02\x0b\x12\x04\xad\x02\x08H\n\r\n\x05\x04\x1a\x02\x0b\x04\x12\x04\
    \xad\x02\x08\x10\n\r\n\x05\x04\x1a\x02\x0b\x06\x12\x04\xad\x02\x11\x1b\n\
    \r\n\x05\x04\x1a\x02\x0b\x01\x12\x04\xad\x02\x1cB\n\r\n\x05\x04\x1a\x02\
    \x0b\x03\x12\x04\xad\x02EG\n\x0c\n\x04\x04\x1a\x02\x0c\x12\x04\xae\x02\
    \x08.\n\r\n\x05\x04\x1a\x02\x0c\x04\x12\x04\xae\x02\x08\x10\n\r\n\x05\
    \x04\x1a\x02\x0c\x05\x12\x04\xae\x02\x11\x17\n\r\n\x05\x04\x1a\x02\x0c\
    \x01\x12\x04\xae\x02\x18(\n\r\n\x05\x04\x1a\x02\x0c\x03\x12\x04\xae\x02+\
    -\n\x0c\n\x04\x04\x1a\x02\r\x12\x04\xaf\x02\x087\n\r\n\x05\x04\x1a\x02\r\
    \x04\x12\x04\xaf\x02\x08\x10\n\r\n\x05\x04\x1a\x02\r\x05\x12\x04\xaf\x02\
    \x11\x17\n\r\n\x05\x04\x1a\x02\r\x01\x12\x04\xaf\x02\x181\n\r\n\x05\x04\
    \x1a\x02\r\x03\x12\x04\xaf\x0246\n\x0c\n\x04\x04\x1a\x02\x0e\x12\x04\xb0\
    \x02\x08,\n\r\n\x05\x04\x1a\x02\x0e\x04\x12\x04\xb0\x02\x08\x10\n\r\n\
    \x05\x04\x1a\x02\x0e\x05\x12\x04\xb0\x02\x11\x17\n\r\n\x05\x04\x1a\x02\
    \x0e\x01\x12\x04\xb0\x02\x18&\n\r\n\x05\x04\x1a\x02\x0e\x03\x12\x04\xb0\
    \x02)+\n\x0c\n\x04\x04\x1a\x02\x0f\x12\x04\xb1\x02\x085\n\r\n\x05\x04\
    \x1a\x02\x0f\x04\x12\x04\xb1\x02\x08\x10\n\r\n\x05\x04\x1a\x02\x0f\x05\
    \x12\x04\xb1\x02\x11\x17\n\r\n\x05\x04\x1a\x02\x0f\x01\x12\x04\xb1\x02\
    \x18/\n\r\n\x05\x04\x1a\x02\x0f\x03\x12\x04\xb1\x0224\n\x0c\n\x04\x04\
    \x1a\x02\x10\x12\x04\xb2\x02\x081\n\r\n\x05\x04\x1a\x02\x10\x04\x12\x04\
    \xb2\x02\x08\x10\n\r\n\x05\x04\x1a\x02\x10\x05\x12\x04\xb2\x02\x11\x17\n\
    \r\n\x05\x04\x1a\x02\x10\x01\x12\x04\xb2\x02\x18+\n\r\n\x05\x04\x1a\x02\
    \x10\x03\x12\x04\xb2\x02.0\n\x0c\n\x04\x04\x1a\x02\x11\x12\x04\xb3\x02\
    \x080\n\r\n\x05\x04\x1a\x02\x11\x04\x12\x04\xb3\x02\x08\x10\n\r\n\x05\
    \x04\x1a\x02\x11\x05\x12\x04\xb3\x02\x11\x17\n\r\n\x05\x04\x1a\x02\x11\
    \x01\x12\x04\xb3\x02\x18*\n\r\n\x05\x04\x1a\x02\x11\x03\x12\x04\xb3\x02-\
    /\n\x0c\n\x04\x04\x1a\x02\x12\x12\x04\xb4\x02\x08/\n\r\n\x05\x04\x1a\x02\
    \x12\x04\x12\x04\xb4\x02\x08\x10\n\r\n\x05\x04\x1a\x02\x12\x05\x12\x04\
    \xb4\x02\x11\x16\n\r\n\x05\x04\x1a\x02\x12\x01\x12\x04\xb4\x02\x17)\n\r\
    \n\x05\x04\x1a\x02\x12\x03\x12\x04\xb4\x02,.\n\x0c\n\x04\x04\x1a\x02\x13\
    \x12\x04\xb5\x02\x088\n\r\n\x05\x04\x1a\x02\x13\x04\x12\x04\xb5\x02\x08\
    \x10\n\r\n\x05\x04\x1a\x02\x13\x05\x12\x04\xb5\x02\x11\x16\n\r\n\x05\x04\
    \x1a\x02\x13\x01\x12\x04\xb5\x02\x172\n\r\n\x05\x04\x1a\x02\x13\x03\x12\
    \x04\xb5\x0257\n\x0c\n\x04\x04\x1a\x02\x14\x12\x04\xb6\x02\x08-\n\r\n\
    \x05\x04\x1a\x02\x14\x04\x12\x04\xb6\x02\x08\x10\n\r\n\x05\x04\x1a\x02\
    \x14\x05\x12\x04\xb6\x02\x11\x16\n\r\n\x05\x04\x1a\x02\x14\x01\x12\x04\
    \xb6\x02\x17'\n\r\n\x05\x04\x1a\x02\x14\x03\x12\x04\xb6\x02*,\n\x0c\n\
    \x04\x04\x1a\x02\x15\x12\x04\xb7\x02\x086\n\r\n\x05\x04\x1a\x02\x15\x04\
    \x12\x04\xb7\x02\x08\x10\n\r\n\x05\x04\x1a\x02\x15\x05\x12\x04\xb7\x02\
    \x11\x16\n\r\n\x05\x04\x1a\x02\x15\x01\x12\x04\xb7\x02\x170\n\r\n\x05\
    \x04\x1a\x02\x15\x03\x12\x04\xb7\x0235\n\x0c\n\x04\x04\x1a\x02\x16\x12\
    \x04\xb8\x02\x087\n\r\n\x05\x04\x1a\x02\x16\x04\x12\x04\xb8\x02\x08\x10\
    \n\r\n\x05\x04\x1a\x02\x16\x06\x12\x04\xb8\x02\x11\x1b\n\r\n\x05\x04\x1a\
    \x02\x16\x01\x12\x04\xb8\x02\x1c1\n\r\n\x05\x04\x1a\x02\x16\x03\x12\x04\
    \xb8\x0246\n\x0c\n\x04\x04\x1a\x02\x17\x12\x04\xb9\x02\x087\n\r\n\x05\
    \x04\x1a\x02\x17\x04\x12\x04\xb9\x02\x08\x10\n\r\n\x05\x04\x1a\x02\x17\
    \x06\x12\x04\xb9\x02\x11\x1b\n\r\n\x05\x04\x1a\x02\x17\x01\x12\x04\xb9\
    \x02\x1c1\n\r\n\x05\x04\x1a\x02\x17\x03\x12\x04\xb9\x0246\n\x0c\n\x04\
    \x04\x1a\x02\x18\x12\x04\xba\x02\x08.\n\r\n\x05\x04\x1a\x02\x18\x04\x12\
    \x04\xba\x02\x08\x10\n\r\n\x05\x04\x1a\x02\x18\x06\x12\x04\xba\x02\x11\
    \x1e\n\r\n\x05\x04\x1a\x02\x18\x01\x12\x04\xba\x02\x1f(\n\r\n\x05\x04\
    \x1a\x02\x18\x03\x12\x04\xba\x02+-\n\x0c\n\x02\x04\x1b\x12\x06\xbd\x02\0\
    \xc3\x02\x01\n\x0b\n\x03\x04\x1b\x01\x12\x04\xbd\x02\x08\x15\n\x0c\n\x04\
    \x04\x1b\x02\0\x12\x04\xbe\x02\x08$\n\r\n\x05\x04\x1b\x02\0\x04\x12\x04\
    \xbe\x02\x08\x10\n\r\n\x05\x04\x1b\x02\0\x05\x12\x04\xbe\x02\x11\x17\n\r\
    \n\x05\x04\x1b\x02\0\x01\x12\x04\xbe\x02\x18\x1f\n\r\n\x05\x04\x1b\x02\0\
    \x03\x12\x04\xbe\x02\"#\n\x0c\n\x04\x04\x1b\x02\x01\x12\x04\xbf\x02\x08'\
    \n\r\n\x05\x04\x1b\x02\x01\x04\x12\x04\xbf\x02\x08\x10\n\r\n\x05\x04\x1b\
    \x02\x01\x05\x12\x04\xbf\x02\x11\x17\n\r\n\x05\x04\x1b\x02\x01\x01\x12\
    \x04\xbf\x02\x18\"\n\r\n\x05\x04\x1b\x02\x01\x03\x12\x04\xbf\x02%&\n\x0c\
    \n\x04\x04\x1b\x02\x02\x12\x04\xc0\x02\x089\n\r\n\x05\x04\x1b\x02\x02\
    \x04\x12\x04\xc0\x02\x08\x10\n\r\n\x05\x04\x1b\x02\x02\x06\x12\x04\xc0\
    \x02\x11$\n\r\n\x05\x04\x1b\x02\x02\x01\x12\x04\xc0\x02%4\n\r\n\x05\x04\
    \x1b\x02\x02\x03\x12\x04\xc0\x0278\n\x0c\n\x04\x04\x1b\x02\x03\x12\x04\
    \xc1\x02\x089\n\r\n\x05\x04\x1b\x02\x03\x04\x12\x04\xc1\x02\x08\x10\n\r\
    \n\x05\x04\x1b\x02\x03\x06\x12\x04\xc1\x02\x11$\n\r\n\x05\x04\x1b\x02\
    \x03\x01\x12\x04\xc1\x02%4\n\r\n\x05\x04\x1b\x02\x03\x03\x12\x04\xc1\x02\
    78\n\x0c\n\x04\x04\x1b\x02\x04\x12\x04\xc2\x02\x089\n\r\n\x05\x04\x1b\
    \x02\x04\x04\x12\x04\xc2\x02\x08\x10\n\r\n\x05\x04\x1b\x02\x04\x06\x12\
    \x04\xc2\x02\x11$\n\r\n\x05\x04\x1b\x02\x04\x01\x12\x04\xc2\x02%4\n\r\n\
    \x05\x04\x1b\x02\x04\x03\x12\x04\xc2\x0278\n\x0c\n\x02\x04\x1c\x12\x06\
    \xc5\x02\0\xd3\x02\x01\n\x0b\n\x03\x04\x1c\x01\x12\x04\xc5\x02\x08\x1f\n\
    \r\n\x03\x04\x1c\x06\x12\x06\xc6\x02\x08\xc8\x02\t\n\x0c\n\x04\x04\x1c\
    \x06\0\x12\x04\xc7\x02\x10a\n\r\n\x05\x04\x1c\x06\0\x02\x12\x04\xc6\x02\
    \x0f&\n\r\n\x05\x04\x1c\x06\0\x04\x12\x04\xc7\x02\x10\x18\n\r\n\x05\x04\
    \x1c\x06\0\x06\x12\x04\xc7\x02\x19D\n\r\n\x05\x04\x1c\x06\0\x01\x12\x04\
    \xc7\x02EY\n\r\n\x05\x04\x1c\x06\0\x03\x12\x04\xc7\x02\\`\n\x0e\n\x04\
    \x04\x1c\x03\0\x12\x06\xca\x02\x08\xcc\x02\t\n\r\n\x05\x04\x1c\x03\0\x01\
    \x12\x04\xca\x02\x10\"\n\x0e\n\x06\x04\x1c\x03\0\x02\0\x12\x04\xcb\x02\
    \x101\n\x0f\n\x07\x04\x1c\x03\0\x02\0\x04\x12\x04\xcb\x02\x10\x18\n\x0f\
    \n\x07\x04\x1c\x03\0\x02\0\x06\x12\x04\xcb\x02\x19'\n\x0f\n\x07\x04\x1c\
    \x03\0\x02\0\x01\x12\x04\xcb\x02(,\n\x0f\n\x07\x04\x1c\x03\0\x02\0\x03\
    \x12\x04\xcb\x02/0\n\x0c\n\x04\x04\x1c\x02\0\x12\x04\xce\x02\x08)\n\r\n\
    \x05\x04\x1c\x02\0\x04\x12\x04\xce\x02\x08\x10\n\r\n\x05\x04\x1c\x02\0\
    \x06\x12\x04\xce\x02\x11\x1f\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\xce\x02\
    \x20$\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\xce\x02'(\n\x0c\n\x04\x04\x1c\
    \x02\x01\x12\x04\xcf\x02\x08/\n\r\n\x05\x04\x1c\x02\x01\x04\x12\x04\xcf\
    \x02\x08\x10\n\r\n\x05\x04\x1c\x02\x01\x06\x12\x04\xcf\x02\x11\x1f\n\r\n\
    \x05\x04\x1c\x02\x01\x01\x12\x04\xcf\x02\x20*\n\r\n\x05\x04\x1c\x02\x01\
    \x03\x12\x04\xcf\x02-.\n\x0c\n\x04\x04\x1c\x02\x02\x12\x04\xd0\x02\x089\
    \n\r\n\x05\x04\x1c\x02\x02\x04\x12\x04\xd0\x02\x08\x10\n\r\n\x05\x04\x1c\
    \x02\x02\x06\x12\x04\xd0\x02\x11$\n\r\n\x05\x04\x1c\x02\x02\x01\x12\x04\
    \xd0\x02%4\n\r\n\x05\x04\x1c\x02\x02\x03\x12\x04\xd0\x0278\n\x0c\n\x04\
    \x04\x1c\x02\x03\x12\x04\xd1\x02\x08)\n\r\n\x05\x04\x1c\x02\x03\x04\x12\
    \x04\xd1\x02\x08\x10\n\r\n\x05\x04\x1c\x02\x03\x05\x12\x04\xd1\x02\x11\
    \x17\n\r\n\x05\x04\x1c\x02\x03\x01\x12\x04\xd1\x02\x18$\n\r\n\x05\x04\
    \x1c\x02\x03\x03\x12\x04\xd1\x02'(\n\x0c\n\x04\x04\x1c\x02\x04\x12\x04\
    \xd2\x02\x083\n\r\n\x05\x04\x1c\x02\x04\x04\x12\x04\xd2\x02\x08\x10\n\r\
    \n\x05\x04\x1c\x02\x04\x06\x12\x04\xd2\x02\x11#\n\r\n\x05\x04\x1c\x02\
    \x04\x01\x12\x04\xd2\x02$.\n\r\n\x05\x04\x1c\x02\x04\x03\x12\x04\xd2\x02\
    12\n\x0c\n\x02\x04\x1d\x12\x06\xd5\x02\0\xd7\x02\x01\n\x0b\n\x03\x04\x1d\
    \x01\x12\x04\xd5\x02\x08%\n\x0c\n\x04\x04\x1d\x02\0\x12\x04\xd6\x02\x08/\
    \n\r\n\x05\x04\x1d\x02\0\x04\x12\x04\xd6\x02\x08\x10\n\r\n\x05\x04\x1d\
    \x02\0\x06\x12\x04\xd6\x02\x11\x1f\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\
    \xd6\x02\x20*\n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\xd6\x02-.\n\x0c\n\x02\
    \x04\x1e\x12\x06\xd9\x02\0\xeb\x02\x01\n\x0b\n\x03\x04\x1e\x01\x12\x04\
    \xd9\x02\x08\x19\n\r\n\x03\x04\x1e\x06\x12\x06\xda\x02\x08\xdc\x02\t\n\
    \x0c\n\x04\x04\x1e\x06\0\x12\x04\xdb\x02\x10[\n\r\n\x05\x04\x1e\x06\0\
    \x02\x12\x04\xda\x02\x0f&\n\r\n\x05\x04\x1e\x06\0\x04\x12\x04\xdb\x02\
    \x10\x18\n\r\n\x05\x04\x1e\x06\0\x06\x12\x04\xdb\x02\x19>\n\r\n\x05\x04\
    \x1e\x06\0\x01\x12\x04\xdb\x02?S\n\r\n\x05\x04\x1e\x06\0\x03\x12\x04\xdb\
    \x02VZ\n\x0e\n\x04\x04\x1e\x03\0\x12\x06\xde\x02\x08\xe0\x02\t\n\r\n\x05\
    \x04\x1e\x03\0\x01\x12\x04\xde\x02\x10\"\n\x0e\n\x06\x04\x1e\x03\0\x02\0\
    \x12\x04\xdf\x02\x10-\n\x0f\n\x07\x04\x1e\x03\0\x02\0\x04\x12\x04\xdf\
    \x02\x10\x18\n\x0f\n\x07\x04\x1e\x03\0\x02\0\x06\x12\x04\xdf\x02\x19#\n\
    \x0f\n\x07\x04\x1e\x03\0\x02\0\x01\x12\x04\xdf\x02$(\n\x0f\n\x07\x04\x1e\
    \x03\0\x02\0\x03\x12\x04\xdf\x02+,\n\x0c\n\x04\x04\x1e\x02\0\x12\x04\xe2\
    \x02\x08%\n\r\n\x05\x04\x1e\x02\0\x04\x12\x04\xe2\x02\x08\x10\n\r\n\x05\
    \x04\x1e\x02\0\x06\x12\x04\xe2\x02\x11\x1b\n\r\n\x05\x04\x1e\x02\0\x01\
    \x12\x04\xe2\x02\x1c\x20\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\xe2\x02#$\n\
    \x0c\n\x04\x04\x1e\x02\x01\x12\x04\xe3\x02\x08+\n\r\n\x05\x04\x1e\x02\
    \x01\x04\x12\x04\xe3\x02\x08\x10\n\r\n\x05\x04\x1e\x02\x01\x06\x12\x04\
    \xe3\x02\x11\x1b\n\r\n\x05\x04\x1e\x02\x01\x01\x12\x04\xe3\x02\x1c&\n\r\
    \n\x05\x04\x1e\x02\x01\x03\x12\x04\xe3\x02)*\n\x0c\n\x04\x04\x1e\x02\x02\
    \x12\x04\xe4\x02\x089\n\r\n\x05\x04\x1e\x02\x02\x04\x12\x04\xe4\x02\x08\
    \x10\n\r\n\x05\x04\x1e\x02\x02\x06\x12\x04\xe4\x02\x11$\n\r\n\x05\x04\
    \x1e\x02\x02\x01\x12\x04\xe4\x02%4\n\r\n\x05\x04\x1e\x02\x02\x03\x12\x04\
    \xe4\x0278\n\x0c\n\x04\x04\x1e\x02\x03\x12\x04\xe5\x02\x08)\n\r\n\x05\
    \x04\x1e\x02\x03\x04\x12\x04\xe5\x02\x08\x10\n\r\n\x05\x04\x1e\x02\x03\
    \x05\x12\x04\xe5\x02\x11\x17\n\r\n\x05\x04\x1e\x02\x03\x01\x12\x04\xe5\
    \x02\x18$\n\r\n\x05\x04\x1e\x02\x03\x03\x12\x04\xe5\x02'(\n\x0c\n\x04\
    \x04\x1e\x02\x04\x12\x04\xe6\x02\x083\n\r\n\x05\x04\x1e\x02\x04\x04\x12\
    \x04\xe6\x02\x08\x10\n\r\n\x05\x04\x1e\x02\x04\x06\x12\x04\xe6\x02\x11#\
    \n\r\n\x05\x04\x1e\x02\x04\x01\x12\x04\xe6\x02$.\n\r\n\x05\x04\x1e\x02\
    \x04\x03\x12\x04\xe6\x0212\n\x0c\n\x04\x04\x1e\x02\x05\x12\x04\xe7\x02\
    \x08.\n\r\n\x05\x04\x1e\x02\x05\x04\x12\x04\xe7\x02\x08\x10\n\r\n\x05\
    \x04\x1e\x02\x05\x06\x12\x04\xe7\x02\x11\x1b\n\r\n\x05\x04\x1e\x02\x05\
    \x01\x12\x04\xe7\x02\x1c)\n\r\n\x05\x04\x1e\x02\x05\x03\x12\x04\xe7\x02,\
    -\n\x0c\n\x04\x04\x1e\x02\x06\x12\x04\xe8\x02\x085\n\r\n\x05\x04\x1e\x02\
    \x06\x04\x12\x04\xe8\x02\x08\x10\n\r\n\x05\x04\x1e\x02\x06\x06\x12\x04\
    \xe8\x02\x11\x1b\n\r\n\x05\x04\x1e\x02\x06\x01\x12\x04\xe8\x02\x1c0\n\r\
    \n\x05\x04\x1e\x02\x06\x03\x12\x04\xe8\x0234\n\x0c\n\x04\x04\x1e\x02\x07\
    \x12\x04\xe9\x02\x08=\n\r\n\x05\x04\x1e\x02\x07\x04\x12\x04\xe9\x02\x08\
    \x10\n\r\n\x05\x04\x1e\x02\x07\x06\x12\x04\xe9\x02\x11$\n\r\n\x05\x04\
    \x1e\x02\x07\x01\x12\x04\xe9\x02%8\n\r\n\x05\x04\x1e\x02\x07\x03\x12\x04\
    \xe9\x02;<\n\x0c\n\x04\x04\x1e\x02\x08\x12\x04\xea\x02\x08=\n\r\n\x05\
    \x04\x1e\x02\x08\x04\x12\x04\xea\x02\x08\x10\n\r\n\x05\x04\x1e\x02\x08\
    \x06\x12\x04\xea\x02\x11$\n\r\n\x05\x04\x1e\x02\x08\x01\x12\x04\xea\x02%\
    8\n\r\n\x05\x04\x1e\x02\x08\x03\x12\x04\xea\x02;<\n\x0c\n\x02\x04\x1f\
    \x12\x06\xed\x02\0\xfb\x02\x01\n\x0b\n\x03\x04\x1f\x01\x12\x04\xed\x02\
    \x08\x13\n\r\n\x03\x04\x1f\x06\x12\x06\xee\x02\x08\xf0\x02\t\n\x0c\n\x04\
    \x04\x1f\x06\0\x12\x04\xef\x02\x10U\n\r\n\x05\x04\x1f\x06\0\x02\x12\x04\
    \xee\x02\x0f&\n\r\n\x05\x04\x1f\x06\0\x04\x12\x04\xef\x02\x10\x18\n\r\n\
    \x05\x04\x1f\x06\0\x06\x12\x04\xef\x02\x198\n\r\n\x05\x04\x1f\x06\0\x01\
    \x12\x04\xef\x029M\n\r\n\x05\x04\x1f\x06\0\x03\x12\x04\xef\x02PT\n\x0e\n\
    \x04\x04\x1f\x03\0\x12\x06\xf2\x02\x08\xf4\x02\t\n\r\n\x05\x04\x1f\x03\0\
    \x01\x12\x04\xf2\x02\x10\"\n\x0e\n\x06\x04\x1f\x03\0\x02\0\x12\x04\xf3\
    \x02\x10)\n\x0f\n\x07\x04\x1f\x03\0\x02\0\x04\x12\x04\xf3\x02\x10\x18\n\
    \x0f\n\x07\x04\x1f\x03\0\x02\0\x05\x12\x04\xf3\x02\x19\x1f\n\x0f\n\x07\
    \x04\x1f\x03\0\x02\0\x01\x12\x04\xf3\x02\x20$\n\x0f\n\x07\x04\x1f\x03\0\
    \x02\0\x03\x12\x04\xf3\x02'(\n\x0c\n\x04\x04\x1f\x02\0\x12\x04\xf6\x02\
    \x08!\n\r\n\x05\x04\x1f\x02\0\x04\x12\x04\xf6\x02\x08\x10\n\r\n\x05\x04\
    \x1f\x02\0\x05\x12\x04\xf6\x02\x11\x17\n\r\n\x05\x04\x1f\x02\0\x01\x12\
    \x04\xf6\x02\x18\x1c\n\r\n\x05\x04\x1f\x02\0\x03\x12\x04\xf6\x02\x1f\x20\
    \n\x0c\n\x04\x04\x1f\x02\x01\x12\x04\xf7\x02\x08'\n\r\n\x05\x04\x1f\x02\
    \x01\x04\x12\x04\xf7\x02\x08\x10\n\r\n\x05\x04\x1f\x02\x01\x05\x12\x04\
    \xf7\x02\x11\x17\n\r\n\x05\x04\x1f\x02\x01\x01\x12\x04\xf7\x02\x18\"\n\r\
    \n\x05\x04\x1f\x02\x01\x03\x12\x04\xf7\x02%&\n\x0c\n\x04\x04\x1f\x02\x02\
    \x12\x04\xf8\x02\x089\n\r\n\x05\x04\x1f\x02\x02\x04\x12\x04\xf8\x02\x08\
    \x10\n\r\n\x05\x04\x1f\x02\x02\x06\x12\x04\xf8\x02\x11$\n\r\n\x05\x04\
    \x1f\x02\x02\x01\x12\x04\xf8\x02%4\n\r\n\x05\x04\x1f\x02\x02\x03\x12\x04\
    \xf8\x0278\n\x0c\n\x04\x04\x1f\x02\x03\x12\x04\xf9\x02\x08)\n\r\n\x05\
    \x04\x1f\x02\x03\x04\x12\x04\xf9\x02\x08\x10\n\r\n\x05\x04\x1f\x02\x03\
    \x05\x12\x04\xf9\x02\x11\x17\n\r\n\x05\x04\x1f\x02\x03\x01\x12\x04\xf9\
    \x02\x18$\n\r\n\x05\x04\x1f\x02\x03\x03\x12\x04\xf9\x02'(\n\x0c\n\x04\
    \x04\x1f\x02\x04\x12\x04\xfa\x02\x083\n\r\n\x05\x04\x1f\x02\x04\x04\x12\
    \x04\xfa\x02\x08\x10\n\r\n\x05\x04\x1f\x02\x04\x06\x12\x04\xfa\x02\x11#\
    \n\r\n\x05\x04\x1f\x02\x04\x01\x12\x04\xfa\x02$.\n\r\n\x05\x04\x1f\x02\
    \x04\x03\x12\x04\xfa\x0212\n\x0c\n\x02\x04\x20\x12\x06\xfd\x02\0\x8b\x03\
    \x01\n\x0b\n\x03\x04\x20\x01\x12\x04\xfd\x02\x08\x14\n\r\n\x03\x04\x20\
    \x06\x12\x06\xfe\x02\x08\x80\x03\t\n\x0c\n\x04\x04\x20\x06\0\x12\x04\xff\
    \x02\x10V\n\r\n\x05\x04\x20\x06\0\x02\x12\x04\xfe\x02\x0f&\n\r\n\x05\x04\
    \x20\x06\0\x04\x12\x04\xff\x02\x10\x18\n\r\n\x05\x04\x20\x06\0\x06\x12\
    \x04\xff\x02\x199\n\r\n\x05\x04\x20\x06\0\x01\x12\x04\xff\x02:N\n\r\n\
    \x05\x04\x20\x06\0\x03\x12\x04\xff\x02QU\n\x0e\n\x04\x04\x20\x03\0\x12\
    \x06\x82\x03\x08\x84\x03\t\n\r\n\x05\x04\x20\x03\0\x01\x12\x04\x82\x03\
    \x10\"\n\x0e\n\x06\x04\x20\x03\0\x02\0\x12\x04\x83\x03\x10)\n\x0f\n\x07\
    \x04\x20\x03\0\x02\0\x04\x12\x04\x83\x03\x10\x18\n\x0f\n\x07\x04\x20\x03\
    \0\x02\0\x05\x12\x04\x83\x03\x19\x1f\n\x0f\n\x07\x04\x20\x03\0\x02\0\x01\
    \x12\x04\x83\x03\x20$\n\x0f\n\x07\x04\x20\x03\0\x02\0\x03\x12\x04\x83\
    \x03'(\n\x0c\n\x04\x04\x20\x02\0\x12\x04\x86\x03\x08!\n\r\n\x05\x04\x20\
    \x02\0\x04\x12\x04\x86\x03\x08\x10\n\r\n\x05\x04\x20\x02\0\x05\x12\x04\
    \x86\x03\x11\x17\n\r\n\x05\x04\x20\x02\0\x01\x12\x04\x86\x03\x18\x1c\n\r\
    \n\x05\x04\x20\x02\0\x03\x12\x04\x86\x03\x1f\x20\n\x0c\n\x04\x04\x20\x02\
    \x01\x12\x04\x87\x03\x08'\n\r\n\x05\x04\x20\x02\x01\x04\x12\x04\x87\x03\
    \x08\x10\n\r\n\x05\x04\x20\x02\x01\x05\x12\x04\x87\x03\x11\x17\n\r\n\x05\
    \x04\x20\x02\x01\x01\x12\x04\x87\x03\x18\"\n\r\n\x05\x04\x20\x02\x01\x03\
    \x12\x04\x87\x03%&\n\x0c\n\x04\x04\x20\x02\x02\x12\x04\x88\x03\x089\n\r\
    \n\x05\x04\x20\x02\x02\x04\x12\x04\x88\x03\x08\x10\n\r\n\x05\x04\x20\x02\
    \x02\x06\x12\x04\x88\x03\x11$\n\r\n\x05\x04\x20\x02\x02\x01\x12\x04\x88\
    \x03%4\n\r\n\x05\x04\x20\x02\x02\x03\x12\x04\x88\x0378\n\x0c\n\x04\x04\
    \x20\x02\x03\x12\x04\x89\x03\x08)\n\r\n\x05\x04\x20\x02\x03\x04\x12\x04\
    \x89\x03\x08\x10\n\r\n\x05\x04\x20\x02\x03\x05\x12\x04\x89\x03\x11\x17\n\
    \r\n\x05\x04\x20\x02\x03\x01\x12\x04\x89\x03\x18$\n\r\n\x05\x04\x20\x02\
    \x03\x03\x12\x04\x89\x03'(\n\x0c\n\x04\x04\x20\x02\x04\x12\x04\x8a\x03\
    \x083\n\r\n\x05\x04\x20\x02\x04\x04\x12\x04\x8a\x03\x08\x10\n\r\n\x05\
    \x04\x20\x02\x04\x06\x12\x04\x8a\x03\x11#\n\r\n\x05\x04\x20\x02\x04\x01\
    \x12\x04\x8a\x03$.\n\r\n\x05\x04\x20\x02\x04\x03\x12\x04\x8a\x0312\n\x0c\
    \n\x02\x04!\x12\x06\x8d\x03\0\x90\x03\x01\n\x0b\n\x03\x04!\x01\x12\x04\
    \x8d\x03\x08\x1b\n\x0c\n\x04\x04!\x02\0\x12\x04\x8e\x03\x084\n\r\n\x05\
    \x04!\x02\0\x04\x12\x04\x8e\x03\x08\x10\n\r\n\x05\x04!\x02\0\x05\x12\x04\
    \x8e\x03\x11\x17\n\r\n\x05\x04!\x02\0\x01\x12\x04\x8e\x03\x18/\n\r\n\x05\
    \x04!\x02\0\x03\x12\x04\x8e\x0323\n\x0c\n\x04\x04!\x02\x01\x12\x04\x8f\
    \x03\x081\n\r\n\x05\x04!\x02\x01\x04\x12\x04\x8f\x03\x08\x10\n\r\n\x05\
    \x04!\x02\x01\x05\x12\x04\x8f\x03\x11\x17\n\r\n\x05\x04!\x02\x01\x01\x12\
    \x04\x8f\x03\x18,\n\r\n\x05\x04!\x02\x01\x03\x12\x04\x8f\x03/0\n\x0c\n\
    \x02\x04\"\x12\x06\x92\x03\0\xa0\x03\x01\n\x0b\n\x03\x04\"\x01\x12\x04\
    \x92\x03\x08\x17\n\r\n\x03\x04\"\x06\x12\x06\x93\x03\x08\x95\x03\t\n\x0c\
    \n\x04\x04\"\x06\0\x12\x04\x94\x03\x10Y\n\r\n\x05\x04\"\x06\0\x02\x12\
    \x04\x93\x03\x0f&\n\r\n\x05\x04\"\x06\0\x04\x12\x04\x94\x03\x10\x18\n\r\
    \n\x05\x04\"\x06\0\x06\x12\x04\x94\x03\x19<\n\r\n\x05\x04\"\x06\0\x01\
    \x12\x04\x94\x03=Q\n\r\n\x05\x04\"\x06\0\x03\x12\x04\x94\x03TX\n\x0e\n\
    \x04\x04\"\x03\0\x12\x06\x97\x03\x08\x99\x03\t\n\r\n\x05\x04\"\x03\0\x01\
    \x12\x04\x97\x03\x10\"\n\x0e\n\x06\x04\"\x03\0\x02\0\x12\x04\x98\x03\x10\
    7\n\x0f\n\x07\x04\"\x03\0\x02\0\x04\x12\x04\x98\x03\x10\x18\n\x0f\n\x07\
    \x04\"\x03\0\x02\0\x06\x12\x04\x98\x03\x19-\n\x0f\n\x07\x04\"\x03\0\x02\
    \0\x01\x12\x04\x98\x03.2\n\x0f\n\x07\x04\"\x03\0\x02\0\x03\x12\x04\x98\
    \x0356\n\x0c\n\x04\x04\"\x02\0\x12\x04\x9b\x03\x08/\n\r\n\x05\x04\"\x02\
    \0\x04\x12\x04\x9b\x03\x08\x10\n\r\n\x05\x04\"\x02\0\x06\x12\x04\x9b\x03\
    \x11%\n\r\n\x05\x04\"\x02\0\x01\x12\x04\x9b\x03&*\n\r\n\x05\x04\"\x02\0\
    \x03\x12\x04\x9b\x03-.\n\x0c\n\x04\x04\"\x02\x01\x12\x04\x9c\x03\x085\n\
    \r\n\x05\x04\"\x02\x01\x04\x12\x04\x9c\x03\x08\x10\n\r\n\x05\x04\"\x02\
    \x01\x06\x12\x04\x9c\x03\x11%\n\r\n\x05\x04\"\x02\x01\x01\x12\x04\x9c\
    \x03&0\n\r\n\x05\x04\"\x02\x01\x03\x12\x04\x9c\x0334\n\x0c\n\x04\x04\"\
    \x02\x02\x12\x04\x9d\x03\x089\n\r\n\x05\x04\"\x02\x02\x04\x12\x04\x9d\
    \x03\x08\x10\n\r\n\x05\x04\"\x02\x02\x06\x12\x04\x9d\x03\x11$\n\r\n\x05\
    \x04\"\x02\x02\x01\x12\x04\x9d\x03%4\n\r\n\x05\x04\"\x02\x02\x03\x12\x04\
    \x9d\x0378\n\x0c\n\x04\x04\"\x02\x03\x12\x04\x9e\x03\x08)\n\r\n\x05\x04\
    \"\x02\x03\x04\x12\x04\x9e\x03\x08\x10\n\r\n\x05\x04\"\x02\x03\x05\x12\
    \x04\x9e\x03\x11\x17\n\r\n\x05\x04\"\x02\x03\x01\x12\x04\x9e\x03\x18$\n\
    \r\n\x05\x04\"\x02\x03\x03\x12\x04\x9e\x03'(\n\x0c\n\x04\x04\"\x02\x04\
    \x12\x04\x9f\x03\x083\n\r\n\x05\x04\"\x02\x04\x04\x12\x04\x9f\x03\x08\
    \x10\n\r\n\x05\x04\"\x02\x04\x06\x12\x04\x9f\x03\x11#\n\r\n\x05\x04\"\
    \x02\x04\x01\x12\x04\x9f\x03$.\n\r\n\x05\x04\"\x02\x04\x03\x12\x04\x9f\
    \x0312\n\x0c\n\x02\x04#\x12\x06\xa2\x03\0\xb0\x03\x01\n\x0b\n\x03\x04#\
    \x01\x12\x04\xa2\x03\x08\x14\n\r\n\x03\x04#\x06\x12\x06\xa3\x03\x08\xa5\
    \x03\t\n\x0c\n\x04\x04#\x06\0\x12\x04\xa4\x03\x10V\n\r\n\x05\x04#\x06\0\
    \x02\x12\x04\xa3\x03\x0f&\n\r\n\x05\x04#\x06\0\x04\x12\x04\xa4\x03\x10\
    \x18\n\r\n\x05\x04#\x06\0\x06\x12\x04\xa4\x03\x199\n\r\n\x05\x04#\x06\0\
    \x01\x12\x04\xa4\x03:N\n\r\n\x05\x04#\x06\0\x03\x12\x04\xa4\x03QU\n\x0e\
    \n\x04\x04#\x03\0\x12\x06\xa7\x03\x08\xa9\x03\t\n\r\n\x05\x04#\x03\0\x01\
    \x12\x04\xa7\x03\x10\"\n\x0e\n\x06\x04#\x03\0\x02\0\x12\x04\xa8\x03\x10)\
    \n\x0f\n\x07\x04#\x03\0\x02\0\x04\x12\x04\xa8\x03\x10\x18\n\x0f\n\x07\
    \x04#\x03\0\x02\0\x05\x12\x04\xa8\x03\x19\x1f\n\x0f\n\x07\x04#\x03\0\x02\
    \0\x01\x12\x04\xa8\x03\x20$\n\x0f\n\x07\x04#\x03\0\x02\0\x03\x12\x04\xa8\
    \x03'(\n\x0c\n\x04\x04#\x02\0\x12\x04\xab\x03\x08!\n\r\n\x05\x04#\x02\0\
    \x04\x12\x04\xab\x03\x08\x10\n\r\n\x05\x04#\x02\0\x05\x12\x04\xab\x03\
    \x11\x17\n\r\n\x05\x04#\x02\0\x01\x12\x04\xab\x03\x18\x1c\n\r\n\x05\x04#\
    \x02\0\x03\x12\x04\xab\x03\x1f\x20\n\x0c\n\x04\x04#\x02\x01\x12\x04\xac\
    \x03\x08'\n\r\n\x05\x04#\x02\x01\x04\x12\x04\xac\x03\x08\x10\n\r\n\x05\
    \x04#\x02\x01\x05\x12\x04\xac\x03\x11\x17\n\r\n\x05\x04#\x02\x01\x01\x12\
    \x04\xac\x03\x18\"\n\r\n\x05\x04#\x02\x01\x03\x12\x04\xac\x03%&\n\x0c\n\
    \x04\x04#\x02\x02\x12\x04\xad\x03\x089\n\r\n\x05\x04#\x02\x02\x04\x12\
    \x04\xad\x03\x08\x10\n\r\n\x05\x04#\x02\x02\x06\x12\x04\xad\x03\x11$\n\r\
    \n\x05\x04#\x02\x02\x01\x12\x04\xad\x03%4\n\r\n\x05\x04#\x02\x02\x03\x12\
    \x04\xad\x0378\n\x0c\n\x04\x04#\x02\x03\x12\x04\xae\x03\x08)\n\r\n\x05\
    \x04#\x02\x03\x04\x12\x04\xae\x03\x08\x10\n\r\n\x05\x04#\x02\x03\x05\x12\
    \x04\xae\x03\x11\x17\n\r\n\x05\x04#\x02\x03\x01\x12\x04\xae\x03\x18$\n\r\
    \n\x05\x04#\x02\x03\x03\x12\x04\xae\x03'(\n\x0c\n\x04\x04#\x02\x04\x12\
    \x04\xaf\x03\x083\n\r\n\x05\x04#\x02\x04\x04\x12\x04\xaf\x03\x08\x10\n\r\
    \n\x05\x04#\x02\x04\x06\x12\x04\xaf\x03\x11#\n\r\n\x05\x04#\x02\x04\x01\
    \x12\x04\xaf\x03$.\n\r\n\x05\x04#\x02\x04\x03\x12\x04\xaf\x0312\n\x0c\n\
    \x02\x04$\x12\x06\xb2\x03\0\xc0\x03\x01\n\x0b\n\x03\x04$\x01\x12\x04\xb2\
    \x03\x08\x16\n\r\n\x03\x04$\x06\x12\x06\xb3\x03\x08\xb5\x03\t\n\x0c\n\
    \x04\x04$\x06\0\x12\x04\xb4\x03\x10X\n\r\n\x05\x04$\x06\0\x02\x12\x04\
    \xb3\x03\x0f&\n\r\n\x05\x04$\x06\0\x04\x12\x04\xb4\x03\x10\x18\n\r\n\x05\
    \x04$\x06\0\x06\x12\x04\xb4\x03\x19;\n\r\n\x05\x04$\x06\0\x01\x12\x04\
    \xb4\x03<P\n\r\n\x05\x04$\x06\0\x03\x12\x04\xb4\x03SW\n\x0e\n\x04\x04$\
    \x03\0\x12\x06\xb7\x03\x08\xb9\x03\t\n\r\n\x05\x04$\x03\0\x01\x12\x04\
    \xb7\x03\x10\"\n\x0e\n\x06\x04$\x03\0\x02\0\x12\x04\xb8\x03\x10)\n\x0f\n\
    \x07\x04$\x03\0\x02\0\x04\x12\x04\xb8\x03\x10\x18\n\x0f\n\x07\x04$\x03\0\
    \x02\0\x05\x12\x04\xb8\x03\x19\x1f\n\x0f\n\x07\x04$\x03\0\x02\0\x01\x12\
    \x04\xb8\x03\x20$\n\x0f\n\x07\x04$\x03\0\x02\0\x03\x12\x04\xb8\x03'(\n\
    \x0c\n\x04\x04$\x02\0\x12\x04\xbb\x03\x08!\n\r\n\x05\x04$\x02\0\x04\x12\
    \x04\xbb\x03\x08\x10\n\r\n\x05\x04$\x02\0\x05\x12\x04\xbb\x03\x11\x17\n\
    \r\n\x05\x04$\x02\0\x01\x12\x04\xbb\x03\x18\x1c\n\r\n\x05\x04$\x02\0\x03\
    \x12\x04\xbb\x03\x1f\x20\n\x0c\n\x04\x04$\x02\x01\x12\x04\xbc\x03\x08'\n\
    \r\n\x05\x04$\x02\x01\x04\x12\x04\xbc\x03\x08\x10\n\r\n\x05\x04$\x02\x01\
    \x05\x12\x04\xbc\x03\x11\x17\n\r\n\x05\x04$\x02\x01\x01\x12\x04\xbc\x03\
    \x18\"\n\r\n\x05\x04$\x02\x01\x03\x12\x04\xbc\x03%&\n\x0c\n\x04\x04$\x02\
    \x02\x12\x04\xbd\x03\x089\n\r\n\x05\x04$\x02\x02\x04\x12\x04\xbd\x03\x08\
    \x10\n\r\n\x05\x04$\x02\x02\x06\x12\x04\xbd\x03\x11$\n\r\n\x05\x04$\x02\
    \x02\x01\x12\x04\xbd\x03%4\n\r\n\x05\x04$\x02\x02\x03\x12\x04\xbd\x0378\
    \n\x0c\n\x04\x04$\x02\x03\x12\x04\xbe\x03\x08)\n\r\n\x05\x04$\x02\x03\
    \x04\x12\x04\xbe\x03\x08\x10\n\r\n\x05\x04$\x02\x03\x05\x12\x04\xbe\x03\
    \x11\x17\n\r\n\x05\x04$\x02\x03\x01\x12\x04\xbe\x03\x18$\n\r\n\x05\x04$\
    \x02\x03\x03\x12\x04\xbe\x03'(\n\x0c\n\x04\x04$\x02\x04\x12\x04\xbf\x03\
    \x083\n\r\n\x05\x04$\x02\x04\x04\x12\x04\xbf\x03\x08\x10\n\r\n\x05\x04$\
    \x02\x04\x06\x12\x04\xbf\x03\x11#\n\r\n\x05\x04$\x02\x04\x01\x12\x04\xbf\
    \x03$.\n\r\n\x05\x04$\x02\x04\x03\x12\x04\xbf\x0312\n\x0c\n\x02\x04%\x12\
    \x06\xc2\x03\0\xd0\x03\x01\n\x0b\n\x03\x04%\x01\x12\x04\xc2\x03\x08\x16\
    \n\r\n\x03\x04%\x06\x12\x06\xc3\x03\x08\xc5\x03\t\n\x0c\n\x04\x04%\x06\0\
    \x12\x04\xc4\x03\x10X\n\r\n\x05\x04%\x06\0\x02\x12\x04\xc3\x03\x0f&\n\r\
    \n\x05\x04%\x06\0\x04\x12\x04\xc4\x03\x10\x18\n\r\n\x05\x04%\x06\0\x06\
    \x12\x04\xc4\x03\x19;\n\r\n\x05\x04%\x06\0\x01\x12\x04\xc4\x03<P\n\r\n\
    \x05\x04%\x06\0\x03\x12\x04\xc4\x03SW\n\x0e\n\x04\x04%\x03\0\x12\x06\xc7\
    \x03\x08\xc9\x03\t\n\r\n\x05\x04%\x03\0\x01\x12\x04\xc7\x03\x10\"\n\x0e\
    \n\x06\x04%\x03\0\x02\0\x12\x04\xc8\x03\x10)\n\x0f\n\x07\x04%\x03\0\x02\
    \0\x04\x12\x04\xc8\x03\x10\x18\n\x0f\n\x07\x04%\x03\0\x02\0\x05\x12\x04\
    \xc8\x03\x19\x1f\n\x0f\n\x07\x04%\x03\0\x02\0\x01\x12\x04\xc8\x03\x20$\n\
    \x0f\n\x07\x04%\x03\0\x02\0\x03\x12\x04\xc8\x03'(\n\x0c\n\x04\x04%\x02\0\
    \x12\x04\xcb\x03\x08!\n\r\n\x05\x04%\x02\0\x04\x12\x04\xcb\x03\x08\x10\n\
    \r\n\x05\x04%\x02\0\x05\x12\x04\xcb\x03\x11\x17\n\r\n\x05\x04%\x02\0\x01\
    \x12\x04\xcb\x03\x18\x1c\n\r\n\x05\x04%\x02\0\x03\x12\x04\xcb\x03\x1f\
    \x20\n\x0c\n\x04\x04%\x02\x01\x12\x04\xcc\x03\x08'\n\r\n\x05\x04%\x02\
    \x01\x04\x12\x04\xcc\x03\x08\x10\n\r\n\x05\x04%\x02\x01\x05\x12\x04\xcc\
    \x03\x11\x17\n\r\n\x05\x04%\x02\x01\x01\x12\x04\xcc\x03\x18\"\n\r\n\x05\
    \x04%\x02\x01\x03\x12\x04\xcc\x03%&\n\x0c\n\x04\x04%\x02\x02\x12\x04\xcd\
    \x03\x089\n\r\n\x05\x04%\x02\x02\x04\x12\x04\xcd\x03\x08\x10\n\r\n\x05\
    \x04%\x02\x02\x06\x12\x04\xcd\x03\x11$\n\r\n\x05\x04%\x02\x02\x01\x12\
    \x04\xcd\x03%4\n\r\n\x05\x04%\x02\x02\x03\x12\x04\xcd\x0378\n\x0c\n\x04\
    \x04%\x02\x03\x12\x04\xce\x03\x08)\n\r\n\x05\x04%\x02\x03\x04\x12\x04\
    \xce\x03\x08\x10\n\r\n\x05\x04%\x02\x03\x05\x12\x04\xce\x03\x11\x17\n\r\
    \n\x05\x04%\x02\x03\x01\x12\x04\xce\x03\x18$\n\r\n\x05\x04%\x02\x03\x03\
    \x12\x04\xce\x03'(\n\x0c\n\x04\x04%\x02\x04\x12\x04\xcf\x03\x083\n\r\n\
    \x05\x04%\x02\x04\x04\x12\x04\xcf\x03\x08\x10\n\r\n\x05\x04%\x02\x04\x06\
    \x12\x04\xcf\x03\x11#\n\r\n\x05\x04%\x02\x04\x01\x12\x04\xcf\x03$.\n\r\n\
    \x05\x04%\x02\x04\x03\x12\x04\xcf\x0312\n\x0c\n\x02\x04&\x12\x06\xd2\x03\
    \0\xe0\x03\x01\n\x0b\n\x03\x04&\x01\x12\x04\xd2\x03\x08\x14\n\r\n\x03\
    \x04&\x06\x12\x06\xd3\x03\x08\xd5\x03\t\n\x0c\n\x04\x04&\x06\0\x12\x04\
    \xd4\x03\x10V\n\r\n\x05\x04&\x06\0\x02\x12\x04\xd3\x03\x0f&\n\r\n\x05\
    \x04&\x06\0\x04\x12\x04\xd4\x03\x10\x18\n\r\n\x05\x04&\x06\0\x06\x12\x04\
    \xd4\x03\x199\n\r\n\x05\x04&\x06\0\x01\x12\x04\xd4\x03:N\n\r\n\x05\x04&\
    \x06\0\x03\x12\x04\xd4\x03QU\n\x0e\n\x04\x04&\x03\0\x12\x06\xd7\x03\x08\
    \xd9\x03\t\n\r\n\x05\x04&\x03\0\x01\x12\x04\xd7\x03\x10\"\n\x0e\n\x06\
    \x04&\x03\0\x02\0\x12\x04\xd8\x03\x10)\n\x0f\n\x07\x04&\x03\0\x02\0\x04\
    \x12\x04\xd8\x03\x10\x18\n\x0f\n\x07\x04&\x03\0\x02\0\x05\x12\x04\xd8\
    \x03\x19\x1f\n\x0f\n\x07\x04&\x03\0\x02\0\x01\x12\x04\xd8\x03\x20$\n\x0f\
    \n\x07\x04&\x03\0\x02\0\x03\x12\x04\xd8\x03'(\n\x0c\n\x04\x04&\x02\0\x12\
    \x04\xdb\x03\x08!\n\r\n\x05\x04&\x02\0\x04\x12\x04\xdb\x03\x08\x10\n\r\n\
    \x05\x04&\x02\0\x05\x12\x04\xdb\x03\x11\x17\n\r\n\x05\x04&\x02\0\x01\x12\
    \x04\xdb\x03\x18\x1c\n\r\n\x05\x04&\x02\0\x03\x12\x04\xdb\x03\x1f\x20\n\
    \x0c\n\x04\x04&\x02\x01\x12\x04\xdc\x03\x08'\n\r\n\x05\x04&\x02\x01\x04\
    \x12\x04\xdc\x03\x08\x10\n\r\n\x05\x04&\x02\x01\x05\x12\x04\xdc\x03\x11\
    \x17\n\r\n\x05\x04&\x02\x01\x01\x12\x04\xdc\x03\x18\"\n\r\n\x05\x04&\x02\
    \x01\x03\x12\x04\xdc\x03%&\n\x0c\n\x04\x04&\x02\x02\x12\x04\xdd\x03\x089\
    \n\r\n\x05\x04&\x02\x02\x04\x12\x04\xdd\x03\x08\x10\n\r\n\x05\x04&\x02\
    \x02\x06\x12\x04\xdd\x03\x11$\n\r\n\x05\x04&\x02\x02\x01\x12\x04\xdd\x03\
    %4\n\r\n\x05\x04&\x02\x02\x03\x12\x04\xdd\x0378\n\x0c\n\x04\x04&\x02\x03\
    \x12\x04\xde\x03\x08)\n\r\n\x05\x04&\x02\x03\x04\x12\x04\xde\x03\x08\x10\
    \n\r\n\x05\x04&\x02\x03\x05\x12\x04\xde\x03\x11\x17\n\r\n\x05\x04&\x02\
    \x03\x01\x12\x04\xde\x03\x18$\n\r\n\x05\x04&\x02\x03\x03\x12\x04\xde\x03\
    '(\n\x0c\n\x04\x04&\x02\x04\x12\x04\xdf\x03\x083\n\r\n\x05\x04&\x02\x04\
    \x04\x12\x04\xdf\x03\x08\x10\n\r\n\x05\x04&\x02\x04\x06\x12\x04\xdf\x03\
    \x11#\n\r\n\x05\x04&\x02\x04\x01\x12\x04\xdf\x03$.\n\r\n\x05\x04&\x02\
    \x04\x03\x12\x04\xdf\x0312\n\x0c\n\x02\x04'\x12\x06\xe2\x03\0\xe6\x03\
    \x01\n\x0b\n\x03\x04'\x01\x12\x04\xe2\x03\x08\x1a\n\x0c\n\x04\x04'\x02\0\
    \x12\x04\xe3\x03\x08#\n\r\n\x05\x04'\x02\0\x04\x12\x04\xe3\x03\x08\x10\n\
    \r\n\x05\x04'\x02\0\x05\x12\x04\xe3\x03\x11\x17\n\r\n\x05\x04'\x02\0\x01\
    \x12\x04\xe3\x03\x18\x1e\n\r\n\x05\x04'\x02\0\x03\x12\x04\xe3\x03!\"\n\
    \x0c\n\x04\x04'\x02\x01\x12\x04\xe4\x03\x08'\n\r\n\x05\x04'\x02\x01\x04\
    \x12\x04\xe4\x03\x08\x10\n\r\n\x05\x04'\x02\x01\x05\x12\x04\xe4\x03\x11\
    \x17\n\r\n\x05\x04'\x02\x01\x01\x12\x04\xe4\x03\x18\"\n\r\n\x05\x04'\x02\
    \x01\x03\x12\x04\xe4\x03%&\n\x0c\n\x04\x04'\x02\x02\x12\x04\xe5\x03\x08'\
    \n\r\n\x05\x04'\x02\x02\x04\x12\x04\xe5\x03\x08\x10\n\r\n\x05\x04'\x02\
    \x02\x05\x12\x04\xe5\x03\x11\x17\n\r\n\x05\x04'\x02\x02\x01\x12\x04\xe5\
    \x03\x18\"\n\r\n\x05\x04'\x02\x02\x03\x12\x04\xe5\x03%&\n\x0c\n\x02\x04(\
    \x12\x06\xe8\x03\0\xf6\x03\x01\n\x0b\n\x03\x04(\x01\x12\x04\xe8\x03\x08\
    \x18\n\r\n\x03\x04(\x06\x12\x06\xe9\x03\x08\xeb\x03\t\n\x0c\n\x04\x04(\
    \x06\0\x12\x04\xea\x03\x10Z\n\r\n\x05\x04(\x06\0\x02\x12\x04\xe9\x03\x0f\
    &\n\r\n\x05\x04(\x06\0\x04\x12\x04\xea\x03\x10\x18\n\r\n\x05\x04(\x06\0\
    \x06\x12\x04\xea\x03\x19=\n\r\n\x05\x04(\x06\0\x01\x12\x04\xea\x03>R\n\r\
    \n\x05\x04(\x06\0\x03\x12\x04\xea\x03UY\n\x0e\n\x04\x04(\x03\0\x12\x06\
    \xed\x03\x08\xef\x03\t\n\r\n\x05\x04(\x03\0\x01\x12\x04\xed\x03\x10\"\n\
    \x0e\n\x06\x04(\x03\0\x02\0\x12\x04\xee\x03\x106\n\x0f\n\x07\x04(\x03\0\
    \x02\0\x04\x12\x04\xee\x03\x10\x18\n\x0f\n\x07\x04(\x03\0\x02\0\x06\x12\
    \x04\xee\x03\x19,\n\x0f\n\x07\x04(\x03\0\x02\0\x01\x12\x04\xee\x03-1\n\
    \x0f\n\x07\x04(\x03\0\x02\0\x03\x12\x04\xee\x0345\n\x0c\n\x04\x04(\x02\0\
    \x12\x04\xf1\x03\x08.\n\r\n\x05\x04(\x02\0\x04\x12\x04\xf1\x03\x08\x10\n\
    \r\n\x05\x04(\x02\0\x06\x12\x04\xf1\x03\x11$\n\r\n\x05\x04(\x02\0\x01\
    \x12\x04\xf1\x03%)\n\r\n\x05\x04(\x02\0\x03\x12\x04\xf1\x03,-\n\x0c\n\
    \x04\x04(\x02\x01\x12\x04\xf2\x03\x084\n\r\n\x05\x04(\x02\x01\x04\x12\
    \x04\xf2\x03\x08\x10\n\r\n\x05\x04(\x02\x01\x06\x12\x04\xf2\x03\x11$\n\r\
    \n\x05\x04(\x02\x01\x01\x12\x04\xf2\x03%/\n\r\n\x05\x04(\x02\x01\x03\x12\
    \x04\xf2\x0323\n\x0c\n\x04\x04(\x02\x02\x12\x04\xf3\x03\x089\n\r\n\x05\
    \x04(\x02\x02\x04\x12\x04\xf3\x03\x08\x10\n\r\n\x05\x04(\x02\x02\x06\x12\
    \x04\xf3\x03\x11$\n\r\n\x05\x04(\x02\x02\x01\x12\x04\xf3\x03%4\n\r\n\x05\
    \x04(\x02\x02\x03\x12\x04\xf3\x0378\n\x0c\n\x04\x04(\x02\x03\x12\x04\xf4\
    \x03\x08)\n\r\n\x05\x04(\x02\x03\x04\x12\x04\xf4\x03\x08\x10\n\r\n\x05\
    \x04(\x02\x03\x05\x12\x04\xf4\x03\x11\x17\n\r\n\x05\x04(\x02\x03\x01\x12\
    \x04\xf4\x03\x18$\n\r\n\x05\x04(\x02\x03\x03\x12\x04\xf4\x03'(\n\x0c\n\
    \x04\x04(\x02\x04\x12\x04\xf5\x03\x083\n\r\n\x05\x04(\x02\x04\x04\x12\
    \x04\xf5\x03\x08\x10\n\r\n\x05\x04(\x02\x04\x06\x12\x04\xf5\x03\x11#\n\r\
    \n\x05\x04(\x02\x04\x01\x12\x04\xf5\x03$.\n\r\n\x05\x04(\x02\x04\x03\x12\
    \x04\xf5\x0312\n\x0c\n\x02\x04)\x12\x06\xf8\x03\0\xfc\x03\x01\n\x0b\n\
    \x03\x04)\x01\x12\x04\xf8\x03\x08\x1c\n\x0c\n\x04\x04)\x02\0\x12\x04\xf9\
    \x03\x08%\n\r\n\x05\x04)\x02\0\x04\x12\x04\xf9\x03\x08\x10\n\r\n\x05\x04\
    )\x02\0\x05\x12\x04\xf9\x03\x11\x17\n\r\n\x05\x04)\x02\0\x01\x12\x04\xf9\
    \x03\x18\x20\n\r\n\x05\x04)\x02\0\x03\x12\x04\xf9\x03#$\n\x0c\n\x04\x04)\
    \x02\x01\x12\x04\xfa\x03\x08!\n\r\n\x05\x04)\x02\x01\x04\x12\x04\xfa\x03\
    \x08\x10\n\r\n\x05\x04)\x02\x01\x05\x12\x04\xfa\x03\x11\x17\n\r\n\x05\
    \x04)\x02\x01\x01\x12\x04\xfa\x03\x18\x1c\n\r\n\x05\x04)\x02\x01\x03\x12\
    \x04\xfa\x03\x1f\x20\n\x0c\n\x04\x04)\x02\x02\x12\x04\xfb\x03\x08!\n\r\n\
    \x05\x04)\x02\x02\x04\x12\x04\xfb\x03\x08\x10\n\r\n\x05\x04)\x02\x02\x05\
    \x12\x04\xfb\x03\x11\x17\n\r\n\x05\x04)\x02\x02\x01\x12\x04\xfb\x03\x18\
    \x1c\n\r\n\x05\x04)\x02\x02\x03\x12\x04\xfb\x03\x1f\x20\n\x0c\n\x02\x04*\
    \x12\x06\xfe\x03\0\x8c\x04\x01\n\x0b\n\x03\x04*\x01\x12\x04\xfe\x03\x08\
    \x16\n\r\n\x03\x04*\x06\x12\x06\xff\x03\x08\x81\x04\t\n\x0c\n\x04\x04*\
    \x06\0\x12\x04\x80\x04\x10X\n\r\n\x05\x04*\x06\0\x02\x12\x04\xff\x03\x0f\
    &\n\r\n\x05\x04*\x06\0\x04\x12\x04\x80\x04\x10\x18\n\r\n\x05\x04*\x06\0\
    \x06\x12\x04\x80\x04\x19;\n\r\n\x05\x04*\x06\0\x01\x12\x04\x80\x04<P\n\r\
    \n\x05\x04*\x06\0\x03\x12\x04\x80\x04SW\n\x0e\n\x04\x04*\x03\0\x12\x06\
    \x83\x04\x08\x85\x04\t\n\r\n\x05\x04*\x03\0\x01\x12\x04\x83\x04\x10\"\n\
    \x0e\n\x06\x04*\x03\0\x02\0\x12\x04\x84\x04\x108\n\x0f\n\x07\x04*\x03\0\
    \x02\0\x04\x12\x04\x84\x04\x10\x18\n\x0f\n\x07\x04*\x03\0\x02\0\x06\x12\
    \x04\x84\x04\x19.\n\x0f\n\x07\x04*\x03\0\x02\0\x01\x12\x04\x84\x04/3\n\
    \x0f\n\x07\x04*\x03\0\x02\0\x03\x12\x04\x84\x0467\n\x0c\n\x04\x04*\x02\0\
    \x12\x04\x87\x04\x080\n\r\n\x05\x04*\x02\0\x04\x12\x04\x87\x04\x08\x10\n\
    \r\n\x05\x04*\x02\0\x06\x12\x04\x87\x04\x11&\n\r\n\x05\x04*\x02\0\x01\
    \x12\x04\x87\x04'+\n\r\n\x05\x04*\x02\0\x03\x12\x04\x87\x04./\n\x0c\n\
    \x04\x04*\x02\x01\x12\x04\x88\x04\x086\n\r\n\x05\x04*\x02\x01\x04\x12\
    \x04\x88\x04\x08\x10\n\r\n\x05\x04*\x02\x01\x06\x12\x04\x88\x04\x11&\n\r\
    \n\x05\x04*\x02\x01\x01\x12\x04\x88\x04'1\n\r\n\x05\x04*\x02\x01\x03\x12\
    \x04\x88\x0445\n\x0c\n\x04\x04*\x02\x02\x12\x04\x89\x04\x089\n\r\n\x05\
    \x04*\x02\x02\x04\x12\x04\x89\x04\x08\x10\n\r\n\x05\x04*\x02\x02\x06\x12\
    \x04\x89\x04\x11$\n\r\n\x05\x04*\x02\x02\x01\x12\x04\x89\x04%4\n\r\n\x05\
    \x04*\x02\x02\x03\x12\x04\x89\x0478\n\x0c\n\x04\x04*\x02\x03\x12\x04\x8a\
    \x04\x083\n\r\n\x05\x04*\x02\x03\x04\x12\x04\x8a\x04\x08\x10\n\r\n\x05\
    \x04*\x02\x03\x06\x12\x04\x8a\x04\x11#\n\r\n\x05\x04*\x02\x03\x01\x12\
    \x04\x8a\x04$.\n\r\n\x05\x04*\x02\x03\x03\x12\x04\x8a\x0412\n\x0c\n\x04\
    \x04*\x02\x04\x12\x04\x8b\x04\x08)\n\r\n\x05\x04*\x02\x04\x04\x12\x04\
    \x8b\x04\x08\x10\n\r\n\x05\x04*\x02\x04\x05\x12\x04\x8b\x04\x11\x17\n\r\
    \n\x05\x04*\x02\x04\x01\x12\x04\x8b\x04\x18$\n\r\n\x05\x04*\x02\x04\x03\
    \x12\x04\x8b\x04'(\n\x0c\n\x02\x04+\x12\x06\x8e\x04\0\x9c\x04\x01\n\x0b\
    \n\x03\x04+\x01\x12\x04\x8e\x04\x08\"\n\r\n\x03\x04+\x06\x12\x06\x8f\x04\
    \x08\x91\x04\t\n\x0c\n\x04\x04+\x06\0\x12\x04\x90\x04\x10d\n\r\n\x05\x04\
    +\x06\0\x02\x12\x04\x8f\x04\x0f&\n\r\n\x05\x04+\x06\0\x04\x12\x04\x90\
    \x04\x10\x18\n\r\n\x05\x04+\x06\0\x06\x12\x04\x90\x04\x19G\n\r\n\x05\x04\
    +\x06\0\x01\x12\x04\x90\x04H\\\n\r\n\x05\x04+\x06\0\x03\x12\x04\x90\x04_\
    c\n\x0e\n\x04\x04+\x03\0\x12\x06\x93\x04\x08\x95\x04\t\n\r\n\x05\x04+\
    \x03\0\x01\x12\x04\x93\x04\x10\"\n\x0e\n\x06\x04+\x03\0\x02\0\x12\x04\
    \x94\x04\x10)\n\x0f\n\x07\x04+\x03\0\x02\0\x04\x12\x04\x94\x04\x10\x18\n\
    \x0f\n\x07\x04+\x03\0\x02\0\x05\x12\x04\x94\x04\x19\x1f\n\x0f\n\x07\x04+\
    \x03\0\x02\0\x01\x12\x04\x94\x04\x20$\n\x0f\n\x07\x04+\x03\0\x02\0\x03\
    \x12\x04\x94\x04'(\n\x0c\n\x04\x04+\x02\0\x12\x04\x97\x04\x08!\n\r\n\x05\
    \x04+\x02\0\x04\x12\x04\x97\x04\x08\x10\n\r\n\x05\x04+\x02\0\x05\x12\x04\
    \x97\x04\x11\x17\n\r\n\x05\x04+\x02\0\x01\x12\x04\x97\x04\x18\x1c\n\r\n\
    \x05\x04+\x02\0\x03\x12\x04\x97\x04\x1f\x20\n\x0c\n\x04\x04+\x02\x01\x12\
    \x04\x98\x04\x08'\n\r\n\x05\x04+\x02\x01\x04\x12\x04\x98\x04\x08\x10\n\r\
    \n\x05\x04+\x02\x01\x05\x12\x04\x98\x04\x11\x17\n\r\n\x05\x04+\x02\x01\
    \x01\x12\x04\x98\x04\x18\"\n\r\n\x05\x04+\x02\x01\x03\x12\x04\x98\x04%&\
    \n\x0c\n\x04\x04+\x02\x02\x12\x04\x99\x04\x089\n\r\n\x05\x04+\x02\x02\
    \x04\x12\x04\x99\x04\x08\x10\n\r\n\x05\x04+\x02\x02\x06\x12\x04\x99\x04\
    \x11$\n\r\n\x05\x04+\x02\x02\x01\x12\x04\x99\x04%4\n\r\n\x05\x04+\x02\
    \x02\x03\x12\x04\x99\x0478\n\x0c\n\x04\x04+\x02\x03\x12\x04\x9a\x04\x08)\
    \n\r\n\x05\x04+\x02\x03\x04\x12\x04\x9a\x04\x08\x10\n\r\n\x05\x04+\x02\
    \x03\x05\x12\x04\x9a\x04\x11\x17\n\r\n\x05\x04+\x02\x03\x01\x12\x04\x9a\
    \x04\x18$\n\r\n\x05\x04+\x02\x03\x03\x12\x04\x9a\x04'(\n\x0c\n\x04\x04+\
    \x02\x04\x12\x04\x9b\x04\x083\n\r\n\x05\x04+\x02\x04\x04\x12\x04\x9b\x04\
    \x08\x10\n\r\n\x05\x04+\x02\x04\x06\x12\x04\x9b\x04\x11#\n\r\n\x05\x04+\
    \x02\x04\x01\x12\x04\x9b\x04$.\n\r\n\x05\x04+\x02\x04\x03\x12\x04\x9b\
    \x0412\n\x0c\n\x02\x04,\x12\x06\x9e\x04\0\xac\x04\x01\n\x0b\n\x03\x04,\
    \x01\x12\x04\x9e\x04\x08(\n\r\n\x03\x04,\x06\x12\x06\x9f\x04\x08\xa1\x04\
    \t\n\x0c\n\x04\x04,\x06\0\x12\x04\xa0\x04\x10j\n\r\n\x05\x04,\x06\0\x02\
    \x12\x04\x9f\x04\x0f&\n\r\n\x05\x04,\x06\0\x04\x12\x04\xa0\x04\x10\x18\n\
    \r\n\x05\x04,\x06\0\x06\x12\x04\xa0\x04\x19M\n\r\n\x05\x04,\x06\0\x01\
    \x12\x04\xa0\x04Nb\n\r\n\x05\x04,\x06\0\x03\x12\x04\xa0\x04ei\n\x0e\n\
    \x04\x04,\x03\0\x12\x06\xa3\x04\x08\xa5\x04\t\n\r\n\x05\x04,\x03\0\x01\
    \x12\x04\xa3\x04\x10\"\n\x0e\n\x06\x04,\x03\0\x02\0\x12\x04\xa4\x04\x10-\
    \n\x0f\n\x07\x04,\x03\0\x02\0\x04\x12\x04\xa4\x04\x10\x18\n\x0f\n\x07\
    \x04,\x03\0\x02\0\x06\x12\x04\xa4\x04\x19#\n\x0f\n\x07\x04,\x03\0\x02\0\
    \x01\x12\x04\xa4\x04$(\n\x0f\n\x07\x04,\x03\0\x02\0\x03\x12\x04\xa4\x04+\
    ,\n\x0c\n\x04\x04,\x02\0\x12\x04\xa7\x04\x08%\n\r\n\x05\x04,\x02\0\x04\
    \x12\x04\xa7\x04\x08\x10\n\r\n\x05\x04,\x02\0\x06\x12\x04\xa7\x04\x11\
    \x1b\n\r\n\x05\x04,\x02\0\x01\x12\x04\xa7\x04\x1c\x20\n\r\n\x05\x04,\x02\
    \0\x03\x12\x04\xa7\x04#$\n\x0c\n\x04\x04,\x02\x01\x12\x04\xa8\x04\x08+\n\
    \r\n\x05\x04,\x02\x01\x04\x12\x04\xa8\x04\x08\x10\n\r\n\x05\x04,\x02\x01\
    \x06\x12\x04\xa8\x04\x11\x1b\n\r\n\x05\x04,\x02\x01\x01\x12\x04\xa8\x04\
    \x1c&\n\r\n\x05\x04,\x02\x01\x03\x12\x04\xa8\x04)*\n\x0c\n\x04\x04,\x02\
    \x02\x12\x04\xa9\x04\x089\n\r\n\x05\x04,\x02\x02\x04\x12\x04\xa9\x04\x08\
    \x10\n\r\n\x05\x04,\x02\x02\x06\x12\x04\xa9\x04\x11$\n\r\n\x05\x04,\x02\
    \x02\x01\x12\x04\xa9\x04%4\n\r\n\x05\x04,\x02\x02\x03\x12\x04\xa9\x0478\
    \n\x0c\n\x04\x04,\x02\x03\x12\x04\xaa\x04\x08)\n\r\n\x05\x04,\x02\x03\
    \x04\x12\x04\xaa\x04\x08\x10\n\r\n\x05\x04,\x02\x03\x05\x12\x04\xaa\x04\
    \x11\x17\n\r\n\x05\x04,\x02\x03\x01\x12\x04\xaa\x04\x18$\n\r\n\x05\x04,\
    \x02\x03\x03\x12\x04\xaa\x04'(\n\x0c\n\x04\x04,\x02\x04\x12\x04\xab\x04\
    \x083\n\r\n\x05\x04,\x02\x04\x04\x12\x04\xab\x04\x08\x10\n\r\n\x05\x04,\
    \x02\x04\x06\x12\x04\xab\x04\x11#\n\r\n\x05\x04,\x02\x04\x01\x12\x04\xab\
    \x04$.\n\r\n\x05\x04,\x02\x04\x03\x12\x04\xab\x0412\n\x0c\n\x02\x04-\x12\
    \x06\xae\x04\0\xb4\x04\x01\n\x0b\n\x03\x04-\x01\x12\x04\xae\x04\x08\x1f\
    \n\x0c\n\x04\x04-\x02\0\x12\x04\xaf\x04\x08\x1e\n\r\n\x05\x04-\x02\0\x04\
    \x12\x04\xaf\x04\x08\x10\n\r\n\x05\x04-\x02\0\x05\x12\x04\xaf\x04\x11\
    \x17\n\r\n\x05\x04-\x02\0\x01\x12\x04\xaf\x04\x18\x19\n\r\n\x05\x04-\x02\
    \0\x03\x12\x04\xaf\x04\x1c\x1d\n\x0c\n\x04\x04-\x02\x01\x12\x04\xb0\x04\
    \x08\x1e\n\r\n\x05\x04-\x02\x01\x04\x12\x04\xb0\x04\x08\x10\n\r\n\x05\
    \x04-\x02\x01\x05\x12\x04\xb0\x04\x11\x17\n\r\n\x05\x04-\x02\x01\x01\x12\
    \x04\xb0\x04\x18\x19\n\r\n\x05\x04-\x02\x01\x03\x12\x04\xb0\x04\x1c\x1d\
    \n\x0c\n\x04\x04-\x02\x02\x12\x04\xb1\x04\x08'\n\r\n\x05\x04-\x02\x02\
    \x04\x12\x04\xb1\x04\x08\x10\n\r\n\x05\x04-\x02\x02\x05\x12\x04\xb1\x04\
    \x11\x15\n\r\n\x05\x04-\x02\x02\x01\x12\x04\xb1\x04\x16\"\n\r\n\x05\x04-\
    \x02\x02\x03\x12\x04\xb1\x04%&\n\x0c\n\x04\x04-\x02\x03\x12\x04\xb2\x04\
    \x08'\n\r\n\x05\x04-\x02\x03\x04\x12\x04\xb2\x04\x08\x10\n\r\n\x05\x04-\
    \x02\x03\x05\x12\x04\xb2\x04\x11\x15\n\r\n\x05\x04-\x02\x03\x01\x12\x04\
    \xb2\x04\x16\"\n\r\n\x05\x04-\x02\x03\x03\x12\x04\xb2\x04%&\n\x0c\n\x04\
    \x04-\x02\x04\x12\x04\xb3\x04\x08-\n\r\n\x05\x04-\x02\x04\x04\x12\x04\
    \xb3\x04\x08\x10\n\r\n\x05\x04-\x02\x04\x05\x12\x04\xb3\x04\x11\x15\n\r\
    \n\x05\x04-\x02\x04\x01\x12\x04\xb3\x04\x16(\n\r\n\x05\x04-\x02\x04\x03\
    \x12\x04\xb3\x04+,\n\x0c\n\x02\x04.\x12\x06\xb6\x04\0\xc4\x04\x01\n\x0b\
    \n\x03\x04.\x01\x12\x04\xb6\x04\x08\x1d\n\r\n\x03\x04.\x06\x12\x06\xb7\
    \x04\x08\xb9\x04\t\n\x0c\n\x04\x04.\x06\0\x12\x04\xb8\x04\x10_\n\r\n\x05\
    \x04.\x06\0\x02\x12\x04\xb7\x04\x0f&\n\r\n\x05\x04.\x06\0\x04\x12\x04\
    \xb8\x04\x10\x18\n\r\n\x05\x04.\x06\0\x06\x12\x04\xb8\x04\x19B\n\r\n\x05\
    \x04.\x06\0\x01\x12\x04\xb8\x04CW\n\r\n\x05\x04.\x06\0\x03\x12\x04\xb8\
    \x04Z^\n\x0e\n\x04\x04.\x03\0\x12\x06\xbb\x04\x08\xbd\x04\t\n\r\n\x05\
    \x04.\x03\0\x01\x12\x04\xbb\x04\x10\"\n\x0e\n\x06\x04.\x03\0\x02\0\x12\
    \x04\xbc\x04\x10;\n\x0f\n\x07\x04.\x03\0\x02\0\x04\x12\x04\xbc\x04\x10\
    \x18\n\x0f\n\x07\x04.\x03\0\x02\0\x06\x12\x04\xbc\x04\x191\n\x0f\n\x07\
    \x04.\x03\0\x02\0\x01\x12\x04\xbc\x0426\n\x0f\n\x07\x04.\x03\0\x02\0\x03\
    \x12\x04\xbc\x049:\n\x0c\n\x04\x04.\x02\0\x12\x04\xbf\x04\x083\n\r\n\x05\
    \x04.\x02\0\x04\x12\x04\xbf\x04\x08\x10\n\r\n\x05\x04.\x02\0\x06\x12\x04\
    \xbf\x04\x11)\n\r\n\x05\x04.\x02\0\x01\x12\x04\xbf\x04*.\n\r\n\x05\x04.\
    \x02\0\x03\x12\x04\xbf\x0412\n\x0c\n\x04\x04.\x02\x01\x12\x04\xc0\x04\
    \x089\n\r\n\x05\x04.\x02\x01\x04\x12\x04\xc0\x04\x08\x10\n\r\n\x05\x04.\
    \x02\x01\x06\x12\x04\xc0\x04\x11)\n\r\n\x05\x04.\x02\x01\x01\x12\x04\xc0\
    \x04*4\n\r\n\x05\x04.\x02\x01\x03\x12\x04\xc0\x0478\n\x0c\n\x04\x04.\x02\
    \x02\x12\x04\xc1\x04\x089\n\r\n\x05\x04.\x02\x02\x04\x12\x04\xc1\x04\x08\
    \x10\n\r\n\x05\x04.\x02\x02\x06\x12\x04\xc1\x04\x11$\n\r\n\x05\x04.\x02\
    \x02\x01\x12\x04\xc1\x04%4\n\r\n\x05\x04.\x02\x02\x03\x12\x04\xc1\x0478\
    \n\x0c\n\x04\x04.\x02\x03\x12\x04\xc2\x04\x08)\n\r\n\x05\x04.\x02\x03\
    \x04\x12\x04\xc2\x04\x08\x10\n\r\n\x05\x04.\x02\x03\x05\x12\x04\xc2\x04\
    \x11\x17\n\r\n\x05\x04.\x02\x03\x01\x12\x04\xc2\x04\x18$\n\r\n\x05\x04.\
    \x02\x03\x03\x12\x04\xc2\x04'(\n\x0c\n\x04\x04.\x02\x04\x12\x04\xc3\x04\
    \x083\n\r\n\x05\x04.\x02\x04\x04\x12\x04\xc3\x04\x08\x10\n\r\n\x05\x04.\
    \x02\x04\x06\x12\x04\xc3\x04\x11#\n\r\n\x05\x04.\x02\x04\x01\x12\x04\xc3\
    \x04$.\n\r\n\x05\x04.\x02\x04\x03\x12\x04\xc3\x0412\n\x0c\n\x02\x04/\x12\
    \x06\xc6\x04\0\xd4\x04\x01\n\x0b\n\x03\x04/\x01\x12\x04\xc6\x04\x08\x1d\
    \n\r\n\x03\x04/\x06\x12\x06\xc7\x04\x08\xc9\x04\t\n\x0c\n\x04\x04/\x06\0\
    \x12\x04\xc8\x04\x10_\n\r\n\x05\x04/\x06\0\x02\x12\x04\xc7\x04\x0f&\n\r\
    \n\x05\x04/\x06\0\x04\x12\x04\xc8\x04\x10\x18\n\r\n\x05\x04/\x06\0\x06\
    \x12\x04\xc8\x04\x19B\n\r\n\x05\x04/\x06\0\x01\x12\x04\xc8\x04CW\n\r\n\
    \x05\x04/\x06\0\x03\x12\x04\xc8\x04Z^\n\x0e\n\x04\x04/\x03\0\x12\x06\xcb\
    \x04\x08\xcd\x04\t\n\r\n\x05\x04/\x03\0\x01\x12\x04\xcb\x04\x10\"\n\x0e\
    \n\x06\x04/\x03\0\x02\0\x12\x04\xcc\x04\x101\n\x0f\n\x07\x04/\x03\0\x02\
    \0\x04\x12\x04\xcc\x04\x10\x18\n\x0f\n\x07\x04/\x03\0\x02\0\x06\x12\x04\
    \xcc\x04\x19'\n\x0f\n\x07\x04/\x03\0\x02\0\x01\x12\x04\xcc\x04(,\n\x0f\n\
    \x07\x04/\x03\0\x02\0\x03\x12\x04\xcc\x04/0\n\x0c\n\x04\x04/\x02\0\x12\
    \x04\xcf\x04\x08)\n\r\n\x05\x04/\x02\0\x04\x12\x04\xcf\x04\x08\x10\n\r\n\
    \x05\x04/\x02\0\x06\x12\x04\xcf\x04\x11\x1f\n\r\n\x05\x04/\x02\0\x01\x12\
    \x04\xcf\x04\x20$\n\r\n\x05\x04/\x02\0\x03\x12\x04\xcf\x04'(\n\x0c\n\x04\
    \x04/\x02\x01\x12\x04\xd0\x04\x089\n\r\n\x05\x04/\x02\x01\x04\x12\x04\
    \xd0\x04\x08\x10\n\r\n\x05\x04/\x02\x01\x06\x12\x04\xd0\x04\x11$\n\r\n\
    \x05\x04/\x02\x01\x01\x12\x04\xd0\x04%4\n\r\n\x05\x04/\x02\x01\x03\x12\
    \x04\xd0\x0478\n\x0c\n\x04\x04/\x02\x02\x12\x04\xd1\x04\x08/\n\r\n\x05\
    \x04/\x02\x02\x04\x12\x04\xd1\x04\x08\x10\n\r\n\x05\x04/\x02\x02\x06\x12\
    \x04\xd1\x04\x11\x1f\n\r\n\x05\x04/\x02\x02\x01\x12\x04\xd1\x04\x20*\n\r\
    \n\x05\x04/\x02\x02\x03\x12\x04\xd1\x04-.\n\x0c\n\x04\x04/\x02\x03\x12\
    \x04\xd2\x04\x08)\n\r\n\x05\x04/\x02\x03\x04\x12\x04\xd2\x04\x08\x10\n\r\
    \n\x05\x04/\x02\x03\x05\x12\x04\xd2\x04\x11\x17\n\r\n\x05\x04/\x02\x03\
    \x01\x12\x04\xd2\x04\x18$\n\r\n\x05\x04/\x02\x03\x03\x12\x04\xd2\x04'(\n\
    \x0c\n\x04\x04/\x02\x04\x12\x04\xd3\x04\x083\n\r\n\x05\x04/\x02\x04\x04\
    \x12\x04\xd3\x04\x08\x10\n\r\n\x05\x04/\x02\x04\x06\x12\x04\xd3\x04\x11#\
    \n\r\n\x05\x04/\x02\x04\x01\x12\x04\xd3\x04$.\n\r\n\x05\x04/\x02\x04\x03\
    \x12\x04\xd3\x0412\n\x0c\n\x02\x040\x12\x06\xd6\x04\0\xe4\x04\x01\n\x0b\
    \n\x03\x040\x01\x12\x04\xd6\x04\x08\x18\n\r\n\x03\x040\x06\x12\x06\xd7\
    \x04\x08\xd9\x04\t\n\x0c\n\x04\x040\x06\0\x12\x04\xd8\x04\x10Z\n\r\n\x05\
    \x040\x06\0\x02\x12\x04\xd7\x04\x0f&\n\r\n\x05\x040\x06\0\x04\x12\x04\
    \xd8\x04\x10\x18\n\r\n\x05\x040\x06\0\x06\x12\x04\xd8\x04\x19=\n\r\n\x05\
    \x040\x06\0\x01\x12\x04\xd8\x04>R\n\r\n\x05\x040\x06\0\x03\x12\x04\xd8\
    \x04UY\n\x0e\n\x04\x040\x03\0\x12\x06\xdb\x04\x08\xdd\x04\t\n\r\n\x05\
    \x040\x03\0\x01\x12\x04\xdb\x04\x10\"\n\x0e\n\x06\x040\x03\0\x02\0\x12\
    \x04\xdc\x04\x10/\n\x0f\n\x07\x040\x03\0\x02\0\x04\x12\x04\xdc\x04\x10\
    \x18\n\x0f\n\x07\x040\x03\0\x02\0\x06\x12\x04\xdc\x04\x19%\n\x0f\n\x07\
    \x040\x03\0\x02\0\x01\x12\x04\xdc\x04&*\n\x0f\n\x07\x040\x03\0\x02\0\x03\
    \x12\x04\xdc\x04-.\n\x0c\n\x04\x040\x02\0\x12\x04\xdf\x04\x08'\n\r\n\x05\
    \x040\x02\0\x04\x12\x04\xdf\x04\x08\x10\n\r\n\x05\x040\x02\0\x06\x12\x04\
    \xdf\x04\x11\x1d\n\r\n\x05\x040\x02\0\x01\x12\x04\xdf\x04\x1e\"\n\r\n\
    \x05\x040\x02\0\x03\x12\x04\xdf\x04%&\n\x0c\n\x04\x040\x02\x01\x12\x04\
    \xe0\x04\x089\n\r\n\x05\x040\x02\x01\x04\x12\x04\xe0\x04\x08\x10\n\r\n\
    \x05\x040\x02\x01\x06\x12\x04\xe0\x04\x11$\n\r\n\x05\x040\x02\x01\x01\
    \x12\x04\xe0\x04%4\n\r\n\x05\x040\x02\x01\x03\x12\x04\xe0\x0478\n\x0c\n\
    \x04\x040\x02\x02\x12\x04\xe1\x04\x08-\n\r\n\x05\x040\x02\x02\x04\x12\
    \x04\xe1\x04\x08\x10\n\r\n\x05\x040\x02\x02\x06\x12\x04\xe1\x04\x11\x1d\
    \n\r\n\x05\x040\x02\x02\x01\x12\x04\xe1\x04\x1e(\n\r\n\x05\x040\x02\x02\
    \x03\x12\x04\xe1\x04+,\n\x0c\n\x04\x040\x02\x03\x12\x04\xe2\x04\x08)\n\r\
    \n\x05\x040\x02\x03\x04\x12\x04\xe2\x04\x08\x10\n\r\n\x05\x040\x02\x03\
    \x05\x12\x04\xe2\x04\x11\x17\n\r\n\x05\x040\x02\x03\x01\x12\x04\xe2\x04\
    \x18$\n\r\n\x05\x040\x02\x03\x03\x12\x04\xe2\x04'(\n\x0c\n\x04\x040\x02\
    \x04\x12\x04\xe3\x04\x083\n\r\n\x05\x040\x02\x04\x04\x12\x04\xe3\x04\x08\
    \x10\n\r\n\x05\x040\x02\x04\x06\x12\x04\xe3\x04\x11#\n\r\n\x05\x040\x02\
    \x04\x01\x12\x04\xe3\x04$.\n\r\n\x05\x040\x02\x04\x03\x12\x04\xe3\x0412\
    \n\x0c\n\x02\x041\x12\x06\xe6\x04\0\xf4\x04\x01\n\x0b\n\x03\x041\x01\x12\
    \x04\xe6\x04\x08\x12\n\r\n\x03\x041\x06\x12\x06\xe7\x04\x08\xe9\x04\t\n\
    \x0c\n\x04\x041\x06\0\x12\x04\xe8\x04\x10T\n\r\n\x05\x041\x06\0\x02\x12\
    \x04\xe7\x04\x0f&\n\r\n\x05\x041\x06\0\x04\x12\x04\xe8\x04\x10\x18\n\r\n\
    \x05\x041\x06\0\x06\x12\x04\xe8\x04\x197\n\r\n\x05\x041\x06\0\x01\x12\
    \x04\xe8\x048L\n\r\n\x05\x041\x06\0\x03\x12\x04\xe8\x04OS\n\x0e\n\x04\
    \x041\x03\0\x12\x06\xeb\x04\x08\xed\x04\t\n\r\n\x05\x041\x03\0\x01\x12\
    \x04\xeb\x04\x10\"\n\x0e\n\x06\x041\x03\0\x02\0\x12\x04\xec\x04\x10/\n\
    \x0f\n\x07\x041\x03\0\x02\0\x04\x12\x04\xec\x04\x10\x18\n\x0f\n\x07\x041\
    \x03\0\x02\0\x06\x12\x04\xec\x04\x19%\n\x0f\n\x07\x041\x03\0\x02\0\x01\
    \x12\x04\xec\x04&*\n\x0f\n\x07\x041\x03\0\x02\0\x03\x12\x04\xec\x04-.\n\
    \x0c\n\x04\x041\x02\0\x12\x04\xef\x04\x08'\n\r\n\x05\x041\x02\0\x04\x12\
    \x04\xef\x04\x08\x10\n\r\n\x05\x041\x02\0\x06\x12\x04\xef\x04\x11\x1d\n\
    \r\n\x05\x041\x02\0\x01\x12\x04\xef\x04\x1e\"\n\r\n\x05\x041\x02\0\x03\
    \x12\x04\xef\x04%&\n\x0c\n\x04\x041\x02\x01\x12\x04\xf0\x04\x089\n\r\n\
    \x05\x041\x02\x01\x04\x12\x04\xf0\x04\x08\x10\n\r\n\x05\x041\x02\x01\x06\
    \x12\x04\xf0\x04\x11$\n\r\n\x05\x041\x02\x01\x01\x12\x04\xf0\x04%4\n\r\n\
    \x05\x041\x02\x01\x03\x12\x04\xf0\x0478\n\x0c\n\x04\x041\x02\x02\x12\x04\
    \xf1\x04\x08-\n\r\n\x05\x041\x02\x02\x04\x12\x04\xf1\x04\x08\x10\n\r\n\
    \x05\x041\x02\x02\x06\x12\x04\xf1\x04\x11\x1d\n\r\n\x05\x041\x02\x02\x01\
    \x12\x04\xf1\x04\x1e(\n\r\n\x05\x041\x02\x02\x03\x12\x04\xf1\x04+,\n\x0c\
    \n\x04\x041\x02\x03\x12\x04\xf2\x04\x08)\n\r\n\x05\x041\x02\x03\x04\x12\
    \x04\xf2\x04\x08\x10\n\r\n\x05\x041\x02\x03\x05\x12\x04\xf2\x04\x11\x17\
    \n\r\n\x05\x041\x02\x03\x01\x12\x04\xf2\x04\x18$\n\r\n\x05\x041\x02\x03\
    \x03\x12\x04\xf2\x04'(\n\x0c\n\x04\x041\x02\x04\x12\x04\xf3\x04\x083\n\r\
    \n\x05\x041\x02\x04\x04\x12\x04\xf3\x04\x08\x10\n\r\n\x05\x041\x02\x04\
    \x06\x12\x04\xf3\x04\x11#\n\r\n\x05\x041\x02\x04\x01\x12\x04\xf3\x04$.\n\
    \r\n\x05\x041\x02\x04\x03\x12\x04\xf3\x0412\n\x0c\n\x02\x042\x12\x06\xf6\
    \x04\0\x84\x05\x01\n\x0b\n\x03\x042\x01\x12\x04\xf6\x04\x08\x15\n\r\n\
    \x03\x042\x06\x12\x06\xf7\x04\x08\xf9\x04\t\n\x0c\n\x04\x042\x06\0\x12\
    \x04\xf8\x04\x10W\n\r\n\x05\x042\x06\0\x02\x12\x04\xf7\x04\x0f&\n\r\n\
    \x05\x042\x06\0\x04\x12\x04\xf8\x04\x10\x18\n\r\n\x05\x042\x06\0\x06\x12\
    \x04\xf8\x04\x19:\n\r\n\x05\x042\x06\0\x01\x12\x04\xf8\x04;O\n\r\n\x05\
    \x042\x06\0\x03\x12\x04\xf8\x04RV\n\x0e\n\x04\x042\x03\0\x12\x06\xfb\x04\
    \x08\xfd\x04\t\n\r\n\x05\x042\x03\0\x01\x12\x04\xfb\x04\x10\"\n\x0e\n\
    \x06\x042\x03\0\x02\0\x12\x04\xfc\x04\x102\n\x0f\n\x07\x042\x03\0\x02\0\
    \x04\x12\x04\xfc\x04\x10\x18\n\x0f\n\x07\x042\x03\0\x02\0\x06\x12\x04\
    \xfc\x04\x19(\n\x0f\n\x07\x042\x03\0\x02\0\x01\x12\x04\xfc\x04)-\n\x0f\n\
    \x07\x042\x03\0\x02\0\x03\x12\x04\xfc\x0401\n\x0c\n\x04\x042\x02\0\x12\
    \x04\xff\x04\x08*\n\r\n\x05\x042\x02\0\x04\x12\x04\xff\x04\x08\x10\n\r\n\
    \x05\x042\x02\0\x06\x12\x04\xff\x04\x11\x20\n\r\n\x05\x042\x02\0\x01\x12\
    \x04\xff\x04!%\n\r\n\x05\x042\x02\0\x03\x12\x04\xff\x04()\n\x0c\n\x04\
    \x042\x02\x01\x12\x04\x80\x05\x089\n\r\n\x05\x042\x02\x01\x04\x12\x04\
    \x80\x05\x08\x10\n\r\n\x05\x042\x02\x01\x06\x12\x04\x80\x05\x11$\n\r\n\
    \x05\x042\x02\x01\x01\x12\x04\x80\x05%4\n\r\n\x05\x042\x02\x01\x03\x12\
    \x04\x80\x0578\n\x0c\n\x04\x042\x02\x02\x12\x04\x81\x05\x080\n\r\n\x05\
    \x042\x02\x02\x04\x12\x04\x81\x05\x08\x10\n\r\n\x05\x042\x02\x02\x06\x12\
    \x04\x81\x05\x11\x20\n\r\n\x05\x042\x02\x02\x01\x12\x04\x81\x05!+\n\r\n\
    \x05\x042\x02\x02\x03\x12\x04\x81\x05./\n\x0c\n\x04\x042\x02\x03\x12\x04\
    \x82\x05\x08)\n\r\n\x05\x042\x02\x03\x04\x12\x04\x82\x05\x08\x10\n\r\n\
    \x05\x042\x02\x03\x05\x12\x04\x82\x05\x11\x17\n\r\n\x05\x042\x02\x03\x01\
    \x12\x04\x82\x05\x18$\n\r\n\x05\x042\x02\x03\x03\x12\x04\x82\x05'(\n\x0c\
    \n\x04\x042\x02\x04\x12\x04\x83\x05\x083\n\r\n\x05\x042\x02\x04\x04\x12\
    \x04\x83\x05\x08\x10\n\r\n\x05\x042\x02\x04\x06\x12\x04\x83\x05\x11#\n\r\
    \n\x05\x042\x02\x04\x01\x12\x04\x83\x05$.\n\r\n\x05\x042\x02\x04\x03\x12\
    \x04\x83\x0512\n\x0c\n\x02\x043\x12\x06\x86\x05\0\x94\x05\x01\n\x0b\n\
    \x03\x043\x01\x12\x04\x86\x05\x08\x16\n\r\n\x03\x043\x06\x12\x06\x87\x05\
    \x08\x89\x05\t\n\x0c\n\x04\x043\x06\0\x12\x04\x88\x05\x10X\n\r\n\x05\x04\
    3\x06\0\x02\x12\x04\x87\x05\x0f&\n\r\n\x05\x043\x06\0\x04\x12\x04\x88\
    \x05\x10\x18\n\r\n\x05\x043\x06\0\x06\x12\x04\x88\x05\x19;\n\r\n\x05\x04\
    3\x06\0\x01\x12\x04\x88\x05<P\n\r\n\x05\x043\x06\0\x03\x12\x04\x88\x05SW\
    \n\x0e\n\x04\x043\x03\0\x12\x06\x8b\x05\x08\x8d\x05\t\n\r\n\x05\x043\x03\
    \0\x01\x12\x04\x8b\x05\x10\"\n\x0e\n\x06\x043\x03\0\x02\0\x12\x04\x8c\
    \x05\x103\n\x0f\n\x07\x043\x03\0\x02\0\x04\x12\x04\x8c\x05\x10\x18\n\x0f\
    \n\x07\x043\x03\0\x02\0\x06\x12\x04\x8c\x05\x19)\n\x0f\n\x07\x043\x03\0\
    \x02\0\x01\x12\x04\x8c\x05*.\n\x0f\n\x07\x043\x03\0\x02\0\x03\x12\x04\
    \x8c\x0512\n\x0c\n\x04\x043\x02\0\x12\x04\x8f\x05\x08+\n\r\n\x05\x043\
    \x02\0\x04\x12\x04\x8f\x05\x08\x10\n\r\n\x05\x043\x02\0\x06\x12\x04\x8f\
    \x05\x11!\n\r\n\x05\x043\x02\0\x01\x12\x04\x8f\x05\"&\n\r\n\x05\x043\x02\
    \0\x03\x12\x04\x8f\x05)*\n\x0c\n\x04\x043\x02\x01\x12\x04\x90\x05\x089\n\
    \r\n\x05\x043\x02\x01\x04\x12\x04\x90\x05\x08\x10\n\r\n\x05\x043\x02\x01\
    \x06\x12\x04\x90\x05\x11$\n\r\n\x05\x043\x02\x01\x01\x12\x04\x90\x05%4\n\
    \r\n\x05\x043\x02\x01\x03\x12\x04\x90\x0578\n\x0c\n\x04\x043\x02\x02\x12\
    \x04\x91\x05\x081\n\r\n\x05\x043\x02\x02\x04\x12\x04\x91\x05\x08\x10\n\r\
    \n\x05\x043\x02\x02\x06\x12\x04\x91\x05\x11!\n\r\n\x05\x043\x02\x02\x01\
    \x12\x04\x91\x05\",\n\r\n\x05\x043\x02\x02\x03\x12\x04\x91\x05/0\n\x0c\n\
    \x04\x043\x02\x03\x12\x04\x92\x05\x08)\n\r\n\x05\x043\x02\x03\x04\x12\
    \x04\x92\x05\x08\x10\n\r\n\x05\x043\x02\x03\x05\x12\x04\x92\x05\x11\x17\
    \n\r\n\x05\x043\x02\x03\x01\x12\x04\x92\x05\x18$\n\r\n\x05\x043\x02\x03\
    \x03\x12\x04\x92\x05'(\n\x0c\n\x04\x043\x02\x04\x12\x04\x93\x05\x083\n\r\
    \n\x05\x043\x02\x04\x04\x12\x04\x93\x05\x08\x10\n\r\n\x05\x043\x02\x04\
    \x06\x12\x04\x93\x05\x11#\n\r\n\x05\x043\x02\x04\x01\x12\x04\x93\x05$.\n\
    \r\n\x05\x043\x02\x04\x03\x12\x04\x93\x0512\n\x0c\n\x02\x044\x12\x06\x96\
    \x05\0\xa4\x05\x01\n\x0b\n\x03\x044\x01\x12\x04\x96\x05\x08\x10\n\r\n\
    \x03\x044\x06\x12\x06\x97\x05\x08\x99\x05\t\n\x0c\n\x04\x044\x06\0\x12\
    \x04\x98\x05\x10R\n\r\n\x05\x044\x06\0\x02\x12\x04\x97\x05\x0f&\n\r\n\
    \x05\x044\x06\0\x04\x12\x04\x98\x05\x10\x18\n\r\n\x05\x044\x06\0\x06\x12\
    \x04\x98\x05\x195\n\r\n\x05\x044\x06\0\x01\x12\x04\x98\x056J\n\r\n\x05\
    \x044\x06\0\x03\x12\x04\x98\x05MQ\n\x0e\n\x04\x044\x03\0\x12\x06\x9b\x05\
    \x08\x9d\x05\t\n\r\n\x05\x044\x03\0\x01\x12\x04\x9b\x05\x10\"\n\x0e\n\
    \x06\x044\x03\0\x02\0\x12\x04\x9c\x05\x100\n\x0f\n\x07\x044\x03\0\x02\0\
    \x04\x12\x04\x9c\x05\x10\x18\n\x0f\n\x07\x044\x03\0\x02\0\x06\x12\x04\
    \x9c\x05\x19&\n\x0f\n\x07\x044\x03\0\x02\0\x01\x12\x04\x9c\x05'+\n\x0f\n\
    \x07\x044\x03\0\x02\0\x03\x12\x04\x9c\x05./\n\x0c\n\x04\x044\x02\0\x12\
    \x04\x9f\x05\x08(\n\r\n\x05\x044\x02\0\x04\x12\x04\x9f\x05\x08\x10\n\r\n\
    \x05\x044\x02\0\x06\x12\x04\x9f\x05\x11\x1e\n\r\n\x05\x044\x02\0\x01\x12\
    \x04\x9f\x05\x1f#\n\r\n\x05\x044\x02\0\x03\x12\x04\x9f\x05&'\n\x0c\n\x04\
    \x044\x02\x01\x12\x04\xa0\x05\x089\n\r\n\x05\x044\x02\x01\x04\x12\x04\
    \xa0\x05\x08\x10\n\r\n\x05\x044\x02\x01\x06\x12\x04\xa0\x05\x11$\n\r\n\
    \x05\x044\x02\x01\x01\x12\x04\xa0\x05%4\n\r\n\x05\x044\x02\x01\x03\x12\
    \x04\xa0\x0578\n\x0c\n\x04\x044\x02\x02\x12\x04\xa1\x05\x08.\n\r\n\x05\
    \x044\x02\x02\x04\x12\x04\xa1\x05\x08\x10\n\r\n\x05\x044\x02\x02\x06\x12\
    \x04\xa1\x05\x11\x1e\n\r\n\x05\x044\x02\x02\x01\x12\x04\xa1\x05\x1f)\n\r\
    \n\x05\x044\x02\x02\x03\x12\x04\xa1\x05,-\n\x0c\n\x04\x044\x02\x03\x12\
    \x04\xa2\x05\x08)\n\r\n\x05\x044\x02\x03\x04\x12\x04\xa2\x05\x08\x10\n\r\
    \n\x05\x044\x02\x03\x05\x12\x04\xa2\x05\x11\x17\n\r\n\x05\x044\x02\x03\
    \x01\x12\x04\xa2\x05\x18$\n\r\n\x05\x044\x02\x03\x03\x12\x04\xa2\x05'(\n\
    \x0c\n\x04\x044\x02\x04\x12\x04\xa3\x05\x083\n\r\n\x05\x044\x02\x04\x04\
    \x12\x04\xa3\x05\x08\x10\n\r\n\x05\x044\x02\x04\x06\x12\x04\xa3\x05\x11#\
    \n\r\n\x05\x044\x02\x04\x01\x12\x04\xa3\x05$.\n\r\n\x05\x044\x02\x04\x03\
    \x12\x04\xa3\x0512\n\x0c\n\x02\x045\x12\x06\xa6\x05\0\xaa\x05\x01\n\x0b\
    \n\x03\x045\x01\x12\x04\xa6\x05\x08\x19\n\x0c\n\x04\x045\x02\0\x12\x04\
    \xa7\x05\x08)\n\r\n\x05\x045\x02\0\x04\x12\x04\xa7\x05\x08\x10\n\r\n\x05\
    \x045\x02\0\x06\x12\x04\xa7\x05\x11\x1b\n\r\n\x05\x045\x02\0\x01\x12\x04\
    \xa7\x05\x1c$\n\r\n\x05\x045\x02\0\x03\x12\x04\xa7\x05'(\n\x0c\n\x04\x04\
    5\x02\x01\x12\x04\xa8\x05\x08-\n\r\n\x05\x045\x02\x01\x04\x12\x04\xa8\
    \x05\x08\x10\n\r\n\x05\x045\x02\x01\x06\x12\x04\xa8\x05\x11\x1b\n\r\n\
    \x05\x045\x02\x01\x01\x12\x04\xa8\x05\x1c(\n\r\n\x05\x045\x02\x01\x03\
    \x12\x04\xa8\x05+,\n\x0c\n\x04\x045\x02\x02\x12\x04\xa9\x05\x080\n\r\n\
    \x05\x045\x02\x02\x04\x12\x04\xa9\x05\x08\x10\n\r\n\x05\x045\x02\x02\x06\
    \x12\x04\xa9\x05\x11\x1d\n\r\n\x05\x045\x02\x02\x01\x12\x04\xa9\x05\x1e+\
    \n\r\n\x05\x045\x02\x02\x03\x12\x04\xa9\x05./\n\x0c\n\x02\x046\x12\x06\
    \xac\x05\0\xad\x05\x01\n\x0b\n\x03\x046\x01\x12\x04\xac\x05\x08\x18\n\
    \x0c\n\x02\x047\x12\x06\xaf\x05\0\xc9\x05\x01\n\x0b\n\x03\x047\x01\x12\
    \x04\xaf\x05\x08#\n\x0c\n\x04\x047\x02\0\x12\x04\xb0\x05\x08*\n\r\n\x05\
    \x047\x02\0\x04\x12\x04\xb0\x05\x08\x10\n\r\n\x05\x047\x02\0\x05\x12\x04\
    \xb0\x05\x11\x17\n\r\n\x05\x047\x02\0\x01\x12\x04\xb0\x05\x18%\n\r\n\x05\
    \x047\x02\0\x03\x12\x04\xb0\x05()\n\x0c\n\x04\x047\x02\x01\x12\x04\xb1\
    \x05\x08*\n\r\n\x05\x047\x02\x01\x04\x12\x04\xb1\x05\x08\x10\n\r\n\x05\
    \x047\x02\x01\x05\x12\x04\xb1\x05\x11\x17\n\r\n\x05\x047\x02\x01\x01\x12\
    \x04\xb1\x05\x18%\n\r\n\x05\x047\x02\x01\x03\x12\x04\xb1\x05()\n\x0c\n\
    \x04\x047\x02\x02\x12\x04\xb2\x05\x08*\n\r\n\x05\x047\x02\x02\x04\x12\
    \x04\xb2\x05\x08\x10\n\r\n\x05\x047\x02\x02\x05\x12\x04\xb2\x05\x11\x17\
    \n\r\n\x05\x047\x02\x02\x01\x12\x04\xb2\x05\x18%\n\r\n\x05\x047\x02\x02\
    \x03\x12\x04\xb2\x05()\n\x0c\n\x04\x047\x02\x03\x12\x04\xb3\x05\x08*\n\r\
    \n\x05\x047\x02\x03\x04\x12\x04\xb3\x05\x08\x10\n\r\n\x05\x047\x02\x03\
    \x05\x12\x04\xb3\x05\x11\x17\n\r\n\x05\x047\x02\x03\x01\x12\x04\xb3\x05\
    \x18%\n\r\n\x05\x047\x02\x03\x03\x12\x04\xb3\x05()\n\x0c\n\x04\x047\x02\
    \x04\x12\x04\xb4\x05\x08*\n\r\n\x05\x047\x02\x04\x04\x12\x04\xb4\x05\x08\
    \x10\n\r\n\x05\x047\x02\x04\x05\x12\x04\xb4\x05\x11\x17\n\r\n\x05\x047\
    \x02\x04\x01\x12\x04\xb4\x05\x18%\n\r\n\x05\x047\x02\x04\x03\x12\x04\xb4\
    \x05()\n\x0c\n\x04\x047\x02\x05\x12\x04\xb5\x05\x08*\n\r\n\x05\x047\x02\
    \x05\x04\x12\x04\xb5\x05\x08\x10\n\r\n\x05\x047\x02\x05\x05\x12\x04\xb5\
    \x05\x11\x17\n\r\n\x05\x047\x02\x05\x01\x12\x04\xb5\x05\x18%\n\r\n\x05\
    \x047\x02\x05\x03\x12\x04\xb5\x05()\n\x0c\n\x04\x047\x02\x06\x12\x04\xb6\
    \x05\x08*\n\r\n\x05\x047\x02\x06\x04\x12\x04\xb6\x05\x08\x10\n\r\n\x05\
    \x047\x02\x06\x05\x12\x04\xb6\x05\x11\x17\n\r\n\x05\x047\x02\x06\x01\x12\
    \x04\xb6\x05\x18%\n\r\n\x05\x047\x02\x06\x03\x12\x04\xb6\x05()\n\x0c\n\
    \x04\x047\x02\x07\x12\x04\xb7\x05\x08*\n\r\n\x05\x047\x02\x07\x04\x12\
    \x04\xb7\x05\x08\x10\n\r\n\x05\x047\x02\x07\x05\x12\x04\xb7\x05\x11\x17\
    \n\r\n\x05\x047\x02\x07\x01\x12\x04\xb7\x05\x18%\n\r\n\x05\x047\x02\x07\
    \x03\x12\x04\xb7\x05()\n\x0c\n\x04\x047\x02\x08\x12\x04\xb8\x05\x08*\n\r\
    \n\x05\x047\x02\x08\x04\x12\x04\xb8\x05\x08\x10\n\r\n\x05\x047\x02\x08\
    \x05\x12\x04\xb8\x05\x11\x17\n\r\n\x05\x047\x02\x08\x01\x12\x04\xb8\x05\
    \x18%\n\r\n\x05\x047\x02\x08\x03\x12\x04\xb8\x05()\n\x0c\n\x04\x047\x02\
    \t\x12\x04\xb9\x05\x08+\n\r\n\x05\x047\x02\t\x04\x12\x04\xb9\x05\x08\x10\
    \n\r\n\x05\x047\x02\t\x05\x12\x04\xb9\x05\x11\x17\n\r\n\x05\x047\x02\t\
    \x01\x12\x04\xb9\x05\x18%\n\r\n\x05\x047\x02\t\x03\x12\x04\xb9\x05(*\n\
    \x0c\n\x04\x047\x02\n\x12\x04\xba\x05\x08+\n\r\n\x05\x047\x02\n\x04\x12\
    \x04\xba\x05\x08\x10\n\r\n\x05\x047\x02\n\x05\x12\x04\xba\x05\x11\x17\n\
    \r\n\x05\x047\x02\n\x01\x12\x04\xba\x05\x18%\n\r\n\x05\x047\x02\n\x03\
    \x12\x04\xba\x05(*\n\x0c\n\x04\x047\x02\x0b\x12\x04\xbb\x05\x08+\n\r\n\
    \x05\x047\x02\x0b\x04\x12\x04\xbb\x05\x08\x10\n\r\n\x05\x047\x02\x0b\x05\
    \x12\x04\xbb\x05\x11\x17\n\r\n\x05\x047\x02\x0b\x01\x12\x04\xbb\x05\x18%\
    \n\r\n\x05\x047\x02\x0b\x03\x12\x04\xbb\x05(*\n\x0c\n\x04\x047\x02\x0c\
    \x12\x04\xbc\x05\x08+\n\r\n\x05\x047\x02\x0c\x04\x12\x04\xbc\x05\x08\x10\
    \n\r\n\x05\x047\x02\x0c\x05\x12\x04\xbc\x05\x11\x17\n\r\n\x05\x047\x02\
    \x0c\x01\x12\x04\xbc\x05\x18%\n\r\n\x05\x047\x02\x0c\x03\x12\x04\xbc\x05\
    (*\n\x0c\n\x04\x047\x02\r\x12\x04\xbd\x05\x08+\n\r\n\x05\x047\x02\r\x04\
    \x12\x04\xbd\x05\x08\x10\n\r\n\x05\x047\x02\r\x05\x12\x04\xbd\x05\x11\
    \x17\n\r\n\x05\x047\x02\r\x01\x12\x04\xbd\x05\x18%\n\r\n\x05\x047\x02\r\
    \x03\x12\x04\xbd\x05(*\n\x0c\n\x04\x047\x02\x0e\x12\x04\xbe\x05\x08+\n\r\
    \n\x05\x047\x02\x0e\x04\x12\x04\xbe\x05\x08\x10\n\r\n\x05\x047\x02\x0e\
    \x05\x12\x04\xbe\x05\x11\x17\n\r\n\x05\x047\x02\x0e\x01\x12\x04\xbe\x05\
    \x18%\n\r\n\x05\x047\x02\x0e\x03\x12\x04\xbe\x05(*\n\x0c\n\x04\x047\x02\
    \x0f\x12\x04\xbf\x05\x08+\n\r\n\x05\x047\x02\x0f\x04\x12\x04\xbf\x05\x08\
    \x10\n\r\n\x05\x047\x02\x0f\x05\x12\x04\xbf\x05\x11\x17\n\r\n\x05\x047\
    \x02\x0f\x01\x12\x04\xbf\x05\x18%\n\r\n\x05\x047\x02\x0f\x03\x12\x04\xbf\
    \x05(*\n\x0c\n\x04\x047\x02\x10\x12\x04\xc0\x05\x081\n\r\n\x05\x047\x02\
    \x10\x04\x12\x04\xc0\x05\x08\x10\n\r\n\x05\x047\x02\x10\x06\x12\x04\xc0\
    \x05\x11\x20\n\r\n\x05\x047\x02\x10\x01\x12\x04\xc0\x05!+\n\r\n\x05\x047\
    \x02\x10\x03\x12\x04\xc0\x05.0\n\x0c\n\x04\x047\x02\x11\x12\x04\xc1\x05\
    \x08#\n\r\n\x05\x047\x02\x11\x04\x12\x04\xc1\x05\x08\x10\n\r\n\x05\x047\
    \x02\x11\x05\x12\x04\xc1\x05\x11\x17\n\r\n\x05\x047\x02\x11\x01\x12\x04\
    \xc1\x05\x18\x1d\n\r\n\x05\x047\x02\x11\x03\x12\x04\xc1\x05\x20\"\n\x0c\
    \n\x04\x047\x02\x12\x12\x04\xc2\x05\x08$\n\r\n\x05\x047\x02\x12\x04\x12\
    \x04\xc2\x05\x08\x10\n\r\n\x05\x047\x02\x12\x05\x12\x04\xc2\x05\x11\x17\
    \n\r\n\x05\x047\x02\x12\x01\x12\x04\xc2\x05\x18\x1e\n\r\n\x05\x047\x02\
    \x12\x03\x12\x04\xc2\x05!#\n\x0c\n\x04\x047\x02\x13\x12\x04\xc3\x05\x08(\
    \n\r\n\x05\x047\x02\x13\x04\x12\x04\xc3\x05\x08\x10\n\r\n\x05\x047\x02\
    \x13\x05\x12\x04\xc3\x05\x11\x17\n\r\n\x05\x047\x02\x13\x01\x12\x04\xc3\
    \x05\x18\"\n\r\n\x05\x047\x02\x13\x03\x12\x04\xc3\x05%'\n\x0c\n\x04\x047\
    \x02\x14\x12\x04\xc4\x05\x08(\n\r\n\x05\x047\x02\x14\x04\x12\x04\xc4\x05\
    \x08\x10\n\r\n\x05\x047\x02\x14\x05\x12\x04\xc4\x05\x11\x17\n\r\n\x05\
    \x047\x02\x14\x01\x12\x04\xc4\x05\x18\"\n\r\n\x05\x047\x02\x14\x03\x12\
    \x04\xc4\x05%'\n\x0c\n\x04\x047\x02\x15\x12\x04\xc5\x05\x08(\n\r\n\x05\
    \x047\x02\x15\x04\x12\x04\xc5\x05\x08\x10\n\r\n\x05\x047\x02\x15\x05\x12\
    \x04\xc5\x05\x11\x17\n\r\n\x05\x047\x02\x15\x01\x12\x04\xc5\x05\x18\"\n\
    \r\n\x05\x047\x02\x15\x03\x12\x04\xc5\x05%'\n\x0c\n\x04\x047\x02\x16\x12\
    \x04\xc6\x05\x08*\n\r\n\x05\x047\x02\x16\x04\x12\x04\xc6\x05\x08\x10\n\r\
    \n\x05\x047\x02\x16\x06\x12\x04\xc6\x05\x11\x1d\n\r\n\x05\x047\x02\x16\
    \x01\x12\x04\xc6\x05\x1e$\n\r\n\x05\x047\x02\x16\x03\x12\x04\xc6\x05')\n\
    \x0c\n\x04\x047\x02\x17\x12\x04\xc7\x05\x08&\n\r\n\x05\x047\x02\x17\x04\
    \x12\x04\xc7\x05\x08\x10\n\r\n\x05\x047\x02\x17\x05\x12\x04\xc7\x05\x11\
    \x17\n\r\n\x05\x047\x02\x17\x01\x12\x04\xc7\x05\x18\x20\n\r\n\x05\x047\
    \x02\x17\x03\x12\x04\xc7\x05#%\n\x0c\n\x04\x047\x02\x18\x12\x04\xc8\x05\
    \x08&\n\r\n\x05\x047\x02\x18\x04\x12\x04\xc8\x05\x08\x10\n\r\n\x05\x047\
    \x02\x18\x05\x12\x04\xc8\x05\x11\x17\n\r\n\x05\x047\x02\x18\x01\x12\x04\
    \xc8\x05\x18\x20\n\r\n\x05\x047\x02\x18\x03\x12\x04\xc8\x05#%\n\x0c\n\
    \x02\x048\x12\x06\xcb\x05\0\xcc\x05\x01\n\x0b\n\x03\x048\x01\x12\x04\xcb\
    \x05\x08\"\n\x0c\n\x02\x049\x12\x06\xce\x05\0\xf4\x05\x01\n\x0b\n\x03\
    \x049\x01\x12\x04\xce\x05\x08\x1c\n\x0c\n\x04\x049\x02\0\x12\x04\xcf\x05\
    \x08'\n\r\n\x05\x049\x02\0\x04\x12\x04\xcf\x05\x08\x10\n\r\n\x05\x049\
    \x02\0\x05\x12\x04\xcf\x05\x11\x17\n\r\n\x05\x049\x02\0\x01\x12\x04\xcf\
    \x05\x18\"\n\r\n\x05\x049\x02\0\x03\x12\x04\xcf\x05%&\n\x0c\n\x04\x049\
    \x02\x01\x12\x04\xd0\x05\x08\"\n\r\n\x05\x049\x02\x01\x04\x12\x04\xd0\
    \x05\x08\x10\n\r\n\x05\x049\x02\x01\x05\x12\x04\xd0\x05\x11\x17\n\r\n\
    \x05\x049\x02\x01\x01\x12\x04\xd0\x05\x18\x1d\n\r\n\x05\x049\x02\x01\x03\
    \x12\x04\xd0\x05\x20!\n\x0c\n\x04\x049\x02\x02\x12\x04\xd1\x05\x08#\n\r\
    \n\x05\x049\x02\x02\x04\x12\x04\xd1\x05\x08\x10\n\r\n\x05\x049\x02\x02\
    \x05\x12\x04\xd1\x05\x11\x17\n\r\n\x05\x049\x02\x02\x01\x12\x04\xd1\x05\
    \x18\x1e\n\r\n\x05\x049\x02\x02\x03\x12\x04\xd1\x05!\"\n\x0c\n\x04\x049\
    \x02\x03\x12\x04\xd2\x05\x084\n\r\n\x05\x049\x02\x03\x04\x12\x04\xd2\x05\
    \x08\x10\n\r\n\x05\x049\x02\x03\x05\x12\x04\xd2\x05\x11\x15\n\r\n\x05\
    \x049\x02\x03\x01\x12\x04\xd2\x05\x16/\n\r\n\x05\x049\x02\x03\x03\x12\
    \x04\xd2\x0523\n\x0c\n\x04\x049\x02\x04\x12\x04\xd3\x05\x08\"\n\r\n\x05\
    \x049\x02\x04\x04\x12\x04\xd3\x05\x08\x10\n\r\n\x05\x049\x02\x04\x05\x12\
    \x04\xd3\x05\x11\x16\n\r\n\x05\x049\x02\x04\x01\x12\x04\xd3\x05\x17\x1d\
    \n\r\n\x05\x049\x02\x04\x03\x12\x04\xd3\x05\x20!\n\x0c\n\x04\x049\x02\
    \x05\x12\x04\xd4\x05\x087\n\r\n\x05\x049\x02\x05\x04\x12\x04\xd4\x05\x08\
    \x10\n\r\n\x05\x049\x02\x05\x06\x12\x04\xd4\x05\x11#\n\r\n\x05\x049\x02\
    \x05\x01\x12\x04\xd4\x05$2\n\r\n\x05\x049\x02\x05\x03\x12\x04\xd4\x0556\
    \n\x0c\n\x04\x049\x02\x06\x12\x04\xd5\x05\x08=\n\r\n\x05\x049\x02\x06\
    \x04\x12\x04\xd5\x05\x08\x10\n\r\n\x05\x049\x02\x06\x06\x12\x04\xd5\x05\
    \x11'\n\r\n\x05\x049\x02\x06\x01\x12\x04\xd5\x05(8\n\r\n\x05\x049\x02\
    \x06\x03\x12\x04\xd5\x05;<\n\x0c\n\x04\x049\x02\x07\x12\x04\xd6\x05\x08=\
    \n\r\n\x05\x049\x02\x07\x04\x12\x04\xd6\x05\x08\x10\n\r\n\x05\x049\x02\
    \x07\x06\x12\x04\xd6\x05\x11'\n\r\n\x05\x049\x02\x07\x01\x12\x04\xd6\x05\
    (8\n\r\n\x05\x049\x02\x07\x03\x12\x04\xd6\x05;<\n\x0c\n\x04\x049\x02\x08\
    \x12\x04\xd7\x05\x08H\n\r\n\x05\x049\x02\x08\x04\x12\x04\xd7\x05\x08\x10\
    \n\r\n\x05\x049\x02\x08\x06\x12\x04\xd7\x05\x11,\n\r\n\x05\x049\x02\x08\
    \x01\x12\x04\xd7\x05-B\n\r\n\x05\x049\x02\x08\x03\x12\x04\xd7\x05EG\n\
    \x0c\n\x04\x049\x02\t\x12\x04\xd8\x05\x08U\n\r\n\x05\x049\x02\t\x04\x12\
    \x04\xd8\x05\x08\x10\n\r\n\x05\x049\x02\t\x06\x12\x04\xd8\x05\x112\n\r\n\
    \x05\x049\x02\t\x01\x12\x04\xd8\x053O\n\r\n\x05\x049\x02\t\x03\x12\x04\
    \xd8\x05RT\n\x0c\n\x04\x049\x02\n\x12\x04\xd9\x05\x08+\n\r\n\x05\x049\
    \x02\n\x04\x12\x04\xd9\x05\x08\x10\n\r\n\x05\x049\x02\n\x06\x12\x04\xd9\
    \x05\x11\x1d\n\r\n\x05\x049\x02\n\x01\x12\x04\xd9\x05\x1e%\n\r\n\x05\x04\
    9\x02\n\x03\x12\x04\xd9\x05(*\n\x0c\n\x04\x049\x02\x0b\x12\x04\xda\x05\
    \x08,\n\r\n\x05\x049\x02\x0b\x04\x12\x04\xda\x05\x08\x10\n\r\n\x05\x049\
    \x02\x0b\x06\x12\x04\xda\x05\x11\x1b\n\r\n\x05\x049\x02\x0b\x01\x12\x04\
    \xda\x05\x1c&\n\r\n\x05\x049\x02\x0b\x03\x12\x04\xda\x05)+\n\x0c\n\x04\
    \x049\x02\x0c\x12\x04\xdb\x05\x08.\n\r\n\x05\x049\x02\x0c\x04\x12\x04\
    \xdb\x05\x08\x10\n\r\n\x05\x049\x02\x0c\x06\x12\x04\xdb\x05\x11\x1e\n\r\
    \n\x05\x049\x02\x0c\x01\x12\x04\xdb\x05\x1f(\n\r\n\x05\x049\x02\x0c\x03\
    \x12\x04\xdb\x05+-\n\x0c\n\x04\x049\x02\r\x12\x04\xdc\x05\x081\n\r\n\x05\
    \x049\x02\r\x04\x12\x04\xdc\x05\x08\x10\n\r\n\x05\x049\x02\r\x06\x12\x04\
    \xdc\x05\x11\x20\n\r\n\x05\x049\x02\r\x01\x12\x04\xdc\x05!+\n\r\n\x05\
    \x049\x02\r\x03\x12\x04\xdc\x05.0\n\x0c\n\x04\x049\x02\x0e\x12\x04\xdd\
    \x05\x081\n\r\n\x05\x049\x02\x0e\x04\x12\x04\xdd\x05\x08\x10\n\r\n\x05\
    \x049\x02\x0e\x06\x12\x04\xdd\x05\x11\x20\n\r\n\x05\x049\x02\x0e\x01\x12\
    \x04\xdd\x05!+\n\r\n\x05\x049\x02\x0e\x03\x12\x04\xdd\x05.0\n\x0c\n\x04\
    \x049\x02\x0f\x12\x04\xde\x05\x08-\n\r\n\x05\x049\x02\x0f\x04\x12\x04\
    \xde\x05\x08\x10\n\r\n\x05\x049\x02\x0f\x06\x12\x04\xde\x05\x11\x1e\n\r\
    \n\x05\x049\x02\x0f\x01\x12\x04\xde\x05\x1f'\n\r\n\x05\x049\x02\x0f\x03\
    \x12\x04\xde\x05*,\n\x0c\n\x04\x049\x02\x10\x12\x04\xdf\x05\x084\n\r\n\
    \x05\x049\x02\x10\x04\x12\x04\xdf\x05\x08\x10\n\r\n\x05\x049\x02\x10\x06\
    \x12\x04\xdf\x05\x11!\n\r\n\x05\x049\x02\x10\x01\x12\x04\xdf\x05\".\n\r\
    \n\x05\x049\x02\x10\x03\x12\x04\xdf\x0513\n\x0c\n\x04\x049\x02\x11\x12\
    \x04\xe0\x05\x086\n\r\n\x05\x049\x02\x11\x04\x12\x04\xe0\x05\x08\x10\n\r\
    \n\x05\x049\x02\x11\x06\x12\x04\xe0\x05\x11\"\n\r\n\x05\x049\x02\x11\x01\
    \x12\x04\xe0\x05#0\n\r\n\x05\x049\x02\x11\x03\x12\x04\xe0\x0535\n\x0c\n\
    \x04\x049\x02\x12\x12\x04\xe1\x05\x086\n\r\n\x05\x049\x02\x12\x04\x12\
    \x04\xe1\x05\x08\x10\n\r\n\x05\x049\x02\x12\x06\x12\x04\xe1\x05\x11\"\n\
    \r\n\x05\x049\x02\x12\x01\x12\x04\xe1\x05#0\n\r\n\x05\x049\x02\x12\x03\
    \x12\x04\xe1\x0535\n\x0c\n\x04\x049\x02\x13\x12\x04\xe2\x05\x08)\n\r\n\
    \x05\x049\x02\x13\x04\x12\x04\xe2\x05\x08\x10\n\r\n\x05\x049\x02\x13\x06\
    \x12\x04\xe2\x05\x11\x1c\n\r\n\x05\x049\x02\x13\x01\x12\x04\xe2\x05\x1d#\
    \n\r\n\x05\x049\x02\x13\x03\x12\x04\xe2\x05&(\n\x0c\n\x04\x049\x02\x14\
    \x12\x04\xe3\x05\x080\n\r\n\x05\x049\x02\x14\x04\x12\x04\xe3\x05\x08\x10\
    \n\r\n\x05\x049\x02\x14\x06\x12\x04\xe3\x05\x11\x1f\n\r\n\x05\x049\x02\
    \x14\x01\x12\x04\xe3\x05\x20*\n\r\n\x05\x049\x02\x14\x03\x12\x04\xe3\x05\
    -/\n\x0c\n\x04\x049\x02\x15\x12\x04\xe4\x05\x08A\n\r\n\x05\x049\x02\x15\
    \x04\x12\x04\xe4\x05\x08\x10\n\r\n\x05\x049\x02\x15\x06\x12\x04\xe4\x05\
    \x11)\n\r\n\x05\x049\x02\x15\x01\x12\x04\xe4\x05*;\n\r\n\x05\x049\x02\
    \x15\x03\x12\x04\xe4\x05>@\n\x0c\n\x04\x049\x02\x16\x12\x04\xe5\x05\x087\
    \n\r\n\x05\x049\x02\x16\x04\x12\x04\xe5\x05\x08\x10\n\r\n\x05\x049\x02\
    \x16\x06\x12\x04\xe5\x05\x11\x1e\n\r\n\x05\x049\x02\x16\x01\x12\x04\xe5\
    \x05\x1f1\n\r\n\x05\x049\x02\x16\x03\x12\x04\xe5\x0546\n\x0c\n\x04\x049\
    \x02\x17\x12\x04\xe6\x05\x082\n\r\n\x05\x049\x02\x17\x04\x12\x04\xe6\x05\
    \x08\x10\n\r\n\x05\x049\x02\x17\x06\x12\x04\xe6\x05\x11\x20\n\r\n\x05\
    \x049\x02\x17\x01\x12\x04\xe6\x05!,\n\r\n\x05\x049\x02\x17\x03\x12\x04\
    \xe6\x05/1\n\x0c\n\x04\x049\x02\x18\x12\x04\xe7\x05\x08%\n\r\n\x05\x049\
    \x02\x18\x04\x12\x04\xe7\x05\x08\x10\n\r\n\x05\x049\x02\x18\x06\x12\x04\
    \xe7\x05\x11\x1a\n\r\n\x05\x049\x02\x18\x01\x12\x04\xe7\x05\x1b\x1f\n\r\
    \n\x05\x049\x02\x18\x03\x12\x04\xe7\x05\"$\n\x0c\n\x04\x049\x02\x19\x12\
    \x04\xe8\x05\x083\n\r\n\x05\x049\x02\x19\x04\x12\x04\xe8\x05\x08\x10\n\r\
    \n\x05\x049\x02\x19\x05\x12\x04\xe8\x05\x11\x15\n\r\n\x05\x049\x02\x19\
    \x01\x12\x04\xe8\x05\x16-\n\r\n\x05\x049\x02\x19\x03\x12\x04\xe8\x0502\n\
    \x0c\n\x04\x049\x02\x1a\x12\x04\xe9\x05\x08/\n\r\n\x05\x049\x02\x1a\x04\
    \x12\x04\xe9\x05\x08\x10\n\r\n\x05\x049\x02\x1a\x05\x12\x04\xe9\x05\x11\
    \x16\n\r\n\x05\x049\x02\x1a\x01\x12\x04\xe9\x05\x17)\n\r\n\x05\x049\x02\
    \x1a\x03\x12\x04\xe9\x05,.\n\x0c\n\x04\x049\x02\x1b\x12\x04\xea\x05\x086\
    \n\r\n\x05\x049\x02\x1b\x04\x12\x04\xea\x05\x08\x10\n\r\n\x05\x049\x02\
    \x1b\x05\x12\x04\xea\x05\x11\x15\n\r\n\x05\x049\x02\x1b\x01\x12\x04\xea\
    \x05\x160\n\r\n\x05\x049\x02\x1b\x03\x12\x04\xea\x0535\n\x0c\n\x04\x049\
    \x02\x1c\x12\x04\xeb\x05\x080\n\r\n\x05\x049\x02\x1c\x04\x12\x04\xeb\x05\
    \x08\x10\n\r\n\x05\x049\x02\x1c\x05\x12\x04\xeb\x05\x11\x15\n\r\n\x05\
    \x049\x02\x1c\x01\x12\x04\xeb\x05\x16*\n\r\n\x05\x049\x02\x1c\x03\x12\
    \x04\xeb\x05-/\n\x0c\n\x04\x049\x02\x1d\x12\x04\xec\x05\x08*\n\r\n\x05\
    \x049\x02\x1d\x04\x12\x04\xec\x05\x08\x10\n\r\n\x05\x049\x02\x1d\x05\x12\
    \x04\xec\x05\x11\x15\n\r\n\x05\x049\x02\x1d\x01\x12\x04\xec\x05\x16$\n\r\
    \n\x05\x049\x02\x1d\x03\x12\x04\xec\x05')\n\x0c\n\x04\x049\x02\x1e\x12\
    \x04\xed\x05\x083\n\r\n\x05\x049\x02\x1e\x04\x12\x04\xed\x05\x08\x10\n\r\
    \n\x05\x049\x02\x1e\x05\x12\x04\xed\x05\x11\x15\n\r\n\x05\x049\x02\x1e\
    \x01\x12\x04\xed\x05\x16-\n\r\n\x05\x049\x02\x1e\x03\x12\x04\xed\x0502\n\
    \x0c\n\x04\x049\x02\x1f\x12\x04\xee\x05\x08,\n\r\n\x05\x049\x02\x1f\x04\
    \x12\x04\xee\x05\x08\x10\n\r\n\x05\x049\x02\x1f\x05\x12\x04\xee\x05\x11\
    \x17\n\r\n\x05\x049\x02\x1f\x01\x12\x04\xee\x05\x18&\n\r\n\x05\x049\x02\
    \x1f\x03\x12\x04\xee\x05)+\n\x0c\n\x04\x049\x02\x20\x12\x04\xef\x05\x08-\
    \n\r\n\x05\x049\x02\x20\x04\x12\x04\xef\x05\x08\x10\n\r\n\x05\x049\x02\
    \x20\x05\x12\x04\xef\x05\x11\x15\n\r\n\x05\x049\x02\x20\x01\x12\x04\xef\
    \x05\x16'\n\r\n\x05\x049\x02\x20\x03\x12\x04\xef\x05*,\n\x0c\n\x04\x049\
    \x02!\x12\x04\xf0\x05\x08/\n\r\n\x05\x049\x02!\x04\x12\x04\xf0\x05\x08\
    \x10\n\r\n\x05\x049\x02!\x05\x12\x04\xf0\x05\x11\x17\n\r\n\x05\x049\x02!\
    \x01\x12\x04\xf0\x05\x18)\n\r\n\x05\x049\x02!\x03\x12\x04\xf0\x05,.\n\
    \x0c\n\x04\x049\x02\"\x12\x04\xf1\x05\x089\n\r\n\x05\x049\x02\"\x04\x12\
    \x04\xf1\x05\x08\x10\n\r\n\x05\x049\x02\"\x05\x12\x04\xf1\x05\x11\x15\n\
    \r\n\x05\x049\x02\"\x01\x12\x04\xf1\x05\x163\n\r\n\x05\x049\x02\"\x03\
    \x12\x04\xf1\x0568\n\x0c\n\x04\x049\x02#\x12\x04\xf2\x05\x082\n\r\n\x05\
    \x049\x02#\x04\x12\x04\xf2\x05\x08\x10\n\r\n\x05\x049\x02#\x06\x12\x04\
    \xf2\x05\x11\x20\n\r\n\x05\x049\x02#\x01\x12\x04\xf2\x05!,\n\r\n\x05\x04\
    9\x02#\x03\x12\x04\xf2\x05/1\n\x0c\n\x04\x049\x02$\x12\x04\xf3\x05\x08<\
    \n\r\n\x05\x049\x02$\x04\x12\x04\xf3\x05\x08\x10\n\r\n\x05\x049\x02$\x05\
    \x12\x04\xf3\x05\x11\x17\n\r\n\x05\x049\x02$\x01\x12\x04\xf3\x05\x186\n\
    \r\n\x05\x049\x02$\x03\x12\x04\xf3\x059;\n\x0c\n\x02\x04:\x12\x06\xf6\
    \x05\0\xf8\x05\x01\n\x0b\n\x03\x04:\x01\x12\x04\xf6\x05\x08\x1b\n\x0c\n\
    \x04\x04:\x02\0\x12\x04\xf7\x05\x08'\n\r\n\x05\x04:\x02\0\x04\x12\x04\
    \xf7\x05\x08\x10\n\r\n\x05\x04:\x02\0\x05\x12\x04\xf7\x05\x11\x17\n\r\n\
    \x05\x04:\x02\0\x01\x12\x04\xf7\x05\x18\"\n\r\n\x05\x04:\x02\0\x03\x12\
    \x04\xf7\x05%&\n\x0c\n\x02\x04;\x12\x06\xfa\x05\0\xfb\x05\x01\n\x0b\n\
    \x03\x04;\x01\x12\x04\xfa\x05\x08\x20\n\x0c\n\x02\x04<\x12\x06\xfd\x05\0\
    \xfe\x05\x01\n\x0b\n\x03\x04<\x01\x12\x04\xfd\x05\x08\x1e\n\x0c\n\x02\
    \x04=\x12\x06\x80\x06\0\x81\x06\x01\n\x0b\n\x03\x04=\x01\x12\x04\x80\x06\
    \x08\x1a\n\x0c\n\x02\x04>\x12\x06\x83\x06\0\x84\x06\x01\n\x0b\n\x03\x04>\
    \x01\x12\x04\x83\x06\x08\x18\n\x0c\n\x02\x04?\x12\x06\x86\x06\0\x8b\x06\
    \x01\n\x0b\n\x03\x04?\x01\x12\x04\x86\x06\x08\x1a\n\x0c\n\x04\x04?\x02\0\
    \x12\x04\x87\x06\x08)\n\r\n\x05\x04?\x02\0\x04\x12\x04\x87\x06\x08\x10\n\
    \r\n\x05\x04?\x02\0\x06\x12\x04\x87\x06\x11\x1b\n\r\n\x05\x04?\x02\0\x01\
    \x12\x04\x87\x06\x1c$\n\r\n\x05\x04?\x02\0\x03\x12\x04\x87\x06'(\n\x0c\n\
    \x04\x04?\x02\x01\x12\x04\x88\x06\x08-\n\r\n\x05\x04?\x02\x01\x04\x12\
    \x04\x88\x06\x08\x10\n\r\n\x05\x04?\x02\x01\x06\x12\x04\x88\x06\x11\x1b\
    \n\r\n\x05\x04?\x02\x01\x01\x12\x04\x88\x06\x1c(\n\r\n\x05\x04?\x02\x01\
    \x03\x12\x04\x88\x06+,\n\x0c\n\x04\x04?\x02\x02\x12\x04\x89\x06\x08D\n\r\
    \n\x05\x04?\x02\x02\x04\x12\x04\x89\x06\x08\x10\n\r\n\x05\x04?\x02\x02\
    \x06\x12\x04\x89\x06\x11)\n\r\n\x05\x04?\x02\x02\x01\x12\x04\x89\x06*?\n\
    \r\n\x05\x04?\x02\x02\x03\x12\x04\x89\x06BC\n\x0c\n\x04\x04?\x02\x03\x12\
    \x04\x8a\x06\x08)\n\r\n\x05\x04?\x02\x03\x04\x12\x04\x8a\x06\x08\x10\n\r\
    \n\x05\x04?\x02\x03\x05\x12\x04\x8a\x06\x11\x17\n\r\n\x05\x04?\x02\x03\
    \x01\x12\x04\x8a\x06\x18$\n\r\n\x05\x04?\x02\x03\x03\x12\x04\x8a\x06'(\n\
    \x0c\n\x02\x04@\x12\x06\x8d\x06\0\x92\x06\x01\n\x0b\n\x03\x04@\x01\x12\
    \x04\x8d\x06\x08\x1c\n\x0c\n\x04\x04@\x02\0\x12\x04\x8e\x06\x08)\n\r\n\
    \x05\x04@\x02\0\x04\x12\x04\x8e\x06\x08\x10\n\r\n\x05\x04@\x02\0\x06\x12\
    \x04\x8e\x06\x11\x1b\n\r\n\x05\x04@\x02\0\x01\x12\x04\x8e\x06\x1c$\n\r\n\
    \x05\x04@\x02\0\x03\x12\x04\x8e\x06'(\n\x0c\n\x04\x04@\x02\x01\x12\x04\
    \x8f\x06\x08-\n\r\n\x05\x04@\x02\x01\x04\x12\x04\x8f\x06\x08\x10\n\r\n\
    \x05\x04@\x02\x01\x06\x12\x04\x8f\x06\x11\x1b\n\r\n\x05\x04@\x02\x01\x01\
    \x12\x04\x8f\x06\x1c(\n\r\n\x05\x04@\x02\x01\x03\x12\x04\x8f\x06+,\n\x0c\
    \n\x04\x04@\x02\x02\x12\x04\x90\x06\x08J\n\r\n\x05\x04@\x02\x02\x04\x12\
    \x04\x90\x06\x08\x10\n\r\n\x05\x04@\x02\x02\x06\x12\x04\x90\x06\x11/\n\r\
    \n\x05\x04@\x02\x02\x01\x12\x04\x90\x060E\n\r\n\x05\x04@\x02\x02\x03\x12\
    \x04\x90\x06HI\n\x0c\n\x04\x04@\x02\x03\x12\x04\x91\x06\x08)\n\r\n\x05\
    \x04@\x02\x03\x04\x12\x04\x91\x06\x08\x10\n\r\n\x05\x04@\x02\x03\x05\x12\
    \x04\x91\x06\x11\x17\n\r\n\x05\x04@\x02\x03\x01\x12\x04\x91\x06\x18$\n\r\
    \n\x05\x04@\x02\x03\x03\x12\x04\x91\x06'(\n\x0c\n\x02\x04A\x12\x06\x94\
    \x06\0\x9d\x06\x01\n\x0b\n\x03\x04A\x01\x12\x04\x94\x06\x08\x1c\n\x0c\n\
    \x04\x04A\x02\0\x12\x04\x95\x06\x08)\n\r\n\x05\x04A\x02\0\x04\x12\x04\
    \x95\x06\x08\x10\n\r\n\x05\x04A\x02\0\x06\x12\x04\x95\x06\x11\x1b\n\r\n\
    \x05\x04A\x02\0\x01\x12\x04\x95\x06\x1c$\n\r\n\x05\x04A\x02\0\x03\x12\
    \x04\x95\x06'(\n\x0c\n\x04\x04A\x02\x01\x12\x04\x96\x06\x08-\n\r\n\x05\
    \x04A\x02\x01\x04\x12\x04\x96\x06\x08\x10\n\r\n\x05\x04A\x02\x01\x06\x12\
    \x04\x96\x06\x11\x1b\n\r\n\x05\x04A\x02\x01\x01\x12\x04\x96\x06\x1c(\n\r\
    \n\x05\x04A\x02\x01\x03\x12\x04\x96\x06+,\n\x0c\n\x04\x04A\x02\x02\x12\
    \x04\x97\x06\x08'\n\r\n\x05\x04A\x02\x02\x04\x12\x04\x97\x06\x08\x10\n\r\
    \n\x05\x04A\x02\x02\x05\x12\x04\x97\x06\x11\x17\n\r\n\x05\x04A\x02\x02\
    \x01\x12\x04\x97\x06\x18\"\n\r\n\x05\x04A\x02\x02\x03\x12\x04\x97\x06%&\
    \n\x0c\n\x04\x04A\x02\x03\x12\x04\x98\x06\x081\n\r\n\x05\x04A\x02\x03\
    \x04\x12\x04\x98\x06\x08\x10\n\r\n\x05\x04A\x02\x03\x06\x12\x04\x98\x06\
    \x11\x1b\n\r\n\x05\x04A\x02\x03\x01\x12\x04\x98\x06\x1c,\n\r\n\x05\x04A\
    \x02\x03\x03\x12\x04\x98\x06/0\n\x0c\n\x04\x04A\x02\x04\x12\x04\x99\x06\
    \x085\n\r\n\x05\x04A\x02\x04\x04\x12\x04\x99\x06\x08\x10\n\r\n\x05\x04A\
    \x02\x04\x06\x12\x04\x99\x06\x11\x1b\n\r\n\x05\x04A\x02\x04\x01\x12\x04\
    \x99\x06\x1c0\n\r\n\x05\x04A\x02\x04\x03\x12\x04\x99\x0634\n\x0c\n\x04\
    \x04A\x02\x05\x12\x04\x9a\x06\x088\n\r\n\x05\x04A\x02\x05\x04\x12\x04\
    \x9a\x06\x08\x10\n\r\n\x05\x04A\x02\x05\x05\x12\x04\x9a\x06\x11\x16\n\r\
    \n\x05\x04A\x02\x05\x01\x12\x04\x9a\x06\x17%\n\r\n\x05\x04A\x02\x05\x03\
    \x12\x04\x9a\x06()\n\r\n\x05\x04A\x02\x05\x08\x12\x04\x9a\x06*7\n\r\n\
    \x05\x04A\x02\x05\x07\x12\x04\x9a\x0656\n\x0c\n\x04\x04A\x02\x06\x12\x04\
    \x9b\x06\x08>\n\r\n\x05\x04A\x02\x06\x04\x12\x04\x9b\x06\x08\x10\n\r\n\
    \x05\x04A\x02\x06\x05\x12\x04\x9b\x06\x11\x17\n\r\n\x05\x04A\x02\x06\x01\
    \x12\x04\x9b\x06\x18+\n\r\n\x05\x04A\x02\x06\x03\x12\x04\x9b\x06./\n\r\n\
    \x05\x04A\x02\x06\x08\x12\x04\x9b\x060=\n\r\n\x05\x04A\x02\x06\x07\x12\
    \x04\x9b\x06;<\n\x0c\n\x04\x04A\x02\x07\x12\x04\x9c\x06\x082\n\r\n\x05\
    \x04A\x02\x07\x04\x12\x04\x9c\x06\x08\x10\n\r\n\x05\x04A\x02\x07\x06\x12\
    \x04\x9c\x06\x11\x1d\n\r\n\x05\x04A\x02\x07\x01\x12\x04\x9c\x06\x1e-\n\r\
    \n\x05\x04A\x02\x07\x03\x12\x04\x9c\x0601\n\x0c\n\x02\x04B\x12\x06\x9f\
    \x06\0\xa8\x06\x01\n\x0b\n\x03\x04B\x01\x12\x04\x9f\x06\x08\x1e\n\x0c\n\
    \x04\x04B\x02\0\x12\x04\xa0\x06\x08)\n\r\n\x05\x04B\x02\0\x04\x12\x04\
    \xa0\x06\x08\x10\n\r\n\x05\x04B\x02\0\x06\x12\x04\xa0\x06\x11\x1b\n\r\n\
    \x05\x04B\x02\0\x01\x12\x04\xa0\x06\x1c$\n\r\n\x05\x04B\x02\0\x03\x12\
    \x04\xa0\x06'(\n\x0c\n\x04\x04B\x02\x01\x12\x04\xa1\x06\x08-\n\r\n\x05\
    \x04B\x02\x01\x04\x12\x04\xa1\x06\x08\x10\n\r\n\x05\x04B\x02\x01\x06\x12\
    \x04\xa1\x06\x11\x1b\n\r\n\x05\x04B\x02\x01\x01\x12\x04\xa1\x06\x1c(\n\r\
    \n\x05\x04B\x02\x01\x03\x12\x04\xa1\x06+,\n\x0c\n\x04\x04B\x02\x02\x12\
    \x04\xa2\x06\x08'\n\r\n\x05\x04B\x02\x02\x04\x12\x04\xa2\x06\x08\x10\n\r\
    \n\x05\x04B\x02\x02\x05\x12\x04\xa2\x06\x11\x17\n\r\n\x05\x04B\x02\x02\
    \x01\x12\x04\xa2\x06\x18\"\n\r\n\x05\x04B\x02\x02\x03\x12\x04\xa2\x06%&\
    \n\x0c\n\x04\x04B\x02\x03\x12\x04\xa3\x06\x081\n\r\n\x05\x04B\x02\x03\
    \x04\x12\x04\xa3\x06\x08\x10\n\r\n\x05\x04B\x02\x03\x06\x12\x04\xa3\x06\
    \x11\x1b\n\r\n\x05\x04B\x02\x03\x01\x12\x04\xa3\x06\x1c,\n\r\n\x05\x04B\
    \x02\x03\x03\x12\x04\xa3\x06/0\n\x0c\n\x04\x04B\x02\x04\x12\x04\xa4\x06\
    \x085\n\r\n\x05\x04B\x02\x04\x04\x12\x04\xa4\x06\x08\x10\n\r\n\x05\x04B\
    \x02\x04\x06\x12\x04\xa4\x06\x11\x1b\n\r\n\x05\x04B\x02\x04\x01\x12\x04\
    \xa4\x06\x1c0\n\r\n\x05\x04B\x02\x04\x03\x12\x04\xa4\x0634\n\x0c\n\x04\
    \x04B\x02\x05\x12\x04\xa5\x06\x088\n\r\n\x05\x04B\x02\x05\x04\x12\x04\
    \xa5\x06\x08\x10\n\r\n\x05\x04B\x02\x05\x05\x12\x04\xa5\x06\x11\x16\n\r\
    \n\x05\x04B\x02\x05\x01\x12\x04\xa5\x06\x17%\n\r\n\x05\x04B\x02\x05\x03\
    \x12\x04\xa5\x06()\n\r\n\x05\x04B\x02\x05\x08\x12\x04\xa5\x06*7\n\r\n\
    \x05\x04B\x02\x05\x07\x12\x04\xa5\x0656\n\x0c\n\x04\x04B\x02\x06\x12\x04\
    \xa6\x06\x08>\n\r\n\x05\x04B\x02\x06\x04\x12\x04\xa6\x06\x08\x10\n\r\n\
    \x05\x04B\x02\x06\x05\x12\x04\xa6\x06\x11\x17\n\r\n\x05\x04B\x02\x06\x01\
    \x12\x04\xa6\x06\x18+\n\r\n\x05\x04B\x02\x06\x03\x12\x04\xa6\x06./\n\r\n\
    \x05\x04B\x02\x06\x08\x12\x04\xa6\x060=\n\r\n\x05\x04B\x02\x06\x07\x12\
    \x04\xa6\x06;<\n\x0c\n\x04\x04B\x02\x07\x12\x04\xa7\x06\x089\n\r\n\x05\
    \x04B\x02\x07\x04\x12\x04\xa7\x06\x08\x10\n\r\n\x05\x04B\x02\x07\x05\x12\
    \x04\xa7\x06\x11\x16\n\r\n\x05\x04B\x02\x07\x01\x12\x04\xa7\x06\x17&\n\r\
    \n\x05\x04B\x02\x07\x03\x12\x04\xa7\x06)*\n\r\n\x05\x04B\x02\x07\x08\x12\
    \x04\xa7\x06+8\n\r\n\x05\x04B\x02\x07\x07\x12\x04\xa7\x0667\n\x0c\n\x02\
    \x04C\x12\x06\xaa\x06\0\xad\x06\x01\n\x0b\n\x03\x04C\x01\x12\x04\xaa\x06\
    \x08\x17\n\x0c\n\x04\x04C\x02\0\x12\x04\xab\x06\x08'\n\r\n\x05\x04C\x02\
    \0\x04\x12\x04\xab\x06\x08\x10\n\r\n\x05\x04C\x02\0\x05\x12\x04\xab\x06\
    \x11\x17\n\r\n\x05\x04C\x02\0\x01\x12\x04\xab\x06\x18\"\n\r\n\x05\x04C\
    \x02\0\x03\x12\x04\xab\x06%&\n\x0c\n\x04\x04C\x02\x01\x12\x04\xac\x06\
    \x088\n\r\n\x05\x04C\x02\x01\x04\x12\x04\xac\x06\x08\x10\n\r\n\x05\x04C\
    \x02\x01\x05\x12\x04\xac\x06\x11\x16\n\r\n\x05\x04C\x02\x01\x01\x12\x04\
    \xac\x06\x17%\n\r\n\x05\x04C\x02\x01\x03\x12\x04\xac\x06()\n\r\n\x05\x04\
    C\x02\x01\x08\x12\x04\xac\x06*7\n\r\n\x05\x04C\x02\x01\x07\x12\x04\xac\
    \x0656\n\x0c\n\x02\x04D\x12\x06\xaf\x06\0\xb2\x06\x01\n\x0b\n\x03\x04D\
    \x01\x12\x04\xaf\x06\x08\x1c\n\x0c\n\x04\x04D\x02\0\x12\x04\xb0\x06\x08!\
    \n\r\n\x05\x04D\x02\0\x04\x12\x04\xb0\x06\x08\x10\n\r\n\x05\x04D\x02\0\
    \x05\x12\x04\xb0\x06\x11\x16\n\r\n\x05\x04D\x02\0\x01\x12\x04\xb0\x06\
    \x17\x1c\n\r\n\x05\x04D\x02\0\x03\x12\x04\xb0\x06\x1f\x20\n\x0c\n\x04\
    \x04D\x02\x01\x12\x04\xb1\x06\x08\"\n\r\n\x05\x04D\x02\x01\x04\x12\x04\
    \xb1\x06\x08\x10\n\r\n\x05\x04D\x02\x01\x05\x12\x04\xb1\x06\x11\x16\n\r\
    \n\x05\x04D\x02\x01\x01\x12\x04\xb1\x06\x17\x1d\n\r\n\x05\x04D\x02\x01\
    \x03\x12\x04\xb1\x06\x20!\n\x0c\n\x02\x04E\x12\x06\xb4\x06\0\xbe\x06\x01\
    \n\x0b\n\x03\x04E\x01\x12\x04\xb4\x06\x08\x16\n\x0c\n\x04\x04E\x02\0\x12\
    \x04\xb5\x06\x08&\n\r\n\x05\x04E\x02\0\x04\x12\x04\xb5\x06\x08\x10\n\r\n\
    \x05\x04E\x02\0\x05\x12\x04\xb5\x06\x11\x17\n\r\n\x05\x04E\x02\0\x01\x12\
    \x04\xb5\x06\x18!\n\r\n\x05\x04E\x02\0\x03\x12\x04\xb5\x06$%\n\x0c\n\x04\
    \x04E\x02\x01\x12\x04\xb6\x06\x08&\n\r\n\x05\x04E\x02\x01\x04\x12\x04\
    \xb6\x06\x08\x10\n\r\n\x05\x04E\x02\x01\x05\x12\x04\xb6\x06\x11\x17\n\r\
    \n\x05\x04E\x02\x01\x01\x12\x04\xb6\x06\x18!\n\r\n\x05\x04E\x02\x01\x03\
    \x12\x04\xb6\x06$%\n\x0c\n\x04\x04E\x02\x02\x12\x04\xb7\x06\x086\n\r\n\
    \x05\x04E\x02\x02\x04\x12\x04\xb7\x06\x08\x10\n\r\n\x05\x04E\x02\x02\x05\
    \x12\x04\xb7\x06\x11\x16\n\r\n\x05\x04E\x02\x02\x01\x12\x04\xb7\x06\x17\
    \"\n\r\n\x05\x04E\x02\x02\x03\x12\x04\xb7\x06%&\n\r\n\x05\x04E\x02\x02\
    \x08\x12\x04\xb7\x06'5\n\r\n\x05\x04E\x02\x02\x07\x12\x04\xb7\x0624\n\
    \x0c\n\x04\x04E\x02\x03\x12\x04\xb8\x06\x085\n\r\n\x05\x04E\x02\x03\x04\
    \x12\x04\xb8\x06\x08\x10\n\r\n\x05\x04E\x02\x03\x05\x12\x04\xb8\x06\x11\
    \x16\n\r\n\x05\x04E\x02\x03\x01\x12\x04\xb8\x06\x17!\n\r\n\x05\x04E\x02\
    \x03\x03\x12\x04\xb8\x06$%\n\r\n\x05\x04E\x02\x03\x08\x12\x04\xb8\x06&4\
    \n\r\n\x05\x04E\x02\x03\x07\x12\x04\xb8\x0613\n\x0c\n\x04\x04E\x02\x04\
    \x12\x04\xb9\x06\x08$\n\r\n\x05\x04E\x02\x04\x04\x12\x04\xb9\x06\x08\x10\
    \n\r\n\x05\x04E\x02\x04\x05\x12\x04\xb9\x06\x11\x15\n\r\n\x05\x04E\x02\
    \x04\x01\x12\x04\xb9\x06\x16\x1f\n\r\n\x05\x04E\x02\x04\x03\x12\x04\xb9\
    \x06\"#\n\x0c\n\x04\x04E\x02\x05\x12\x04\xba\x06\x08(\n\r\n\x05\x04E\x02\
    \x05\x04\x12\x04\xba\x06\x08\x10\n\r\n\x05\x04E\x02\x05\x05\x12\x04\xba\
    \x06\x11\x15\n\r\n\x05\x04E\x02\x05\x01\x12\x04\xba\x06\x16#\n\r\n\x05\
    \x04E\x02\x05\x03\x12\x04\xba\x06&'\n\x0c\n\x04\x04E\x02\x06\x12\x04\xbb\
    \x06\x08D\n\r\n\x05\x04E\x02\x06\x04\x12\x04\xbb\x06\x08\x10\n\r\n\x05\
    \x04E\x02\x06\x06\x12\x04\xbb\x06\x11)\n\r\n\x05\x04E\x02\x06\x01\x12\
    \x04\xbb\x06*?\n\r\n\x05\x04E\x02\x06\x03\x12\x04\xbb\x06BC\n\x0c\n\x04\
    \x04E\x02\x07\x12\x04\xbc\x06\x088\n\r\n\x05\x04E\x02\x07\x04\x12\x04\
    \xbc\x06\x08\x10\n\r\n\x05\x04E\x02\x07\x05\x12\x04\xbc\x06\x11\x16\n\r\
    \n\x05\x04E\x02\x07\x01\x12\x04\xbc\x06\x17%\n\r\n\x05\x04E\x02\x07\x03\
    \x12\x04\xbc\x06()\n\r\n\x05\x04E\x02\x07\x08\x12\x04\xbc\x06*7\n\r\n\
    \x05\x04E\x02\x07\x07\x12\x04\xbc\x0656\n\x0c\n\x04\x04E\x02\x08\x12\x04\
    \xbd\x06\x089\n\r\n\x05\x04E\x02\x08\x04\x12\x04\xbd\x06\x08\x10\n\r\n\
    \x05\x04E\x02\x08\x06\x12\x04\xbd\x06\x11&\n\r\n\x05\x04E\x02\x08\x01\
    \x12\x04\xbd\x06'4\n\r\n\x05\x04E\x02\x08\x03\x12\x04\xbd\x0678\n\x0c\n\
    \x02\x04F\x12\x06\xc0\x06\0\xc4\x06\x01\n\x0b\n\x03\x04F\x01\x12\x04\xc0\
    \x06\x08\x1b\n\x0c\n\x04\x04F\x02\0\x12\x04\xc1\x06\x08(\n\r\n\x05\x04F\
    \x02\0\x04\x12\x04\xc1\x06\x08\x10\n\r\n\x05\x04F\x02\0\x05\x12\x04\xc1\
    \x06\x11\x17\n\r\n\x05\x04F\x02\0\x01\x12\x04\xc1\x06\x18#\n\r\n\x05\x04\
    F\x02\0\x03\x12\x04\xc1\x06&'\n\x0c\n\x04\x04F\x02\x01\x12\x04\xc2\x06\
    \x08&\n\r\n\x05\x04F\x02\x01\x04\x12\x04\xc2\x06\x08\x10\n\r\n\x05\x04F\
    \x02\x01\x05\x12\x04\xc2\x06\x11\x17\n\r\n\x05\x04F\x02\x01\x01\x12\x04\
    \xc2\x06\x18!\n\r\n\x05\x04F\x02\x01\x03\x12\x04\xc2\x06$%\n\x0c\n\x04\
    \x04F\x02\x02\x12\x04\xc3\x06\x08,\n\r\n\x05\x04F\x02\x02\x04\x12\x04\
    \xc3\x06\x08\x10\n\r\n\x05\x04F\x02\x02\x06\x12\x04\xc3\x06\x11\x20\n\r\
    \n\x05\x04F\x02\x02\x01\x12\x04\xc3\x06!'\n\r\n\x05\x04F\x02\x02\x03\x12\
    \x04\xc3\x06*+\n\x0c\n\x02\x04G\x12\x06\xc6\x06\0\xd0\x06\x01\n\x0b\n\
    \x03\x04G\x01\x12\x04\xc6\x06\x08\x1c\n\x0c\n\x04\x04G\x02\0\x12\x04\xc7\
    \x06\x08&\n\r\n\x05\x04G\x02\0\x04\x12\x04\xc7\x06\x08\x10\n\r\n\x05\x04\
    G\x02\0\x05\x12\x04\xc7\x06\x11\x17\n\r\n\x05\x04G\x02\0\x01\x12\x04\xc7\
    \x06\x18!\n\r\n\x05\x04G\x02\0\x03\x12\x04\xc7\x06$%\n\x0c\n\x04\x04G\
    \x02\x01\x12\x04\xc8\x06\x08&\n\r\n\x05\x04G\x02\x01\x04\x12\x04\xc8\x06\
    \x08\x10\n\r\n\x05\x04G\x02\x01\x05\x12\x04\xc8\x06\x11\x17\n\r\n\x05\
    \x04G\x02\x01\x01\x12\x04\xc8\x06\x18!\n\r\n\x05\x04G\x02\x01\x03\x12\
    \x04\xc8\x06$%\n\x0c\n\x04\x04G\x02\x02\x12\x04\xc9\x06\x086\n\r\n\x05\
    \x04G\x02\x02\x04\x12\x04\xc9\x06\x08\x10\n\r\n\x05\x04G\x02\x02\x05\x12\
    \x04\xc9\x06\x11\x16\n\r\n\x05\x04G\x02\x02\x01\x12\x04\xc9\x06\x17\"\n\
    \r\n\x05\x04G\x02\x02\x03\x12\x04\xc9\x06%&\n\r\n\x05\x04G\x02\x02\x08\
    \x12\x04\xc9\x06'5\n\r\n\x05\x04G\x02\x02\x07\x12\x04\xc9\x0624\n\x0c\n\
    \x04\x04G\x02\x03\x12\x04\xca\x06\x085\n\r\n\x05\x04G\x02\x03\x04\x12\
    \x04\xca\x06\x08\x10\n\r\n\x05\x04G\x02\x03\x05\x12\x04\xca\x06\x11\x16\
    \n\r\n\x05\x04G\x02\x03\x01\x12\x04\xca\x06\x17!\n\r\n\x05\x04G\x02\x03\
    \x03\x12\x04\xca\x06$%\n\r\n\x05\x04G\x02\x03\x08\x12\x04\xca\x06&4\n\r\
    \n\x05\x04G\x02\x03\x07\x12\x04\xca\x0613\n\x0c\n\x04\x04G\x02\x04\x12\
    \x04\xcb\x06\x08$\n\r\n\x05\x04G\x02\x04\x04\x12\x04\xcb\x06\x08\x10\n\r\
    \n\x05\x04G\x02\x04\x05\x12\x04\xcb\x06\x11\x15\n\r\n\x05\x04G\x02\x04\
    \x01\x12\x04\xcb\x06\x16\x1f\n\r\n\x05\x04G\x02\x04\x03\x12\x04\xcb\x06\
    \"#\n\x0c\n\x04\x04G\x02\x05\x12\x04\xcc\x06\x08(\n\r\n\x05\x04G\x02\x05\
    \x04\x12\x04\xcc\x06\x08\x10\n\r\n\x05\x04G\x02\x05\x05\x12\x04\xcc\x06\
    \x11\x15\n\r\n\x05\x04G\x02\x05\x01\x12\x04\xcc\x06\x16#\n\r\n\x05\x04G\
    \x02\x05\x03\x12\x04\xcc\x06&'\n\x0c\n\x04\x04G\x02\x06\x12\x04\xcd\x06\
    \x08J\n\r\n\x05\x04G\x02\x06\x04\x12\x04\xcd\x06\x08\x10\n\r\n\x05\x04G\
    \x02\x06\x06\x12\x04\xcd\x06\x11/\n\r\n\x05\x04G\x02\x06\x01\x12\x04\xcd\
    \x060E\n\r\n\x05\x04G\x02\x06\x03\x12\x04\xcd\x06HI\n\x0c\n\x04\x04G\x02\
    \x07\x12\x04\xce\x06\x088\n\r\n\x05\x04G\x02\x07\x04\x12\x04\xce\x06\x08\
    \x10\n\r\n\x05\x04G\x02\x07\x05\x12\x04\xce\x06\x11\x16\n\r\n\x05\x04G\
    \x02\x07\x01\x12\x04\xce\x06\x17%\n\r\n\x05\x04G\x02\x07\x03\x12\x04\xce\
    \x06()\n\r\n\x05\x04G\x02\x07\x08\x12\x04\xce\x06*7\n\r\n\x05\x04G\x02\
    \x07\x07\x12\x04\xce\x0656\n\x0c\n\x04\x04G\x02\x08\x12\x04\xcf\x06\x089\
    \n\r\n\x05\x04G\x02\x08\x04\x12\x04\xcf\x06\x08\x10\n\r\n\x05\x04G\x02\
    \x08\x06\x12\x04\xcf\x06\x11&\n\r\n\x05\x04G\x02\x08\x01\x12\x04\xcf\x06\
    '4\n\r\n\x05\x04G\x02\x08\x03\x12\x04\xcf\x0678\n\x0c\n\x02\x04H\x12\x06\
    \xd2\x06\0\xd6\x06\x01\n\x0b\n\x03\x04H\x01\x12\x04\xd2\x06\x08!\n\x0c\n\
    \x04\x04H\x02\0\x12\x04\xd3\x06\x08(\n\r\n\x05\x04H\x02\0\x04\x12\x04\
    \xd3\x06\x08\x10\n\r\n\x05\x04H\x02\0\x05\x12\x04\xd3\x06\x11\x17\n\r\n\
    \x05\x04H\x02\0\x01\x12\x04\xd3\x06\x18#\n\r\n\x05\x04H\x02\0\x03\x12\
    \x04\xd3\x06&'\n\x0c\n\x04\x04H\x02\x01\x12\x04\xd4\x06\x08&\n\r\n\x05\
    \x04H\x02\x01\x04\x12\x04\xd4\x06\x08\x10\n\r\n\x05\x04H\x02\x01\x05\x12\
    \x04\xd4\x06\x11\x17\n\r\n\x05\x04H\x02\x01\x01\x12\x04\xd4\x06\x18!\n\r\
    \n\x05\x04H\x02\x01\x03\x12\x04\xd4\x06$%\n\x0c\n\x04\x04H\x02\x02\x12\
    \x04\xd5\x06\x082\n\r\n\x05\x04H\x02\x02\x04\x12\x04\xd5\x06\x08\x10\n\r\
    \n\x05\x04H\x02\x02\x06\x12\x04\xd5\x06\x11&\n\r\n\x05\x04H\x02\x02\x01\
    \x12\x04\xd5\x06'-\n\r\n\x05\x04H\x02\x02\x03\x12\x04\xd5\x0601\n\x0c\n\
    \x02\x04I\x12\x06\xd8\x06\0\xe4\x06\x01\n\x0b\n\x03\x04I\x01\x12\x04\xd8\
    \x06\x08\x1a\n\x0c\n\x04\x04I\x02\0\x12\x04\xd9\x06\x08%\n\r\n\x05\x04I\
    \x02\0\x04\x12\x04\xd9\x06\x08\x10\n\r\n\x05\x04I\x02\0\x05\x12\x04\xd9\
    \x06\x11\x16\n\r\n\x05\x04I\x02\0\x01\x12\x04\xd9\x06\x17\x1f\n\r\n\x05\
    \x04I\x02\0\x03\x12\x04\xd9\x06\"$\n\x0c\n\x04\x04I\x02\x01\x12\x04\xda\
    \x06\x08'\n\r\n\x05\x04I\x02\x01\x04\x12\x04\xda\x06\x08\x10\n\r\n\x05\
    \x04I\x02\x01\x05\x12\x04\xda\x06\x11\x16\n\r\n\x05\x04I\x02\x01\x01\x12\
    \x04\xda\x06\x17!\n\r\n\x05\x04I\x02\x01\x03\x12\x04\xda\x06$&\n\x0c\n\
    \x04\x04I\x02\x02\x12\x04\xdb\x06\x08*\n\r\n\x05\x04I\x02\x02\x04\x12\
    \x04\xdb\x06\x08\x10\n\r\n\x05\x04I\x02\x02\x05\x12\x04\xdb\x06\x11\x16\
    \n\r\n\x05\x04I\x02\x02\x01\x12\x04\xdb\x06\x17$\n\r\n\x05\x04I\x02\x02\
    \x03\x12\x04\xdb\x06')\n\x0c\n\x04\x04I\x02\x03\x12\x04\xdc\x06\x084\n\r\
    \n\x05\x04I\x02\x03\x04\x12\x04\xdc\x06\x08\x10\n\r\n\x05\x04I\x02\x03\
    \x06\x12\x04\xdc\x06\x11\x20\n\r\n\x05\x04I\x02\x03\x01\x12\x04\xdc\x06!\
    /\n\r\n\x05\x04I\x02\x03\x03\x12\x04\xdc\x0623\n\x0c\n\x04\x04I\x02\x04\
    \x12\x04\xdd\x06\x08'\n\r\n\x05\x04I\x02\x04\x04\x12\x04\xdd\x06\x08\x10\
    \n\r\n\x05\x04I\x02\x04\x05\x12\x04\xdd\x06\x11\x17\n\r\n\x05\x04I\x02\
    \x04\x01\x12\x04\xdd\x06\x18\"\n\r\n\x05\x04I\x02\x04\x03\x12\x04\xdd\
    \x06%&\n\x0c\n\x04\x04I\x02\x05\x12\x04\xde\x06\x08(\n\r\n\x05\x04I\x02\
    \x05\x04\x12\x04\xde\x06\x08\x10\n\r\n\x05\x04I\x02\x05\x05\x12\x04\xde\
    \x06\x11\x17\n\r\n\x05\x04I\x02\x05\x01\x12\x04\xde\x06\x18#\n\r\n\x05\
    \x04I\x02\x05\x03\x12\x04\xde\x06&'\n\x0c\n\x04\x04I\x02\x06\x12\x04\xdf\
    \x06\x08)\n\r\n\x05\x04I\x02\x06\x04\x12\x04\xdf\x06\x08\x10\n\r\n\x05\
    \x04I\x02\x06\x06\x12\x04\xdf\x06\x11\x1b\n\r\n\x05\x04I\x02\x06\x01\x12\
    \x04\xdf\x06\x1c$\n\r\n\x05\x04I\x02\x06\x03\x12\x04\xdf\x06'(\n\x0c\n\
    \x04\x04I\x02\x07\x12\x04\xe0\x06\x08-\n\r\n\x05\x04I\x02\x07\x04\x12\
    \x04\xe0\x06\x08\x10\n\r\n\x05\x04I\x02\x07\x06\x12\x04\xe0\x06\x11\x1b\
    \n\r\n\x05\x04I\x02\x07\x01\x12\x04\xe0\x06\x1c(\n\r\n\x05\x04I\x02\x07\
    \x03\x12\x04\xe0\x06+,\n\x0c\n\x04\x04I\x02\x08\x12\x04\xe1\x06\x08#\n\r\
    \n\x05\x04I\x02\x08\x04\x12\x04\xe1\x06\x08\x10\n\r\n\x05\x04I\x02\x08\
    \x05\x12\x04\xe1\x06\x11\x15\n\r\n\x05\x04I\x02\x08\x01\x12\x04\xe1\x06\
    \x16\x1e\n\r\n\x05\x04I\x02\x08\x03\x12\x04\xe1\x06!\"\n\x0c\n\x04\x04I\
    \x02\t\x12\x04\xe2\x06\x08#\n\r\n\x05\x04I\x02\t\x04\x12\x04\xe2\x06\x08\
    \x10\n\r\n\x05\x04I\x02\t\x05\x12\x04\xe2\x06\x11\x15\n\r\n\x05\x04I\x02\
    \t\x01\x12\x04\xe2\x06\x16\x1e\n\r\n\x05\x04I\x02\t\x03\x12\x04\xe2\x06!\
    \"\n\x0c\n\x04\x04I\x02\n\x12\x04\xe3\x06\x089\n\r\n\x05\x04I\x02\n\x04\
    \x12\x04\xe3\x06\x08\x10\n\r\n\x05\x04I\x02\n\x06\x12\x04\xe3\x06\x11%\n\
    \r\n\x05\x04I\x02\n\x01\x12\x04\xe3\x06&3\n\r\n\x05\x04I\x02\n\x03\x12\
    \x04\xe3\x0668\n\x0c\n\x02\x04J\x12\x06\xe6\x06\0\xf3\x06\x01\n\x0b\n\
    \x03\x04J\x01\x12\x04\xe6\x06\x08\x1c\n\x0c\n\x04\x04J\x02\0\x12\x04\xe7\
    \x06\x08%\n\r\n\x05\x04J\x02\0\x04\x12\x04\xe7\x06\x08\x10\n\r\n\x05\x04\
    J\x02\0\x05\x12\x04\xe7\x06\x11\x16\n\r\n\x05\x04J\x02\0\x01\x12\x04\xe7\
    \x06\x17\x1f\n\r\n\x05\x04J\x02\0\x03\x12\x04\xe7\x06\"$\n\x0c\n\x04\x04\
    J\x02\x01\x12\x04\xe8\x06\x08'\n\r\n\x05\x04J\x02\x01\x04\x12\x04\xe8\
    \x06\x08\x10\n\r\n\x05\x04J\x02\x01\x05\x12\x04\xe8\x06\x11\x16\n\r\n\
    \x05\x04J\x02\x01\x01\x12\x04\xe8\x06\x17!\n\r\n\x05\x04J\x02\x01\x03\
    \x12\x04\xe8\x06$&\n\x0c\n\x04\x04J\x02\x02\x12\x04\xe9\x06\x08*\n\r\n\
    \x05\x04J\x02\x02\x04\x12\x04\xe9\x06\x08\x10\n\r\n\x05\x04J\x02\x02\x05\
    \x12\x04\xe9\x06\x11\x16\n\r\n\x05\x04J\x02\x02\x01\x12\x04\xe9\x06\x17$\
    \n\r\n\x05\x04J\x02\x02\x03\x12\x04\xe9\x06')\n\x0c\n\x04\x04J\x02\x03\
    \x12\x04\xea\x06\x08:\n\r\n\x05\x04J\x02\x03\x04\x12\x04\xea\x06\x08\x10\
    \n\r\n\x05\x04J\x02\x03\x06\x12\x04\xea\x06\x11&\n\r\n\x05\x04J\x02\x03\
    \x01\x12\x04\xea\x06'5\n\r\n\x05\x04J\x02\x03\x03\x12\x04\xea\x0689\n\
    \x0c\n\x04\x04J\x02\x04\x12\x04\xeb\x06\x08'\n\r\n\x05\x04J\x02\x04\x04\
    \x12\x04\xeb\x06\x08\x10\n\r\n\x05\x04J\x02\x04\x05\x12\x04\xeb\x06\x11\
    \x17\n\r\n\x05\x04J\x02\x04\x01\x12\x04\xeb\x06\x18\"\n\r\n\x05\x04J\x02\
    \x04\x03\x12\x04\xeb\x06%&\n\x0c\n\x04\x04J\x02\x05\x12\x04\xec\x06\x08(\
    \n\r\n\x05\x04J\x02\x05\x04\x12\x04\xec\x06\x08\x10\n\r\n\x05\x04J\x02\
    \x05\x05\x12\x04\xec\x06\x11\x17\n\r\n\x05\x04J\x02\x05\x01\x12\x04\xec\
    \x06\x18#\n\r\n\x05\x04J\x02\x05\x03\x12\x04\xec\x06&'\n\x0c\n\x04\x04J\
    \x02\x06\x12\x04\xed\x06\x08)\n\r\n\x05\x04J\x02\x06\x04\x12\x04\xed\x06\
    \x08\x10\n\r\n\x05\x04J\x02\x06\x06\x12\x04\xed\x06\x11\x1b\n\r\n\x05\
    \x04J\x02\x06\x01\x12\x04\xed\x06\x1c$\n\r\n\x05\x04J\x02\x06\x03\x12\
    \x04\xed\x06'(\n\x0c\n\x04\x04J\x02\x07\x12\x04\xee\x06\x08-\n\r\n\x05\
    \x04J\x02\x07\x04\x12\x04\xee\x06\x08\x10\n\r\n\x05\x04J\x02\x07\x06\x12\
    \x04\xee\x06\x11\x1b\n\r\n\x05\x04J\x02\x07\x01\x12\x04\xee\x06\x1c(\n\r\
    \n\x05\x04J\x02\x07\x03\x12\x04\xee\x06+,\n\x0c\n\x04\x04J\x02\x08\x12\
    \x04\xef\x06\x08#\n\r\n\x05\x04J\x02\x08\x04\x12\x04\xef\x06\x08\x10\n\r\
    \n\x05\x04J\x02\x08\x05\x12\x04\xef\x06\x11\x15\n\r\n\x05\x04J\x02\x08\
    \x01\x12\x04\xef\x06\x16\x1e\n\r\n\x05\x04J\x02\x08\x03\x12\x04\xef\x06!\
    \"\n\x0c\n\x04\x04J\x02\t\x12\x04\xf0\x06\x08#\n\r\n\x05\x04J\x02\t\x04\
    \x12\x04\xf0\x06\x08\x10\n\r\n\x05\x04J\x02\t\x05\x12\x04\xf0\x06\x11\
    \x15\n\r\n\x05\x04J\x02\t\x01\x12\x04\xf0\x06\x16\x1e\n\r\n\x05\x04J\x02\
    \t\x03\x12\x04\xf0\x06!\"\n\x0c\n\x04\x04J\x02\n\x12\x04\xf1\x06\x08?\n\
    \r\n\x05\x04J\x02\n\x04\x12\x04\xf1\x06\x08\x10\n\r\n\x05\x04J\x02\n\x06\
    \x12\x04\xf1\x06\x11+\n\r\n\x05\x04J\x02\n\x01\x12\x04\xf1\x06,9\n\r\n\
    \x05\x04J\x02\n\x03\x12\x04\xf1\x06<>\n\x0c\n\x04\x04J\x02\x0b\x12\x04\
    \xf2\x06\x083\n\r\n\x05\x04J\x02\x0b\x04\x12\x04\xf2\x06\x08\x10\n\r\n\
    \x05\x04J\x02\x0b\x06\x12\x04\xf2\x06\x11!\n\r\n\x05\x04J\x02\x0b\x01\
    \x12\x04\xf2\x06\"-\n\r\n\x05\x04J\x02\x0b\x03\x12\x04\xf2\x0602\n\x0c\n\
    \x02\x04K\x12\x06\xf5\x06\0\xfc\x06\x01\n\x0b\n\x03\x04K\x01\x12\x04\xf5\
    \x06\x08!\n\x0c\n\x04\x04K\x02\0\x12\x04\xf6\x06\x08(\n\r\n\x05\x04K\x02\
    \0\x04\x12\x04\xf6\x06\x08\x10\n\r\n\x05\x04K\x02\0\x05\x12\x04\xf6\x06\
    \x11\x16\n\r\n\x05\x04K\x02\0\x01\x12\x04\xf6\x06\x17#\n\r\n\x05\x04K\
    \x02\0\x03\x12\x04\xf6\x06&'\n\x0c\n\x04\x04K\x02\x01\x12\x04\xf7\x06\
    \x08)\n\r\n\x05\x04K\x02\x01\x04\x12\x04\xf7\x06\x08\x10\n\r\n\x05\x04K\
    \x02\x01\x06\x12\x04\xf7\x06\x11\x1b\n\r\n\x05\x04K\x02\x01\x01\x12\x04\
    \xf7\x06\x1c$\n\r\n\x05\x04K\x02\x01\x03\x12\x04\xf7\x06'(\n\x0c\n\x04\
    \x04K\x02\x02\x12\x04\xf8\x06\x08-\n\r\n\x05\x04K\x02\x02\x04\x12\x04\
    \xf8\x06\x08\x10\n\r\n\x05\x04K\x02\x02\x06\x12\x04\xf8\x06\x11\x1b\n\r\
    \n\x05\x04K\x02\x02\x01\x12\x04\xf8\x06\x1c(\n\r\n\x05\x04K\x02\x02\x03\
    \x12\x04\xf8\x06+,\n\x0c\n\x04\x04K\x02\x03\x12\x04\xf9\x06\x081\n\r\n\
    \x05\x04K\x02\x03\x04\x12\x04\xf9\x06\x08\x10\n\r\n\x05\x04K\x02\x03\x06\
    \x12\x04\xf9\x06\x11\x1b\n\r\n\x05\x04K\x02\x03\x01\x12\x04\xf9\x06\x1c,\
    \n\r\n\x05\x04K\x02\x03\x03\x12\x04\xf9\x06/0\n\x0c\n\x04\x04K\x02\x04\
    \x12\x04\xfa\x06\x085\n\r\n\x05\x04K\x02\x04\x04\x12\x04\xfa\x06\x08\x10\
    \n\r\n\x05\x04K\x02\x04\x06\x12\x04\xfa\x06\x11\x1b\n\r\n\x05\x04K\x02\
    \x04\x01\x12\x04\xfa\x06\x1c0\n\r\n\x05\x04K\x02\x04\x03\x12\x04\xfa\x06\
    34\n\x0c\n\x04\x04K\x02\x05\x12\x04\xfb\x06\x083\n\r\n\x05\x04K\x02\x05\
    \x04\x12\x04\xfb\x06\x08\x10\n\r\n\x05\x04K\x02\x05\x05\x12\x04\xfb\x06\
    \x11\x15\n\r\n\x05\x04K\x02\x05\x01\x12\x04\xfb\x06\x16.\n\r\n\x05\x04K\
    \x02\x05\x03\x12\x04\xfb\x0612\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(100);
            messages.push(CMsgBeginFrame::generated_message_descriptor_data());
            messages.push(CMsgEndFrame::generated_message_descriptor_data());
            messages.push(CMsgClearBackbuffer::generated_message_descriptor_data());
            messages.push(CMsgDeleteTexture::generated_message_descriptor_data());
            messages.push(CMsgDeletePanel::generated_message_descriptor_data());
            messages.push(CMsgDeleteParticleSystem::generated_message_descriptor_data());
            messages.push(CMsgPoint::generated_message_descriptor_data());
            messages.push(CMsgMatrix4x4::generated_message_descriptor_data());
            messages.push(CRadiusData::generated_message_descriptor_data());
            messages.push(CBorderData::generated_message_descriptor_data());
            messages.push(CBoxShadowData::generated_message_descriptor_data());
            messages.push(CTextShadowData::generated_message_descriptor_data());
            messages.push(CRadialClipData::generated_message_descriptor_data());
            messages.push(CMsgClipData::generated_message_descriptor_data());
            messages.push(CMsgPushCompositingLayer::generated_message_descriptor_data());
            messages.push(CMsgPopCompositingLayer::generated_message_descriptor_data());
            messages.push(CMsgFreeCompositingLayer::generated_message_descriptor_data());
            messages.push(CMsgTransitionData::generated_message_descriptor_data());
            messages.push(CMsgAnimationData::generated_message_descriptor_data());
            messages.push(CMsgAnimationFrameData::generated_message_descriptor_data());
            messages.push(CMsgPointWithTransition::generated_message_descriptor_data());
            messages.push(CMsgColor::generated_message_descriptor_data());
            messages.push(CMsgColorStop::generated_message_descriptor_data());
            messages.push(CMsgLinearGradient::generated_message_descriptor_data());
            messages.push(CMsgRadialGradient::generated_message_descriptor_data());
            messages.push(CMsgParticle::generated_message_descriptor_data());
            messages.push(CMsgParticleSystem::generated_message_descriptor_data());
            messages.push(CMsgFillBrush::generated_message_descriptor_data());
            messages.push(CMsgFillBrushCollection::generated_message_descriptor_data());
            messages.push(CMsgRenderFillBrushCollection::generated_message_descriptor_data());
            messages.push(CMsgPanelPosition::generated_message_descriptor_data());
            messages.push(CMsgOpacity::generated_message_descriptor_data());
            messages.push(CMsgRotate2D::generated_message_descriptor_data());
            messages.push(CMsgOpacityMaskData::generated_message_descriptor_data());
            messages.push(CMsgOpacityMask::generated_message_descriptor_data());
            messages.push(CMsgHueShift::generated_message_descriptor_data());
            messages.push(CMsgSaturation::generated_message_descriptor_data());
            messages.push(CMsgBrightness::generated_message_descriptor_data());
            messages.push(CMsgContrast::generated_message_descriptor_data());
            messages.push(CMsgGaussianValues::generated_message_descriptor_data());
            messages.push(CMsgGaussianBlur::generated_message_descriptor_data());
            messages.push(CMsgMotionBlurValues::generated_message_descriptor_data());
            messages.push(CMsgMotionBlur::generated_message_descriptor_data());
            messages.push(CMsg3DTransformPerspective::generated_message_descriptor_data());
            messages.push(CMsg3DTransformPerspectiveOrigin::generated_message_descriptor_data());
            messages.push(CMsgTransformOriginData::generated_message_descriptor_data());
            messages.push(CMsg3DTransformOrigin::generated_message_descriptor_data());
            messages.push(CMsg3DTransformMatrix::generated_message_descriptor_data());
            messages.push(CMsgBorderRadius::generated_message_descriptor_data());
            messages.push(CMsgBorder::generated_message_descriptor_data());
            messages.push(CMsgBoxShadow::generated_message_descriptor_data());
            messages.push(CMsgTextShadow::generated_message_descriptor_data());
            messages.push(CMsgClip::generated_message_descriptor_data());
            messages.push(CMsgPushClipLayer::generated_message_descriptor_data());
            messages.push(CMsgPopClipLayer::generated_message_descriptor_data());
            messages.push(CMsgPushPanelContextInLayer::generated_message_descriptor_data());
            messages.push(CMsgPopPanelContextInLayer::generated_message_descriptor_data());
            messages.push(CMsgPushAAndTContext::generated_message_descriptor_data());
            messages.push(CMsgPopAAndTContext::generated_message_descriptor_data());
            messages.push(CMsgBeginPaintBackground::generated_message_descriptor_data());
            messages.push(CMsgEndPaintBackground::generated_message_descriptor_data());
            messages.push(CMsgBeginPaintLast::generated_message_descriptor_data());
            messages.push(CMsgEndPaintLast::generated_message_descriptor_data());
            messages.push(CMsgDrawFilledRect::generated_message_descriptor_data());
            messages.push(CMsgRenderFilledRect::generated_message_descriptor_data());
            messages.push(CMsgDrawTexturedRect::generated_message_descriptor_data());
            messages.push(CMsgRenderTexturedRect::generated_message_descriptor_data());
            messages.push(CMsgLockTexture::generated_message_descriptor_data());
            messages.push(CMsgTextInlineObject::generated_message_descriptor_data());
            messages.push(CMsgTextFormat::generated_message_descriptor_data());
            messages.push(CMsgTextRangeFormat::generated_message_descriptor_data());
            messages.push(CMsgRenderTextFormat::generated_message_descriptor_data());
            messages.push(CMsgRenderTextRangeFormat::generated_message_descriptor_data());
            messages.push(CMsgDrawTextRegion::generated_message_descriptor_data());
            messages.push(CMsgRenderTextRegion::generated_message_descriptor_data());
            messages.push(CMsgRequestRenderCallback::generated_message_descriptor_data());
            messages.push(cradius_data::CCornerRadius::generated_message_descriptor_data());
            messages.push(cborder_data::CBorderSide::generated_message_descriptor_data());
            messages.push(cmsg_point_with_transition::AnimationFrameData::generated_message_descriptor_data());
            messages.push(cmsg_color::AnimationFrameData::generated_message_descriptor_data());
            messages.push(cmsg_fill_brush_collection::AnimationFrameData::generated_message_descriptor_data());
            messages.push(cmsg_panel_position::AnimationFrameData::generated_message_descriptor_data());
            messages.push(cmsg_opacity::AnimationFrameData::generated_message_descriptor_data());
            messages.push(cmsg_rotate2d::AnimationFrameData::generated_message_descriptor_data());
            messages.push(cmsg_opacity_mask::AnimationFrameData::generated_message_descriptor_data());
            messages.push(cmsg_hue_shift::AnimationFrameData::generated_message_descriptor_data());
            messages.push(cmsg_saturation::AnimationFrameData::generated_message_descriptor_data());
            messages.push(cmsg_brightness::AnimationFrameData::generated_message_descriptor_data());
            messages.push(cmsg_contrast::AnimationFrameData::generated_message_descriptor_data());
            messages.push(cmsg_gaussian_blur::AnimationFrameData::generated_message_descriptor_data());
            messages.push(cmsg_motion_blur::AnimationFrameData::generated_message_descriptor_data());
            messages.push(cmsg3dtransform_perspective::AnimationFrameData::generated_message_descriptor_data());
            messages.push(cmsg3dtransform_perspective_origin::AnimationFrameData::generated_message_descriptor_data());
            messages.push(cmsg3dtransform_origin::AnimationFrameData::generated_message_descriptor_data());
            messages.push(cmsg3dtransform_matrix::AnimationFrameData::generated_message_descriptor_data());
            messages.push(cmsg_border_radius::AnimationFrameData::generated_message_descriptor_data());
            messages.push(cmsg_border::AnimationFrameData::generated_message_descriptor_data());
            messages.push(cmsg_box_shadow::AnimationFrameData::generated_message_descriptor_data());
            messages.push(cmsg_text_shadow::AnimationFrameData::generated_message_descriptor_data());
            messages.push(cmsg_clip::AnimationFrameData::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
