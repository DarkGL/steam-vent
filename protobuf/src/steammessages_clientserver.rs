// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_clientserver.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:CMsgClientUDSP2PSessionStarted)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUDSP2PSessionStarted {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUDSP2PSessionStarted.steamid_remote)
    pub steamid_remote: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUDSP2PSessionStarted.appid)
    pub appid: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUDSP2PSessionStarted.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUDSP2PSessionStarted {
    fn default() -> &'a CMsgClientUDSP2PSessionStarted {
        <CMsgClientUDSP2PSessionStarted as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUDSP2PSessionStarted {
    pub fn new() -> CMsgClientUDSP2PSessionStarted {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_remote = 1;

    pub fn steamid_remote(&self) -> u64 {
        self.steamid_remote.unwrap_or(0)
    }

    pub fn clear_steamid_remote(&mut self) {
        self.steamid_remote = ::std::option::Option::None;
    }

    pub fn has_steamid_remote(&self) -> bool {
        self.steamid_remote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_remote(&mut self, v: u64) {
        self.steamid_remote = ::std::option::Option::Some(v);
    }

    // optional int32 appid = 2;

    pub fn appid(&self) -> i32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: i32) {
        self.appid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid_remote",
            |m: &CMsgClientUDSP2PSessionStarted| { &m.steamid_remote },
            |m: &mut CMsgClientUDSP2PSessionStarted| { &mut m.steamid_remote },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CMsgClientUDSP2PSessionStarted| { &m.appid },
            |m: &mut CMsgClientUDSP2PSessionStarted| { &mut m.appid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUDSP2PSessionStarted>(
            "CMsgClientUDSP2PSessionStarted",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUDSP2PSessionStarted {
    const NAME: &'static str = "CMsgClientUDSP2PSessionStarted";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid_remote = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.appid = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_remote {
            my_size += 1 + 8;
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid_remote {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.appid {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUDSP2PSessionStarted {
        CMsgClientUDSP2PSessionStarted::new()
    }

    fn clear(&mut self) {
        self.steamid_remote = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUDSP2PSessionStarted {
        static instance: CMsgClientUDSP2PSessionStarted = CMsgClientUDSP2PSessionStarted {
            steamid_remote: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUDSP2PSessionStarted {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUDSP2PSessionStarted").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUDSP2PSessionStarted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUDSP2PSessionStarted {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUDSP2PSessionEnded)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUDSP2PSessionEnded {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUDSP2PSessionEnded.steamid_remote)
    pub steamid_remote: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUDSP2PSessionEnded.appid)
    pub appid: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUDSP2PSessionEnded.session_length_sec)
    pub session_length_sec: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUDSP2PSessionEnded.session_error)
    pub session_error: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUDSP2PSessionEnded.nattype)
    pub nattype: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUDSP2PSessionEnded.bytes_recv)
    pub bytes_recv: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUDSP2PSessionEnded.bytes_sent)
    pub bytes_sent: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUDSP2PSessionEnded.bytes_sent_relay)
    pub bytes_sent_relay: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUDSP2PSessionEnded.bytes_recv_relay)
    pub bytes_recv_relay: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUDSP2PSessionEnded.time_to_connect_ms)
    pub time_to_connect_ms: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUDSP2PSessionEnded.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUDSP2PSessionEnded {
    fn default() -> &'a CMsgClientUDSP2PSessionEnded {
        <CMsgClientUDSP2PSessionEnded as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUDSP2PSessionEnded {
    pub fn new() -> CMsgClientUDSP2PSessionEnded {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_remote = 1;

    pub fn steamid_remote(&self) -> u64 {
        self.steamid_remote.unwrap_or(0)
    }

    pub fn clear_steamid_remote(&mut self) {
        self.steamid_remote = ::std::option::Option::None;
    }

    pub fn has_steamid_remote(&self) -> bool {
        self.steamid_remote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_remote(&mut self, v: u64) {
        self.steamid_remote = ::std::option::Option::Some(v);
    }

    // optional int32 appid = 2;

    pub fn appid(&self) -> i32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: i32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional int32 session_length_sec = 3;

    pub fn session_length_sec(&self) -> i32 {
        self.session_length_sec.unwrap_or(0)
    }

    pub fn clear_session_length_sec(&mut self) {
        self.session_length_sec = ::std::option::Option::None;
    }

    pub fn has_session_length_sec(&self) -> bool {
        self.session_length_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_length_sec(&mut self, v: i32) {
        self.session_length_sec = ::std::option::Option::Some(v);
    }

    // optional int32 session_error = 4;

    pub fn session_error(&self) -> i32 {
        self.session_error.unwrap_or(0)
    }

    pub fn clear_session_error(&mut self) {
        self.session_error = ::std::option::Option::None;
    }

    pub fn has_session_error(&self) -> bool {
        self.session_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_error(&mut self, v: i32) {
        self.session_error = ::std::option::Option::Some(v);
    }

    // optional int32 nattype = 5;

    pub fn nattype(&self) -> i32 {
        self.nattype.unwrap_or(0)
    }

    pub fn clear_nattype(&mut self) {
        self.nattype = ::std::option::Option::None;
    }

    pub fn has_nattype(&self) -> bool {
        self.nattype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nattype(&mut self, v: i32) {
        self.nattype = ::std::option::Option::Some(v);
    }

    // optional int32 bytes_recv = 6;

    pub fn bytes_recv(&self) -> i32 {
        self.bytes_recv.unwrap_or(0)
    }

    pub fn clear_bytes_recv(&mut self) {
        self.bytes_recv = ::std::option::Option::None;
    }

    pub fn has_bytes_recv(&self) -> bool {
        self.bytes_recv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_recv(&mut self, v: i32) {
        self.bytes_recv = ::std::option::Option::Some(v);
    }

    // optional int32 bytes_sent = 7;

    pub fn bytes_sent(&self) -> i32 {
        self.bytes_sent.unwrap_or(0)
    }

    pub fn clear_bytes_sent(&mut self) {
        self.bytes_sent = ::std::option::Option::None;
    }

    pub fn has_bytes_sent(&self) -> bool {
        self.bytes_sent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_sent(&mut self, v: i32) {
        self.bytes_sent = ::std::option::Option::Some(v);
    }

    // optional int32 bytes_sent_relay = 8;

    pub fn bytes_sent_relay(&self) -> i32 {
        self.bytes_sent_relay.unwrap_or(0)
    }

    pub fn clear_bytes_sent_relay(&mut self) {
        self.bytes_sent_relay = ::std::option::Option::None;
    }

    pub fn has_bytes_sent_relay(&self) -> bool {
        self.bytes_sent_relay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_sent_relay(&mut self, v: i32) {
        self.bytes_sent_relay = ::std::option::Option::Some(v);
    }

    // optional int32 bytes_recv_relay = 9;

    pub fn bytes_recv_relay(&self) -> i32 {
        self.bytes_recv_relay.unwrap_or(0)
    }

    pub fn clear_bytes_recv_relay(&mut self) {
        self.bytes_recv_relay = ::std::option::Option::None;
    }

    pub fn has_bytes_recv_relay(&self) -> bool {
        self.bytes_recv_relay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_recv_relay(&mut self, v: i32) {
        self.bytes_recv_relay = ::std::option::Option::Some(v);
    }

    // optional int32 time_to_connect_ms = 10;

    pub fn time_to_connect_ms(&self) -> i32 {
        self.time_to_connect_ms.unwrap_or(0)
    }

    pub fn clear_time_to_connect_ms(&mut self) {
        self.time_to_connect_ms = ::std::option::Option::None;
    }

    pub fn has_time_to_connect_ms(&self) -> bool {
        self.time_to_connect_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_to_connect_ms(&mut self, v: i32) {
        self.time_to_connect_ms = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid_remote",
            |m: &CMsgClientUDSP2PSessionEnded| { &m.steamid_remote },
            |m: &mut CMsgClientUDSP2PSessionEnded| { &mut m.steamid_remote },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CMsgClientUDSP2PSessionEnded| { &m.appid },
            |m: &mut CMsgClientUDSP2PSessionEnded| { &mut m.appid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "session_length_sec",
            |m: &CMsgClientUDSP2PSessionEnded| { &m.session_length_sec },
            |m: &mut CMsgClientUDSP2PSessionEnded| { &mut m.session_length_sec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "session_error",
            |m: &CMsgClientUDSP2PSessionEnded| { &m.session_error },
            |m: &mut CMsgClientUDSP2PSessionEnded| { &mut m.session_error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nattype",
            |m: &CMsgClientUDSP2PSessionEnded| { &m.nattype },
            |m: &mut CMsgClientUDSP2PSessionEnded| { &mut m.nattype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bytes_recv",
            |m: &CMsgClientUDSP2PSessionEnded| { &m.bytes_recv },
            |m: &mut CMsgClientUDSP2PSessionEnded| { &mut m.bytes_recv },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bytes_sent",
            |m: &CMsgClientUDSP2PSessionEnded| { &m.bytes_sent },
            |m: &mut CMsgClientUDSP2PSessionEnded| { &mut m.bytes_sent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bytes_sent_relay",
            |m: &CMsgClientUDSP2PSessionEnded| { &m.bytes_sent_relay },
            |m: &mut CMsgClientUDSP2PSessionEnded| { &mut m.bytes_sent_relay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bytes_recv_relay",
            |m: &CMsgClientUDSP2PSessionEnded| { &m.bytes_recv_relay },
            |m: &mut CMsgClientUDSP2PSessionEnded| { &mut m.bytes_recv_relay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_to_connect_ms",
            |m: &CMsgClientUDSP2PSessionEnded| { &m.time_to_connect_ms },
            |m: &mut CMsgClientUDSP2PSessionEnded| { &mut m.time_to_connect_ms },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUDSP2PSessionEnded>(
            "CMsgClientUDSP2PSessionEnded",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUDSP2PSessionEnded {
    const NAME: &'static str = "CMsgClientUDSP2PSessionEnded";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid_remote = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.appid = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.session_length_sec = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.session_error = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.nattype = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.bytes_recv = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.bytes_sent = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.bytes_sent_relay = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.bytes_recv_relay = ::std::option::Option::Some(is.read_int32()?);
                },
                80 => {
                    self.time_to_connect_ms = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_remote {
            my_size += 1 + 8;
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.session_length_sec {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.session_error {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.nattype {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.bytes_recv {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.bytes_sent {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.bytes_sent_relay {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.bytes_recv_relay {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        if let Some(v) = self.time_to_connect_ms {
            my_size += ::protobuf::rt::int32_size(10, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid_remote {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.appid {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.session_length_sec {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.session_error {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.nattype {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.bytes_recv {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.bytes_sent {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.bytes_sent_relay {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.bytes_recv_relay {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.time_to_connect_ms {
            os.write_int32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUDSP2PSessionEnded {
        CMsgClientUDSP2PSessionEnded::new()
    }

    fn clear(&mut self) {
        self.steamid_remote = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.session_length_sec = ::std::option::Option::None;
        self.session_error = ::std::option::Option::None;
        self.nattype = ::std::option::Option::None;
        self.bytes_recv = ::std::option::Option::None;
        self.bytes_sent = ::std::option::Option::None;
        self.bytes_sent_relay = ::std::option::Option::None;
        self.bytes_recv_relay = ::std::option::Option::None;
        self.time_to_connect_ms = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUDSP2PSessionEnded {
        static instance: CMsgClientUDSP2PSessionEnded = CMsgClientUDSP2PSessionEnded {
            steamid_remote: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            session_length_sec: ::std::option::Option::None,
            session_error: ::std::option::Option::None,
            nattype: ::std::option::Option::None,
            bytes_recv: ::std::option::Option::None,
            bytes_sent: ::std::option::Option::None,
            bytes_sent_relay: ::std::option::Option::None,
            bytes_recv_relay: ::std::option::Option::None,
            time_to_connect_ms: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUDSP2PSessionEnded {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUDSP2PSessionEnded").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUDSP2PSessionEnded {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUDSP2PSessionEnded {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRegisterAuthTicketWithCM)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRegisterAuthTicketWithCM {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRegisterAuthTicketWithCM.protocol_version)
    pub protocol_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRegisterAuthTicketWithCM.ticket)
    pub ticket: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientRegisterAuthTicketWithCM.client_instance_id)
    pub client_instance_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRegisterAuthTicketWithCM.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRegisterAuthTicketWithCM {
    fn default() -> &'a CMsgClientRegisterAuthTicketWithCM {
        <CMsgClientRegisterAuthTicketWithCM as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRegisterAuthTicketWithCM {
    pub fn new() -> CMsgClientRegisterAuthTicketWithCM {
        ::std::default::Default::default()
    }

    // optional uint32 protocol_version = 1;

    pub fn protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }

    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }

    // optional bytes ticket = 3;

    pub fn ticket(&self) -> &[u8] {
        match self.ticket.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_ticket(&mut self) {
        self.ticket = ::std::option::Option::None;
    }

    pub fn has_ticket(&self) -> bool {
        self.ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket(&mut self, v: ::std::vec::Vec<u8>) {
        self.ticket = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticket(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ticket.is_none() {
            self.ticket = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_ticket(&mut self) -> ::std::vec::Vec<u8> {
        self.ticket.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 client_instance_id = 4;

    pub fn client_instance_id(&self) -> u64 {
        self.client_instance_id.unwrap_or(0)
    }

    pub fn clear_client_instance_id(&mut self) {
        self.client_instance_id = ::std::option::Option::None;
    }

    pub fn has_client_instance_id(&self) -> bool {
        self.client_instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_instance_id(&mut self, v: u64) {
        self.client_instance_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "protocol_version",
            |m: &CMsgClientRegisterAuthTicketWithCM| { &m.protocol_version },
            |m: &mut CMsgClientRegisterAuthTicketWithCM| { &mut m.protocol_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ticket",
            |m: &CMsgClientRegisterAuthTicketWithCM| { &m.ticket },
            |m: &mut CMsgClientRegisterAuthTicketWithCM| { &mut m.ticket },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_instance_id",
            |m: &CMsgClientRegisterAuthTicketWithCM| { &m.client_instance_id },
            |m: &mut CMsgClientRegisterAuthTicketWithCM| { &mut m.client_instance_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRegisterAuthTicketWithCM>(
            "CMsgClientRegisterAuthTicketWithCM",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientRegisterAuthTicketWithCM {
    const NAME: &'static str = "CMsgClientRegisterAuthTicketWithCM";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.protocol_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.ticket = ::std::option::Option::Some(is.read_bytes()?);
                },
                32 => {
                    self.client_instance_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.protocol_version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.ticket.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.client_instance_id {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.protocol_version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.ticket.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.client_instance_id {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRegisterAuthTicketWithCM {
        CMsgClientRegisterAuthTicketWithCM::new()
    }

    fn clear(&mut self) {
        self.protocol_version = ::std::option::Option::None;
        self.ticket = ::std::option::Option::None;
        self.client_instance_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRegisterAuthTicketWithCM {
        static instance: CMsgClientRegisterAuthTicketWithCM = CMsgClientRegisterAuthTicketWithCM {
            protocol_version: ::std::option::Option::None,
            ticket: ::std::option::Option::None,
            client_instance_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientRegisterAuthTicketWithCM {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRegisterAuthTicketWithCM").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRegisterAuthTicketWithCM {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRegisterAuthTicketWithCM {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientTicketAuthComplete)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientTicketAuthComplete {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientTicketAuthComplete.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientTicketAuthComplete.game_id)
    pub game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientTicketAuthComplete.estate)
    pub estate: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientTicketAuthComplete.eauth_session_response)
    pub eauth_session_response: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientTicketAuthComplete.DEPRECATED_ticket)
    pub DEPRECATED_ticket: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientTicketAuthComplete.ticket_crc)
    pub ticket_crc: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientTicketAuthComplete.ticket_sequence)
    pub ticket_sequence: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientTicketAuthComplete.owner_steam_id)
    pub owner_steam_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientTicketAuthComplete.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientTicketAuthComplete {
    fn default() -> &'a CMsgClientTicketAuthComplete {
        <CMsgClientTicketAuthComplete as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientTicketAuthComplete {
    pub fn new() -> CMsgClientTicketAuthComplete {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 game_id = 2;

    pub fn game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // optional uint32 estate = 3;

    pub fn estate(&self) -> u32 {
        self.estate.unwrap_or(0)
    }

    pub fn clear_estate(&mut self) {
        self.estate = ::std::option::Option::None;
    }

    pub fn has_estate(&self) -> bool {
        self.estate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_estate(&mut self, v: u32) {
        self.estate = ::std::option::Option::Some(v);
    }

    // optional uint32 eauth_session_response = 4;

    pub fn eauth_session_response(&self) -> u32 {
        self.eauth_session_response.unwrap_or(0)
    }

    pub fn clear_eauth_session_response(&mut self) {
        self.eauth_session_response = ::std::option::Option::None;
    }

    pub fn has_eauth_session_response(&self) -> bool {
        self.eauth_session_response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eauth_session_response(&mut self, v: u32) {
        self.eauth_session_response = ::std::option::Option::Some(v);
    }

    // optional bytes DEPRECATED_ticket = 5;

    pub fn DEPRECATED_ticket(&self) -> &[u8] {
        match self.DEPRECATED_ticket.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_DEPRECATED_ticket(&mut self) {
        self.DEPRECATED_ticket = ::std::option::Option::None;
    }

    pub fn has_DEPRECATED_ticket(&self) -> bool {
        self.DEPRECATED_ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_DEPRECATED_ticket(&mut self, v: ::std::vec::Vec<u8>) {
        self.DEPRECATED_ticket = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_DEPRECATED_ticket(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.DEPRECATED_ticket.is_none() {
            self.DEPRECATED_ticket = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.DEPRECATED_ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_DEPRECATED_ticket(&mut self) -> ::std::vec::Vec<u8> {
        self.DEPRECATED_ticket.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 ticket_crc = 6;

    pub fn ticket_crc(&self) -> u32 {
        self.ticket_crc.unwrap_or(0)
    }

    pub fn clear_ticket_crc(&mut self) {
        self.ticket_crc = ::std::option::Option::None;
    }

    pub fn has_ticket_crc(&self) -> bool {
        self.ticket_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket_crc(&mut self, v: u32) {
        self.ticket_crc = ::std::option::Option::Some(v);
    }

    // optional uint32 ticket_sequence = 7;

    pub fn ticket_sequence(&self) -> u32 {
        self.ticket_sequence.unwrap_or(0)
    }

    pub fn clear_ticket_sequence(&mut self) {
        self.ticket_sequence = ::std::option::Option::None;
    }

    pub fn has_ticket_sequence(&self) -> bool {
        self.ticket_sequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket_sequence(&mut self, v: u32) {
        self.ticket_sequence = ::std::option::Option::Some(v);
    }

    // optional fixed64 owner_steam_id = 8;

    pub fn owner_steam_id(&self) -> u64 {
        self.owner_steam_id.unwrap_or(0)
    }

    pub fn clear_owner_steam_id(&mut self) {
        self.owner_steam_id = ::std::option::Option::None;
    }

    pub fn has_owner_steam_id(&self) -> bool {
        self.owner_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_steam_id(&mut self, v: u64) {
        self.owner_steam_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id",
            |m: &CMsgClientTicketAuthComplete| { &m.steam_id },
            |m: &mut CMsgClientTicketAuthComplete| { &mut m.steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_id",
            |m: &CMsgClientTicketAuthComplete| { &m.game_id },
            |m: &mut CMsgClientTicketAuthComplete| { &mut m.game_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "estate",
            |m: &CMsgClientTicketAuthComplete| { &m.estate },
            |m: &mut CMsgClientTicketAuthComplete| { &mut m.estate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eauth_session_response",
            |m: &CMsgClientTicketAuthComplete| { &m.eauth_session_response },
            |m: &mut CMsgClientTicketAuthComplete| { &mut m.eauth_session_response },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "DEPRECATED_ticket",
            |m: &CMsgClientTicketAuthComplete| { &m.DEPRECATED_ticket },
            |m: &mut CMsgClientTicketAuthComplete| { &mut m.DEPRECATED_ticket },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ticket_crc",
            |m: &CMsgClientTicketAuthComplete| { &m.ticket_crc },
            |m: &mut CMsgClientTicketAuthComplete| { &mut m.ticket_crc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ticket_sequence",
            |m: &CMsgClientTicketAuthComplete| { &m.ticket_sequence },
            |m: &mut CMsgClientTicketAuthComplete| { &mut m.ticket_sequence },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "owner_steam_id",
            |m: &CMsgClientTicketAuthComplete| { &m.owner_steam_id },
            |m: &mut CMsgClientTicketAuthComplete| { &mut m.owner_steam_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientTicketAuthComplete>(
            "CMsgClientTicketAuthComplete",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientTicketAuthComplete {
    const NAME: &'static str = "CMsgClientTicketAuthComplete";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.game_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.estate = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.eauth_session_response = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.DEPRECATED_ticket = ::std::option::Option::Some(is.read_bytes()?);
                },
                48 => {
                    self.ticket_crc = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.ticket_sequence = ::std::option::Option::Some(is.read_uint32()?);
                },
                65 => {
                    self.owner_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.game_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.estate {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.eauth_session_response {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.DEPRECATED_ticket.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.ticket_crc {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.ticket_sequence {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.owner_steam_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.game_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.estate {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.eauth_session_response {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.DEPRECATED_ticket.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.ticket_crc {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.ticket_sequence {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.owner_steam_id {
            os.write_fixed64(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientTicketAuthComplete {
        CMsgClientTicketAuthComplete::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.game_id = ::std::option::Option::None;
        self.estate = ::std::option::Option::None;
        self.eauth_session_response = ::std::option::Option::None;
        self.DEPRECATED_ticket = ::std::option::Option::None;
        self.ticket_crc = ::std::option::Option::None;
        self.ticket_sequence = ::std::option::Option::None;
        self.owner_steam_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientTicketAuthComplete {
        static instance: CMsgClientTicketAuthComplete = CMsgClientTicketAuthComplete {
            steam_id: ::std::option::Option::None,
            game_id: ::std::option::Option::None,
            estate: ::std::option::Option::None,
            eauth_session_response: ::std::option::Option::None,
            DEPRECATED_ticket: ::std::option::Option::None,
            ticket_crc: ::std::option::Option::None,
            ticket_sequence: ::std::option::Option::None,
            owner_steam_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientTicketAuthComplete {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientTicketAuthComplete").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientTicketAuthComplete {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientTicketAuthComplete {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientCMList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientCMList {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientCMList.cm_addresses)
    pub cm_addresses: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgClientCMList.cm_ports)
    pub cm_ports: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgClientCMList.cm_websocket_addresses)
    pub cm_websocket_addresses: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientCMList.percent_default_to_websocket)
    pub percent_default_to_websocket: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientCMList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientCMList {
    fn default() -> &'a CMsgClientCMList {
        <CMsgClientCMList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientCMList {
    pub fn new() -> CMsgClientCMList {
        ::std::default::Default::default()
    }

    // optional uint32 percent_default_to_websocket = 4;

    pub fn percent_default_to_websocket(&self) -> u32 {
        self.percent_default_to_websocket.unwrap_or(0)
    }

    pub fn clear_percent_default_to_websocket(&mut self) {
        self.percent_default_to_websocket = ::std::option::Option::None;
    }

    pub fn has_percent_default_to_websocket(&self) -> bool {
        self.percent_default_to_websocket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_percent_default_to_websocket(&mut self, v: u32) {
        self.percent_default_to_websocket = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "cm_addresses",
            |m: &CMsgClientCMList| { &m.cm_addresses },
            |m: &mut CMsgClientCMList| { &mut m.cm_addresses },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "cm_ports",
            |m: &CMsgClientCMList| { &m.cm_ports },
            |m: &mut CMsgClientCMList| { &mut m.cm_ports },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "cm_websocket_addresses",
            |m: &CMsgClientCMList| { &m.cm_websocket_addresses },
            |m: &mut CMsgClientCMList| { &mut m.cm_websocket_addresses },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "percent_default_to_websocket",
            |m: &CMsgClientCMList| { &m.percent_default_to_websocket },
            |m: &mut CMsgClientCMList| { &mut m.percent_default_to_websocket },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientCMList>(
            "CMsgClientCMList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientCMList {
    const NAME: &'static str = "CMsgClientCMList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.cm_addresses)?;
                },
                8 => {
                    self.cm_addresses.push(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.cm_ports)?;
                },
                16 => {
                    self.cm_ports.push(is.read_uint32()?);
                },
                26 => {
                    self.cm_websocket_addresses.push(is.read_string()?);
                },
                32 => {
                    self.percent_default_to_websocket = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.cm_addresses {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        for value in &self.cm_ports {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        for value in &self.cm_websocket_addresses {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if let Some(v) = self.percent_default_to_websocket {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.cm_addresses {
            os.write_uint32(1, *v)?;
        };
        for v in &self.cm_ports {
            os.write_uint32(2, *v)?;
        };
        for v in &self.cm_websocket_addresses {
            os.write_string(3, &v)?;
        };
        if let Some(v) = self.percent_default_to_websocket {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientCMList {
        CMsgClientCMList::new()
    }

    fn clear(&mut self) {
        self.cm_addresses.clear();
        self.cm_ports.clear();
        self.cm_websocket_addresses.clear();
        self.percent_default_to_websocket = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientCMList {
        static instance: CMsgClientCMList = CMsgClientCMList {
            cm_addresses: ::std::vec::Vec::new(),
            cm_ports: ::std::vec::Vec::new(),
            cm_websocket_addresses: ::std::vec::Vec::new(),
            percent_default_to_websocket: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientCMList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientCMList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientCMList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientCMList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientP2PConnectionInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientP2PConnectionInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientP2PConnectionInfo.steam_id_dest)
    pub steam_id_dest: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientP2PConnectionInfo.steam_id_src)
    pub steam_id_src: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientP2PConnectionInfo.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientP2PConnectionInfo.candidate)
    pub candidate: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientP2PConnectionInfo.legacy_connection_id_src)
    pub legacy_connection_id_src: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientP2PConnectionInfo.rendezvous)
    pub rendezvous: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientP2PConnectionInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientP2PConnectionInfo {
    fn default() -> &'a CMsgClientP2PConnectionInfo {
        <CMsgClientP2PConnectionInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientP2PConnectionInfo {
    pub fn new() -> CMsgClientP2PConnectionInfo {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_dest = 1;

    pub fn steam_id_dest(&self) -> u64 {
        self.steam_id_dest.unwrap_or(0)
    }

    pub fn clear_steam_id_dest(&mut self) {
        self.steam_id_dest = ::std::option::Option::None;
    }

    pub fn has_steam_id_dest(&self) -> bool {
        self.steam_id_dest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_dest(&mut self, v: u64) {
        self.steam_id_dest = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_src = 2;

    pub fn steam_id_src(&self) -> u64 {
        self.steam_id_src.unwrap_or(0)
    }

    pub fn clear_steam_id_src(&mut self) {
        self.steam_id_src = ::std::option::Option::None;
    }

    pub fn has_steam_id_src(&self) -> bool {
        self.steam_id_src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_src(&mut self, v: u64) {
        self.steam_id_src = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 3;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional bytes candidate = 4;

    pub fn candidate(&self) -> &[u8] {
        match self.candidate.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_candidate(&mut self) {
        self.candidate = ::std::option::Option::None;
    }

    pub fn has_candidate(&self) -> bool {
        self.candidate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_candidate(&mut self, v: ::std::vec::Vec<u8>) {
        self.candidate = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_candidate(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.candidate.is_none() {
            self.candidate = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.candidate.as_mut().unwrap()
    }

    // Take field
    pub fn take_candidate(&mut self) -> ::std::vec::Vec<u8> {
        self.candidate.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed64 legacy_connection_id_src = 5;

    pub fn legacy_connection_id_src(&self) -> u64 {
        self.legacy_connection_id_src.unwrap_or(0)
    }

    pub fn clear_legacy_connection_id_src(&mut self) {
        self.legacy_connection_id_src = ::std::option::Option::None;
    }

    pub fn has_legacy_connection_id_src(&self) -> bool {
        self.legacy_connection_id_src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_connection_id_src(&mut self, v: u64) {
        self.legacy_connection_id_src = ::std::option::Option::Some(v);
    }

    // optional bytes rendezvous = 6;

    pub fn rendezvous(&self) -> &[u8] {
        match self.rendezvous.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_rendezvous(&mut self) {
        self.rendezvous = ::std::option::Option::None;
    }

    pub fn has_rendezvous(&self) -> bool {
        self.rendezvous.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rendezvous(&mut self, v: ::std::vec::Vec<u8>) {
        self.rendezvous = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rendezvous(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.rendezvous.is_none() {
            self.rendezvous = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.rendezvous.as_mut().unwrap()
    }

    // Take field
    pub fn take_rendezvous(&mut self) -> ::std::vec::Vec<u8> {
        self.rendezvous.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_dest",
            |m: &CMsgClientP2PConnectionInfo| { &m.steam_id_dest },
            |m: &mut CMsgClientP2PConnectionInfo| { &mut m.steam_id_dest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_src",
            |m: &CMsgClientP2PConnectionInfo| { &m.steam_id_src },
            |m: &mut CMsgClientP2PConnectionInfo| { &mut m.steam_id_src },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientP2PConnectionInfo| { &m.app_id },
            |m: &mut CMsgClientP2PConnectionInfo| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "candidate",
            |m: &CMsgClientP2PConnectionInfo| { &m.candidate },
            |m: &mut CMsgClientP2PConnectionInfo| { &mut m.candidate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "legacy_connection_id_src",
            |m: &CMsgClientP2PConnectionInfo| { &m.legacy_connection_id_src },
            |m: &mut CMsgClientP2PConnectionInfo| { &mut m.legacy_connection_id_src },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rendezvous",
            |m: &CMsgClientP2PConnectionInfo| { &m.rendezvous },
            |m: &mut CMsgClientP2PConnectionInfo| { &mut m.rendezvous },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientP2PConnectionInfo>(
            "CMsgClientP2PConnectionInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientP2PConnectionInfo {
    const NAME: &'static str = "CMsgClientP2PConnectionInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id_dest = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.steam_id_src = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.candidate = ::std::option::Option::Some(is.read_bytes()?);
                },
                41 => {
                    self.legacy_connection_id_src = ::std::option::Option::Some(is.read_fixed64()?);
                },
                50 => {
                    self.rendezvous = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_dest {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steam_id_src {
            my_size += 1 + 8;
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.candidate.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.legacy_connection_id_src {
            my_size += 1 + 8;
        }
        if let Some(v) = self.rendezvous.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id_dest {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.steam_id_src {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.candidate.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.legacy_connection_id_src {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.rendezvous.as_ref() {
            os.write_bytes(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientP2PConnectionInfo {
        CMsgClientP2PConnectionInfo::new()
    }

    fn clear(&mut self) {
        self.steam_id_dest = ::std::option::Option::None;
        self.steam_id_src = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.candidate = ::std::option::Option::None;
        self.legacy_connection_id_src = ::std::option::Option::None;
        self.rendezvous = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientP2PConnectionInfo {
        static instance: CMsgClientP2PConnectionInfo = CMsgClientP2PConnectionInfo {
            steam_id_dest: ::std::option::Option::None,
            steam_id_src: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            candidate: ::std::option::Option::None,
            legacy_connection_id_src: ::std::option::Option::None,
            rendezvous: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientP2PConnectionInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientP2PConnectionInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientP2PConnectionInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientP2PConnectionInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientP2PConnectionFailInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientP2PConnectionFailInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientP2PConnectionFailInfo.steam_id_dest)
    pub steam_id_dest: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientP2PConnectionFailInfo.steam_id_src)
    pub steam_id_src: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientP2PConnectionFailInfo.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientP2PConnectionFailInfo.ep2p_session_error)
    pub ep2p_session_error: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientP2PConnectionFailInfo.connection_id_dest)
    pub connection_id_dest: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientP2PConnectionFailInfo.close_reason)
    pub close_reason: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientP2PConnectionFailInfo.close_message)
    pub close_message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientP2PConnectionFailInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientP2PConnectionFailInfo {
    fn default() -> &'a CMsgClientP2PConnectionFailInfo {
        <CMsgClientP2PConnectionFailInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientP2PConnectionFailInfo {
    pub fn new() -> CMsgClientP2PConnectionFailInfo {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_dest = 1;

    pub fn steam_id_dest(&self) -> u64 {
        self.steam_id_dest.unwrap_or(0)
    }

    pub fn clear_steam_id_dest(&mut self) {
        self.steam_id_dest = ::std::option::Option::None;
    }

    pub fn has_steam_id_dest(&self) -> bool {
        self.steam_id_dest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_dest(&mut self, v: u64) {
        self.steam_id_dest = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_src = 2;

    pub fn steam_id_src(&self) -> u64 {
        self.steam_id_src.unwrap_or(0)
    }

    pub fn clear_steam_id_src(&mut self) {
        self.steam_id_src = ::std::option::Option::None;
    }

    pub fn has_steam_id_src(&self) -> bool {
        self.steam_id_src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_src(&mut self, v: u64) {
        self.steam_id_src = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 3;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 ep2p_session_error = 4;

    pub fn ep2p_session_error(&self) -> u32 {
        self.ep2p_session_error.unwrap_or(0)
    }

    pub fn clear_ep2p_session_error(&mut self) {
        self.ep2p_session_error = ::std::option::Option::None;
    }

    pub fn has_ep2p_session_error(&self) -> bool {
        self.ep2p_session_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ep2p_session_error(&mut self, v: u32) {
        self.ep2p_session_error = ::std::option::Option::Some(v);
    }

    // optional fixed64 connection_id_dest = 5;

    pub fn connection_id_dest(&self) -> u64 {
        self.connection_id_dest.unwrap_or(0)
    }

    pub fn clear_connection_id_dest(&mut self) {
        self.connection_id_dest = ::std::option::Option::None;
    }

    pub fn has_connection_id_dest(&self) -> bool {
        self.connection_id_dest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id_dest(&mut self, v: u64) {
        self.connection_id_dest = ::std::option::Option::Some(v);
    }

    // optional uint32 close_reason = 7;

    pub fn close_reason(&self) -> u32 {
        self.close_reason.unwrap_or(0)
    }

    pub fn clear_close_reason(&mut self) {
        self.close_reason = ::std::option::Option::None;
    }

    pub fn has_close_reason(&self) -> bool {
        self.close_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_close_reason(&mut self, v: u32) {
        self.close_reason = ::std::option::Option::Some(v);
    }

    // optional string close_message = 8;

    pub fn close_message(&self) -> &str {
        match self.close_message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_close_message(&mut self) {
        self.close_message = ::std::option::Option::None;
    }

    pub fn has_close_message(&self) -> bool {
        self.close_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_close_message(&mut self, v: ::std::string::String) {
        self.close_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_close_message(&mut self) -> &mut ::std::string::String {
        if self.close_message.is_none() {
            self.close_message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.close_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_close_message(&mut self) -> ::std::string::String {
        self.close_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_dest",
            |m: &CMsgClientP2PConnectionFailInfo| { &m.steam_id_dest },
            |m: &mut CMsgClientP2PConnectionFailInfo| { &mut m.steam_id_dest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_src",
            |m: &CMsgClientP2PConnectionFailInfo| { &m.steam_id_src },
            |m: &mut CMsgClientP2PConnectionFailInfo| { &mut m.steam_id_src },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientP2PConnectionFailInfo| { &m.app_id },
            |m: &mut CMsgClientP2PConnectionFailInfo| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ep2p_session_error",
            |m: &CMsgClientP2PConnectionFailInfo| { &m.ep2p_session_error },
            |m: &mut CMsgClientP2PConnectionFailInfo| { &mut m.ep2p_session_error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "connection_id_dest",
            |m: &CMsgClientP2PConnectionFailInfo| { &m.connection_id_dest },
            |m: &mut CMsgClientP2PConnectionFailInfo| { &mut m.connection_id_dest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "close_reason",
            |m: &CMsgClientP2PConnectionFailInfo| { &m.close_reason },
            |m: &mut CMsgClientP2PConnectionFailInfo| { &mut m.close_reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "close_message",
            |m: &CMsgClientP2PConnectionFailInfo| { &m.close_message },
            |m: &mut CMsgClientP2PConnectionFailInfo| { &mut m.close_message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientP2PConnectionFailInfo>(
            "CMsgClientP2PConnectionFailInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientP2PConnectionFailInfo {
    const NAME: &'static str = "CMsgClientP2PConnectionFailInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id_dest = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.steam_id_src = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.ep2p_session_error = ::std::option::Option::Some(is.read_uint32()?);
                },
                41 => {
                    self.connection_id_dest = ::std::option::Option::Some(is.read_fixed64()?);
                },
                56 => {
                    self.close_reason = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.close_message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_dest {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steam_id_src {
            my_size += 1 + 8;
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.ep2p_session_error {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.connection_id_dest {
            my_size += 1 + 8;
        }
        if let Some(v) = self.close_reason {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.close_message.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id_dest {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.steam_id_src {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.ep2p_session_error {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.connection_id_dest {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.close_reason {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.close_message.as_ref() {
            os.write_string(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientP2PConnectionFailInfo {
        CMsgClientP2PConnectionFailInfo::new()
    }

    fn clear(&mut self) {
        self.steam_id_dest = ::std::option::Option::None;
        self.steam_id_src = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.ep2p_session_error = ::std::option::Option::None;
        self.connection_id_dest = ::std::option::Option::None;
        self.close_reason = ::std::option::Option::None;
        self.close_message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientP2PConnectionFailInfo {
        static instance: CMsgClientP2PConnectionFailInfo = CMsgClientP2PConnectionFailInfo {
            steam_id_dest: ::std::option::Option::None,
            steam_id_src: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            ep2p_session_error: ::std::option::Option::None,
            connection_id_dest: ::std::option::Option::None,
            close_reason: ::std::option::Option::None,
            close_message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientP2PConnectionFailInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientP2PConnectionFailInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientP2PConnectionFailInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientP2PConnectionFailInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientNetworkingCertRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientNetworkingCertRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientNetworkingCertRequest.key_data)
    pub key_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientNetworkingCertRequest.app_id)
    pub app_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientNetworkingCertRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientNetworkingCertRequest {
    fn default() -> &'a CMsgClientNetworkingCertRequest {
        <CMsgClientNetworkingCertRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientNetworkingCertRequest {
    pub fn new() -> CMsgClientNetworkingCertRequest {
        ::std::default::Default::default()
    }

    // optional bytes key_data = 2;

    pub fn key_data(&self) -> &[u8] {
        match self.key_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_key_data(&mut self) {
        self.key_data = ::std::option::Option::None;
    }

    pub fn has_key_data(&self) -> bool {
        self.key_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.key_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.key_data.is_none() {
            self.key_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.key_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_key_data(&mut self) -> ::std::vec::Vec<u8> {
        self.key_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 app_id = 3;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key_data",
            |m: &CMsgClientNetworkingCertRequest| { &m.key_data },
            |m: &mut CMsgClientNetworkingCertRequest| { &mut m.key_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientNetworkingCertRequest| { &m.app_id },
            |m: &mut CMsgClientNetworkingCertRequest| { &mut m.app_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientNetworkingCertRequest>(
            "CMsgClientNetworkingCertRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientNetworkingCertRequest {
    const NAME: &'static str = "CMsgClientNetworkingCertRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.key_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                24 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key_data.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientNetworkingCertRequest {
        CMsgClientNetworkingCertRequest::new()
    }

    fn clear(&mut self) {
        self.key_data = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientNetworkingCertRequest {
        static instance: CMsgClientNetworkingCertRequest = CMsgClientNetworkingCertRequest {
            key_data: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientNetworkingCertRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientNetworkingCertRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientNetworkingCertRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientNetworkingCertRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientNetworkingCertReply)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientNetworkingCertReply {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientNetworkingCertReply.cert)
    pub cert: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientNetworkingCertReply.ca_key_id)
    pub ca_key_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientNetworkingCertReply.ca_signature)
    pub ca_signature: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientNetworkingCertReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientNetworkingCertReply {
    fn default() -> &'a CMsgClientNetworkingCertReply {
        <CMsgClientNetworkingCertReply as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientNetworkingCertReply {
    pub fn new() -> CMsgClientNetworkingCertReply {
        ::std::default::Default::default()
    }

    // optional bytes cert = 4;

    pub fn cert(&self) -> &[u8] {
        match self.cert.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_cert(&mut self) {
        self.cert = ::std::option::Option::None;
    }

    pub fn has_cert(&self) -> bool {
        self.cert.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cert(&mut self, v: ::std::vec::Vec<u8>) {
        self.cert = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cert(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.cert.is_none() {
            self.cert = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.cert.as_mut().unwrap()
    }

    // Take field
    pub fn take_cert(&mut self) -> ::std::vec::Vec<u8> {
        self.cert.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed64 ca_key_id = 5;

    pub fn ca_key_id(&self) -> u64 {
        self.ca_key_id.unwrap_or(0)
    }

    pub fn clear_ca_key_id(&mut self) {
        self.ca_key_id = ::std::option::Option::None;
    }

    pub fn has_ca_key_id(&self) -> bool {
        self.ca_key_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ca_key_id(&mut self, v: u64) {
        self.ca_key_id = ::std::option::Option::Some(v);
    }

    // optional bytes ca_signature = 6;

    pub fn ca_signature(&self) -> &[u8] {
        match self.ca_signature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_ca_signature(&mut self) {
        self.ca_signature = ::std::option::Option::None;
    }

    pub fn has_ca_signature(&self) -> bool {
        self.ca_signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ca_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.ca_signature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ca_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ca_signature.is_none() {
            self.ca_signature = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.ca_signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_ca_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.ca_signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cert",
            |m: &CMsgClientNetworkingCertReply| { &m.cert },
            |m: &mut CMsgClientNetworkingCertReply| { &mut m.cert },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ca_key_id",
            |m: &CMsgClientNetworkingCertReply| { &m.ca_key_id },
            |m: &mut CMsgClientNetworkingCertReply| { &mut m.ca_key_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ca_signature",
            |m: &CMsgClientNetworkingCertReply| { &m.ca_signature },
            |m: &mut CMsgClientNetworkingCertReply| { &mut m.ca_signature },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientNetworkingCertReply>(
            "CMsgClientNetworkingCertReply",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientNetworkingCertReply {
    const NAME: &'static str = "CMsgClientNetworkingCertReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                34 => {
                    self.cert = ::std::option::Option::Some(is.read_bytes()?);
                },
                41 => {
                    self.ca_key_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                50 => {
                    self.ca_signature = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cert.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.ca_key_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.ca_signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cert.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.ca_key_id {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.ca_signature.as_ref() {
            os.write_bytes(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientNetworkingCertReply {
        CMsgClientNetworkingCertReply::new()
    }

    fn clear(&mut self) {
        self.cert = ::std::option::Option::None;
        self.ca_key_id = ::std::option::Option::None;
        self.ca_signature = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientNetworkingCertReply {
        static instance: CMsgClientNetworkingCertReply = CMsgClientNetworkingCertReply {
            cert: ::std::option::Option::None,
            ca_key_id: ::std::option::Option::None,
            ca_signature: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientNetworkingCertReply {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientNetworkingCertReply").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientNetworkingCertReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientNetworkingCertReply {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientNetworkingMobileCertRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientNetworkingMobileCertRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientNetworkingMobileCertRequest.app_id)
    pub app_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientNetworkingMobileCertRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientNetworkingMobileCertRequest {
    fn default() -> &'a CMsgClientNetworkingMobileCertRequest {
        <CMsgClientNetworkingMobileCertRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientNetworkingMobileCertRequest {
    pub fn new() -> CMsgClientNetworkingMobileCertRequest {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientNetworkingMobileCertRequest| { &m.app_id },
            |m: &mut CMsgClientNetworkingMobileCertRequest| { &mut m.app_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientNetworkingMobileCertRequest>(
            "CMsgClientNetworkingMobileCertRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientNetworkingMobileCertRequest {
    const NAME: &'static str = "CMsgClientNetworkingMobileCertRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientNetworkingMobileCertRequest {
        CMsgClientNetworkingMobileCertRequest::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientNetworkingMobileCertRequest {
        static instance: CMsgClientNetworkingMobileCertRequest = CMsgClientNetworkingMobileCertRequest {
            app_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientNetworkingMobileCertRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientNetworkingMobileCertRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientNetworkingMobileCertRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientNetworkingMobileCertRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientNetworkingMobileCertReply)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientNetworkingMobileCertReply {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientNetworkingMobileCertReply.encoded_cert)
    pub encoded_cert: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientNetworkingMobileCertReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientNetworkingMobileCertReply {
    fn default() -> &'a CMsgClientNetworkingMobileCertReply {
        <CMsgClientNetworkingMobileCertReply as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientNetworkingMobileCertReply {
    pub fn new() -> CMsgClientNetworkingMobileCertReply {
        ::std::default::Default::default()
    }

    // optional string encoded_cert = 1;

    pub fn encoded_cert(&self) -> &str {
        match self.encoded_cert.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_encoded_cert(&mut self) {
        self.encoded_cert = ::std::option::Option::None;
    }

    pub fn has_encoded_cert(&self) -> bool {
        self.encoded_cert.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encoded_cert(&mut self, v: ::std::string::String) {
        self.encoded_cert = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encoded_cert(&mut self) -> &mut ::std::string::String {
        if self.encoded_cert.is_none() {
            self.encoded_cert = ::std::option::Option::Some(::std::string::String::new());
        }
        self.encoded_cert.as_mut().unwrap()
    }

    // Take field
    pub fn take_encoded_cert(&mut self) -> ::std::string::String {
        self.encoded_cert.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "encoded_cert",
            |m: &CMsgClientNetworkingMobileCertReply| { &m.encoded_cert },
            |m: &mut CMsgClientNetworkingMobileCertReply| { &mut m.encoded_cert },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientNetworkingMobileCertReply>(
            "CMsgClientNetworkingMobileCertReply",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientNetworkingMobileCertReply {
    const NAME: &'static str = "CMsgClientNetworkingMobileCertReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.encoded_cert = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.encoded_cert.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.encoded_cert.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientNetworkingMobileCertReply {
        CMsgClientNetworkingMobileCertReply::new()
    }

    fn clear(&mut self) {
        self.encoded_cert = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientNetworkingMobileCertReply {
        static instance: CMsgClientNetworkingMobileCertReply = CMsgClientNetworkingMobileCertReply {
            encoded_cert: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientNetworkingMobileCertReply {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientNetworkingMobileCertReply").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientNetworkingMobileCertReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientNetworkingMobileCertReply {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientGetAppOwnershipTicket)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetAppOwnershipTicket {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetAppOwnershipTicket.app_id)
    pub app_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetAppOwnershipTicket.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetAppOwnershipTicket {
    fn default() -> &'a CMsgClientGetAppOwnershipTicket {
        <CMsgClientGetAppOwnershipTicket as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetAppOwnershipTicket {
    pub fn new() -> CMsgClientGetAppOwnershipTicket {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientGetAppOwnershipTicket| { &m.app_id },
            |m: &mut CMsgClientGetAppOwnershipTicket| { &mut m.app_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientGetAppOwnershipTicket>(
            "CMsgClientGetAppOwnershipTicket",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientGetAppOwnershipTicket {
    const NAME: &'static str = "CMsgClientGetAppOwnershipTicket";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetAppOwnershipTicket {
        CMsgClientGetAppOwnershipTicket::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetAppOwnershipTicket {
        static instance: CMsgClientGetAppOwnershipTicket = CMsgClientGetAppOwnershipTicket {
            app_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientGetAppOwnershipTicket {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientGetAppOwnershipTicket").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientGetAppOwnershipTicket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetAppOwnershipTicket {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientGetAppOwnershipTicketResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetAppOwnershipTicketResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetAppOwnershipTicketResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGetAppOwnershipTicketResponse.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGetAppOwnershipTicketResponse.ticket)
    pub ticket: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetAppOwnershipTicketResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetAppOwnershipTicketResponse {
    fn default() -> &'a CMsgClientGetAppOwnershipTicketResponse {
        <CMsgClientGetAppOwnershipTicketResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetAppOwnershipTicketResponse {
    pub fn new() -> CMsgClientGetAppOwnershipTicketResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional bytes ticket = 3;

    pub fn ticket(&self) -> &[u8] {
        match self.ticket.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_ticket(&mut self) {
        self.ticket = ::std::option::Option::None;
    }

    pub fn has_ticket(&self) -> bool {
        self.ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket(&mut self, v: ::std::vec::Vec<u8>) {
        self.ticket = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticket(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ticket.is_none() {
            self.ticket = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_ticket(&mut self) -> ::std::vec::Vec<u8> {
        self.ticket.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientGetAppOwnershipTicketResponse| { &m.eresult },
            |m: &mut CMsgClientGetAppOwnershipTicketResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientGetAppOwnershipTicketResponse| { &m.app_id },
            |m: &mut CMsgClientGetAppOwnershipTicketResponse| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ticket",
            |m: &CMsgClientGetAppOwnershipTicketResponse| { &m.ticket },
            |m: &mut CMsgClientGetAppOwnershipTicketResponse| { &mut m.ticket },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientGetAppOwnershipTicketResponse>(
            "CMsgClientGetAppOwnershipTicketResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientGetAppOwnershipTicketResponse {
    const NAME: &'static str = "CMsgClientGetAppOwnershipTicketResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.ticket = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.ticket.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.ticket.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetAppOwnershipTicketResponse {
        CMsgClientGetAppOwnershipTicketResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.ticket = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetAppOwnershipTicketResponse {
        static instance: CMsgClientGetAppOwnershipTicketResponse = CMsgClientGetAppOwnershipTicketResponse {
            eresult: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            ticket: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientGetAppOwnershipTicketResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientGetAppOwnershipTicketResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientGetAppOwnershipTicketResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetAppOwnershipTicketResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientSessionToken)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientSessionToken {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientSessionToken.token)
    pub token: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientSessionToken.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientSessionToken {
    fn default() -> &'a CMsgClientSessionToken {
        <CMsgClientSessionToken as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientSessionToken {
    pub fn new() -> CMsgClientSessionToken {
        ::std::default::Default::default()
    }

    // optional uint64 token = 1;

    pub fn token(&self) -> u64 {
        self.token.unwrap_or(0)
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: u64) {
        self.token = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "token",
            |m: &CMsgClientSessionToken| { &m.token },
            |m: &mut CMsgClientSessionToken| { &mut m.token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientSessionToken>(
            "CMsgClientSessionToken",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientSessionToken {
    const NAME: &'static str = "CMsgClientSessionToken";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.token = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.token {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.token {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientSessionToken {
        CMsgClientSessionToken::new()
    }

    fn clear(&mut self) {
        self.token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientSessionToken {
        static instance: CMsgClientSessionToken = CMsgClientSessionToken {
            token: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientSessionToken {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientSessionToken").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientSessionToken {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientSessionToken {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientGameConnectTokens)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGameConnectTokens {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGameConnectTokens.max_tokens_to_keep)
    pub max_tokens_to_keep: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGameConnectTokens.tokens)
    pub tokens: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGameConnectTokens.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGameConnectTokens {
    fn default() -> &'a CMsgClientGameConnectTokens {
        <CMsgClientGameConnectTokens as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGameConnectTokens {
    pub fn new() -> CMsgClientGameConnectTokens {
        ::std::default::Default::default()
    }

    // optional uint32 max_tokens_to_keep = 1;

    pub fn max_tokens_to_keep(&self) -> u32 {
        self.max_tokens_to_keep.unwrap_or(10u32)
    }

    pub fn clear_max_tokens_to_keep(&mut self) {
        self.max_tokens_to_keep = ::std::option::Option::None;
    }

    pub fn has_max_tokens_to_keep(&self) -> bool {
        self.max_tokens_to_keep.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_tokens_to_keep(&mut self, v: u32) {
        self.max_tokens_to_keep = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_tokens_to_keep",
            |m: &CMsgClientGameConnectTokens| { &m.max_tokens_to_keep },
            |m: &mut CMsgClientGameConnectTokens| { &mut m.max_tokens_to_keep },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tokens",
            |m: &CMsgClientGameConnectTokens| { &m.tokens },
            |m: &mut CMsgClientGameConnectTokens| { &mut m.tokens },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientGameConnectTokens>(
            "CMsgClientGameConnectTokens",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientGameConnectTokens {
    const NAME: &'static str = "CMsgClientGameConnectTokens";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.max_tokens_to_keep = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.tokens.push(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.max_tokens_to_keep {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.tokens {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.max_tokens_to_keep {
            os.write_uint32(1, v)?;
        }
        for v in &self.tokens {
            os.write_bytes(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGameConnectTokens {
        CMsgClientGameConnectTokens::new()
    }

    fn clear(&mut self) {
        self.max_tokens_to_keep = ::std::option::Option::None;
        self.tokens.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGameConnectTokens {
        static instance: CMsgClientGameConnectTokens = CMsgClientGameConnectTokens {
            max_tokens_to_keep: ::std::option::Option::None,
            tokens: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientGameConnectTokens {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientGameConnectTokens").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientGameConnectTokens {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGameConnectTokens {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGSServerType)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGSServerType {
    // message fields
    // @@protoc_insertion_point(field:CMsgGSServerType.app_id_served)
    pub app_id_served: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGSServerType.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGSServerType.deprecated_game_ip_address)
    pub deprecated_game_ip_address: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGSServerType.game_port)
    pub game_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGSServerType.game_dir)
    pub game_dir: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGSServerType.game_version)
    pub game_version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGSServerType.game_query_port)
    pub game_query_port: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGSServerType.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGSServerType {
    fn default() -> &'a CMsgGSServerType {
        <CMsgGSServerType as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSServerType {
    pub fn new() -> CMsgGSServerType {
        ::std::default::Default::default()
    }

    // optional uint32 app_id_served = 1;

    pub fn app_id_served(&self) -> u32 {
        self.app_id_served.unwrap_or(0)
    }

    pub fn clear_app_id_served(&mut self) {
        self.app_id_served = ::std::option::Option::None;
    }

    pub fn has_app_id_served(&self) -> bool {
        self.app_id_served.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id_served(&mut self, v: u32) {
        self.app_id_served = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 2;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 deprecated_game_ip_address = 3;

    pub fn deprecated_game_ip_address(&self) -> u32 {
        self.deprecated_game_ip_address.unwrap_or(0)
    }

    pub fn clear_deprecated_game_ip_address(&mut self) {
        self.deprecated_game_ip_address = ::std::option::Option::None;
    }

    pub fn has_deprecated_game_ip_address(&self) -> bool {
        self.deprecated_game_ip_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_game_ip_address(&mut self, v: u32) {
        self.deprecated_game_ip_address = ::std::option::Option::Some(v);
    }

    // optional uint32 game_port = 4;

    pub fn game_port(&self) -> u32 {
        self.game_port.unwrap_or(0)
    }

    pub fn clear_game_port(&mut self) {
        self.game_port = ::std::option::Option::None;
    }

    pub fn has_game_port(&self) -> bool {
        self.game_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_port(&mut self, v: u32) {
        self.game_port = ::std::option::Option::Some(v);
    }

    // optional string game_dir = 5;

    pub fn game_dir(&self) -> &str {
        match self.game_dir.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_dir(&mut self) {
        self.game_dir = ::std::option::Option::None;
    }

    pub fn has_game_dir(&self) -> bool {
        self.game_dir.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_dir(&mut self, v: ::std::string::String) {
        self.game_dir = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_dir(&mut self) -> &mut ::std::string::String {
        if self.game_dir.is_none() {
            self.game_dir = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_dir.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_dir(&mut self) -> ::std::string::String {
        self.game_dir.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string game_version = 6;

    pub fn game_version(&self) -> &str {
        match self.game_version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_version(&mut self) {
        self.game_version = ::std::option::Option::None;
    }

    pub fn has_game_version(&self) -> bool {
        self.game_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_version(&mut self, v: ::std::string::String) {
        self.game_version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_version(&mut self) -> &mut ::std::string::String {
        if self.game_version.is_none() {
            self.game_version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_version(&mut self) -> ::std::string::String {
        self.game_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 game_query_port = 7;

    pub fn game_query_port(&self) -> u32 {
        self.game_query_port.unwrap_or(0)
    }

    pub fn clear_game_query_port(&mut self) {
        self.game_query_port = ::std::option::Option::None;
    }

    pub fn has_game_query_port(&self) -> bool {
        self.game_query_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_query_port(&mut self, v: u32) {
        self.game_query_port = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id_served",
            |m: &CMsgGSServerType| { &m.app_id_served },
            |m: &mut CMsgGSServerType| { &mut m.app_id_served },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CMsgGSServerType| { &m.flags },
            |m: &mut CMsgGSServerType| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deprecated_game_ip_address",
            |m: &CMsgGSServerType| { &m.deprecated_game_ip_address },
            |m: &mut CMsgGSServerType| { &mut m.deprecated_game_ip_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_port",
            |m: &CMsgGSServerType| { &m.game_port },
            |m: &mut CMsgGSServerType| { &mut m.game_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_dir",
            |m: &CMsgGSServerType| { &m.game_dir },
            |m: &mut CMsgGSServerType| { &mut m.game_dir },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_version",
            |m: &CMsgGSServerType| { &m.game_version },
            |m: &mut CMsgGSServerType| { &mut m.game_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_query_port",
            |m: &CMsgGSServerType| { &m.game_query_port },
            |m: &mut CMsgGSServerType| { &mut m.game_query_port },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGSServerType>(
            "CMsgGSServerType",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGSServerType {
    const NAME: &'static str = "CMsgGSServerType";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id_served = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.deprecated_game_ip_address = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.game_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.game_dir = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.game_version = ::std::option::Option::Some(is.read_string()?);
                },
                56 => {
                    self.game_query_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id_served {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.deprecated_game_ip_address {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.game_port {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.game_dir.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.game_version.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.game_query_port {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id_served {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.deprecated_game_ip_address {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_port {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.game_dir.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.game_version.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.game_query_port {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGSServerType {
        CMsgGSServerType::new()
    }

    fn clear(&mut self) {
        self.app_id_served = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.deprecated_game_ip_address = ::std::option::Option::None;
        self.game_port = ::std::option::Option::None;
        self.game_dir = ::std::option::Option::None;
        self.game_version = ::std::option::Option::None;
        self.game_query_port = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGSServerType {
        static instance: CMsgGSServerType = CMsgGSServerType {
            app_id_served: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            deprecated_game_ip_address: ::std::option::Option::None,
            game_port: ::std::option::Option::None,
            game_dir: ::std::option::Option::None,
            game_version: ::std::option::Option::None,
            game_query_port: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGSServerType {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGSServerType").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGSServerType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGSServerType {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGSStatusReply)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGSStatusReply {
    // message fields
    // @@protoc_insertion_point(field:CMsgGSStatusReply.is_secure)
    pub is_secure: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGSStatusReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGSStatusReply {
    fn default() -> &'a CMsgGSStatusReply {
        <CMsgGSStatusReply as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSStatusReply {
    pub fn new() -> CMsgGSStatusReply {
        ::std::default::Default::default()
    }

    // optional bool is_secure = 1;

    pub fn is_secure(&self) -> bool {
        self.is_secure.unwrap_or(false)
    }

    pub fn clear_is_secure(&mut self) {
        self.is_secure = ::std::option::Option::None;
    }

    pub fn has_is_secure(&self) -> bool {
        self.is_secure.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_secure(&mut self, v: bool) {
        self.is_secure = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_secure",
            |m: &CMsgGSStatusReply| { &m.is_secure },
            |m: &mut CMsgGSStatusReply| { &mut m.is_secure },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGSStatusReply>(
            "CMsgGSStatusReply",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGSStatusReply {
    const NAME: &'static str = "CMsgGSStatusReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_secure = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.is_secure {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.is_secure {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGSStatusReply {
        CMsgGSStatusReply::new()
    }

    fn clear(&mut self) {
        self.is_secure = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGSStatusReply {
        static instance: CMsgGSStatusReply = CMsgGSStatusReply {
            is_secure: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGSStatusReply {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGSStatusReply").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGSStatusReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGSStatusReply {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGSPlayerList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGSPlayerList {
    // message fields
    // @@protoc_insertion_point(field:CMsgGSPlayerList.players)
    pub players: ::std::vec::Vec<cmsg_gsplayer_list::Player>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGSPlayerList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGSPlayerList {
    fn default() -> &'a CMsgGSPlayerList {
        <CMsgGSPlayerList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSPlayerList {
    pub fn new() -> CMsgGSPlayerList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "players",
            |m: &CMsgGSPlayerList| { &m.players },
            |m: &mut CMsgGSPlayerList| { &mut m.players },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGSPlayerList>(
            "CMsgGSPlayerList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGSPlayerList {
    const NAME: &'static str = "CMsgGSPlayerList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.players.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.players {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGSPlayerList {
        CMsgGSPlayerList::new()
    }

    fn clear(&mut self) {
        self.players.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGSPlayerList {
        static instance: CMsgGSPlayerList = CMsgGSPlayerList {
            players: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGSPlayerList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGSPlayerList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGSPlayerList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGSPlayerList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGSPlayerList`
pub mod cmsg_gsplayer_list {
    // @@protoc_insertion_point(message:CMsgGSPlayerList.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:CMsgGSPlayerList.Player.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgGSPlayerList.Player.deprecated_public_ip)
        pub deprecated_public_ip: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGSPlayerList.Player.token)
        pub token: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:CMsgGSPlayerList.Player.public_ip)
        pub public_ip: ::protobuf::MessageField<super::super::steammessages_base::CMsgIPAddress>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGSPlayerList.Player.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional uint64 steam_id = 1;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional uint32 deprecated_public_ip = 2;

        pub fn deprecated_public_ip(&self) -> u32 {
            self.deprecated_public_ip.unwrap_or(0)
        }

        pub fn clear_deprecated_public_ip(&mut self) {
            self.deprecated_public_ip = ::std::option::Option::None;
        }

        pub fn has_deprecated_public_ip(&self) -> bool {
            self.deprecated_public_ip.is_some()
        }

        // Param is passed by value, moved
        pub fn set_deprecated_public_ip(&mut self, v: u32) {
            self.deprecated_public_ip = ::std::option::Option::Some(v);
        }

        // optional bytes token = 3;

        pub fn token(&self) -> &[u8] {
            match self.token.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_token(&mut self) {
            self.token = ::std::option::Option::None;
        }

        pub fn has_token(&self) -> bool {
            self.token.is_some()
        }

        // Param is passed by value, moved
        pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
            self.token = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.token.is_none() {
                self.token = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.token.as_mut().unwrap()
        }

        // Take field
        pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
            self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "steam_id",
                |m: &Player| { &m.steam_id },
                |m: &mut Player| { &mut m.steam_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "deprecated_public_ip",
                |m: &Player| { &m.deprecated_public_ip },
                |m: &mut Player| { &mut m.deprecated_public_ip },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "token",
                |m: &Player| { &m.token },
                |m: &mut Player| { &mut m.token },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::steammessages_base::CMsgIPAddress>(
                "public_ip",
                |m: &Player| { &m.public_ip },
                |m: &mut Player| { &mut m.public_ip },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Player>(
                "CMsgGSPlayerList.Player",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.steam_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.deprecated_public_ip = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.token = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    34 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.public_ip)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.deprecated_public_ip {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.token.as_ref() {
                my_size += ::protobuf::rt::bytes_size(3, &v);
            }
            if let Some(v) = self.public_ip.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.steam_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.deprecated_public_ip {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.token.as_ref() {
                os.write_bytes(3, v)?;
            }
            if let Some(v) = self.public_ip.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.deprecated_public_ip = ::std::option::Option::None;
            self.token = ::std::option::Option::None;
            self.public_ip.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                steam_id: ::std::option::Option::None,
                deprecated_public_ip: ::std::option::Option::None,
                token: ::std::option::Option::None,
                public_ip: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Player {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGSPlayerList.Player").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Player {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Player {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgGSUserPlaying)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGSUserPlaying {
    // message fields
    // @@protoc_insertion_point(field:CMsgGSUserPlaying.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGSUserPlaying.deprecated_public_ip)
    pub deprecated_public_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGSUserPlaying.token)
    pub token: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgGSUserPlaying.public_ip)
    pub public_ip: ::protobuf::MessageField<super::steammessages_base::CMsgIPAddress>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGSUserPlaying.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGSUserPlaying {
    fn default() -> &'a CMsgGSUserPlaying {
        <CMsgGSUserPlaying as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSUserPlaying {
    pub fn new() -> CMsgGSUserPlaying {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 deprecated_public_ip = 2;

    pub fn deprecated_public_ip(&self) -> u32 {
        self.deprecated_public_ip.unwrap_or(0)
    }

    pub fn clear_deprecated_public_ip(&mut self) {
        self.deprecated_public_ip = ::std::option::Option::None;
    }

    pub fn has_deprecated_public_ip(&self) -> bool {
        self.deprecated_public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_public_ip(&mut self, v: u32) {
        self.deprecated_public_ip = ::std::option::Option::Some(v);
    }

    // optional bytes token = 3;

    pub fn token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.token.is_none() {
            self.token = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
        self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id",
            |m: &CMsgGSUserPlaying| { &m.steam_id },
            |m: &mut CMsgGSUserPlaying| { &mut m.steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deprecated_public_ip",
            |m: &CMsgGSUserPlaying| { &m.deprecated_public_ip },
            |m: &mut CMsgGSUserPlaying| { &mut m.deprecated_public_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "token",
            |m: &CMsgGSUserPlaying| { &m.token },
            |m: &mut CMsgGSUserPlaying| { &mut m.token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steammessages_base::CMsgIPAddress>(
            "public_ip",
            |m: &CMsgGSUserPlaying| { &m.public_ip },
            |m: &mut CMsgGSUserPlaying| { &mut m.public_ip },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGSUserPlaying>(
            "CMsgGSUserPlaying",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGSUserPlaying {
    const NAME: &'static str = "CMsgGSUserPlaying";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.deprecated_public_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.token = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.public_ip)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.deprecated_public_ip {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.public_ip.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.deprecated_public_ip {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.token.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.public_ip.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGSUserPlaying {
        CMsgGSUserPlaying::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.deprecated_public_ip = ::std::option::Option::None;
        self.token = ::std::option::Option::None;
        self.public_ip.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGSUserPlaying {
        static instance: CMsgGSUserPlaying = CMsgGSUserPlaying {
            steam_id: ::std::option::Option::None,
            deprecated_public_ip: ::std::option::Option::None,
            token: ::std::option::Option::None,
            public_ip: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGSUserPlaying {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGSUserPlaying").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGSUserPlaying {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGSUserPlaying {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGSDisconnectNotice)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGSDisconnectNotice {
    // message fields
    // @@protoc_insertion_point(field:CMsgGSDisconnectNotice.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGSDisconnectNotice.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGSDisconnectNotice {
    fn default() -> &'a CMsgGSDisconnectNotice {
        <CMsgGSDisconnectNotice as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSDisconnectNotice {
    pub fn new() -> CMsgGSDisconnectNotice {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id",
            |m: &CMsgGSDisconnectNotice| { &m.steam_id },
            |m: &mut CMsgGSDisconnectNotice| { &mut m.steam_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGSDisconnectNotice>(
            "CMsgGSDisconnectNotice",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGSDisconnectNotice {
    const NAME: &'static str = "CMsgGSDisconnectNotice";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGSDisconnectNotice {
        CMsgGSDisconnectNotice::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGSDisconnectNotice {
        static instance: CMsgGSDisconnectNotice = CMsgGSDisconnectNotice {
            steam_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGSDisconnectNotice {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGSDisconnectNotice").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGSDisconnectNotice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGSDisconnectNotice {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientGamesPlayed)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGamesPlayed {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGamesPlayed.games_played)
    pub games_played: ::std::vec::Vec<cmsg_client_games_played::GamePlayed>,
    // @@protoc_insertion_point(field:CMsgClientGamesPlayed.client_os_type)
    pub client_os_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGamesPlayed.cloud_gaming_platform)
    pub cloud_gaming_platform: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGamesPlayed.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGamesPlayed {
    fn default() -> &'a CMsgClientGamesPlayed {
        <CMsgClientGamesPlayed as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGamesPlayed {
    pub fn new() -> CMsgClientGamesPlayed {
        ::std::default::Default::default()
    }

    // optional uint32 client_os_type = 2;

    pub fn client_os_type(&self) -> u32 {
        self.client_os_type.unwrap_or(0)
    }

    pub fn clear_client_os_type(&mut self) {
        self.client_os_type = ::std::option::Option::None;
    }

    pub fn has_client_os_type(&self) -> bool {
        self.client_os_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_os_type(&mut self, v: u32) {
        self.client_os_type = ::std::option::Option::Some(v);
    }

    // optional uint32 cloud_gaming_platform = 3;

    pub fn cloud_gaming_platform(&self) -> u32 {
        self.cloud_gaming_platform.unwrap_or(0)
    }

    pub fn clear_cloud_gaming_platform(&mut self) {
        self.cloud_gaming_platform = ::std::option::Option::None;
    }

    pub fn has_cloud_gaming_platform(&self) -> bool {
        self.cloud_gaming_platform.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cloud_gaming_platform(&mut self, v: u32) {
        self.cloud_gaming_platform = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "games_played",
            |m: &CMsgClientGamesPlayed| { &m.games_played },
            |m: &mut CMsgClientGamesPlayed| { &mut m.games_played },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_os_type",
            |m: &CMsgClientGamesPlayed| { &m.client_os_type },
            |m: &mut CMsgClientGamesPlayed| { &mut m.client_os_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cloud_gaming_platform",
            |m: &CMsgClientGamesPlayed| { &m.cloud_gaming_platform },
            |m: &mut CMsgClientGamesPlayed| { &mut m.cloud_gaming_platform },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientGamesPlayed>(
            "CMsgClientGamesPlayed",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientGamesPlayed {
    const NAME: &'static str = "CMsgClientGamesPlayed";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.games_played.push(is.read_message()?);
                },
                16 => {
                    self.client_os_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.cloud_gaming_platform = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.games_played {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.client_os_type {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.cloud_gaming_platform {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.games_played {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.client_os_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.cloud_gaming_platform {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGamesPlayed {
        CMsgClientGamesPlayed::new()
    }

    fn clear(&mut self) {
        self.games_played.clear();
        self.client_os_type = ::std::option::Option::None;
        self.cloud_gaming_platform = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGamesPlayed {
        static instance: CMsgClientGamesPlayed = CMsgClientGamesPlayed {
            games_played: ::std::vec::Vec::new(),
            client_os_type: ::std::option::Option::None,
            cloud_gaming_platform: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientGamesPlayed {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientGamesPlayed").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientGamesPlayed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGamesPlayed {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientGamesPlayed`
pub mod cmsg_client_games_played {
    // @@protoc_insertion_point(message:CMsgClientGamesPlayed.GamePlayed)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct GamePlayed {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.steam_id_gs)
        pub steam_id_gs: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.game_id)
        pub game_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.deprecated_game_ip_address)
        pub deprecated_game_ip_address: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.game_port)
        pub game_port: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.is_secure)
        pub is_secure: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.token)
        pub token: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.game_extra_info)
        pub game_extra_info: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.game_data_blob)
        pub game_data_blob: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.process_id)
        pub process_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.streaming_provider_id)
        pub streaming_provider_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.game_flags)
        pub game_flags: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.owner_id)
        pub owner_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.vr_hmd_vendor)
        pub vr_hmd_vendor: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.vr_hmd_model)
        pub vr_hmd_model: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.launch_option_type)
        pub launch_option_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.primary_controller_type)
        pub primary_controller_type: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.primary_steam_controller_serial)
        pub primary_steam_controller_serial: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.total_steam_controller_count)
        pub total_steam_controller_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.total_non_steam_controller_count)
        pub total_non_steam_controller_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.controller_workshop_file_id)
        pub controller_workshop_file_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.launch_source)
        pub launch_source: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.vr_hmd_runtime)
        pub vr_hmd_runtime: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.game_ip_address)
        pub game_ip_address: ::protobuf::MessageField<super::super::steammessages_base::CMsgIPAddress>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.controller_connection_type)
        pub controller_connection_type: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientGamesPlayed.GamePlayed.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GamePlayed {
        fn default() -> &'a GamePlayed {
            <GamePlayed as ::protobuf::Message>::default_instance()
        }
    }

    impl GamePlayed {
        pub fn new() -> GamePlayed {
            ::std::default::Default::default()
        }

        // optional uint64 steam_id_gs = 1;

        pub fn steam_id_gs(&self) -> u64 {
            self.steam_id_gs.unwrap_or(0)
        }

        pub fn clear_steam_id_gs(&mut self) {
            self.steam_id_gs = ::std::option::Option::None;
        }

        pub fn has_steam_id_gs(&self) -> bool {
            self.steam_id_gs.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id_gs(&mut self, v: u64) {
            self.steam_id_gs = ::std::option::Option::Some(v);
        }

        // optional fixed64 game_id = 2;

        pub fn game_id(&self) -> u64 {
            self.game_id.unwrap_or(0)
        }

        pub fn clear_game_id(&mut self) {
            self.game_id = ::std::option::Option::None;
        }

        pub fn has_game_id(&self) -> bool {
            self.game_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_id(&mut self, v: u64) {
            self.game_id = ::std::option::Option::Some(v);
        }

        // optional uint32 deprecated_game_ip_address = 3;

        pub fn deprecated_game_ip_address(&self) -> u32 {
            self.deprecated_game_ip_address.unwrap_or(0)
        }

        pub fn clear_deprecated_game_ip_address(&mut self) {
            self.deprecated_game_ip_address = ::std::option::Option::None;
        }

        pub fn has_deprecated_game_ip_address(&self) -> bool {
            self.deprecated_game_ip_address.is_some()
        }

        // Param is passed by value, moved
        pub fn set_deprecated_game_ip_address(&mut self, v: u32) {
            self.deprecated_game_ip_address = ::std::option::Option::Some(v);
        }

        // optional uint32 game_port = 4;

        pub fn game_port(&self) -> u32 {
            self.game_port.unwrap_or(0)
        }

        pub fn clear_game_port(&mut self) {
            self.game_port = ::std::option::Option::None;
        }

        pub fn has_game_port(&self) -> bool {
            self.game_port.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_port(&mut self, v: u32) {
            self.game_port = ::std::option::Option::Some(v);
        }

        // optional bool is_secure = 5;

        pub fn is_secure(&self) -> bool {
            self.is_secure.unwrap_or(false)
        }

        pub fn clear_is_secure(&mut self) {
            self.is_secure = ::std::option::Option::None;
        }

        pub fn has_is_secure(&self) -> bool {
            self.is_secure.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_secure(&mut self, v: bool) {
            self.is_secure = ::std::option::Option::Some(v);
        }

        // optional bytes token = 6;

        pub fn token(&self) -> &[u8] {
            match self.token.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_token(&mut self) {
            self.token = ::std::option::Option::None;
        }

        pub fn has_token(&self) -> bool {
            self.token.is_some()
        }

        // Param is passed by value, moved
        pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
            self.token = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.token.is_none() {
                self.token = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.token.as_mut().unwrap()
        }

        // Take field
        pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
            self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional string game_extra_info = 7;

        pub fn game_extra_info(&self) -> &str {
            match self.game_extra_info.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_game_extra_info(&mut self) {
            self.game_extra_info = ::std::option::Option::None;
        }

        pub fn has_game_extra_info(&self) -> bool {
            self.game_extra_info.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_extra_info(&mut self, v: ::std::string::String) {
            self.game_extra_info = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_game_extra_info(&mut self) -> &mut ::std::string::String {
            if self.game_extra_info.is_none() {
                self.game_extra_info = ::std::option::Option::Some(::std::string::String::new());
            }
            self.game_extra_info.as_mut().unwrap()
        }

        // Take field
        pub fn take_game_extra_info(&mut self) -> ::std::string::String {
            self.game_extra_info.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bytes game_data_blob = 8;

        pub fn game_data_blob(&self) -> &[u8] {
            match self.game_data_blob.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_game_data_blob(&mut self) {
            self.game_data_blob = ::std::option::Option::None;
        }

        pub fn has_game_data_blob(&self) -> bool {
            self.game_data_blob.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_data_blob(&mut self, v: ::std::vec::Vec<u8>) {
            self.game_data_blob = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_game_data_blob(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.game_data_blob.is_none() {
                self.game_data_blob = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.game_data_blob.as_mut().unwrap()
        }

        // Take field
        pub fn take_game_data_blob(&mut self) -> ::std::vec::Vec<u8> {
            self.game_data_blob.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional uint32 process_id = 9;

        pub fn process_id(&self) -> u32 {
            self.process_id.unwrap_or(0)
        }

        pub fn clear_process_id(&mut self) {
            self.process_id = ::std::option::Option::None;
        }

        pub fn has_process_id(&self) -> bool {
            self.process_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_process_id(&mut self, v: u32) {
            self.process_id = ::std::option::Option::Some(v);
        }

        // optional uint32 streaming_provider_id = 10;

        pub fn streaming_provider_id(&self) -> u32 {
            self.streaming_provider_id.unwrap_or(0)
        }

        pub fn clear_streaming_provider_id(&mut self) {
            self.streaming_provider_id = ::std::option::Option::None;
        }

        pub fn has_streaming_provider_id(&self) -> bool {
            self.streaming_provider_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_streaming_provider_id(&mut self, v: u32) {
            self.streaming_provider_id = ::std::option::Option::Some(v);
        }

        // optional uint32 game_flags = 11;

        pub fn game_flags(&self) -> u32 {
            self.game_flags.unwrap_or(0)
        }

        pub fn clear_game_flags(&mut self) {
            self.game_flags = ::std::option::Option::None;
        }

        pub fn has_game_flags(&self) -> bool {
            self.game_flags.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_flags(&mut self, v: u32) {
            self.game_flags = ::std::option::Option::Some(v);
        }

        // optional uint32 owner_id = 12;

        pub fn owner_id(&self) -> u32 {
            self.owner_id.unwrap_or(0)
        }

        pub fn clear_owner_id(&mut self) {
            self.owner_id = ::std::option::Option::None;
        }

        pub fn has_owner_id(&self) -> bool {
            self.owner_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_owner_id(&mut self, v: u32) {
            self.owner_id = ::std::option::Option::Some(v);
        }

        // optional string vr_hmd_vendor = 13;

        pub fn vr_hmd_vendor(&self) -> &str {
            match self.vr_hmd_vendor.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_vr_hmd_vendor(&mut self) {
            self.vr_hmd_vendor = ::std::option::Option::None;
        }

        pub fn has_vr_hmd_vendor(&self) -> bool {
            self.vr_hmd_vendor.is_some()
        }

        // Param is passed by value, moved
        pub fn set_vr_hmd_vendor(&mut self, v: ::std::string::String) {
            self.vr_hmd_vendor = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_vr_hmd_vendor(&mut self) -> &mut ::std::string::String {
            if self.vr_hmd_vendor.is_none() {
                self.vr_hmd_vendor = ::std::option::Option::Some(::std::string::String::new());
            }
            self.vr_hmd_vendor.as_mut().unwrap()
        }

        // Take field
        pub fn take_vr_hmd_vendor(&mut self) -> ::std::string::String {
            self.vr_hmd_vendor.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string vr_hmd_model = 14;

        pub fn vr_hmd_model(&self) -> &str {
            match self.vr_hmd_model.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_vr_hmd_model(&mut self) {
            self.vr_hmd_model = ::std::option::Option::None;
        }

        pub fn has_vr_hmd_model(&self) -> bool {
            self.vr_hmd_model.is_some()
        }

        // Param is passed by value, moved
        pub fn set_vr_hmd_model(&mut self, v: ::std::string::String) {
            self.vr_hmd_model = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_vr_hmd_model(&mut self) -> &mut ::std::string::String {
            if self.vr_hmd_model.is_none() {
                self.vr_hmd_model = ::std::option::Option::Some(::std::string::String::new());
            }
            self.vr_hmd_model.as_mut().unwrap()
        }

        // Take field
        pub fn take_vr_hmd_model(&mut self) -> ::std::string::String {
            self.vr_hmd_model.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 launch_option_type = 15;

        pub fn launch_option_type(&self) -> u32 {
            self.launch_option_type.unwrap_or(0u32)
        }

        pub fn clear_launch_option_type(&mut self) {
            self.launch_option_type = ::std::option::Option::None;
        }

        pub fn has_launch_option_type(&self) -> bool {
            self.launch_option_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_launch_option_type(&mut self, v: u32) {
            self.launch_option_type = ::std::option::Option::Some(v);
        }

        // optional int32 primary_controller_type = 16;

        pub fn primary_controller_type(&self) -> i32 {
            self.primary_controller_type.unwrap_or(-1i32)
        }

        pub fn clear_primary_controller_type(&mut self) {
            self.primary_controller_type = ::std::option::Option::None;
        }

        pub fn has_primary_controller_type(&self) -> bool {
            self.primary_controller_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_primary_controller_type(&mut self, v: i32) {
            self.primary_controller_type = ::std::option::Option::Some(v);
        }

        // optional string primary_steam_controller_serial = 17;

        pub fn primary_steam_controller_serial(&self) -> &str {
            match self.primary_steam_controller_serial.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_primary_steam_controller_serial(&mut self) {
            self.primary_steam_controller_serial = ::std::option::Option::None;
        }

        pub fn has_primary_steam_controller_serial(&self) -> bool {
            self.primary_steam_controller_serial.is_some()
        }

        // Param is passed by value, moved
        pub fn set_primary_steam_controller_serial(&mut self, v: ::std::string::String) {
            self.primary_steam_controller_serial = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_primary_steam_controller_serial(&mut self) -> &mut ::std::string::String {
            if self.primary_steam_controller_serial.is_none() {
                self.primary_steam_controller_serial = ::std::option::Option::Some(::std::string::String::new());
            }
            self.primary_steam_controller_serial.as_mut().unwrap()
        }

        // Take field
        pub fn take_primary_steam_controller_serial(&mut self) -> ::std::string::String {
            self.primary_steam_controller_serial.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 total_steam_controller_count = 18;

        pub fn total_steam_controller_count(&self) -> u32 {
            self.total_steam_controller_count.unwrap_or(0u32)
        }

        pub fn clear_total_steam_controller_count(&mut self) {
            self.total_steam_controller_count = ::std::option::Option::None;
        }

        pub fn has_total_steam_controller_count(&self) -> bool {
            self.total_steam_controller_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_steam_controller_count(&mut self, v: u32) {
            self.total_steam_controller_count = ::std::option::Option::Some(v);
        }

        // optional uint32 total_non_steam_controller_count = 19;

        pub fn total_non_steam_controller_count(&self) -> u32 {
            self.total_non_steam_controller_count.unwrap_or(0u32)
        }

        pub fn clear_total_non_steam_controller_count(&mut self) {
            self.total_non_steam_controller_count = ::std::option::Option::None;
        }

        pub fn has_total_non_steam_controller_count(&self) -> bool {
            self.total_non_steam_controller_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_non_steam_controller_count(&mut self, v: u32) {
            self.total_non_steam_controller_count = ::std::option::Option::Some(v);
        }

        // optional uint64 controller_workshop_file_id = 20;

        pub fn controller_workshop_file_id(&self) -> u64 {
            self.controller_workshop_file_id.unwrap_or(0u64)
        }

        pub fn clear_controller_workshop_file_id(&mut self) {
            self.controller_workshop_file_id = ::std::option::Option::None;
        }

        pub fn has_controller_workshop_file_id(&self) -> bool {
            self.controller_workshop_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_controller_workshop_file_id(&mut self, v: u64) {
            self.controller_workshop_file_id = ::std::option::Option::Some(v);
        }

        // optional uint32 launch_source = 21;

        pub fn launch_source(&self) -> u32 {
            self.launch_source.unwrap_or(0u32)
        }

        pub fn clear_launch_source(&mut self) {
            self.launch_source = ::std::option::Option::None;
        }

        pub fn has_launch_source(&self) -> bool {
            self.launch_source.is_some()
        }

        // Param is passed by value, moved
        pub fn set_launch_source(&mut self, v: u32) {
            self.launch_source = ::std::option::Option::Some(v);
        }

        // optional uint32 vr_hmd_runtime = 22;

        pub fn vr_hmd_runtime(&self) -> u32 {
            self.vr_hmd_runtime.unwrap_or(0)
        }

        pub fn clear_vr_hmd_runtime(&mut self) {
            self.vr_hmd_runtime = ::std::option::Option::None;
        }

        pub fn has_vr_hmd_runtime(&self) -> bool {
            self.vr_hmd_runtime.is_some()
        }

        // Param is passed by value, moved
        pub fn set_vr_hmd_runtime(&mut self, v: u32) {
            self.vr_hmd_runtime = ::std::option::Option::Some(v);
        }

        // optional uint32 controller_connection_type = 24;

        pub fn controller_connection_type(&self) -> u32 {
            self.controller_connection_type.unwrap_or(0u32)
        }

        pub fn clear_controller_connection_type(&mut self) {
            self.controller_connection_type = ::std::option::Option::None;
        }

        pub fn has_controller_connection_type(&self) -> bool {
            self.controller_connection_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_controller_connection_type(&mut self, v: u32) {
            self.controller_connection_type = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(24);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "steam_id_gs",
                |m: &GamePlayed| { &m.steam_id_gs },
                |m: &mut GamePlayed| { &mut m.steam_id_gs },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_id",
                |m: &GamePlayed| { &m.game_id },
                |m: &mut GamePlayed| { &mut m.game_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "deprecated_game_ip_address",
                |m: &GamePlayed| { &m.deprecated_game_ip_address },
                |m: &mut GamePlayed| { &mut m.deprecated_game_ip_address },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_port",
                |m: &GamePlayed| { &m.game_port },
                |m: &mut GamePlayed| { &mut m.game_port },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_secure",
                |m: &GamePlayed| { &m.is_secure },
                |m: &mut GamePlayed| { &mut m.is_secure },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "token",
                |m: &GamePlayed| { &m.token },
                |m: &mut GamePlayed| { &mut m.token },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_extra_info",
                |m: &GamePlayed| { &m.game_extra_info },
                |m: &mut GamePlayed| { &mut m.game_extra_info },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_data_blob",
                |m: &GamePlayed| { &m.game_data_blob },
                |m: &mut GamePlayed| { &mut m.game_data_blob },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "process_id",
                |m: &GamePlayed| { &m.process_id },
                |m: &mut GamePlayed| { &mut m.process_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "streaming_provider_id",
                |m: &GamePlayed| { &m.streaming_provider_id },
                |m: &mut GamePlayed| { &mut m.streaming_provider_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_flags",
                |m: &GamePlayed| { &m.game_flags },
                |m: &mut GamePlayed| { &mut m.game_flags },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "owner_id",
                |m: &GamePlayed| { &m.owner_id },
                |m: &mut GamePlayed| { &mut m.owner_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "vr_hmd_vendor",
                |m: &GamePlayed| { &m.vr_hmd_vendor },
                |m: &mut GamePlayed| { &mut m.vr_hmd_vendor },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "vr_hmd_model",
                |m: &GamePlayed| { &m.vr_hmd_model },
                |m: &mut GamePlayed| { &mut m.vr_hmd_model },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "launch_option_type",
                |m: &GamePlayed| { &m.launch_option_type },
                |m: &mut GamePlayed| { &mut m.launch_option_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "primary_controller_type",
                |m: &GamePlayed| { &m.primary_controller_type },
                |m: &mut GamePlayed| { &mut m.primary_controller_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "primary_steam_controller_serial",
                |m: &GamePlayed| { &m.primary_steam_controller_serial },
                |m: &mut GamePlayed| { &mut m.primary_steam_controller_serial },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "total_steam_controller_count",
                |m: &GamePlayed| { &m.total_steam_controller_count },
                |m: &mut GamePlayed| { &mut m.total_steam_controller_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "total_non_steam_controller_count",
                |m: &GamePlayed| { &m.total_non_steam_controller_count },
                |m: &mut GamePlayed| { &mut m.total_non_steam_controller_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "controller_workshop_file_id",
                |m: &GamePlayed| { &m.controller_workshop_file_id },
                |m: &mut GamePlayed| { &mut m.controller_workshop_file_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "launch_source",
                |m: &GamePlayed| { &m.launch_source },
                |m: &mut GamePlayed| { &mut m.launch_source },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "vr_hmd_runtime",
                |m: &GamePlayed| { &m.vr_hmd_runtime },
                |m: &mut GamePlayed| { &mut m.vr_hmd_runtime },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::steammessages_base::CMsgIPAddress>(
                "game_ip_address",
                |m: &GamePlayed| { &m.game_ip_address },
                |m: &mut GamePlayed| { &mut m.game_ip_address },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "controller_connection_type",
                |m: &GamePlayed| { &m.controller_connection_type },
                |m: &mut GamePlayed| { &mut m.controller_connection_type },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GamePlayed>(
                "CMsgClientGamesPlayed.GamePlayed",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for GamePlayed {
        const NAME: &'static str = "GamePlayed";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.steam_id_gs = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    17 => {
                        self.game_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    24 => {
                        self.deprecated_game_ip_address = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.game_port = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.is_secure = ::std::option::Option::Some(is.read_bool()?);
                    },
                    50 => {
                        self.token = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    58 => {
                        self.game_extra_info = ::std::option::Option::Some(is.read_string()?);
                    },
                    66 => {
                        self.game_data_blob = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    72 => {
                        self.process_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.streaming_provider_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    88 => {
                        self.game_flags = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    96 => {
                        self.owner_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    106 => {
                        self.vr_hmd_vendor = ::std::option::Option::Some(is.read_string()?);
                    },
                    114 => {
                        self.vr_hmd_model = ::std::option::Option::Some(is.read_string()?);
                    },
                    120 => {
                        self.launch_option_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    128 => {
                        self.primary_controller_type = ::std::option::Option::Some(is.read_int32()?);
                    },
                    138 => {
                        self.primary_steam_controller_serial = ::std::option::Option::Some(is.read_string()?);
                    },
                    144 => {
                        self.total_steam_controller_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    152 => {
                        self.total_non_steam_controller_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    160 => {
                        self.controller_workshop_file_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    168 => {
                        self.launch_source = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    176 => {
                        self.vr_hmd_runtime = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    186 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.game_ip_address)?;
                    },
                    192 => {
                        self.controller_connection_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id_gs {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.game_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.deprecated_game_ip_address {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.game_port {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.is_secure {
                my_size += 1 + 1;
            }
            if let Some(v) = self.token.as_ref() {
                my_size += ::protobuf::rt::bytes_size(6, &v);
            }
            if let Some(v) = self.game_extra_info.as_ref() {
                my_size += ::protobuf::rt::string_size(7, &v);
            }
            if let Some(v) = self.game_data_blob.as_ref() {
                my_size += ::protobuf::rt::bytes_size(8, &v);
            }
            if let Some(v) = self.process_id {
                my_size += ::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.streaming_provider_id {
                my_size += ::protobuf::rt::uint32_size(10, v);
            }
            if let Some(v) = self.game_flags {
                my_size += ::protobuf::rt::uint32_size(11, v);
            }
            if let Some(v) = self.owner_id {
                my_size += ::protobuf::rt::uint32_size(12, v);
            }
            if let Some(v) = self.vr_hmd_vendor.as_ref() {
                my_size += ::protobuf::rt::string_size(13, &v);
            }
            if let Some(v) = self.vr_hmd_model.as_ref() {
                my_size += ::protobuf::rt::string_size(14, &v);
            }
            if let Some(v) = self.launch_option_type {
                my_size += ::protobuf::rt::uint32_size(15, v);
            }
            if let Some(v) = self.primary_controller_type {
                my_size += ::protobuf::rt::int32_size(16, v);
            }
            if let Some(v) = self.primary_steam_controller_serial.as_ref() {
                my_size += ::protobuf::rt::string_size(17, &v);
            }
            if let Some(v) = self.total_steam_controller_count {
                my_size += ::protobuf::rt::uint32_size(18, v);
            }
            if let Some(v) = self.total_non_steam_controller_count {
                my_size += ::protobuf::rt::uint32_size(19, v);
            }
            if let Some(v) = self.controller_workshop_file_id {
                my_size += ::protobuf::rt::uint64_size(20, v);
            }
            if let Some(v) = self.launch_source {
                my_size += ::protobuf::rt::uint32_size(21, v);
            }
            if let Some(v) = self.vr_hmd_runtime {
                my_size += ::protobuf::rt::uint32_size(22, v);
            }
            if let Some(v) = self.game_ip_address.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.controller_connection_type {
                my_size += ::protobuf::rt::uint32_size(24, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.steam_id_gs {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.game_id {
                os.write_fixed64(2, v)?;
            }
            if let Some(v) = self.deprecated_game_ip_address {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.game_port {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.is_secure {
                os.write_bool(5, v)?;
            }
            if let Some(v) = self.token.as_ref() {
                os.write_bytes(6, v)?;
            }
            if let Some(v) = self.game_extra_info.as_ref() {
                os.write_string(7, v)?;
            }
            if let Some(v) = self.game_data_blob.as_ref() {
                os.write_bytes(8, v)?;
            }
            if let Some(v) = self.process_id {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.streaming_provider_id {
                os.write_uint32(10, v)?;
            }
            if let Some(v) = self.game_flags {
                os.write_uint32(11, v)?;
            }
            if let Some(v) = self.owner_id {
                os.write_uint32(12, v)?;
            }
            if let Some(v) = self.vr_hmd_vendor.as_ref() {
                os.write_string(13, v)?;
            }
            if let Some(v) = self.vr_hmd_model.as_ref() {
                os.write_string(14, v)?;
            }
            if let Some(v) = self.launch_option_type {
                os.write_uint32(15, v)?;
            }
            if let Some(v) = self.primary_controller_type {
                os.write_int32(16, v)?;
            }
            if let Some(v) = self.primary_steam_controller_serial.as_ref() {
                os.write_string(17, v)?;
            }
            if let Some(v) = self.total_steam_controller_count {
                os.write_uint32(18, v)?;
            }
            if let Some(v) = self.total_non_steam_controller_count {
                os.write_uint32(19, v)?;
            }
            if let Some(v) = self.controller_workshop_file_id {
                os.write_uint64(20, v)?;
            }
            if let Some(v) = self.launch_source {
                os.write_uint32(21, v)?;
            }
            if let Some(v) = self.vr_hmd_runtime {
                os.write_uint32(22, v)?;
            }
            if let Some(v) = self.game_ip_address.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
            }
            if let Some(v) = self.controller_connection_type {
                os.write_uint32(24, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GamePlayed {
            GamePlayed::new()
        }

        fn clear(&mut self) {
            self.steam_id_gs = ::std::option::Option::None;
            self.game_id = ::std::option::Option::None;
            self.deprecated_game_ip_address = ::std::option::Option::None;
            self.game_port = ::std::option::Option::None;
            self.is_secure = ::std::option::Option::None;
            self.token = ::std::option::Option::None;
            self.game_extra_info = ::std::option::Option::None;
            self.game_data_blob = ::std::option::Option::None;
            self.process_id = ::std::option::Option::None;
            self.streaming_provider_id = ::std::option::Option::None;
            self.game_flags = ::std::option::Option::None;
            self.owner_id = ::std::option::Option::None;
            self.vr_hmd_vendor = ::std::option::Option::None;
            self.vr_hmd_model = ::std::option::Option::None;
            self.launch_option_type = ::std::option::Option::None;
            self.primary_controller_type = ::std::option::Option::None;
            self.primary_steam_controller_serial = ::std::option::Option::None;
            self.total_steam_controller_count = ::std::option::Option::None;
            self.total_non_steam_controller_count = ::std::option::Option::None;
            self.controller_workshop_file_id = ::std::option::Option::None;
            self.launch_source = ::std::option::Option::None;
            self.vr_hmd_runtime = ::std::option::Option::None;
            self.game_ip_address.clear();
            self.controller_connection_type = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GamePlayed {
            static instance: GamePlayed = GamePlayed {
                steam_id_gs: ::std::option::Option::None,
                game_id: ::std::option::Option::None,
                deprecated_game_ip_address: ::std::option::Option::None,
                game_port: ::std::option::Option::None,
                is_secure: ::std::option::Option::None,
                token: ::std::option::Option::None,
                game_extra_info: ::std::option::Option::None,
                game_data_blob: ::std::option::Option::None,
                process_id: ::std::option::Option::None,
                streaming_provider_id: ::std::option::Option::None,
                game_flags: ::std::option::Option::None,
                owner_id: ::std::option::Option::None,
                vr_hmd_vendor: ::std::option::Option::None,
                vr_hmd_model: ::std::option::Option::None,
                launch_option_type: ::std::option::Option::None,
                primary_controller_type: ::std::option::Option::None,
                primary_steam_controller_serial: ::std::option::Option::None,
                total_steam_controller_count: ::std::option::Option::None,
                total_non_steam_controller_count: ::std::option::Option::None,
                controller_workshop_file_id: ::std::option::Option::None,
                launch_source: ::std::option::Option::None,
                vr_hmd_runtime: ::std::option::Option::None,
                game_ip_address: ::protobuf::MessageField::none(),
                controller_connection_type: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for GamePlayed {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientGamesPlayed.GamePlayed").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for GamePlayed {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for GamePlayed {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgGSApprove)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGSApprove {
    // message fields
    // @@protoc_insertion_point(field:CMsgGSApprove.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGSApprove.owner_steam_id)
    pub owner_steam_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGSApprove.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGSApprove {
    fn default() -> &'a CMsgGSApprove {
        <CMsgGSApprove as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSApprove {
    pub fn new() -> CMsgGSApprove {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 owner_steam_id = 2;

    pub fn owner_steam_id(&self) -> u64 {
        self.owner_steam_id.unwrap_or(0)
    }

    pub fn clear_owner_steam_id(&mut self) {
        self.owner_steam_id = ::std::option::Option::None;
    }

    pub fn has_owner_steam_id(&self) -> bool {
        self.owner_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_steam_id(&mut self, v: u64) {
        self.owner_steam_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id",
            |m: &CMsgGSApprove| { &m.steam_id },
            |m: &mut CMsgGSApprove| { &mut m.steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "owner_steam_id",
            |m: &CMsgGSApprove| { &m.owner_steam_id },
            |m: &mut CMsgGSApprove| { &mut m.owner_steam_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGSApprove>(
            "CMsgGSApprove",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGSApprove {
    const NAME: &'static str = "CMsgGSApprove";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.owner_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.owner_steam_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.owner_steam_id {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGSApprove {
        CMsgGSApprove::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.owner_steam_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGSApprove {
        static instance: CMsgGSApprove = CMsgGSApprove {
            steam_id: ::std::option::Option::None,
            owner_steam_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGSApprove {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGSApprove").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGSApprove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGSApprove {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGSDeny)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGSDeny {
    // message fields
    // @@protoc_insertion_point(field:CMsgGSDeny.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGSDeny.edeny_reason)
    pub edeny_reason: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGSDeny.deny_string)
    pub deny_string: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGSDeny.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGSDeny {
    fn default() -> &'a CMsgGSDeny {
        <CMsgGSDeny as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSDeny {
    pub fn new() -> CMsgGSDeny {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional int32 edeny_reason = 2;

    pub fn edeny_reason(&self) -> i32 {
        self.edeny_reason.unwrap_or(0)
    }

    pub fn clear_edeny_reason(&mut self) {
        self.edeny_reason = ::std::option::Option::None;
    }

    pub fn has_edeny_reason(&self) -> bool {
        self.edeny_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edeny_reason(&mut self, v: i32) {
        self.edeny_reason = ::std::option::Option::Some(v);
    }

    // optional string deny_string = 3;

    pub fn deny_string(&self) -> &str {
        match self.deny_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_deny_string(&mut self) {
        self.deny_string = ::std::option::Option::None;
    }

    pub fn has_deny_string(&self) -> bool {
        self.deny_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deny_string(&mut self, v: ::std::string::String) {
        self.deny_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deny_string(&mut self) -> &mut ::std::string::String {
        if self.deny_string.is_none() {
            self.deny_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.deny_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_deny_string(&mut self) -> ::std::string::String {
        self.deny_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id",
            |m: &CMsgGSDeny| { &m.steam_id },
            |m: &mut CMsgGSDeny| { &mut m.steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "edeny_reason",
            |m: &CMsgGSDeny| { &m.edeny_reason },
            |m: &mut CMsgGSDeny| { &mut m.edeny_reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deny_string",
            |m: &CMsgGSDeny| { &m.deny_string },
            |m: &mut CMsgGSDeny| { &mut m.deny_string },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGSDeny>(
            "CMsgGSDeny",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGSDeny {
    const NAME: &'static str = "CMsgGSDeny";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.edeny_reason = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.deny_string = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.edeny_reason {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.deny_string.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.edeny_reason {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.deny_string.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGSDeny {
        CMsgGSDeny::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.edeny_reason = ::std::option::Option::None;
        self.deny_string = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGSDeny {
        static instance: CMsgGSDeny = CMsgGSDeny {
            steam_id: ::std::option::Option::None,
            edeny_reason: ::std::option::Option::None,
            deny_string: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGSDeny {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGSDeny").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGSDeny {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGSDeny {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGSKick)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGSKick {
    // message fields
    // @@protoc_insertion_point(field:CMsgGSKick.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGSKick.edeny_reason)
    pub edeny_reason: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGSKick.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGSKick {
    fn default() -> &'a CMsgGSKick {
        <CMsgGSKick as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSKick {
    pub fn new() -> CMsgGSKick {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional int32 edeny_reason = 2;

    pub fn edeny_reason(&self) -> i32 {
        self.edeny_reason.unwrap_or(0)
    }

    pub fn clear_edeny_reason(&mut self) {
        self.edeny_reason = ::std::option::Option::None;
    }

    pub fn has_edeny_reason(&self) -> bool {
        self.edeny_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edeny_reason(&mut self, v: i32) {
        self.edeny_reason = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id",
            |m: &CMsgGSKick| { &m.steam_id },
            |m: &mut CMsgGSKick| { &mut m.steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "edeny_reason",
            |m: &CMsgGSKick| { &m.edeny_reason },
            |m: &mut CMsgGSKick| { &mut m.edeny_reason },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGSKick>(
            "CMsgGSKick",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGSKick {
    const NAME: &'static str = "CMsgGSKick";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.edeny_reason = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.edeny_reason {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.edeny_reason {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGSKick {
        CMsgGSKick::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.edeny_reason = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGSKick {
        static instance: CMsgGSKick = CMsgGSKick {
            steam_id: ::std::option::Option::None,
            edeny_reason: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGSKick {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGSKick").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGSKick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGSKick {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientAuthList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientAuthList {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientAuthList.tokens_left)
    pub tokens_left: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientAuthList.last_request_seq)
    pub last_request_seq: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientAuthList.last_request_seq_from_server)
    pub last_request_seq_from_server: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientAuthList.tickets)
    pub tickets: ::std::vec::Vec<super::steammessages_base::CMsgAuthTicket>,
    // @@protoc_insertion_point(field:CMsgClientAuthList.app_ids)
    pub app_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgClientAuthList.message_sequence)
    pub message_sequence: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientAuthList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientAuthList {
    fn default() -> &'a CMsgClientAuthList {
        <CMsgClientAuthList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAuthList {
    pub fn new() -> CMsgClientAuthList {
        ::std::default::Default::default()
    }

    // optional uint32 tokens_left = 1;

    pub fn tokens_left(&self) -> u32 {
        self.tokens_left.unwrap_or(0)
    }

    pub fn clear_tokens_left(&mut self) {
        self.tokens_left = ::std::option::Option::None;
    }

    pub fn has_tokens_left(&self) -> bool {
        self.tokens_left.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tokens_left(&mut self, v: u32) {
        self.tokens_left = ::std::option::Option::Some(v);
    }

    // optional uint32 last_request_seq = 2;

    pub fn last_request_seq(&self) -> u32 {
        self.last_request_seq.unwrap_or(0)
    }

    pub fn clear_last_request_seq(&mut self) {
        self.last_request_seq = ::std::option::Option::None;
    }

    pub fn has_last_request_seq(&self) -> bool {
        self.last_request_seq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_request_seq(&mut self, v: u32) {
        self.last_request_seq = ::std::option::Option::Some(v);
    }

    // optional uint32 last_request_seq_from_server = 3;

    pub fn last_request_seq_from_server(&self) -> u32 {
        self.last_request_seq_from_server.unwrap_or(0)
    }

    pub fn clear_last_request_seq_from_server(&mut self) {
        self.last_request_seq_from_server = ::std::option::Option::None;
    }

    pub fn has_last_request_seq_from_server(&self) -> bool {
        self.last_request_seq_from_server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_request_seq_from_server(&mut self, v: u32) {
        self.last_request_seq_from_server = ::std::option::Option::Some(v);
    }

    // optional uint32 message_sequence = 6;

    pub fn message_sequence(&self) -> u32 {
        self.message_sequence.unwrap_or(0)
    }

    pub fn clear_message_sequence(&mut self) {
        self.message_sequence = ::std::option::Option::None;
    }

    pub fn has_message_sequence(&self) -> bool {
        self.message_sequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_sequence(&mut self, v: u32) {
        self.message_sequence = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tokens_left",
            |m: &CMsgClientAuthList| { &m.tokens_left },
            |m: &mut CMsgClientAuthList| { &mut m.tokens_left },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_request_seq",
            |m: &CMsgClientAuthList| { &m.last_request_seq },
            |m: &mut CMsgClientAuthList| { &mut m.last_request_seq },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_request_seq_from_server",
            |m: &CMsgClientAuthList| { &m.last_request_seq_from_server },
            |m: &mut CMsgClientAuthList| { &mut m.last_request_seq_from_server },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tickets",
            |m: &CMsgClientAuthList| { &m.tickets },
            |m: &mut CMsgClientAuthList| { &mut m.tickets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "app_ids",
            |m: &CMsgClientAuthList| { &m.app_ids },
            |m: &mut CMsgClientAuthList| { &mut m.app_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message_sequence",
            |m: &CMsgClientAuthList| { &m.message_sequence },
            |m: &mut CMsgClientAuthList| { &mut m.message_sequence },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientAuthList>(
            "CMsgClientAuthList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientAuthList {
    const NAME: &'static str = "CMsgClientAuthList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tokens_left = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.last_request_seq = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.last_request_seq_from_server = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.tickets.push(is.read_message()?);
                },
                42 => {
                    is.read_repeated_packed_uint32_into(&mut self.app_ids)?;
                },
                40 => {
                    self.app_ids.push(is.read_uint32()?);
                },
                48 => {
                    self.message_sequence = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tokens_left {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.last_request_seq {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.last_request_seq_from_server {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        for value in &self.tickets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.app_ids {
            my_size += ::protobuf::rt::uint32_size(5, *value);
        };
        if let Some(v) = self.message_sequence {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.tokens_left {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.last_request_seq {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.last_request_seq_from_server {
            os.write_uint32(3, v)?;
        }
        for v in &self.tickets {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.app_ids {
            os.write_uint32(5, *v)?;
        };
        if let Some(v) = self.message_sequence {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientAuthList {
        CMsgClientAuthList::new()
    }

    fn clear(&mut self) {
        self.tokens_left = ::std::option::Option::None;
        self.last_request_seq = ::std::option::Option::None;
        self.last_request_seq_from_server = ::std::option::Option::None;
        self.tickets.clear();
        self.app_ids.clear();
        self.message_sequence = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientAuthList {
        static instance: CMsgClientAuthList = CMsgClientAuthList {
            tokens_left: ::std::option::Option::None,
            last_request_seq: ::std::option::Option::None,
            last_request_seq_from_server: ::std::option::Option::None,
            tickets: ::std::vec::Vec::new(),
            app_ids: ::std::vec::Vec::new(),
            message_sequence: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientAuthList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientAuthList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientAuthList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAuthList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientAuthListAck)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientAuthListAck {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientAuthListAck.ticket_crc)
    pub ticket_crc: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgClientAuthListAck.app_ids)
    pub app_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgClientAuthListAck.message_sequence)
    pub message_sequence: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientAuthListAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientAuthListAck {
    fn default() -> &'a CMsgClientAuthListAck {
        <CMsgClientAuthListAck as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAuthListAck {
    pub fn new() -> CMsgClientAuthListAck {
        ::std::default::Default::default()
    }

    // optional uint32 message_sequence = 3;

    pub fn message_sequence(&self) -> u32 {
        self.message_sequence.unwrap_or(0)
    }

    pub fn clear_message_sequence(&mut self) {
        self.message_sequence = ::std::option::Option::None;
    }

    pub fn has_message_sequence(&self) -> bool {
        self.message_sequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_sequence(&mut self, v: u32) {
        self.message_sequence = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ticket_crc",
            |m: &CMsgClientAuthListAck| { &m.ticket_crc },
            |m: &mut CMsgClientAuthListAck| { &mut m.ticket_crc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "app_ids",
            |m: &CMsgClientAuthListAck| { &m.app_ids },
            |m: &mut CMsgClientAuthListAck| { &mut m.app_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message_sequence",
            |m: &CMsgClientAuthListAck| { &m.message_sequence },
            |m: &mut CMsgClientAuthListAck| { &mut m.message_sequence },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientAuthListAck>(
            "CMsgClientAuthListAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientAuthListAck {
    const NAME: &'static str = "CMsgClientAuthListAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.ticket_crc)?;
                },
                8 => {
                    self.ticket_crc.push(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.app_ids)?;
                },
                16 => {
                    self.app_ids.push(is.read_uint32()?);
                },
                24 => {
                    self.message_sequence = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.ticket_crc {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        for value in &self.app_ids {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        if let Some(v) = self.message_sequence {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.ticket_crc {
            os.write_uint32(1, *v)?;
        };
        for v in &self.app_ids {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.message_sequence {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientAuthListAck {
        CMsgClientAuthListAck::new()
    }

    fn clear(&mut self) {
        self.ticket_crc.clear();
        self.app_ids.clear();
        self.message_sequence = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientAuthListAck {
        static instance: CMsgClientAuthListAck = CMsgClientAuthListAck {
            ticket_crc: ::std::vec::Vec::new(),
            app_ids: ::std::vec::Vec::new(),
            message_sequence: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientAuthListAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientAuthListAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientAuthListAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAuthListAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientLicenseList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientLicenseList {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientLicenseList.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientLicenseList.licenses)
    pub licenses: ::std::vec::Vec<cmsg_client_license_list::License>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientLicenseList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientLicenseList {
    fn default() -> &'a CMsgClientLicenseList {
        <CMsgClientLicenseList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientLicenseList {
    pub fn new() -> CMsgClientLicenseList {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientLicenseList| { &m.eresult },
            |m: &mut CMsgClientLicenseList| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "licenses",
            |m: &CMsgClientLicenseList| { &m.licenses },
            |m: &mut CMsgClientLicenseList| { &mut m.licenses },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientLicenseList>(
            "CMsgClientLicenseList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientLicenseList {
    const NAME: &'static str = "CMsgClientLicenseList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.licenses.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.licenses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.licenses {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientLicenseList {
        CMsgClientLicenseList::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.licenses.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientLicenseList {
        static instance: CMsgClientLicenseList = CMsgClientLicenseList {
            eresult: ::std::option::Option::None,
            licenses: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientLicenseList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientLicenseList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientLicenseList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientLicenseList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientLicenseList`
pub mod cmsg_client_license_list {
    // @@protoc_insertion_point(message:CMsgClientLicenseList.License)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct License {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.package_id)
        pub package_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.time_created)
        pub time_created: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.time_next_process)
        pub time_next_process: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.minute_limit)
        pub minute_limit: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.minutes_used)
        pub minutes_used: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.payment_method)
        pub payment_method: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.flags)
        pub flags: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.purchase_country_code)
        pub purchase_country_code: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.license_type)
        pub license_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.territory_code)
        pub territory_code: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.change_number)
        pub change_number: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.owner_id)
        pub owner_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.initial_period)
        pub initial_period: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.initial_time_unit)
        pub initial_time_unit: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.renewal_period)
        pub renewal_period: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.renewal_time_unit)
        pub renewal_time_unit: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.access_token)
        pub access_token: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.master_package_id)
        pub master_package_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientLicenseList.License.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a License {
        fn default() -> &'a License {
            <License as ::protobuf::Message>::default_instance()
        }
    }

    impl License {
        pub fn new() -> License {
            ::std::default::Default::default()
        }

        // optional uint32 package_id = 1;

        pub fn package_id(&self) -> u32 {
            self.package_id.unwrap_or(0)
        }

        pub fn clear_package_id(&mut self) {
            self.package_id = ::std::option::Option::None;
        }

        pub fn has_package_id(&self) -> bool {
            self.package_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_package_id(&mut self, v: u32) {
            self.package_id = ::std::option::Option::Some(v);
        }

        // optional fixed32 time_created = 2;

        pub fn time_created(&self) -> u32 {
            self.time_created.unwrap_or(0)
        }

        pub fn clear_time_created(&mut self) {
            self.time_created = ::std::option::Option::None;
        }

        pub fn has_time_created(&self) -> bool {
            self.time_created.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_created(&mut self, v: u32) {
            self.time_created = ::std::option::Option::Some(v);
        }

        // optional fixed32 time_next_process = 3;

        pub fn time_next_process(&self) -> u32 {
            self.time_next_process.unwrap_or(0)
        }

        pub fn clear_time_next_process(&mut self) {
            self.time_next_process = ::std::option::Option::None;
        }

        pub fn has_time_next_process(&self) -> bool {
            self.time_next_process.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_next_process(&mut self, v: u32) {
            self.time_next_process = ::std::option::Option::Some(v);
        }

        // optional int32 minute_limit = 4;

        pub fn minute_limit(&self) -> i32 {
            self.minute_limit.unwrap_or(0)
        }

        pub fn clear_minute_limit(&mut self) {
            self.minute_limit = ::std::option::Option::None;
        }

        pub fn has_minute_limit(&self) -> bool {
            self.minute_limit.is_some()
        }

        // Param is passed by value, moved
        pub fn set_minute_limit(&mut self, v: i32) {
            self.minute_limit = ::std::option::Option::Some(v);
        }

        // optional int32 minutes_used = 5;

        pub fn minutes_used(&self) -> i32 {
            self.minutes_used.unwrap_or(0)
        }

        pub fn clear_minutes_used(&mut self) {
            self.minutes_used = ::std::option::Option::None;
        }

        pub fn has_minutes_used(&self) -> bool {
            self.minutes_used.is_some()
        }

        // Param is passed by value, moved
        pub fn set_minutes_used(&mut self, v: i32) {
            self.minutes_used = ::std::option::Option::Some(v);
        }

        // optional uint32 payment_method = 6;

        pub fn payment_method(&self) -> u32 {
            self.payment_method.unwrap_or(0)
        }

        pub fn clear_payment_method(&mut self) {
            self.payment_method = ::std::option::Option::None;
        }

        pub fn has_payment_method(&self) -> bool {
            self.payment_method.is_some()
        }

        // Param is passed by value, moved
        pub fn set_payment_method(&mut self, v: u32) {
            self.payment_method = ::std::option::Option::Some(v);
        }

        // optional uint32 flags = 7;

        pub fn flags(&self) -> u32 {
            self.flags.unwrap_or(0)
        }

        pub fn clear_flags(&mut self) {
            self.flags = ::std::option::Option::None;
        }

        pub fn has_flags(&self) -> bool {
            self.flags.is_some()
        }

        // Param is passed by value, moved
        pub fn set_flags(&mut self, v: u32) {
            self.flags = ::std::option::Option::Some(v);
        }

        // optional string purchase_country_code = 8;

        pub fn purchase_country_code(&self) -> &str {
            match self.purchase_country_code.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_purchase_country_code(&mut self) {
            self.purchase_country_code = ::std::option::Option::None;
        }

        pub fn has_purchase_country_code(&self) -> bool {
            self.purchase_country_code.is_some()
        }

        // Param is passed by value, moved
        pub fn set_purchase_country_code(&mut self, v: ::std::string::String) {
            self.purchase_country_code = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_purchase_country_code(&mut self) -> &mut ::std::string::String {
            if self.purchase_country_code.is_none() {
                self.purchase_country_code = ::std::option::Option::Some(::std::string::String::new());
            }
            self.purchase_country_code.as_mut().unwrap()
        }

        // Take field
        pub fn take_purchase_country_code(&mut self) -> ::std::string::String {
            self.purchase_country_code.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 license_type = 9;

        pub fn license_type(&self) -> u32 {
            self.license_type.unwrap_or(0)
        }

        pub fn clear_license_type(&mut self) {
            self.license_type = ::std::option::Option::None;
        }

        pub fn has_license_type(&self) -> bool {
            self.license_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_license_type(&mut self, v: u32) {
            self.license_type = ::std::option::Option::Some(v);
        }

        // optional int32 territory_code = 10;

        pub fn territory_code(&self) -> i32 {
            self.territory_code.unwrap_or(0)
        }

        pub fn clear_territory_code(&mut self) {
            self.territory_code = ::std::option::Option::None;
        }

        pub fn has_territory_code(&self) -> bool {
            self.territory_code.is_some()
        }

        // Param is passed by value, moved
        pub fn set_territory_code(&mut self, v: i32) {
            self.territory_code = ::std::option::Option::Some(v);
        }

        // optional int32 change_number = 11;

        pub fn change_number(&self) -> i32 {
            self.change_number.unwrap_or(0)
        }

        pub fn clear_change_number(&mut self) {
            self.change_number = ::std::option::Option::None;
        }

        pub fn has_change_number(&self) -> bool {
            self.change_number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_change_number(&mut self, v: i32) {
            self.change_number = ::std::option::Option::Some(v);
        }

        // optional uint32 owner_id = 12;

        pub fn owner_id(&self) -> u32 {
            self.owner_id.unwrap_or(0)
        }

        pub fn clear_owner_id(&mut self) {
            self.owner_id = ::std::option::Option::None;
        }

        pub fn has_owner_id(&self) -> bool {
            self.owner_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_owner_id(&mut self, v: u32) {
            self.owner_id = ::std::option::Option::Some(v);
        }

        // optional uint32 initial_period = 13;

        pub fn initial_period(&self) -> u32 {
            self.initial_period.unwrap_or(0)
        }

        pub fn clear_initial_period(&mut self) {
            self.initial_period = ::std::option::Option::None;
        }

        pub fn has_initial_period(&self) -> bool {
            self.initial_period.is_some()
        }

        // Param is passed by value, moved
        pub fn set_initial_period(&mut self, v: u32) {
            self.initial_period = ::std::option::Option::Some(v);
        }

        // optional uint32 initial_time_unit = 14;

        pub fn initial_time_unit(&self) -> u32 {
            self.initial_time_unit.unwrap_or(0)
        }

        pub fn clear_initial_time_unit(&mut self) {
            self.initial_time_unit = ::std::option::Option::None;
        }

        pub fn has_initial_time_unit(&self) -> bool {
            self.initial_time_unit.is_some()
        }

        // Param is passed by value, moved
        pub fn set_initial_time_unit(&mut self, v: u32) {
            self.initial_time_unit = ::std::option::Option::Some(v);
        }

        // optional uint32 renewal_period = 15;

        pub fn renewal_period(&self) -> u32 {
            self.renewal_period.unwrap_or(0)
        }

        pub fn clear_renewal_period(&mut self) {
            self.renewal_period = ::std::option::Option::None;
        }

        pub fn has_renewal_period(&self) -> bool {
            self.renewal_period.is_some()
        }

        // Param is passed by value, moved
        pub fn set_renewal_period(&mut self, v: u32) {
            self.renewal_period = ::std::option::Option::Some(v);
        }

        // optional uint32 renewal_time_unit = 16;

        pub fn renewal_time_unit(&self) -> u32 {
            self.renewal_time_unit.unwrap_or(0)
        }

        pub fn clear_renewal_time_unit(&mut self) {
            self.renewal_time_unit = ::std::option::Option::None;
        }

        pub fn has_renewal_time_unit(&self) -> bool {
            self.renewal_time_unit.is_some()
        }

        // Param is passed by value, moved
        pub fn set_renewal_time_unit(&mut self, v: u32) {
            self.renewal_time_unit = ::std::option::Option::Some(v);
        }

        // optional uint64 access_token = 17;

        pub fn access_token(&self) -> u64 {
            self.access_token.unwrap_or(0)
        }

        pub fn clear_access_token(&mut self) {
            self.access_token = ::std::option::Option::None;
        }

        pub fn has_access_token(&self) -> bool {
            self.access_token.is_some()
        }

        // Param is passed by value, moved
        pub fn set_access_token(&mut self, v: u64) {
            self.access_token = ::std::option::Option::Some(v);
        }

        // optional uint32 master_package_id = 18;

        pub fn master_package_id(&self) -> u32 {
            self.master_package_id.unwrap_or(0)
        }

        pub fn clear_master_package_id(&mut self) {
            self.master_package_id = ::std::option::Option::None;
        }

        pub fn has_master_package_id(&self) -> bool {
            self.master_package_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_master_package_id(&mut self, v: u32) {
            self.master_package_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(18);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "package_id",
                |m: &License| { &m.package_id },
                |m: &mut License| { &mut m.package_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "time_created",
                |m: &License| { &m.time_created },
                |m: &mut License| { &mut m.time_created },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "time_next_process",
                |m: &License| { &m.time_next_process },
                |m: &mut License| { &mut m.time_next_process },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "minute_limit",
                |m: &License| { &m.minute_limit },
                |m: &mut License| { &mut m.minute_limit },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "minutes_used",
                |m: &License| { &m.minutes_used },
                |m: &mut License| { &mut m.minutes_used },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "payment_method",
                |m: &License| { &m.payment_method },
                |m: &mut License| { &mut m.payment_method },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "flags",
                |m: &License| { &m.flags },
                |m: &mut License| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "purchase_country_code",
                |m: &License| { &m.purchase_country_code },
                |m: &mut License| { &mut m.purchase_country_code },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "license_type",
                |m: &License| { &m.license_type },
                |m: &mut License| { &mut m.license_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "territory_code",
                |m: &License| { &m.territory_code },
                |m: &mut License| { &mut m.territory_code },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "change_number",
                |m: &License| { &m.change_number },
                |m: &mut License| { &mut m.change_number },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "owner_id",
                |m: &License| { &m.owner_id },
                |m: &mut License| { &mut m.owner_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "initial_period",
                |m: &License| { &m.initial_period },
                |m: &mut License| { &mut m.initial_period },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "initial_time_unit",
                |m: &License| { &m.initial_time_unit },
                |m: &mut License| { &mut m.initial_time_unit },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "renewal_period",
                |m: &License| { &m.renewal_period },
                |m: &mut License| { &mut m.renewal_period },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "renewal_time_unit",
                |m: &License| { &m.renewal_time_unit },
                |m: &mut License| { &mut m.renewal_time_unit },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "access_token",
                |m: &License| { &m.access_token },
                |m: &mut License| { &mut m.access_token },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "master_package_id",
                |m: &License| { &m.master_package_id },
                |m: &mut License| { &mut m.master_package_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<License>(
                "CMsgClientLicenseList.License",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for License {
        const NAME: &'static str = "License";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.package_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    21 => {
                        self.time_created = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    29 => {
                        self.time_next_process = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    32 => {
                        self.minute_limit = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.minutes_used = ::std::option::Option::Some(is.read_int32()?);
                    },
                    48 => {
                        self.payment_method = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.flags = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    66 => {
                        self.purchase_country_code = ::std::option::Option::Some(is.read_string()?);
                    },
                    72 => {
                        self.license_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.territory_code = ::std::option::Option::Some(is.read_int32()?);
                    },
                    88 => {
                        self.change_number = ::std::option::Option::Some(is.read_int32()?);
                    },
                    96 => {
                        self.owner_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    104 => {
                        self.initial_period = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    112 => {
                        self.initial_time_unit = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    120 => {
                        self.renewal_period = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    128 => {
                        self.renewal_time_unit = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    136 => {
                        self.access_token = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    144 => {
                        self.master_package_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.package_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.time_created {
                my_size += 1 + 4;
            }
            if let Some(v) = self.time_next_process {
                my_size += 1 + 4;
            }
            if let Some(v) = self.minute_limit {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.minutes_used {
                my_size += ::protobuf::rt::int32_size(5, v);
            }
            if let Some(v) = self.payment_method {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.flags {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.purchase_country_code.as_ref() {
                my_size += ::protobuf::rt::string_size(8, &v);
            }
            if let Some(v) = self.license_type {
                my_size += ::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.territory_code {
                my_size += ::protobuf::rt::int32_size(10, v);
            }
            if let Some(v) = self.change_number {
                my_size += ::protobuf::rt::int32_size(11, v);
            }
            if let Some(v) = self.owner_id {
                my_size += ::protobuf::rt::uint32_size(12, v);
            }
            if let Some(v) = self.initial_period {
                my_size += ::protobuf::rt::uint32_size(13, v);
            }
            if let Some(v) = self.initial_time_unit {
                my_size += ::protobuf::rt::uint32_size(14, v);
            }
            if let Some(v) = self.renewal_period {
                my_size += ::protobuf::rt::uint32_size(15, v);
            }
            if let Some(v) = self.renewal_time_unit {
                my_size += ::protobuf::rt::uint32_size(16, v);
            }
            if let Some(v) = self.access_token {
                my_size += ::protobuf::rt::uint64_size(17, v);
            }
            if let Some(v) = self.master_package_id {
                my_size += ::protobuf::rt::uint32_size(18, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.package_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.time_created {
                os.write_fixed32(2, v)?;
            }
            if let Some(v) = self.time_next_process {
                os.write_fixed32(3, v)?;
            }
            if let Some(v) = self.minute_limit {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.minutes_used {
                os.write_int32(5, v)?;
            }
            if let Some(v) = self.payment_method {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.flags {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.purchase_country_code.as_ref() {
                os.write_string(8, v)?;
            }
            if let Some(v) = self.license_type {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.territory_code {
                os.write_int32(10, v)?;
            }
            if let Some(v) = self.change_number {
                os.write_int32(11, v)?;
            }
            if let Some(v) = self.owner_id {
                os.write_uint32(12, v)?;
            }
            if let Some(v) = self.initial_period {
                os.write_uint32(13, v)?;
            }
            if let Some(v) = self.initial_time_unit {
                os.write_uint32(14, v)?;
            }
            if let Some(v) = self.renewal_period {
                os.write_uint32(15, v)?;
            }
            if let Some(v) = self.renewal_time_unit {
                os.write_uint32(16, v)?;
            }
            if let Some(v) = self.access_token {
                os.write_uint64(17, v)?;
            }
            if let Some(v) = self.master_package_id {
                os.write_uint32(18, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> License {
            License::new()
        }

        fn clear(&mut self) {
            self.package_id = ::std::option::Option::None;
            self.time_created = ::std::option::Option::None;
            self.time_next_process = ::std::option::Option::None;
            self.minute_limit = ::std::option::Option::None;
            self.minutes_used = ::std::option::Option::None;
            self.payment_method = ::std::option::Option::None;
            self.flags = ::std::option::Option::None;
            self.purchase_country_code = ::std::option::Option::None;
            self.license_type = ::std::option::Option::None;
            self.territory_code = ::std::option::Option::None;
            self.change_number = ::std::option::Option::None;
            self.owner_id = ::std::option::Option::None;
            self.initial_period = ::std::option::Option::None;
            self.initial_time_unit = ::std::option::Option::None;
            self.renewal_period = ::std::option::Option::None;
            self.renewal_time_unit = ::std::option::Option::None;
            self.access_token = ::std::option::Option::None;
            self.master_package_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static License {
            static instance: License = License {
                package_id: ::std::option::Option::None,
                time_created: ::std::option::Option::None,
                time_next_process: ::std::option::Option::None,
                minute_limit: ::std::option::Option::None,
                minutes_used: ::std::option::Option::None,
                payment_method: ::std::option::Option::None,
                flags: ::std::option::Option::None,
                purchase_country_code: ::std::option::Option::None,
                license_type: ::std::option::Option::None,
                territory_code: ::std::option::Option::None,
                change_number: ::std::option::Option::None,
                owner_id: ::std::option::Option::None,
                initial_period: ::std::option::Option::None,
                initial_time_unit: ::std::option::Option::None,
                renewal_period: ::std::option::Option::None,
                renewal_time_unit: ::std::option::Option::None,
                access_token: ::std::option::Option::None,
                master_package_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for License {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientLicenseList.License").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for License {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for License {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientLBSSetScore)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientLBSSetScore {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientLBSSetScore.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientLBSSetScore.leaderboard_id)
    pub leaderboard_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientLBSSetScore.score)
    pub score: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientLBSSetScore.details)
    pub details: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientLBSSetScore.upload_score_method)
    pub upload_score_method: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientLBSSetScore.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientLBSSetScore {
    fn default() -> &'a CMsgClientLBSSetScore {
        <CMsgClientLBSSetScore as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientLBSSetScore {
    pub fn new() -> CMsgClientLBSSetScore {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional int32 leaderboard_id = 2;

    pub fn leaderboard_id(&self) -> i32 {
        self.leaderboard_id.unwrap_or(0)
    }

    pub fn clear_leaderboard_id(&mut self) {
        self.leaderboard_id = ::std::option::Option::None;
    }

    pub fn has_leaderboard_id(&self) -> bool {
        self.leaderboard_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_id(&mut self, v: i32) {
        self.leaderboard_id = ::std::option::Option::Some(v);
    }

    // optional int32 score = 3;

    pub fn score(&self) -> i32 {
        self.score.unwrap_or(0)
    }

    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: i32) {
        self.score = ::std::option::Option::Some(v);
    }

    // optional bytes details = 4;

    pub fn details(&self) -> &[u8] {
        match self.details.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_details(&mut self) {
        self.details = ::std::option::Option::None;
    }

    pub fn has_details(&self) -> bool {
        self.details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_details(&mut self, v: ::std::vec::Vec<u8>) {
        self.details = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_details(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.details.is_none() {
            self.details = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.details.as_mut().unwrap()
    }

    // Take field
    pub fn take_details(&mut self) -> ::std::vec::Vec<u8> {
        self.details.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 upload_score_method = 5;

    pub fn upload_score_method(&self) -> i32 {
        self.upload_score_method.unwrap_or(0)
    }

    pub fn clear_upload_score_method(&mut self) {
        self.upload_score_method = ::std::option::Option::None;
    }

    pub fn has_upload_score_method(&self) -> bool {
        self.upload_score_method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_score_method(&mut self, v: i32) {
        self.upload_score_method = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientLBSSetScore| { &m.app_id },
            |m: &mut CMsgClientLBSSetScore| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leaderboard_id",
            |m: &CMsgClientLBSSetScore| { &m.leaderboard_id },
            |m: &mut CMsgClientLBSSetScore| { &mut m.leaderboard_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "score",
            |m: &CMsgClientLBSSetScore| { &m.score },
            |m: &mut CMsgClientLBSSetScore| { &mut m.score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "details",
            |m: &CMsgClientLBSSetScore| { &m.details },
            |m: &mut CMsgClientLBSSetScore| { &mut m.details },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "upload_score_method",
            |m: &CMsgClientLBSSetScore| { &m.upload_score_method },
            |m: &mut CMsgClientLBSSetScore| { &mut m.upload_score_method },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientLBSSetScore>(
            "CMsgClientLBSSetScore",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientLBSSetScore {
    const NAME: &'static str = "CMsgClientLBSSetScore";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.leaderboard_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.score = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.details = ::std::option::Option::Some(is.read_bytes()?);
                },
                40 => {
                    self.upload_score_method = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.leaderboard_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.score {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.details.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.upload_score_method {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.leaderboard_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.score {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.details.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.upload_score_method {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientLBSSetScore {
        CMsgClientLBSSetScore::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.leaderboard_id = ::std::option::Option::None;
        self.score = ::std::option::Option::None;
        self.details = ::std::option::Option::None;
        self.upload_score_method = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientLBSSetScore {
        static instance: CMsgClientLBSSetScore = CMsgClientLBSSetScore {
            app_id: ::std::option::Option::None,
            leaderboard_id: ::std::option::Option::None,
            score: ::std::option::Option::None,
            details: ::std::option::Option::None,
            upload_score_method: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientLBSSetScore {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientLBSSetScore").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientLBSSetScore {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientLBSSetScore {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientLBSSetScoreResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientLBSSetScoreResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientLBSSetScoreResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientLBSSetScoreResponse.leaderboard_entry_count)
    pub leaderboard_entry_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientLBSSetScoreResponse.score_changed)
    pub score_changed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientLBSSetScoreResponse.global_rank_previous)
    pub global_rank_previous: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientLBSSetScoreResponse.global_rank_new)
    pub global_rank_new: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientLBSSetScoreResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientLBSSetScoreResponse {
    fn default() -> &'a CMsgClientLBSSetScoreResponse {
        <CMsgClientLBSSetScoreResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientLBSSetScoreResponse {
    pub fn new() -> CMsgClientLBSSetScoreResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional int32 leaderboard_entry_count = 2;

    pub fn leaderboard_entry_count(&self) -> i32 {
        self.leaderboard_entry_count.unwrap_or(0)
    }

    pub fn clear_leaderboard_entry_count(&mut self) {
        self.leaderboard_entry_count = ::std::option::Option::None;
    }

    pub fn has_leaderboard_entry_count(&self) -> bool {
        self.leaderboard_entry_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_entry_count(&mut self, v: i32) {
        self.leaderboard_entry_count = ::std::option::Option::Some(v);
    }

    // optional bool score_changed = 3;

    pub fn score_changed(&self) -> bool {
        self.score_changed.unwrap_or(false)
    }

    pub fn clear_score_changed(&mut self) {
        self.score_changed = ::std::option::Option::None;
    }

    pub fn has_score_changed(&self) -> bool {
        self.score_changed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score_changed(&mut self, v: bool) {
        self.score_changed = ::std::option::Option::Some(v);
    }

    // optional int32 global_rank_previous = 4;

    pub fn global_rank_previous(&self) -> i32 {
        self.global_rank_previous.unwrap_or(0)
    }

    pub fn clear_global_rank_previous(&mut self) {
        self.global_rank_previous = ::std::option::Option::None;
    }

    pub fn has_global_rank_previous(&self) -> bool {
        self.global_rank_previous.is_some()
    }

    // Param is passed by value, moved
    pub fn set_global_rank_previous(&mut self, v: i32) {
        self.global_rank_previous = ::std::option::Option::Some(v);
    }

    // optional int32 global_rank_new = 5;

    pub fn global_rank_new(&self) -> i32 {
        self.global_rank_new.unwrap_or(0)
    }

    pub fn clear_global_rank_new(&mut self) {
        self.global_rank_new = ::std::option::Option::None;
    }

    pub fn has_global_rank_new(&self) -> bool {
        self.global_rank_new.is_some()
    }

    // Param is passed by value, moved
    pub fn set_global_rank_new(&mut self, v: i32) {
        self.global_rank_new = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientLBSSetScoreResponse| { &m.eresult },
            |m: &mut CMsgClientLBSSetScoreResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leaderboard_entry_count",
            |m: &CMsgClientLBSSetScoreResponse| { &m.leaderboard_entry_count },
            |m: &mut CMsgClientLBSSetScoreResponse| { &mut m.leaderboard_entry_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "score_changed",
            |m: &CMsgClientLBSSetScoreResponse| { &m.score_changed },
            |m: &mut CMsgClientLBSSetScoreResponse| { &mut m.score_changed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "global_rank_previous",
            |m: &CMsgClientLBSSetScoreResponse| { &m.global_rank_previous },
            |m: &mut CMsgClientLBSSetScoreResponse| { &mut m.global_rank_previous },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "global_rank_new",
            |m: &CMsgClientLBSSetScoreResponse| { &m.global_rank_new },
            |m: &mut CMsgClientLBSSetScoreResponse| { &mut m.global_rank_new },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientLBSSetScoreResponse>(
            "CMsgClientLBSSetScoreResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientLBSSetScoreResponse {
    const NAME: &'static str = "CMsgClientLBSSetScoreResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.leaderboard_entry_count = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.score_changed = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.global_rank_previous = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.global_rank_new = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.leaderboard_entry_count {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.score_changed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.global_rank_previous {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.global_rank_new {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.leaderboard_entry_count {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.score_changed {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.global_rank_previous {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.global_rank_new {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientLBSSetScoreResponse {
        CMsgClientLBSSetScoreResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.leaderboard_entry_count = ::std::option::Option::None;
        self.score_changed = ::std::option::Option::None;
        self.global_rank_previous = ::std::option::Option::None;
        self.global_rank_new = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientLBSSetScoreResponse {
        static instance: CMsgClientLBSSetScoreResponse = CMsgClientLBSSetScoreResponse {
            eresult: ::std::option::Option::None,
            leaderboard_entry_count: ::std::option::Option::None,
            score_changed: ::std::option::Option::None,
            global_rank_previous: ::std::option::Option::None,
            global_rank_new: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientLBSSetScoreResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientLBSSetScoreResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientLBSSetScoreResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientLBSSetScoreResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientLBSSetUGC)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientLBSSetUGC {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientLBSSetUGC.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientLBSSetUGC.leaderboard_id)
    pub leaderboard_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientLBSSetUGC.ugc_id)
    pub ugc_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientLBSSetUGC.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientLBSSetUGC {
    fn default() -> &'a CMsgClientLBSSetUGC {
        <CMsgClientLBSSetUGC as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientLBSSetUGC {
    pub fn new() -> CMsgClientLBSSetUGC {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional int32 leaderboard_id = 2;

    pub fn leaderboard_id(&self) -> i32 {
        self.leaderboard_id.unwrap_or(0)
    }

    pub fn clear_leaderboard_id(&mut self) {
        self.leaderboard_id = ::std::option::Option::None;
    }

    pub fn has_leaderboard_id(&self) -> bool {
        self.leaderboard_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_id(&mut self, v: i32) {
        self.leaderboard_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 ugc_id = 3;

    pub fn ugc_id(&self) -> u64 {
        self.ugc_id.unwrap_or(0)
    }

    pub fn clear_ugc_id(&mut self) {
        self.ugc_id = ::std::option::Option::None;
    }

    pub fn has_ugc_id(&self) -> bool {
        self.ugc_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ugc_id(&mut self, v: u64) {
        self.ugc_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientLBSSetUGC| { &m.app_id },
            |m: &mut CMsgClientLBSSetUGC| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leaderboard_id",
            |m: &CMsgClientLBSSetUGC| { &m.leaderboard_id },
            |m: &mut CMsgClientLBSSetUGC| { &mut m.leaderboard_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ugc_id",
            |m: &CMsgClientLBSSetUGC| { &m.ugc_id },
            |m: &mut CMsgClientLBSSetUGC| { &mut m.ugc_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientLBSSetUGC>(
            "CMsgClientLBSSetUGC",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientLBSSetUGC {
    const NAME: &'static str = "CMsgClientLBSSetUGC";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.leaderboard_id = ::std::option::Option::Some(is.read_int32()?);
                },
                25 => {
                    self.ugc_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.leaderboard_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.ugc_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.leaderboard_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.ugc_id {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientLBSSetUGC {
        CMsgClientLBSSetUGC::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.leaderboard_id = ::std::option::Option::None;
        self.ugc_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientLBSSetUGC {
        static instance: CMsgClientLBSSetUGC = CMsgClientLBSSetUGC {
            app_id: ::std::option::Option::None,
            leaderboard_id: ::std::option::Option::None,
            ugc_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientLBSSetUGC {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientLBSSetUGC").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientLBSSetUGC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientLBSSetUGC {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientLBSSetUGCResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientLBSSetUGCResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientLBSSetUGCResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientLBSSetUGCResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientLBSSetUGCResponse {
    fn default() -> &'a CMsgClientLBSSetUGCResponse {
        <CMsgClientLBSSetUGCResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientLBSSetUGCResponse {
    pub fn new() -> CMsgClientLBSSetUGCResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientLBSSetUGCResponse| { &m.eresult },
            |m: &mut CMsgClientLBSSetUGCResponse| { &mut m.eresult },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientLBSSetUGCResponse>(
            "CMsgClientLBSSetUGCResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientLBSSetUGCResponse {
    const NAME: &'static str = "CMsgClientLBSSetUGCResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientLBSSetUGCResponse {
        CMsgClientLBSSetUGCResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientLBSSetUGCResponse {
        static instance: CMsgClientLBSSetUGCResponse = CMsgClientLBSSetUGCResponse {
            eresult: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientLBSSetUGCResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientLBSSetUGCResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientLBSSetUGCResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientLBSSetUGCResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientLBSFindOrCreateLB)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientLBSFindOrCreateLB {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientLBSFindOrCreateLB.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientLBSFindOrCreateLB.leaderboard_sort_method)
    pub leaderboard_sort_method: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientLBSFindOrCreateLB.leaderboard_display_type)
    pub leaderboard_display_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientLBSFindOrCreateLB.create_if_not_found)
    pub create_if_not_found: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientLBSFindOrCreateLB.leaderboard_name)
    pub leaderboard_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientLBSFindOrCreateLB.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientLBSFindOrCreateLB {
    fn default() -> &'a CMsgClientLBSFindOrCreateLB {
        <CMsgClientLBSFindOrCreateLB as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientLBSFindOrCreateLB {
    pub fn new() -> CMsgClientLBSFindOrCreateLB {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional int32 leaderboard_sort_method = 2;

    pub fn leaderboard_sort_method(&self) -> i32 {
        self.leaderboard_sort_method.unwrap_or(0)
    }

    pub fn clear_leaderboard_sort_method(&mut self) {
        self.leaderboard_sort_method = ::std::option::Option::None;
    }

    pub fn has_leaderboard_sort_method(&self) -> bool {
        self.leaderboard_sort_method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_sort_method(&mut self, v: i32) {
        self.leaderboard_sort_method = ::std::option::Option::Some(v);
    }

    // optional int32 leaderboard_display_type = 3;

    pub fn leaderboard_display_type(&self) -> i32 {
        self.leaderboard_display_type.unwrap_or(0)
    }

    pub fn clear_leaderboard_display_type(&mut self) {
        self.leaderboard_display_type = ::std::option::Option::None;
    }

    pub fn has_leaderboard_display_type(&self) -> bool {
        self.leaderboard_display_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_display_type(&mut self, v: i32) {
        self.leaderboard_display_type = ::std::option::Option::Some(v);
    }

    // optional bool create_if_not_found = 4;

    pub fn create_if_not_found(&self) -> bool {
        self.create_if_not_found.unwrap_or(false)
    }

    pub fn clear_create_if_not_found(&mut self) {
        self.create_if_not_found = ::std::option::Option::None;
    }

    pub fn has_create_if_not_found(&self) -> bool {
        self.create_if_not_found.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_if_not_found(&mut self, v: bool) {
        self.create_if_not_found = ::std::option::Option::Some(v);
    }

    // optional string leaderboard_name = 5;

    pub fn leaderboard_name(&self) -> &str {
        match self.leaderboard_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_leaderboard_name(&mut self) {
        self.leaderboard_name = ::std::option::Option::None;
    }

    pub fn has_leaderboard_name(&self) -> bool {
        self.leaderboard_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_name(&mut self, v: ::std::string::String) {
        self.leaderboard_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_leaderboard_name(&mut self) -> &mut ::std::string::String {
        if self.leaderboard_name.is_none() {
            self.leaderboard_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.leaderboard_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_leaderboard_name(&mut self) -> ::std::string::String {
        self.leaderboard_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientLBSFindOrCreateLB| { &m.app_id },
            |m: &mut CMsgClientLBSFindOrCreateLB| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leaderboard_sort_method",
            |m: &CMsgClientLBSFindOrCreateLB| { &m.leaderboard_sort_method },
            |m: &mut CMsgClientLBSFindOrCreateLB| { &mut m.leaderboard_sort_method },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leaderboard_display_type",
            |m: &CMsgClientLBSFindOrCreateLB| { &m.leaderboard_display_type },
            |m: &mut CMsgClientLBSFindOrCreateLB| { &mut m.leaderboard_display_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "create_if_not_found",
            |m: &CMsgClientLBSFindOrCreateLB| { &m.create_if_not_found },
            |m: &mut CMsgClientLBSFindOrCreateLB| { &mut m.create_if_not_found },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leaderboard_name",
            |m: &CMsgClientLBSFindOrCreateLB| { &m.leaderboard_name },
            |m: &mut CMsgClientLBSFindOrCreateLB| { &mut m.leaderboard_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientLBSFindOrCreateLB>(
            "CMsgClientLBSFindOrCreateLB",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientLBSFindOrCreateLB {
    const NAME: &'static str = "CMsgClientLBSFindOrCreateLB";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.leaderboard_sort_method = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.leaderboard_display_type = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.create_if_not_found = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    self.leaderboard_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.leaderboard_sort_method {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.leaderboard_display_type {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.create_if_not_found {
            my_size += 1 + 1;
        }
        if let Some(v) = self.leaderboard_name.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.leaderboard_sort_method {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.leaderboard_display_type {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.create_if_not_found {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.leaderboard_name.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientLBSFindOrCreateLB {
        CMsgClientLBSFindOrCreateLB::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.leaderboard_sort_method = ::std::option::Option::None;
        self.leaderboard_display_type = ::std::option::Option::None;
        self.create_if_not_found = ::std::option::Option::None;
        self.leaderboard_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientLBSFindOrCreateLB {
        static instance: CMsgClientLBSFindOrCreateLB = CMsgClientLBSFindOrCreateLB {
            app_id: ::std::option::Option::None,
            leaderboard_sort_method: ::std::option::Option::None,
            leaderboard_display_type: ::std::option::Option::None,
            create_if_not_found: ::std::option::Option::None,
            leaderboard_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientLBSFindOrCreateLB {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientLBSFindOrCreateLB").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientLBSFindOrCreateLB {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientLBSFindOrCreateLB {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientLBSFindOrCreateLBResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientLBSFindOrCreateLBResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientLBSFindOrCreateLBResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientLBSFindOrCreateLBResponse.leaderboard_id)
    pub leaderboard_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientLBSFindOrCreateLBResponse.leaderboard_entry_count)
    pub leaderboard_entry_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientLBSFindOrCreateLBResponse.leaderboard_sort_method)
    pub leaderboard_sort_method: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientLBSFindOrCreateLBResponse.leaderboard_display_type)
    pub leaderboard_display_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientLBSFindOrCreateLBResponse.leaderboard_name)
    pub leaderboard_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientLBSFindOrCreateLBResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientLBSFindOrCreateLBResponse {
    fn default() -> &'a CMsgClientLBSFindOrCreateLBResponse {
        <CMsgClientLBSFindOrCreateLBResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientLBSFindOrCreateLBResponse {
    pub fn new() -> CMsgClientLBSFindOrCreateLBResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional int32 leaderboard_id = 2;

    pub fn leaderboard_id(&self) -> i32 {
        self.leaderboard_id.unwrap_or(0)
    }

    pub fn clear_leaderboard_id(&mut self) {
        self.leaderboard_id = ::std::option::Option::None;
    }

    pub fn has_leaderboard_id(&self) -> bool {
        self.leaderboard_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_id(&mut self, v: i32) {
        self.leaderboard_id = ::std::option::Option::Some(v);
    }

    // optional int32 leaderboard_entry_count = 3;

    pub fn leaderboard_entry_count(&self) -> i32 {
        self.leaderboard_entry_count.unwrap_or(0)
    }

    pub fn clear_leaderboard_entry_count(&mut self) {
        self.leaderboard_entry_count = ::std::option::Option::None;
    }

    pub fn has_leaderboard_entry_count(&self) -> bool {
        self.leaderboard_entry_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_entry_count(&mut self, v: i32) {
        self.leaderboard_entry_count = ::std::option::Option::Some(v);
    }

    // optional int32 leaderboard_sort_method = 4;

    pub fn leaderboard_sort_method(&self) -> i32 {
        self.leaderboard_sort_method.unwrap_or(0i32)
    }

    pub fn clear_leaderboard_sort_method(&mut self) {
        self.leaderboard_sort_method = ::std::option::Option::None;
    }

    pub fn has_leaderboard_sort_method(&self) -> bool {
        self.leaderboard_sort_method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_sort_method(&mut self, v: i32) {
        self.leaderboard_sort_method = ::std::option::Option::Some(v);
    }

    // optional int32 leaderboard_display_type = 5;

    pub fn leaderboard_display_type(&self) -> i32 {
        self.leaderboard_display_type.unwrap_or(0i32)
    }

    pub fn clear_leaderboard_display_type(&mut self) {
        self.leaderboard_display_type = ::std::option::Option::None;
    }

    pub fn has_leaderboard_display_type(&self) -> bool {
        self.leaderboard_display_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_display_type(&mut self, v: i32) {
        self.leaderboard_display_type = ::std::option::Option::Some(v);
    }

    // optional string leaderboard_name = 6;

    pub fn leaderboard_name(&self) -> &str {
        match self.leaderboard_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_leaderboard_name(&mut self) {
        self.leaderboard_name = ::std::option::Option::None;
    }

    pub fn has_leaderboard_name(&self) -> bool {
        self.leaderboard_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_name(&mut self, v: ::std::string::String) {
        self.leaderboard_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_leaderboard_name(&mut self) -> &mut ::std::string::String {
        if self.leaderboard_name.is_none() {
            self.leaderboard_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.leaderboard_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_leaderboard_name(&mut self) -> ::std::string::String {
        self.leaderboard_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientLBSFindOrCreateLBResponse| { &m.eresult },
            |m: &mut CMsgClientLBSFindOrCreateLBResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leaderboard_id",
            |m: &CMsgClientLBSFindOrCreateLBResponse| { &m.leaderboard_id },
            |m: &mut CMsgClientLBSFindOrCreateLBResponse| { &mut m.leaderboard_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leaderboard_entry_count",
            |m: &CMsgClientLBSFindOrCreateLBResponse| { &m.leaderboard_entry_count },
            |m: &mut CMsgClientLBSFindOrCreateLBResponse| { &mut m.leaderboard_entry_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leaderboard_sort_method",
            |m: &CMsgClientLBSFindOrCreateLBResponse| { &m.leaderboard_sort_method },
            |m: &mut CMsgClientLBSFindOrCreateLBResponse| { &mut m.leaderboard_sort_method },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leaderboard_display_type",
            |m: &CMsgClientLBSFindOrCreateLBResponse| { &m.leaderboard_display_type },
            |m: &mut CMsgClientLBSFindOrCreateLBResponse| { &mut m.leaderboard_display_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leaderboard_name",
            |m: &CMsgClientLBSFindOrCreateLBResponse| { &m.leaderboard_name },
            |m: &mut CMsgClientLBSFindOrCreateLBResponse| { &mut m.leaderboard_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientLBSFindOrCreateLBResponse>(
            "CMsgClientLBSFindOrCreateLBResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientLBSFindOrCreateLBResponse {
    const NAME: &'static str = "CMsgClientLBSFindOrCreateLBResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.leaderboard_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.leaderboard_entry_count = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.leaderboard_sort_method = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.leaderboard_display_type = ::std::option::Option::Some(is.read_int32()?);
                },
                50 => {
                    self.leaderboard_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.leaderboard_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.leaderboard_entry_count {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.leaderboard_sort_method {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.leaderboard_display_type {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.leaderboard_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.leaderboard_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.leaderboard_entry_count {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.leaderboard_sort_method {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.leaderboard_display_type {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.leaderboard_name.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientLBSFindOrCreateLBResponse {
        CMsgClientLBSFindOrCreateLBResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.leaderboard_id = ::std::option::Option::None;
        self.leaderboard_entry_count = ::std::option::Option::None;
        self.leaderboard_sort_method = ::std::option::Option::None;
        self.leaderboard_display_type = ::std::option::Option::None;
        self.leaderboard_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientLBSFindOrCreateLBResponse {
        static instance: CMsgClientLBSFindOrCreateLBResponse = CMsgClientLBSFindOrCreateLBResponse {
            eresult: ::std::option::Option::None,
            leaderboard_id: ::std::option::Option::None,
            leaderboard_entry_count: ::std::option::Option::None,
            leaderboard_sort_method: ::std::option::Option::None,
            leaderboard_display_type: ::std::option::Option::None,
            leaderboard_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientLBSFindOrCreateLBResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientLBSFindOrCreateLBResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientLBSFindOrCreateLBResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientLBSFindOrCreateLBResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientLBSGetLBEntries)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientLBSGetLBEntries {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientLBSGetLBEntries.app_id)
    pub app_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientLBSGetLBEntries.leaderboard_id)
    pub leaderboard_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientLBSGetLBEntries.range_start)
    pub range_start: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientLBSGetLBEntries.range_end)
    pub range_end: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientLBSGetLBEntries.leaderboard_data_request)
    pub leaderboard_data_request: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientLBSGetLBEntries.steamids)
    pub steamids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientLBSGetLBEntries.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientLBSGetLBEntries {
    fn default() -> &'a CMsgClientLBSGetLBEntries {
        <CMsgClientLBSGetLBEntries as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientLBSGetLBEntries {
    pub fn new() -> CMsgClientLBSGetLBEntries {
        ::std::default::Default::default()
    }

    // optional int32 app_id = 1;

    pub fn app_id(&self) -> i32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: i32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional int32 leaderboard_id = 2;

    pub fn leaderboard_id(&self) -> i32 {
        self.leaderboard_id.unwrap_or(0)
    }

    pub fn clear_leaderboard_id(&mut self) {
        self.leaderboard_id = ::std::option::Option::None;
    }

    pub fn has_leaderboard_id(&self) -> bool {
        self.leaderboard_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_id(&mut self, v: i32) {
        self.leaderboard_id = ::std::option::Option::Some(v);
    }

    // optional int32 range_start = 3;

    pub fn range_start(&self) -> i32 {
        self.range_start.unwrap_or(0)
    }

    pub fn clear_range_start(&mut self) {
        self.range_start = ::std::option::Option::None;
    }

    pub fn has_range_start(&self) -> bool {
        self.range_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_range_start(&mut self, v: i32) {
        self.range_start = ::std::option::Option::Some(v);
    }

    // optional int32 range_end = 4;

    pub fn range_end(&self) -> i32 {
        self.range_end.unwrap_or(0)
    }

    pub fn clear_range_end(&mut self) {
        self.range_end = ::std::option::Option::None;
    }

    pub fn has_range_end(&self) -> bool {
        self.range_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_range_end(&mut self, v: i32) {
        self.range_end = ::std::option::Option::Some(v);
    }

    // optional int32 leaderboard_data_request = 5;

    pub fn leaderboard_data_request(&self) -> i32 {
        self.leaderboard_data_request.unwrap_or(0)
    }

    pub fn clear_leaderboard_data_request(&mut self) {
        self.leaderboard_data_request = ::std::option::Option::None;
    }

    pub fn has_leaderboard_data_request(&self) -> bool {
        self.leaderboard_data_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_data_request(&mut self, v: i32) {
        self.leaderboard_data_request = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientLBSGetLBEntries| { &m.app_id },
            |m: &mut CMsgClientLBSGetLBEntries| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leaderboard_id",
            |m: &CMsgClientLBSGetLBEntries| { &m.leaderboard_id },
            |m: &mut CMsgClientLBSGetLBEntries| { &mut m.leaderboard_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "range_start",
            |m: &CMsgClientLBSGetLBEntries| { &m.range_start },
            |m: &mut CMsgClientLBSGetLBEntries| { &mut m.range_start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "range_end",
            |m: &CMsgClientLBSGetLBEntries| { &m.range_end },
            |m: &mut CMsgClientLBSGetLBEntries| { &mut m.range_end },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leaderboard_data_request",
            |m: &CMsgClientLBSGetLBEntries| { &m.leaderboard_data_request },
            |m: &mut CMsgClientLBSGetLBEntries| { &mut m.leaderboard_data_request },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "steamids",
            |m: &CMsgClientLBSGetLBEntries| { &m.steamids },
            |m: &mut CMsgClientLBSGetLBEntries| { &mut m.steamids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientLBSGetLBEntries>(
            "CMsgClientLBSGetLBEntries",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientLBSGetLBEntries {
    const NAME: &'static str = "CMsgClientLBSGetLBEntries";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.leaderboard_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.range_start = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.range_end = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.leaderboard_data_request = ::std::option::Option::Some(is.read_int32()?);
                },
                50 => {
                    is.read_repeated_packed_fixed64_into(&mut self.steamids)?;
                },
                49 => {
                    self.steamids.push(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.leaderboard_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.range_start {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.range_end {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.leaderboard_data_request {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        my_size += 9 * self.steamids.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.leaderboard_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.range_start {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.range_end {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.leaderboard_data_request {
            os.write_int32(5, v)?;
        }
        for v in &self.steamids {
            os.write_fixed64(6, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientLBSGetLBEntries {
        CMsgClientLBSGetLBEntries::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.leaderboard_id = ::std::option::Option::None;
        self.range_start = ::std::option::Option::None;
        self.range_end = ::std::option::Option::None;
        self.leaderboard_data_request = ::std::option::Option::None;
        self.steamids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientLBSGetLBEntries {
        static instance: CMsgClientLBSGetLBEntries = CMsgClientLBSGetLBEntries {
            app_id: ::std::option::Option::None,
            leaderboard_id: ::std::option::Option::None,
            range_start: ::std::option::Option::None,
            range_end: ::std::option::Option::None,
            leaderboard_data_request: ::std::option::Option::None,
            steamids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientLBSGetLBEntries {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientLBSGetLBEntries").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientLBSGetLBEntries {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientLBSGetLBEntries {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientLBSGetLBEntriesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientLBSGetLBEntriesResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientLBSGetLBEntriesResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientLBSGetLBEntriesResponse.leaderboard_entry_count)
    pub leaderboard_entry_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientLBSGetLBEntriesResponse.entries)
    pub entries: ::std::vec::Vec<cmsg_client_lbsget_lbentries_response::Entry>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientLBSGetLBEntriesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientLBSGetLBEntriesResponse {
    fn default() -> &'a CMsgClientLBSGetLBEntriesResponse {
        <CMsgClientLBSGetLBEntriesResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientLBSGetLBEntriesResponse {
    pub fn new() -> CMsgClientLBSGetLBEntriesResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional int32 leaderboard_entry_count = 2;

    pub fn leaderboard_entry_count(&self) -> i32 {
        self.leaderboard_entry_count.unwrap_or(0)
    }

    pub fn clear_leaderboard_entry_count(&mut self) {
        self.leaderboard_entry_count = ::std::option::Option::None;
    }

    pub fn has_leaderboard_entry_count(&self) -> bool {
        self.leaderboard_entry_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_entry_count(&mut self, v: i32) {
        self.leaderboard_entry_count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientLBSGetLBEntriesResponse| { &m.eresult },
            |m: &mut CMsgClientLBSGetLBEntriesResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leaderboard_entry_count",
            |m: &CMsgClientLBSGetLBEntriesResponse| { &m.leaderboard_entry_count },
            |m: &mut CMsgClientLBSGetLBEntriesResponse| { &mut m.leaderboard_entry_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entries",
            |m: &CMsgClientLBSGetLBEntriesResponse| { &m.entries },
            |m: &mut CMsgClientLBSGetLBEntriesResponse| { &mut m.entries },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientLBSGetLBEntriesResponse>(
            "CMsgClientLBSGetLBEntriesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientLBSGetLBEntriesResponse {
    const NAME: &'static str = "CMsgClientLBSGetLBEntriesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.leaderboard_entry_count = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.entries.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.leaderboard_entry_count {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.leaderboard_entry_count {
            os.write_int32(2, v)?;
        }
        for v in &self.entries {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientLBSGetLBEntriesResponse {
        CMsgClientLBSGetLBEntriesResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.leaderboard_entry_count = ::std::option::Option::None;
        self.entries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientLBSGetLBEntriesResponse {
        static instance: CMsgClientLBSGetLBEntriesResponse = CMsgClientLBSGetLBEntriesResponse {
            eresult: ::std::option::Option::None,
            leaderboard_entry_count: ::std::option::Option::None,
            entries: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientLBSGetLBEntriesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientLBSGetLBEntriesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientLBSGetLBEntriesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientLBSGetLBEntriesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientLBSGetLBEntriesResponse`
pub mod cmsg_client_lbsget_lbentries_response {
    // @@protoc_insertion_point(message:CMsgClientLBSGetLBEntriesResponse.Entry)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Entry {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientLBSGetLBEntriesResponse.Entry.steam_id_user)
        pub steam_id_user: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientLBSGetLBEntriesResponse.Entry.global_rank)
        pub global_rank: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientLBSGetLBEntriesResponse.Entry.score)
        pub score: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientLBSGetLBEntriesResponse.Entry.details)
        pub details: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:CMsgClientLBSGetLBEntriesResponse.Entry.ugc_id)
        pub ugc_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientLBSGetLBEntriesResponse.Entry.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Entry {
        fn default() -> &'a Entry {
            <Entry as ::protobuf::Message>::default_instance()
        }
    }

    impl Entry {
        pub fn new() -> Entry {
            ::std::default::Default::default()
        }

        // optional fixed64 steam_id_user = 1;

        pub fn steam_id_user(&self) -> u64 {
            self.steam_id_user.unwrap_or(0)
        }

        pub fn clear_steam_id_user(&mut self) {
            self.steam_id_user = ::std::option::Option::None;
        }

        pub fn has_steam_id_user(&self) -> bool {
            self.steam_id_user.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id_user(&mut self, v: u64) {
            self.steam_id_user = ::std::option::Option::Some(v);
        }

        // optional int32 global_rank = 2;

        pub fn global_rank(&self) -> i32 {
            self.global_rank.unwrap_or(0)
        }

        pub fn clear_global_rank(&mut self) {
            self.global_rank = ::std::option::Option::None;
        }

        pub fn has_global_rank(&self) -> bool {
            self.global_rank.is_some()
        }

        // Param is passed by value, moved
        pub fn set_global_rank(&mut self, v: i32) {
            self.global_rank = ::std::option::Option::Some(v);
        }

        // optional int32 score = 3;

        pub fn score(&self) -> i32 {
            self.score.unwrap_or(0)
        }

        pub fn clear_score(&mut self) {
            self.score = ::std::option::Option::None;
        }

        pub fn has_score(&self) -> bool {
            self.score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score(&mut self, v: i32) {
            self.score = ::std::option::Option::Some(v);
        }

        // optional bytes details = 4;

        pub fn details(&self) -> &[u8] {
            match self.details.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_details(&mut self) {
            self.details = ::std::option::Option::None;
        }

        pub fn has_details(&self) -> bool {
            self.details.is_some()
        }

        // Param is passed by value, moved
        pub fn set_details(&mut self, v: ::std::vec::Vec<u8>) {
            self.details = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_details(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.details.is_none() {
                self.details = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.details.as_mut().unwrap()
        }

        // Take field
        pub fn take_details(&mut self) -> ::std::vec::Vec<u8> {
            self.details.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional fixed64 ugc_id = 5;

        pub fn ugc_id(&self) -> u64 {
            self.ugc_id.unwrap_or(0)
        }

        pub fn clear_ugc_id(&mut self) {
            self.ugc_id = ::std::option::Option::None;
        }

        pub fn has_ugc_id(&self) -> bool {
            self.ugc_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ugc_id(&mut self, v: u64) {
            self.ugc_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "steam_id_user",
                |m: &Entry| { &m.steam_id_user },
                |m: &mut Entry| { &mut m.steam_id_user },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "global_rank",
                |m: &Entry| { &m.global_rank },
                |m: &mut Entry| { &mut m.global_rank },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "score",
                |m: &Entry| { &m.score },
                |m: &mut Entry| { &mut m.score },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "details",
                |m: &Entry| { &m.details },
                |m: &mut Entry| { &mut m.details },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ugc_id",
                |m: &Entry| { &m.ugc_id },
                |m: &mut Entry| { &mut m.ugc_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Entry>(
                "CMsgClientLBSGetLBEntriesResponse.Entry",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Entry {
        const NAME: &'static str = "Entry";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steam_id_user = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.global_rank = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.score = ::std::option::Option::Some(is.read_int32()?);
                    },
                    34 => {
                        self.details = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    41 => {
                        self.ugc_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id_user {
                my_size += 1 + 8;
            }
            if let Some(v) = self.global_rank {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.score {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.details.as_ref() {
                my_size += ::protobuf::rt::bytes_size(4, &v);
            }
            if let Some(v) = self.ugc_id {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.steam_id_user {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.global_rank {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.score {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.details.as_ref() {
                os.write_bytes(4, v)?;
            }
            if let Some(v) = self.ugc_id {
                os.write_fixed64(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Entry {
            Entry::new()
        }

        fn clear(&mut self) {
            self.steam_id_user = ::std::option::Option::None;
            self.global_rank = ::std::option::Option::None;
            self.score = ::std::option::Option::None;
            self.details = ::std::option::Option::None;
            self.ugc_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Entry {
            static instance: Entry = Entry {
                steam_id_user: ::std::option::Option::None,
                global_rank: ::std::option::Option::None,
                score: ::std::option::Option::None,
                details: ::std::option::Option::None,
                ugc_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Entry {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientLBSGetLBEntriesResponse.Entry").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Entry {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Entry {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientIsLimitedAccount)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientIsLimitedAccount {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientIsLimitedAccount.bis_limited_account)
    pub bis_limited_account: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientIsLimitedAccount.bis_community_banned)
    pub bis_community_banned: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientIsLimitedAccount.bis_locked_account)
    pub bis_locked_account: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientIsLimitedAccount.bis_limited_account_allowed_to_invite_friends)
    pub bis_limited_account_allowed_to_invite_friends: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientIsLimitedAccount.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientIsLimitedAccount {
    fn default() -> &'a CMsgClientIsLimitedAccount {
        <CMsgClientIsLimitedAccount as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientIsLimitedAccount {
    pub fn new() -> CMsgClientIsLimitedAccount {
        ::std::default::Default::default()
    }

    // optional bool bis_limited_account = 1;

    pub fn bis_limited_account(&self) -> bool {
        self.bis_limited_account.unwrap_or(false)
    }

    pub fn clear_bis_limited_account(&mut self) {
        self.bis_limited_account = ::std::option::Option::None;
    }

    pub fn has_bis_limited_account(&self) -> bool {
        self.bis_limited_account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bis_limited_account(&mut self, v: bool) {
        self.bis_limited_account = ::std::option::Option::Some(v);
    }

    // optional bool bis_community_banned = 2;

    pub fn bis_community_banned(&self) -> bool {
        self.bis_community_banned.unwrap_or(false)
    }

    pub fn clear_bis_community_banned(&mut self) {
        self.bis_community_banned = ::std::option::Option::None;
    }

    pub fn has_bis_community_banned(&self) -> bool {
        self.bis_community_banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bis_community_banned(&mut self, v: bool) {
        self.bis_community_banned = ::std::option::Option::Some(v);
    }

    // optional bool bis_locked_account = 3;

    pub fn bis_locked_account(&self) -> bool {
        self.bis_locked_account.unwrap_or(false)
    }

    pub fn clear_bis_locked_account(&mut self) {
        self.bis_locked_account = ::std::option::Option::None;
    }

    pub fn has_bis_locked_account(&self) -> bool {
        self.bis_locked_account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bis_locked_account(&mut self, v: bool) {
        self.bis_locked_account = ::std::option::Option::Some(v);
    }

    // optional bool bis_limited_account_allowed_to_invite_friends = 4;

    pub fn bis_limited_account_allowed_to_invite_friends(&self) -> bool {
        self.bis_limited_account_allowed_to_invite_friends.unwrap_or(false)
    }

    pub fn clear_bis_limited_account_allowed_to_invite_friends(&mut self) {
        self.bis_limited_account_allowed_to_invite_friends = ::std::option::Option::None;
    }

    pub fn has_bis_limited_account_allowed_to_invite_friends(&self) -> bool {
        self.bis_limited_account_allowed_to_invite_friends.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bis_limited_account_allowed_to_invite_friends(&mut self, v: bool) {
        self.bis_limited_account_allowed_to_invite_friends = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bis_limited_account",
            |m: &CMsgClientIsLimitedAccount| { &m.bis_limited_account },
            |m: &mut CMsgClientIsLimitedAccount| { &mut m.bis_limited_account },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bis_community_banned",
            |m: &CMsgClientIsLimitedAccount| { &m.bis_community_banned },
            |m: &mut CMsgClientIsLimitedAccount| { &mut m.bis_community_banned },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bis_locked_account",
            |m: &CMsgClientIsLimitedAccount| { &m.bis_locked_account },
            |m: &mut CMsgClientIsLimitedAccount| { &mut m.bis_locked_account },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bis_limited_account_allowed_to_invite_friends",
            |m: &CMsgClientIsLimitedAccount| { &m.bis_limited_account_allowed_to_invite_friends },
            |m: &mut CMsgClientIsLimitedAccount| { &mut m.bis_limited_account_allowed_to_invite_friends },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientIsLimitedAccount>(
            "CMsgClientIsLimitedAccount",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientIsLimitedAccount {
    const NAME: &'static str = "CMsgClientIsLimitedAccount";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.bis_limited_account = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.bis_community_banned = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.bis_locked_account = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.bis_limited_account_allowed_to_invite_friends = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.bis_limited_account {
            my_size += 1 + 1;
        }
        if let Some(v) = self.bis_community_banned {
            my_size += 1 + 1;
        }
        if let Some(v) = self.bis_locked_account {
            my_size += 1 + 1;
        }
        if let Some(v) = self.bis_limited_account_allowed_to_invite_friends {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.bis_limited_account {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.bis_community_banned {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.bis_locked_account {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.bis_limited_account_allowed_to_invite_friends {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientIsLimitedAccount {
        CMsgClientIsLimitedAccount::new()
    }

    fn clear(&mut self) {
        self.bis_limited_account = ::std::option::Option::None;
        self.bis_community_banned = ::std::option::Option::None;
        self.bis_locked_account = ::std::option::Option::None;
        self.bis_limited_account_allowed_to_invite_friends = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientIsLimitedAccount {
        static instance: CMsgClientIsLimitedAccount = CMsgClientIsLimitedAccount {
            bis_limited_account: ::std::option::Option::None,
            bis_community_banned: ::std::option::Option::None,
            bis_locked_account: ::std::option::Option::None,
            bis_limited_account_allowed_to_invite_friends: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientIsLimitedAccount {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientIsLimitedAccount").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientIsLimitedAccount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientIsLimitedAccount {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRequestedClientStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestedClientStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRequestedClientStats.stats_to_send)
    pub stats_to_send: ::std::vec::Vec<cmsg_client_requested_client_stats::StatsToSend>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestedClientStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestedClientStats {
    fn default() -> &'a CMsgClientRequestedClientStats {
        <CMsgClientRequestedClientStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestedClientStats {
    pub fn new() -> CMsgClientRequestedClientStats {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stats_to_send",
            |m: &CMsgClientRequestedClientStats| { &m.stats_to_send },
            |m: &mut CMsgClientRequestedClientStats| { &mut m.stats_to_send },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRequestedClientStats>(
            "CMsgClientRequestedClientStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientRequestedClientStats {
    const NAME: &'static str = "CMsgClientRequestedClientStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.stats_to_send.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.stats_to_send {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.stats_to_send {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestedClientStats {
        CMsgClientRequestedClientStats::new()
    }

    fn clear(&mut self) {
        self.stats_to_send.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestedClientStats {
        static instance: CMsgClientRequestedClientStats = CMsgClientRequestedClientStats {
            stats_to_send: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientRequestedClientStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRequestedClientStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRequestedClientStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestedClientStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientRequestedClientStats`
pub mod cmsg_client_requested_client_stats {
    // @@protoc_insertion_point(message:CMsgClientRequestedClientStats.StatsToSend)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct StatsToSend {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientRequestedClientStats.StatsToSend.client_stat)
        pub client_stat: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientRequestedClientStats.StatsToSend.stat_aggregate_method)
        pub stat_aggregate_method: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientRequestedClientStats.StatsToSend.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a StatsToSend {
        fn default() -> &'a StatsToSend {
            <StatsToSend as ::protobuf::Message>::default_instance()
        }
    }

    impl StatsToSend {
        pub fn new() -> StatsToSend {
            ::std::default::Default::default()
        }

        // optional uint32 client_stat = 1;

        pub fn client_stat(&self) -> u32 {
            self.client_stat.unwrap_or(0)
        }

        pub fn clear_client_stat(&mut self) {
            self.client_stat = ::std::option::Option::None;
        }

        pub fn has_client_stat(&self) -> bool {
            self.client_stat.is_some()
        }

        // Param is passed by value, moved
        pub fn set_client_stat(&mut self, v: u32) {
            self.client_stat = ::std::option::Option::Some(v);
        }

        // optional uint32 stat_aggregate_method = 2;

        pub fn stat_aggregate_method(&self) -> u32 {
            self.stat_aggregate_method.unwrap_or(0)
        }

        pub fn clear_stat_aggregate_method(&mut self) {
            self.stat_aggregate_method = ::std::option::Option::None;
        }

        pub fn has_stat_aggregate_method(&self) -> bool {
            self.stat_aggregate_method.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stat_aggregate_method(&mut self, v: u32) {
            self.stat_aggregate_method = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "client_stat",
                |m: &StatsToSend| { &m.client_stat },
                |m: &mut StatsToSend| { &mut m.client_stat },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "stat_aggregate_method",
                |m: &StatsToSend| { &m.stat_aggregate_method },
                |m: &mut StatsToSend| { &mut m.stat_aggregate_method },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatsToSend>(
                "CMsgClientRequestedClientStats.StatsToSend",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for StatsToSend {
        const NAME: &'static str = "StatsToSend";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.client_stat = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.stat_aggregate_method = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.client_stat {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.stat_aggregate_method {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.client_stat {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.stat_aggregate_method {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> StatsToSend {
            StatsToSend::new()
        }

        fn clear(&mut self) {
            self.client_stat = ::std::option::Option::None;
            self.stat_aggregate_method = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static StatsToSend {
            static instance: StatsToSend = StatsToSend {
                client_stat: ::std::option::Option::None,
                stat_aggregate_method: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for StatsToSend {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientRequestedClientStats.StatsToSend").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for StatsToSend {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for StatsToSend {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientStat2)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientStat2 {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientStat2.stat_detail)
    pub stat_detail: ::std::vec::Vec<cmsg_client_stat2::StatDetail>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientStat2.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientStat2 {
    fn default() -> &'a CMsgClientStat2 {
        <CMsgClientStat2 as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientStat2 {
    pub fn new() -> CMsgClientStat2 {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stat_detail",
            |m: &CMsgClientStat2| { &m.stat_detail },
            |m: &mut CMsgClientStat2| { &mut m.stat_detail },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientStat2>(
            "CMsgClientStat2",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientStat2 {
    const NAME: &'static str = "CMsgClientStat2";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.stat_detail.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.stat_detail {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.stat_detail {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientStat2 {
        CMsgClientStat2::new()
    }

    fn clear(&mut self) {
        self.stat_detail.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientStat2 {
        static instance: CMsgClientStat2 = CMsgClientStat2 {
            stat_detail: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientStat2 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientStat2").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientStat2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientStat2 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientStat2`
pub mod cmsg_client_stat2 {
    // @@protoc_insertion_point(message:CMsgClientStat2.StatDetail)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct StatDetail {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientStat2.StatDetail.client_stat)
        pub client_stat: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientStat2.StatDetail.ll_value)
        pub ll_value: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:CMsgClientStat2.StatDetail.time_of_day)
        pub time_of_day: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientStat2.StatDetail.cell_id)
        pub cell_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientStat2.StatDetail.depot_id)
        pub depot_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientStat2.StatDetail.app_id)
        pub app_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientStat2.StatDetail.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a StatDetail {
        fn default() -> &'a StatDetail {
            <StatDetail as ::protobuf::Message>::default_instance()
        }
    }

    impl StatDetail {
        pub fn new() -> StatDetail {
            ::std::default::Default::default()
        }

        // optional uint32 client_stat = 1;

        pub fn client_stat(&self) -> u32 {
            self.client_stat.unwrap_or(0)
        }

        pub fn clear_client_stat(&mut self) {
            self.client_stat = ::std::option::Option::None;
        }

        pub fn has_client_stat(&self) -> bool {
            self.client_stat.is_some()
        }

        // Param is passed by value, moved
        pub fn set_client_stat(&mut self, v: u32) {
            self.client_stat = ::std::option::Option::Some(v);
        }

        // optional int64 ll_value = 2;

        pub fn ll_value(&self) -> i64 {
            self.ll_value.unwrap_or(0)
        }

        pub fn clear_ll_value(&mut self) {
            self.ll_value = ::std::option::Option::None;
        }

        pub fn has_ll_value(&self) -> bool {
            self.ll_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ll_value(&mut self, v: i64) {
            self.ll_value = ::std::option::Option::Some(v);
        }

        // optional uint32 time_of_day = 3;

        pub fn time_of_day(&self) -> u32 {
            self.time_of_day.unwrap_or(0)
        }

        pub fn clear_time_of_day(&mut self) {
            self.time_of_day = ::std::option::Option::None;
        }

        pub fn has_time_of_day(&self) -> bool {
            self.time_of_day.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_of_day(&mut self, v: u32) {
            self.time_of_day = ::std::option::Option::Some(v);
        }

        // optional uint32 cell_id = 4;

        pub fn cell_id(&self) -> u32 {
            self.cell_id.unwrap_or(0)
        }

        pub fn clear_cell_id(&mut self) {
            self.cell_id = ::std::option::Option::None;
        }

        pub fn has_cell_id(&self) -> bool {
            self.cell_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_cell_id(&mut self, v: u32) {
            self.cell_id = ::std::option::Option::Some(v);
        }

        // optional uint32 depot_id = 5;

        pub fn depot_id(&self) -> u32 {
            self.depot_id.unwrap_or(0)
        }

        pub fn clear_depot_id(&mut self) {
            self.depot_id = ::std::option::Option::None;
        }

        pub fn has_depot_id(&self) -> bool {
            self.depot_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_depot_id(&mut self, v: u32) {
            self.depot_id = ::std::option::Option::Some(v);
        }

        // optional uint32 app_id = 6;

        pub fn app_id(&self) -> u32 {
            self.app_id.unwrap_or(0)
        }

        pub fn clear_app_id(&mut self) {
            self.app_id = ::std::option::Option::None;
        }

        pub fn has_app_id(&self) -> bool {
            self.app_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_app_id(&mut self, v: u32) {
            self.app_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "client_stat",
                |m: &StatDetail| { &m.client_stat },
                |m: &mut StatDetail| { &mut m.client_stat },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ll_value",
                |m: &StatDetail| { &m.ll_value },
                |m: &mut StatDetail| { &mut m.ll_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "time_of_day",
                |m: &StatDetail| { &m.time_of_day },
                |m: &mut StatDetail| { &mut m.time_of_day },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "cell_id",
                |m: &StatDetail| { &m.cell_id },
                |m: &mut StatDetail| { &mut m.cell_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "depot_id",
                |m: &StatDetail| { &m.depot_id },
                |m: &mut StatDetail| { &mut m.depot_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "app_id",
                |m: &StatDetail| { &m.app_id },
                |m: &mut StatDetail| { &mut m.app_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatDetail>(
                "CMsgClientStat2.StatDetail",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for StatDetail {
        const NAME: &'static str = "StatDetail";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.client_stat = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.ll_value = ::std::option::Option::Some(is.read_int64()?);
                    },
                    24 => {
                        self.time_of_day = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.cell_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.depot_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.client_stat {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.ll_value {
                my_size += ::protobuf::rt::int64_size(2, v);
            }
            if let Some(v) = self.time_of_day {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.cell_id {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.depot_id {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.app_id {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.client_stat {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.ll_value {
                os.write_int64(2, v)?;
            }
            if let Some(v) = self.time_of_day {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.cell_id {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.depot_id {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.app_id {
                os.write_uint32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> StatDetail {
            StatDetail::new()
        }

        fn clear(&mut self) {
            self.client_stat = ::std::option::Option::None;
            self.ll_value = ::std::option::Option::None;
            self.time_of_day = ::std::option::Option::None;
            self.cell_id = ::std::option::Option::None;
            self.depot_id = ::std::option::Option::None;
            self.app_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static StatDetail {
            static instance: StatDetail = StatDetail {
                client_stat: ::std::option::Option::None,
                ll_value: ::std::option::Option::None,
                time_of_day: ::std::option::Option::None,
                cell_id: ::std::option::Option::None,
                depot_id: ::std::option::Option::None,
                app_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for StatDetail {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientStat2.StatDetail").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for StatDetail {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for StatDetail {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientMMSSetRatelimitPolicyOnClient)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSSetRatelimitPolicyOnClient {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSSetRatelimitPolicyOnClient.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetRatelimitPolicyOnClient.enable_rate_limits)
    pub enable_rate_limits: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetRatelimitPolicyOnClient.seconds_per_message)
    pub seconds_per_message: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetRatelimitPolicyOnClient.milliseconds_per_data_update)
    pub milliseconds_per_data_update: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSSetRatelimitPolicyOnClient.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSSetRatelimitPolicyOnClient {
    fn default() -> &'a CMsgClientMMSSetRatelimitPolicyOnClient {
        <CMsgClientMMSSetRatelimitPolicyOnClient as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSSetRatelimitPolicyOnClient {
    pub fn new() -> CMsgClientMMSSetRatelimitPolicyOnClient {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional bool enable_rate_limits = 2;

    pub fn enable_rate_limits(&self) -> bool {
        self.enable_rate_limits.unwrap_or(false)
    }

    pub fn clear_enable_rate_limits(&mut self) {
        self.enable_rate_limits = ::std::option::Option::None;
    }

    pub fn has_enable_rate_limits(&self) -> bool {
        self.enable_rate_limits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_rate_limits(&mut self, v: bool) {
        self.enable_rate_limits = ::std::option::Option::Some(v);
    }

    // optional int32 seconds_per_message = 3;

    pub fn seconds_per_message(&self) -> i32 {
        self.seconds_per_message.unwrap_or(0)
    }

    pub fn clear_seconds_per_message(&mut self) {
        self.seconds_per_message = ::std::option::Option::None;
    }

    pub fn has_seconds_per_message(&self) -> bool {
        self.seconds_per_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_per_message(&mut self, v: i32) {
        self.seconds_per_message = ::std::option::Option::Some(v);
    }

    // optional int32 milliseconds_per_data_update = 4;

    pub fn milliseconds_per_data_update(&self) -> i32 {
        self.milliseconds_per_data_update.unwrap_or(0)
    }

    pub fn clear_milliseconds_per_data_update(&mut self) {
        self.milliseconds_per_data_update = ::std::option::Option::None;
    }

    pub fn has_milliseconds_per_data_update(&self) -> bool {
        self.milliseconds_per_data_update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_milliseconds_per_data_update(&mut self, v: i32) {
        self.milliseconds_per_data_update = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSSetRatelimitPolicyOnClient| { &m.app_id },
            |m: &mut CMsgClientMMSSetRatelimitPolicyOnClient| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "enable_rate_limits",
            |m: &CMsgClientMMSSetRatelimitPolicyOnClient| { &m.enable_rate_limits },
            |m: &mut CMsgClientMMSSetRatelimitPolicyOnClient| { &mut m.enable_rate_limits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seconds_per_message",
            |m: &CMsgClientMMSSetRatelimitPolicyOnClient| { &m.seconds_per_message },
            |m: &mut CMsgClientMMSSetRatelimitPolicyOnClient| { &mut m.seconds_per_message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "milliseconds_per_data_update",
            |m: &CMsgClientMMSSetRatelimitPolicyOnClient| { &m.milliseconds_per_data_update },
            |m: &mut CMsgClientMMSSetRatelimitPolicyOnClient| { &mut m.milliseconds_per_data_update },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSSetRatelimitPolicyOnClient>(
            "CMsgClientMMSSetRatelimitPolicyOnClient",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientMMSSetRatelimitPolicyOnClient {
    const NAME: &'static str = "CMsgClientMMSSetRatelimitPolicyOnClient";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.enable_rate_limits = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.seconds_per_message = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.milliseconds_per_data_update = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.enable_rate_limits {
            my_size += 1 + 1;
        }
        if let Some(v) = self.seconds_per_message {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.milliseconds_per_data_update {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.enable_rate_limits {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.seconds_per_message {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.milliseconds_per_data_update {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSSetRatelimitPolicyOnClient {
        CMsgClientMMSSetRatelimitPolicyOnClient::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.enable_rate_limits = ::std::option::Option::None;
        self.seconds_per_message = ::std::option::Option::None;
        self.milliseconds_per_data_update = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSSetRatelimitPolicyOnClient {
        static instance: CMsgClientMMSSetRatelimitPolicyOnClient = CMsgClientMMSSetRatelimitPolicyOnClient {
            app_id: ::std::option::Option::None,
            enable_rate_limits: ::std::option::Option::None,
            seconds_per_message: ::std::option::Option::None,
            milliseconds_per_data_update: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientMMSSetRatelimitPolicyOnClient {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSSetRatelimitPolicyOnClient").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSSetRatelimitPolicyOnClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSSetRatelimitPolicyOnClient {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientMMSCreateLobby)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSCreateLobby {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSCreateLobby.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSCreateLobby.max_members)
    pub max_members: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSCreateLobby.lobby_type)
    pub lobby_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSCreateLobby.lobby_flags)
    pub lobby_flags: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSCreateLobby.cell_id)
    pub cell_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSCreateLobby.deprecated_public_ip)
    pub deprecated_public_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSCreateLobby.metadata)
    pub metadata: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientMMSCreateLobby.persona_name_owner)
    pub persona_name_owner: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientMMSCreateLobby.public_ip)
    pub public_ip: ::protobuf::MessageField<super::steammessages_base::CMsgIPAddress>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSCreateLobby.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSCreateLobby {
    fn default() -> &'a CMsgClientMMSCreateLobby {
        <CMsgClientMMSCreateLobby as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSCreateLobby {
    pub fn new() -> CMsgClientMMSCreateLobby {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional int32 max_members = 2;

    pub fn max_members(&self) -> i32 {
        self.max_members.unwrap_or(0)
    }

    pub fn clear_max_members(&mut self) {
        self.max_members = ::std::option::Option::None;
    }

    pub fn has_max_members(&self) -> bool {
        self.max_members.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_members(&mut self, v: i32) {
        self.max_members = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_type = 3;

    pub fn lobby_type(&self) -> i32 {
        self.lobby_type.unwrap_or(0)
    }

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: i32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_flags = 4;

    pub fn lobby_flags(&self) -> i32 {
        self.lobby_flags.unwrap_or(0)
    }

    pub fn clear_lobby_flags(&mut self) {
        self.lobby_flags = ::std::option::Option::None;
    }

    pub fn has_lobby_flags(&self) -> bool {
        self.lobby_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_flags(&mut self, v: i32) {
        self.lobby_flags = ::std::option::Option::Some(v);
    }

    // optional uint32 cell_id = 5;

    pub fn cell_id(&self) -> u32 {
        self.cell_id.unwrap_or(0)
    }

    pub fn clear_cell_id(&mut self) {
        self.cell_id = ::std::option::Option::None;
    }

    pub fn has_cell_id(&self) -> bool {
        self.cell_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id(&mut self, v: u32) {
        self.cell_id = ::std::option::Option::Some(v);
    }

    // optional uint32 deprecated_public_ip = 6;

    pub fn deprecated_public_ip(&self) -> u32 {
        self.deprecated_public_ip.unwrap_or(0)
    }

    pub fn clear_deprecated_public_ip(&mut self) {
        self.deprecated_public_ip = ::std::option::Option::None;
    }

    pub fn has_deprecated_public_ip(&self) -> bool {
        self.deprecated_public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_public_ip(&mut self, v: u32) {
        self.deprecated_public_ip = ::std::option::Option::Some(v);
    }

    // optional bytes metadata = 7;

    pub fn metadata(&self) -> &[u8] {
        match self.metadata.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_metadata(&mut self) {
        self.metadata = ::std::option::Option::None;
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
        self.metadata = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.metadata.is_none() {
            self.metadata = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
        self.metadata.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string persona_name_owner = 8;

    pub fn persona_name_owner(&self) -> &str {
        match self.persona_name_owner.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_persona_name_owner(&mut self) {
        self.persona_name_owner = ::std::option::Option::None;
    }

    pub fn has_persona_name_owner(&self) -> bool {
        self.persona_name_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_name_owner(&mut self, v: ::std::string::String) {
        self.persona_name_owner = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona_name_owner(&mut self) -> &mut ::std::string::String {
        if self.persona_name_owner.is_none() {
            self.persona_name_owner = ::std::option::Option::Some(::std::string::String::new());
        }
        self.persona_name_owner.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona_name_owner(&mut self) -> ::std::string::String {
        self.persona_name_owner.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSCreateLobby| { &m.app_id },
            |m: &mut CMsgClientMMSCreateLobby| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_members",
            |m: &CMsgClientMMSCreateLobby| { &m.max_members },
            |m: &mut CMsgClientMMSCreateLobby| { &mut m.max_members },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_type",
            |m: &CMsgClientMMSCreateLobby| { &m.lobby_type },
            |m: &mut CMsgClientMMSCreateLobby| { &mut m.lobby_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_flags",
            |m: &CMsgClientMMSCreateLobby| { &m.lobby_flags },
            |m: &mut CMsgClientMMSCreateLobby| { &mut m.lobby_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cell_id",
            |m: &CMsgClientMMSCreateLobby| { &m.cell_id },
            |m: &mut CMsgClientMMSCreateLobby| { &mut m.cell_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deprecated_public_ip",
            |m: &CMsgClientMMSCreateLobby| { &m.deprecated_public_ip },
            |m: &mut CMsgClientMMSCreateLobby| { &mut m.deprecated_public_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "metadata",
            |m: &CMsgClientMMSCreateLobby| { &m.metadata },
            |m: &mut CMsgClientMMSCreateLobby| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "persona_name_owner",
            |m: &CMsgClientMMSCreateLobby| { &m.persona_name_owner },
            |m: &mut CMsgClientMMSCreateLobby| { &mut m.persona_name_owner },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steammessages_base::CMsgIPAddress>(
            "public_ip",
            |m: &CMsgClientMMSCreateLobby| { &m.public_ip },
            |m: &mut CMsgClientMMSCreateLobby| { &mut m.public_ip },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSCreateLobby>(
            "CMsgClientMMSCreateLobby",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientMMSCreateLobby {
    const NAME: &'static str = "CMsgClientMMSCreateLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.max_members = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.lobby_type = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.lobby_flags = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.cell_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.deprecated_public_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.metadata = ::std::option::Option::Some(is.read_bytes()?);
                },
                66 => {
                    self.persona_name_owner = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.public_ip)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.max_members {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.lobby_flags {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.cell_id {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.deprecated_public_ip {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.metadata.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.persona_name_owner.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.public_ip.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.max_members {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.lobby_flags {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.cell_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.deprecated_public_ip {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.persona_name_owner.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.public_ip.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSCreateLobby {
        CMsgClientMMSCreateLobby::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.max_members = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.lobby_flags = ::std::option::Option::None;
        self.cell_id = ::std::option::Option::None;
        self.deprecated_public_ip = ::std::option::Option::None;
        self.metadata = ::std::option::Option::None;
        self.persona_name_owner = ::std::option::Option::None;
        self.public_ip.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSCreateLobby {
        static instance: CMsgClientMMSCreateLobby = CMsgClientMMSCreateLobby {
            app_id: ::std::option::Option::None,
            max_members: ::std::option::Option::None,
            lobby_type: ::std::option::Option::None,
            lobby_flags: ::std::option::Option::None,
            cell_id: ::std::option::Option::None,
            deprecated_public_ip: ::std::option::Option::None,
            metadata: ::std::option::Option::None,
            persona_name_owner: ::std::option::Option::None,
            public_ip: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientMMSCreateLobby {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSCreateLobby").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSCreateLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSCreateLobby {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientMMSCreateLobbyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSCreateLobbyResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSCreateLobbyResponse.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSCreateLobbyResponse.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSCreateLobbyResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSCreateLobbyResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSCreateLobbyResponse {
    fn default() -> &'a CMsgClientMMSCreateLobbyResponse {
        <CMsgClientMMSCreateLobbyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSCreateLobbyResponse {
    pub fn new() -> CMsgClientMMSCreateLobbyResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 3;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSCreateLobbyResponse| { &m.app_id },
            |m: &mut CMsgClientMMSCreateLobbyResponse| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSCreateLobbyResponse| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSCreateLobbyResponse| { &mut m.steam_id_lobby },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientMMSCreateLobbyResponse| { &m.eresult },
            |m: &mut CMsgClientMMSCreateLobbyResponse| { &mut m.eresult },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSCreateLobbyResponse>(
            "CMsgClientMMSCreateLobbyResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientMMSCreateLobbyResponse {
    const NAME: &'static str = "CMsgClientMMSCreateLobbyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSCreateLobbyResponse {
        CMsgClientMMSCreateLobbyResponse::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSCreateLobbyResponse {
        static instance: CMsgClientMMSCreateLobbyResponse = CMsgClientMMSCreateLobbyResponse {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientMMSCreateLobbyResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSCreateLobbyResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSCreateLobbyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSCreateLobbyResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientMMSJoinLobby)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSJoinLobby {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSJoinLobby.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSJoinLobby.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSJoinLobby.persona_name)
    pub persona_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSJoinLobby.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSJoinLobby {
    fn default() -> &'a CMsgClientMMSJoinLobby {
        <CMsgClientMMSJoinLobby as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSJoinLobby {
    pub fn new() -> CMsgClientMMSJoinLobby {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional string persona_name = 3;

    pub fn persona_name(&self) -> &str {
        match self.persona_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_persona_name(&mut self) {
        self.persona_name = ::std::option::Option::None;
    }

    pub fn has_persona_name(&self) -> bool {
        self.persona_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_name(&mut self, v: ::std::string::String) {
        self.persona_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona_name(&mut self) -> &mut ::std::string::String {
        if self.persona_name.is_none() {
            self.persona_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.persona_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona_name(&mut self) -> ::std::string::String {
        self.persona_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSJoinLobby| { &m.app_id },
            |m: &mut CMsgClientMMSJoinLobby| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSJoinLobby| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSJoinLobby| { &mut m.steam_id_lobby },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "persona_name",
            |m: &CMsgClientMMSJoinLobby| { &m.persona_name },
            |m: &mut CMsgClientMMSJoinLobby| { &mut m.persona_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSJoinLobby>(
            "CMsgClientMMSJoinLobby",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientMMSJoinLobby {
    const NAME: &'static str = "CMsgClientMMSJoinLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.persona_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.persona_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.persona_name.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSJoinLobby {
        CMsgClientMMSJoinLobby::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.persona_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSJoinLobby {
        static instance: CMsgClientMMSJoinLobby = CMsgClientMMSJoinLobby {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            persona_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientMMSJoinLobby {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSJoinLobby").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSJoinLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSJoinLobby {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientMMSJoinLobbyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSJoinLobbyResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSJoinLobbyResponse.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSJoinLobbyResponse.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSJoinLobbyResponse.chat_room_enter_response)
    pub chat_room_enter_response: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSJoinLobbyResponse.max_members)
    pub max_members: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSJoinLobbyResponse.lobby_type)
    pub lobby_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSJoinLobbyResponse.lobby_flags)
    pub lobby_flags: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSJoinLobbyResponse.steam_id_owner)
    pub steam_id_owner: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSJoinLobbyResponse.metadata)
    pub metadata: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientMMSJoinLobbyResponse.members)
    pub members: ::std::vec::Vec<cmsg_client_mmsjoin_lobby_response::Member>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSJoinLobbyResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSJoinLobbyResponse {
    fn default() -> &'a CMsgClientMMSJoinLobbyResponse {
        <CMsgClientMMSJoinLobbyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSJoinLobbyResponse {
    pub fn new() -> CMsgClientMMSJoinLobbyResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional int32 chat_room_enter_response = 3;

    pub fn chat_room_enter_response(&self) -> i32 {
        self.chat_room_enter_response.unwrap_or(0)
    }

    pub fn clear_chat_room_enter_response(&mut self) {
        self.chat_room_enter_response = ::std::option::Option::None;
    }

    pub fn has_chat_room_enter_response(&self) -> bool {
        self.chat_room_enter_response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_room_enter_response(&mut self, v: i32) {
        self.chat_room_enter_response = ::std::option::Option::Some(v);
    }

    // optional int32 max_members = 4;

    pub fn max_members(&self) -> i32 {
        self.max_members.unwrap_or(0)
    }

    pub fn clear_max_members(&mut self) {
        self.max_members = ::std::option::Option::None;
    }

    pub fn has_max_members(&self) -> bool {
        self.max_members.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_members(&mut self, v: i32) {
        self.max_members = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_type = 5;

    pub fn lobby_type(&self) -> i32 {
        self.lobby_type.unwrap_or(0)
    }

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: i32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_flags = 6;

    pub fn lobby_flags(&self) -> i32 {
        self.lobby_flags.unwrap_or(0)
    }

    pub fn clear_lobby_flags(&mut self) {
        self.lobby_flags = ::std::option::Option::None;
    }

    pub fn has_lobby_flags(&self) -> bool {
        self.lobby_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_flags(&mut self, v: i32) {
        self.lobby_flags = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_owner = 7;

    pub fn steam_id_owner(&self) -> u64 {
        self.steam_id_owner.unwrap_or(0)
    }

    pub fn clear_steam_id_owner(&mut self) {
        self.steam_id_owner = ::std::option::Option::None;
    }

    pub fn has_steam_id_owner(&self) -> bool {
        self.steam_id_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_owner(&mut self, v: u64) {
        self.steam_id_owner = ::std::option::Option::Some(v);
    }

    // optional bytes metadata = 8;

    pub fn metadata(&self) -> &[u8] {
        match self.metadata.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_metadata(&mut self) {
        self.metadata = ::std::option::Option::None;
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
        self.metadata = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.metadata.is_none() {
            self.metadata = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
        self.metadata.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSJoinLobbyResponse| { &m.app_id },
            |m: &mut CMsgClientMMSJoinLobbyResponse| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSJoinLobbyResponse| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSJoinLobbyResponse| { &mut m.steam_id_lobby },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_room_enter_response",
            |m: &CMsgClientMMSJoinLobbyResponse| { &m.chat_room_enter_response },
            |m: &mut CMsgClientMMSJoinLobbyResponse| { &mut m.chat_room_enter_response },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_members",
            |m: &CMsgClientMMSJoinLobbyResponse| { &m.max_members },
            |m: &mut CMsgClientMMSJoinLobbyResponse| { &mut m.max_members },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_type",
            |m: &CMsgClientMMSJoinLobbyResponse| { &m.lobby_type },
            |m: &mut CMsgClientMMSJoinLobbyResponse| { &mut m.lobby_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_flags",
            |m: &CMsgClientMMSJoinLobbyResponse| { &m.lobby_flags },
            |m: &mut CMsgClientMMSJoinLobbyResponse| { &mut m.lobby_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_owner",
            |m: &CMsgClientMMSJoinLobbyResponse| { &m.steam_id_owner },
            |m: &mut CMsgClientMMSJoinLobbyResponse| { &mut m.steam_id_owner },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "metadata",
            |m: &CMsgClientMMSJoinLobbyResponse| { &m.metadata },
            |m: &mut CMsgClientMMSJoinLobbyResponse| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "members",
            |m: &CMsgClientMMSJoinLobbyResponse| { &m.members },
            |m: &mut CMsgClientMMSJoinLobbyResponse| { &mut m.members },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSJoinLobbyResponse>(
            "CMsgClientMMSJoinLobbyResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientMMSJoinLobbyResponse {
    const NAME: &'static str = "CMsgClientMMSJoinLobbyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.chat_room_enter_response = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.max_members = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.lobby_type = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.lobby_flags = ::std::option::Option::Some(is.read_int32()?);
                },
                57 => {
                    self.steam_id_owner = ::std::option::Option::Some(is.read_fixed64()?);
                },
                66 => {
                    self.metadata = ::std::option::Option::Some(is.read_bytes()?);
                },
                74 => {
                    self.members.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.chat_room_enter_response {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.max_members {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.lobby_flags {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.steam_id_owner {
            my_size += 1 + 8;
        }
        if let Some(v) = self.metadata.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.chat_room_enter_response {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.max_members {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.lobby_flags {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.steam_id_owner {
            os.write_fixed64(7, v)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            os.write_bytes(8, v)?;
        }
        for v in &self.members {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSJoinLobbyResponse {
        CMsgClientMMSJoinLobbyResponse::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.chat_room_enter_response = ::std::option::Option::None;
        self.max_members = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.lobby_flags = ::std::option::Option::None;
        self.steam_id_owner = ::std::option::Option::None;
        self.metadata = ::std::option::Option::None;
        self.members.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSJoinLobbyResponse {
        static instance: CMsgClientMMSJoinLobbyResponse = CMsgClientMMSJoinLobbyResponse {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            chat_room_enter_response: ::std::option::Option::None,
            max_members: ::std::option::Option::None,
            lobby_type: ::std::option::Option::None,
            lobby_flags: ::std::option::Option::None,
            steam_id_owner: ::std::option::Option::None,
            metadata: ::std::option::Option::None,
            members: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientMMSJoinLobbyResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSJoinLobbyResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSJoinLobbyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSJoinLobbyResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientMMSJoinLobbyResponse`
pub mod cmsg_client_mmsjoin_lobby_response {
    // @@protoc_insertion_point(message:CMsgClientMMSJoinLobbyResponse.Member)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Member {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientMMSJoinLobbyResponse.Member.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientMMSJoinLobbyResponse.Member.persona_name)
        pub persona_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientMMSJoinLobbyResponse.Member.metadata)
        pub metadata: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientMMSJoinLobbyResponse.Member.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Member {
        fn default() -> &'a Member {
            <Member as ::protobuf::Message>::default_instance()
        }
    }

    impl Member {
        pub fn new() -> Member {
            ::std::default::Default::default()
        }

        // optional fixed64 steam_id = 1;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional string persona_name = 2;

        pub fn persona_name(&self) -> &str {
            match self.persona_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_persona_name(&mut self) {
            self.persona_name = ::std::option::Option::None;
        }

        pub fn has_persona_name(&self) -> bool {
            self.persona_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_persona_name(&mut self, v: ::std::string::String) {
            self.persona_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_persona_name(&mut self) -> &mut ::std::string::String {
            if self.persona_name.is_none() {
                self.persona_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.persona_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_persona_name(&mut self) -> ::std::string::String {
            self.persona_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bytes metadata = 3;

        pub fn metadata(&self) -> &[u8] {
            match self.metadata.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_metadata(&mut self) {
            self.metadata = ::std::option::Option::None;
        }

        pub fn has_metadata(&self) -> bool {
            self.metadata.is_some()
        }

        // Param is passed by value, moved
        pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
            self.metadata = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_metadata(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.metadata.is_none() {
                self.metadata = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.metadata.as_mut().unwrap()
        }

        // Take field
        pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
            self.metadata.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "steam_id",
                |m: &Member| { &m.steam_id },
                |m: &mut Member| { &mut m.steam_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "persona_name",
                |m: &Member| { &m.persona_name },
                |m: &mut Member| { &mut m.persona_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "metadata",
                |m: &Member| { &m.metadata },
                |m: &mut Member| { &mut m.metadata },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Member>(
                "CMsgClientMMSJoinLobbyResponse.Member",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Member {
        const NAME: &'static str = "Member";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    18 => {
                        self.persona_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.metadata = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.persona_name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.metadata.as_ref() {
                my_size += ::protobuf::rt::bytes_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.steam_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.persona_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.metadata.as_ref() {
                os.write_bytes(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Member {
            Member::new()
        }

        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.persona_name = ::std::option::Option::None;
            self.metadata = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Member {
            static instance: Member = Member {
                steam_id: ::std::option::Option::None,
                persona_name: ::std::option::Option::None,
                metadata: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Member {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientMMSJoinLobbyResponse.Member").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Member {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Member {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientMMSLeaveLobby)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSLeaveLobby {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSLeaveLobby.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSLeaveLobby.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSLeaveLobby.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSLeaveLobby {
    fn default() -> &'a CMsgClientMMSLeaveLobby {
        <CMsgClientMMSLeaveLobby as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSLeaveLobby {
    pub fn new() -> CMsgClientMMSLeaveLobby {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSLeaveLobby| { &m.app_id },
            |m: &mut CMsgClientMMSLeaveLobby| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSLeaveLobby| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSLeaveLobby| { &mut m.steam_id_lobby },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSLeaveLobby>(
            "CMsgClientMMSLeaveLobby",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientMMSLeaveLobby {
    const NAME: &'static str = "CMsgClientMMSLeaveLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSLeaveLobby {
        CMsgClientMMSLeaveLobby::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSLeaveLobby {
        static instance: CMsgClientMMSLeaveLobby = CMsgClientMMSLeaveLobby {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientMMSLeaveLobby {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSLeaveLobby").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSLeaveLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSLeaveLobby {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientMMSLeaveLobbyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSLeaveLobbyResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSLeaveLobbyResponse.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSLeaveLobbyResponse.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSLeaveLobbyResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSLeaveLobbyResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSLeaveLobbyResponse {
    fn default() -> &'a CMsgClientMMSLeaveLobbyResponse {
        <CMsgClientMMSLeaveLobbyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSLeaveLobbyResponse {
    pub fn new() -> CMsgClientMMSLeaveLobbyResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 3;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSLeaveLobbyResponse| { &m.app_id },
            |m: &mut CMsgClientMMSLeaveLobbyResponse| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSLeaveLobbyResponse| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSLeaveLobbyResponse| { &mut m.steam_id_lobby },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientMMSLeaveLobbyResponse| { &m.eresult },
            |m: &mut CMsgClientMMSLeaveLobbyResponse| { &mut m.eresult },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSLeaveLobbyResponse>(
            "CMsgClientMMSLeaveLobbyResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientMMSLeaveLobbyResponse {
    const NAME: &'static str = "CMsgClientMMSLeaveLobbyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSLeaveLobbyResponse {
        CMsgClientMMSLeaveLobbyResponse::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSLeaveLobbyResponse {
        static instance: CMsgClientMMSLeaveLobbyResponse = CMsgClientMMSLeaveLobbyResponse {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientMMSLeaveLobbyResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSLeaveLobbyResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSLeaveLobbyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSLeaveLobbyResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientMMSGetLobbyList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSGetLobbyList {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyList.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyList.num_lobbies_requested)
    pub num_lobbies_requested: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyList.cell_id)
    pub cell_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyList.deprecated_public_ip)
    pub deprecated_public_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyList.filters)
    pub filters: ::std::vec::Vec<cmsg_client_mmsget_lobby_list::Filter>,
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyList.public_ip)
    pub public_ip: ::protobuf::MessageField<super::steammessages_base::CMsgIPAddress>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSGetLobbyList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSGetLobbyList {
    fn default() -> &'a CMsgClientMMSGetLobbyList {
        <CMsgClientMMSGetLobbyList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSGetLobbyList {
    pub fn new() -> CMsgClientMMSGetLobbyList {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional int32 num_lobbies_requested = 3;

    pub fn num_lobbies_requested(&self) -> i32 {
        self.num_lobbies_requested.unwrap_or(0)
    }

    pub fn clear_num_lobbies_requested(&mut self) {
        self.num_lobbies_requested = ::std::option::Option::None;
    }

    pub fn has_num_lobbies_requested(&self) -> bool {
        self.num_lobbies_requested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_lobbies_requested(&mut self, v: i32) {
        self.num_lobbies_requested = ::std::option::Option::Some(v);
    }

    // optional uint32 cell_id = 4;

    pub fn cell_id(&self) -> u32 {
        self.cell_id.unwrap_or(0)
    }

    pub fn clear_cell_id(&mut self) {
        self.cell_id = ::std::option::Option::None;
    }

    pub fn has_cell_id(&self) -> bool {
        self.cell_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id(&mut self, v: u32) {
        self.cell_id = ::std::option::Option::Some(v);
    }

    // optional uint32 deprecated_public_ip = 5;

    pub fn deprecated_public_ip(&self) -> u32 {
        self.deprecated_public_ip.unwrap_or(0)
    }

    pub fn clear_deprecated_public_ip(&mut self) {
        self.deprecated_public_ip = ::std::option::Option::None;
    }

    pub fn has_deprecated_public_ip(&self) -> bool {
        self.deprecated_public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_public_ip(&mut self, v: u32) {
        self.deprecated_public_ip = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSGetLobbyList| { &m.app_id },
            |m: &mut CMsgClientMMSGetLobbyList| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_lobbies_requested",
            |m: &CMsgClientMMSGetLobbyList| { &m.num_lobbies_requested },
            |m: &mut CMsgClientMMSGetLobbyList| { &mut m.num_lobbies_requested },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cell_id",
            |m: &CMsgClientMMSGetLobbyList| { &m.cell_id },
            |m: &mut CMsgClientMMSGetLobbyList| { &mut m.cell_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deprecated_public_ip",
            |m: &CMsgClientMMSGetLobbyList| { &m.deprecated_public_ip },
            |m: &mut CMsgClientMMSGetLobbyList| { &mut m.deprecated_public_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "filters",
            |m: &CMsgClientMMSGetLobbyList| { &m.filters },
            |m: &mut CMsgClientMMSGetLobbyList| { &mut m.filters },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steammessages_base::CMsgIPAddress>(
            "public_ip",
            |m: &CMsgClientMMSGetLobbyList| { &m.public_ip },
            |m: &mut CMsgClientMMSGetLobbyList| { &mut m.public_ip },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSGetLobbyList>(
            "CMsgClientMMSGetLobbyList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientMMSGetLobbyList {
    const NAME: &'static str = "CMsgClientMMSGetLobbyList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.num_lobbies_requested = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.cell_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.deprecated_public_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    self.filters.push(is.read_message()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.public_ip)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.num_lobbies_requested {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.cell_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.deprecated_public_ip {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        for value in &self.filters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.public_ip.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.num_lobbies_requested {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.cell_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.deprecated_public_ip {
            os.write_uint32(5, v)?;
        }
        for v in &self.filters {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if let Some(v) = self.public_ip.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSGetLobbyList {
        CMsgClientMMSGetLobbyList::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.num_lobbies_requested = ::std::option::Option::None;
        self.cell_id = ::std::option::Option::None;
        self.deprecated_public_ip = ::std::option::Option::None;
        self.filters.clear();
        self.public_ip.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSGetLobbyList {
        static instance: CMsgClientMMSGetLobbyList = CMsgClientMMSGetLobbyList {
            app_id: ::std::option::Option::None,
            num_lobbies_requested: ::std::option::Option::None,
            cell_id: ::std::option::Option::None,
            deprecated_public_ip: ::std::option::Option::None,
            filters: ::std::vec::Vec::new(),
            public_ip: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientMMSGetLobbyList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSGetLobbyList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSGetLobbyList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSGetLobbyList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientMMSGetLobbyList`
pub mod cmsg_client_mmsget_lobby_list {
    // @@protoc_insertion_point(message:CMsgClientMMSGetLobbyList.Filter)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Filter {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyList.Filter.key)
        pub key: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyList.Filter.value)
        pub value: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyList.Filter.comparision)
        pub comparision: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyList.Filter.filter_type)
        pub filter_type: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientMMSGetLobbyList.Filter.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Filter {
        fn default() -> &'a Filter {
            <Filter as ::protobuf::Message>::default_instance()
        }
    }

    impl Filter {
        pub fn new() -> Filter {
            ::std::default::Default::default()
        }

        // optional string key = 1;

        pub fn key(&self) -> &str {
            match self.key.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_key(&mut self) {
            self.key = ::std::option::Option::None;
        }

        pub fn has_key(&self) -> bool {
            self.key.is_some()
        }

        // Param is passed by value, moved
        pub fn set_key(&mut self, v: ::std::string::String) {
            self.key = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_key(&mut self) -> &mut ::std::string::String {
            if self.key.is_none() {
                self.key = ::std::option::Option::Some(::std::string::String::new());
            }
            self.key.as_mut().unwrap()
        }

        // Take field
        pub fn take_key(&mut self) -> ::std::string::String {
            self.key.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string value = 2;

        pub fn value(&self) -> &str {
            match self.value.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: ::std::string::String) {
            self.value = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_value(&mut self) -> &mut ::std::string::String {
            if self.value.is_none() {
                self.value = ::std::option::Option::Some(::std::string::String::new());
            }
            self.value.as_mut().unwrap()
        }

        // Take field
        pub fn take_value(&mut self) -> ::std::string::String {
            self.value.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 comparision = 3;

        pub fn comparision(&self) -> i32 {
            self.comparision.unwrap_or(0)
        }

        pub fn clear_comparision(&mut self) {
            self.comparision = ::std::option::Option::None;
        }

        pub fn has_comparision(&self) -> bool {
            self.comparision.is_some()
        }

        // Param is passed by value, moved
        pub fn set_comparision(&mut self, v: i32) {
            self.comparision = ::std::option::Option::Some(v);
        }

        // optional int32 filter_type = 4;

        pub fn filter_type(&self) -> i32 {
            self.filter_type.unwrap_or(0)
        }

        pub fn clear_filter_type(&mut self) {
            self.filter_type = ::std::option::Option::None;
        }

        pub fn has_filter_type(&self) -> bool {
            self.filter_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_filter_type(&mut self, v: i32) {
            self.filter_type = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "key",
                |m: &Filter| { &m.key },
                |m: &mut Filter| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "value",
                |m: &Filter| { &m.value },
                |m: &mut Filter| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "comparision",
                |m: &Filter| { &m.comparision },
                |m: &mut Filter| { &mut m.comparision },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "filter_type",
                |m: &Filter| { &m.filter_type },
                |m: &mut Filter| { &mut m.filter_type },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Filter>(
                "CMsgClientMMSGetLobbyList.Filter",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Filter {
        const NAME: &'static str = "Filter";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.key = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.value = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.comparision = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.filter_type = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.key.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.value.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.comparision {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.filter_type {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.key.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.value.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.comparision {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.filter_type {
                os.write_int32(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Filter {
            Filter::new()
        }

        fn clear(&mut self) {
            self.key = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.comparision = ::std::option::Option::None;
            self.filter_type = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Filter {
            static instance: Filter = Filter {
                key: ::std::option::Option::None,
                value: ::std::option::Option::None,
                comparision: ::std::option::Option::None,
                filter_type: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Filter {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientMMSGetLobbyList.Filter").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Filter {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Filter {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientMMSGetLobbyListResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSGetLobbyListResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyListResponse.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyListResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyListResponse.lobbies)
    pub lobbies: ::std::vec::Vec<cmsg_client_mmsget_lobby_list_response::Lobby>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSGetLobbyListResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSGetLobbyListResponse {
    fn default() -> &'a CMsgClientMMSGetLobbyListResponse {
        <CMsgClientMMSGetLobbyListResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSGetLobbyListResponse {
    pub fn new() -> CMsgClientMMSGetLobbyListResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 3;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSGetLobbyListResponse| { &m.app_id },
            |m: &mut CMsgClientMMSGetLobbyListResponse| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientMMSGetLobbyListResponse| { &m.eresult },
            |m: &mut CMsgClientMMSGetLobbyListResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "lobbies",
            |m: &CMsgClientMMSGetLobbyListResponse| { &m.lobbies },
            |m: &mut CMsgClientMMSGetLobbyListResponse| { &mut m.lobbies },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSGetLobbyListResponse>(
            "CMsgClientMMSGetLobbyListResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientMMSGetLobbyListResponse {
    const NAME: &'static str = "CMsgClientMMSGetLobbyListResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.lobbies.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        for value in &self.lobbies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(3, v)?;
        }
        for v in &self.lobbies {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSGetLobbyListResponse {
        CMsgClientMMSGetLobbyListResponse::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.lobbies.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSGetLobbyListResponse {
        static instance: CMsgClientMMSGetLobbyListResponse = CMsgClientMMSGetLobbyListResponse {
            app_id: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            lobbies: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientMMSGetLobbyListResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSGetLobbyListResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSGetLobbyListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSGetLobbyListResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientMMSGetLobbyListResponse`
pub mod cmsg_client_mmsget_lobby_list_response {
    // @@protoc_insertion_point(message:CMsgClientMMSGetLobbyListResponse.Lobby)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Lobby {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyListResponse.Lobby.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyListResponse.Lobby.max_members)
        pub max_members: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyListResponse.Lobby.lobby_type)
        pub lobby_type: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyListResponse.Lobby.lobby_flags)
        pub lobby_flags: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyListResponse.Lobby.metadata)
        pub metadata: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyListResponse.Lobby.num_members)
        pub num_members: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyListResponse.Lobby.distance)
        pub distance: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyListResponse.Lobby.weight)
        pub weight: ::std::option::Option<i64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientMMSGetLobbyListResponse.Lobby.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Lobby {
        fn default() -> &'a Lobby {
            <Lobby as ::protobuf::Message>::default_instance()
        }
    }

    impl Lobby {
        pub fn new() -> Lobby {
            ::std::default::Default::default()
        }

        // optional fixed64 steam_id = 1;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional int32 max_members = 2;

        pub fn max_members(&self) -> i32 {
            self.max_members.unwrap_or(0)
        }

        pub fn clear_max_members(&mut self) {
            self.max_members = ::std::option::Option::None;
        }

        pub fn has_max_members(&self) -> bool {
            self.max_members.is_some()
        }

        // Param is passed by value, moved
        pub fn set_max_members(&mut self, v: i32) {
            self.max_members = ::std::option::Option::Some(v);
        }

        // optional int32 lobby_type = 3;

        pub fn lobby_type(&self) -> i32 {
            self.lobby_type.unwrap_or(0)
        }

        pub fn clear_lobby_type(&mut self) {
            self.lobby_type = ::std::option::Option::None;
        }

        pub fn has_lobby_type(&self) -> bool {
            self.lobby_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lobby_type(&mut self, v: i32) {
            self.lobby_type = ::std::option::Option::Some(v);
        }

        // optional int32 lobby_flags = 4;

        pub fn lobby_flags(&self) -> i32 {
            self.lobby_flags.unwrap_or(0)
        }

        pub fn clear_lobby_flags(&mut self) {
            self.lobby_flags = ::std::option::Option::None;
        }

        pub fn has_lobby_flags(&self) -> bool {
            self.lobby_flags.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lobby_flags(&mut self, v: i32) {
            self.lobby_flags = ::std::option::Option::Some(v);
        }

        // optional bytes metadata = 5;

        pub fn metadata(&self) -> &[u8] {
            match self.metadata.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_metadata(&mut self) {
            self.metadata = ::std::option::Option::None;
        }

        pub fn has_metadata(&self) -> bool {
            self.metadata.is_some()
        }

        // Param is passed by value, moved
        pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
            self.metadata = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_metadata(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.metadata.is_none() {
                self.metadata = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.metadata.as_mut().unwrap()
        }

        // Take field
        pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
            self.metadata.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional int32 num_members = 6;

        pub fn num_members(&self) -> i32 {
            self.num_members.unwrap_or(0)
        }

        pub fn clear_num_members(&mut self) {
            self.num_members = ::std::option::Option::None;
        }

        pub fn has_num_members(&self) -> bool {
            self.num_members.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_members(&mut self, v: i32) {
            self.num_members = ::std::option::Option::Some(v);
        }

        // optional float distance = 7;

        pub fn distance(&self) -> f32 {
            self.distance.unwrap_or(0.)
        }

        pub fn clear_distance(&mut self) {
            self.distance = ::std::option::Option::None;
        }

        pub fn has_distance(&self) -> bool {
            self.distance.is_some()
        }

        // Param is passed by value, moved
        pub fn set_distance(&mut self, v: f32) {
            self.distance = ::std::option::Option::Some(v);
        }

        // optional int64 weight = 8;

        pub fn weight(&self) -> i64 {
            self.weight.unwrap_or(0)
        }

        pub fn clear_weight(&mut self) {
            self.weight = ::std::option::Option::None;
        }

        pub fn has_weight(&self) -> bool {
            self.weight.is_some()
        }

        // Param is passed by value, moved
        pub fn set_weight(&mut self, v: i64) {
            self.weight = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(8);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "steam_id",
                |m: &Lobby| { &m.steam_id },
                |m: &mut Lobby| { &mut m.steam_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "max_members",
                |m: &Lobby| { &m.max_members },
                |m: &mut Lobby| { &mut m.max_members },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "lobby_type",
                |m: &Lobby| { &m.lobby_type },
                |m: &mut Lobby| { &mut m.lobby_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "lobby_flags",
                |m: &Lobby| { &m.lobby_flags },
                |m: &mut Lobby| { &mut m.lobby_flags },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "metadata",
                |m: &Lobby| { &m.metadata },
                |m: &mut Lobby| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "num_members",
                |m: &Lobby| { &m.num_members },
                |m: &mut Lobby| { &mut m.num_members },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "distance",
                |m: &Lobby| { &m.distance },
                |m: &mut Lobby| { &mut m.distance },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "weight",
                |m: &Lobby| { &m.weight },
                |m: &mut Lobby| { &mut m.weight },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Lobby>(
                "CMsgClientMMSGetLobbyListResponse.Lobby",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Lobby {
        const NAME: &'static str = "Lobby";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.max_members = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.lobby_type = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.lobby_flags = ::std::option::Option::Some(is.read_int32()?);
                    },
                    42 => {
                        self.metadata = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    48 => {
                        self.num_members = ::std::option::Option::Some(is.read_int32()?);
                    },
                    61 => {
                        self.distance = ::std::option::Option::Some(is.read_float()?);
                    },
                    64 => {
                        self.weight = ::std::option::Option::Some(is.read_int64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.max_members {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.lobby_type {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.lobby_flags {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.metadata.as_ref() {
                my_size += ::protobuf::rt::bytes_size(5, &v);
            }
            if let Some(v) = self.num_members {
                my_size += ::protobuf::rt::int32_size(6, v);
            }
            if let Some(v) = self.distance {
                my_size += 1 + 4;
            }
            if let Some(v) = self.weight {
                my_size += ::protobuf::rt::int64_size(8, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.steam_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.max_members {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.lobby_type {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.lobby_flags {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.metadata.as_ref() {
                os.write_bytes(5, v)?;
            }
            if let Some(v) = self.num_members {
                os.write_int32(6, v)?;
            }
            if let Some(v) = self.distance {
                os.write_float(7, v)?;
            }
            if let Some(v) = self.weight {
                os.write_int64(8, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Lobby {
            Lobby::new()
        }

        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.max_members = ::std::option::Option::None;
            self.lobby_type = ::std::option::Option::None;
            self.lobby_flags = ::std::option::Option::None;
            self.metadata = ::std::option::Option::None;
            self.num_members = ::std::option::Option::None;
            self.distance = ::std::option::Option::None;
            self.weight = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Lobby {
            static instance: Lobby = Lobby {
                steam_id: ::std::option::Option::None,
                max_members: ::std::option::Option::None,
                lobby_type: ::std::option::Option::None,
                lobby_flags: ::std::option::Option::None,
                metadata: ::std::option::Option::None,
                num_members: ::std::option::Option::None,
                distance: ::std::option::Option::None,
                weight: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Lobby {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientMMSGetLobbyListResponse.Lobby").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Lobby {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Lobby {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientMMSSetLobbyData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSSetLobbyData {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyData.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyData.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyData.steam_id_member)
    pub steam_id_member: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyData.max_members)
    pub max_members: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyData.lobby_type)
    pub lobby_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyData.lobby_flags)
    pub lobby_flags: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyData.metadata)
    pub metadata: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSSetLobbyData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSSetLobbyData {
    fn default() -> &'a CMsgClientMMSSetLobbyData {
        <CMsgClientMMSSetLobbyData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSSetLobbyData {
    pub fn new() -> CMsgClientMMSSetLobbyData {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_member = 3;

    pub fn steam_id_member(&self) -> u64 {
        self.steam_id_member.unwrap_or(0)
    }

    pub fn clear_steam_id_member(&mut self) {
        self.steam_id_member = ::std::option::Option::None;
    }

    pub fn has_steam_id_member(&self) -> bool {
        self.steam_id_member.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_member(&mut self, v: u64) {
        self.steam_id_member = ::std::option::Option::Some(v);
    }

    // optional int32 max_members = 4;

    pub fn max_members(&self) -> i32 {
        self.max_members.unwrap_or(0)
    }

    pub fn clear_max_members(&mut self) {
        self.max_members = ::std::option::Option::None;
    }

    pub fn has_max_members(&self) -> bool {
        self.max_members.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_members(&mut self, v: i32) {
        self.max_members = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_type = 5;

    pub fn lobby_type(&self) -> i32 {
        self.lobby_type.unwrap_or(0)
    }

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: i32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_flags = 6;

    pub fn lobby_flags(&self) -> i32 {
        self.lobby_flags.unwrap_or(0)
    }

    pub fn clear_lobby_flags(&mut self) {
        self.lobby_flags = ::std::option::Option::None;
    }

    pub fn has_lobby_flags(&self) -> bool {
        self.lobby_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_flags(&mut self, v: i32) {
        self.lobby_flags = ::std::option::Option::Some(v);
    }

    // optional bytes metadata = 7;

    pub fn metadata(&self) -> &[u8] {
        match self.metadata.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_metadata(&mut self) {
        self.metadata = ::std::option::Option::None;
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
        self.metadata = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.metadata.is_none() {
            self.metadata = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
        self.metadata.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSSetLobbyData| { &m.app_id },
            |m: &mut CMsgClientMMSSetLobbyData| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSSetLobbyData| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSSetLobbyData| { &mut m.steam_id_lobby },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_member",
            |m: &CMsgClientMMSSetLobbyData| { &m.steam_id_member },
            |m: &mut CMsgClientMMSSetLobbyData| { &mut m.steam_id_member },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_members",
            |m: &CMsgClientMMSSetLobbyData| { &m.max_members },
            |m: &mut CMsgClientMMSSetLobbyData| { &mut m.max_members },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_type",
            |m: &CMsgClientMMSSetLobbyData| { &m.lobby_type },
            |m: &mut CMsgClientMMSSetLobbyData| { &mut m.lobby_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_flags",
            |m: &CMsgClientMMSSetLobbyData| { &m.lobby_flags },
            |m: &mut CMsgClientMMSSetLobbyData| { &mut m.lobby_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "metadata",
            |m: &CMsgClientMMSSetLobbyData| { &m.metadata },
            |m: &mut CMsgClientMMSSetLobbyData| { &mut m.metadata },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSSetLobbyData>(
            "CMsgClientMMSSetLobbyData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientMMSSetLobbyData {
    const NAME: &'static str = "CMsgClientMMSSetLobbyData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.steam_id_member = ::std::option::Option::Some(is.read_fixed64()?);
                },
                32 => {
                    self.max_members = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.lobby_type = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.lobby_flags = ::std::option::Option::Some(is.read_int32()?);
                },
                58 => {
                    self.metadata = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steam_id_member {
            my_size += 1 + 8;
        }
        if let Some(v) = self.max_members {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.lobby_flags {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.metadata.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_member {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.max_members {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.lobby_flags {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            os.write_bytes(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSSetLobbyData {
        CMsgClientMMSSetLobbyData::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.steam_id_member = ::std::option::Option::None;
        self.max_members = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.lobby_flags = ::std::option::Option::None;
        self.metadata = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSSetLobbyData {
        static instance: CMsgClientMMSSetLobbyData = CMsgClientMMSSetLobbyData {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            steam_id_member: ::std::option::Option::None,
            max_members: ::std::option::Option::None,
            lobby_type: ::std::option::Option::None,
            lobby_flags: ::std::option::Option::None,
            metadata: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientMMSSetLobbyData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSSetLobbyData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSSetLobbyData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSSetLobbyData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientMMSSetLobbyDataResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSSetLobbyDataResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyDataResponse.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyDataResponse.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyDataResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSSetLobbyDataResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSSetLobbyDataResponse {
    fn default() -> &'a CMsgClientMMSSetLobbyDataResponse {
        <CMsgClientMMSSetLobbyDataResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSSetLobbyDataResponse {
    pub fn new() -> CMsgClientMMSSetLobbyDataResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 3;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSSetLobbyDataResponse| { &m.app_id },
            |m: &mut CMsgClientMMSSetLobbyDataResponse| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSSetLobbyDataResponse| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSSetLobbyDataResponse| { &mut m.steam_id_lobby },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientMMSSetLobbyDataResponse| { &m.eresult },
            |m: &mut CMsgClientMMSSetLobbyDataResponse| { &mut m.eresult },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSSetLobbyDataResponse>(
            "CMsgClientMMSSetLobbyDataResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientMMSSetLobbyDataResponse {
    const NAME: &'static str = "CMsgClientMMSSetLobbyDataResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSSetLobbyDataResponse {
        CMsgClientMMSSetLobbyDataResponse::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSSetLobbyDataResponse {
        static instance: CMsgClientMMSSetLobbyDataResponse = CMsgClientMMSSetLobbyDataResponse {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientMMSSetLobbyDataResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSSetLobbyDataResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSSetLobbyDataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSSetLobbyDataResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientMMSGetLobbyData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSGetLobbyData {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyData.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyData.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSGetLobbyData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSGetLobbyData {
    fn default() -> &'a CMsgClientMMSGetLobbyData {
        <CMsgClientMMSGetLobbyData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSGetLobbyData {
    pub fn new() -> CMsgClientMMSGetLobbyData {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSGetLobbyData| { &m.app_id },
            |m: &mut CMsgClientMMSGetLobbyData| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSGetLobbyData| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSGetLobbyData| { &mut m.steam_id_lobby },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSGetLobbyData>(
            "CMsgClientMMSGetLobbyData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientMMSGetLobbyData {
    const NAME: &'static str = "CMsgClientMMSGetLobbyData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSGetLobbyData {
        CMsgClientMMSGetLobbyData::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSGetLobbyData {
        static instance: CMsgClientMMSGetLobbyData = CMsgClientMMSGetLobbyData {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientMMSGetLobbyData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSGetLobbyData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSGetLobbyData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSGetLobbyData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientMMSLobbyData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSLobbyData {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.num_members)
    pub num_members: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.max_members)
    pub max_members: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.lobby_type)
    pub lobby_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.lobby_flags)
    pub lobby_flags: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.steam_id_owner)
    pub steam_id_owner: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.metadata)
    pub metadata: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.members)
    pub members: ::std::vec::Vec<cmsg_client_mmslobby_data::Member>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.lobby_cellid)
    pub lobby_cellid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.owner_should_accept_changes)
    pub owner_should_accept_changes: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSLobbyData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSLobbyData {
    fn default() -> &'a CMsgClientMMSLobbyData {
        <CMsgClientMMSLobbyData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSLobbyData {
    pub fn new() -> CMsgClientMMSLobbyData {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional int32 num_members = 3;

    pub fn num_members(&self) -> i32 {
        self.num_members.unwrap_or(0)
    }

    pub fn clear_num_members(&mut self) {
        self.num_members = ::std::option::Option::None;
    }

    pub fn has_num_members(&self) -> bool {
        self.num_members.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_members(&mut self, v: i32) {
        self.num_members = ::std::option::Option::Some(v);
    }

    // optional int32 max_members = 4;

    pub fn max_members(&self) -> i32 {
        self.max_members.unwrap_or(0)
    }

    pub fn clear_max_members(&mut self) {
        self.max_members = ::std::option::Option::None;
    }

    pub fn has_max_members(&self) -> bool {
        self.max_members.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_members(&mut self, v: i32) {
        self.max_members = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_type = 5;

    pub fn lobby_type(&self) -> i32 {
        self.lobby_type.unwrap_or(0)
    }

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: i32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_flags = 6;

    pub fn lobby_flags(&self) -> i32 {
        self.lobby_flags.unwrap_or(0)
    }

    pub fn clear_lobby_flags(&mut self) {
        self.lobby_flags = ::std::option::Option::None;
    }

    pub fn has_lobby_flags(&self) -> bool {
        self.lobby_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_flags(&mut self, v: i32) {
        self.lobby_flags = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_owner = 7;

    pub fn steam_id_owner(&self) -> u64 {
        self.steam_id_owner.unwrap_or(0)
    }

    pub fn clear_steam_id_owner(&mut self) {
        self.steam_id_owner = ::std::option::Option::None;
    }

    pub fn has_steam_id_owner(&self) -> bool {
        self.steam_id_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_owner(&mut self, v: u64) {
        self.steam_id_owner = ::std::option::Option::Some(v);
    }

    // optional bytes metadata = 8;

    pub fn metadata(&self) -> &[u8] {
        match self.metadata.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_metadata(&mut self) {
        self.metadata = ::std::option::Option::None;
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
        self.metadata = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.metadata.is_none() {
            self.metadata = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
        self.metadata.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 lobby_cellid = 10;

    pub fn lobby_cellid(&self) -> u32 {
        self.lobby_cellid.unwrap_or(0)
    }

    pub fn clear_lobby_cellid(&mut self) {
        self.lobby_cellid = ::std::option::Option::None;
    }

    pub fn has_lobby_cellid(&self) -> bool {
        self.lobby_cellid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_cellid(&mut self, v: u32) {
        self.lobby_cellid = ::std::option::Option::Some(v);
    }

    // optional bool owner_should_accept_changes = 11;

    pub fn owner_should_accept_changes(&self) -> bool {
        self.owner_should_accept_changes.unwrap_or(false)
    }

    pub fn clear_owner_should_accept_changes(&mut self) {
        self.owner_should_accept_changes = ::std::option::Option::None;
    }

    pub fn has_owner_should_accept_changes(&self) -> bool {
        self.owner_should_accept_changes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_should_accept_changes(&mut self, v: bool) {
        self.owner_should_accept_changes = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSLobbyData| { &m.app_id },
            |m: &mut CMsgClientMMSLobbyData| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSLobbyData| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSLobbyData| { &mut m.steam_id_lobby },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_members",
            |m: &CMsgClientMMSLobbyData| { &m.num_members },
            |m: &mut CMsgClientMMSLobbyData| { &mut m.num_members },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_members",
            |m: &CMsgClientMMSLobbyData| { &m.max_members },
            |m: &mut CMsgClientMMSLobbyData| { &mut m.max_members },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_type",
            |m: &CMsgClientMMSLobbyData| { &m.lobby_type },
            |m: &mut CMsgClientMMSLobbyData| { &mut m.lobby_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_flags",
            |m: &CMsgClientMMSLobbyData| { &m.lobby_flags },
            |m: &mut CMsgClientMMSLobbyData| { &mut m.lobby_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_owner",
            |m: &CMsgClientMMSLobbyData| { &m.steam_id_owner },
            |m: &mut CMsgClientMMSLobbyData| { &mut m.steam_id_owner },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "metadata",
            |m: &CMsgClientMMSLobbyData| { &m.metadata },
            |m: &mut CMsgClientMMSLobbyData| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "members",
            |m: &CMsgClientMMSLobbyData| { &m.members },
            |m: &mut CMsgClientMMSLobbyData| { &mut m.members },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_cellid",
            |m: &CMsgClientMMSLobbyData| { &m.lobby_cellid },
            |m: &mut CMsgClientMMSLobbyData| { &mut m.lobby_cellid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "owner_should_accept_changes",
            |m: &CMsgClientMMSLobbyData| { &m.owner_should_accept_changes },
            |m: &mut CMsgClientMMSLobbyData| { &mut m.owner_should_accept_changes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSLobbyData>(
            "CMsgClientMMSLobbyData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientMMSLobbyData {
    const NAME: &'static str = "CMsgClientMMSLobbyData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.num_members = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.max_members = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.lobby_type = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.lobby_flags = ::std::option::Option::Some(is.read_int32()?);
                },
                57 => {
                    self.steam_id_owner = ::std::option::Option::Some(is.read_fixed64()?);
                },
                66 => {
                    self.metadata = ::std::option::Option::Some(is.read_bytes()?);
                },
                74 => {
                    self.members.push(is.read_message()?);
                },
                80 => {
                    self.lobby_cellid = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.owner_should_accept_changes = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.num_members {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.max_members {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.lobby_flags {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.steam_id_owner {
            my_size += 1 + 8;
        }
        if let Some(v) = self.metadata.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.lobby_cellid {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.owner_should_accept_changes {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.num_members {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.max_members {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.lobby_flags {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.steam_id_owner {
            os.write_fixed64(7, v)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            os.write_bytes(8, v)?;
        }
        for v in &self.members {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        if let Some(v) = self.lobby_cellid {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.owner_should_accept_changes {
            os.write_bool(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSLobbyData {
        CMsgClientMMSLobbyData::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.num_members = ::std::option::Option::None;
        self.max_members = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.lobby_flags = ::std::option::Option::None;
        self.steam_id_owner = ::std::option::Option::None;
        self.metadata = ::std::option::Option::None;
        self.members.clear();
        self.lobby_cellid = ::std::option::Option::None;
        self.owner_should_accept_changes = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSLobbyData {
        static instance: CMsgClientMMSLobbyData = CMsgClientMMSLobbyData {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            num_members: ::std::option::Option::None,
            max_members: ::std::option::Option::None,
            lobby_type: ::std::option::Option::None,
            lobby_flags: ::std::option::Option::None,
            steam_id_owner: ::std::option::Option::None,
            metadata: ::std::option::Option::None,
            members: ::std::vec::Vec::new(),
            lobby_cellid: ::std::option::Option::None,
            owner_should_accept_changes: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientMMSLobbyData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSLobbyData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSLobbyData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSLobbyData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientMMSLobbyData`
pub mod cmsg_client_mmslobby_data {
    // @@protoc_insertion_point(message:CMsgClientMMSLobbyData.Member)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Member {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.Member.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.Member.persona_name)
        pub persona_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.Member.metadata)
        pub metadata: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientMMSLobbyData.Member.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Member {
        fn default() -> &'a Member {
            <Member as ::protobuf::Message>::default_instance()
        }
    }

    impl Member {
        pub fn new() -> Member {
            ::std::default::Default::default()
        }

        // optional fixed64 steam_id = 1;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional string persona_name = 2;

        pub fn persona_name(&self) -> &str {
            match self.persona_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_persona_name(&mut self) {
            self.persona_name = ::std::option::Option::None;
        }

        pub fn has_persona_name(&self) -> bool {
            self.persona_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_persona_name(&mut self, v: ::std::string::String) {
            self.persona_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_persona_name(&mut self) -> &mut ::std::string::String {
            if self.persona_name.is_none() {
                self.persona_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.persona_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_persona_name(&mut self) -> ::std::string::String {
            self.persona_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bytes metadata = 3;

        pub fn metadata(&self) -> &[u8] {
            match self.metadata.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_metadata(&mut self) {
            self.metadata = ::std::option::Option::None;
        }

        pub fn has_metadata(&self) -> bool {
            self.metadata.is_some()
        }

        // Param is passed by value, moved
        pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
            self.metadata = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_metadata(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.metadata.is_none() {
                self.metadata = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.metadata.as_mut().unwrap()
        }

        // Take field
        pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
            self.metadata.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "steam_id",
                |m: &Member| { &m.steam_id },
                |m: &mut Member| { &mut m.steam_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "persona_name",
                |m: &Member| { &m.persona_name },
                |m: &mut Member| { &mut m.persona_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "metadata",
                |m: &Member| { &m.metadata },
                |m: &mut Member| { &mut m.metadata },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Member>(
                "CMsgClientMMSLobbyData.Member",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Member {
        const NAME: &'static str = "Member";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    18 => {
                        self.persona_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.metadata = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.persona_name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.metadata.as_ref() {
                my_size += ::protobuf::rt::bytes_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.steam_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.persona_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.metadata.as_ref() {
                os.write_bytes(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Member {
            Member::new()
        }

        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.persona_name = ::std::option::Option::None;
            self.metadata = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Member {
            static instance: Member = Member {
                steam_id: ::std::option::Option::None,
                persona_name: ::std::option::Option::None,
                metadata: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Member {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientMMSLobbyData.Member").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Member {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Member {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientMMSSendLobbyChatMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSSendLobbyChatMsg {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSSendLobbyChatMsg.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSendLobbyChatMsg.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSSendLobbyChatMsg.steam_id_target)
    pub steam_id_target: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSSendLobbyChatMsg.lobby_message)
    pub lobby_message: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSSendLobbyChatMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSSendLobbyChatMsg {
    fn default() -> &'a CMsgClientMMSSendLobbyChatMsg {
        <CMsgClientMMSSendLobbyChatMsg as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSSendLobbyChatMsg {
    pub fn new() -> CMsgClientMMSSendLobbyChatMsg {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_target = 3;

    pub fn steam_id_target(&self) -> u64 {
        self.steam_id_target.unwrap_or(0)
    }

    pub fn clear_steam_id_target(&mut self) {
        self.steam_id_target = ::std::option::Option::None;
    }

    pub fn has_steam_id_target(&self) -> bool {
        self.steam_id_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_target(&mut self, v: u64) {
        self.steam_id_target = ::std::option::Option::Some(v);
    }

    // optional bytes lobby_message = 4;

    pub fn lobby_message(&self) -> &[u8] {
        match self.lobby_message.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_lobby_message(&mut self) {
        self.lobby_message = ::std::option::Option::None;
    }

    pub fn has_lobby_message(&self) -> bool {
        self.lobby_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.lobby_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lobby_message(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.lobby_message.is_none() {
            self.lobby_message = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.lobby_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_lobby_message(&mut self) -> ::std::vec::Vec<u8> {
        self.lobby_message.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSSendLobbyChatMsg| { &m.app_id },
            |m: &mut CMsgClientMMSSendLobbyChatMsg| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSSendLobbyChatMsg| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSSendLobbyChatMsg| { &mut m.steam_id_lobby },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_target",
            |m: &CMsgClientMMSSendLobbyChatMsg| { &m.steam_id_target },
            |m: &mut CMsgClientMMSSendLobbyChatMsg| { &mut m.steam_id_target },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_message",
            |m: &CMsgClientMMSSendLobbyChatMsg| { &m.lobby_message },
            |m: &mut CMsgClientMMSSendLobbyChatMsg| { &mut m.lobby_message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSSendLobbyChatMsg>(
            "CMsgClientMMSSendLobbyChatMsg",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientMMSSendLobbyChatMsg {
    const NAME: &'static str = "CMsgClientMMSSendLobbyChatMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.steam_id_target = ::std::option::Option::Some(is.read_fixed64()?);
                },
                34 => {
                    self.lobby_message = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steam_id_target {
            my_size += 1 + 8;
        }
        if let Some(v) = self.lobby_message.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_target {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.lobby_message.as_ref() {
            os.write_bytes(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSSendLobbyChatMsg {
        CMsgClientMMSSendLobbyChatMsg::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.steam_id_target = ::std::option::Option::None;
        self.lobby_message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSSendLobbyChatMsg {
        static instance: CMsgClientMMSSendLobbyChatMsg = CMsgClientMMSSendLobbyChatMsg {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            steam_id_target: ::std::option::Option::None,
            lobby_message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientMMSSendLobbyChatMsg {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSSendLobbyChatMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSSendLobbyChatMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSSendLobbyChatMsg {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientMMSLobbyChatMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSLobbyChatMsg {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyChatMsg.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyChatMsg.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyChatMsg.steam_id_sender)
    pub steam_id_sender: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyChatMsg.lobby_message)
    pub lobby_message: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSLobbyChatMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSLobbyChatMsg {
    fn default() -> &'a CMsgClientMMSLobbyChatMsg {
        <CMsgClientMMSLobbyChatMsg as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSLobbyChatMsg {
    pub fn new() -> CMsgClientMMSLobbyChatMsg {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_sender = 3;

    pub fn steam_id_sender(&self) -> u64 {
        self.steam_id_sender.unwrap_or(0)
    }

    pub fn clear_steam_id_sender(&mut self) {
        self.steam_id_sender = ::std::option::Option::None;
    }

    pub fn has_steam_id_sender(&self) -> bool {
        self.steam_id_sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_sender(&mut self, v: u64) {
        self.steam_id_sender = ::std::option::Option::Some(v);
    }

    // optional bytes lobby_message = 4;

    pub fn lobby_message(&self) -> &[u8] {
        match self.lobby_message.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_lobby_message(&mut self) {
        self.lobby_message = ::std::option::Option::None;
    }

    pub fn has_lobby_message(&self) -> bool {
        self.lobby_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.lobby_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lobby_message(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.lobby_message.is_none() {
            self.lobby_message = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.lobby_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_lobby_message(&mut self) -> ::std::vec::Vec<u8> {
        self.lobby_message.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSLobbyChatMsg| { &m.app_id },
            |m: &mut CMsgClientMMSLobbyChatMsg| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSLobbyChatMsg| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSLobbyChatMsg| { &mut m.steam_id_lobby },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_sender",
            |m: &CMsgClientMMSLobbyChatMsg| { &m.steam_id_sender },
            |m: &mut CMsgClientMMSLobbyChatMsg| { &mut m.steam_id_sender },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_message",
            |m: &CMsgClientMMSLobbyChatMsg| { &m.lobby_message },
            |m: &mut CMsgClientMMSLobbyChatMsg| { &mut m.lobby_message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSLobbyChatMsg>(
            "CMsgClientMMSLobbyChatMsg",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientMMSLobbyChatMsg {
    const NAME: &'static str = "CMsgClientMMSLobbyChatMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.steam_id_sender = ::std::option::Option::Some(is.read_fixed64()?);
                },
                34 => {
                    self.lobby_message = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steam_id_sender {
            my_size += 1 + 8;
        }
        if let Some(v) = self.lobby_message.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_sender {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.lobby_message.as_ref() {
            os.write_bytes(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSLobbyChatMsg {
        CMsgClientMMSLobbyChatMsg::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.steam_id_sender = ::std::option::Option::None;
        self.lobby_message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSLobbyChatMsg {
        static instance: CMsgClientMMSLobbyChatMsg = CMsgClientMMSLobbyChatMsg {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            steam_id_sender: ::std::option::Option::None,
            lobby_message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientMMSLobbyChatMsg {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSLobbyChatMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSLobbyChatMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSLobbyChatMsg {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientMMSSetLobbyOwner)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSSetLobbyOwner {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyOwner.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyOwner.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyOwner.steam_id_new_owner)
    pub steam_id_new_owner: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSSetLobbyOwner.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSSetLobbyOwner {
    fn default() -> &'a CMsgClientMMSSetLobbyOwner {
        <CMsgClientMMSSetLobbyOwner as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSSetLobbyOwner {
    pub fn new() -> CMsgClientMMSSetLobbyOwner {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_new_owner = 3;

    pub fn steam_id_new_owner(&self) -> u64 {
        self.steam_id_new_owner.unwrap_or(0)
    }

    pub fn clear_steam_id_new_owner(&mut self) {
        self.steam_id_new_owner = ::std::option::Option::None;
    }

    pub fn has_steam_id_new_owner(&self) -> bool {
        self.steam_id_new_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_new_owner(&mut self, v: u64) {
        self.steam_id_new_owner = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSSetLobbyOwner| { &m.app_id },
            |m: &mut CMsgClientMMSSetLobbyOwner| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSSetLobbyOwner| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSSetLobbyOwner| { &mut m.steam_id_lobby },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_new_owner",
            |m: &CMsgClientMMSSetLobbyOwner| { &m.steam_id_new_owner },
            |m: &mut CMsgClientMMSSetLobbyOwner| { &mut m.steam_id_new_owner },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSSetLobbyOwner>(
            "CMsgClientMMSSetLobbyOwner",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientMMSSetLobbyOwner {
    const NAME: &'static str = "CMsgClientMMSSetLobbyOwner";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.steam_id_new_owner = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steam_id_new_owner {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_new_owner {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSSetLobbyOwner {
        CMsgClientMMSSetLobbyOwner::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.steam_id_new_owner = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSSetLobbyOwner {
        static instance: CMsgClientMMSSetLobbyOwner = CMsgClientMMSSetLobbyOwner {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            steam_id_new_owner: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientMMSSetLobbyOwner {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSSetLobbyOwner").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSSetLobbyOwner {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSSetLobbyOwner {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientMMSSetLobbyOwnerResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSSetLobbyOwnerResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyOwnerResponse.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyOwnerResponse.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyOwnerResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSSetLobbyOwnerResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSSetLobbyOwnerResponse {
    fn default() -> &'a CMsgClientMMSSetLobbyOwnerResponse {
        <CMsgClientMMSSetLobbyOwnerResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSSetLobbyOwnerResponse {
    pub fn new() -> CMsgClientMMSSetLobbyOwnerResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 3;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSSetLobbyOwnerResponse| { &m.app_id },
            |m: &mut CMsgClientMMSSetLobbyOwnerResponse| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSSetLobbyOwnerResponse| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSSetLobbyOwnerResponse| { &mut m.steam_id_lobby },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientMMSSetLobbyOwnerResponse| { &m.eresult },
            |m: &mut CMsgClientMMSSetLobbyOwnerResponse| { &mut m.eresult },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSSetLobbyOwnerResponse>(
            "CMsgClientMMSSetLobbyOwnerResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientMMSSetLobbyOwnerResponse {
    const NAME: &'static str = "CMsgClientMMSSetLobbyOwnerResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSSetLobbyOwnerResponse {
        CMsgClientMMSSetLobbyOwnerResponse::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSSetLobbyOwnerResponse {
        static instance: CMsgClientMMSSetLobbyOwnerResponse = CMsgClientMMSSetLobbyOwnerResponse {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientMMSSetLobbyOwnerResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSSetLobbyOwnerResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSSetLobbyOwnerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSSetLobbyOwnerResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientMMSSetLobbyLinked)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSSetLobbyLinked {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyLinked.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyLinked.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyLinked.steam_id_lobby2)
    pub steam_id_lobby2: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSSetLobbyLinked.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSSetLobbyLinked {
    fn default() -> &'a CMsgClientMMSSetLobbyLinked {
        <CMsgClientMMSSetLobbyLinked as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSSetLobbyLinked {
    pub fn new() -> CMsgClientMMSSetLobbyLinked {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby2 = 3;

    pub fn steam_id_lobby2(&self) -> u64 {
        self.steam_id_lobby2.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby2(&mut self) {
        self.steam_id_lobby2 = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby2(&self) -> bool {
        self.steam_id_lobby2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby2(&mut self, v: u64) {
        self.steam_id_lobby2 = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSSetLobbyLinked| { &m.app_id },
            |m: &mut CMsgClientMMSSetLobbyLinked| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSSetLobbyLinked| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSSetLobbyLinked| { &mut m.steam_id_lobby },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby2",
            |m: &CMsgClientMMSSetLobbyLinked| { &m.steam_id_lobby2 },
            |m: &mut CMsgClientMMSSetLobbyLinked| { &mut m.steam_id_lobby2 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSSetLobbyLinked>(
            "CMsgClientMMSSetLobbyLinked",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientMMSSetLobbyLinked {
    const NAME: &'static str = "CMsgClientMMSSetLobbyLinked";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.steam_id_lobby2 = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steam_id_lobby2 {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_lobby2 {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSSetLobbyLinked {
        CMsgClientMMSSetLobbyLinked::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.steam_id_lobby2 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSSetLobbyLinked {
        static instance: CMsgClientMMSSetLobbyLinked = CMsgClientMMSSetLobbyLinked {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            steam_id_lobby2: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientMMSSetLobbyLinked {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSSetLobbyLinked").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSSetLobbyLinked {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSSetLobbyLinked {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientMMSSetLobbyGameServer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSSetLobbyGameServer {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyGameServer.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyGameServer.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyGameServer.deprecated_game_server_ip)
    pub deprecated_game_server_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyGameServer.game_server_port)
    pub game_server_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyGameServer.game_server_steam_id)
    pub game_server_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyGameServer.game_server_ip)
    pub game_server_ip: ::protobuf::MessageField<super::steammessages_base::CMsgIPAddress>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSSetLobbyGameServer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSSetLobbyGameServer {
    fn default() -> &'a CMsgClientMMSSetLobbyGameServer {
        <CMsgClientMMSSetLobbyGameServer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSSetLobbyGameServer {
    pub fn new() -> CMsgClientMMSSetLobbyGameServer {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional uint32 deprecated_game_server_ip = 3;

    pub fn deprecated_game_server_ip(&self) -> u32 {
        self.deprecated_game_server_ip.unwrap_or(0)
    }

    pub fn clear_deprecated_game_server_ip(&mut self) {
        self.deprecated_game_server_ip = ::std::option::Option::None;
    }

    pub fn has_deprecated_game_server_ip(&self) -> bool {
        self.deprecated_game_server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_game_server_ip(&mut self, v: u32) {
        self.deprecated_game_server_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 game_server_port = 4;

    pub fn game_server_port(&self) -> u32 {
        self.game_server_port.unwrap_or(0)
    }

    pub fn clear_game_server_port(&mut self) {
        self.game_server_port = ::std::option::Option::None;
    }

    pub fn has_game_server_port(&self) -> bool {
        self.game_server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_port(&mut self, v: u32) {
        self.game_server_port = ::std::option::Option::Some(v);
    }

    // optional fixed64 game_server_steam_id = 5;

    pub fn game_server_steam_id(&self) -> u64 {
        self.game_server_steam_id.unwrap_or(0)
    }

    pub fn clear_game_server_steam_id(&mut self) {
        self.game_server_steam_id = ::std::option::Option::None;
    }

    pub fn has_game_server_steam_id(&self) -> bool {
        self.game_server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_steam_id(&mut self, v: u64) {
        self.game_server_steam_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSSetLobbyGameServer| { &m.app_id },
            |m: &mut CMsgClientMMSSetLobbyGameServer| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSSetLobbyGameServer| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSSetLobbyGameServer| { &mut m.steam_id_lobby },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deprecated_game_server_ip",
            |m: &CMsgClientMMSSetLobbyGameServer| { &m.deprecated_game_server_ip },
            |m: &mut CMsgClientMMSSetLobbyGameServer| { &mut m.deprecated_game_server_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_server_port",
            |m: &CMsgClientMMSSetLobbyGameServer| { &m.game_server_port },
            |m: &mut CMsgClientMMSSetLobbyGameServer| { &mut m.game_server_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_server_steam_id",
            |m: &CMsgClientMMSSetLobbyGameServer| { &m.game_server_steam_id },
            |m: &mut CMsgClientMMSSetLobbyGameServer| { &mut m.game_server_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steammessages_base::CMsgIPAddress>(
            "game_server_ip",
            |m: &CMsgClientMMSSetLobbyGameServer| { &m.game_server_ip },
            |m: &mut CMsgClientMMSSetLobbyGameServer| { &mut m.game_server_ip },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSSetLobbyGameServer>(
            "CMsgClientMMSSetLobbyGameServer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientMMSSetLobbyGameServer {
    const NAME: &'static str = "CMsgClientMMSSetLobbyGameServer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.deprecated_game_server_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.game_server_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                41 => {
                    self.game_server_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.game_server_ip)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.deprecated_game_server_ip {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.game_server_port {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.game_server_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.game_server_ip.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.deprecated_game_server_ip {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_server_port {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.game_server_steam_id {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.game_server_ip.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSSetLobbyGameServer {
        CMsgClientMMSSetLobbyGameServer::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.deprecated_game_server_ip = ::std::option::Option::None;
        self.game_server_port = ::std::option::Option::None;
        self.game_server_steam_id = ::std::option::Option::None;
        self.game_server_ip.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSSetLobbyGameServer {
        static instance: CMsgClientMMSSetLobbyGameServer = CMsgClientMMSSetLobbyGameServer {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            deprecated_game_server_ip: ::std::option::Option::None,
            game_server_port: ::std::option::Option::None,
            game_server_steam_id: ::std::option::Option::None,
            game_server_ip: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientMMSSetLobbyGameServer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSSetLobbyGameServer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSSetLobbyGameServer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSSetLobbyGameServer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientMMSLobbyGameServerSet)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSLobbyGameServerSet {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyGameServerSet.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyGameServerSet.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyGameServerSet.deprecated_game_server_ip)
    pub deprecated_game_server_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyGameServerSet.game_server_port)
    pub game_server_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyGameServerSet.game_server_steam_id)
    pub game_server_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyGameServerSet.game_server_ip)
    pub game_server_ip: ::protobuf::MessageField<super::steammessages_base::CMsgIPAddress>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSLobbyGameServerSet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSLobbyGameServerSet {
    fn default() -> &'a CMsgClientMMSLobbyGameServerSet {
        <CMsgClientMMSLobbyGameServerSet as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSLobbyGameServerSet {
    pub fn new() -> CMsgClientMMSLobbyGameServerSet {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional uint32 deprecated_game_server_ip = 3;

    pub fn deprecated_game_server_ip(&self) -> u32 {
        self.deprecated_game_server_ip.unwrap_or(0)
    }

    pub fn clear_deprecated_game_server_ip(&mut self) {
        self.deprecated_game_server_ip = ::std::option::Option::None;
    }

    pub fn has_deprecated_game_server_ip(&self) -> bool {
        self.deprecated_game_server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_game_server_ip(&mut self, v: u32) {
        self.deprecated_game_server_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 game_server_port = 4;

    pub fn game_server_port(&self) -> u32 {
        self.game_server_port.unwrap_or(0)
    }

    pub fn clear_game_server_port(&mut self) {
        self.game_server_port = ::std::option::Option::None;
    }

    pub fn has_game_server_port(&self) -> bool {
        self.game_server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_port(&mut self, v: u32) {
        self.game_server_port = ::std::option::Option::Some(v);
    }

    // optional fixed64 game_server_steam_id = 5;

    pub fn game_server_steam_id(&self) -> u64 {
        self.game_server_steam_id.unwrap_or(0)
    }

    pub fn clear_game_server_steam_id(&mut self) {
        self.game_server_steam_id = ::std::option::Option::None;
    }

    pub fn has_game_server_steam_id(&self) -> bool {
        self.game_server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_steam_id(&mut self, v: u64) {
        self.game_server_steam_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSLobbyGameServerSet| { &m.app_id },
            |m: &mut CMsgClientMMSLobbyGameServerSet| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSLobbyGameServerSet| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSLobbyGameServerSet| { &mut m.steam_id_lobby },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deprecated_game_server_ip",
            |m: &CMsgClientMMSLobbyGameServerSet| { &m.deprecated_game_server_ip },
            |m: &mut CMsgClientMMSLobbyGameServerSet| { &mut m.deprecated_game_server_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_server_port",
            |m: &CMsgClientMMSLobbyGameServerSet| { &m.game_server_port },
            |m: &mut CMsgClientMMSLobbyGameServerSet| { &mut m.game_server_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_server_steam_id",
            |m: &CMsgClientMMSLobbyGameServerSet| { &m.game_server_steam_id },
            |m: &mut CMsgClientMMSLobbyGameServerSet| { &mut m.game_server_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steammessages_base::CMsgIPAddress>(
            "game_server_ip",
            |m: &CMsgClientMMSLobbyGameServerSet| { &m.game_server_ip },
            |m: &mut CMsgClientMMSLobbyGameServerSet| { &mut m.game_server_ip },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSLobbyGameServerSet>(
            "CMsgClientMMSLobbyGameServerSet",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientMMSLobbyGameServerSet {
    const NAME: &'static str = "CMsgClientMMSLobbyGameServerSet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.deprecated_game_server_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.game_server_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                41 => {
                    self.game_server_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.game_server_ip)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.deprecated_game_server_ip {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.game_server_port {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.game_server_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.game_server_ip.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.deprecated_game_server_ip {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_server_port {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.game_server_steam_id {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.game_server_ip.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSLobbyGameServerSet {
        CMsgClientMMSLobbyGameServerSet::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.deprecated_game_server_ip = ::std::option::Option::None;
        self.game_server_port = ::std::option::Option::None;
        self.game_server_steam_id = ::std::option::Option::None;
        self.game_server_ip.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSLobbyGameServerSet {
        static instance: CMsgClientMMSLobbyGameServerSet = CMsgClientMMSLobbyGameServerSet {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            deprecated_game_server_ip: ::std::option::Option::None,
            game_server_port: ::std::option::Option::None,
            game_server_steam_id: ::std::option::Option::None,
            game_server_ip: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientMMSLobbyGameServerSet {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSLobbyGameServerSet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSLobbyGameServerSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSLobbyGameServerSet {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientMMSUserJoinedLobby)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSUserJoinedLobby {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSUserJoinedLobby.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSUserJoinedLobby.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSUserJoinedLobby.steam_id_user)
    pub steam_id_user: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSUserJoinedLobby.persona_name)
    pub persona_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSUserJoinedLobby.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSUserJoinedLobby {
    fn default() -> &'a CMsgClientMMSUserJoinedLobby {
        <CMsgClientMMSUserJoinedLobby as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSUserJoinedLobby {
    pub fn new() -> CMsgClientMMSUserJoinedLobby {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_user = 3;

    pub fn steam_id_user(&self) -> u64 {
        self.steam_id_user.unwrap_or(0)
    }

    pub fn clear_steam_id_user(&mut self) {
        self.steam_id_user = ::std::option::Option::None;
    }

    pub fn has_steam_id_user(&self) -> bool {
        self.steam_id_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_user(&mut self, v: u64) {
        self.steam_id_user = ::std::option::Option::Some(v);
    }

    // optional string persona_name = 4;

    pub fn persona_name(&self) -> &str {
        match self.persona_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_persona_name(&mut self) {
        self.persona_name = ::std::option::Option::None;
    }

    pub fn has_persona_name(&self) -> bool {
        self.persona_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_name(&mut self, v: ::std::string::String) {
        self.persona_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona_name(&mut self) -> &mut ::std::string::String {
        if self.persona_name.is_none() {
            self.persona_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.persona_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona_name(&mut self) -> ::std::string::String {
        self.persona_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSUserJoinedLobby| { &m.app_id },
            |m: &mut CMsgClientMMSUserJoinedLobby| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSUserJoinedLobby| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSUserJoinedLobby| { &mut m.steam_id_lobby },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_user",
            |m: &CMsgClientMMSUserJoinedLobby| { &m.steam_id_user },
            |m: &mut CMsgClientMMSUserJoinedLobby| { &mut m.steam_id_user },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "persona_name",
            |m: &CMsgClientMMSUserJoinedLobby| { &m.persona_name },
            |m: &mut CMsgClientMMSUserJoinedLobby| { &mut m.persona_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSUserJoinedLobby>(
            "CMsgClientMMSUserJoinedLobby",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientMMSUserJoinedLobby {
    const NAME: &'static str = "CMsgClientMMSUserJoinedLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.steam_id_user = ::std::option::Option::Some(is.read_fixed64()?);
                },
                34 => {
                    self.persona_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steam_id_user {
            my_size += 1 + 8;
        }
        if let Some(v) = self.persona_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_user {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.persona_name.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSUserJoinedLobby {
        CMsgClientMMSUserJoinedLobby::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.steam_id_user = ::std::option::Option::None;
        self.persona_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSUserJoinedLobby {
        static instance: CMsgClientMMSUserJoinedLobby = CMsgClientMMSUserJoinedLobby {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            steam_id_user: ::std::option::Option::None,
            persona_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientMMSUserJoinedLobby {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSUserJoinedLobby").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSUserJoinedLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSUserJoinedLobby {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientMMSUserLeftLobby)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSUserLeftLobby {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSUserLeftLobby.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSUserLeftLobby.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSUserLeftLobby.steam_id_user)
    pub steam_id_user: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSUserLeftLobby.persona_name)
    pub persona_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSUserLeftLobby.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSUserLeftLobby {
    fn default() -> &'a CMsgClientMMSUserLeftLobby {
        <CMsgClientMMSUserLeftLobby as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSUserLeftLobby {
    pub fn new() -> CMsgClientMMSUserLeftLobby {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_user = 3;

    pub fn steam_id_user(&self) -> u64 {
        self.steam_id_user.unwrap_or(0)
    }

    pub fn clear_steam_id_user(&mut self) {
        self.steam_id_user = ::std::option::Option::None;
    }

    pub fn has_steam_id_user(&self) -> bool {
        self.steam_id_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_user(&mut self, v: u64) {
        self.steam_id_user = ::std::option::Option::Some(v);
    }

    // optional string persona_name = 4;

    pub fn persona_name(&self) -> &str {
        match self.persona_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_persona_name(&mut self) {
        self.persona_name = ::std::option::Option::None;
    }

    pub fn has_persona_name(&self) -> bool {
        self.persona_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_name(&mut self, v: ::std::string::String) {
        self.persona_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona_name(&mut self) -> &mut ::std::string::String {
        if self.persona_name.is_none() {
            self.persona_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.persona_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona_name(&mut self) -> ::std::string::String {
        self.persona_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSUserLeftLobby| { &m.app_id },
            |m: &mut CMsgClientMMSUserLeftLobby| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSUserLeftLobby| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSUserLeftLobby| { &mut m.steam_id_lobby },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_user",
            |m: &CMsgClientMMSUserLeftLobby| { &m.steam_id_user },
            |m: &mut CMsgClientMMSUserLeftLobby| { &mut m.steam_id_user },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "persona_name",
            |m: &CMsgClientMMSUserLeftLobby| { &m.persona_name },
            |m: &mut CMsgClientMMSUserLeftLobby| { &mut m.persona_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSUserLeftLobby>(
            "CMsgClientMMSUserLeftLobby",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientMMSUserLeftLobby {
    const NAME: &'static str = "CMsgClientMMSUserLeftLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.steam_id_user = ::std::option::Option::Some(is.read_fixed64()?);
                },
                34 => {
                    self.persona_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steam_id_user {
            my_size += 1 + 8;
        }
        if let Some(v) = self.persona_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_user {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.persona_name.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSUserLeftLobby {
        CMsgClientMMSUserLeftLobby::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.steam_id_user = ::std::option::Option::None;
        self.persona_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSUserLeftLobby {
        static instance: CMsgClientMMSUserLeftLobby = CMsgClientMMSUserLeftLobby {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            steam_id_user: ::std::option::Option::None,
            persona_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientMMSUserLeftLobby {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSUserLeftLobby").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSUserLeftLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSUserLeftLobby {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientMMSInviteToLobby)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSInviteToLobby {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSInviteToLobby.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSInviteToLobby.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSInviteToLobby.steam_id_user_invited)
    pub steam_id_user_invited: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSInviteToLobby.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSInviteToLobby {
    fn default() -> &'a CMsgClientMMSInviteToLobby {
        <CMsgClientMMSInviteToLobby as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSInviteToLobby {
    pub fn new() -> CMsgClientMMSInviteToLobby {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_user_invited = 3;

    pub fn steam_id_user_invited(&self) -> u64 {
        self.steam_id_user_invited.unwrap_or(0)
    }

    pub fn clear_steam_id_user_invited(&mut self) {
        self.steam_id_user_invited = ::std::option::Option::None;
    }

    pub fn has_steam_id_user_invited(&self) -> bool {
        self.steam_id_user_invited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_user_invited(&mut self, v: u64) {
        self.steam_id_user_invited = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSInviteToLobby| { &m.app_id },
            |m: &mut CMsgClientMMSInviteToLobby| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSInviteToLobby| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSInviteToLobby| { &mut m.steam_id_lobby },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_user_invited",
            |m: &CMsgClientMMSInviteToLobby| { &m.steam_id_user_invited },
            |m: &mut CMsgClientMMSInviteToLobby| { &mut m.steam_id_user_invited },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSInviteToLobby>(
            "CMsgClientMMSInviteToLobby",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientMMSInviteToLobby {
    const NAME: &'static str = "CMsgClientMMSInviteToLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.steam_id_user_invited = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steam_id_user_invited {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_user_invited {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSInviteToLobby {
        CMsgClientMMSInviteToLobby::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.steam_id_user_invited = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSInviteToLobby {
        static instance: CMsgClientMMSInviteToLobby = CMsgClientMMSInviteToLobby {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            steam_id_user_invited: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientMMSInviteToLobby {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSInviteToLobby").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSInviteToLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSInviteToLobby {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientMMSGetLobbyStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSGetLobbyStatus {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyStatus.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyStatus.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyStatus.claim_membership)
    pub claim_membership: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyStatus.claim_ownership)
    pub claim_ownership: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSGetLobbyStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSGetLobbyStatus {
    fn default() -> &'a CMsgClientMMSGetLobbyStatus {
        <CMsgClientMMSGetLobbyStatus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSGetLobbyStatus {
    pub fn new() -> CMsgClientMMSGetLobbyStatus {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional bool claim_membership = 3;

    pub fn claim_membership(&self) -> bool {
        self.claim_membership.unwrap_or(false)
    }

    pub fn clear_claim_membership(&mut self) {
        self.claim_membership = ::std::option::Option::None;
    }

    pub fn has_claim_membership(&self) -> bool {
        self.claim_membership.is_some()
    }

    // Param is passed by value, moved
    pub fn set_claim_membership(&mut self, v: bool) {
        self.claim_membership = ::std::option::Option::Some(v);
    }

    // optional bool claim_ownership = 4;

    pub fn claim_ownership(&self) -> bool {
        self.claim_ownership.unwrap_or(false)
    }

    pub fn clear_claim_ownership(&mut self) {
        self.claim_ownership = ::std::option::Option::None;
    }

    pub fn has_claim_ownership(&self) -> bool {
        self.claim_ownership.is_some()
    }

    // Param is passed by value, moved
    pub fn set_claim_ownership(&mut self, v: bool) {
        self.claim_ownership = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSGetLobbyStatus| { &m.app_id },
            |m: &mut CMsgClientMMSGetLobbyStatus| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSGetLobbyStatus| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSGetLobbyStatus| { &mut m.steam_id_lobby },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "claim_membership",
            |m: &CMsgClientMMSGetLobbyStatus| { &m.claim_membership },
            |m: &mut CMsgClientMMSGetLobbyStatus| { &mut m.claim_membership },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "claim_ownership",
            |m: &CMsgClientMMSGetLobbyStatus| { &m.claim_ownership },
            |m: &mut CMsgClientMMSGetLobbyStatus| { &mut m.claim_ownership },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSGetLobbyStatus>(
            "CMsgClientMMSGetLobbyStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientMMSGetLobbyStatus {
    const NAME: &'static str = "CMsgClientMMSGetLobbyStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.claim_membership = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.claim_ownership = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.claim_membership {
            my_size += 1 + 1;
        }
        if let Some(v) = self.claim_ownership {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.claim_membership {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.claim_ownership {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSGetLobbyStatus {
        CMsgClientMMSGetLobbyStatus::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.claim_membership = ::std::option::Option::None;
        self.claim_ownership = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSGetLobbyStatus {
        static instance: CMsgClientMMSGetLobbyStatus = CMsgClientMMSGetLobbyStatus {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            claim_membership: ::std::option::Option::None,
            claim_ownership: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientMMSGetLobbyStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSGetLobbyStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSGetLobbyStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSGetLobbyStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientMMSGetLobbyStatusResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientMMSGetLobbyStatusResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyStatusResponse.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyStatusResponse.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyStatusResponse.lobby_status)
    pub lobby_status: ::std::option::Option<::protobuf::EnumOrUnknown<EMMSLobbyStatus>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSGetLobbyStatusResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSGetLobbyStatusResponse {
    fn default() -> &'a CMsgClientMMSGetLobbyStatusResponse {
        <CMsgClientMMSGetLobbyStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSGetLobbyStatusResponse {
    pub fn new() -> CMsgClientMMSGetLobbyStatusResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional .EMMSLobbyStatus lobby_status = 3;

    pub fn lobby_status(&self) -> EMMSLobbyStatus {
        match self.lobby_status {
            Some(e) => e.enum_value_or(EMMSLobbyStatus::k_EMMSLobbyStatusInvalid),
            None => EMMSLobbyStatus::k_EMMSLobbyStatusInvalid,
        }
    }

    pub fn clear_lobby_status(&mut self) {
        self.lobby_status = ::std::option::Option::None;
    }

    pub fn has_lobby_status(&self) -> bool {
        self.lobby_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_status(&mut self, v: EMMSLobbyStatus) {
        self.lobby_status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientMMSGetLobbyStatusResponse| { &m.app_id },
            |m: &mut CMsgClientMMSGetLobbyStatusResponse| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_lobby",
            |m: &CMsgClientMMSGetLobbyStatusResponse| { &m.steam_id_lobby },
            |m: &mut CMsgClientMMSGetLobbyStatusResponse| { &mut m.steam_id_lobby },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_status",
            |m: &CMsgClientMMSGetLobbyStatusResponse| { &m.lobby_status },
            |m: &mut CMsgClientMMSGetLobbyStatusResponse| { &mut m.lobby_status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientMMSGetLobbyStatusResponse>(
            "CMsgClientMMSGetLobbyStatusResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientMMSGetLobbyStatusResponse {
    const NAME: &'static str = "CMsgClientMMSGetLobbyStatusResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.lobby_status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.lobby_status {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.lobby_status {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSGetLobbyStatusResponse {
        CMsgClientMMSGetLobbyStatusResponse::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.lobby_status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSGetLobbyStatusResponse {
        static instance: CMsgClientMMSGetLobbyStatusResponse = CMsgClientMMSGetLobbyStatusResponse {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            lobby_status: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientMMSGetLobbyStatusResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientMMSGetLobbyStatusResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientMMSGetLobbyStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSGetLobbyStatusResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientInviteToGame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientInviteToGame {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientInviteToGame.steam_id_dest)
    pub steam_id_dest: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientInviteToGame.steam_id_src)
    pub steam_id_src: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientInviteToGame.connect_string)
    pub connect_string: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientInviteToGame.remote_play)
    pub remote_play: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientInviteToGame.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientInviteToGame {
    fn default() -> &'a CMsgClientInviteToGame {
        <CMsgClientInviteToGame as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientInviteToGame {
    pub fn new() -> CMsgClientInviteToGame {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_dest = 1;

    pub fn steam_id_dest(&self) -> u64 {
        self.steam_id_dest.unwrap_or(0)
    }

    pub fn clear_steam_id_dest(&mut self) {
        self.steam_id_dest = ::std::option::Option::None;
    }

    pub fn has_steam_id_dest(&self) -> bool {
        self.steam_id_dest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_dest(&mut self, v: u64) {
        self.steam_id_dest = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_src = 2;

    pub fn steam_id_src(&self) -> u64 {
        self.steam_id_src.unwrap_or(0)
    }

    pub fn clear_steam_id_src(&mut self) {
        self.steam_id_src = ::std::option::Option::None;
    }

    pub fn has_steam_id_src(&self) -> bool {
        self.steam_id_src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_src(&mut self, v: u64) {
        self.steam_id_src = ::std::option::Option::Some(v);
    }

    // optional string connect_string = 3;

    pub fn connect_string(&self) -> &str {
        match self.connect_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_connect_string(&mut self) {
        self.connect_string = ::std::option::Option::None;
    }

    pub fn has_connect_string(&self) -> bool {
        self.connect_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connect_string(&mut self, v: ::std::string::String) {
        self.connect_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connect_string(&mut self) -> &mut ::std::string::String {
        if self.connect_string.is_none() {
            self.connect_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.connect_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_connect_string(&mut self) -> ::std::string::String {
        self.connect_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string remote_play = 4;

    pub fn remote_play(&self) -> &str {
        match self.remote_play.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_remote_play(&mut self) {
        self.remote_play = ::std::option::Option::None;
    }

    pub fn has_remote_play(&self) -> bool {
        self.remote_play.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remote_play(&mut self, v: ::std::string::String) {
        self.remote_play = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remote_play(&mut self) -> &mut ::std::string::String {
        if self.remote_play.is_none() {
            self.remote_play = ::std::option::Option::Some(::std::string::String::new());
        }
        self.remote_play.as_mut().unwrap()
    }

    // Take field
    pub fn take_remote_play(&mut self) -> ::std::string::String {
        self.remote_play.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_dest",
            |m: &CMsgClientInviteToGame| { &m.steam_id_dest },
            |m: &mut CMsgClientInviteToGame| { &mut m.steam_id_dest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_src",
            |m: &CMsgClientInviteToGame| { &m.steam_id_src },
            |m: &mut CMsgClientInviteToGame| { &mut m.steam_id_src },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "connect_string",
            |m: &CMsgClientInviteToGame| { &m.connect_string },
            |m: &mut CMsgClientInviteToGame| { &mut m.connect_string },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "remote_play",
            |m: &CMsgClientInviteToGame| { &m.remote_play },
            |m: &mut CMsgClientInviteToGame| { &mut m.remote_play },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientInviteToGame>(
            "CMsgClientInviteToGame",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientInviteToGame {
    const NAME: &'static str = "CMsgClientInviteToGame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id_dest = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.steam_id_src = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.connect_string = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.remote_play = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_dest {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steam_id_src {
            my_size += 1 + 8;
        }
        if let Some(v) = self.connect_string.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.remote_play.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id_dest {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.steam_id_src {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.connect_string.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.remote_play.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientInviteToGame {
        CMsgClientInviteToGame::new()
    }

    fn clear(&mut self) {
        self.steam_id_dest = ::std::option::Option::None;
        self.steam_id_src = ::std::option::Option::None;
        self.connect_string = ::std::option::Option::None;
        self.remote_play = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientInviteToGame {
        static instance: CMsgClientInviteToGame = CMsgClientInviteToGame {
            steam_id_dest: ::std::option::Option::None,
            steam_id_src: ::std::option::Option::None,
            connect_string: ::std::option::Option::None,
            remote_play: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientInviteToGame {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientInviteToGame").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientInviteToGame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientInviteToGame {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientChatInvite)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientChatInvite {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientChatInvite.steam_id_invited)
    pub steam_id_invited: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientChatInvite.steam_id_chat)
    pub steam_id_chat: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientChatInvite.steam_id_patron)
    pub steam_id_patron: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientChatInvite.chatroom_type)
    pub chatroom_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientChatInvite.steam_id_friend_chat)
    pub steam_id_friend_chat: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientChatInvite.chat_name)
    pub chat_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientChatInvite.game_id)
    pub game_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientChatInvite.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientChatInvite {
    fn default() -> &'a CMsgClientChatInvite {
        <CMsgClientChatInvite as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientChatInvite {
    pub fn new() -> CMsgClientChatInvite {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_invited = 1;

    pub fn steam_id_invited(&self) -> u64 {
        self.steam_id_invited.unwrap_or(0)
    }

    pub fn clear_steam_id_invited(&mut self) {
        self.steam_id_invited = ::std::option::Option::None;
    }

    pub fn has_steam_id_invited(&self) -> bool {
        self.steam_id_invited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_invited(&mut self, v: u64) {
        self.steam_id_invited = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_chat = 2;

    pub fn steam_id_chat(&self) -> u64 {
        self.steam_id_chat.unwrap_or(0)
    }

    pub fn clear_steam_id_chat(&mut self) {
        self.steam_id_chat = ::std::option::Option::None;
    }

    pub fn has_steam_id_chat(&self) -> bool {
        self.steam_id_chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_chat(&mut self, v: u64) {
        self.steam_id_chat = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_patron = 3;

    pub fn steam_id_patron(&self) -> u64 {
        self.steam_id_patron.unwrap_or(0)
    }

    pub fn clear_steam_id_patron(&mut self) {
        self.steam_id_patron = ::std::option::Option::None;
    }

    pub fn has_steam_id_patron(&self) -> bool {
        self.steam_id_patron.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_patron(&mut self, v: u64) {
        self.steam_id_patron = ::std::option::Option::Some(v);
    }

    // optional int32 chatroom_type = 4;

    pub fn chatroom_type(&self) -> i32 {
        self.chatroom_type.unwrap_or(0)
    }

    pub fn clear_chatroom_type(&mut self) {
        self.chatroom_type = ::std::option::Option::None;
    }

    pub fn has_chatroom_type(&self) -> bool {
        self.chatroom_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chatroom_type(&mut self, v: i32) {
        self.chatroom_type = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_friend_chat = 5;

    pub fn steam_id_friend_chat(&self) -> u64 {
        self.steam_id_friend_chat.unwrap_or(0)
    }

    pub fn clear_steam_id_friend_chat(&mut self) {
        self.steam_id_friend_chat = ::std::option::Option::None;
    }

    pub fn has_steam_id_friend_chat(&self) -> bool {
        self.steam_id_friend_chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_friend_chat(&mut self, v: u64) {
        self.steam_id_friend_chat = ::std::option::Option::Some(v);
    }

    // optional string chat_name = 6;

    pub fn chat_name(&self) -> &str {
        match self.chat_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_chat_name(&mut self) {
        self.chat_name = ::std::option::Option::None;
    }

    pub fn has_chat_name(&self) -> bool {
        self.chat_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_name(&mut self, v: ::std::string::String) {
        self.chat_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_name(&mut self) -> &mut ::std::string::String {
        if self.chat_name.is_none() {
            self.chat_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.chat_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_name(&mut self) -> ::std::string::String {
        self.chat_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 game_id = 7;

    pub fn game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_invited",
            |m: &CMsgClientChatInvite| { &m.steam_id_invited },
            |m: &mut CMsgClientChatInvite| { &mut m.steam_id_invited },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_chat",
            |m: &CMsgClientChatInvite| { &m.steam_id_chat },
            |m: &mut CMsgClientChatInvite| { &mut m.steam_id_chat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_patron",
            |m: &CMsgClientChatInvite| { &m.steam_id_patron },
            |m: &mut CMsgClientChatInvite| { &mut m.steam_id_patron },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chatroom_type",
            |m: &CMsgClientChatInvite| { &m.chatroom_type },
            |m: &mut CMsgClientChatInvite| { &mut m.chatroom_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_friend_chat",
            |m: &CMsgClientChatInvite| { &m.steam_id_friend_chat },
            |m: &mut CMsgClientChatInvite| { &mut m.steam_id_friend_chat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_name",
            |m: &CMsgClientChatInvite| { &m.chat_name },
            |m: &mut CMsgClientChatInvite| { &mut m.chat_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_id",
            |m: &CMsgClientChatInvite| { &m.game_id },
            |m: &mut CMsgClientChatInvite| { &mut m.game_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientChatInvite>(
            "CMsgClientChatInvite",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientChatInvite {
    const NAME: &'static str = "CMsgClientChatInvite";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id_invited = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.steam_id_chat = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.steam_id_patron = ::std::option::Option::Some(is.read_fixed64()?);
                },
                32 => {
                    self.chatroom_type = ::std::option::Option::Some(is.read_int32()?);
                },
                41 => {
                    self.steam_id_friend_chat = ::std::option::Option::Some(is.read_fixed64()?);
                },
                50 => {
                    self.chat_name = ::std::option::Option::Some(is.read_string()?);
                },
                57 => {
                    self.game_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_invited {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steam_id_chat {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steam_id_patron {
            my_size += 1 + 8;
        }
        if let Some(v) = self.chatroom_type {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.steam_id_friend_chat {
            my_size += 1 + 8;
        }
        if let Some(v) = self.chat_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.game_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id_invited {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.steam_id_chat {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_patron {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.chatroom_type {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.steam_id_friend_chat {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.chat_name.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.game_id {
            os.write_fixed64(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientChatInvite {
        CMsgClientChatInvite::new()
    }

    fn clear(&mut self) {
        self.steam_id_invited = ::std::option::Option::None;
        self.steam_id_chat = ::std::option::Option::None;
        self.steam_id_patron = ::std::option::Option::None;
        self.chatroom_type = ::std::option::Option::None;
        self.steam_id_friend_chat = ::std::option::Option::None;
        self.chat_name = ::std::option::Option::None;
        self.game_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientChatInvite {
        static instance: CMsgClientChatInvite = CMsgClientChatInvite {
            steam_id_invited: ::std::option::Option::None,
            steam_id_chat: ::std::option::Option::None,
            steam_id_patron: ::std::option::Option::None,
            chatroom_type: ::std::option::Option::None,
            steam_id_friend_chat: ::std::option::Option::None,
            chat_name: ::std::option::Option::None,
            game_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientChatInvite {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientChatInvite").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientChatInvite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientChatInvite {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientConnectionStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientConnectionStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientConnectionStats.stats_logon)
    pub stats_logon: ::protobuf::MessageField<cmsg_client_connection_stats::Stats_Logon>,
    // @@protoc_insertion_point(field:CMsgClientConnectionStats.stats_vconn)
    pub stats_vconn: ::protobuf::MessageField<cmsg_client_connection_stats::Stats_VConn>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientConnectionStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientConnectionStats {
    fn default() -> &'a CMsgClientConnectionStats {
        <CMsgClientConnectionStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientConnectionStats {
    pub fn new() -> CMsgClientConnectionStats {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_client_connection_stats::Stats_Logon>(
            "stats_logon",
            |m: &CMsgClientConnectionStats| { &m.stats_logon },
            |m: &mut CMsgClientConnectionStats| { &mut m.stats_logon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_client_connection_stats::Stats_VConn>(
            "stats_vconn",
            |m: &CMsgClientConnectionStats| { &m.stats_vconn },
            |m: &mut CMsgClientConnectionStats| { &mut m.stats_vconn },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientConnectionStats>(
            "CMsgClientConnectionStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientConnectionStats {
    const NAME: &'static str = "CMsgClientConnectionStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.stats_logon)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.stats_vconn)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stats_logon.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.stats_vconn.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.stats_logon.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.stats_vconn.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientConnectionStats {
        CMsgClientConnectionStats::new()
    }

    fn clear(&mut self) {
        self.stats_logon.clear();
        self.stats_vconn.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientConnectionStats {
        static instance: CMsgClientConnectionStats = CMsgClientConnectionStats {
            stats_logon: ::protobuf::MessageField::none(),
            stats_vconn: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientConnectionStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientConnectionStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientConnectionStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientConnectionStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientConnectionStats`
pub mod cmsg_client_connection_stats {
    // @@protoc_insertion_point(message:CMsgClientConnectionStats.Stats_Logon)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Stats_Logon {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_Logon.connect_attempts)
        pub connect_attempts: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_Logon.connect_successes)
        pub connect_successes: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_Logon.connect_failures)
        pub connect_failures: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_Logon.connections_dropped)
        pub connections_dropped: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_Logon.seconds_running)
        pub seconds_running: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_Logon.msec_tologonthistime)
        pub msec_tologonthistime: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_Logon.count_bad_cms)
        pub count_bad_cms: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientConnectionStats.Stats_Logon.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Stats_Logon {
        fn default() -> &'a Stats_Logon {
            <Stats_Logon as ::protobuf::Message>::default_instance()
        }
    }

    impl Stats_Logon {
        pub fn new() -> Stats_Logon {
            ::std::default::Default::default()
        }

        // optional int32 connect_attempts = 1;

        pub fn connect_attempts(&self) -> i32 {
            self.connect_attempts.unwrap_or(0)
        }

        pub fn clear_connect_attempts(&mut self) {
            self.connect_attempts = ::std::option::Option::None;
        }

        pub fn has_connect_attempts(&self) -> bool {
            self.connect_attempts.is_some()
        }

        // Param is passed by value, moved
        pub fn set_connect_attempts(&mut self, v: i32) {
            self.connect_attempts = ::std::option::Option::Some(v);
        }

        // optional int32 connect_successes = 2;

        pub fn connect_successes(&self) -> i32 {
            self.connect_successes.unwrap_or(0)
        }

        pub fn clear_connect_successes(&mut self) {
            self.connect_successes = ::std::option::Option::None;
        }

        pub fn has_connect_successes(&self) -> bool {
            self.connect_successes.is_some()
        }

        // Param is passed by value, moved
        pub fn set_connect_successes(&mut self, v: i32) {
            self.connect_successes = ::std::option::Option::Some(v);
        }

        // optional int32 connect_failures = 3;

        pub fn connect_failures(&self) -> i32 {
            self.connect_failures.unwrap_or(0)
        }

        pub fn clear_connect_failures(&mut self) {
            self.connect_failures = ::std::option::Option::None;
        }

        pub fn has_connect_failures(&self) -> bool {
            self.connect_failures.is_some()
        }

        // Param is passed by value, moved
        pub fn set_connect_failures(&mut self, v: i32) {
            self.connect_failures = ::std::option::Option::Some(v);
        }

        // optional int32 connections_dropped = 4;

        pub fn connections_dropped(&self) -> i32 {
            self.connections_dropped.unwrap_or(0)
        }

        pub fn clear_connections_dropped(&mut self) {
            self.connections_dropped = ::std::option::Option::None;
        }

        pub fn has_connections_dropped(&self) -> bool {
            self.connections_dropped.is_some()
        }

        // Param is passed by value, moved
        pub fn set_connections_dropped(&mut self, v: i32) {
            self.connections_dropped = ::std::option::Option::Some(v);
        }

        // optional uint32 seconds_running = 5;

        pub fn seconds_running(&self) -> u32 {
            self.seconds_running.unwrap_or(0)
        }

        pub fn clear_seconds_running(&mut self) {
            self.seconds_running = ::std::option::Option::None;
        }

        pub fn has_seconds_running(&self) -> bool {
            self.seconds_running.is_some()
        }

        // Param is passed by value, moved
        pub fn set_seconds_running(&mut self, v: u32) {
            self.seconds_running = ::std::option::Option::Some(v);
        }

        // optional uint32 msec_tologonthistime = 6;

        pub fn msec_tologonthistime(&self) -> u32 {
            self.msec_tologonthistime.unwrap_or(0)
        }

        pub fn clear_msec_tologonthistime(&mut self) {
            self.msec_tologonthistime = ::std::option::Option::None;
        }

        pub fn has_msec_tologonthistime(&self) -> bool {
            self.msec_tologonthistime.is_some()
        }

        // Param is passed by value, moved
        pub fn set_msec_tologonthistime(&mut self, v: u32) {
            self.msec_tologonthistime = ::std::option::Option::Some(v);
        }

        // optional uint32 count_bad_cms = 7;

        pub fn count_bad_cms(&self) -> u32 {
            self.count_bad_cms.unwrap_or(0)
        }

        pub fn clear_count_bad_cms(&mut self) {
            self.count_bad_cms = ::std::option::Option::None;
        }

        pub fn has_count_bad_cms(&self) -> bool {
            self.count_bad_cms.is_some()
        }

        // Param is passed by value, moved
        pub fn set_count_bad_cms(&mut self, v: u32) {
            self.count_bad_cms = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(7);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "connect_attempts",
                |m: &Stats_Logon| { &m.connect_attempts },
                |m: &mut Stats_Logon| { &mut m.connect_attempts },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "connect_successes",
                |m: &Stats_Logon| { &m.connect_successes },
                |m: &mut Stats_Logon| { &mut m.connect_successes },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "connect_failures",
                |m: &Stats_Logon| { &m.connect_failures },
                |m: &mut Stats_Logon| { &mut m.connect_failures },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "connections_dropped",
                |m: &Stats_Logon| { &m.connections_dropped },
                |m: &mut Stats_Logon| { &mut m.connections_dropped },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "seconds_running",
                |m: &Stats_Logon| { &m.seconds_running },
                |m: &mut Stats_Logon| { &mut m.seconds_running },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "msec_tologonthistime",
                |m: &Stats_Logon| { &m.msec_tologonthistime },
                |m: &mut Stats_Logon| { &mut m.msec_tologonthistime },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "count_bad_cms",
                |m: &Stats_Logon| { &m.count_bad_cms },
                |m: &mut Stats_Logon| { &mut m.count_bad_cms },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Stats_Logon>(
                "CMsgClientConnectionStats.Stats_Logon",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Stats_Logon {
        const NAME: &'static str = "Stats_Logon";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.connect_attempts = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.connect_successes = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.connect_failures = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.connections_dropped = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.seconds_running = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.msec_tologonthistime = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.count_bad_cms = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.connect_attempts {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.connect_successes {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.connect_failures {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.connections_dropped {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.seconds_running {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.msec_tologonthistime {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.count_bad_cms {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.connect_attempts {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.connect_successes {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.connect_failures {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.connections_dropped {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.seconds_running {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.msec_tologonthistime {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.count_bad_cms {
                os.write_uint32(7, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Stats_Logon {
            Stats_Logon::new()
        }

        fn clear(&mut self) {
            self.connect_attempts = ::std::option::Option::None;
            self.connect_successes = ::std::option::Option::None;
            self.connect_failures = ::std::option::Option::None;
            self.connections_dropped = ::std::option::Option::None;
            self.seconds_running = ::std::option::Option::None;
            self.msec_tologonthistime = ::std::option::Option::None;
            self.count_bad_cms = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Stats_Logon {
            static instance: Stats_Logon = Stats_Logon {
                connect_attempts: ::std::option::Option::None,
                connect_successes: ::std::option::Option::None,
                connect_failures: ::std::option::Option::None,
                connections_dropped: ::std::option::Option::None,
                seconds_running: ::std::option::Option::None,
                msec_tologonthistime: ::std::option::Option::None,
                count_bad_cms: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Stats_Logon {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientConnectionStats.Stats_Logon").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Stats_Logon {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Stats_Logon {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgClientConnectionStats.Stats_UDP)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Stats_UDP {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_UDP.pkts_sent)
        pub pkts_sent: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_UDP.bytes_sent)
        pub bytes_sent: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_UDP.pkts_recv)
        pub pkts_recv: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_UDP.pkts_processed)
        pub pkts_processed: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_UDP.bytes_recv)
        pub bytes_recv: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientConnectionStats.Stats_UDP.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Stats_UDP {
        fn default() -> &'a Stats_UDP {
            <Stats_UDP as ::protobuf::Message>::default_instance()
        }
    }

    impl Stats_UDP {
        pub fn new() -> Stats_UDP {
            ::std::default::Default::default()
        }

        // optional uint64 pkts_sent = 1;

        pub fn pkts_sent(&self) -> u64 {
            self.pkts_sent.unwrap_or(0)
        }

        pub fn clear_pkts_sent(&mut self) {
            self.pkts_sent = ::std::option::Option::None;
        }

        pub fn has_pkts_sent(&self) -> bool {
            self.pkts_sent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pkts_sent(&mut self, v: u64) {
            self.pkts_sent = ::std::option::Option::Some(v);
        }

        // optional uint64 bytes_sent = 2;

        pub fn bytes_sent(&self) -> u64 {
            self.bytes_sent.unwrap_or(0)
        }

        pub fn clear_bytes_sent(&mut self) {
            self.bytes_sent = ::std::option::Option::None;
        }

        pub fn has_bytes_sent(&self) -> bool {
            self.bytes_sent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bytes_sent(&mut self, v: u64) {
            self.bytes_sent = ::std::option::Option::Some(v);
        }

        // optional uint64 pkts_recv = 3;

        pub fn pkts_recv(&self) -> u64 {
            self.pkts_recv.unwrap_or(0)
        }

        pub fn clear_pkts_recv(&mut self) {
            self.pkts_recv = ::std::option::Option::None;
        }

        pub fn has_pkts_recv(&self) -> bool {
            self.pkts_recv.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pkts_recv(&mut self, v: u64) {
            self.pkts_recv = ::std::option::Option::Some(v);
        }

        // optional uint64 pkts_processed = 4;

        pub fn pkts_processed(&self) -> u64 {
            self.pkts_processed.unwrap_or(0)
        }

        pub fn clear_pkts_processed(&mut self) {
            self.pkts_processed = ::std::option::Option::None;
        }

        pub fn has_pkts_processed(&self) -> bool {
            self.pkts_processed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pkts_processed(&mut self, v: u64) {
            self.pkts_processed = ::std::option::Option::Some(v);
        }

        // optional uint64 bytes_recv = 5;

        pub fn bytes_recv(&self) -> u64 {
            self.bytes_recv.unwrap_or(0)
        }

        pub fn clear_bytes_recv(&mut self) {
            self.bytes_recv = ::std::option::Option::None;
        }

        pub fn has_bytes_recv(&self) -> bool {
            self.bytes_recv.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bytes_recv(&mut self, v: u64) {
            self.bytes_recv = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "pkts_sent",
                |m: &Stats_UDP| { &m.pkts_sent },
                |m: &mut Stats_UDP| { &mut m.pkts_sent },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "bytes_sent",
                |m: &Stats_UDP| { &m.bytes_sent },
                |m: &mut Stats_UDP| { &mut m.bytes_sent },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "pkts_recv",
                |m: &Stats_UDP| { &m.pkts_recv },
                |m: &mut Stats_UDP| { &mut m.pkts_recv },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "pkts_processed",
                |m: &Stats_UDP| { &m.pkts_processed },
                |m: &mut Stats_UDP| { &mut m.pkts_processed },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "bytes_recv",
                |m: &Stats_UDP| { &m.bytes_recv },
                |m: &mut Stats_UDP| { &mut m.bytes_recv },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Stats_UDP>(
                "CMsgClientConnectionStats.Stats_UDP",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Stats_UDP {
        const NAME: &'static str = "Stats_UDP";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.pkts_sent = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.bytes_sent = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    24 => {
                        self.pkts_recv = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    32 => {
                        self.pkts_processed = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    40 => {
                        self.bytes_recv = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.pkts_sent {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.bytes_sent {
                my_size += ::protobuf::rt::uint64_size(2, v);
            }
            if let Some(v) = self.pkts_recv {
                my_size += ::protobuf::rt::uint64_size(3, v);
            }
            if let Some(v) = self.pkts_processed {
                my_size += ::protobuf::rt::uint64_size(4, v);
            }
            if let Some(v) = self.bytes_recv {
                my_size += ::protobuf::rt::uint64_size(5, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.pkts_sent {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.bytes_sent {
                os.write_uint64(2, v)?;
            }
            if let Some(v) = self.pkts_recv {
                os.write_uint64(3, v)?;
            }
            if let Some(v) = self.pkts_processed {
                os.write_uint64(4, v)?;
            }
            if let Some(v) = self.bytes_recv {
                os.write_uint64(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Stats_UDP {
            Stats_UDP::new()
        }

        fn clear(&mut self) {
            self.pkts_sent = ::std::option::Option::None;
            self.bytes_sent = ::std::option::Option::None;
            self.pkts_recv = ::std::option::Option::None;
            self.pkts_processed = ::std::option::Option::None;
            self.bytes_recv = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Stats_UDP {
            static instance: Stats_UDP = Stats_UDP {
                pkts_sent: ::std::option::Option::None,
                bytes_sent: ::std::option::Option::None,
                pkts_recv: ::std::option::Option::None,
                pkts_processed: ::std::option::Option::None,
                bytes_recv: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Stats_UDP {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientConnectionStats.Stats_UDP").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Stats_UDP {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Stats_UDP {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgClientConnectionStats.Stats_VConn)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Stats_VConn {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.connections_udp)
        pub connections_udp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.connections_tcp)
        pub connections_tcp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.stats_udp)
        pub stats_udp: ::protobuf::MessageField<Stats_UDP>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.pkts_abandoned)
        pub pkts_abandoned: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.conn_req_received)
        pub conn_req_received: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.pkts_resent)
        pub pkts_resent: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.msgs_sent)
        pub msgs_sent: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.msgs_sent_failed)
        pub msgs_sent_failed: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.msgs_recv)
        pub msgs_recv: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.datagrams_sent)
        pub datagrams_sent: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.datagrams_recv)
        pub datagrams_recv: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.bad_pkts_recv)
        pub bad_pkts_recv: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.unknown_conn_pkts_recv)
        pub unknown_conn_pkts_recv: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.missed_pkts_recv)
        pub missed_pkts_recv: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.dup_pkts_recv)
        pub dup_pkts_recv: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.failed_connect_challenges)
        pub failed_connect_challenges: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.micro_sec_avg_latency)
        pub micro_sec_avg_latency: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.micro_sec_min_latency)
        pub micro_sec_min_latency: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.micro_sec_max_latency)
        pub micro_sec_max_latency: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.mem_pool_msg_in_use)
        pub mem_pool_msg_in_use: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientConnectionStats.Stats_VConn.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Stats_VConn {
        fn default() -> &'a Stats_VConn {
            <Stats_VConn as ::protobuf::Message>::default_instance()
        }
    }

    impl Stats_VConn {
        pub fn new() -> Stats_VConn {
            ::std::default::Default::default()
        }

        // optional uint32 connections_udp = 1;

        pub fn connections_udp(&self) -> u32 {
            self.connections_udp.unwrap_or(0)
        }

        pub fn clear_connections_udp(&mut self) {
            self.connections_udp = ::std::option::Option::None;
        }

        pub fn has_connections_udp(&self) -> bool {
            self.connections_udp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_connections_udp(&mut self, v: u32) {
            self.connections_udp = ::std::option::Option::Some(v);
        }

        // optional uint32 connections_tcp = 2;

        pub fn connections_tcp(&self) -> u32 {
            self.connections_tcp.unwrap_or(0)
        }

        pub fn clear_connections_tcp(&mut self) {
            self.connections_tcp = ::std::option::Option::None;
        }

        pub fn has_connections_tcp(&self) -> bool {
            self.connections_tcp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_connections_tcp(&mut self, v: u32) {
            self.connections_tcp = ::std::option::Option::Some(v);
        }

        // optional uint64 pkts_abandoned = 4;

        pub fn pkts_abandoned(&self) -> u64 {
            self.pkts_abandoned.unwrap_or(0)
        }

        pub fn clear_pkts_abandoned(&mut self) {
            self.pkts_abandoned = ::std::option::Option::None;
        }

        pub fn has_pkts_abandoned(&self) -> bool {
            self.pkts_abandoned.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pkts_abandoned(&mut self, v: u64) {
            self.pkts_abandoned = ::std::option::Option::Some(v);
        }

        // optional uint64 conn_req_received = 5;

        pub fn conn_req_received(&self) -> u64 {
            self.conn_req_received.unwrap_or(0)
        }

        pub fn clear_conn_req_received(&mut self) {
            self.conn_req_received = ::std::option::Option::None;
        }

        pub fn has_conn_req_received(&self) -> bool {
            self.conn_req_received.is_some()
        }

        // Param is passed by value, moved
        pub fn set_conn_req_received(&mut self, v: u64) {
            self.conn_req_received = ::std::option::Option::Some(v);
        }

        // optional uint64 pkts_resent = 6;

        pub fn pkts_resent(&self) -> u64 {
            self.pkts_resent.unwrap_or(0)
        }

        pub fn clear_pkts_resent(&mut self) {
            self.pkts_resent = ::std::option::Option::None;
        }

        pub fn has_pkts_resent(&self) -> bool {
            self.pkts_resent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pkts_resent(&mut self, v: u64) {
            self.pkts_resent = ::std::option::Option::Some(v);
        }

        // optional uint64 msgs_sent = 7;

        pub fn msgs_sent(&self) -> u64 {
            self.msgs_sent.unwrap_or(0)
        }

        pub fn clear_msgs_sent(&mut self) {
            self.msgs_sent = ::std::option::Option::None;
        }

        pub fn has_msgs_sent(&self) -> bool {
            self.msgs_sent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_msgs_sent(&mut self, v: u64) {
            self.msgs_sent = ::std::option::Option::Some(v);
        }

        // optional uint64 msgs_sent_failed = 8;

        pub fn msgs_sent_failed(&self) -> u64 {
            self.msgs_sent_failed.unwrap_or(0)
        }

        pub fn clear_msgs_sent_failed(&mut self) {
            self.msgs_sent_failed = ::std::option::Option::None;
        }

        pub fn has_msgs_sent_failed(&self) -> bool {
            self.msgs_sent_failed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_msgs_sent_failed(&mut self, v: u64) {
            self.msgs_sent_failed = ::std::option::Option::Some(v);
        }

        // optional uint64 msgs_recv = 9;

        pub fn msgs_recv(&self) -> u64 {
            self.msgs_recv.unwrap_or(0)
        }

        pub fn clear_msgs_recv(&mut self) {
            self.msgs_recv = ::std::option::Option::None;
        }

        pub fn has_msgs_recv(&self) -> bool {
            self.msgs_recv.is_some()
        }

        // Param is passed by value, moved
        pub fn set_msgs_recv(&mut self, v: u64) {
            self.msgs_recv = ::std::option::Option::Some(v);
        }

        // optional uint64 datagrams_sent = 10;

        pub fn datagrams_sent(&self) -> u64 {
            self.datagrams_sent.unwrap_or(0)
        }

        pub fn clear_datagrams_sent(&mut self) {
            self.datagrams_sent = ::std::option::Option::None;
        }

        pub fn has_datagrams_sent(&self) -> bool {
            self.datagrams_sent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_datagrams_sent(&mut self, v: u64) {
            self.datagrams_sent = ::std::option::Option::Some(v);
        }

        // optional uint64 datagrams_recv = 11;

        pub fn datagrams_recv(&self) -> u64 {
            self.datagrams_recv.unwrap_or(0)
        }

        pub fn clear_datagrams_recv(&mut self) {
            self.datagrams_recv = ::std::option::Option::None;
        }

        pub fn has_datagrams_recv(&self) -> bool {
            self.datagrams_recv.is_some()
        }

        // Param is passed by value, moved
        pub fn set_datagrams_recv(&mut self, v: u64) {
            self.datagrams_recv = ::std::option::Option::Some(v);
        }

        // optional uint64 bad_pkts_recv = 12;

        pub fn bad_pkts_recv(&self) -> u64 {
            self.bad_pkts_recv.unwrap_or(0)
        }

        pub fn clear_bad_pkts_recv(&mut self) {
            self.bad_pkts_recv = ::std::option::Option::None;
        }

        pub fn has_bad_pkts_recv(&self) -> bool {
            self.bad_pkts_recv.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bad_pkts_recv(&mut self, v: u64) {
            self.bad_pkts_recv = ::std::option::Option::Some(v);
        }

        // optional uint64 unknown_conn_pkts_recv = 13;

        pub fn unknown_conn_pkts_recv(&self) -> u64 {
            self.unknown_conn_pkts_recv.unwrap_or(0)
        }

        pub fn clear_unknown_conn_pkts_recv(&mut self) {
            self.unknown_conn_pkts_recv = ::std::option::Option::None;
        }

        pub fn has_unknown_conn_pkts_recv(&self) -> bool {
            self.unknown_conn_pkts_recv.is_some()
        }

        // Param is passed by value, moved
        pub fn set_unknown_conn_pkts_recv(&mut self, v: u64) {
            self.unknown_conn_pkts_recv = ::std::option::Option::Some(v);
        }

        // optional uint64 missed_pkts_recv = 14;

        pub fn missed_pkts_recv(&self) -> u64 {
            self.missed_pkts_recv.unwrap_or(0)
        }

        pub fn clear_missed_pkts_recv(&mut self) {
            self.missed_pkts_recv = ::std::option::Option::None;
        }

        pub fn has_missed_pkts_recv(&self) -> bool {
            self.missed_pkts_recv.is_some()
        }

        // Param is passed by value, moved
        pub fn set_missed_pkts_recv(&mut self, v: u64) {
            self.missed_pkts_recv = ::std::option::Option::Some(v);
        }

        // optional uint64 dup_pkts_recv = 15;

        pub fn dup_pkts_recv(&self) -> u64 {
            self.dup_pkts_recv.unwrap_or(0)
        }

        pub fn clear_dup_pkts_recv(&mut self) {
            self.dup_pkts_recv = ::std::option::Option::None;
        }

        pub fn has_dup_pkts_recv(&self) -> bool {
            self.dup_pkts_recv.is_some()
        }

        // Param is passed by value, moved
        pub fn set_dup_pkts_recv(&mut self, v: u64) {
            self.dup_pkts_recv = ::std::option::Option::Some(v);
        }

        // optional uint64 failed_connect_challenges = 16;

        pub fn failed_connect_challenges(&self) -> u64 {
            self.failed_connect_challenges.unwrap_or(0)
        }

        pub fn clear_failed_connect_challenges(&mut self) {
            self.failed_connect_challenges = ::std::option::Option::None;
        }

        pub fn has_failed_connect_challenges(&self) -> bool {
            self.failed_connect_challenges.is_some()
        }

        // Param is passed by value, moved
        pub fn set_failed_connect_challenges(&mut self, v: u64) {
            self.failed_connect_challenges = ::std::option::Option::Some(v);
        }

        // optional uint32 micro_sec_avg_latency = 17;

        pub fn micro_sec_avg_latency(&self) -> u32 {
            self.micro_sec_avg_latency.unwrap_or(0)
        }

        pub fn clear_micro_sec_avg_latency(&mut self) {
            self.micro_sec_avg_latency = ::std::option::Option::None;
        }

        pub fn has_micro_sec_avg_latency(&self) -> bool {
            self.micro_sec_avg_latency.is_some()
        }

        // Param is passed by value, moved
        pub fn set_micro_sec_avg_latency(&mut self, v: u32) {
            self.micro_sec_avg_latency = ::std::option::Option::Some(v);
        }

        // optional uint32 micro_sec_min_latency = 18;

        pub fn micro_sec_min_latency(&self) -> u32 {
            self.micro_sec_min_latency.unwrap_or(0)
        }

        pub fn clear_micro_sec_min_latency(&mut self) {
            self.micro_sec_min_latency = ::std::option::Option::None;
        }

        pub fn has_micro_sec_min_latency(&self) -> bool {
            self.micro_sec_min_latency.is_some()
        }

        // Param is passed by value, moved
        pub fn set_micro_sec_min_latency(&mut self, v: u32) {
            self.micro_sec_min_latency = ::std::option::Option::Some(v);
        }

        // optional uint32 micro_sec_max_latency = 19;

        pub fn micro_sec_max_latency(&self) -> u32 {
            self.micro_sec_max_latency.unwrap_or(0)
        }

        pub fn clear_micro_sec_max_latency(&mut self) {
            self.micro_sec_max_latency = ::std::option::Option::None;
        }

        pub fn has_micro_sec_max_latency(&self) -> bool {
            self.micro_sec_max_latency.is_some()
        }

        // Param is passed by value, moved
        pub fn set_micro_sec_max_latency(&mut self, v: u32) {
            self.micro_sec_max_latency = ::std::option::Option::Some(v);
        }

        // optional uint32 mem_pool_msg_in_use = 20;

        pub fn mem_pool_msg_in_use(&self) -> u32 {
            self.mem_pool_msg_in_use.unwrap_or(0)
        }

        pub fn clear_mem_pool_msg_in_use(&mut self) {
            self.mem_pool_msg_in_use = ::std::option::Option::None;
        }

        pub fn has_mem_pool_msg_in_use(&self) -> bool {
            self.mem_pool_msg_in_use.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mem_pool_msg_in_use(&mut self, v: u32) {
            self.mem_pool_msg_in_use = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(20);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "connections_udp",
                |m: &Stats_VConn| { &m.connections_udp },
                |m: &mut Stats_VConn| { &mut m.connections_udp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "connections_tcp",
                |m: &Stats_VConn| { &m.connections_tcp },
                |m: &mut Stats_VConn| { &mut m.connections_tcp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Stats_UDP>(
                "stats_udp",
                |m: &Stats_VConn| { &m.stats_udp },
                |m: &mut Stats_VConn| { &mut m.stats_udp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "pkts_abandoned",
                |m: &Stats_VConn| { &m.pkts_abandoned },
                |m: &mut Stats_VConn| { &mut m.pkts_abandoned },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "conn_req_received",
                |m: &Stats_VConn| { &m.conn_req_received },
                |m: &mut Stats_VConn| { &mut m.conn_req_received },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "pkts_resent",
                |m: &Stats_VConn| { &m.pkts_resent },
                |m: &mut Stats_VConn| { &mut m.pkts_resent },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "msgs_sent",
                |m: &Stats_VConn| { &m.msgs_sent },
                |m: &mut Stats_VConn| { &mut m.msgs_sent },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "msgs_sent_failed",
                |m: &Stats_VConn| { &m.msgs_sent_failed },
                |m: &mut Stats_VConn| { &mut m.msgs_sent_failed },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "msgs_recv",
                |m: &Stats_VConn| { &m.msgs_recv },
                |m: &mut Stats_VConn| { &mut m.msgs_recv },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "datagrams_sent",
                |m: &Stats_VConn| { &m.datagrams_sent },
                |m: &mut Stats_VConn| { &mut m.datagrams_sent },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "datagrams_recv",
                |m: &Stats_VConn| { &m.datagrams_recv },
                |m: &mut Stats_VConn| { &mut m.datagrams_recv },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "bad_pkts_recv",
                |m: &Stats_VConn| { &m.bad_pkts_recv },
                |m: &mut Stats_VConn| { &mut m.bad_pkts_recv },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "unknown_conn_pkts_recv",
                |m: &Stats_VConn| { &m.unknown_conn_pkts_recv },
                |m: &mut Stats_VConn| { &mut m.unknown_conn_pkts_recv },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "missed_pkts_recv",
                |m: &Stats_VConn| { &m.missed_pkts_recv },
                |m: &mut Stats_VConn| { &mut m.missed_pkts_recv },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "dup_pkts_recv",
                |m: &Stats_VConn| { &m.dup_pkts_recv },
                |m: &mut Stats_VConn| { &mut m.dup_pkts_recv },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "failed_connect_challenges",
                |m: &Stats_VConn| { &m.failed_connect_challenges },
                |m: &mut Stats_VConn| { &mut m.failed_connect_challenges },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "micro_sec_avg_latency",
                |m: &Stats_VConn| { &m.micro_sec_avg_latency },
                |m: &mut Stats_VConn| { &mut m.micro_sec_avg_latency },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "micro_sec_min_latency",
                |m: &Stats_VConn| { &m.micro_sec_min_latency },
                |m: &mut Stats_VConn| { &mut m.micro_sec_min_latency },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "micro_sec_max_latency",
                |m: &Stats_VConn| { &m.micro_sec_max_latency },
                |m: &mut Stats_VConn| { &mut m.micro_sec_max_latency },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "mem_pool_msg_in_use",
                |m: &Stats_VConn| { &m.mem_pool_msg_in_use },
                |m: &mut Stats_VConn| { &mut m.mem_pool_msg_in_use },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Stats_VConn>(
                "CMsgClientConnectionStats.Stats_VConn",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Stats_VConn {
        const NAME: &'static str = "Stats_VConn";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.connections_udp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.connections_tcp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.stats_udp)?;
                    },
                    32 => {
                        self.pkts_abandoned = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    40 => {
                        self.conn_req_received = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    48 => {
                        self.pkts_resent = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    56 => {
                        self.msgs_sent = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    64 => {
                        self.msgs_sent_failed = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    72 => {
                        self.msgs_recv = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    80 => {
                        self.datagrams_sent = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    88 => {
                        self.datagrams_recv = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    96 => {
                        self.bad_pkts_recv = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    104 => {
                        self.unknown_conn_pkts_recv = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    112 => {
                        self.missed_pkts_recv = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    120 => {
                        self.dup_pkts_recv = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    128 => {
                        self.failed_connect_challenges = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    136 => {
                        self.micro_sec_avg_latency = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    144 => {
                        self.micro_sec_min_latency = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    152 => {
                        self.micro_sec_max_latency = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    160 => {
                        self.mem_pool_msg_in_use = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.connections_udp {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.connections_tcp {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.stats_udp.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.pkts_abandoned {
                my_size += ::protobuf::rt::uint64_size(4, v);
            }
            if let Some(v) = self.conn_req_received {
                my_size += ::protobuf::rt::uint64_size(5, v);
            }
            if let Some(v) = self.pkts_resent {
                my_size += ::protobuf::rt::uint64_size(6, v);
            }
            if let Some(v) = self.msgs_sent {
                my_size += ::protobuf::rt::uint64_size(7, v);
            }
            if let Some(v) = self.msgs_sent_failed {
                my_size += ::protobuf::rt::uint64_size(8, v);
            }
            if let Some(v) = self.msgs_recv {
                my_size += ::protobuf::rt::uint64_size(9, v);
            }
            if let Some(v) = self.datagrams_sent {
                my_size += ::protobuf::rt::uint64_size(10, v);
            }
            if let Some(v) = self.datagrams_recv {
                my_size += ::protobuf::rt::uint64_size(11, v);
            }
            if let Some(v) = self.bad_pkts_recv {
                my_size += ::protobuf::rt::uint64_size(12, v);
            }
            if let Some(v) = self.unknown_conn_pkts_recv {
                my_size += ::protobuf::rt::uint64_size(13, v);
            }
            if let Some(v) = self.missed_pkts_recv {
                my_size += ::protobuf::rt::uint64_size(14, v);
            }
            if let Some(v) = self.dup_pkts_recv {
                my_size += ::protobuf::rt::uint64_size(15, v);
            }
            if let Some(v) = self.failed_connect_challenges {
                my_size += ::protobuf::rt::uint64_size(16, v);
            }
            if let Some(v) = self.micro_sec_avg_latency {
                my_size += ::protobuf::rt::uint32_size(17, v);
            }
            if let Some(v) = self.micro_sec_min_latency {
                my_size += ::protobuf::rt::uint32_size(18, v);
            }
            if let Some(v) = self.micro_sec_max_latency {
                my_size += ::protobuf::rt::uint32_size(19, v);
            }
            if let Some(v) = self.mem_pool_msg_in_use {
                my_size += ::protobuf::rt::uint32_size(20, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.connections_udp {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.connections_tcp {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.stats_udp.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if let Some(v) = self.pkts_abandoned {
                os.write_uint64(4, v)?;
            }
            if let Some(v) = self.conn_req_received {
                os.write_uint64(5, v)?;
            }
            if let Some(v) = self.pkts_resent {
                os.write_uint64(6, v)?;
            }
            if let Some(v) = self.msgs_sent {
                os.write_uint64(7, v)?;
            }
            if let Some(v) = self.msgs_sent_failed {
                os.write_uint64(8, v)?;
            }
            if let Some(v) = self.msgs_recv {
                os.write_uint64(9, v)?;
            }
            if let Some(v) = self.datagrams_sent {
                os.write_uint64(10, v)?;
            }
            if let Some(v) = self.datagrams_recv {
                os.write_uint64(11, v)?;
            }
            if let Some(v) = self.bad_pkts_recv {
                os.write_uint64(12, v)?;
            }
            if let Some(v) = self.unknown_conn_pkts_recv {
                os.write_uint64(13, v)?;
            }
            if let Some(v) = self.missed_pkts_recv {
                os.write_uint64(14, v)?;
            }
            if let Some(v) = self.dup_pkts_recv {
                os.write_uint64(15, v)?;
            }
            if let Some(v) = self.failed_connect_challenges {
                os.write_uint64(16, v)?;
            }
            if let Some(v) = self.micro_sec_avg_latency {
                os.write_uint32(17, v)?;
            }
            if let Some(v) = self.micro_sec_min_latency {
                os.write_uint32(18, v)?;
            }
            if let Some(v) = self.micro_sec_max_latency {
                os.write_uint32(19, v)?;
            }
            if let Some(v) = self.mem_pool_msg_in_use {
                os.write_uint32(20, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Stats_VConn {
            Stats_VConn::new()
        }

        fn clear(&mut self) {
            self.connections_udp = ::std::option::Option::None;
            self.connections_tcp = ::std::option::Option::None;
            self.stats_udp.clear();
            self.pkts_abandoned = ::std::option::Option::None;
            self.conn_req_received = ::std::option::Option::None;
            self.pkts_resent = ::std::option::Option::None;
            self.msgs_sent = ::std::option::Option::None;
            self.msgs_sent_failed = ::std::option::Option::None;
            self.msgs_recv = ::std::option::Option::None;
            self.datagrams_sent = ::std::option::Option::None;
            self.datagrams_recv = ::std::option::Option::None;
            self.bad_pkts_recv = ::std::option::Option::None;
            self.unknown_conn_pkts_recv = ::std::option::Option::None;
            self.missed_pkts_recv = ::std::option::Option::None;
            self.dup_pkts_recv = ::std::option::Option::None;
            self.failed_connect_challenges = ::std::option::Option::None;
            self.micro_sec_avg_latency = ::std::option::Option::None;
            self.micro_sec_min_latency = ::std::option::Option::None;
            self.micro_sec_max_latency = ::std::option::Option::None;
            self.mem_pool_msg_in_use = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Stats_VConn {
            static instance: Stats_VConn = Stats_VConn {
                connections_udp: ::std::option::Option::None,
                connections_tcp: ::std::option::Option::None,
                stats_udp: ::protobuf::MessageField::none(),
                pkts_abandoned: ::std::option::Option::None,
                conn_req_received: ::std::option::Option::None,
                pkts_resent: ::std::option::Option::None,
                msgs_sent: ::std::option::Option::None,
                msgs_sent_failed: ::std::option::Option::None,
                msgs_recv: ::std::option::Option::None,
                datagrams_sent: ::std::option::Option::None,
                datagrams_recv: ::std::option::Option::None,
                bad_pkts_recv: ::std::option::Option::None,
                unknown_conn_pkts_recv: ::std::option::Option::None,
                missed_pkts_recv: ::std::option::Option::None,
                dup_pkts_recv: ::std::option::Option::None,
                failed_connect_challenges: ::std::option::Option::None,
                micro_sec_avg_latency: ::std::option::Option::None,
                micro_sec_min_latency: ::std::option::Option::None,
                micro_sec_max_latency: ::std::option::Option::None,
                mem_pool_msg_in_use: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Stats_VConn {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientConnectionStats.Stats_VConn").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Stats_VConn {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Stats_VConn {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientServersAvailable)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientServersAvailable {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientServersAvailable.server_types_available)
    pub server_types_available: ::std::vec::Vec<cmsg_client_servers_available::Server_Types_Available>,
    // @@protoc_insertion_point(field:CMsgClientServersAvailable.server_type_for_auth_services)
    pub server_type_for_auth_services: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientServersAvailable.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientServersAvailable {
    fn default() -> &'a CMsgClientServersAvailable {
        <CMsgClientServersAvailable as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientServersAvailable {
    pub fn new() -> CMsgClientServersAvailable {
        ::std::default::Default::default()
    }

    // optional uint32 server_type_for_auth_services = 2;

    pub fn server_type_for_auth_services(&self) -> u32 {
        self.server_type_for_auth_services.unwrap_or(0)
    }

    pub fn clear_server_type_for_auth_services(&mut self) {
        self.server_type_for_auth_services = ::std::option::Option::None;
    }

    pub fn has_server_type_for_auth_services(&self) -> bool {
        self.server_type_for_auth_services.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_type_for_auth_services(&mut self, v: u32) {
        self.server_type_for_auth_services = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "server_types_available",
            |m: &CMsgClientServersAvailable| { &m.server_types_available },
            |m: &mut CMsgClientServersAvailable| { &mut m.server_types_available },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_type_for_auth_services",
            |m: &CMsgClientServersAvailable| { &m.server_type_for_auth_services },
            |m: &mut CMsgClientServersAvailable| { &mut m.server_type_for_auth_services },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientServersAvailable>(
            "CMsgClientServersAvailable",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientServersAvailable {
    const NAME: &'static str = "CMsgClientServersAvailable";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.server_types_available.push(is.read_message()?);
                },
                16 => {
                    self.server_type_for_auth_services = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.server_types_available {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.server_type_for_auth_services {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.server_types_available {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.server_type_for_auth_services {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientServersAvailable {
        CMsgClientServersAvailable::new()
    }

    fn clear(&mut self) {
        self.server_types_available.clear();
        self.server_type_for_auth_services = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientServersAvailable {
        static instance: CMsgClientServersAvailable = CMsgClientServersAvailable {
            server_types_available: ::std::vec::Vec::new(),
            server_type_for_auth_services: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientServersAvailable {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientServersAvailable").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientServersAvailable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientServersAvailable {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientServersAvailable`
pub mod cmsg_client_servers_available {
    // @@protoc_insertion_point(message:CMsgClientServersAvailable.Server_Types_Available)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Server_Types_Available {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientServersAvailable.Server_Types_Available.server)
        pub server: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientServersAvailable.Server_Types_Available.changed)
        pub changed: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientServersAvailable.Server_Types_Available.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Server_Types_Available {
        fn default() -> &'a Server_Types_Available {
            <Server_Types_Available as ::protobuf::Message>::default_instance()
        }
    }

    impl Server_Types_Available {
        pub fn new() -> Server_Types_Available {
            ::std::default::Default::default()
        }

        // optional uint32 server = 1;

        pub fn server(&self) -> u32 {
            self.server.unwrap_or(0)
        }

        pub fn clear_server(&mut self) {
            self.server = ::std::option::Option::None;
        }

        pub fn has_server(&self) -> bool {
            self.server.is_some()
        }

        // Param is passed by value, moved
        pub fn set_server(&mut self, v: u32) {
            self.server = ::std::option::Option::Some(v);
        }

        // optional bool changed = 2;

        pub fn changed(&self) -> bool {
            self.changed.unwrap_or(false)
        }

        pub fn clear_changed(&mut self) {
            self.changed = ::std::option::Option::None;
        }

        pub fn has_changed(&self) -> bool {
            self.changed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_changed(&mut self, v: bool) {
            self.changed = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "server",
                |m: &Server_Types_Available| { &m.server },
                |m: &mut Server_Types_Available| { &mut m.server },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "changed",
                |m: &Server_Types_Available| { &m.changed },
                |m: &mut Server_Types_Available| { &mut m.changed },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Server_Types_Available>(
                "CMsgClientServersAvailable.Server_Types_Available",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Server_Types_Available {
        const NAME: &'static str = "Server_Types_Available";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.server = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.changed = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.server {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.changed {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.server {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.changed {
                os.write_bool(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Server_Types_Available {
            Server_Types_Available::new()
        }

        fn clear(&mut self) {
            self.server = ::std::option::Option::None;
            self.changed = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Server_Types_Available {
            static instance: Server_Types_Available = Server_Types_Available {
                server: ::std::option::Option::None,
                changed: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Server_Types_Available {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientServersAvailable.Server_Types_Available").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Server_Types_Available {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Server_Types_Available {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientGetUserStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetUserStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetUserStats.game_id)
    pub game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientGetUserStats.crc_stats)
    pub crc_stats: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGetUserStats.schema_local_version)
    pub schema_local_version: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientGetUserStats.steam_id_for_user)
    pub steam_id_for_user: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetUserStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetUserStats {
    fn default() -> &'a CMsgClientGetUserStats {
        <CMsgClientGetUserStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetUserStats {
    pub fn new() -> CMsgClientGetUserStats {
        ::std::default::Default::default()
    }

    // optional fixed64 game_id = 1;

    pub fn game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // optional uint32 crc_stats = 2;

    pub fn crc_stats(&self) -> u32 {
        self.crc_stats.unwrap_or(0)
    }

    pub fn clear_crc_stats(&mut self) {
        self.crc_stats = ::std::option::Option::None;
    }

    pub fn has_crc_stats(&self) -> bool {
        self.crc_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc_stats(&mut self, v: u32) {
        self.crc_stats = ::std::option::Option::Some(v);
    }

    // optional int32 schema_local_version = 3;

    pub fn schema_local_version(&self) -> i32 {
        self.schema_local_version.unwrap_or(0)
    }

    pub fn clear_schema_local_version(&mut self) {
        self.schema_local_version = ::std::option::Option::None;
    }

    pub fn has_schema_local_version(&self) -> bool {
        self.schema_local_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema_local_version(&mut self, v: i32) {
        self.schema_local_version = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_for_user = 4;

    pub fn steam_id_for_user(&self) -> u64 {
        self.steam_id_for_user.unwrap_or(0)
    }

    pub fn clear_steam_id_for_user(&mut self) {
        self.steam_id_for_user = ::std::option::Option::None;
    }

    pub fn has_steam_id_for_user(&self) -> bool {
        self.steam_id_for_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_for_user(&mut self, v: u64) {
        self.steam_id_for_user = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_id",
            |m: &CMsgClientGetUserStats| { &m.game_id },
            |m: &mut CMsgClientGetUserStats| { &mut m.game_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "crc_stats",
            |m: &CMsgClientGetUserStats| { &m.crc_stats },
            |m: &mut CMsgClientGetUserStats| { &mut m.crc_stats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "schema_local_version",
            |m: &CMsgClientGetUserStats| { &m.schema_local_version },
            |m: &mut CMsgClientGetUserStats| { &mut m.schema_local_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id_for_user",
            |m: &CMsgClientGetUserStats| { &m.steam_id_for_user },
            |m: &mut CMsgClientGetUserStats| { &mut m.steam_id_for_user },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientGetUserStats>(
            "CMsgClientGetUserStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientGetUserStats {
    const NAME: &'static str = "CMsgClientGetUserStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.game_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.crc_stats = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.schema_local_version = ::std::option::Option::Some(is.read_int32()?);
                },
                33 => {
                    self.steam_id_for_user = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.crc_stats {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.schema_local_version {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.steam_id_for_user {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.game_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.crc_stats {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.schema_local_version {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.steam_id_for_user {
            os.write_fixed64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetUserStats {
        CMsgClientGetUserStats::new()
    }

    fn clear(&mut self) {
        self.game_id = ::std::option::Option::None;
        self.crc_stats = ::std::option::Option::None;
        self.schema_local_version = ::std::option::Option::None;
        self.steam_id_for_user = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetUserStats {
        static instance: CMsgClientGetUserStats = CMsgClientGetUserStats {
            game_id: ::std::option::Option::None,
            crc_stats: ::std::option::Option::None,
            schema_local_version: ::std::option::Option::None,
            steam_id_for_user: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientGetUserStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientGetUserStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientGetUserStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetUserStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientGetUserStatsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetUserStatsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetUserStatsResponse.game_id)
    pub game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientGetUserStatsResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientGetUserStatsResponse.crc_stats)
    pub crc_stats: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGetUserStatsResponse.schema)
    pub schema: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientGetUserStatsResponse.stats)
    pub stats: ::std::vec::Vec<cmsg_client_get_user_stats_response::Stats>,
    // @@protoc_insertion_point(field:CMsgClientGetUserStatsResponse.achievement_blocks)
    pub achievement_blocks: ::std::vec::Vec<cmsg_client_get_user_stats_response::Achievement_Blocks>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetUserStatsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetUserStatsResponse {
    fn default() -> &'a CMsgClientGetUserStatsResponse {
        <CMsgClientGetUserStatsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetUserStatsResponse {
    pub fn new() -> CMsgClientGetUserStatsResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 game_id = 1;

    pub fn game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 2;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 crc_stats = 3;

    pub fn crc_stats(&self) -> u32 {
        self.crc_stats.unwrap_or(0)
    }

    pub fn clear_crc_stats(&mut self) {
        self.crc_stats = ::std::option::Option::None;
    }

    pub fn has_crc_stats(&self) -> bool {
        self.crc_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc_stats(&mut self, v: u32) {
        self.crc_stats = ::std::option::Option::Some(v);
    }

    // optional bytes schema = 4;

    pub fn schema(&self) -> &[u8] {
        match self.schema.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_schema(&mut self) {
        self.schema = ::std::option::Option::None;
    }

    pub fn has_schema(&self) -> bool {
        self.schema.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema(&mut self, v: ::std::vec::Vec<u8>) {
        self.schema = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.schema.is_none() {
            self.schema = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.schema.as_mut().unwrap()
    }

    // Take field
    pub fn take_schema(&mut self) -> ::std::vec::Vec<u8> {
        self.schema.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_id",
            |m: &CMsgClientGetUserStatsResponse| { &m.game_id },
            |m: &mut CMsgClientGetUserStatsResponse| { &mut m.game_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientGetUserStatsResponse| { &m.eresult },
            |m: &mut CMsgClientGetUserStatsResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "crc_stats",
            |m: &CMsgClientGetUserStatsResponse| { &m.crc_stats },
            |m: &mut CMsgClientGetUserStatsResponse| { &mut m.crc_stats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "schema",
            |m: &CMsgClientGetUserStatsResponse| { &m.schema },
            |m: &mut CMsgClientGetUserStatsResponse| { &mut m.schema },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stats",
            |m: &CMsgClientGetUserStatsResponse| { &m.stats },
            |m: &mut CMsgClientGetUserStatsResponse| { &mut m.stats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "achievement_blocks",
            |m: &CMsgClientGetUserStatsResponse| { &m.achievement_blocks },
            |m: &mut CMsgClientGetUserStatsResponse| { &mut m.achievement_blocks },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientGetUserStatsResponse>(
            "CMsgClientGetUserStatsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientGetUserStatsResponse {
    const NAME: &'static str = "CMsgClientGetUserStatsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.game_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.crc_stats = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.schema = ::std::option::Option::Some(is.read_bytes()?);
                },
                42 => {
                    self.stats.push(is.read_message()?);
                },
                50 => {
                    self.achievement_blocks.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.crc_stats {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.schema.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.achievement_blocks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.game_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.crc_stats {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.schema.as_ref() {
            os.write_bytes(4, v)?;
        }
        for v in &self.stats {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.achievement_blocks {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetUserStatsResponse {
        CMsgClientGetUserStatsResponse::new()
    }

    fn clear(&mut self) {
        self.game_id = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.crc_stats = ::std::option::Option::None;
        self.schema = ::std::option::Option::None;
        self.stats.clear();
        self.achievement_blocks.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetUserStatsResponse {
        static instance: CMsgClientGetUserStatsResponse = CMsgClientGetUserStatsResponse {
            game_id: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            crc_stats: ::std::option::Option::None,
            schema: ::std::option::Option::None,
            stats: ::std::vec::Vec::new(),
            achievement_blocks: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientGetUserStatsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientGetUserStatsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientGetUserStatsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetUserStatsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientGetUserStatsResponse`
pub mod cmsg_client_get_user_stats_response {
    // @@protoc_insertion_point(message:CMsgClientGetUserStatsResponse.Stats)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Stats {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientGetUserStatsResponse.Stats.stat_id)
        pub stat_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGetUserStatsResponse.Stats.stat_value)
        pub stat_value: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientGetUserStatsResponse.Stats.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Stats {
        fn default() -> &'a Stats {
            <Stats as ::protobuf::Message>::default_instance()
        }
    }

    impl Stats {
        pub fn new() -> Stats {
            ::std::default::Default::default()
        }

        // optional uint32 stat_id = 1;

        pub fn stat_id(&self) -> u32 {
            self.stat_id.unwrap_or(0)
        }

        pub fn clear_stat_id(&mut self) {
            self.stat_id = ::std::option::Option::None;
        }

        pub fn has_stat_id(&self) -> bool {
            self.stat_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stat_id(&mut self, v: u32) {
            self.stat_id = ::std::option::Option::Some(v);
        }

        // optional uint32 stat_value = 2;

        pub fn stat_value(&self) -> u32 {
            self.stat_value.unwrap_or(0)
        }

        pub fn clear_stat_value(&mut self) {
            self.stat_value = ::std::option::Option::None;
        }

        pub fn has_stat_value(&self) -> bool {
            self.stat_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stat_value(&mut self, v: u32) {
            self.stat_value = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "stat_id",
                |m: &Stats| { &m.stat_id },
                |m: &mut Stats| { &mut m.stat_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "stat_value",
                |m: &Stats| { &m.stat_value },
                |m: &mut Stats| { &mut m.stat_value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Stats>(
                "CMsgClientGetUserStatsResponse.Stats",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Stats {
        const NAME: &'static str = "Stats";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.stat_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.stat_value = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.stat_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.stat_value {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.stat_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.stat_value {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Stats {
            Stats::new()
        }

        fn clear(&mut self) {
            self.stat_id = ::std::option::Option::None;
            self.stat_value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Stats {
            static instance: Stats = Stats {
                stat_id: ::std::option::Option::None,
                stat_value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Stats {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientGetUserStatsResponse.Stats").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Stats {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Stats {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgClientGetUserStatsResponse.Achievement_Blocks)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Achievement_Blocks {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientGetUserStatsResponse.Achievement_Blocks.achievement_id)
        pub achievement_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGetUserStatsResponse.Achievement_Blocks.unlock_time)
        pub unlock_time: ::std::vec::Vec<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientGetUserStatsResponse.Achievement_Blocks.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Achievement_Blocks {
        fn default() -> &'a Achievement_Blocks {
            <Achievement_Blocks as ::protobuf::Message>::default_instance()
        }
    }

    impl Achievement_Blocks {
        pub fn new() -> Achievement_Blocks {
            ::std::default::Default::default()
        }

        // optional uint32 achievement_id = 1;

        pub fn achievement_id(&self) -> u32 {
            self.achievement_id.unwrap_or(0)
        }

        pub fn clear_achievement_id(&mut self) {
            self.achievement_id = ::std::option::Option::None;
        }

        pub fn has_achievement_id(&self) -> bool {
            self.achievement_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_achievement_id(&mut self, v: u32) {
            self.achievement_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "achievement_id",
                |m: &Achievement_Blocks| { &m.achievement_id },
                |m: &mut Achievement_Blocks| { &mut m.achievement_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "unlock_time",
                |m: &Achievement_Blocks| { &m.unlock_time },
                |m: &mut Achievement_Blocks| { &mut m.unlock_time },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Achievement_Blocks>(
                "CMsgClientGetUserStatsResponse.Achievement_Blocks",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Achievement_Blocks {
        const NAME: &'static str = "Achievement_Blocks";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.achievement_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        is.read_repeated_packed_fixed32_into(&mut self.unlock_time)?;
                    },
                    21 => {
                        self.unlock_time.push(is.read_fixed32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.achievement_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            my_size += 5 * self.unlock_time.len() as u64;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.achievement_id {
                os.write_uint32(1, v)?;
            }
            for v in &self.unlock_time {
                os.write_fixed32(2, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Achievement_Blocks {
            Achievement_Blocks::new()
        }

        fn clear(&mut self) {
            self.achievement_id = ::std::option::Option::None;
            self.unlock_time.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Achievement_Blocks {
            static instance: Achievement_Blocks = Achievement_Blocks {
                achievement_id: ::std::option::Option::None,
                unlock_time: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Achievement_Blocks {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientGetUserStatsResponse.Achievement_Blocks").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Achievement_Blocks {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Achievement_Blocks {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientStoreUserStatsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientStoreUserStatsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientStoreUserStatsResponse.game_id)
    pub game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientStoreUserStatsResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientStoreUserStatsResponse.crc_stats)
    pub crc_stats: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientStoreUserStatsResponse.stats_failed_validation)
    pub stats_failed_validation: ::std::vec::Vec<cmsg_client_store_user_stats_response::Stats_Failed_Validation>,
    // @@protoc_insertion_point(field:CMsgClientStoreUserStatsResponse.stats_out_of_date)
    pub stats_out_of_date: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientStoreUserStatsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientStoreUserStatsResponse {
    fn default() -> &'a CMsgClientStoreUserStatsResponse {
        <CMsgClientStoreUserStatsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientStoreUserStatsResponse {
    pub fn new() -> CMsgClientStoreUserStatsResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 game_id = 1;

    pub fn game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 2;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 crc_stats = 3;

    pub fn crc_stats(&self) -> u32 {
        self.crc_stats.unwrap_or(0)
    }

    pub fn clear_crc_stats(&mut self) {
        self.crc_stats = ::std::option::Option::None;
    }

    pub fn has_crc_stats(&self) -> bool {
        self.crc_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc_stats(&mut self, v: u32) {
        self.crc_stats = ::std::option::Option::Some(v);
    }

    // optional bool stats_out_of_date = 5;

    pub fn stats_out_of_date(&self) -> bool {
        self.stats_out_of_date.unwrap_or(false)
    }

    pub fn clear_stats_out_of_date(&mut self) {
        self.stats_out_of_date = ::std::option::Option::None;
    }

    pub fn has_stats_out_of_date(&self) -> bool {
        self.stats_out_of_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats_out_of_date(&mut self, v: bool) {
        self.stats_out_of_date = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_id",
            |m: &CMsgClientStoreUserStatsResponse| { &m.game_id },
            |m: &mut CMsgClientStoreUserStatsResponse| { &mut m.game_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientStoreUserStatsResponse| { &m.eresult },
            |m: &mut CMsgClientStoreUserStatsResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "crc_stats",
            |m: &CMsgClientStoreUserStatsResponse| { &m.crc_stats },
            |m: &mut CMsgClientStoreUserStatsResponse| { &mut m.crc_stats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stats_failed_validation",
            |m: &CMsgClientStoreUserStatsResponse| { &m.stats_failed_validation },
            |m: &mut CMsgClientStoreUserStatsResponse| { &mut m.stats_failed_validation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stats_out_of_date",
            |m: &CMsgClientStoreUserStatsResponse| { &m.stats_out_of_date },
            |m: &mut CMsgClientStoreUserStatsResponse| { &mut m.stats_out_of_date },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientStoreUserStatsResponse>(
            "CMsgClientStoreUserStatsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientStoreUserStatsResponse {
    const NAME: &'static str = "CMsgClientStoreUserStatsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.game_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.crc_stats = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.stats_failed_validation.push(is.read_message()?);
                },
                40 => {
                    self.stats_out_of_date = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.crc_stats {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        for value in &self.stats_failed_validation {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.stats_out_of_date {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.game_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.crc_stats {
            os.write_uint32(3, v)?;
        }
        for v in &self.stats_failed_validation {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.stats_out_of_date {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientStoreUserStatsResponse {
        CMsgClientStoreUserStatsResponse::new()
    }

    fn clear(&mut self) {
        self.game_id = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.crc_stats = ::std::option::Option::None;
        self.stats_failed_validation.clear();
        self.stats_out_of_date = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientStoreUserStatsResponse {
        static instance: CMsgClientStoreUserStatsResponse = CMsgClientStoreUserStatsResponse {
            game_id: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            crc_stats: ::std::option::Option::None,
            stats_failed_validation: ::std::vec::Vec::new(),
            stats_out_of_date: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientStoreUserStatsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientStoreUserStatsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientStoreUserStatsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientStoreUserStatsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientStoreUserStatsResponse`
pub mod cmsg_client_store_user_stats_response {
    // @@protoc_insertion_point(message:CMsgClientStoreUserStatsResponse.Stats_Failed_Validation)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Stats_Failed_Validation {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientStoreUserStatsResponse.Stats_Failed_Validation.stat_id)
        pub stat_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientStoreUserStatsResponse.Stats_Failed_Validation.reverted_stat_value)
        pub reverted_stat_value: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientStoreUserStatsResponse.Stats_Failed_Validation.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Stats_Failed_Validation {
        fn default() -> &'a Stats_Failed_Validation {
            <Stats_Failed_Validation as ::protobuf::Message>::default_instance()
        }
    }

    impl Stats_Failed_Validation {
        pub fn new() -> Stats_Failed_Validation {
            ::std::default::Default::default()
        }

        // optional uint32 stat_id = 1;

        pub fn stat_id(&self) -> u32 {
            self.stat_id.unwrap_or(0)
        }

        pub fn clear_stat_id(&mut self) {
            self.stat_id = ::std::option::Option::None;
        }

        pub fn has_stat_id(&self) -> bool {
            self.stat_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stat_id(&mut self, v: u32) {
            self.stat_id = ::std::option::Option::Some(v);
        }

        // optional uint32 reverted_stat_value = 2;

        pub fn reverted_stat_value(&self) -> u32 {
            self.reverted_stat_value.unwrap_or(0)
        }

        pub fn clear_reverted_stat_value(&mut self) {
            self.reverted_stat_value = ::std::option::Option::None;
        }

        pub fn has_reverted_stat_value(&self) -> bool {
            self.reverted_stat_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_reverted_stat_value(&mut self, v: u32) {
            self.reverted_stat_value = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "stat_id",
                |m: &Stats_Failed_Validation| { &m.stat_id },
                |m: &mut Stats_Failed_Validation| { &mut m.stat_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "reverted_stat_value",
                |m: &Stats_Failed_Validation| { &m.reverted_stat_value },
                |m: &mut Stats_Failed_Validation| { &mut m.reverted_stat_value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Stats_Failed_Validation>(
                "CMsgClientStoreUserStatsResponse.Stats_Failed_Validation",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Stats_Failed_Validation {
        const NAME: &'static str = "Stats_Failed_Validation";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.stat_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.reverted_stat_value = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.stat_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.reverted_stat_value {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.stat_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.reverted_stat_value {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Stats_Failed_Validation {
            Stats_Failed_Validation::new()
        }

        fn clear(&mut self) {
            self.stat_id = ::std::option::Option::None;
            self.reverted_stat_value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Stats_Failed_Validation {
            static instance: Stats_Failed_Validation = Stats_Failed_Validation {
                stat_id: ::std::option::Option::None,
                reverted_stat_value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Stats_Failed_Validation {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientStoreUserStatsResponse.Stats_Failed_Validation").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Stats_Failed_Validation {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Stats_Failed_Validation {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientStoreUserStats2)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientStoreUserStats2 {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientStoreUserStats2.game_id)
    pub game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientStoreUserStats2.settor_steam_id)
    pub settor_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientStoreUserStats2.settee_steam_id)
    pub settee_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientStoreUserStats2.crc_stats)
    pub crc_stats: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientStoreUserStats2.explicit_reset)
    pub explicit_reset: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientStoreUserStats2.stats)
    pub stats: ::std::vec::Vec<cmsg_client_store_user_stats2::Stats>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientStoreUserStats2.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientStoreUserStats2 {
    fn default() -> &'a CMsgClientStoreUserStats2 {
        <CMsgClientStoreUserStats2 as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientStoreUserStats2 {
    pub fn new() -> CMsgClientStoreUserStats2 {
        ::std::default::Default::default()
    }

    // optional fixed64 game_id = 1;

    pub fn game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 settor_steam_id = 2;

    pub fn settor_steam_id(&self) -> u64 {
        self.settor_steam_id.unwrap_or(0)
    }

    pub fn clear_settor_steam_id(&mut self) {
        self.settor_steam_id = ::std::option::Option::None;
    }

    pub fn has_settor_steam_id(&self) -> bool {
        self.settor_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_settor_steam_id(&mut self, v: u64) {
        self.settor_steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 settee_steam_id = 3;

    pub fn settee_steam_id(&self) -> u64 {
        self.settee_steam_id.unwrap_or(0)
    }

    pub fn clear_settee_steam_id(&mut self) {
        self.settee_steam_id = ::std::option::Option::None;
    }

    pub fn has_settee_steam_id(&self) -> bool {
        self.settee_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_settee_steam_id(&mut self, v: u64) {
        self.settee_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 crc_stats = 4;

    pub fn crc_stats(&self) -> u32 {
        self.crc_stats.unwrap_or(0)
    }

    pub fn clear_crc_stats(&mut self) {
        self.crc_stats = ::std::option::Option::None;
    }

    pub fn has_crc_stats(&self) -> bool {
        self.crc_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc_stats(&mut self, v: u32) {
        self.crc_stats = ::std::option::Option::Some(v);
    }

    // optional bool explicit_reset = 5;

    pub fn explicit_reset(&self) -> bool {
        self.explicit_reset.unwrap_or(false)
    }

    pub fn clear_explicit_reset(&mut self) {
        self.explicit_reset = ::std::option::Option::None;
    }

    pub fn has_explicit_reset(&self) -> bool {
        self.explicit_reset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_explicit_reset(&mut self, v: bool) {
        self.explicit_reset = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_id",
            |m: &CMsgClientStoreUserStats2| { &m.game_id },
            |m: &mut CMsgClientStoreUserStats2| { &mut m.game_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "settor_steam_id",
            |m: &CMsgClientStoreUserStats2| { &m.settor_steam_id },
            |m: &mut CMsgClientStoreUserStats2| { &mut m.settor_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "settee_steam_id",
            |m: &CMsgClientStoreUserStats2| { &m.settee_steam_id },
            |m: &mut CMsgClientStoreUserStats2| { &mut m.settee_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "crc_stats",
            |m: &CMsgClientStoreUserStats2| { &m.crc_stats },
            |m: &mut CMsgClientStoreUserStats2| { &mut m.crc_stats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "explicit_reset",
            |m: &CMsgClientStoreUserStats2| { &m.explicit_reset },
            |m: &mut CMsgClientStoreUserStats2| { &mut m.explicit_reset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stats",
            |m: &CMsgClientStoreUserStats2| { &m.stats },
            |m: &mut CMsgClientStoreUserStats2| { &mut m.stats },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientStoreUserStats2>(
            "CMsgClientStoreUserStats2",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientStoreUserStats2 {
    const NAME: &'static str = "CMsgClientStoreUserStats2";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.game_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.settor_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.settee_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                32 => {
                    self.crc_stats = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.explicit_reset = ::std::option::Option::Some(is.read_bool()?);
                },
                50 => {
                    self.stats.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.settor_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.settee_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.crc_stats {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.explicit_reset {
            my_size += 1 + 1;
        }
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.game_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.settor_steam_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.settee_steam_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.crc_stats {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.explicit_reset {
            os.write_bool(5, v)?;
        }
        for v in &self.stats {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientStoreUserStats2 {
        CMsgClientStoreUserStats2::new()
    }

    fn clear(&mut self) {
        self.game_id = ::std::option::Option::None;
        self.settor_steam_id = ::std::option::Option::None;
        self.settee_steam_id = ::std::option::Option::None;
        self.crc_stats = ::std::option::Option::None;
        self.explicit_reset = ::std::option::Option::None;
        self.stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientStoreUserStats2 {
        static instance: CMsgClientStoreUserStats2 = CMsgClientStoreUserStats2 {
            game_id: ::std::option::Option::None,
            settor_steam_id: ::std::option::Option::None,
            settee_steam_id: ::std::option::Option::None,
            crc_stats: ::std::option::Option::None,
            explicit_reset: ::std::option::Option::None,
            stats: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientStoreUserStats2 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientStoreUserStats2").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientStoreUserStats2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientStoreUserStats2 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientStoreUserStats2`
pub mod cmsg_client_store_user_stats2 {
    // @@protoc_insertion_point(message:CMsgClientStoreUserStats2.Stats)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Stats {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientStoreUserStats2.Stats.stat_id)
        pub stat_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientStoreUserStats2.Stats.stat_value)
        pub stat_value: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientStoreUserStats2.Stats.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Stats {
        fn default() -> &'a Stats {
            <Stats as ::protobuf::Message>::default_instance()
        }
    }

    impl Stats {
        pub fn new() -> Stats {
            ::std::default::Default::default()
        }

        // optional uint32 stat_id = 1;

        pub fn stat_id(&self) -> u32 {
            self.stat_id.unwrap_or(0)
        }

        pub fn clear_stat_id(&mut self) {
            self.stat_id = ::std::option::Option::None;
        }

        pub fn has_stat_id(&self) -> bool {
            self.stat_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stat_id(&mut self, v: u32) {
            self.stat_id = ::std::option::Option::Some(v);
        }

        // optional uint32 stat_value = 2;

        pub fn stat_value(&self) -> u32 {
            self.stat_value.unwrap_or(0)
        }

        pub fn clear_stat_value(&mut self) {
            self.stat_value = ::std::option::Option::None;
        }

        pub fn has_stat_value(&self) -> bool {
            self.stat_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stat_value(&mut self, v: u32) {
            self.stat_value = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "stat_id",
                |m: &Stats| { &m.stat_id },
                |m: &mut Stats| { &mut m.stat_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "stat_value",
                |m: &Stats| { &m.stat_value },
                |m: &mut Stats| { &mut m.stat_value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Stats>(
                "CMsgClientStoreUserStats2.Stats",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Stats {
        const NAME: &'static str = "Stats";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.stat_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.stat_value = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.stat_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.stat_value {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.stat_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.stat_value {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Stats {
            Stats::new()
        }

        fn clear(&mut self) {
            self.stat_id = ::std::option::Option::None;
            self.stat_value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Stats {
            static instance: Stats = Stats {
                stat_id: ::std::option::Option::None,
                stat_value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Stats {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientStoreUserStats2.Stats").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Stats {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Stats {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientStatsUpdated)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientStatsUpdated {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientStatsUpdated.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientStatsUpdated.game_id)
    pub game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientStatsUpdated.crc_stats)
    pub crc_stats: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientStatsUpdated.updated_stats)
    pub updated_stats: ::std::vec::Vec<cmsg_client_stats_updated::Updated_Stats>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientStatsUpdated.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientStatsUpdated {
    fn default() -> &'a CMsgClientStatsUpdated {
        <CMsgClientStatsUpdated as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientStatsUpdated {
    pub fn new() -> CMsgClientStatsUpdated {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 game_id = 2;

    pub fn game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // optional uint32 crc_stats = 3;

    pub fn crc_stats(&self) -> u32 {
        self.crc_stats.unwrap_or(0)
    }

    pub fn clear_crc_stats(&mut self) {
        self.crc_stats = ::std::option::Option::None;
    }

    pub fn has_crc_stats(&self) -> bool {
        self.crc_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc_stats(&mut self, v: u32) {
        self.crc_stats = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id",
            |m: &CMsgClientStatsUpdated| { &m.steam_id },
            |m: &mut CMsgClientStatsUpdated| { &mut m.steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_id",
            |m: &CMsgClientStatsUpdated| { &m.game_id },
            |m: &mut CMsgClientStatsUpdated| { &mut m.game_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "crc_stats",
            |m: &CMsgClientStatsUpdated| { &m.crc_stats },
            |m: &mut CMsgClientStatsUpdated| { &mut m.crc_stats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "updated_stats",
            |m: &CMsgClientStatsUpdated| { &m.updated_stats },
            |m: &mut CMsgClientStatsUpdated| { &mut m.updated_stats },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientStatsUpdated>(
            "CMsgClientStatsUpdated",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientStatsUpdated {
    const NAME: &'static str = "CMsgClientStatsUpdated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.game_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.crc_stats = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.updated_stats.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.game_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.crc_stats {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        for value in &self.updated_stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.game_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.crc_stats {
            os.write_uint32(3, v)?;
        }
        for v in &self.updated_stats {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientStatsUpdated {
        CMsgClientStatsUpdated::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.game_id = ::std::option::Option::None;
        self.crc_stats = ::std::option::Option::None;
        self.updated_stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientStatsUpdated {
        static instance: CMsgClientStatsUpdated = CMsgClientStatsUpdated {
            steam_id: ::std::option::Option::None,
            game_id: ::std::option::Option::None,
            crc_stats: ::std::option::Option::None,
            updated_stats: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientStatsUpdated {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientStatsUpdated").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientStatsUpdated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientStatsUpdated {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientStatsUpdated`
pub mod cmsg_client_stats_updated {
    // @@protoc_insertion_point(message:CMsgClientStatsUpdated.Updated_Stats)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Updated_Stats {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientStatsUpdated.Updated_Stats.stat_id)
        pub stat_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientStatsUpdated.Updated_Stats.stat_value)
        pub stat_value: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientStatsUpdated.Updated_Stats.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Updated_Stats {
        fn default() -> &'a Updated_Stats {
            <Updated_Stats as ::protobuf::Message>::default_instance()
        }
    }

    impl Updated_Stats {
        pub fn new() -> Updated_Stats {
            ::std::default::Default::default()
        }

        // optional uint32 stat_id = 1;

        pub fn stat_id(&self) -> u32 {
            self.stat_id.unwrap_or(0)
        }

        pub fn clear_stat_id(&mut self) {
            self.stat_id = ::std::option::Option::None;
        }

        pub fn has_stat_id(&self) -> bool {
            self.stat_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stat_id(&mut self, v: u32) {
            self.stat_id = ::std::option::Option::Some(v);
        }

        // optional uint32 stat_value = 2;

        pub fn stat_value(&self) -> u32 {
            self.stat_value.unwrap_or(0)
        }

        pub fn clear_stat_value(&mut self) {
            self.stat_value = ::std::option::Option::None;
        }

        pub fn has_stat_value(&self) -> bool {
            self.stat_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stat_value(&mut self, v: u32) {
            self.stat_value = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "stat_id",
                |m: &Updated_Stats| { &m.stat_id },
                |m: &mut Updated_Stats| { &mut m.stat_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "stat_value",
                |m: &Updated_Stats| { &m.stat_value },
                |m: &mut Updated_Stats| { &mut m.stat_value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Updated_Stats>(
                "CMsgClientStatsUpdated.Updated_Stats",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Updated_Stats {
        const NAME: &'static str = "Updated_Stats";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.stat_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.stat_value = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.stat_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.stat_value {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.stat_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.stat_value {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Updated_Stats {
            Updated_Stats::new()
        }

        fn clear(&mut self) {
            self.stat_id = ::std::option::Option::None;
            self.stat_value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Updated_Stats {
            static instance: Updated_Stats = Updated_Stats {
                stat_id: ::std::option::Option::None,
                stat_value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Updated_Stats {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientStatsUpdated.Updated_Stats").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Updated_Stats {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Updated_Stats {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientStoreUserStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientStoreUserStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientStoreUserStats.game_id)
    pub game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientStoreUserStats.explicit_reset)
    pub explicit_reset: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientStoreUserStats.stats_to_store)
    pub stats_to_store: ::std::vec::Vec<cmsg_client_store_user_stats::Stats_To_Store>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientStoreUserStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientStoreUserStats {
    fn default() -> &'a CMsgClientStoreUserStats {
        <CMsgClientStoreUserStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientStoreUserStats {
    pub fn new() -> CMsgClientStoreUserStats {
        ::std::default::Default::default()
    }

    // optional fixed64 game_id = 1;

    pub fn game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // optional bool explicit_reset = 2;

    pub fn explicit_reset(&self) -> bool {
        self.explicit_reset.unwrap_or(false)
    }

    pub fn clear_explicit_reset(&mut self) {
        self.explicit_reset = ::std::option::Option::None;
    }

    pub fn has_explicit_reset(&self) -> bool {
        self.explicit_reset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_explicit_reset(&mut self, v: bool) {
        self.explicit_reset = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_id",
            |m: &CMsgClientStoreUserStats| { &m.game_id },
            |m: &mut CMsgClientStoreUserStats| { &mut m.game_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "explicit_reset",
            |m: &CMsgClientStoreUserStats| { &m.explicit_reset },
            |m: &mut CMsgClientStoreUserStats| { &mut m.explicit_reset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stats_to_store",
            |m: &CMsgClientStoreUserStats| { &m.stats_to_store },
            |m: &mut CMsgClientStoreUserStats| { &mut m.stats_to_store },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientStoreUserStats>(
            "CMsgClientStoreUserStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientStoreUserStats {
    const NAME: &'static str = "CMsgClientStoreUserStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.game_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.explicit_reset = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.stats_to_store.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.explicit_reset {
            my_size += 1 + 1;
        }
        for value in &self.stats_to_store {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.game_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.explicit_reset {
            os.write_bool(2, v)?;
        }
        for v in &self.stats_to_store {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientStoreUserStats {
        CMsgClientStoreUserStats::new()
    }

    fn clear(&mut self) {
        self.game_id = ::std::option::Option::None;
        self.explicit_reset = ::std::option::Option::None;
        self.stats_to_store.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientStoreUserStats {
        static instance: CMsgClientStoreUserStats = CMsgClientStoreUserStats {
            game_id: ::std::option::Option::None,
            explicit_reset: ::std::option::Option::None,
            stats_to_store: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientStoreUserStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientStoreUserStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientStoreUserStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientStoreUserStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientStoreUserStats`
pub mod cmsg_client_store_user_stats {
    // @@protoc_insertion_point(message:CMsgClientStoreUserStats.Stats_To_Store)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Stats_To_Store {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientStoreUserStats.Stats_To_Store.stat_id)
        pub stat_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientStoreUserStats.Stats_To_Store.stat_value)
        pub stat_value: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientStoreUserStats.Stats_To_Store.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Stats_To_Store {
        fn default() -> &'a Stats_To_Store {
            <Stats_To_Store as ::protobuf::Message>::default_instance()
        }
    }

    impl Stats_To_Store {
        pub fn new() -> Stats_To_Store {
            ::std::default::Default::default()
        }

        // optional uint32 stat_id = 1;

        pub fn stat_id(&self) -> u32 {
            self.stat_id.unwrap_or(0)
        }

        pub fn clear_stat_id(&mut self) {
            self.stat_id = ::std::option::Option::None;
        }

        pub fn has_stat_id(&self) -> bool {
            self.stat_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stat_id(&mut self, v: u32) {
            self.stat_id = ::std::option::Option::Some(v);
        }

        // optional uint32 stat_value = 2;

        pub fn stat_value(&self) -> u32 {
            self.stat_value.unwrap_or(0)
        }

        pub fn clear_stat_value(&mut self) {
            self.stat_value = ::std::option::Option::None;
        }

        pub fn has_stat_value(&self) -> bool {
            self.stat_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stat_value(&mut self, v: u32) {
            self.stat_value = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "stat_id",
                |m: &Stats_To_Store| { &m.stat_id },
                |m: &mut Stats_To_Store| { &mut m.stat_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "stat_value",
                |m: &Stats_To_Store| { &m.stat_value },
                |m: &mut Stats_To_Store| { &mut m.stat_value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Stats_To_Store>(
                "CMsgClientStoreUserStats.Stats_To_Store",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Stats_To_Store {
        const NAME: &'static str = "Stats_To_Store";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.stat_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.stat_value = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.stat_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.stat_value {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.stat_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.stat_value {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Stats_To_Store {
            Stats_To_Store::new()
        }

        fn clear(&mut self) {
            self.stat_id = ::std::option::Option::None;
            self.stat_value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Stats_To_Store {
            static instance: Stats_To_Store = Stats_To_Store {
                stat_id: ::std::option::Option::None,
                stat_value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Stats_To_Store {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientStoreUserStats.Stats_To_Store").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Stats_To_Store {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Stats_To_Store {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientGetClientDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetClientDetails {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetClientDetails.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetClientDetails {
    fn default() -> &'a CMsgClientGetClientDetails {
        <CMsgClientGetClientDetails as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetClientDetails {
    pub fn new() -> CMsgClientGetClientDetails {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientGetClientDetails>(
            "CMsgClientGetClientDetails",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientGetClientDetails {
    const NAME: &'static str = "CMsgClientGetClientDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetClientDetails {
        CMsgClientGetClientDetails::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetClientDetails {
        static instance: CMsgClientGetClientDetails = CMsgClientGetClientDetails {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientGetClientDetails {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientGetClientDetails").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientGetClientDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetClientDetails {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientReportOverlayDetourFailure)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientReportOverlayDetourFailure {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientReportOverlayDetourFailure.failure_strings)
    pub failure_strings: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientReportOverlayDetourFailure.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientReportOverlayDetourFailure {
    fn default() -> &'a CMsgClientReportOverlayDetourFailure {
        <CMsgClientReportOverlayDetourFailure as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientReportOverlayDetourFailure {
    pub fn new() -> CMsgClientReportOverlayDetourFailure {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "failure_strings",
            |m: &CMsgClientReportOverlayDetourFailure| { &m.failure_strings },
            |m: &mut CMsgClientReportOverlayDetourFailure| { &mut m.failure_strings },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientReportOverlayDetourFailure>(
            "CMsgClientReportOverlayDetourFailure",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientReportOverlayDetourFailure {
    const NAME: &'static str = "CMsgClientReportOverlayDetourFailure";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.failure_strings.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.failure_strings {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.failure_strings {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientReportOverlayDetourFailure {
        CMsgClientReportOverlayDetourFailure::new()
    }

    fn clear(&mut self) {
        self.failure_strings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientReportOverlayDetourFailure {
        static instance: CMsgClientReportOverlayDetourFailure = CMsgClientReportOverlayDetourFailure {
            failure_strings: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientReportOverlayDetourFailure {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientReportOverlayDetourFailure").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientReportOverlayDetourFailure {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientReportOverlayDetourFailure {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientGetClientDetailsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetClientDetailsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetClientDetailsResponse.package_version)
    pub package_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGetClientDetailsResponse.protocol_version)
    pub protocol_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGetClientDetailsResponse.os)
    pub os: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientGetClientDetailsResponse.machine_name)
    pub machine_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientGetClientDetailsResponse.ip_public)
    pub ip_public: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientGetClientDetailsResponse.ip_private)
    pub ip_private: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientGetClientDetailsResponse.bytes_available)
    pub bytes_available: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientGetClientDetailsResponse.games_running)
    pub games_running: ::std::vec::Vec<cmsg_client_get_client_details_response::Game>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetClientDetailsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetClientDetailsResponse {
    fn default() -> &'a CMsgClientGetClientDetailsResponse {
        <CMsgClientGetClientDetailsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetClientDetailsResponse {
    pub fn new() -> CMsgClientGetClientDetailsResponse {
        ::std::default::Default::default()
    }

    // optional uint32 package_version = 1;

    pub fn package_version(&self) -> u32 {
        self.package_version.unwrap_or(0)
    }

    pub fn clear_package_version(&mut self) {
        self.package_version = ::std::option::Option::None;
    }

    pub fn has_package_version(&self) -> bool {
        self.package_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_package_version(&mut self, v: u32) {
        self.package_version = ::std::option::Option::Some(v);
    }

    // optional uint32 protocol_version = 8;

    pub fn protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }

    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }

    // optional string os = 2;

    pub fn os(&self) -> &str {
        match self.os.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_os(&mut self) {
        self.os = ::std::option::Option::None;
    }

    pub fn has_os(&self) -> bool {
        self.os.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os(&mut self, v: ::std::string::String) {
        self.os = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os(&mut self) -> &mut ::std::string::String {
        if self.os.is_none() {
            self.os = ::std::option::Option::Some(::std::string::String::new());
        }
        self.os.as_mut().unwrap()
    }

    // Take field
    pub fn take_os(&mut self) -> ::std::string::String {
        self.os.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string machine_name = 3;

    pub fn machine_name(&self) -> &str {
        match self.machine_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_machine_name(&mut self) {
        self.machine_name = ::std::option::Option::None;
    }

    pub fn has_machine_name(&self) -> bool {
        self.machine_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machine_name(&mut self, v: ::std::string::String) {
        self.machine_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machine_name(&mut self) -> &mut ::std::string::String {
        if self.machine_name.is_none() {
            self.machine_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.machine_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_machine_name(&mut self) -> ::std::string::String {
        self.machine_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string ip_public = 4;

    pub fn ip_public(&self) -> &str {
        match self.ip_public.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_ip_public(&mut self) {
        self.ip_public = ::std::option::Option::None;
    }

    pub fn has_ip_public(&self) -> bool {
        self.ip_public.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip_public(&mut self, v: ::std::string::String) {
        self.ip_public = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip_public(&mut self) -> &mut ::std::string::String {
        if self.ip_public.is_none() {
            self.ip_public = ::std::option::Option::Some(::std::string::String::new());
        }
        self.ip_public.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip_public(&mut self) -> ::std::string::String {
        self.ip_public.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string ip_private = 5;

    pub fn ip_private(&self) -> &str {
        match self.ip_private.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_ip_private(&mut self) {
        self.ip_private = ::std::option::Option::None;
    }

    pub fn has_ip_private(&self) -> bool {
        self.ip_private.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip_private(&mut self, v: ::std::string::String) {
        self.ip_private = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip_private(&mut self) -> &mut ::std::string::String {
        if self.ip_private.is_none() {
            self.ip_private = ::std::option::Option::Some(::std::string::String::new());
        }
        self.ip_private.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip_private(&mut self) -> ::std::string::String {
        self.ip_private.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 bytes_available = 7;

    pub fn bytes_available(&self) -> u64 {
        self.bytes_available.unwrap_or(0)
    }

    pub fn clear_bytes_available(&mut self) {
        self.bytes_available = ::std::option::Option::None;
    }

    pub fn has_bytes_available(&self) -> bool {
        self.bytes_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_available(&mut self, v: u64) {
        self.bytes_available = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "package_version",
            |m: &CMsgClientGetClientDetailsResponse| { &m.package_version },
            |m: &mut CMsgClientGetClientDetailsResponse| { &mut m.package_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "protocol_version",
            |m: &CMsgClientGetClientDetailsResponse| { &m.protocol_version },
            |m: &mut CMsgClientGetClientDetailsResponse| { &mut m.protocol_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "os",
            |m: &CMsgClientGetClientDetailsResponse| { &m.os },
            |m: &mut CMsgClientGetClientDetailsResponse| { &mut m.os },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "machine_name",
            |m: &CMsgClientGetClientDetailsResponse| { &m.machine_name },
            |m: &mut CMsgClientGetClientDetailsResponse| { &mut m.machine_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ip_public",
            |m: &CMsgClientGetClientDetailsResponse| { &m.ip_public },
            |m: &mut CMsgClientGetClientDetailsResponse| { &mut m.ip_public },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ip_private",
            |m: &CMsgClientGetClientDetailsResponse| { &m.ip_private },
            |m: &mut CMsgClientGetClientDetailsResponse| { &mut m.ip_private },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bytes_available",
            |m: &CMsgClientGetClientDetailsResponse| { &m.bytes_available },
            |m: &mut CMsgClientGetClientDetailsResponse| { &mut m.bytes_available },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "games_running",
            |m: &CMsgClientGetClientDetailsResponse| { &m.games_running },
            |m: &mut CMsgClientGetClientDetailsResponse| { &mut m.games_running },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientGetClientDetailsResponse>(
            "CMsgClientGetClientDetailsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientGetClientDetailsResponse {
    const NAME: &'static str = "CMsgClientGetClientDetailsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.package_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.protocol_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.os = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.machine_name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.ip_public = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.ip_private = ::std::option::Option::Some(is.read_string()?);
                },
                56 => {
                    self.bytes_available = ::std::option::Option::Some(is.read_uint64()?);
                },
                50 => {
                    self.games_running.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.package_version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.protocol_version {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.os.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.machine_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.ip_public.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.ip_private.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.bytes_available {
            my_size += ::protobuf::rt::uint64_size(7, v);
        }
        for value in &self.games_running {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.package_version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.protocol_version {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.os.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.machine_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.ip_public.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.ip_private.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.bytes_available {
            os.write_uint64(7, v)?;
        }
        for v in &self.games_running {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetClientDetailsResponse {
        CMsgClientGetClientDetailsResponse::new()
    }

    fn clear(&mut self) {
        self.package_version = ::std::option::Option::None;
        self.protocol_version = ::std::option::Option::None;
        self.os = ::std::option::Option::None;
        self.machine_name = ::std::option::Option::None;
        self.ip_public = ::std::option::Option::None;
        self.ip_private = ::std::option::Option::None;
        self.bytes_available = ::std::option::Option::None;
        self.games_running.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetClientDetailsResponse {
        static instance: CMsgClientGetClientDetailsResponse = CMsgClientGetClientDetailsResponse {
            package_version: ::std::option::Option::None,
            protocol_version: ::std::option::Option::None,
            os: ::std::option::Option::None,
            machine_name: ::std::option::Option::None,
            ip_public: ::std::option::Option::None,
            ip_private: ::std::option::Option::None,
            bytes_available: ::std::option::Option::None,
            games_running: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientGetClientDetailsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientGetClientDetailsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientGetClientDetailsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetClientDetailsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientGetClientDetailsResponse`
pub mod cmsg_client_get_client_details_response {
    // @@protoc_insertion_point(message:CMsgClientGetClientDetailsResponse.Game)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Game {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientGetClientDetailsResponse.Game.appid)
        pub appid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGetClientDetailsResponse.Game.extra_info)
        pub extra_info: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientGetClientDetailsResponse.Game.time_running_sec)
        pub time_running_sec: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientGetClientDetailsResponse.Game.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Game {
        fn default() -> &'a Game {
            <Game as ::protobuf::Message>::default_instance()
        }
    }

    impl Game {
        pub fn new() -> Game {
            ::std::default::Default::default()
        }

        // optional uint32 appid = 1;

        pub fn appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional string extra_info = 2;

        pub fn extra_info(&self) -> &str {
            match self.extra_info.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_extra_info(&mut self) {
            self.extra_info = ::std::option::Option::None;
        }

        pub fn has_extra_info(&self) -> bool {
            self.extra_info.is_some()
        }

        // Param is passed by value, moved
        pub fn set_extra_info(&mut self, v: ::std::string::String) {
            self.extra_info = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_extra_info(&mut self) -> &mut ::std::string::String {
            if self.extra_info.is_none() {
                self.extra_info = ::std::option::Option::Some(::std::string::String::new());
            }
            self.extra_info.as_mut().unwrap()
        }

        // Take field
        pub fn take_extra_info(&mut self) -> ::std::string::String {
            self.extra_info.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 time_running_sec = 3;

        pub fn time_running_sec(&self) -> u32 {
            self.time_running_sec.unwrap_or(0)
        }

        pub fn clear_time_running_sec(&mut self) {
            self.time_running_sec = ::std::option::Option::None;
        }

        pub fn has_time_running_sec(&self) -> bool {
            self.time_running_sec.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_running_sec(&mut self, v: u32) {
            self.time_running_sec = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "appid",
                |m: &Game| { &m.appid },
                |m: &mut Game| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "extra_info",
                |m: &Game| { &m.extra_info },
                |m: &mut Game| { &mut m.extra_info },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "time_running_sec",
                |m: &Game| { &m.time_running_sec },
                |m: &mut Game| { &mut m.time_running_sec },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Game>(
                "CMsgClientGetClientDetailsResponse.Game",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Game {
        const NAME: &'static str = "Game";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.extra_info = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.time_running_sec = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.appid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.extra_info.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.time_running_sec {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.appid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.extra_info.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.time_running_sec {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Game {
            Game::new()
        }

        fn clear(&mut self) {
            self.appid = ::std::option::Option::None;
            self.extra_info = ::std::option::Option::None;
            self.time_running_sec = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Game {
            static instance: Game = Game {
                appid: ::std::option::Option::None,
                extra_info: ::std::option::Option::None,
                time_running_sec: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Game {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientGetClientDetailsResponse.Game").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Game {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Game {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientGetClientAppList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetClientAppList {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetClientAppList.media)
    pub media: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientGetClientAppList.tools)
    pub tools: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientGetClientAppList.games)
    pub games: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientGetClientAppList.only_installed)
    pub only_installed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientGetClientAppList.only_changing)
    pub only_changing: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientGetClientAppList.comics)
    pub comics: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetClientAppList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetClientAppList {
    fn default() -> &'a CMsgClientGetClientAppList {
        <CMsgClientGetClientAppList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetClientAppList {
    pub fn new() -> CMsgClientGetClientAppList {
        ::std::default::Default::default()
    }

    // optional bool media = 1;

    pub fn media(&self) -> bool {
        self.media.unwrap_or(false)
    }

    pub fn clear_media(&mut self) {
        self.media = ::std::option::Option::None;
    }

    pub fn has_media(&self) -> bool {
        self.media.is_some()
    }

    // Param is passed by value, moved
    pub fn set_media(&mut self, v: bool) {
        self.media = ::std::option::Option::Some(v);
    }

    // optional bool tools = 2;

    pub fn tools(&self) -> bool {
        self.tools.unwrap_or(false)
    }

    pub fn clear_tools(&mut self) {
        self.tools = ::std::option::Option::None;
    }

    pub fn has_tools(&self) -> bool {
        self.tools.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tools(&mut self, v: bool) {
        self.tools = ::std::option::Option::Some(v);
    }

    // optional bool games = 3;

    pub fn games(&self) -> bool {
        self.games.unwrap_or(false)
    }

    pub fn clear_games(&mut self) {
        self.games = ::std::option::Option::None;
    }

    pub fn has_games(&self) -> bool {
        self.games.is_some()
    }

    // Param is passed by value, moved
    pub fn set_games(&mut self, v: bool) {
        self.games = ::std::option::Option::Some(v);
    }

    // optional bool only_installed = 4;

    pub fn only_installed(&self) -> bool {
        self.only_installed.unwrap_or(false)
    }

    pub fn clear_only_installed(&mut self) {
        self.only_installed = ::std::option::Option::None;
    }

    pub fn has_only_installed(&self) -> bool {
        self.only_installed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_only_installed(&mut self, v: bool) {
        self.only_installed = ::std::option::Option::Some(v);
    }

    // optional bool only_changing = 5;

    pub fn only_changing(&self) -> bool {
        self.only_changing.unwrap_or(false)
    }

    pub fn clear_only_changing(&mut self) {
        self.only_changing = ::std::option::Option::None;
    }

    pub fn has_only_changing(&self) -> bool {
        self.only_changing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_only_changing(&mut self, v: bool) {
        self.only_changing = ::std::option::Option::Some(v);
    }

    // optional bool comics = 6;

    pub fn comics(&self) -> bool {
        self.comics.unwrap_or(false)
    }

    pub fn clear_comics(&mut self) {
        self.comics = ::std::option::Option::None;
    }

    pub fn has_comics(&self) -> bool {
        self.comics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comics(&mut self, v: bool) {
        self.comics = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "media",
            |m: &CMsgClientGetClientAppList| { &m.media },
            |m: &mut CMsgClientGetClientAppList| { &mut m.media },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tools",
            |m: &CMsgClientGetClientAppList| { &m.tools },
            |m: &mut CMsgClientGetClientAppList| { &mut m.tools },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "games",
            |m: &CMsgClientGetClientAppList| { &m.games },
            |m: &mut CMsgClientGetClientAppList| { &mut m.games },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "only_installed",
            |m: &CMsgClientGetClientAppList| { &m.only_installed },
            |m: &mut CMsgClientGetClientAppList| { &mut m.only_installed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "only_changing",
            |m: &CMsgClientGetClientAppList| { &m.only_changing },
            |m: &mut CMsgClientGetClientAppList| { &mut m.only_changing },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "comics",
            |m: &CMsgClientGetClientAppList| { &m.comics },
            |m: &mut CMsgClientGetClientAppList| { &mut m.comics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientGetClientAppList>(
            "CMsgClientGetClientAppList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientGetClientAppList {
    const NAME: &'static str = "CMsgClientGetClientAppList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.media = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.tools = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.games = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.only_installed = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.only_changing = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.comics = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.media {
            my_size += 1 + 1;
        }
        if let Some(v) = self.tools {
            my_size += 1 + 1;
        }
        if let Some(v) = self.games {
            my_size += 1 + 1;
        }
        if let Some(v) = self.only_installed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.only_changing {
            my_size += 1 + 1;
        }
        if let Some(v) = self.comics {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.media {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.tools {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.games {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.only_installed {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.only_changing {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.comics {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetClientAppList {
        CMsgClientGetClientAppList::new()
    }

    fn clear(&mut self) {
        self.media = ::std::option::Option::None;
        self.tools = ::std::option::Option::None;
        self.games = ::std::option::Option::None;
        self.only_installed = ::std::option::Option::None;
        self.only_changing = ::std::option::Option::None;
        self.comics = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetClientAppList {
        static instance: CMsgClientGetClientAppList = CMsgClientGetClientAppList {
            media: ::std::option::Option::None,
            tools: ::std::option::Option::None,
            games: ::std::option::Option::None,
            only_installed: ::std::option::Option::None,
            only_changing: ::std::option::Option::None,
            comics: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientGetClientAppList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientGetClientAppList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientGetClientAppList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetClientAppList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientGetClientAppListResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGetClientAppListResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.apps)
    pub apps: ::std::vec::Vec<cmsg_client_get_client_app_list_response::App>,
    // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.bytes_available)
    pub bytes_available: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetClientAppListResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetClientAppListResponse {
    fn default() -> &'a CMsgClientGetClientAppListResponse {
        <CMsgClientGetClientAppListResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetClientAppListResponse {
    pub fn new() -> CMsgClientGetClientAppListResponse {
        ::std::default::Default::default()
    }

    // optional uint64 bytes_available = 2;

    pub fn bytes_available(&self) -> u64 {
        self.bytes_available.unwrap_or(0)
    }

    pub fn clear_bytes_available(&mut self) {
        self.bytes_available = ::std::option::Option::None;
    }

    pub fn has_bytes_available(&self) -> bool {
        self.bytes_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_available(&mut self, v: u64) {
        self.bytes_available = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "apps",
            |m: &CMsgClientGetClientAppListResponse| { &m.apps },
            |m: &mut CMsgClientGetClientAppListResponse| { &mut m.apps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bytes_available",
            |m: &CMsgClientGetClientAppListResponse| { &m.bytes_available },
            |m: &mut CMsgClientGetClientAppListResponse| { &mut m.bytes_available },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientGetClientAppListResponse>(
            "CMsgClientGetClientAppListResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientGetClientAppListResponse {
    const NAME: &'static str = "CMsgClientGetClientAppListResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.apps.push(is.read_message()?);
                },
                16 => {
                    self.bytes_available = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.bytes_available {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.apps {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.bytes_available {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetClientAppListResponse {
        CMsgClientGetClientAppListResponse::new()
    }

    fn clear(&mut self) {
        self.apps.clear();
        self.bytes_available = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetClientAppListResponse {
        static instance: CMsgClientGetClientAppListResponse = CMsgClientGetClientAppListResponse {
            apps: ::std::vec::Vec::new(),
            bytes_available: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientGetClientAppListResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientGetClientAppListResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientGetClientAppListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetClientAppListResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientGetClientAppListResponse`
pub mod cmsg_client_get_client_app_list_response {
    // @@protoc_insertion_point(message:CMsgClientGetClientAppListResponse.App)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct App {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.appid)
        pub appid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.category)
        pub category: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.app_type)
        pub app_type: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.favorite)
        pub favorite: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.installed)
        pub installed: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.auto_update)
        pub auto_update: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.bytes_downloaded)
        pub bytes_downloaded: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.bytes_needed)
        pub bytes_needed: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.bytes_download_rate)
        pub bytes_download_rate: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.download_paused)
        pub download_paused: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.num_downloading)
        pub num_downloading: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.num_paused)
        pub num_paused: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.changing)
        pub changing: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.available_on_platform)
        pub available_on_platform: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.dlcs)
        pub dlcs: ::std::vec::Vec<app::DLC>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientGetClientAppListResponse.App.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a App {
        fn default() -> &'a App {
            <App as ::protobuf::Message>::default_instance()
        }
    }

    impl App {
        pub fn new() -> App {
            ::std::default::Default::default()
        }

        // optional uint32 appid = 1;

        pub fn appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional string category = 2;

        pub fn category(&self) -> &str {
            match self.category.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_category(&mut self) {
            self.category = ::std::option::Option::None;
        }

        pub fn has_category(&self) -> bool {
            self.category.is_some()
        }

        // Param is passed by value, moved
        pub fn set_category(&mut self, v: ::std::string::String) {
            self.category = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_category(&mut self) -> &mut ::std::string::String {
            if self.category.is_none() {
                self.category = ::std::option::Option::Some(::std::string::String::new());
            }
            self.category.as_mut().unwrap()
        }

        // Take field
        pub fn take_category(&mut self) -> ::std::string::String {
            self.category.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string app_type = 10;

        pub fn app_type(&self) -> &str {
            match self.app_type.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_app_type(&mut self) {
            self.app_type = ::std::option::Option::None;
        }

        pub fn has_app_type(&self) -> bool {
            self.app_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_app_type(&mut self, v: ::std::string::String) {
            self.app_type = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_app_type(&mut self) -> &mut ::std::string::String {
            if self.app_type.is_none() {
                self.app_type = ::std::option::Option::Some(::std::string::String::new());
            }
            self.app_type.as_mut().unwrap()
        }

        // Take field
        pub fn take_app_type(&mut self) -> ::std::string::String {
            self.app_type.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool favorite = 3;

        pub fn favorite(&self) -> bool {
            self.favorite.unwrap_or(false)
        }

        pub fn clear_favorite(&mut self) {
            self.favorite = ::std::option::Option::None;
        }

        pub fn has_favorite(&self) -> bool {
            self.favorite.is_some()
        }

        // Param is passed by value, moved
        pub fn set_favorite(&mut self, v: bool) {
            self.favorite = ::std::option::Option::Some(v);
        }

        // optional bool installed = 4;

        pub fn installed(&self) -> bool {
            self.installed.unwrap_or(false)
        }

        pub fn clear_installed(&mut self) {
            self.installed = ::std::option::Option::None;
        }

        pub fn has_installed(&self) -> bool {
            self.installed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_installed(&mut self, v: bool) {
            self.installed = ::std::option::Option::Some(v);
        }

        // optional bool auto_update = 5;

        pub fn auto_update(&self) -> bool {
            self.auto_update.unwrap_or(false)
        }

        pub fn clear_auto_update(&mut self) {
            self.auto_update = ::std::option::Option::None;
        }

        pub fn has_auto_update(&self) -> bool {
            self.auto_update.is_some()
        }

        // Param is passed by value, moved
        pub fn set_auto_update(&mut self, v: bool) {
            self.auto_update = ::std::option::Option::Some(v);
        }

        // optional uint64 bytes_downloaded = 6;

        pub fn bytes_downloaded(&self) -> u64 {
            self.bytes_downloaded.unwrap_or(0)
        }

        pub fn clear_bytes_downloaded(&mut self) {
            self.bytes_downloaded = ::std::option::Option::None;
        }

        pub fn has_bytes_downloaded(&self) -> bool {
            self.bytes_downloaded.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bytes_downloaded(&mut self, v: u64) {
            self.bytes_downloaded = ::std::option::Option::Some(v);
        }

        // optional uint64 bytes_needed = 7;

        pub fn bytes_needed(&self) -> u64 {
            self.bytes_needed.unwrap_or(0)
        }

        pub fn clear_bytes_needed(&mut self) {
            self.bytes_needed = ::std::option::Option::None;
        }

        pub fn has_bytes_needed(&self) -> bool {
            self.bytes_needed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bytes_needed(&mut self, v: u64) {
            self.bytes_needed = ::std::option::Option::Some(v);
        }

        // optional uint32 bytes_download_rate = 8;

        pub fn bytes_download_rate(&self) -> u32 {
            self.bytes_download_rate.unwrap_or(0)
        }

        pub fn clear_bytes_download_rate(&mut self) {
            self.bytes_download_rate = ::std::option::Option::None;
        }

        pub fn has_bytes_download_rate(&self) -> bool {
            self.bytes_download_rate.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bytes_download_rate(&mut self, v: u32) {
            self.bytes_download_rate = ::std::option::Option::Some(v);
        }

        // optional bool download_paused = 11;

        pub fn download_paused(&self) -> bool {
            self.download_paused.unwrap_or(false)
        }

        pub fn clear_download_paused(&mut self) {
            self.download_paused = ::std::option::Option::None;
        }

        pub fn has_download_paused(&self) -> bool {
            self.download_paused.is_some()
        }

        // Param is passed by value, moved
        pub fn set_download_paused(&mut self, v: bool) {
            self.download_paused = ::std::option::Option::Some(v);
        }

        // optional uint32 num_downloading = 12;

        pub fn num_downloading(&self) -> u32 {
            self.num_downloading.unwrap_or(0)
        }

        pub fn clear_num_downloading(&mut self) {
            self.num_downloading = ::std::option::Option::None;
        }

        pub fn has_num_downloading(&self) -> bool {
            self.num_downloading.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_downloading(&mut self, v: u32) {
            self.num_downloading = ::std::option::Option::Some(v);
        }

        // optional uint32 num_paused = 13;

        pub fn num_paused(&self) -> u32 {
            self.num_paused.unwrap_or(0)
        }

        pub fn clear_num_paused(&mut self) {
            self.num_paused = ::std::option::Option::None;
        }

        pub fn has_num_paused(&self) -> bool {
            self.num_paused.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_paused(&mut self, v: u32) {
            self.num_paused = ::std::option::Option::Some(v);
        }

        // optional bool changing = 14;

        pub fn changing(&self) -> bool {
            self.changing.unwrap_or(false)
        }

        pub fn clear_changing(&mut self) {
            self.changing = ::std::option::Option::None;
        }

        pub fn has_changing(&self) -> bool {
            self.changing.is_some()
        }

        // Param is passed by value, moved
        pub fn set_changing(&mut self, v: bool) {
            self.changing = ::std::option::Option::Some(v);
        }

        // optional bool available_on_platform = 15;

        pub fn available_on_platform(&self) -> bool {
            self.available_on_platform.unwrap_or(false)
        }

        pub fn clear_available_on_platform(&mut self) {
            self.available_on_platform = ::std::option::Option::None;
        }

        pub fn has_available_on_platform(&self) -> bool {
            self.available_on_platform.is_some()
        }

        // Param is passed by value, moved
        pub fn set_available_on_platform(&mut self, v: bool) {
            self.available_on_platform = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(15);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "appid",
                |m: &App| { &m.appid },
                |m: &mut App| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "category",
                |m: &App| { &m.category },
                |m: &mut App| { &mut m.category },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "app_type",
                |m: &App| { &m.app_type },
                |m: &mut App| { &mut m.app_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "favorite",
                |m: &App| { &m.favorite },
                |m: &mut App| { &mut m.favorite },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "installed",
                |m: &App| { &m.installed },
                |m: &mut App| { &mut m.installed },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "auto_update",
                |m: &App| { &m.auto_update },
                |m: &mut App| { &mut m.auto_update },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "bytes_downloaded",
                |m: &App| { &m.bytes_downloaded },
                |m: &mut App| { &mut m.bytes_downloaded },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "bytes_needed",
                |m: &App| { &m.bytes_needed },
                |m: &mut App| { &mut m.bytes_needed },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "bytes_download_rate",
                |m: &App| { &m.bytes_download_rate },
                |m: &mut App| { &mut m.bytes_download_rate },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "download_paused",
                |m: &App| { &m.download_paused },
                |m: &mut App| { &mut m.download_paused },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "num_downloading",
                |m: &App| { &m.num_downloading },
                |m: &mut App| { &mut m.num_downloading },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "num_paused",
                |m: &App| { &m.num_paused },
                |m: &mut App| { &mut m.num_paused },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "changing",
                |m: &App| { &m.changing },
                |m: &mut App| { &mut m.changing },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "available_on_platform",
                |m: &App| { &m.available_on_platform },
                |m: &mut App| { &mut m.available_on_platform },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "dlcs",
                |m: &App| { &m.dlcs },
                |m: &mut App| { &mut m.dlcs },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<App>(
                "CMsgClientGetClientAppListResponse.App",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for App {
        const NAME: &'static str = "App";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.category = ::std::option::Option::Some(is.read_string()?);
                    },
                    82 => {
                        self.app_type = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.favorite = ::std::option::Option::Some(is.read_bool()?);
                    },
                    32 => {
                        self.installed = ::std::option::Option::Some(is.read_bool()?);
                    },
                    40 => {
                        self.auto_update = ::std::option::Option::Some(is.read_bool()?);
                    },
                    48 => {
                        self.bytes_downloaded = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    56 => {
                        self.bytes_needed = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    64 => {
                        self.bytes_download_rate = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    88 => {
                        self.download_paused = ::std::option::Option::Some(is.read_bool()?);
                    },
                    96 => {
                        self.num_downloading = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    104 => {
                        self.num_paused = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    112 => {
                        self.changing = ::std::option::Option::Some(is.read_bool()?);
                    },
                    120 => {
                        self.available_on_platform = ::std::option::Option::Some(is.read_bool()?);
                    },
                    74 => {
                        self.dlcs.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.appid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.category.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.app_type.as_ref() {
                my_size += ::protobuf::rt::string_size(10, &v);
            }
            if let Some(v) = self.favorite {
                my_size += 1 + 1;
            }
            if let Some(v) = self.installed {
                my_size += 1 + 1;
            }
            if let Some(v) = self.auto_update {
                my_size += 1 + 1;
            }
            if let Some(v) = self.bytes_downloaded {
                my_size += ::protobuf::rt::uint64_size(6, v);
            }
            if let Some(v) = self.bytes_needed {
                my_size += ::protobuf::rt::uint64_size(7, v);
            }
            if let Some(v) = self.bytes_download_rate {
                my_size += ::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.download_paused {
                my_size += 1 + 1;
            }
            if let Some(v) = self.num_downloading {
                my_size += ::protobuf::rt::uint32_size(12, v);
            }
            if let Some(v) = self.num_paused {
                my_size += ::protobuf::rt::uint32_size(13, v);
            }
            if let Some(v) = self.changing {
                my_size += 1 + 1;
            }
            if let Some(v) = self.available_on_platform {
                my_size += 1 + 1;
            }
            for value in &self.dlcs {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.appid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.category.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.app_type.as_ref() {
                os.write_string(10, v)?;
            }
            if let Some(v) = self.favorite {
                os.write_bool(3, v)?;
            }
            if let Some(v) = self.installed {
                os.write_bool(4, v)?;
            }
            if let Some(v) = self.auto_update {
                os.write_bool(5, v)?;
            }
            if let Some(v) = self.bytes_downloaded {
                os.write_uint64(6, v)?;
            }
            if let Some(v) = self.bytes_needed {
                os.write_uint64(7, v)?;
            }
            if let Some(v) = self.bytes_download_rate {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.download_paused {
                os.write_bool(11, v)?;
            }
            if let Some(v) = self.num_downloading {
                os.write_uint32(12, v)?;
            }
            if let Some(v) = self.num_paused {
                os.write_uint32(13, v)?;
            }
            if let Some(v) = self.changing {
                os.write_bool(14, v)?;
            }
            if let Some(v) = self.available_on_platform {
                os.write_bool(15, v)?;
            }
            for v in &self.dlcs {
                ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> App {
            App::new()
        }

        fn clear(&mut self) {
            self.appid = ::std::option::Option::None;
            self.category = ::std::option::Option::None;
            self.app_type = ::std::option::Option::None;
            self.favorite = ::std::option::Option::None;
            self.installed = ::std::option::Option::None;
            self.auto_update = ::std::option::Option::None;
            self.bytes_downloaded = ::std::option::Option::None;
            self.bytes_needed = ::std::option::Option::None;
            self.bytes_download_rate = ::std::option::Option::None;
            self.download_paused = ::std::option::Option::None;
            self.num_downloading = ::std::option::Option::None;
            self.num_paused = ::std::option::Option::None;
            self.changing = ::std::option::Option::None;
            self.available_on_platform = ::std::option::Option::None;
            self.dlcs.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static App {
            static instance: App = App {
                appid: ::std::option::Option::None,
                category: ::std::option::Option::None,
                app_type: ::std::option::Option::None,
                favorite: ::std::option::Option::None,
                installed: ::std::option::Option::None,
                auto_update: ::std::option::Option::None,
                bytes_downloaded: ::std::option::Option::None,
                bytes_needed: ::std::option::Option::None,
                bytes_download_rate: ::std::option::Option::None,
                download_paused: ::std::option::Option::None,
                num_downloading: ::std::option::Option::None,
                num_paused: ::std::option::Option::None,
                changing: ::std::option::Option::None,
                available_on_platform: ::std::option::Option::None,
                dlcs: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for App {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientGetClientAppListResponse.App").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for App {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for App {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `App`
    pub mod app {
        // @@protoc_insertion_point(message:CMsgClientGetClientAppListResponse.App.DLC)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct DLC {
            // message fields
            // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.DLC.appid)
            pub appid: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgClientGetClientAppListResponse.App.DLC.installed)
            pub installed: ::std::option::Option<bool>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgClientGetClientAppListResponse.App.DLC.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a DLC {
            fn default() -> &'a DLC {
                <DLC as ::protobuf::Message>::default_instance()
            }
        }

        impl DLC {
            pub fn new() -> DLC {
                ::std::default::Default::default()
            }

            // optional uint32 appid = 1;

            pub fn appid(&self) -> u32 {
                self.appid.unwrap_or(0)
            }

            pub fn clear_appid(&mut self) {
                self.appid = ::std::option::Option::None;
            }

            pub fn has_appid(&self) -> bool {
                self.appid.is_some()
            }

            // Param is passed by value, moved
            pub fn set_appid(&mut self, v: u32) {
                self.appid = ::std::option::Option::Some(v);
            }

            // optional bool installed = 2;

            pub fn installed(&self) -> bool {
                self.installed.unwrap_or(false)
            }

            pub fn clear_installed(&mut self) {
                self.installed = ::std::option::Option::None;
            }

            pub fn has_installed(&self) -> bool {
                self.installed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_installed(&mut self, v: bool) {
                self.installed = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "appid",
                    |m: &DLC| { &m.appid },
                    |m: &mut DLC| { &mut m.appid },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "installed",
                    |m: &DLC| { &m.installed },
                    |m: &mut DLC| { &mut m.installed },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DLC>(
                    "CMsgClientGetClientAppListResponse.App.DLC",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for DLC {
            const NAME: &'static str = "DLC";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.appid = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.installed = ::std::option::Option::Some(is.read_bool()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.appid {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.installed {
                    my_size += 1 + 1;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.appid {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.installed {
                    os.write_bool(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> DLC {
                DLC::new()
            }

            fn clear(&mut self) {
                self.appid = ::std::option::Option::None;
                self.installed = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static DLC {
                static instance: DLC = DLC {
                    appid: ::std::option::Option::None,
                    installed: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for DLC {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CMsgClientGetClientAppListResponse.App.DLC").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for DLC {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for DLC {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientInstallClientApp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientInstallClientApp {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientInstallClientApp.appid)
    pub appid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientInstallClientApp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientInstallClientApp {
    fn default() -> &'a CMsgClientInstallClientApp {
        <CMsgClientInstallClientApp as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientInstallClientApp {
    pub fn new() -> CMsgClientInstallClientApp {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CMsgClientInstallClientApp| { &m.appid },
            |m: &mut CMsgClientInstallClientApp| { &mut m.appid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientInstallClientApp>(
            "CMsgClientInstallClientApp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientInstallClientApp {
    const NAME: &'static str = "CMsgClientInstallClientApp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientInstallClientApp {
        CMsgClientInstallClientApp::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientInstallClientApp {
        static instance: CMsgClientInstallClientApp = CMsgClientInstallClientApp {
            appid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientInstallClientApp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientInstallClientApp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientInstallClientApp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientInstallClientApp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientInstallClientAppResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientInstallClientAppResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientInstallClientAppResponse.result)
    pub result: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientInstallClientAppResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientInstallClientAppResponse {
    fn default() -> &'a CMsgClientInstallClientAppResponse {
        <CMsgClientInstallClientAppResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientInstallClientAppResponse {
    pub fn new() -> CMsgClientInstallClientAppResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientInstallClientAppResponse| { &m.result },
            |m: &mut CMsgClientInstallClientAppResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientInstallClientAppResponse>(
            "CMsgClientInstallClientAppResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientInstallClientAppResponse {
    const NAME: &'static str = "CMsgClientInstallClientAppResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientInstallClientAppResponse {
        CMsgClientInstallClientAppResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientInstallClientAppResponse {
        static instance: CMsgClientInstallClientAppResponse = CMsgClientInstallClientAppResponse {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientInstallClientAppResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientInstallClientAppResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientInstallClientAppResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientInstallClientAppResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUninstallClientApp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUninstallClientApp {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUninstallClientApp.appid)
    pub appid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUninstallClientApp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUninstallClientApp {
    fn default() -> &'a CMsgClientUninstallClientApp {
        <CMsgClientUninstallClientApp as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUninstallClientApp {
    pub fn new() -> CMsgClientUninstallClientApp {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CMsgClientUninstallClientApp| { &m.appid },
            |m: &mut CMsgClientUninstallClientApp| { &mut m.appid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUninstallClientApp>(
            "CMsgClientUninstallClientApp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUninstallClientApp {
    const NAME: &'static str = "CMsgClientUninstallClientApp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUninstallClientApp {
        CMsgClientUninstallClientApp::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUninstallClientApp {
        static instance: CMsgClientUninstallClientApp = CMsgClientUninstallClientApp {
            appid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUninstallClientApp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUninstallClientApp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUninstallClientApp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUninstallClientApp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUninstallClientAppResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUninstallClientAppResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUninstallClientAppResponse.result)
    pub result: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUninstallClientAppResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUninstallClientAppResponse {
    fn default() -> &'a CMsgClientUninstallClientAppResponse {
        <CMsgClientUninstallClientAppResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUninstallClientAppResponse {
    pub fn new() -> CMsgClientUninstallClientAppResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientUninstallClientAppResponse| { &m.result },
            |m: &mut CMsgClientUninstallClientAppResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUninstallClientAppResponse>(
            "CMsgClientUninstallClientAppResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUninstallClientAppResponse {
    const NAME: &'static str = "CMsgClientUninstallClientAppResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUninstallClientAppResponse {
        CMsgClientUninstallClientAppResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUninstallClientAppResponse {
        static instance: CMsgClientUninstallClientAppResponse = CMsgClientUninstallClientAppResponse {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUninstallClientAppResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUninstallClientAppResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUninstallClientAppResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUninstallClientAppResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientSetClientAppUpdateState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientSetClientAppUpdateState {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientSetClientAppUpdateState.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientSetClientAppUpdateState.update)
    pub update: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientSetClientAppUpdateState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientSetClientAppUpdateState {
    fn default() -> &'a CMsgClientSetClientAppUpdateState {
        <CMsgClientSetClientAppUpdateState as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientSetClientAppUpdateState {
    pub fn new() -> CMsgClientSetClientAppUpdateState {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional bool update = 2;

    pub fn update(&self) -> bool {
        self.update.unwrap_or(false)
    }

    pub fn clear_update(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_update(&self) -> bool {
        self.update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update(&mut self, v: bool) {
        self.update = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CMsgClientSetClientAppUpdateState| { &m.appid },
            |m: &mut CMsgClientSetClientAppUpdateState| { &mut m.appid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "update",
            |m: &CMsgClientSetClientAppUpdateState| { &m.update },
            |m: &mut CMsgClientSetClientAppUpdateState| { &mut m.update },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientSetClientAppUpdateState>(
            "CMsgClientSetClientAppUpdateState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientSetClientAppUpdateState {
    const NAME: &'static str = "CMsgClientSetClientAppUpdateState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.update = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.update {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.update {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientSetClientAppUpdateState {
        CMsgClientSetClientAppUpdateState::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.update = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientSetClientAppUpdateState {
        static instance: CMsgClientSetClientAppUpdateState = CMsgClientSetClientAppUpdateState {
            appid: ::std::option::Option::None,
            update: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientSetClientAppUpdateState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientSetClientAppUpdateState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientSetClientAppUpdateState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientSetClientAppUpdateState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientSetClientAppUpdateStateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientSetClientAppUpdateStateResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientSetClientAppUpdateStateResponse.result)
    pub result: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientSetClientAppUpdateStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientSetClientAppUpdateStateResponse {
    fn default() -> &'a CMsgClientSetClientAppUpdateStateResponse {
        <CMsgClientSetClientAppUpdateStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientSetClientAppUpdateStateResponse {
    pub fn new() -> CMsgClientSetClientAppUpdateStateResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgClientSetClientAppUpdateStateResponse| { &m.result },
            |m: &mut CMsgClientSetClientAppUpdateStateResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientSetClientAppUpdateStateResponse>(
            "CMsgClientSetClientAppUpdateStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientSetClientAppUpdateStateResponse {
    const NAME: &'static str = "CMsgClientSetClientAppUpdateStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientSetClientAppUpdateStateResponse {
        CMsgClientSetClientAppUpdateStateResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientSetClientAppUpdateStateResponse {
        static instance: CMsgClientSetClientAppUpdateStateResponse = CMsgClientSetClientAppUpdateStateResponse {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientSetClientAppUpdateStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientSetClientAppUpdateStateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientSetClientAppUpdateStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientSetClientAppUpdateStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUFSUploadFileRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUFSUploadFileRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUFSUploadFileRequest.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUFSUploadFileRequest.file_size)
    pub file_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUFSUploadFileRequest.raw_file_size)
    pub raw_file_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUFSUploadFileRequest.sha_file)
    pub sha_file: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientUFSUploadFileRequest.time_stamp)
    pub time_stamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUFSUploadFileRequest.file_name)
    pub file_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUFSUploadFileRequest.platforms_to_sync_deprecated)
    pub platforms_to_sync_deprecated: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUFSUploadFileRequest.platforms_to_sync)
    pub platforms_to_sync: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUFSUploadFileRequest.cell_id)
    pub cell_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUFSUploadFileRequest.can_encrypt)
    pub can_encrypt: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUFSUploadFileRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSUploadFileRequest {
    fn default() -> &'a CMsgClientUFSUploadFileRequest {
        <CMsgClientUFSUploadFileRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSUploadFileRequest {
    pub fn new() -> CMsgClientUFSUploadFileRequest {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 file_size = 2;

    pub fn file_size(&self) -> u32 {
        self.file_size.unwrap_or(0)
    }

    pub fn clear_file_size(&mut self) {
        self.file_size = ::std::option::Option::None;
    }

    pub fn has_file_size(&self) -> bool {
        self.file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: u32) {
        self.file_size = ::std::option::Option::Some(v);
    }

    // optional uint32 raw_file_size = 3;

    pub fn raw_file_size(&self) -> u32 {
        self.raw_file_size.unwrap_or(0)
    }

    pub fn clear_raw_file_size(&mut self) {
        self.raw_file_size = ::std::option::Option::None;
    }

    pub fn has_raw_file_size(&self) -> bool {
        self.raw_file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_file_size(&mut self, v: u32) {
        self.raw_file_size = ::std::option::Option::Some(v);
    }

    // optional bytes sha_file = 4;

    pub fn sha_file(&self) -> &[u8] {
        match self.sha_file.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sha_file(&mut self) {
        self.sha_file = ::std::option::Option::None;
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 time_stamp = 5;

    pub fn time_stamp(&self) -> u64 {
        self.time_stamp.unwrap_or(0)
    }

    pub fn clear_time_stamp(&mut self) {
        self.time_stamp = ::std::option::Option::None;
    }

    pub fn has_time_stamp(&self) -> bool {
        self.time_stamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_stamp(&mut self, v: u64) {
        self.time_stamp = ::std::option::Option::Some(v);
    }

    // optional string file_name = 6;

    pub fn file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_name(&mut self) {
        self.file_name = ::std::option::Option::None;
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 platforms_to_sync_deprecated = 7;

    pub fn platforms_to_sync_deprecated(&self) -> u32 {
        self.platforms_to_sync_deprecated.unwrap_or(0)
    }

    pub fn clear_platforms_to_sync_deprecated(&mut self) {
        self.platforms_to_sync_deprecated = ::std::option::Option::None;
    }

    pub fn has_platforms_to_sync_deprecated(&self) -> bool {
        self.platforms_to_sync_deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platforms_to_sync_deprecated(&mut self, v: u32) {
        self.platforms_to_sync_deprecated = ::std::option::Option::Some(v);
    }

    // optional uint32 platforms_to_sync = 8;

    pub fn platforms_to_sync(&self) -> u32 {
        self.platforms_to_sync.unwrap_or(4294967295u32)
    }

    pub fn clear_platforms_to_sync(&mut self) {
        self.platforms_to_sync = ::std::option::Option::None;
    }

    pub fn has_platforms_to_sync(&self) -> bool {
        self.platforms_to_sync.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platforms_to_sync(&mut self, v: u32) {
        self.platforms_to_sync = ::std::option::Option::Some(v);
    }

    // optional uint32 cell_id = 9;

    pub fn cell_id(&self) -> u32 {
        self.cell_id.unwrap_or(0)
    }

    pub fn clear_cell_id(&mut self) {
        self.cell_id = ::std::option::Option::None;
    }

    pub fn has_cell_id(&self) -> bool {
        self.cell_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id(&mut self, v: u32) {
        self.cell_id = ::std::option::Option::Some(v);
    }

    // optional bool can_encrypt = 10;

    pub fn can_encrypt(&self) -> bool {
        self.can_encrypt.unwrap_or(false)
    }

    pub fn clear_can_encrypt(&mut self) {
        self.can_encrypt = ::std::option::Option::None;
    }

    pub fn has_can_encrypt(&self) -> bool {
        self.can_encrypt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_encrypt(&mut self, v: bool) {
        self.can_encrypt = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientUFSUploadFileRequest| { &m.app_id },
            |m: &mut CMsgClientUFSUploadFileRequest| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_size",
            |m: &CMsgClientUFSUploadFileRequest| { &m.file_size },
            |m: &mut CMsgClientUFSUploadFileRequest| { &mut m.file_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "raw_file_size",
            |m: &CMsgClientUFSUploadFileRequest| { &m.raw_file_size },
            |m: &mut CMsgClientUFSUploadFileRequest| { &mut m.raw_file_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sha_file",
            |m: &CMsgClientUFSUploadFileRequest| { &m.sha_file },
            |m: &mut CMsgClientUFSUploadFileRequest| { &mut m.sha_file },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_stamp",
            |m: &CMsgClientUFSUploadFileRequest| { &m.time_stamp },
            |m: &mut CMsgClientUFSUploadFileRequest| { &mut m.time_stamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_name",
            |m: &CMsgClientUFSUploadFileRequest| { &m.file_name },
            |m: &mut CMsgClientUFSUploadFileRequest| { &mut m.file_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "platforms_to_sync_deprecated",
            |m: &CMsgClientUFSUploadFileRequest| { &m.platforms_to_sync_deprecated },
            |m: &mut CMsgClientUFSUploadFileRequest| { &mut m.platforms_to_sync_deprecated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "platforms_to_sync",
            |m: &CMsgClientUFSUploadFileRequest| { &m.platforms_to_sync },
            |m: &mut CMsgClientUFSUploadFileRequest| { &mut m.platforms_to_sync },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cell_id",
            |m: &CMsgClientUFSUploadFileRequest| { &m.cell_id },
            |m: &mut CMsgClientUFSUploadFileRequest| { &mut m.cell_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "can_encrypt",
            |m: &CMsgClientUFSUploadFileRequest| { &m.can_encrypt },
            |m: &mut CMsgClientUFSUploadFileRequest| { &mut m.can_encrypt },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUFSUploadFileRequest>(
            "CMsgClientUFSUploadFileRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUFSUploadFileRequest {
    const NAME: &'static str = "CMsgClientUFSUploadFileRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.file_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.raw_file_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.sha_file = ::std::option::Option::Some(is.read_bytes()?);
                },
                40 => {
                    self.time_stamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                50 => {
                    self.file_name = ::std::option::Option::Some(is.read_string()?);
                },
                56 => {
                    self.platforms_to_sync_deprecated = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.platforms_to_sync = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.cell_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.can_encrypt = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.file_size {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.raw_file_size {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.sha_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.time_stamp {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.platforms_to_sync_deprecated {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.platforms_to_sync {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.cell_id {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.can_encrypt {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.file_size {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.raw_file_size {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.sha_file.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.time_stamp {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.file_name.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.platforms_to_sync_deprecated {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.platforms_to_sync {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.cell_id {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.can_encrypt {
            os.write_bool(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUFSUploadFileRequest {
        CMsgClientUFSUploadFileRequest::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.file_size = ::std::option::Option::None;
        self.raw_file_size = ::std::option::Option::None;
        self.sha_file = ::std::option::Option::None;
        self.time_stamp = ::std::option::Option::None;
        self.file_name = ::std::option::Option::None;
        self.platforms_to_sync_deprecated = ::std::option::Option::None;
        self.platforms_to_sync = ::std::option::Option::None;
        self.cell_id = ::std::option::Option::None;
        self.can_encrypt = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUFSUploadFileRequest {
        static instance: CMsgClientUFSUploadFileRequest = CMsgClientUFSUploadFileRequest {
            app_id: ::std::option::Option::None,
            file_size: ::std::option::Option::None,
            raw_file_size: ::std::option::Option::None,
            sha_file: ::std::option::Option::None,
            time_stamp: ::std::option::Option::None,
            file_name: ::std::option::Option::None,
            platforms_to_sync_deprecated: ::std::option::Option::None,
            platforms_to_sync: ::std::option::Option::None,
            cell_id: ::std::option::Option::None,
            can_encrypt: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUFSUploadFileRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUFSUploadFileRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUFSUploadFileRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSUploadFileRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUFSUploadFileResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUFSUploadFileResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUFSUploadFileResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUFSUploadFileResponse.sha_file)
    pub sha_file: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientUFSUploadFileResponse.use_http)
    pub use_http: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUFSUploadFileResponse.http_host)
    pub http_host: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUFSUploadFileResponse.http_url)
    pub http_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUFSUploadFileResponse.kv_headers)
    pub kv_headers: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientUFSUploadFileResponse.use_https)
    pub use_https: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUFSUploadFileResponse.encrypt_file)
    pub encrypt_file: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUFSUploadFileResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSUploadFileResponse {
    fn default() -> &'a CMsgClientUFSUploadFileResponse {
        <CMsgClientUFSUploadFileResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSUploadFileResponse {
    pub fn new() -> CMsgClientUFSUploadFileResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional bytes sha_file = 2;

    pub fn sha_file(&self) -> &[u8] {
        match self.sha_file.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sha_file(&mut self) {
        self.sha_file = ::std::option::Option::None;
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool use_http = 3;

    pub fn use_http(&self) -> bool {
        self.use_http.unwrap_or(false)
    }

    pub fn clear_use_http(&mut self) {
        self.use_http = ::std::option::Option::None;
    }

    pub fn has_use_http(&self) -> bool {
        self.use_http.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_http(&mut self, v: bool) {
        self.use_http = ::std::option::Option::Some(v);
    }

    // optional string http_host = 4;

    pub fn http_host(&self) -> &str {
        match self.http_host.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_http_host(&mut self) {
        self.http_host = ::std::option::Option::None;
    }

    pub fn has_http_host(&self) -> bool {
        self.http_host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http_host(&mut self, v: ::std::string::String) {
        self.http_host = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http_host(&mut self) -> &mut ::std::string::String {
        if self.http_host.is_none() {
            self.http_host = ::std::option::Option::Some(::std::string::String::new());
        }
        self.http_host.as_mut().unwrap()
    }

    // Take field
    pub fn take_http_host(&mut self) -> ::std::string::String {
        self.http_host.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string http_url = 5;

    pub fn http_url(&self) -> &str {
        match self.http_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_http_url(&mut self) {
        self.http_url = ::std::option::Option::None;
    }

    pub fn has_http_url(&self) -> bool {
        self.http_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http_url(&mut self, v: ::std::string::String) {
        self.http_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http_url(&mut self) -> &mut ::std::string::String {
        if self.http_url.is_none() {
            self.http_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.http_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_http_url(&mut self) -> ::std::string::String {
        self.http_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes kv_headers = 6;

    pub fn kv_headers(&self) -> &[u8] {
        match self.kv_headers.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_kv_headers(&mut self) {
        self.kv_headers = ::std::option::Option::None;
    }

    pub fn has_kv_headers(&self) -> bool {
        self.kv_headers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kv_headers(&mut self, v: ::std::vec::Vec<u8>) {
        self.kv_headers = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kv_headers(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.kv_headers.is_none() {
            self.kv_headers = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.kv_headers.as_mut().unwrap()
    }

    // Take field
    pub fn take_kv_headers(&mut self) -> ::std::vec::Vec<u8> {
        self.kv_headers.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool use_https = 7;

    pub fn use_https(&self) -> bool {
        self.use_https.unwrap_or(false)
    }

    pub fn clear_use_https(&mut self) {
        self.use_https = ::std::option::Option::None;
    }

    pub fn has_use_https(&self) -> bool {
        self.use_https.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_https(&mut self, v: bool) {
        self.use_https = ::std::option::Option::Some(v);
    }

    // optional bool encrypt_file = 8;

    pub fn encrypt_file(&self) -> bool {
        self.encrypt_file.unwrap_or(false)
    }

    pub fn clear_encrypt_file(&mut self) {
        self.encrypt_file = ::std::option::Option::None;
    }

    pub fn has_encrypt_file(&self) -> bool {
        self.encrypt_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encrypt_file(&mut self, v: bool) {
        self.encrypt_file = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientUFSUploadFileResponse| { &m.eresult },
            |m: &mut CMsgClientUFSUploadFileResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sha_file",
            |m: &CMsgClientUFSUploadFileResponse| { &m.sha_file },
            |m: &mut CMsgClientUFSUploadFileResponse| { &mut m.sha_file },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "use_http",
            |m: &CMsgClientUFSUploadFileResponse| { &m.use_http },
            |m: &mut CMsgClientUFSUploadFileResponse| { &mut m.use_http },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "http_host",
            |m: &CMsgClientUFSUploadFileResponse| { &m.http_host },
            |m: &mut CMsgClientUFSUploadFileResponse| { &mut m.http_host },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "http_url",
            |m: &CMsgClientUFSUploadFileResponse| { &m.http_url },
            |m: &mut CMsgClientUFSUploadFileResponse| { &mut m.http_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kv_headers",
            |m: &CMsgClientUFSUploadFileResponse| { &m.kv_headers },
            |m: &mut CMsgClientUFSUploadFileResponse| { &mut m.kv_headers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "use_https",
            |m: &CMsgClientUFSUploadFileResponse| { &m.use_https },
            |m: &mut CMsgClientUFSUploadFileResponse| { &mut m.use_https },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "encrypt_file",
            |m: &CMsgClientUFSUploadFileResponse| { &m.encrypt_file },
            |m: &mut CMsgClientUFSUploadFileResponse| { &mut m.encrypt_file },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUFSUploadFileResponse>(
            "CMsgClientUFSUploadFileResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUFSUploadFileResponse {
    const NAME: &'static str = "CMsgClientUFSUploadFileResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.sha_file = ::std::option::Option::Some(is.read_bytes()?);
                },
                24 => {
                    self.use_http = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    self.http_host = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.http_url = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.kv_headers = ::std::option::Option::Some(is.read_bytes()?);
                },
                56 => {
                    self.use_https = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.encrypt_file = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.sha_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.use_http {
            my_size += 1 + 1;
        }
        if let Some(v) = self.http_host.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.http_url.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.kv_headers.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.use_https {
            my_size += 1 + 1;
        }
        if let Some(v) = self.encrypt_file {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.sha_file.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.use_http {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.http_host.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.http_url.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.kv_headers.as_ref() {
            os.write_bytes(6, v)?;
        }
        if let Some(v) = self.use_https {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.encrypt_file {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUFSUploadFileResponse {
        CMsgClientUFSUploadFileResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.sha_file = ::std::option::Option::None;
        self.use_http = ::std::option::Option::None;
        self.http_host = ::std::option::Option::None;
        self.http_url = ::std::option::Option::None;
        self.kv_headers = ::std::option::Option::None;
        self.use_https = ::std::option::Option::None;
        self.encrypt_file = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUFSUploadFileResponse {
        static instance: CMsgClientUFSUploadFileResponse = CMsgClientUFSUploadFileResponse {
            eresult: ::std::option::Option::None,
            sha_file: ::std::option::Option::None,
            use_http: ::std::option::Option::None,
            http_host: ::std::option::Option::None,
            http_url: ::std::option::Option::None,
            kv_headers: ::std::option::Option::None,
            use_https: ::std::option::Option::None,
            encrypt_file: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUFSUploadFileResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUFSUploadFileResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUFSUploadFileResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSUploadFileResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUFSUploadCommit)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUFSUploadCommit {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUFSUploadCommit.files)
    pub files: ::std::vec::Vec<cmsg_client_ufsupload_commit::File>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUFSUploadCommit.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSUploadCommit {
    fn default() -> &'a CMsgClientUFSUploadCommit {
        <CMsgClientUFSUploadCommit as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSUploadCommit {
    pub fn new() -> CMsgClientUFSUploadCommit {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "files",
            |m: &CMsgClientUFSUploadCommit| { &m.files },
            |m: &mut CMsgClientUFSUploadCommit| { &mut m.files },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUFSUploadCommit>(
            "CMsgClientUFSUploadCommit",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUFSUploadCommit {
    const NAME: &'static str = "CMsgClientUFSUploadCommit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.files.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.files {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUFSUploadCommit {
        CMsgClientUFSUploadCommit::new()
    }

    fn clear(&mut self) {
        self.files.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUFSUploadCommit {
        static instance: CMsgClientUFSUploadCommit = CMsgClientUFSUploadCommit {
            files: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUFSUploadCommit {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUFSUploadCommit").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUFSUploadCommit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSUploadCommit {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientUFSUploadCommit`
pub mod cmsg_client_ufsupload_commit {
    // @@protoc_insertion_point(message:CMsgClientUFSUploadCommit.File)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct File {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientUFSUploadCommit.File.eresult)
        pub eresult: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientUFSUploadCommit.File.app_id)
        pub app_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientUFSUploadCommit.File.sha_file)
        pub sha_file: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:CMsgClientUFSUploadCommit.File.cub_file)
        pub cub_file: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientUFSUploadCommit.File.file_name)
        pub file_name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientUFSUploadCommit.File.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a File {
        fn default() -> &'a File {
            <File as ::protobuf::Message>::default_instance()
        }
    }

    impl File {
        pub fn new() -> File {
            ::std::default::Default::default()
        }

        // optional int32 eresult = 1;

        pub fn eresult(&self) -> i32 {
            self.eresult.unwrap_or(2i32)
        }

        pub fn clear_eresult(&mut self) {
            self.eresult = ::std::option::Option::None;
        }

        pub fn has_eresult(&self) -> bool {
            self.eresult.is_some()
        }

        // Param is passed by value, moved
        pub fn set_eresult(&mut self, v: i32) {
            self.eresult = ::std::option::Option::Some(v);
        }

        // optional uint32 app_id = 2;

        pub fn app_id(&self) -> u32 {
            self.app_id.unwrap_or(0)
        }

        pub fn clear_app_id(&mut self) {
            self.app_id = ::std::option::Option::None;
        }

        pub fn has_app_id(&self) -> bool {
            self.app_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_app_id(&mut self, v: u32) {
            self.app_id = ::std::option::Option::Some(v);
        }

        // optional bytes sha_file = 3;

        pub fn sha_file(&self) -> &[u8] {
            match self.sha_file.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_sha_file(&mut self) {
            self.sha_file = ::std::option::Option::None;
        }

        pub fn has_sha_file(&self) -> bool {
            self.sha_file.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
            self.sha_file = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_sha_file(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.sha_file.is_none() {
                self.sha_file = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.sha_file.as_mut().unwrap()
        }

        // Take field
        pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
            self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional uint32 cub_file = 4;

        pub fn cub_file(&self) -> u32 {
            self.cub_file.unwrap_or(0)
        }

        pub fn clear_cub_file(&mut self) {
            self.cub_file = ::std::option::Option::None;
        }

        pub fn has_cub_file(&self) -> bool {
            self.cub_file.is_some()
        }

        // Param is passed by value, moved
        pub fn set_cub_file(&mut self, v: u32) {
            self.cub_file = ::std::option::Option::Some(v);
        }

        // optional string file_name = 5;

        pub fn file_name(&self) -> &str {
            match self.file_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_file_name(&mut self) {
            self.file_name = ::std::option::Option::None;
        }

        pub fn has_file_name(&self) -> bool {
            self.file_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_file_name(&mut self, v: ::std::string::String) {
            self.file_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
            if self.file_name.is_none() {
                self.file_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.file_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_file_name(&mut self) -> ::std::string::String {
            self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "eresult",
                |m: &File| { &m.eresult },
                |m: &mut File| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "app_id",
                |m: &File| { &m.app_id },
                |m: &mut File| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sha_file",
                |m: &File| { &m.sha_file },
                |m: &mut File| { &mut m.sha_file },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "cub_file",
                |m: &File| { &m.cub_file },
                |m: &mut File| { &mut m.cub_file },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "file_name",
                |m: &File| { &m.file_name },
                |m: &mut File| { &mut m.file_name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<File>(
                "CMsgClientUFSUploadCommit.File",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for File {
        const NAME: &'static str = "File";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.eresult = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.sha_file = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    32 => {
                        self.cub_file = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    42 => {
                        self.file_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.eresult {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.app_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.sha_file.as_ref() {
                my_size += ::protobuf::rt::bytes_size(3, &v);
            }
            if let Some(v) = self.cub_file {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.file_name.as_ref() {
                my_size += ::protobuf::rt::string_size(5, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.eresult {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.app_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.sha_file.as_ref() {
                os.write_bytes(3, v)?;
            }
            if let Some(v) = self.cub_file {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.file_name.as_ref() {
                os.write_string(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> File {
            File::new()
        }

        fn clear(&mut self) {
            self.eresult = ::std::option::Option::None;
            self.app_id = ::std::option::Option::None;
            self.sha_file = ::std::option::Option::None;
            self.cub_file = ::std::option::Option::None;
            self.file_name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static File {
            static instance: File = File {
                eresult: ::std::option::Option::None,
                app_id: ::std::option::Option::None,
                sha_file: ::std::option::Option::None,
                cub_file: ::std::option::Option::None,
                file_name: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for File {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientUFSUploadCommit.File").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for File {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for File {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientUFSUploadCommitResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUFSUploadCommitResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUFSUploadCommitResponse.files)
    pub files: ::std::vec::Vec<cmsg_client_ufsupload_commit_response::File>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUFSUploadCommitResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSUploadCommitResponse {
    fn default() -> &'a CMsgClientUFSUploadCommitResponse {
        <CMsgClientUFSUploadCommitResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSUploadCommitResponse {
    pub fn new() -> CMsgClientUFSUploadCommitResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "files",
            |m: &CMsgClientUFSUploadCommitResponse| { &m.files },
            |m: &mut CMsgClientUFSUploadCommitResponse| { &mut m.files },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUFSUploadCommitResponse>(
            "CMsgClientUFSUploadCommitResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUFSUploadCommitResponse {
    const NAME: &'static str = "CMsgClientUFSUploadCommitResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.files.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.files {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUFSUploadCommitResponse {
        CMsgClientUFSUploadCommitResponse::new()
    }

    fn clear(&mut self) {
        self.files.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUFSUploadCommitResponse {
        static instance: CMsgClientUFSUploadCommitResponse = CMsgClientUFSUploadCommitResponse {
            files: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUFSUploadCommitResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUFSUploadCommitResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUFSUploadCommitResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSUploadCommitResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientUFSUploadCommitResponse`
pub mod cmsg_client_ufsupload_commit_response {
    // @@protoc_insertion_point(message:CMsgClientUFSUploadCommitResponse.File)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct File {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientUFSUploadCommitResponse.File.eresult)
        pub eresult: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientUFSUploadCommitResponse.File.app_id)
        pub app_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientUFSUploadCommitResponse.File.sha_file)
        pub sha_file: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientUFSUploadCommitResponse.File.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a File {
        fn default() -> &'a File {
            <File as ::protobuf::Message>::default_instance()
        }
    }

    impl File {
        pub fn new() -> File {
            ::std::default::Default::default()
        }

        // optional int32 eresult = 1;

        pub fn eresult(&self) -> i32 {
            self.eresult.unwrap_or(2i32)
        }

        pub fn clear_eresult(&mut self) {
            self.eresult = ::std::option::Option::None;
        }

        pub fn has_eresult(&self) -> bool {
            self.eresult.is_some()
        }

        // Param is passed by value, moved
        pub fn set_eresult(&mut self, v: i32) {
            self.eresult = ::std::option::Option::Some(v);
        }

        // optional uint32 app_id = 2;

        pub fn app_id(&self) -> u32 {
            self.app_id.unwrap_or(0)
        }

        pub fn clear_app_id(&mut self) {
            self.app_id = ::std::option::Option::None;
        }

        pub fn has_app_id(&self) -> bool {
            self.app_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_app_id(&mut self, v: u32) {
            self.app_id = ::std::option::Option::Some(v);
        }

        // optional bytes sha_file = 3;

        pub fn sha_file(&self) -> &[u8] {
            match self.sha_file.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_sha_file(&mut self) {
            self.sha_file = ::std::option::Option::None;
        }

        pub fn has_sha_file(&self) -> bool {
            self.sha_file.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
            self.sha_file = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_sha_file(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.sha_file.is_none() {
                self.sha_file = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.sha_file.as_mut().unwrap()
        }

        // Take field
        pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
            self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "eresult",
                |m: &File| { &m.eresult },
                |m: &mut File| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "app_id",
                |m: &File| { &m.app_id },
                |m: &mut File| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sha_file",
                |m: &File| { &m.sha_file },
                |m: &mut File| { &mut m.sha_file },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<File>(
                "CMsgClientUFSUploadCommitResponse.File",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for File {
        const NAME: &'static str = "File";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.eresult = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.sha_file = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.eresult {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.app_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.sha_file.as_ref() {
                my_size += ::protobuf::rt::bytes_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.eresult {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.app_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.sha_file.as_ref() {
                os.write_bytes(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> File {
            File::new()
        }

        fn clear(&mut self) {
            self.eresult = ::std::option::Option::None;
            self.app_id = ::std::option::Option::None;
            self.sha_file = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static File {
            static instance: File = File {
                eresult: ::std::option::Option::None,
                app_id: ::std::option::Option::None,
                sha_file: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for File {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientUFSUploadCommitResponse.File").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for File {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for File {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientUFSFileChunk)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUFSFileChunk {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUFSFileChunk.sha_file)
    pub sha_file: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientUFSFileChunk.file_start)
    pub file_start: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUFSFileChunk.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUFSFileChunk.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSFileChunk {
    fn default() -> &'a CMsgClientUFSFileChunk {
        <CMsgClientUFSFileChunk as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSFileChunk {
    pub fn new() -> CMsgClientUFSFileChunk {
        ::std::default::Default::default()
    }

    // optional bytes sha_file = 1;

    pub fn sha_file(&self) -> &[u8] {
        match self.sha_file.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sha_file(&mut self) {
        self.sha_file = ::std::option::Option::None;
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 file_start = 2;

    pub fn file_start(&self) -> u32 {
        self.file_start.unwrap_or(0)
    }

    pub fn clear_file_start(&mut self) {
        self.file_start = ::std::option::Option::None;
    }

    pub fn has_file_start(&self) -> bool {
        self.file_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_start(&mut self, v: u32) {
        self.file_start = ::std::option::Option::Some(v);
    }

    // optional bytes data = 3;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sha_file",
            |m: &CMsgClientUFSFileChunk| { &m.sha_file },
            |m: &mut CMsgClientUFSFileChunk| { &mut m.sha_file },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_start",
            |m: &CMsgClientUFSFileChunk| { &m.file_start },
            |m: &mut CMsgClientUFSFileChunk| { &mut m.file_start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &CMsgClientUFSFileChunk| { &m.data },
            |m: &mut CMsgClientUFSFileChunk| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUFSFileChunk>(
            "CMsgClientUFSFileChunk",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUFSFileChunk {
    const NAME: &'static str = "CMsgClientUFSFileChunk";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.sha_file = ::std::option::Option::Some(is.read_bytes()?);
                },
                16 => {
                    self.file_start = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sha_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.file_start {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.sha_file.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.file_start {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUFSFileChunk {
        CMsgClientUFSFileChunk::new()
    }

    fn clear(&mut self) {
        self.sha_file = ::std::option::Option::None;
        self.file_start = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUFSFileChunk {
        static instance: CMsgClientUFSFileChunk = CMsgClientUFSFileChunk {
            sha_file: ::std::option::Option::None,
            file_start: ::std::option::Option::None,
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUFSFileChunk {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUFSFileChunk").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUFSFileChunk {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSFileChunk {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUFSTransferHeartbeat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUFSTransferHeartbeat {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUFSTransferHeartbeat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSTransferHeartbeat {
    fn default() -> &'a CMsgClientUFSTransferHeartbeat {
        <CMsgClientUFSTransferHeartbeat as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSTransferHeartbeat {
    pub fn new() -> CMsgClientUFSTransferHeartbeat {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUFSTransferHeartbeat>(
            "CMsgClientUFSTransferHeartbeat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUFSTransferHeartbeat {
    const NAME: &'static str = "CMsgClientUFSTransferHeartbeat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUFSTransferHeartbeat {
        CMsgClientUFSTransferHeartbeat::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUFSTransferHeartbeat {
        static instance: CMsgClientUFSTransferHeartbeat = CMsgClientUFSTransferHeartbeat {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUFSTransferHeartbeat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUFSTransferHeartbeat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUFSTransferHeartbeat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSTransferHeartbeat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUFSUploadFileFinished)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUFSUploadFileFinished {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUFSUploadFileFinished.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUFSUploadFileFinished.sha_file)
    pub sha_file: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUFSUploadFileFinished.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSUploadFileFinished {
    fn default() -> &'a CMsgClientUFSUploadFileFinished {
        <CMsgClientUFSUploadFileFinished as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSUploadFileFinished {
    pub fn new() -> CMsgClientUFSUploadFileFinished {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional bytes sha_file = 2;

    pub fn sha_file(&self) -> &[u8] {
        match self.sha_file.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sha_file(&mut self) {
        self.sha_file = ::std::option::Option::None;
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientUFSUploadFileFinished| { &m.eresult },
            |m: &mut CMsgClientUFSUploadFileFinished| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sha_file",
            |m: &CMsgClientUFSUploadFileFinished| { &m.sha_file },
            |m: &mut CMsgClientUFSUploadFileFinished| { &mut m.sha_file },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUFSUploadFileFinished>(
            "CMsgClientUFSUploadFileFinished",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUFSUploadFileFinished {
    const NAME: &'static str = "CMsgClientUFSUploadFileFinished";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.sha_file = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.sha_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.sha_file.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUFSUploadFileFinished {
        CMsgClientUFSUploadFileFinished::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.sha_file = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUFSUploadFileFinished {
        static instance: CMsgClientUFSUploadFileFinished = CMsgClientUFSUploadFileFinished {
            eresult: ::std::option::Option::None,
            sha_file: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUFSUploadFileFinished {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUFSUploadFileFinished").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUFSUploadFileFinished {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSUploadFileFinished {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUFSDeleteFileRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUFSDeleteFileRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUFSDeleteFileRequest.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUFSDeleteFileRequest.file_name)
    pub file_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUFSDeleteFileRequest.is_explicit_delete)
    pub is_explicit_delete: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUFSDeleteFileRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSDeleteFileRequest {
    fn default() -> &'a CMsgClientUFSDeleteFileRequest {
        <CMsgClientUFSDeleteFileRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSDeleteFileRequest {
    pub fn new() -> CMsgClientUFSDeleteFileRequest {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional string file_name = 2;

    pub fn file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_name(&mut self) {
        self.file_name = ::std::option::Option::None;
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_explicit_delete = 3;

    pub fn is_explicit_delete(&self) -> bool {
        self.is_explicit_delete.unwrap_or(false)
    }

    pub fn clear_is_explicit_delete(&mut self) {
        self.is_explicit_delete = ::std::option::Option::None;
    }

    pub fn has_is_explicit_delete(&self) -> bool {
        self.is_explicit_delete.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_explicit_delete(&mut self, v: bool) {
        self.is_explicit_delete = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientUFSDeleteFileRequest| { &m.app_id },
            |m: &mut CMsgClientUFSDeleteFileRequest| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_name",
            |m: &CMsgClientUFSDeleteFileRequest| { &m.file_name },
            |m: &mut CMsgClientUFSDeleteFileRequest| { &mut m.file_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_explicit_delete",
            |m: &CMsgClientUFSDeleteFileRequest| { &m.is_explicit_delete },
            |m: &mut CMsgClientUFSDeleteFileRequest| { &mut m.is_explicit_delete },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUFSDeleteFileRequest>(
            "CMsgClientUFSDeleteFileRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUFSDeleteFileRequest {
    const NAME: &'static str = "CMsgClientUFSDeleteFileRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.file_name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.is_explicit_delete = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.is_explicit_delete {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.file_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.is_explicit_delete {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUFSDeleteFileRequest {
        CMsgClientUFSDeleteFileRequest::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.file_name = ::std::option::Option::None;
        self.is_explicit_delete = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUFSDeleteFileRequest {
        static instance: CMsgClientUFSDeleteFileRequest = CMsgClientUFSDeleteFileRequest {
            app_id: ::std::option::Option::None,
            file_name: ::std::option::Option::None,
            is_explicit_delete: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUFSDeleteFileRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUFSDeleteFileRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUFSDeleteFileRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSDeleteFileRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUFSDeleteFileResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUFSDeleteFileResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUFSDeleteFileResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUFSDeleteFileResponse.file_name)
    pub file_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUFSDeleteFileResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSDeleteFileResponse {
    fn default() -> &'a CMsgClientUFSDeleteFileResponse {
        <CMsgClientUFSDeleteFileResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSDeleteFileResponse {
    pub fn new() -> CMsgClientUFSDeleteFileResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional string file_name = 2;

    pub fn file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_name(&mut self) {
        self.file_name = ::std::option::Option::None;
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientUFSDeleteFileResponse| { &m.eresult },
            |m: &mut CMsgClientUFSDeleteFileResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_name",
            |m: &CMsgClientUFSDeleteFileResponse| { &m.file_name },
            |m: &mut CMsgClientUFSDeleteFileResponse| { &mut m.file_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUFSDeleteFileResponse>(
            "CMsgClientUFSDeleteFileResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUFSDeleteFileResponse {
    const NAME: &'static str = "CMsgClientUFSDeleteFileResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.file_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.file_name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUFSDeleteFileResponse {
        CMsgClientUFSDeleteFileResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.file_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUFSDeleteFileResponse {
        static instance: CMsgClientUFSDeleteFileResponse = CMsgClientUFSDeleteFileResponse {
            eresult: ::std::option::Option::None,
            file_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUFSDeleteFileResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUFSDeleteFileResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUFSDeleteFileResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSDeleteFileResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUFSGetFileListForApp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUFSGetFileListForApp {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUFSGetFileListForApp.apps_to_query)
    pub apps_to_query: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgClientUFSGetFileListForApp.send_path_prefixes)
    pub send_path_prefixes: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUFSGetFileListForApp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSGetFileListForApp {
    fn default() -> &'a CMsgClientUFSGetFileListForApp {
        <CMsgClientUFSGetFileListForApp as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSGetFileListForApp {
    pub fn new() -> CMsgClientUFSGetFileListForApp {
        ::std::default::Default::default()
    }

    // optional bool send_path_prefixes = 2;

    pub fn send_path_prefixes(&self) -> bool {
        self.send_path_prefixes.unwrap_or(false)
    }

    pub fn clear_send_path_prefixes(&mut self) {
        self.send_path_prefixes = ::std::option::Option::None;
    }

    pub fn has_send_path_prefixes(&self) -> bool {
        self.send_path_prefixes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send_path_prefixes(&mut self, v: bool) {
        self.send_path_prefixes = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "apps_to_query",
            |m: &CMsgClientUFSGetFileListForApp| { &m.apps_to_query },
            |m: &mut CMsgClientUFSGetFileListForApp| { &mut m.apps_to_query },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "send_path_prefixes",
            |m: &CMsgClientUFSGetFileListForApp| { &m.send_path_prefixes },
            |m: &mut CMsgClientUFSGetFileListForApp| { &mut m.send_path_prefixes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUFSGetFileListForApp>(
            "CMsgClientUFSGetFileListForApp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUFSGetFileListForApp {
    const NAME: &'static str = "CMsgClientUFSGetFileListForApp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.apps_to_query)?;
                },
                8 => {
                    self.apps_to_query.push(is.read_uint32()?);
                },
                16 => {
                    self.send_path_prefixes = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.apps_to_query {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        if let Some(v) = self.send_path_prefixes {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.apps_to_query {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.send_path_prefixes {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUFSGetFileListForApp {
        CMsgClientUFSGetFileListForApp::new()
    }

    fn clear(&mut self) {
        self.apps_to_query.clear();
        self.send_path_prefixes = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUFSGetFileListForApp {
        static instance: CMsgClientUFSGetFileListForApp = CMsgClientUFSGetFileListForApp {
            apps_to_query: ::std::vec::Vec::new(),
            send_path_prefixes: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUFSGetFileListForApp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUFSGetFileListForApp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUFSGetFileListForApp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSGetFileListForApp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUFSGetFileListForAppResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUFSGetFileListForAppResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUFSGetFileListForAppResponse.files)
    pub files: ::std::vec::Vec<cmsg_client_ufsget_file_list_for_app_response::File>,
    // @@protoc_insertion_point(field:CMsgClientUFSGetFileListForAppResponse.path_prefixes)
    pub path_prefixes: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUFSGetFileListForAppResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSGetFileListForAppResponse {
    fn default() -> &'a CMsgClientUFSGetFileListForAppResponse {
        <CMsgClientUFSGetFileListForAppResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSGetFileListForAppResponse {
    pub fn new() -> CMsgClientUFSGetFileListForAppResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "files",
            |m: &CMsgClientUFSGetFileListForAppResponse| { &m.files },
            |m: &mut CMsgClientUFSGetFileListForAppResponse| { &mut m.files },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "path_prefixes",
            |m: &CMsgClientUFSGetFileListForAppResponse| { &m.path_prefixes },
            |m: &mut CMsgClientUFSGetFileListForAppResponse| { &mut m.path_prefixes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUFSGetFileListForAppResponse>(
            "CMsgClientUFSGetFileListForAppResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUFSGetFileListForAppResponse {
    const NAME: &'static str = "CMsgClientUFSGetFileListForAppResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.files.push(is.read_message()?);
                },
                18 => {
                    self.path_prefixes.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.path_prefixes {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.files {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.path_prefixes {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUFSGetFileListForAppResponse {
        CMsgClientUFSGetFileListForAppResponse::new()
    }

    fn clear(&mut self) {
        self.files.clear();
        self.path_prefixes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUFSGetFileListForAppResponse {
        static instance: CMsgClientUFSGetFileListForAppResponse = CMsgClientUFSGetFileListForAppResponse {
            files: ::std::vec::Vec::new(),
            path_prefixes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUFSGetFileListForAppResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUFSGetFileListForAppResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUFSGetFileListForAppResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSGetFileListForAppResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientUFSGetFileListForAppResponse`
pub mod cmsg_client_ufsget_file_list_for_app_response {
    // @@protoc_insertion_point(message:CMsgClientUFSGetFileListForAppResponse.File)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct File {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientUFSGetFileListForAppResponse.File.app_id)
        pub app_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientUFSGetFileListForAppResponse.File.file_name)
        pub file_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientUFSGetFileListForAppResponse.File.sha_file)
        pub sha_file: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:CMsgClientUFSGetFileListForAppResponse.File.time_stamp)
        pub time_stamp: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientUFSGetFileListForAppResponse.File.raw_file_size)
        pub raw_file_size: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientUFSGetFileListForAppResponse.File.is_explicit_delete)
        pub is_explicit_delete: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientUFSGetFileListForAppResponse.File.platforms_to_sync)
        pub platforms_to_sync: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientUFSGetFileListForAppResponse.File.path_prefix_index)
        pub path_prefix_index: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientUFSGetFileListForAppResponse.File.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a File {
        fn default() -> &'a File {
            <File as ::protobuf::Message>::default_instance()
        }
    }

    impl File {
        pub fn new() -> File {
            ::std::default::Default::default()
        }

        // optional uint32 app_id = 1;

        pub fn app_id(&self) -> u32 {
            self.app_id.unwrap_or(0)
        }

        pub fn clear_app_id(&mut self) {
            self.app_id = ::std::option::Option::None;
        }

        pub fn has_app_id(&self) -> bool {
            self.app_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_app_id(&mut self, v: u32) {
            self.app_id = ::std::option::Option::Some(v);
        }

        // optional string file_name = 2;

        pub fn file_name(&self) -> &str {
            match self.file_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_file_name(&mut self) {
            self.file_name = ::std::option::Option::None;
        }

        pub fn has_file_name(&self) -> bool {
            self.file_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_file_name(&mut self, v: ::std::string::String) {
            self.file_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
            if self.file_name.is_none() {
                self.file_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.file_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_file_name(&mut self) -> ::std::string::String {
            self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bytes sha_file = 3;

        pub fn sha_file(&self) -> &[u8] {
            match self.sha_file.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_sha_file(&mut self) {
            self.sha_file = ::std::option::Option::None;
        }

        pub fn has_sha_file(&self) -> bool {
            self.sha_file.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
            self.sha_file = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_sha_file(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.sha_file.is_none() {
                self.sha_file = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.sha_file.as_mut().unwrap()
        }

        // Take field
        pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
            self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional uint64 time_stamp = 4;

        pub fn time_stamp(&self) -> u64 {
            self.time_stamp.unwrap_or(0)
        }

        pub fn clear_time_stamp(&mut self) {
            self.time_stamp = ::std::option::Option::None;
        }

        pub fn has_time_stamp(&self) -> bool {
            self.time_stamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_stamp(&mut self, v: u64) {
            self.time_stamp = ::std::option::Option::Some(v);
        }

        // optional uint32 raw_file_size = 5;

        pub fn raw_file_size(&self) -> u32 {
            self.raw_file_size.unwrap_or(0)
        }

        pub fn clear_raw_file_size(&mut self) {
            self.raw_file_size = ::std::option::Option::None;
        }

        pub fn has_raw_file_size(&self) -> bool {
            self.raw_file_size.is_some()
        }

        // Param is passed by value, moved
        pub fn set_raw_file_size(&mut self, v: u32) {
            self.raw_file_size = ::std::option::Option::Some(v);
        }

        // optional bool is_explicit_delete = 6;

        pub fn is_explicit_delete(&self) -> bool {
            self.is_explicit_delete.unwrap_or(false)
        }

        pub fn clear_is_explicit_delete(&mut self) {
            self.is_explicit_delete = ::std::option::Option::None;
        }

        pub fn has_is_explicit_delete(&self) -> bool {
            self.is_explicit_delete.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_explicit_delete(&mut self, v: bool) {
            self.is_explicit_delete = ::std::option::Option::Some(v);
        }

        // optional uint32 platforms_to_sync = 7;

        pub fn platforms_to_sync(&self) -> u32 {
            self.platforms_to_sync.unwrap_or(0)
        }

        pub fn clear_platforms_to_sync(&mut self) {
            self.platforms_to_sync = ::std::option::Option::None;
        }

        pub fn has_platforms_to_sync(&self) -> bool {
            self.platforms_to_sync.is_some()
        }

        // Param is passed by value, moved
        pub fn set_platforms_to_sync(&mut self, v: u32) {
            self.platforms_to_sync = ::std::option::Option::Some(v);
        }

        // optional uint32 path_prefix_index = 8;

        pub fn path_prefix_index(&self) -> u32 {
            self.path_prefix_index.unwrap_or(0)
        }

        pub fn clear_path_prefix_index(&mut self) {
            self.path_prefix_index = ::std::option::Option::None;
        }

        pub fn has_path_prefix_index(&self) -> bool {
            self.path_prefix_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_path_prefix_index(&mut self, v: u32) {
            self.path_prefix_index = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(8);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "app_id",
                |m: &File| { &m.app_id },
                |m: &mut File| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "file_name",
                |m: &File| { &m.file_name },
                |m: &mut File| { &mut m.file_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sha_file",
                |m: &File| { &m.sha_file },
                |m: &mut File| { &mut m.sha_file },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "time_stamp",
                |m: &File| { &m.time_stamp },
                |m: &mut File| { &mut m.time_stamp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "raw_file_size",
                |m: &File| { &m.raw_file_size },
                |m: &mut File| { &mut m.raw_file_size },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_explicit_delete",
                |m: &File| { &m.is_explicit_delete },
                |m: &mut File| { &mut m.is_explicit_delete },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "platforms_to_sync",
                |m: &File| { &m.platforms_to_sync },
                |m: &mut File| { &mut m.platforms_to_sync },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "path_prefix_index",
                |m: &File| { &m.path_prefix_index },
                |m: &mut File| { &mut m.path_prefix_index },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<File>(
                "CMsgClientUFSGetFileListForAppResponse.File",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for File {
        const NAME: &'static str = "File";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.file_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.sha_file = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    32 => {
                        self.time_stamp = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    40 => {
                        self.raw_file_size = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.is_explicit_delete = ::std::option::Option::Some(is.read_bool()?);
                    },
                    56 => {
                        self.platforms_to_sync = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.path_prefix_index = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.app_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.file_name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.sha_file.as_ref() {
                my_size += ::protobuf::rt::bytes_size(3, &v);
            }
            if let Some(v) = self.time_stamp {
                my_size += ::protobuf::rt::uint64_size(4, v);
            }
            if let Some(v) = self.raw_file_size {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.is_explicit_delete {
                my_size += 1 + 1;
            }
            if let Some(v) = self.platforms_to_sync {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.path_prefix_index {
                my_size += ::protobuf::rt::uint32_size(8, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.app_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.file_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.sha_file.as_ref() {
                os.write_bytes(3, v)?;
            }
            if let Some(v) = self.time_stamp {
                os.write_uint64(4, v)?;
            }
            if let Some(v) = self.raw_file_size {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.is_explicit_delete {
                os.write_bool(6, v)?;
            }
            if let Some(v) = self.platforms_to_sync {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.path_prefix_index {
                os.write_uint32(8, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> File {
            File::new()
        }

        fn clear(&mut self) {
            self.app_id = ::std::option::Option::None;
            self.file_name = ::std::option::Option::None;
            self.sha_file = ::std::option::Option::None;
            self.time_stamp = ::std::option::Option::None;
            self.raw_file_size = ::std::option::Option::None;
            self.is_explicit_delete = ::std::option::Option::None;
            self.platforms_to_sync = ::std::option::Option::None;
            self.path_prefix_index = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static File {
            static instance: File = File {
                app_id: ::std::option::Option::None,
                file_name: ::std::option::Option::None,
                sha_file: ::std::option::Option::None,
                time_stamp: ::std::option::Option::None,
                raw_file_size: ::std::option::Option::None,
                is_explicit_delete: ::std::option::Option::None,
                platforms_to_sync: ::std::option::Option::None,
                path_prefix_index: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for File {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientUFSGetFileListForAppResponse.File").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for File {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for File {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientUFSDownloadRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUFSDownloadRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUFSDownloadRequest.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUFSDownloadRequest.file_name)
    pub file_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUFSDownloadRequest.can_handle_http)
    pub can_handle_http: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUFSDownloadRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSDownloadRequest {
    fn default() -> &'a CMsgClientUFSDownloadRequest {
        <CMsgClientUFSDownloadRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSDownloadRequest {
    pub fn new() -> CMsgClientUFSDownloadRequest {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional string file_name = 2;

    pub fn file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_name(&mut self) {
        self.file_name = ::std::option::Option::None;
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool can_handle_http = 3;

    pub fn can_handle_http(&self) -> bool {
        self.can_handle_http.unwrap_or(false)
    }

    pub fn clear_can_handle_http(&mut self) {
        self.can_handle_http = ::std::option::Option::None;
    }

    pub fn has_can_handle_http(&self) -> bool {
        self.can_handle_http.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_handle_http(&mut self, v: bool) {
        self.can_handle_http = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientUFSDownloadRequest| { &m.app_id },
            |m: &mut CMsgClientUFSDownloadRequest| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_name",
            |m: &CMsgClientUFSDownloadRequest| { &m.file_name },
            |m: &mut CMsgClientUFSDownloadRequest| { &mut m.file_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "can_handle_http",
            |m: &CMsgClientUFSDownloadRequest| { &m.can_handle_http },
            |m: &mut CMsgClientUFSDownloadRequest| { &mut m.can_handle_http },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUFSDownloadRequest>(
            "CMsgClientUFSDownloadRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUFSDownloadRequest {
    const NAME: &'static str = "CMsgClientUFSDownloadRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.file_name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.can_handle_http = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.can_handle_http {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.file_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.can_handle_http {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUFSDownloadRequest {
        CMsgClientUFSDownloadRequest::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.file_name = ::std::option::Option::None;
        self.can_handle_http = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUFSDownloadRequest {
        static instance: CMsgClientUFSDownloadRequest = CMsgClientUFSDownloadRequest {
            app_id: ::std::option::Option::None,
            file_name: ::std::option::Option::None,
            can_handle_http: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUFSDownloadRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUFSDownloadRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUFSDownloadRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSDownloadRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUFSDownloadResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUFSDownloadResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUFSDownloadResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUFSDownloadResponse.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUFSDownloadResponse.file_size)
    pub file_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUFSDownloadResponse.raw_file_size)
    pub raw_file_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUFSDownloadResponse.sha_file)
    pub sha_file: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientUFSDownloadResponse.time_stamp)
    pub time_stamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUFSDownloadResponse.is_explicit_delete)
    pub is_explicit_delete: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUFSDownloadResponse.use_http)
    pub use_http: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUFSDownloadResponse.http_host)
    pub http_host: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUFSDownloadResponse.http_url)
    pub http_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUFSDownloadResponse.kv_headers)
    pub kv_headers: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientUFSDownloadResponse.use_https)
    pub use_https: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUFSDownloadResponse.encrypted)
    pub encrypted: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUFSDownloadResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSDownloadResponse {
    fn default() -> &'a CMsgClientUFSDownloadResponse {
        <CMsgClientUFSDownloadResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSDownloadResponse {
    pub fn new() -> CMsgClientUFSDownloadResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 file_size = 3;

    pub fn file_size(&self) -> u32 {
        self.file_size.unwrap_or(0)
    }

    pub fn clear_file_size(&mut self) {
        self.file_size = ::std::option::Option::None;
    }

    pub fn has_file_size(&self) -> bool {
        self.file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: u32) {
        self.file_size = ::std::option::Option::Some(v);
    }

    // optional uint32 raw_file_size = 4;

    pub fn raw_file_size(&self) -> u32 {
        self.raw_file_size.unwrap_or(0)
    }

    pub fn clear_raw_file_size(&mut self) {
        self.raw_file_size = ::std::option::Option::None;
    }

    pub fn has_raw_file_size(&self) -> bool {
        self.raw_file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_file_size(&mut self, v: u32) {
        self.raw_file_size = ::std::option::Option::Some(v);
    }

    // optional bytes sha_file = 5;

    pub fn sha_file(&self) -> &[u8] {
        match self.sha_file.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sha_file(&mut self) {
        self.sha_file = ::std::option::Option::None;
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 time_stamp = 6;

    pub fn time_stamp(&self) -> u64 {
        self.time_stamp.unwrap_or(0)
    }

    pub fn clear_time_stamp(&mut self) {
        self.time_stamp = ::std::option::Option::None;
    }

    pub fn has_time_stamp(&self) -> bool {
        self.time_stamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_stamp(&mut self, v: u64) {
        self.time_stamp = ::std::option::Option::Some(v);
    }

    // optional bool is_explicit_delete = 7;

    pub fn is_explicit_delete(&self) -> bool {
        self.is_explicit_delete.unwrap_or(false)
    }

    pub fn clear_is_explicit_delete(&mut self) {
        self.is_explicit_delete = ::std::option::Option::None;
    }

    pub fn has_is_explicit_delete(&self) -> bool {
        self.is_explicit_delete.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_explicit_delete(&mut self, v: bool) {
        self.is_explicit_delete = ::std::option::Option::Some(v);
    }

    // optional bool use_http = 8;

    pub fn use_http(&self) -> bool {
        self.use_http.unwrap_or(false)
    }

    pub fn clear_use_http(&mut self) {
        self.use_http = ::std::option::Option::None;
    }

    pub fn has_use_http(&self) -> bool {
        self.use_http.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_http(&mut self, v: bool) {
        self.use_http = ::std::option::Option::Some(v);
    }

    // optional string http_host = 9;

    pub fn http_host(&self) -> &str {
        match self.http_host.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_http_host(&mut self) {
        self.http_host = ::std::option::Option::None;
    }

    pub fn has_http_host(&self) -> bool {
        self.http_host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http_host(&mut self, v: ::std::string::String) {
        self.http_host = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http_host(&mut self) -> &mut ::std::string::String {
        if self.http_host.is_none() {
            self.http_host = ::std::option::Option::Some(::std::string::String::new());
        }
        self.http_host.as_mut().unwrap()
    }

    // Take field
    pub fn take_http_host(&mut self) -> ::std::string::String {
        self.http_host.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string http_url = 10;

    pub fn http_url(&self) -> &str {
        match self.http_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_http_url(&mut self) {
        self.http_url = ::std::option::Option::None;
    }

    pub fn has_http_url(&self) -> bool {
        self.http_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http_url(&mut self, v: ::std::string::String) {
        self.http_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http_url(&mut self) -> &mut ::std::string::String {
        if self.http_url.is_none() {
            self.http_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.http_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_http_url(&mut self) -> ::std::string::String {
        self.http_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes kv_headers = 11;

    pub fn kv_headers(&self) -> &[u8] {
        match self.kv_headers.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_kv_headers(&mut self) {
        self.kv_headers = ::std::option::Option::None;
    }

    pub fn has_kv_headers(&self) -> bool {
        self.kv_headers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kv_headers(&mut self, v: ::std::vec::Vec<u8>) {
        self.kv_headers = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kv_headers(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.kv_headers.is_none() {
            self.kv_headers = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.kv_headers.as_mut().unwrap()
    }

    // Take field
    pub fn take_kv_headers(&mut self) -> ::std::vec::Vec<u8> {
        self.kv_headers.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool use_https = 12;

    pub fn use_https(&self) -> bool {
        self.use_https.unwrap_or(false)
    }

    pub fn clear_use_https(&mut self) {
        self.use_https = ::std::option::Option::None;
    }

    pub fn has_use_https(&self) -> bool {
        self.use_https.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_https(&mut self, v: bool) {
        self.use_https = ::std::option::Option::Some(v);
    }

    // optional bool encrypted = 13;

    pub fn encrypted(&self) -> bool {
        self.encrypted.unwrap_or(false)
    }

    pub fn clear_encrypted(&mut self) {
        self.encrypted = ::std::option::Option::None;
    }

    pub fn has_encrypted(&self) -> bool {
        self.encrypted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encrypted(&mut self, v: bool) {
        self.encrypted = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientUFSDownloadResponse| { &m.eresult },
            |m: &mut CMsgClientUFSDownloadResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientUFSDownloadResponse| { &m.app_id },
            |m: &mut CMsgClientUFSDownloadResponse| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_size",
            |m: &CMsgClientUFSDownloadResponse| { &m.file_size },
            |m: &mut CMsgClientUFSDownloadResponse| { &mut m.file_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "raw_file_size",
            |m: &CMsgClientUFSDownloadResponse| { &m.raw_file_size },
            |m: &mut CMsgClientUFSDownloadResponse| { &mut m.raw_file_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sha_file",
            |m: &CMsgClientUFSDownloadResponse| { &m.sha_file },
            |m: &mut CMsgClientUFSDownloadResponse| { &mut m.sha_file },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_stamp",
            |m: &CMsgClientUFSDownloadResponse| { &m.time_stamp },
            |m: &mut CMsgClientUFSDownloadResponse| { &mut m.time_stamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_explicit_delete",
            |m: &CMsgClientUFSDownloadResponse| { &m.is_explicit_delete },
            |m: &mut CMsgClientUFSDownloadResponse| { &mut m.is_explicit_delete },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "use_http",
            |m: &CMsgClientUFSDownloadResponse| { &m.use_http },
            |m: &mut CMsgClientUFSDownloadResponse| { &mut m.use_http },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "http_host",
            |m: &CMsgClientUFSDownloadResponse| { &m.http_host },
            |m: &mut CMsgClientUFSDownloadResponse| { &mut m.http_host },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "http_url",
            |m: &CMsgClientUFSDownloadResponse| { &m.http_url },
            |m: &mut CMsgClientUFSDownloadResponse| { &mut m.http_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kv_headers",
            |m: &CMsgClientUFSDownloadResponse| { &m.kv_headers },
            |m: &mut CMsgClientUFSDownloadResponse| { &mut m.kv_headers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "use_https",
            |m: &CMsgClientUFSDownloadResponse| { &m.use_https },
            |m: &mut CMsgClientUFSDownloadResponse| { &mut m.use_https },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "encrypted",
            |m: &CMsgClientUFSDownloadResponse| { &m.encrypted },
            |m: &mut CMsgClientUFSDownloadResponse| { &mut m.encrypted },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUFSDownloadResponse>(
            "CMsgClientUFSDownloadResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUFSDownloadResponse {
    const NAME: &'static str = "CMsgClientUFSDownloadResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.file_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.raw_file_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.sha_file = ::std::option::Option::Some(is.read_bytes()?);
                },
                48 => {
                    self.time_stamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                56 => {
                    self.is_explicit_delete = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.use_http = ::std::option::Option::Some(is.read_bool()?);
                },
                74 => {
                    self.http_host = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.http_url = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    self.kv_headers = ::std::option::Option::Some(is.read_bytes()?);
                },
                96 => {
                    self.use_https = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.encrypted = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.file_size {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.raw_file_size {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.sha_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.time_stamp {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.is_explicit_delete {
            my_size += 1 + 1;
        }
        if let Some(v) = self.use_http {
            my_size += 1 + 1;
        }
        if let Some(v) = self.http_host.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.http_url.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.kv_headers.as_ref() {
            my_size += ::protobuf::rt::bytes_size(11, &v);
        }
        if let Some(v) = self.use_https {
            my_size += 1 + 1;
        }
        if let Some(v) = self.encrypted {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.file_size {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.raw_file_size {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.sha_file.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.time_stamp {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.is_explicit_delete {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.use_http {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.http_host.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.http_url.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.kv_headers.as_ref() {
            os.write_bytes(11, v)?;
        }
        if let Some(v) = self.use_https {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.encrypted {
            os.write_bool(13, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUFSDownloadResponse {
        CMsgClientUFSDownloadResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.file_size = ::std::option::Option::None;
        self.raw_file_size = ::std::option::Option::None;
        self.sha_file = ::std::option::Option::None;
        self.time_stamp = ::std::option::Option::None;
        self.is_explicit_delete = ::std::option::Option::None;
        self.use_http = ::std::option::Option::None;
        self.http_host = ::std::option::Option::None;
        self.http_url = ::std::option::Option::None;
        self.kv_headers = ::std::option::Option::None;
        self.use_https = ::std::option::Option::None;
        self.encrypted = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUFSDownloadResponse {
        static instance: CMsgClientUFSDownloadResponse = CMsgClientUFSDownloadResponse {
            eresult: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            file_size: ::std::option::Option::None,
            raw_file_size: ::std::option::Option::None,
            sha_file: ::std::option::Option::None,
            time_stamp: ::std::option::Option::None,
            is_explicit_delete: ::std::option::Option::None,
            use_http: ::std::option::Option::None,
            http_host: ::std::option::Option::None,
            http_url: ::std::option::Option::None,
            kv_headers: ::std::option::Option::None,
            use_https: ::std::option::Option::None,
            encrypted: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUFSDownloadResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUFSDownloadResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUFSDownloadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSDownloadResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUFSLoginRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUFSLoginRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUFSLoginRequest.protocol_version)
    pub protocol_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUFSLoginRequest.am_session_token)
    pub am_session_token: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUFSLoginRequest.apps)
    pub apps: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUFSLoginRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSLoginRequest {
    fn default() -> &'a CMsgClientUFSLoginRequest {
        <CMsgClientUFSLoginRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSLoginRequest {
    pub fn new() -> CMsgClientUFSLoginRequest {
        ::std::default::Default::default()
    }

    // optional uint32 protocol_version = 1;

    pub fn protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }

    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }

    // optional uint64 am_session_token = 2;

    pub fn am_session_token(&self) -> u64 {
        self.am_session_token.unwrap_or(0)
    }

    pub fn clear_am_session_token(&mut self) {
        self.am_session_token = ::std::option::Option::None;
    }

    pub fn has_am_session_token(&self) -> bool {
        self.am_session_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_am_session_token(&mut self, v: u64) {
        self.am_session_token = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "protocol_version",
            |m: &CMsgClientUFSLoginRequest| { &m.protocol_version },
            |m: &mut CMsgClientUFSLoginRequest| { &mut m.protocol_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "am_session_token",
            |m: &CMsgClientUFSLoginRequest| { &m.am_session_token },
            |m: &mut CMsgClientUFSLoginRequest| { &mut m.am_session_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "apps",
            |m: &CMsgClientUFSLoginRequest| { &m.apps },
            |m: &mut CMsgClientUFSLoginRequest| { &mut m.apps },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUFSLoginRequest>(
            "CMsgClientUFSLoginRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUFSLoginRequest {
    const NAME: &'static str = "CMsgClientUFSLoginRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.protocol_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.am_session_token = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.apps)?;
                },
                24 => {
                    self.apps.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.protocol_version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.am_session_token {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        for value in &self.apps {
            my_size += ::protobuf::rt::uint32_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.protocol_version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.am_session_token {
            os.write_uint64(2, v)?;
        }
        for v in &self.apps {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUFSLoginRequest {
        CMsgClientUFSLoginRequest::new()
    }

    fn clear(&mut self) {
        self.protocol_version = ::std::option::Option::None;
        self.am_session_token = ::std::option::Option::None;
        self.apps.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUFSLoginRequest {
        static instance: CMsgClientUFSLoginRequest = CMsgClientUFSLoginRequest {
            protocol_version: ::std::option::Option::None,
            am_session_token: ::std::option::Option::None,
            apps: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUFSLoginRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUFSLoginRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUFSLoginRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSLoginRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUFSLoginResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUFSLoginResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUFSLoginResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUFSLoginResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSLoginResponse {
    fn default() -> &'a CMsgClientUFSLoginResponse {
        <CMsgClientUFSLoginResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSLoginResponse {
    pub fn new() -> CMsgClientUFSLoginResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientUFSLoginResponse| { &m.eresult },
            |m: &mut CMsgClientUFSLoginResponse| { &mut m.eresult },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUFSLoginResponse>(
            "CMsgClientUFSLoginResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUFSLoginResponse {
    const NAME: &'static str = "CMsgClientUFSLoginResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUFSLoginResponse {
        CMsgClientUFSLoginResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUFSLoginResponse {
        static instance: CMsgClientUFSLoginResponse = CMsgClientUFSLoginResponse {
            eresult: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUFSLoginResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUFSLoginResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUFSLoginResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSLoginResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRequestEncryptedAppTicket)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestEncryptedAppTicket {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRequestEncryptedAppTicket.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRequestEncryptedAppTicket.userdata)
    pub userdata: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestEncryptedAppTicket.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestEncryptedAppTicket {
    fn default() -> &'a CMsgClientRequestEncryptedAppTicket {
        <CMsgClientRequestEncryptedAppTicket as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestEncryptedAppTicket {
    pub fn new() -> CMsgClientRequestEncryptedAppTicket {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional bytes userdata = 2;

    pub fn userdata(&self) -> &[u8] {
        match self.userdata.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_userdata(&mut self) {
        self.userdata = ::std::option::Option::None;
    }

    pub fn has_userdata(&self) -> bool {
        self.userdata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_userdata(&mut self, v: ::std::vec::Vec<u8>) {
        self.userdata = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_userdata(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.userdata.is_none() {
            self.userdata = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.userdata.as_mut().unwrap()
    }

    // Take field
    pub fn take_userdata(&mut self) -> ::std::vec::Vec<u8> {
        self.userdata.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientRequestEncryptedAppTicket| { &m.app_id },
            |m: &mut CMsgClientRequestEncryptedAppTicket| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "userdata",
            |m: &CMsgClientRequestEncryptedAppTicket| { &m.userdata },
            |m: &mut CMsgClientRequestEncryptedAppTicket| { &mut m.userdata },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRequestEncryptedAppTicket>(
            "CMsgClientRequestEncryptedAppTicket",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientRequestEncryptedAppTicket {
    const NAME: &'static str = "CMsgClientRequestEncryptedAppTicket";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.userdata = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.userdata.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.userdata.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestEncryptedAppTicket {
        CMsgClientRequestEncryptedAppTicket::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.userdata = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestEncryptedAppTicket {
        static instance: CMsgClientRequestEncryptedAppTicket = CMsgClientRequestEncryptedAppTicket {
            app_id: ::std::option::Option::None,
            userdata: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientRequestEncryptedAppTicket {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRequestEncryptedAppTicket").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRequestEncryptedAppTicket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestEncryptedAppTicket {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientRequestEncryptedAppTicketResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientRequestEncryptedAppTicketResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRequestEncryptedAppTicketResponse.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRequestEncryptedAppTicketResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientRequestEncryptedAppTicketResponse.encrypted_app_ticket)
    pub encrypted_app_ticket: ::protobuf::MessageField<super::encrypted_app_ticket::EncryptedAppTicket>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestEncryptedAppTicketResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestEncryptedAppTicketResponse {
    fn default() -> &'a CMsgClientRequestEncryptedAppTicketResponse {
        <CMsgClientRequestEncryptedAppTicketResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestEncryptedAppTicketResponse {
    pub fn new() -> CMsgClientRequestEncryptedAppTicketResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 2;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientRequestEncryptedAppTicketResponse| { &m.app_id },
            |m: &mut CMsgClientRequestEncryptedAppTicketResponse| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientRequestEncryptedAppTicketResponse| { &m.eresult },
            |m: &mut CMsgClientRequestEncryptedAppTicketResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::encrypted_app_ticket::EncryptedAppTicket>(
            "encrypted_app_ticket",
            |m: &CMsgClientRequestEncryptedAppTicketResponse| { &m.encrypted_app_ticket },
            |m: &mut CMsgClientRequestEncryptedAppTicketResponse| { &mut m.encrypted_app_ticket },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientRequestEncryptedAppTicketResponse>(
            "CMsgClientRequestEncryptedAppTicketResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientRequestEncryptedAppTicketResponse {
    const NAME: &'static str = "CMsgClientRequestEncryptedAppTicketResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.encrypted_app_ticket)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.encrypted_app_ticket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.encrypted_app_ticket.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestEncryptedAppTicketResponse {
        CMsgClientRequestEncryptedAppTicketResponse::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.encrypted_app_ticket.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestEncryptedAppTicketResponse {
        static instance: CMsgClientRequestEncryptedAppTicketResponse = CMsgClientRequestEncryptedAppTicketResponse {
            app_id: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            encrypted_app_ticket: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientRequestEncryptedAppTicketResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientRequestEncryptedAppTicketResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientRequestEncryptedAppTicketResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestEncryptedAppTicketResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientWalletInfoUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientWalletInfoUpdate {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientWalletInfoUpdate.has_wallet)
    pub has_wallet: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientWalletInfoUpdate.balance)
    pub balance: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientWalletInfoUpdate.currency)
    pub currency: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientWalletInfoUpdate.balance_delayed)
    pub balance_delayed: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientWalletInfoUpdate.balance64)
    pub balance64: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:CMsgClientWalletInfoUpdate.balance64_delayed)
    pub balance64_delayed: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientWalletInfoUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientWalletInfoUpdate {
    fn default() -> &'a CMsgClientWalletInfoUpdate {
        <CMsgClientWalletInfoUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientWalletInfoUpdate {
    pub fn new() -> CMsgClientWalletInfoUpdate {
        ::std::default::Default::default()
    }

    // optional bool has_wallet = 1;

    pub fn has_wallet(&self) -> bool {
        self.has_wallet.unwrap_or(false)
    }

    pub fn clear_has_wallet(&mut self) {
        self.has_wallet = ::std::option::Option::None;
    }

    pub fn has_has_wallet(&self) -> bool {
        self.has_wallet.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_wallet(&mut self, v: bool) {
        self.has_wallet = ::std::option::Option::Some(v);
    }

    // optional int32 balance = 2;

    pub fn balance(&self) -> i32 {
        self.balance.unwrap_or(0)
    }

    pub fn clear_balance(&mut self) {
        self.balance = ::std::option::Option::None;
    }

    pub fn has_balance(&self) -> bool {
        self.balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance(&mut self, v: i32) {
        self.balance = ::std::option::Option::Some(v);
    }

    // optional int32 currency = 3;

    pub fn currency(&self) -> i32 {
        self.currency.unwrap_or(0)
    }

    pub fn clear_currency(&mut self) {
        self.currency = ::std::option::Option::None;
    }

    pub fn has_currency(&self) -> bool {
        self.currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: i32) {
        self.currency = ::std::option::Option::Some(v);
    }

    // optional int32 balance_delayed = 4;

    pub fn balance_delayed(&self) -> i32 {
        self.balance_delayed.unwrap_or(0)
    }

    pub fn clear_balance_delayed(&mut self) {
        self.balance_delayed = ::std::option::Option::None;
    }

    pub fn has_balance_delayed(&self) -> bool {
        self.balance_delayed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance_delayed(&mut self, v: i32) {
        self.balance_delayed = ::std::option::Option::Some(v);
    }

    // optional int64 balance64 = 5;

    pub fn balance64(&self) -> i64 {
        self.balance64.unwrap_or(0)
    }

    pub fn clear_balance64(&mut self) {
        self.balance64 = ::std::option::Option::None;
    }

    pub fn has_balance64(&self) -> bool {
        self.balance64.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance64(&mut self, v: i64) {
        self.balance64 = ::std::option::Option::Some(v);
    }

    // optional int64 balance64_delayed = 6;

    pub fn balance64_delayed(&self) -> i64 {
        self.balance64_delayed.unwrap_or(0)
    }

    pub fn clear_balance64_delayed(&mut self) {
        self.balance64_delayed = ::std::option::Option::None;
    }

    pub fn has_balance64_delayed(&self) -> bool {
        self.balance64_delayed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance64_delayed(&mut self, v: i64) {
        self.balance64_delayed = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "has_wallet",
            |m: &CMsgClientWalletInfoUpdate| { &m.has_wallet },
            |m: &mut CMsgClientWalletInfoUpdate| { &mut m.has_wallet },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "balance",
            |m: &CMsgClientWalletInfoUpdate| { &m.balance },
            |m: &mut CMsgClientWalletInfoUpdate| { &mut m.balance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "currency",
            |m: &CMsgClientWalletInfoUpdate| { &m.currency },
            |m: &mut CMsgClientWalletInfoUpdate| { &mut m.currency },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "balance_delayed",
            |m: &CMsgClientWalletInfoUpdate| { &m.balance_delayed },
            |m: &mut CMsgClientWalletInfoUpdate| { &mut m.balance_delayed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "balance64",
            |m: &CMsgClientWalletInfoUpdate| { &m.balance64 },
            |m: &mut CMsgClientWalletInfoUpdate| { &mut m.balance64 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "balance64_delayed",
            |m: &CMsgClientWalletInfoUpdate| { &m.balance64_delayed },
            |m: &mut CMsgClientWalletInfoUpdate| { &mut m.balance64_delayed },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientWalletInfoUpdate>(
            "CMsgClientWalletInfoUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientWalletInfoUpdate {
    const NAME: &'static str = "CMsgClientWalletInfoUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.has_wallet = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.balance = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.currency = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.balance_delayed = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.balance64 = ::std::option::Option::Some(is.read_int64()?);
                },
                48 => {
                    self.balance64_delayed = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.has_wallet {
            my_size += 1 + 1;
        }
        if let Some(v) = self.balance {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.currency {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.balance_delayed {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.balance64 {
            my_size += ::protobuf::rt::int64_size(5, v);
        }
        if let Some(v) = self.balance64_delayed {
            my_size += ::protobuf::rt::int64_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.has_wallet {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.balance {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.currency {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.balance_delayed {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.balance64 {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.balance64_delayed {
            os.write_int64(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientWalletInfoUpdate {
        CMsgClientWalletInfoUpdate::new()
    }

    fn clear(&mut self) {
        self.has_wallet = ::std::option::Option::None;
        self.balance = ::std::option::Option::None;
        self.currency = ::std::option::Option::None;
        self.balance_delayed = ::std::option::Option::None;
        self.balance64 = ::std::option::Option::None;
        self.balance64_delayed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientWalletInfoUpdate {
        static instance: CMsgClientWalletInfoUpdate = CMsgClientWalletInfoUpdate {
            has_wallet: ::std::option::Option::None,
            balance: ::std::option::Option::None,
            currency: ::std::option::Option::None,
            balance_delayed: ::std::option::Option::None,
            balance64: ::std::option::Option::None,
            balance64_delayed: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientWalletInfoUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientWalletInfoUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientWalletInfoUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientWalletInfoUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientAppInfoUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientAppInfoUpdate {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientAppInfoUpdate.last_changenumber)
    pub last_changenumber: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientAppInfoUpdate.send_changelist)
    pub send_changelist: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientAppInfoUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientAppInfoUpdate {
    fn default() -> &'a CMsgClientAppInfoUpdate {
        <CMsgClientAppInfoUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAppInfoUpdate {
    pub fn new() -> CMsgClientAppInfoUpdate {
        ::std::default::Default::default()
    }

    // optional uint32 last_changenumber = 1;

    pub fn last_changenumber(&self) -> u32 {
        self.last_changenumber.unwrap_or(0)
    }

    pub fn clear_last_changenumber(&mut self) {
        self.last_changenumber = ::std::option::Option::None;
    }

    pub fn has_last_changenumber(&self) -> bool {
        self.last_changenumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_changenumber(&mut self, v: u32) {
        self.last_changenumber = ::std::option::Option::Some(v);
    }

    // optional bool send_changelist = 2;

    pub fn send_changelist(&self) -> bool {
        self.send_changelist.unwrap_or(false)
    }

    pub fn clear_send_changelist(&mut self) {
        self.send_changelist = ::std::option::Option::None;
    }

    pub fn has_send_changelist(&self) -> bool {
        self.send_changelist.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send_changelist(&mut self, v: bool) {
        self.send_changelist = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_changenumber",
            |m: &CMsgClientAppInfoUpdate| { &m.last_changenumber },
            |m: &mut CMsgClientAppInfoUpdate| { &mut m.last_changenumber },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "send_changelist",
            |m: &CMsgClientAppInfoUpdate| { &m.send_changelist },
            |m: &mut CMsgClientAppInfoUpdate| { &mut m.send_changelist },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientAppInfoUpdate>(
            "CMsgClientAppInfoUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientAppInfoUpdate {
    const NAME: &'static str = "CMsgClientAppInfoUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.last_changenumber = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.send_changelist = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.last_changenumber {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.send_changelist {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.last_changenumber {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.send_changelist {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientAppInfoUpdate {
        CMsgClientAppInfoUpdate::new()
    }

    fn clear(&mut self) {
        self.last_changenumber = ::std::option::Option::None;
        self.send_changelist = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientAppInfoUpdate {
        static instance: CMsgClientAppInfoUpdate = CMsgClientAppInfoUpdate {
            last_changenumber: ::std::option::Option::None,
            send_changelist: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientAppInfoUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientAppInfoUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientAppInfoUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAppInfoUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientAppInfoChanges)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientAppInfoChanges {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientAppInfoChanges.current_change_number)
    pub current_change_number: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientAppInfoChanges.force_full_update)
    pub force_full_update: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientAppInfoChanges.appIDs)
    pub appIDs: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientAppInfoChanges.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientAppInfoChanges {
    fn default() -> &'a CMsgClientAppInfoChanges {
        <CMsgClientAppInfoChanges as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAppInfoChanges {
    pub fn new() -> CMsgClientAppInfoChanges {
        ::std::default::Default::default()
    }

    // optional uint32 current_change_number = 1;

    pub fn current_change_number(&self) -> u32 {
        self.current_change_number.unwrap_or(0)
    }

    pub fn clear_current_change_number(&mut self) {
        self.current_change_number = ::std::option::Option::None;
    }

    pub fn has_current_change_number(&self) -> bool {
        self.current_change_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_change_number(&mut self, v: u32) {
        self.current_change_number = ::std::option::Option::Some(v);
    }

    // optional bool force_full_update = 2;

    pub fn force_full_update(&self) -> bool {
        self.force_full_update.unwrap_or(false)
    }

    pub fn clear_force_full_update(&mut self) {
        self.force_full_update = ::std::option::Option::None;
    }

    pub fn has_force_full_update(&self) -> bool {
        self.force_full_update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_full_update(&mut self, v: bool) {
        self.force_full_update = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "current_change_number",
            |m: &CMsgClientAppInfoChanges| { &m.current_change_number },
            |m: &mut CMsgClientAppInfoChanges| { &mut m.current_change_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "force_full_update",
            |m: &CMsgClientAppInfoChanges| { &m.force_full_update },
            |m: &mut CMsgClientAppInfoChanges| { &mut m.force_full_update },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "appIDs",
            |m: &CMsgClientAppInfoChanges| { &m.appIDs },
            |m: &mut CMsgClientAppInfoChanges| { &mut m.appIDs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientAppInfoChanges>(
            "CMsgClientAppInfoChanges",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientAppInfoChanges {
    const NAME: &'static str = "CMsgClientAppInfoChanges";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.current_change_number = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.force_full_update = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.appIDs)?;
                },
                24 => {
                    self.appIDs.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.current_change_number {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.force_full_update {
            my_size += 1 + 1;
        }
        for value in &self.appIDs {
            my_size += ::protobuf::rt::uint32_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.current_change_number {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.force_full_update {
            os.write_bool(2, v)?;
        }
        for v in &self.appIDs {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientAppInfoChanges {
        CMsgClientAppInfoChanges::new()
    }

    fn clear(&mut self) {
        self.current_change_number = ::std::option::Option::None;
        self.force_full_update = ::std::option::Option::None;
        self.appIDs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientAppInfoChanges {
        static instance: CMsgClientAppInfoChanges = CMsgClientAppInfoChanges {
            current_change_number: ::std::option::Option::None,
            force_full_update: ::std::option::Option::None,
            appIDs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientAppInfoChanges {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientAppInfoChanges").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientAppInfoChanges {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAppInfoChanges {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientAppInfoRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientAppInfoRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientAppInfoRequest.apps)
    pub apps: ::std::vec::Vec<cmsg_client_app_info_request::App>,
    // @@protoc_insertion_point(field:CMsgClientAppInfoRequest.supports_batches)
    pub supports_batches: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientAppInfoRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientAppInfoRequest {
    fn default() -> &'a CMsgClientAppInfoRequest {
        <CMsgClientAppInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAppInfoRequest {
    pub fn new() -> CMsgClientAppInfoRequest {
        ::std::default::Default::default()
    }

    // optional bool supports_batches = 2;

    pub fn supports_batches(&self) -> bool {
        self.supports_batches.unwrap_or(false)
    }

    pub fn clear_supports_batches(&mut self) {
        self.supports_batches = ::std::option::Option::None;
    }

    pub fn has_supports_batches(&self) -> bool {
        self.supports_batches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supports_batches(&mut self, v: bool) {
        self.supports_batches = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "apps",
            |m: &CMsgClientAppInfoRequest| { &m.apps },
            |m: &mut CMsgClientAppInfoRequest| { &mut m.apps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "supports_batches",
            |m: &CMsgClientAppInfoRequest| { &m.supports_batches },
            |m: &mut CMsgClientAppInfoRequest| { &mut m.supports_batches },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientAppInfoRequest>(
            "CMsgClientAppInfoRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientAppInfoRequest {
    const NAME: &'static str = "CMsgClientAppInfoRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.apps.push(is.read_message()?);
                },
                16 => {
                    self.supports_batches = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.supports_batches {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.apps {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.supports_batches {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientAppInfoRequest {
        CMsgClientAppInfoRequest::new()
    }

    fn clear(&mut self) {
        self.apps.clear();
        self.supports_batches = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientAppInfoRequest {
        static instance: CMsgClientAppInfoRequest = CMsgClientAppInfoRequest {
            apps: ::std::vec::Vec::new(),
            supports_batches: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientAppInfoRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientAppInfoRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientAppInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAppInfoRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientAppInfoRequest`
pub mod cmsg_client_app_info_request {
    // @@protoc_insertion_point(message:CMsgClientAppInfoRequest.App)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct App {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientAppInfoRequest.App.app_id)
        pub app_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientAppInfoRequest.App.section_flags)
        pub section_flags: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientAppInfoRequest.App.section_CRC)
        pub section_CRC: ::std::vec::Vec<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientAppInfoRequest.App.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a App {
        fn default() -> &'a App {
            <App as ::protobuf::Message>::default_instance()
        }
    }

    impl App {
        pub fn new() -> App {
            ::std::default::Default::default()
        }

        // optional uint32 app_id = 1;

        pub fn app_id(&self) -> u32 {
            self.app_id.unwrap_or(0)
        }

        pub fn clear_app_id(&mut self) {
            self.app_id = ::std::option::Option::None;
        }

        pub fn has_app_id(&self) -> bool {
            self.app_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_app_id(&mut self, v: u32) {
            self.app_id = ::std::option::Option::Some(v);
        }

        // optional uint32 section_flags = 2;

        pub fn section_flags(&self) -> u32 {
            self.section_flags.unwrap_or(0)
        }

        pub fn clear_section_flags(&mut self) {
            self.section_flags = ::std::option::Option::None;
        }

        pub fn has_section_flags(&self) -> bool {
            self.section_flags.is_some()
        }

        // Param is passed by value, moved
        pub fn set_section_flags(&mut self, v: u32) {
            self.section_flags = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "app_id",
                |m: &App| { &m.app_id },
                |m: &mut App| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "section_flags",
                |m: &App| { &m.section_flags },
                |m: &mut App| { &mut m.section_flags },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "section_CRC",
                |m: &App| { &m.section_CRC },
                |m: &mut App| { &mut m.section_CRC },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<App>(
                "CMsgClientAppInfoRequest.App",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for App {
        const NAME: &'static str = "App";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.section_flags = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        is.read_repeated_packed_uint32_into(&mut self.section_CRC)?;
                    },
                    24 => {
                        self.section_CRC.push(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.app_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.section_flags {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            for value in &self.section_CRC {
                my_size += ::protobuf::rt::uint32_size(3, *value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.app_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.section_flags {
                os.write_uint32(2, v)?;
            }
            for v in &self.section_CRC {
                os.write_uint32(3, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> App {
            App::new()
        }

        fn clear(&mut self) {
            self.app_id = ::std::option::Option::None;
            self.section_flags = ::std::option::Option::None;
            self.section_CRC.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static App {
            static instance: App = App {
                app_id: ::std::option::Option::None,
                section_flags: ::std::option::Option::None,
                section_CRC: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for App {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientAppInfoRequest.App").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for App {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for App {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientAppInfoResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientAppInfoResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientAppInfoResponse.apps)
    pub apps: ::std::vec::Vec<cmsg_client_app_info_response::App>,
    // @@protoc_insertion_point(field:CMsgClientAppInfoResponse.apps_unknown)
    pub apps_unknown: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgClientAppInfoResponse.apps_pending)
    pub apps_pending: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientAppInfoResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientAppInfoResponse {
    fn default() -> &'a CMsgClientAppInfoResponse {
        <CMsgClientAppInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAppInfoResponse {
    pub fn new() -> CMsgClientAppInfoResponse {
        ::std::default::Default::default()
    }

    // optional uint32 apps_pending = 3;

    pub fn apps_pending(&self) -> u32 {
        self.apps_pending.unwrap_or(0)
    }

    pub fn clear_apps_pending(&mut self) {
        self.apps_pending = ::std::option::Option::None;
    }

    pub fn has_apps_pending(&self) -> bool {
        self.apps_pending.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apps_pending(&mut self, v: u32) {
        self.apps_pending = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "apps",
            |m: &CMsgClientAppInfoResponse| { &m.apps },
            |m: &mut CMsgClientAppInfoResponse| { &mut m.apps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "apps_unknown",
            |m: &CMsgClientAppInfoResponse| { &m.apps_unknown },
            |m: &mut CMsgClientAppInfoResponse| { &mut m.apps_unknown },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "apps_pending",
            |m: &CMsgClientAppInfoResponse| { &m.apps_pending },
            |m: &mut CMsgClientAppInfoResponse| { &mut m.apps_pending },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientAppInfoResponse>(
            "CMsgClientAppInfoResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientAppInfoResponse {
    const NAME: &'static str = "CMsgClientAppInfoResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.apps.push(is.read_message()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.apps_unknown)?;
                },
                16 => {
                    self.apps_unknown.push(is.read_uint32()?);
                },
                24 => {
                    self.apps_pending = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.apps_unknown {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        if let Some(v) = self.apps_pending {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.apps {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.apps_unknown {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.apps_pending {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientAppInfoResponse {
        CMsgClientAppInfoResponse::new()
    }

    fn clear(&mut self) {
        self.apps.clear();
        self.apps_unknown.clear();
        self.apps_pending = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientAppInfoResponse {
        static instance: CMsgClientAppInfoResponse = CMsgClientAppInfoResponse {
            apps: ::std::vec::Vec::new(),
            apps_unknown: ::std::vec::Vec::new(),
            apps_pending: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientAppInfoResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientAppInfoResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientAppInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAppInfoResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientAppInfoResponse`
pub mod cmsg_client_app_info_response {
    // @@protoc_insertion_point(message:CMsgClientAppInfoResponse.App)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct App {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientAppInfoResponse.App.app_id)
        pub app_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientAppInfoResponse.App.change_number)
        pub change_number: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientAppInfoResponse.App.sections)
        pub sections: ::std::vec::Vec<app::Section>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientAppInfoResponse.App.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a App {
        fn default() -> &'a App {
            <App as ::protobuf::Message>::default_instance()
        }
    }

    impl App {
        pub fn new() -> App {
            ::std::default::Default::default()
        }

        // optional uint32 app_id = 1;

        pub fn app_id(&self) -> u32 {
            self.app_id.unwrap_or(0)
        }

        pub fn clear_app_id(&mut self) {
            self.app_id = ::std::option::Option::None;
        }

        pub fn has_app_id(&self) -> bool {
            self.app_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_app_id(&mut self, v: u32) {
            self.app_id = ::std::option::Option::Some(v);
        }

        // optional uint32 change_number = 2;

        pub fn change_number(&self) -> u32 {
            self.change_number.unwrap_or(0)
        }

        pub fn clear_change_number(&mut self) {
            self.change_number = ::std::option::Option::None;
        }

        pub fn has_change_number(&self) -> bool {
            self.change_number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_change_number(&mut self, v: u32) {
            self.change_number = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "app_id",
                |m: &App| { &m.app_id },
                |m: &mut App| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "change_number",
                |m: &App| { &m.change_number },
                |m: &mut App| { &mut m.change_number },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "sections",
                |m: &App| { &m.sections },
                |m: &mut App| { &mut m.sections },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<App>(
                "CMsgClientAppInfoResponse.App",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for App {
        const NAME: &'static str = "App";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.change_number = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.sections.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.app_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.change_number {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            for value in &self.sections {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.app_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.change_number {
                os.write_uint32(2, v)?;
            }
            for v in &self.sections {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> App {
            App::new()
        }

        fn clear(&mut self) {
            self.app_id = ::std::option::Option::None;
            self.change_number = ::std::option::Option::None;
            self.sections.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static App {
            static instance: App = App {
                app_id: ::std::option::Option::None,
                change_number: ::std::option::Option::None,
                sections: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for App {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientAppInfoResponse.App").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for App {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for App {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `App`
    pub mod app {
        // @@protoc_insertion_point(message:CMsgClientAppInfoResponse.App.Section)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Section {
            // message fields
            // @@protoc_insertion_point(field:CMsgClientAppInfoResponse.App.Section.section_id)
            pub section_id: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgClientAppInfoResponse.App.Section.section_kv)
            pub section_kv: ::std::option::Option<::std::vec::Vec<u8>>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgClientAppInfoResponse.App.Section.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Section {
            fn default() -> &'a Section {
                <Section as ::protobuf::Message>::default_instance()
            }
        }

        impl Section {
            pub fn new() -> Section {
                ::std::default::Default::default()
            }

            // optional uint32 section_id = 1;

            pub fn section_id(&self) -> u32 {
                self.section_id.unwrap_or(0)
            }

            pub fn clear_section_id(&mut self) {
                self.section_id = ::std::option::Option::None;
            }

            pub fn has_section_id(&self) -> bool {
                self.section_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_section_id(&mut self, v: u32) {
                self.section_id = ::std::option::Option::Some(v);
            }

            // optional bytes section_kv = 2;

            pub fn section_kv(&self) -> &[u8] {
                match self.section_kv.as_ref() {
                    Some(v) => v,
                    None => &[],
                }
            }

            pub fn clear_section_kv(&mut self) {
                self.section_kv = ::std::option::Option::None;
            }

            pub fn has_section_kv(&self) -> bool {
                self.section_kv.is_some()
            }

            // Param is passed by value, moved
            pub fn set_section_kv(&mut self, v: ::std::vec::Vec<u8>) {
                self.section_kv = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_section_kv(&mut self) -> &mut ::std::vec::Vec<u8> {
                if self.section_kv.is_none() {
                    self.section_kv = ::std::option::Option::Some(::std::vec::Vec::new());
                }
                self.section_kv.as_mut().unwrap()
            }

            // Take field
            pub fn take_section_kv(&mut self) -> ::std::vec::Vec<u8> {
                self.section_kv.take().unwrap_or_else(|| ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "section_id",
                    |m: &Section| { &m.section_id },
                    |m: &mut Section| { &mut m.section_id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "section_kv",
                    |m: &Section| { &m.section_kv },
                    |m: &mut Section| { &mut m.section_kv },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Section>(
                    "CMsgClientAppInfoResponse.App.Section",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Section {
            const NAME: &'static str = "Section";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.section_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        18 => {
                            self.section_kv = ::std::option::Option::Some(is.read_bytes()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.section_id {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.section_kv.as_ref() {
                    my_size += ::protobuf::rt::bytes_size(2, &v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.section_id {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.section_kv.as_ref() {
                    os.write_bytes(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Section {
                Section::new()
            }

            fn clear(&mut self) {
                self.section_id = ::std::option::Option::None;
                self.section_kv = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Section {
                static instance: Section = Section {
                    section_id: ::std::option::Option::None,
                    section_kv: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Section {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CMsgClientAppInfoResponse.App.Section").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Section {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Section {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientPackageInfoRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientPackageInfoRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientPackageInfoRequest.package_ids)
    pub package_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgClientPackageInfoRequest.meta_data_only)
    pub meta_data_only: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientPackageInfoRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientPackageInfoRequest {
    fn default() -> &'a CMsgClientPackageInfoRequest {
        <CMsgClientPackageInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPackageInfoRequest {
    pub fn new() -> CMsgClientPackageInfoRequest {
        ::std::default::Default::default()
    }

    // optional bool meta_data_only = 2;

    pub fn meta_data_only(&self) -> bool {
        self.meta_data_only.unwrap_or(false)
    }

    pub fn clear_meta_data_only(&mut self) {
        self.meta_data_only = ::std::option::Option::None;
    }

    pub fn has_meta_data_only(&self) -> bool {
        self.meta_data_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_meta_data_only(&mut self, v: bool) {
        self.meta_data_only = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "package_ids",
            |m: &CMsgClientPackageInfoRequest| { &m.package_ids },
            |m: &mut CMsgClientPackageInfoRequest| { &mut m.package_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "meta_data_only",
            |m: &CMsgClientPackageInfoRequest| { &m.meta_data_only },
            |m: &mut CMsgClientPackageInfoRequest| { &mut m.meta_data_only },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientPackageInfoRequest>(
            "CMsgClientPackageInfoRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientPackageInfoRequest {
    const NAME: &'static str = "CMsgClientPackageInfoRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.package_ids)?;
                },
                8 => {
                    self.package_ids.push(is.read_uint32()?);
                },
                16 => {
                    self.meta_data_only = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.package_ids {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        if let Some(v) = self.meta_data_only {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.package_ids {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.meta_data_only {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientPackageInfoRequest {
        CMsgClientPackageInfoRequest::new()
    }

    fn clear(&mut self) {
        self.package_ids.clear();
        self.meta_data_only = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientPackageInfoRequest {
        static instance: CMsgClientPackageInfoRequest = CMsgClientPackageInfoRequest {
            package_ids: ::std::vec::Vec::new(),
            meta_data_only: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientPackageInfoRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientPackageInfoRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientPackageInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPackageInfoRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientPackageInfoResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientPackageInfoResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientPackageInfoResponse.packages)
    pub packages: ::std::vec::Vec<cmsg_client_package_info_response::Package>,
    // @@protoc_insertion_point(field:CMsgClientPackageInfoResponse.packages_unknown)
    pub packages_unknown: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgClientPackageInfoResponse.packages_pending)
    pub packages_pending: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientPackageInfoResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientPackageInfoResponse {
    fn default() -> &'a CMsgClientPackageInfoResponse {
        <CMsgClientPackageInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPackageInfoResponse {
    pub fn new() -> CMsgClientPackageInfoResponse {
        ::std::default::Default::default()
    }

    // optional uint32 packages_pending = 3;

    pub fn packages_pending(&self) -> u32 {
        self.packages_pending.unwrap_or(0)
    }

    pub fn clear_packages_pending(&mut self) {
        self.packages_pending = ::std::option::Option::None;
    }

    pub fn has_packages_pending(&self) -> bool {
        self.packages_pending.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packages_pending(&mut self, v: u32) {
        self.packages_pending = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "packages",
            |m: &CMsgClientPackageInfoResponse| { &m.packages },
            |m: &mut CMsgClientPackageInfoResponse| { &mut m.packages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "packages_unknown",
            |m: &CMsgClientPackageInfoResponse| { &m.packages_unknown },
            |m: &mut CMsgClientPackageInfoResponse| { &mut m.packages_unknown },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "packages_pending",
            |m: &CMsgClientPackageInfoResponse| { &m.packages_pending },
            |m: &mut CMsgClientPackageInfoResponse| { &mut m.packages_pending },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientPackageInfoResponse>(
            "CMsgClientPackageInfoResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientPackageInfoResponse {
    const NAME: &'static str = "CMsgClientPackageInfoResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.packages.push(is.read_message()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.packages_unknown)?;
                },
                16 => {
                    self.packages_unknown.push(is.read_uint32()?);
                },
                24 => {
                    self.packages_pending = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.packages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.packages_unknown {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        if let Some(v) = self.packages_pending {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.packages {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.packages_unknown {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.packages_pending {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientPackageInfoResponse {
        CMsgClientPackageInfoResponse::new()
    }

    fn clear(&mut self) {
        self.packages.clear();
        self.packages_unknown.clear();
        self.packages_pending = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientPackageInfoResponse {
        static instance: CMsgClientPackageInfoResponse = CMsgClientPackageInfoResponse {
            packages: ::std::vec::Vec::new(),
            packages_unknown: ::std::vec::Vec::new(),
            packages_pending: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientPackageInfoResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientPackageInfoResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientPackageInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPackageInfoResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientPackageInfoResponse`
pub mod cmsg_client_package_info_response {
    // @@protoc_insertion_point(message:CMsgClientPackageInfoResponse.Package)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Package {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientPackageInfoResponse.Package.package_id)
        pub package_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPackageInfoResponse.Package.change_number)
        pub change_number: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPackageInfoResponse.Package.sha)
        pub sha: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:CMsgClientPackageInfoResponse.Package.buffer)
        pub buffer: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientPackageInfoResponse.Package.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Package {
        fn default() -> &'a Package {
            <Package as ::protobuf::Message>::default_instance()
        }
    }

    impl Package {
        pub fn new() -> Package {
            ::std::default::Default::default()
        }

        // optional uint32 package_id = 1;

        pub fn package_id(&self) -> u32 {
            self.package_id.unwrap_or(0)
        }

        pub fn clear_package_id(&mut self) {
            self.package_id = ::std::option::Option::None;
        }

        pub fn has_package_id(&self) -> bool {
            self.package_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_package_id(&mut self, v: u32) {
            self.package_id = ::std::option::Option::Some(v);
        }

        // optional uint32 change_number = 2;

        pub fn change_number(&self) -> u32 {
            self.change_number.unwrap_or(0)
        }

        pub fn clear_change_number(&mut self) {
            self.change_number = ::std::option::Option::None;
        }

        pub fn has_change_number(&self) -> bool {
            self.change_number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_change_number(&mut self, v: u32) {
            self.change_number = ::std::option::Option::Some(v);
        }

        // optional bytes sha = 3;

        pub fn sha(&self) -> &[u8] {
            match self.sha.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_sha(&mut self) {
            self.sha = ::std::option::Option::None;
        }

        pub fn has_sha(&self) -> bool {
            self.sha.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sha(&mut self, v: ::std::vec::Vec<u8>) {
            self.sha = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_sha(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.sha.is_none() {
                self.sha = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.sha.as_mut().unwrap()
        }

        // Take field
        pub fn take_sha(&mut self) -> ::std::vec::Vec<u8> {
            self.sha.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional bytes buffer = 4;

        pub fn buffer(&self) -> &[u8] {
            match self.buffer.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_buffer(&mut self) {
            self.buffer = ::std::option::Option::None;
        }

        pub fn has_buffer(&self) -> bool {
            self.buffer.is_some()
        }

        // Param is passed by value, moved
        pub fn set_buffer(&mut self, v: ::std::vec::Vec<u8>) {
            self.buffer = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_buffer(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.buffer.is_none() {
                self.buffer = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.buffer.as_mut().unwrap()
        }

        // Take field
        pub fn take_buffer(&mut self) -> ::std::vec::Vec<u8> {
            self.buffer.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "package_id",
                |m: &Package| { &m.package_id },
                |m: &mut Package| { &mut m.package_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "change_number",
                |m: &Package| { &m.change_number },
                |m: &mut Package| { &mut m.change_number },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sha",
                |m: &Package| { &m.sha },
                |m: &mut Package| { &mut m.sha },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "buffer",
                |m: &Package| { &m.buffer },
                |m: &mut Package| { &mut m.buffer },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Package>(
                "CMsgClientPackageInfoResponse.Package",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Package {
        const NAME: &'static str = "Package";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.package_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.change_number = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.sha = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    34 => {
                        self.buffer = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.package_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.change_number {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.sha.as_ref() {
                my_size += ::protobuf::rt::bytes_size(3, &v);
            }
            if let Some(v) = self.buffer.as_ref() {
                my_size += ::protobuf::rt::bytes_size(4, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.package_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.change_number {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.sha.as_ref() {
                os.write_bytes(3, v)?;
            }
            if let Some(v) = self.buffer.as_ref() {
                os.write_bytes(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Package {
            Package::new()
        }

        fn clear(&mut self) {
            self.package_id = ::std::option::Option::None;
            self.change_number = ::std::option::Option::None;
            self.sha = ::std::option::Option::None;
            self.buffer = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Package {
            static instance: Package = Package {
                package_id: ::std::option::Option::None,
                change_number: ::std::option::Option::None,
                sha: ::std::option::Option::None,
                buffer: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Package {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientPackageInfoResponse.Package").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Package {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Package {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientPICSChangesSinceRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientPICSChangesSinceRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientPICSChangesSinceRequest.since_change_number)
    pub since_change_number: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientPICSChangesSinceRequest.send_app_info_changes)
    pub send_app_info_changes: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientPICSChangesSinceRequest.send_package_info_changes)
    pub send_package_info_changes: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientPICSChangesSinceRequest.num_app_info_cached)
    pub num_app_info_cached: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientPICSChangesSinceRequest.num_package_info_cached)
    pub num_package_info_cached: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientPICSChangesSinceRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientPICSChangesSinceRequest {
    fn default() -> &'a CMsgClientPICSChangesSinceRequest {
        <CMsgClientPICSChangesSinceRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPICSChangesSinceRequest {
    pub fn new() -> CMsgClientPICSChangesSinceRequest {
        ::std::default::Default::default()
    }

    // optional uint32 since_change_number = 1;

    pub fn since_change_number(&self) -> u32 {
        self.since_change_number.unwrap_or(0)
    }

    pub fn clear_since_change_number(&mut self) {
        self.since_change_number = ::std::option::Option::None;
    }

    pub fn has_since_change_number(&self) -> bool {
        self.since_change_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_since_change_number(&mut self, v: u32) {
        self.since_change_number = ::std::option::Option::Some(v);
    }

    // optional bool send_app_info_changes = 2;

    pub fn send_app_info_changes(&self) -> bool {
        self.send_app_info_changes.unwrap_or(false)
    }

    pub fn clear_send_app_info_changes(&mut self) {
        self.send_app_info_changes = ::std::option::Option::None;
    }

    pub fn has_send_app_info_changes(&self) -> bool {
        self.send_app_info_changes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send_app_info_changes(&mut self, v: bool) {
        self.send_app_info_changes = ::std::option::Option::Some(v);
    }

    // optional bool send_package_info_changes = 3;

    pub fn send_package_info_changes(&self) -> bool {
        self.send_package_info_changes.unwrap_or(false)
    }

    pub fn clear_send_package_info_changes(&mut self) {
        self.send_package_info_changes = ::std::option::Option::None;
    }

    pub fn has_send_package_info_changes(&self) -> bool {
        self.send_package_info_changes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send_package_info_changes(&mut self, v: bool) {
        self.send_package_info_changes = ::std::option::Option::Some(v);
    }

    // optional uint32 num_app_info_cached = 4;

    pub fn num_app_info_cached(&self) -> u32 {
        self.num_app_info_cached.unwrap_or(0)
    }

    pub fn clear_num_app_info_cached(&mut self) {
        self.num_app_info_cached = ::std::option::Option::None;
    }

    pub fn has_num_app_info_cached(&self) -> bool {
        self.num_app_info_cached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_app_info_cached(&mut self, v: u32) {
        self.num_app_info_cached = ::std::option::Option::Some(v);
    }

    // optional uint32 num_package_info_cached = 5;

    pub fn num_package_info_cached(&self) -> u32 {
        self.num_package_info_cached.unwrap_or(0)
    }

    pub fn clear_num_package_info_cached(&mut self) {
        self.num_package_info_cached = ::std::option::Option::None;
    }

    pub fn has_num_package_info_cached(&self) -> bool {
        self.num_package_info_cached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_package_info_cached(&mut self, v: u32) {
        self.num_package_info_cached = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "since_change_number",
            |m: &CMsgClientPICSChangesSinceRequest| { &m.since_change_number },
            |m: &mut CMsgClientPICSChangesSinceRequest| { &mut m.since_change_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "send_app_info_changes",
            |m: &CMsgClientPICSChangesSinceRequest| { &m.send_app_info_changes },
            |m: &mut CMsgClientPICSChangesSinceRequest| { &mut m.send_app_info_changes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "send_package_info_changes",
            |m: &CMsgClientPICSChangesSinceRequest| { &m.send_package_info_changes },
            |m: &mut CMsgClientPICSChangesSinceRequest| { &mut m.send_package_info_changes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_app_info_cached",
            |m: &CMsgClientPICSChangesSinceRequest| { &m.num_app_info_cached },
            |m: &mut CMsgClientPICSChangesSinceRequest| { &mut m.num_app_info_cached },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_package_info_cached",
            |m: &CMsgClientPICSChangesSinceRequest| { &m.num_package_info_cached },
            |m: &mut CMsgClientPICSChangesSinceRequest| { &mut m.num_package_info_cached },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientPICSChangesSinceRequest>(
            "CMsgClientPICSChangesSinceRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientPICSChangesSinceRequest {
    const NAME: &'static str = "CMsgClientPICSChangesSinceRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.since_change_number = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.send_app_info_changes = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.send_package_info_changes = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.num_app_info_cached = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.num_package_info_cached = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.since_change_number {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.send_app_info_changes {
            my_size += 1 + 1;
        }
        if let Some(v) = self.send_package_info_changes {
            my_size += 1 + 1;
        }
        if let Some(v) = self.num_app_info_cached {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.num_package_info_cached {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.since_change_number {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.send_app_info_changes {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.send_package_info_changes {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.num_app_info_cached {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.num_package_info_cached {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientPICSChangesSinceRequest {
        CMsgClientPICSChangesSinceRequest::new()
    }

    fn clear(&mut self) {
        self.since_change_number = ::std::option::Option::None;
        self.send_app_info_changes = ::std::option::Option::None;
        self.send_package_info_changes = ::std::option::Option::None;
        self.num_app_info_cached = ::std::option::Option::None;
        self.num_package_info_cached = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientPICSChangesSinceRequest {
        static instance: CMsgClientPICSChangesSinceRequest = CMsgClientPICSChangesSinceRequest {
            since_change_number: ::std::option::Option::None,
            send_app_info_changes: ::std::option::Option::None,
            send_package_info_changes: ::std::option::Option::None,
            num_app_info_cached: ::std::option::Option::None,
            num_package_info_cached: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientPICSChangesSinceRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientPICSChangesSinceRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientPICSChangesSinceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPICSChangesSinceRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientPICSChangesSinceResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientPICSChangesSinceResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientPICSChangesSinceResponse.current_change_number)
    pub current_change_number: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientPICSChangesSinceResponse.since_change_number)
    pub since_change_number: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientPICSChangesSinceResponse.force_full_update)
    pub force_full_update: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientPICSChangesSinceResponse.package_changes)
    pub package_changes: ::std::vec::Vec<cmsg_client_picschanges_since_response::PackageChange>,
    // @@protoc_insertion_point(field:CMsgClientPICSChangesSinceResponse.app_changes)
    pub app_changes: ::std::vec::Vec<cmsg_client_picschanges_since_response::AppChange>,
    // @@protoc_insertion_point(field:CMsgClientPICSChangesSinceResponse.force_full_app_update)
    pub force_full_app_update: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientPICSChangesSinceResponse.force_full_package_update)
    pub force_full_package_update: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientPICSChangesSinceResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientPICSChangesSinceResponse {
    fn default() -> &'a CMsgClientPICSChangesSinceResponse {
        <CMsgClientPICSChangesSinceResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPICSChangesSinceResponse {
    pub fn new() -> CMsgClientPICSChangesSinceResponse {
        ::std::default::Default::default()
    }

    // optional uint32 current_change_number = 1;

    pub fn current_change_number(&self) -> u32 {
        self.current_change_number.unwrap_or(0)
    }

    pub fn clear_current_change_number(&mut self) {
        self.current_change_number = ::std::option::Option::None;
    }

    pub fn has_current_change_number(&self) -> bool {
        self.current_change_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_change_number(&mut self, v: u32) {
        self.current_change_number = ::std::option::Option::Some(v);
    }

    // optional uint32 since_change_number = 2;

    pub fn since_change_number(&self) -> u32 {
        self.since_change_number.unwrap_or(0)
    }

    pub fn clear_since_change_number(&mut self) {
        self.since_change_number = ::std::option::Option::None;
    }

    pub fn has_since_change_number(&self) -> bool {
        self.since_change_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_since_change_number(&mut self, v: u32) {
        self.since_change_number = ::std::option::Option::Some(v);
    }

    // optional bool force_full_update = 3;

    pub fn force_full_update(&self) -> bool {
        self.force_full_update.unwrap_or(false)
    }

    pub fn clear_force_full_update(&mut self) {
        self.force_full_update = ::std::option::Option::None;
    }

    pub fn has_force_full_update(&self) -> bool {
        self.force_full_update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_full_update(&mut self, v: bool) {
        self.force_full_update = ::std::option::Option::Some(v);
    }

    // optional bool force_full_app_update = 6;

    pub fn force_full_app_update(&self) -> bool {
        self.force_full_app_update.unwrap_or(false)
    }

    pub fn clear_force_full_app_update(&mut self) {
        self.force_full_app_update = ::std::option::Option::None;
    }

    pub fn has_force_full_app_update(&self) -> bool {
        self.force_full_app_update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_full_app_update(&mut self, v: bool) {
        self.force_full_app_update = ::std::option::Option::Some(v);
    }

    // optional bool force_full_package_update = 7;

    pub fn force_full_package_update(&self) -> bool {
        self.force_full_package_update.unwrap_or(false)
    }

    pub fn clear_force_full_package_update(&mut self) {
        self.force_full_package_update = ::std::option::Option::None;
    }

    pub fn has_force_full_package_update(&self) -> bool {
        self.force_full_package_update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_full_package_update(&mut self, v: bool) {
        self.force_full_package_update = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "current_change_number",
            |m: &CMsgClientPICSChangesSinceResponse| { &m.current_change_number },
            |m: &mut CMsgClientPICSChangesSinceResponse| { &mut m.current_change_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "since_change_number",
            |m: &CMsgClientPICSChangesSinceResponse| { &m.since_change_number },
            |m: &mut CMsgClientPICSChangesSinceResponse| { &mut m.since_change_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "force_full_update",
            |m: &CMsgClientPICSChangesSinceResponse| { &m.force_full_update },
            |m: &mut CMsgClientPICSChangesSinceResponse| { &mut m.force_full_update },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "package_changes",
            |m: &CMsgClientPICSChangesSinceResponse| { &m.package_changes },
            |m: &mut CMsgClientPICSChangesSinceResponse| { &mut m.package_changes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "app_changes",
            |m: &CMsgClientPICSChangesSinceResponse| { &m.app_changes },
            |m: &mut CMsgClientPICSChangesSinceResponse| { &mut m.app_changes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "force_full_app_update",
            |m: &CMsgClientPICSChangesSinceResponse| { &m.force_full_app_update },
            |m: &mut CMsgClientPICSChangesSinceResponse| { &mut m.force_full_app_update },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "force_full_package_update",
            |m: &CMsgClientPICSChangesSinceResponse| { &m.force_full_package_update },
            |m: &mut CMsgClientPICSChangesSinceResponse| { &mut m.force_full_package_update },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientPICSChangesSinceResponse>(
            "CMsgClientPICSChangesSinceResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientPICSChangesSinceResponse {
    const NAME: &'static str = "CMsgClientPICSChangesSinceResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.current_change_number = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.since_change_number = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.force_full_update = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    self.package_changes.push(is.read_message()?);
                },
                42 => {
                    self.app_changes.push(is.read_message()?);
                },
                48 => {
                    self.force_full_app_update = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.force_full_package_update = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.current_change_number {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.since_change_number {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.force_full_update {
            my_size += 1 + 1;
        }
        for value in &self.package_changes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.app_changes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.force_full_app_update {
            my_size += 1 + 1;
        }
        if let Some(v) = self.force_full_package_update {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.current_change_number {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.since_change_number {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.force_full_update {
            os.write_bool(3, v)?;
        }
        for v in &self.package_changes {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.app_changes {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.force_full_app_update {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.force_full_package_update {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientPICSChangesSinceResponse {
        CMsgClientPICSChangesSinceResponse::new()
    }

    fn clear(&mut self) {
        self.current_change_number = ::std::option::Option::None;
        self.since_change_number = ::std::option::Option::None;
        self.force_full_update = ::std::option::Option::None;
        self.package_changes.clear();
        self.app_changes.clear();
        self.force_full_app_update = ::std::option::Option::None;
        self.force_full_package_update = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientPICSChangesSinceResponse {
        static instance: CMsgClientPICSChangesSinceResponse = CMsgClientPICSChangesSinceResponse {
            current_change_number: ::std::option::Option::None,
            since_change_number: ::std::option::Option::None,
            force_full_update: ::std::option::Option::None,
            package_changes: ::std::vec::Vec::new(),
            app_changes: ::std::vec::Vec::new(),
            force_full_app_update: ::std::option::Option::None,
            force_full_package_update: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientPICSChangesSinceResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientPICSChangesSinceResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientPICSChangesSinceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPICSChangesSinceResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientPICSChangesSinceResponse`
pub mod cmsg_client_picschanges_since_response {
    // @@protoc_insertion_point(message:CMsgClientPICSChangesSinceResponse.PackageChange)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PackageChange {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientPICSChangesSinceResponse.PackageChange.packageid)
        pub packageid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPICSChangesSinceResponse.PackageChange.change_number)
        pub change_number: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPICSChangesSinceResponse.PackageChange.needs_token)
        pub needs_token: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientPICSChangesSinceResponse.PackageChange.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PackageChange {
        fn default() -> &'a PackageChange {
            <PackageChange as ::protobuf::Message>::default_instance()
        }
    }

    impl PackageChange {
        pub fn new() -> PackageChange {
            ::std::default::Default::default()
        }

        // optional uint32 packageid = 1;

        pub fn packageid(&self) -> u32 {
            self.packageid.unwrap_or(0)
        }

        pub fn clear_packageid(&mut self) {
            self.packageid = ::std::option::Option::None;
        }

        pub fn has_packageid(&self) -> bool {
            self.packageid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_packageid(&mut self, v: u32) {
            self.packageid = ::std::option::Option::Some(v);
        }

        // optional uint32 change_number = 2;

        pub fn change_number(&self) -> u32 {
            self.change_number.unwrap_or(0)
        }

        pub fn clear_change_number(&mut self) {
            self.change_number = ::std::option::Option::None;
        }

        pub fn has_change_number(&self) -> bool {
            self.change_number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_change_number(&mut self, v: u32) {
            self.change_number = ::std::option::Option::Some(v);
        }

        // optional bool needs_token = 3;

        pub fn needs_token(&self) -> bool {
            self.needs_token.unwrap_or(false)
        }

        pub fn clear_needs_token(&mut self) {
            self.needs_token = ::std::option::Option::None;
        }

        pub fn has_needs_token(&self) -> bool {
            self.needs_token.is_some()
        }

        // Param is passed by value, moved
        pub fn set_needs_token(&mut self, v: bool) {
            self.needs_token = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "packageid",
                |m: &PackageChange| { &m.packageid },
                |m: &mut PackageChange| { &mut m.packageid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "change_number",
                |m: &PackageChange| { &m.change_number },
                |m: &mut PackageChange| { &mut m.change_number },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "needs_token",
                |m: &PackageChange| { &m.needs_token },
                |m: &mut PackageChange| { &mut m.needs_token },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PackageChange>(
                "CMsgClientPICSChangesSinceResponse.PackageChange",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PackageChange {
        const NAME: &'static str = "PackageChange";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.packageid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.change_number = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.needs_token = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.packageid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.change_number {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.needs_token {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.packageid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.change_number {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.needs_token {
                os.write_bool(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PackageChange {
            PackageChange::new()
        }

        fn clear(&mut self) {
            self.packageid = ::std::option::Option::None;
            self.change_number = ::std::option::Option::None;
            self.needs_token = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PackageChange {
            static instance: PackageChange = PackageChange {
                packageid: ::std::option::Option::None,
                change_number: ::std::option::Option::None,
                needs_token: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PackageChange {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientPICSChangesSinceResponse.PackageChange").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PackageChange {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PackageChange {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgClientPICSChangesSinceResponse.AppChange)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AppChange {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientPICSChangesSinceResponse.AppChange.appid)
        pub appid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPICSChangesSinceResponse.AppChange.change_number)
        pub change_number: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPICSChangesSinceResponse.AppChange.needs_token)
        pub needs_token: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientPICSChangesSinceResponse.AppChange.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AppChange {
        fn default() -> &'a AppChange {
            <AppChange as ::protobuf::Message>::default_instance()
        }
    }

    impl AppChange {
        pub fn new() -> AppChange {
            ::std::default::Default::default()
        }

        // optional uint32 appid = 1;

        pub fn appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional uint32 change_number = 2;

        pub fn change_number(&self) -> u32 {
            self.change_number.unwrap_or(0)
        }

        pub fn clear_change_number(&mut self) {
            self.change_number = ::std::option::Option::None;
        }

        pub fn has_change_number(&self) -> bool {
            self.change_number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_change_number(&mut self, v: u32) {
            self.change_number = ::std::option::Option::Some(v);
        }

        // optional bool needs_token = 3;

        pub fn needs_token(&self) -> bool {
            self.needs_token.unwrap_or(false)
        }

        pub fn clear_needs_token(&mut self) {
            self.needs_token = ::std::option::Option::None;
        }

        pub fn has_needs_token(&self) -> bool {
            self.needs_token.is_some()
        }

        // Param is passed by value, moved
        pub fn set_needs_token(&mut self, v: bool) {
            self.needs_token = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "appid",
                |m: &AppChange| { &m.appid },
                |m: &mut AppChange| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "change_number",
                |m: &AppChange| { &m.change_number },
                |m: &mut AppChange| { &mut m.change_number },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "needs_token",
                |m: &AppChange| { &m.needs_token },
                |m: &mut AppChange| { &mut m.needs_token },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AppChange>(
                "CMsgClientPICSChangesSinceResponse.AppChange",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AppChange {
        const NAME: &'static str = "AppChange";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.change_number = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.needs_token = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.appid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.change_number {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.needs_token {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.appid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.change_number {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.needs_token {
                os.write_bool(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AppChange {
            AppChange::new()
        }

        fn clear(&mut self) {
            self.appid = ::std::option::Option::None;
            self.change_number = ::std::option::Option::None;
            self.needs_token = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AppChange {
            static instance: AppChange = AppChange {
                appid: ::std::option::Option::None,
                change_number: ::std::option::Option::None,
                needs_token: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AppChange {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientPICSChangesSinceResponse.AppChange").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AppChange {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AppChange {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientPICSProductInfoRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientPICSProductInfoRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientPICSProductInfoRequest.packages)
    pub packages: ::std::vec::Vec<cmsg_client_picsproduct_info_request::PackageInfo>,
    // @@protoc_insertion_point(field:CMsgClientPICSProductInfoRequest.apps)
    pub apps: ::std::vec::Vec<cmsg_client_picsproduct_info_request::AppInfo>,
    // @@protoc_insertion_point(field:CMsgClientPICSProductInfoRequest.meta_data_only)
    pub meta_data_only: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientPICSProductInfoRequest.num_prev_failed)
    pub num_prev_failed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientPICSProductInfoRequest.supports_package_tokens)
    pub supports_package_tokens: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientPICSProductInfoRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientPICSProductInfoRequest {
    fn default() -> &'a CMsgClientPICSProductInfoRequest {
        <CMsgClientPICSProductInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPICSProductInfoRequest {
    pub fn new() -> CMsgClientPICSProductInfoRequest {
        ::std::default::Default::default()
    }

    // optional bool meta_data_only = 3;

    pub fn meta_data_only(&self) -> bool {
        self.meta_data_only.unwrap_or(false)
    }

    pub fn clear_meta_data_only(&mut self) {
        self.meta_data_only = ::std::option::Option::None;
    }

    pub fn has_meta_data_only(&self) -> bool {
        self.meta_data_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_meta_data_only(&mut self, v: bool) {
        self.meta_data_only = ::std::option::Option::Some(v);
    }

    // optional uint32 num_prev_failed = 4;

    pub fn num_prev_failed(&self) -> u32 {
        self.num_prev_failed.unwrap_or(0)
    }

    pub fn clear_num_prev_failed(&mut self) {
        self.num_prev_failed = ::std::option::Option::None;
    }

    pub fn has_num_prev_failed(&self) -> bool {
        self.num_prev_failed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_prev_failed(&mut self, v: u32) {
        self.num_prev_failed = ::std::option::Option::Some(v);
    }

    // optional uint32 supports_package_tokens = 5;

    pub fn supports_package_tokens(&self) -> u32 {
        self.supports_package_tokens.unwrap_or(0)
    }

    pub fn clear_supports_package_tokens(&mut self) {
        self.supports_package_tokens = ::std::option::Option::None;
    }

    pub fn has_supports_package_tokens(&self) -> bool {
        self.supports_package_tokens.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supports_package_tokens(&mut self, v: u32) {
        self.supports_package_tokens = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "packages",
            |m: &CMsgClientPICSProductInfoRequest| { &m.packages },
            |m: &mut CMsgClientPICSProductInfoRequest| { &mut m.packages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "apps",
            |m: &CMsgClientPICSProductInfoRequest| { &m.apps },
            |m: &mut CMsgClientPICSProductInfoRequest| { &mut m.apps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "meta_data_only",
            |m: &CMsgClientPICSProductInfoRequest| { &m.meta_data_only },
            |m: &mut CMsgClientPICSProductInfoRequest| { &mut m.meta_data_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_prev_failed",
            |m: &CMsgClientPICSProductInfoRequest| { &m.num_prev_failed },
            |m: &mut CMsgClientPICSProductInfoRequest| { &mut m.num_prev_failed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "supports_package_tokens",
            |m: &CMsgClientPICSProductInfoRequest| { &m.supports_package_tokens },
            |m: &mut CMsgClientPICSProductInfoRequest| { &mut m.supports_package_tokens },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientPICSProductInfoRequest>(
            "CMsgClientPICSProductInfoRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientPICSProductInfoRequest {
    const NAME: &'static str = "CMsgClientPICSProductInfoRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.packages.push(is.read_message()?);
                },
                18 => {
                    self.apps.push(is.read_message()?);
                },
                24 => {
                    self.meta_data_only = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.num_prev_failed = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.supports_package_tokens = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.packages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.meta_data_only {
            my_size += 1 + 1;
        }
        if let Some(v) = self.num_prev_failed {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.supports_package_tokens {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.packages {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.apps {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.meta_data_only {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.num_prev_failed {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.supports_package_tokens {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientPICSProductInfoRequest {
        CMsgClientPICSProductInfoRequest::new()
    }

    fn clear(&mut self) {
        self.packages.clear();
        self.apps.clear();
        self.meta_data_only = ::std::option::Option::None;
        self.num_prev_failed = ::std::option::Option::None;
        self.supports_package_tokens = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientPICSProductInfoRequest {
        static instance: CMsgClientPICSProductInfoRequest = CMsgClientPICSProductInfoRequest {
            packages: ::std::vec::Vec::new(),
            apps: ::std::vec::Vec::new(),
            meta_data_only: ::std::option::Option::None,
            num_prev_failed: ::std::option::Option::None,
            supports_package_tokens: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientPICSProductInfoRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientPICSProductInfoRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientPICSProductInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPICSProductInfoRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientPICSProductInfoRequest`
pub mod cmsg_client_picsproduct_info_request {
    // @@protoc_insertion_point(message:CMsgClientPICSProductInfoRequest.AppInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AppInfo {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientPICSProductInfoRequest.AppInfo.appid)
        pub appid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPICSProductInfoRequest.AppInfo.access_token)
        pub access_token: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientPICSProductInfoRequest.AppInfo.only_public_obsolete)
        pub only_public_obsolete: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientPICSProductInfoRequest.AppInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AppInfo {
        fn default() -> &'a AppInfo {
            <AppInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl AppInfo {
        pub fn new() -> AppInfo {
            ::std::default::Default::default()
        }

        // optional uint32 appid = 1;

        pub fn appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional uint64 access_token = 2;

        pub fn access_token(&self) -> u64 {
            self.access_token.unwrap_or(0)
        }

        pub fn clear_access_token(&mut self) {
            self.access_token = ::std::option::Option::None;
        }

        pub fn has_access_token(&self) -> bool {
            self.access_token.is_some()
        }

        // Param is passed by value, moved
        pub fn set_access_token(&mut self, v: u64) {
            self.access_token = ::std::option::Option::Some(v);
        }

        // optional bool only_public_obsolete = 3;

        pub fn only_public_obsolete(&self) -> bool {
            self.only_public_obsolete.unwrap_or(false)
        }

        pub fn clear_only_public_obsolete(&mut self) {
            self.only_public_obsolete = ::std::option::Option::None;
        }

        pub fn has_only_public_obsolete(&self) -> bool {
            self.only_public_obsolete.is_some()
        }

        // Param is passed by value, moved
        pub fn set_only_public_obsolete(&mut self, v: bool) {
            self.only_public_obsolete = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "appid",
                |m: &AppInfo| { &m.appid },
                |m: &mut AppInfo| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "access_token",
                |m: &AppInfo| { &m.access_token },
                |m: &mut AppInfo| { &mut m.access_token },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "only_public_obsolete",
                |m: &AppInfo| { &m.only_public_obsolete },
                |m: &mut AppInfo| { &mut m.only_public_obsolete },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AppInfo>(
                "CMsgClientPICSProductInfoRequest.AppInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AppInfo {
        const NAME: &'static str = "AppInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.access_token = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    24 => {
                        self.only_public_obsolete = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.appid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.access_token {
                my_size += ::protobuf::rt::uint64_size(2, v);
            }
            if let Some(v) = self.only_public_obsolete {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.appid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.access_token {
                os.write_uint64(2, v)?;
            }
            if let Some(v) = self.only_public_obsolete {
                os.write_bool(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AppInfo {
            AppInfo::new()
        }

        fn clear(&mut self) {
            self.appid = ::std::option::Option::None;
            self.access_token = ::std::option::Option::None;
            self.only_public_obsolete = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AppInfo {
            static instance: AppInfo = AppInfo {
                appid: ::std::option::Option::None,
                access_token: ::std::option::Option::None,
                only_public_obsolete: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AppInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientPICSProductInfoRequest.AppInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AppInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AppInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgClientPICSProductInfoRequest.PackageInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PackageInfo {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientPICSProductInfoRequest.PackageInfo.packageid)
        pub packageid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPICSProductInfoRequest.PackageInfo.access_token)
        pub access_token: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientPICSProductInfoRequest.PackageInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PackageInfo {
        fn default() -> &'a PackageInfo {
            <PackageInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl PackageInfo {
        pub fn new() -> PackageInfo {
            ::std::default::Default::default()
        }

        // optional uint32 packageid = 1;

        pub fn packageid(&self) -> u32 {
            self.packageid.unwrap_or(0)
        }

        pub fn clear_packageid(&mut self) {
            self.packageid = ::std::option::Option::None;
        }

        pub fn has_packageid(&self) -> bool {
            self.packageid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_packageid(&mut self, v: u32) {
            self.packageid = ::std::option::Option::Some(v);
        }

        // optional uint64 access_token = 2;

        pub fn access_token(&self) -> u64 {
            self.access_token.unwrap_or(0)
        }

        pub fn clear_access_token(&mut self) {
            self.access_token = ::std::option::Option::None;
        }

        pub fn has_access_token(&self) -> bool {
            self.access_token.is_some()
        }

        // Param is passed by value, moved
        pub fn set_access_token(&mut self, v: u64) {
            self.access_token = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "packageid",
                |m: &PackageInfo| { &m.packageid },
                |m: &mut PackageInfo| { &mut m.packageid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "access_token",
                |m: &PackageInfo| { &m.access_token },
                |m: &mut PackageInfo| { &mut m.access_token },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PackageInfo>(
                "CMsgClientPICSProductInfoRequest.PackageInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PackageInfo {
        const NAME: &'static str = "PackageInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.packageid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.access_token = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.packageid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.access_token {
                my_size += ::protobuf::rt::uint64_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.packageid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.access_token {
                os.write_uint64(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PackageInfo {
            PackageInfo::new()
        }

        fn clear(&mut self) {
            self.packageid = ::std::option::Option::None;
            self.access_token = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PackageInfo {
            static instance: PackageInfo = PackageInfo {
                packageid: ::std::option::Option::None,
                access_token: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PackageInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientPICSProductInfoRequest.PackageInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PackageInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PackageInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientPICSProductInfoResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientPICSProductInfoResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientPICSProductInfoResponse.apps)
    pub apps: ::std::vec::Vec<cmsg_client_picsproduct_info_response::AppInfo>,
    // @@protoc_insertion_point(field:CMsgClientPICSProductInfoResponse.unknown_appids)
    pub unknown_appids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgClientPICSProductInfoResponse.packages)
    pub packages: ::std::vec::Vec<cmsg_client_picsproduct_info_response::PackageInfo>,
    // @@protoc_insertion_point(field:CMsgClientPICSProductInfoResponse.unknown_packageids)
    pub unknown_packageids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgClientPICSProductInfoResponse.meta_data_only)
    pub meta_data_only: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientPICSProductInfoResponse.response_pending)
    pub response_pending: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientPICSProductInfoResponse.http_min_size)
    pub http_min_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientPICSProductInfoResponse.http_host)
    pub http_host: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientPICSProductInfoResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientPICSProductInfoResponse {
    fn default() -> &'a CMsgClientPICSProductInfoResponse {
        <CMsgClientPICSProductInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPICSProductInfoResponse {
    pub fn new() -> CMsgClientPICSProductInfoResponse {
        ::std::default::Default::default()
    }

    // optional bool meta_data_only = 5;

    pub fn meta_data_only(&self) -> bool {
        self.meta_data_only.unwrap_or(false)
    }

    pub fn clear_meta_data_only(&mut self) {
        self.meta_data_only = ::std::option::Option::None;
    }

    pub fn has_meta_data_only(&self) -> bool {
        self.meta_data_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_meta_data_only(&mut self, v: bool) {
        self.meta_data_only = ::std::option::Option::Some(v);
    }

    // optional bool response_pending = 6;

    pub fn response_pending(&self) -> bool {
        self.response_pending.unwrap_or(false)
    }

    pub fn clear_response_pending(&mut self) {
        self.response_pending = ::std::option::Option::None;
    }

    pub fn has_response_pending(&self) -> bool {
        self.response_pending.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response_pending(&mut self, v: bool) {
        self.response_pending = ::std::option::Option::Some(v);
    }

    // optional uint32 http_min_size = 7;

    pub fn http_min_size(&self) -> u32 {
        self.http_min_size.unwrap_or(0)
    }

    pub fn clear_http_min_size(&mut self) {
        self.http_min_size = ::std::option::Option::None;
    }

    pub fn has_http_min_size(&self) -> bool {
        self.http_min_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http_min_size(&mut self, v: u32) {
        self.http_min_size = ::std::option::Option::Some(v);
    }

    // optional string http_host = 8;

    pub fn http_host(&self) -> &str {
        match self.http_host.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_http_host(&mut self) {
        self.http_host = ::std::option::Option::None;
    }

    pub fn has_http_host(&self) -> bool {
        self.http_host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http_host(&mut self, v: ::std::string::String) {
        self.http_host = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http_host(&mut self) -> &mut ::std::string::String {
        if self.http_host.is_none() {
            self.http_host = ::std::option::Option::Some(::std::string::String::new());
        }
        self.http_host.as_mut().unwrap()
    }

    // Take field
    pub fn take_http_host(&mut self) -> ::std::string::String {
        self.http_host.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "apps",
            |m: &CMsgClientPICSProductInfoResponse| { &m.apps },
            |m: &mut CMsgClientPICSProductInfoResponse| { &mut m.apps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "unknown_appids",
            |m: &CMsgClientPICSProductInfoResponse| { &m.unknown_appids },
            |m: &mut CMsgClientPICSProductInfoResponse| { &mut m.unknown_appids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "packages",
            |m: &CMsgClientPICSProductInfoResponse| { &m.packages },
            |m: &mut CMsgClientPICSProductInfoResponse| { &mut m.packages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "unknown_packageids",
            |m: &CMsgClientPICSProductInfoResponse| { &m.unknown_packageids },
            |m: &mut CMsgClientPICSProductInfoResponse| { &mut m.unknown_packageids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "meta_data_only",
            |m: &CMsgClientPICSProductInfoResponse| { &m.meta_data_only },
            |m: &mut CMsgClientPICSProductInfoResponse| { &mut m.meta_data_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response_pending",
            |m: &CMsgClientPICSProductInfoResponse| { &m.response_pending },
            |m: &mut CMsgClientPICSProductInfoResponse| { &mut m.response_pending },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "http_min_size",
            |m: &CMsgClientPICSProductInfoResponse| { &m.http_min_size },
            |m: &mut CMsgClientPICSProductInfoResponse| { &mut m.http_min_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "http_host",
            |m: &CMsgClientPICSProductInfoResponse| { &m.http_host },
            |m: &mut CMsgClientPICSProductInfoResponse| { &mut m.http_host },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientPICSProductInfoResponse>(
            "CMsgClientPICSProductInfoResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientPICSProductInfoResponse {
    const NAME: &'static str = "CMsgClientPICSProductInfoResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.apps.push(is.read_message()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.unknown_appids)?;
                },
                16 => {
                    self.unknown_appids.push(is.read_uint32()?);
                },
                26 => {
                    self.packages.push(is.read_message()?);
                },
                34 => {
                    is.read_repeated_packed_uint32_into(&mut self.unknown_packageids)?;
                },
                32 => {
                    self.unknown_packageids.push(is.read_uint32()?);
                },
                40 => {
                    self.meta_data_only = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.response_pending = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.http_min_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.http_host = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.unknown_appids {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        for value in &self.packages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.unknown_packageids {
            my_size += ::protobuf::rt::uint32_size(4, *value);
        };
        if let Some(v) = self.meta_data_only {
            my_size += 1 + 1;
        }
        if let Some(v) = self.response_pending {
            my_size += 1 + 1;
        }
        if let Some(v) = self.http_min_size {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.http_host.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.apps {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.unknown_appids {
            os.write_uint32(2, *v)?;
        };
        for v in &self.packages {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.unknown_packageids {
            os.write_uint32(4, *v)?;
        };
        if let Some(v) = self.meta_data_only {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.response_pending {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.http_min_size {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.http_host.as_ref() {
            os.write_string(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientPICSProductInfoResponse {
        CMsgClientPICSProductInfoResponse::new()
    }

    fn clear(&mut self) {
        self.apps.clear();
        self.unknown_appids.clear();
        self.packages.clear();
        self.unknown_packageids.clear();
        self.meta_data_only = ::std::option::Option::None;
        self.response_pending = ::std::option::Option::None;
        self.http_min_size = ::std::option::Option::None;
        self.http_host = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientPICSProductInfoResponse {
        static instance: CMsgClientPICSProductInfoResponse = CMsgClientPICSProductInfoResponse {
            apps: ::std::vec::Vec::new(),
            unknown_appids: ::std::vec::Vec::new(),
            packages: ::std::vec::Vec::new(),
            unknown_packageids: ::std::vec::Vec::new(),
            meta_data_only: ::std::option::Option::None,
            response_pending: ::std::option::Option::None,
            http_min_size: ::std::option::Option::None,
            http_host: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientPICSProductInfoResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientPICSProductInfoResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientPICSProductInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPICSProductInfoResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientPICSProductInfoResponse`
pub mod cmsg_client_picsproduct_info_response {
    // @@protoc_insertion_point(message:CMsgClientPICSProductInfoResponse.AppInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AppInfo {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientPICSProductInfoResponse.AppInfo.appid)
        pub appid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPICSProductInfoResponse.AppInfo.change_number)
        pub change_number: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPICSProductInfoResponse.AppInfo.missing_token)
        pub missing_token: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientPICSProductInfoResponse.AppInfo.sha)
        pub sha: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:CMsgClientPICSProductInfoResponse.AppInfo.buffer)
        pub buffer: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:CMsgClientPICSProductInfoResponse.AppInfo.only_public)
        pub only_public: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientPICSProductInfoResponse.AppInfo.size)
        pub size: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientPICSProductInfoResponse.AppInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AppInfo {
        fn default() -> &'a AppInfo {
            <AppInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl AppInfo {
        pub fn new() -> AppInfo {
            ::std::default::Default::default()
        }

        // optional uint32 appid = 1;

        pub fn appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional uint32 change_number = 2;

        pub fn change_number(&self) -> u32 {
            self.change_number.unwrap_or(0)
        }

        pub fn clear_change_number(&mut self) {
            self.change_number = ::std::option::Option::None;
        }

        pub fn has_change_number(&self) -> bool {
            self.change_number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_change_number(&mut self, v: u32) {
            self.change_number = ::std::option::Option::Some(v);
        }

        // optional bool missing_token = 3;

        pub fn missing_token(&self) -> bool {
            self.missing_token.unwrap_or(false)
        }

        pub fn clear_missing_token(&mut self) {
            self.missing_token = ::std::option::Option::None;
        }

        pub fn has_missing_token(&self) -> bool {
            self.missing_token.is_some()
        }

        // Param is passed by value, moved
        pub fn set_missing_token(&mut self, v: bool) {
            self.missing_token = ::std::option::Option::Some(v);
        }

        // optional bytes sha = 4;

        pub fn sha(&self) -> &[u8] {
            match self.sha.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_sha(&mut self) {
            self.sha = ::std::option::Option::None;
        }

        pub fn has_sha(&self) -> bool {
            self.sha.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sha(&mut self, v: ::std::vec::Vec<u8>) {
            self.sha = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_sha(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.sha.is_none() {
                self.sha = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.sha.as_mut().unwrap()
        }

        // Take field
        pub fn take_sha(&mut self) -> ::std::vec::Vec<u8> {
            self.sha.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional bytes buffer = 5;

        pub fn buffer(&self) -> &[u8] {
            match self.buffer.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_buffer(&mut self) {
            self.buffer = ::std::option::Option::None;
        }

        pub fn has_buffer(&self) -> bool {
            self.buffer.is_some()
        }

        // Param is passed by value, moved
        pub fn set_buffer(&mut self, v: ::std::vec::Vec<u8>) {
            self.buffer = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_buffer(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.buffer.is_none() {
                self.buffer = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.buffer.as_mut().unwrap()
        }

        // Take field
        pub fn take_buffer(&mut self) -> ::std::vec::Vec<u8> {
            self.buffer.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional bool only_public = 6;

        pub fn only_public(&self) -> bool {
            self.only_public.unwrap_or(false)
        }

        pub fn clear_only_public(&mut self) {
            self.only_public = ::std::option::Option::None;
        }

        pub fn has_only_public(&self) -> bool {
            self.only_public.is_some()
        }

        // Param is passed by value, moved
        pub fn set_only_public(&mut self, v: bool) {
            self.only_public = ::std::option::Option::Some(v);
        }

        // optional uint32 size = 7;

        pub fn size(&self) -> u32 {
            self.size.unwrap_or(0)
        }

        pub fn clear_size(&mut self) {
            self.size = ::std::option::Option::None;
        }

        pub fn has_size(&self) -> bool {
            self.size.is_some()
        }

        // Param is passed by value, moved
        pub fn set_size(&mut self, v: u32) {
            self.size = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(7);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "appid",
                |m: &AppInfo| { &m.appid },
                |m: &mut AppInfo| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "change_number",
                |m: &AppInfo| { &m.change_number },
                |m: &mut AppInfo| { &mut m.change_number },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "missing_token",
                |m: &AppInfo| { &m.missing_token },
                |m: &mut AppInfo| { &mut m.missing_token },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sha",
                |m: &AppInfo| { &m.sha },
                |m: &mut AppInfo| { &mut m.sha },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "buffer",
                |m: &AppInfo| { &m.buffer },
                |m: &mut AppInfo| { &mut m.buffer },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "only_public",
                |m: &AppInfo| { &m.only_public },
                |m: &mut AppInfo| { &mut m.only_public },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "size",
                |m: &AppInfo| { &m.size },
                |m: &mut AppInfo| { &mut m.size },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AppInfo>(
                "CMsgClientPICSProductInfoResponse.AppInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AppInfo {
        const NAME: &'static str = "AppInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.change_number = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.missing_token = ::std::option::Option::Some(is.read_bool()?);
                    },
                    34 => {
                        self.sha = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    42 => {
                        self.buffer = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    48 => {
                        self.only_public = ::std::option::Option::Some(is.read_bool()?);
                    },
                    56 => {
                        self.size = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.appid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.change_number {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.missing_token {
                my_size += 1 + 1;
            }
            if let Some(v) = self.sha.as_ref() {
                my_size += ::protobuf::rt::bytes_size(4, &v);
            }
            if let Some(v) = self.buffer.as_ref() {
                my_size += ::protobuf::rt::bytes_size(5, &v);
            }
            if let Some(v) = self.only_public {
                my_size += 1 + 1;
            }
            if let Some(v) = self.size {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.appid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.change_number {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.missing_token {
                os.write_bool(3, v)?;
            }
            if let Some(v) = self.sha.as_ref() {
                os.write_bytes(4, v)?;
            }
            if let Some(v) = self.buffer.as_ref() {
                os.write_bytes(5, v)?;
            }
            if let Some(v) = self.only_public {
                os.write_bool(6, v)?;
            }
            if let Some(v) = self.size {
                os.write_uint32(7, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AppInfo {
            AppInfo::new()
        }

        fn clear(&mut self) {
            self.appid = ::std::option::Option::None;
            self.change_number = ::std::option::Option::None;
            self.missing_token = ::std::option::Option::None;
            self.sha = ::std::option::Option::None;
            self.buffer = ::std::option::Option::None;
            self.only_public = ::std::option::Option::None;
            self.size = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AppInfo {
            static instance: AppInfo = AppInfo {
                appid: ::std::option::Option::None,
                change_number: ::std::option::Option::None,
                missing_token: ::std::option::Option::None,
                sha: ::std::option::Option::None,
                buffer: ::std::option::Option::None,
                only_public: ::std::option::Option::None,
                size: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AppInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientPICSProductInfoResponse.AppInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AppInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AppInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgClientPICSProductInfoResponse.PackageInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PackageInfo {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientPICSProductInfoResponse.PackageInfo.packageid)
        pub packageid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPICSProductInfoResponse.PackageInfo.change_number)
        pub change_number: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPICSProductInfoResponse.PackageInfo.missing_token)
        pub missing_token: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientPICSProductInfoResponse.PackageInfo.sha)
        pub sha: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:CMsgClientPICSProductInfoResponse.PackageInfo.buffer)
        pub buffer: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:CMsgClientPICSProductInfoResponse.PackageInfo.size)
        pub size: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientPICSProductInfoResponse.PackageInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PackageInfo {
        fn default() -> &'a PackageInfo {
            <PackageInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl PackageInfo {
        pub fn new() -> PackageInfo {
            ::std::default::Default::default()
        }

        // optional uint32 packageid = 1;

        pub fn packageid(&self) -> u32 {
            self.packageid.unwrap_or(0)
        }

        pub fn clear_packageid(&mut self) {
            self.packageid = ::std::option::Option::None;
        }

        pub fn has_packageid(&self) -> bool {
            self.packageid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_packageid(&mut self, v: u32) {
            self.packageid = ::std::option::Option::Some(v);
        }

        // optional uint32 change_number = 2;

        pub fn change_number(&self) -> u32 {
            self.change_number.unwrap_or(0)
        }

        pub fn clear_change_number(&mut self) {
            self.change_number = ::std::option::Option::None;
        }

        pub fn has_change_number(&self) -> bool {
            self.change_number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_change_number(&mut self, v: u32) {
            self.change_number = ::std::option::Option::Some(v);
        }

        // optional bool missing_token = 3;

        pub fn missing_token(&self) -> bool {
            self.missing_token.unwrap_or(false)
        }

        pub fn clear_missing_token(&mut self) {
            self.missing_token = ::std::option::Option::None;
        }

        pub fn has_missing_token(&self) -> bool {
            self.missing_token.is_some()
        }

        // Param is passed by value, moved
        pub fn set_missing_token(&mut self, v: bool) {
            self.missing_token = ::std::option::Option::Some(v);
        }

        // optional bytes sha = 4;

        pub fn sha(&self) -> &[u8] {
            match self.sha.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_sha(&mut self) {
            self.sha = ::std::option::Option::None;
        }

        pub fn has_sha(&self) -> bool {
            self.sha.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sha(&mut self, v: ::std::vec::Vec<u8>) {
            self.sha = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_sha(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.sha.is_none() {
                self.sha = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.sha.as_mut().unwrap()
        }

        // Take field
        pub fn take_sha(&mut self) -> ::std::vec::Vec<u8> {
            self.sha.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional bytes buffer = 5;

        pub fn buffer(&self) -> &[u8] {
            match self.buffer.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_buffer(&mut self) {
            self.buffer = ::std::option::Option::None;
        }

        pub fn has_buffer(&self) -> bool {
            self.buffer.is_some()
        }

        // Param is passed by value, moved
        pub fn set_buffer(&mut self, v: ::std::vec::Vec<u8>) {
            self.buffer = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_buffer(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.buffer.is_none() {
                self.buffer = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.buffer.as_mut().unwrap()
        }

        // Take field
        pub fn take_buffer(&mut self) -> ::std::vec::Vec<u8> {
            self.buffer.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional uint32 size = 6;

        pub fn size(&self) -> u32 {
            self.size.unwrap_or(0)
        }

        pub fn clear_size(&mut self) {
            self.size = ::std::option::Option::None;
        }

        pub fn has_size(&self) -> bool {
            self.size.is_some()
        }

        // Param is passed by value, moved
        pub fn set_size(&mut self, v: u32) {
            self.size = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "packageid",
                |m: &PackageInfo| { &m.packageid },
                |m: &mut PackageInfo| { &mut m.packageid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "change_number",
                |m: &PackageInfo| { &m.change_number },
                |m: &mut PackageInfo| { &mut m.change_number },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "missing_token",
                |m: &PackageInfo| { &m.missing_token },
                |m: &mut PackageInfo| { &mut m.missing_token },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sha",
                |m: &PackageInfo| { &m.sha },
                |m: &mut PackageInfo| { &mut m.sha },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "buffer",
                |m: &PackageInfo| { &m.buffer },
                |m: &mut PackageInfo| { &mut m.buffer },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "size",
                |m: &PackageInfo| { &m.size },
                |m: &mut PackageInfo| { &mut m.size },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PackageInfo>(
                "CMsgClientPICSProductInfoResponse.PackageInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PackageInfo {
        const NAME: &'static str = "PackageInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.packageid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.change_number = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.missing_token = ::std::option::Option::Some(is.read_bool()?);
                    },
                    34 => {
                        self.sha = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    42 => {
                        self.buffer = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    48 => {
                        self.size = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.packageid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.change_number {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.missing_token {
                my_size += 1 + 1;
            }
            if let Some(v) = self.sha.as_ref() {
                my_size += ::protobuf::rt::bytes_size(4, &v);
            }
            if let Some(v) = self.buffer.as_ref() {
                my_size += ::protobuf::rt::bytes_size(5, &v);
            }
            if let Some(v) = self.size {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.packageid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.change_number {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.missing_token {
                os.write_bool(3, v)?;
            }
            if let Some(v) = self.sha.as_ref() {
                os.write_bytes(4, v)?;
            }
            if let Some(v) = self.buffer.as_ref() {
                os.write_bytes(5, v)?;
            }
            if let Some(v) = self.size {
                os.write_uint32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PackageInfo {
            PackageInfo::new()
        }

        fn clear(&mut self) {
            self.packageid = ::std::option::Option::None;
            self.change_number = ::std::option::Option::None;
            self.missing_token = ::std::option::Option::None;
            self.sha = ::std::option::Option::None;
            self.buffer = ::std::option::Option::None;
            self.size = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PackageInfo {
            static instance: PackageInfo = PackageInfo {
                packageid: ::std::option::Option::None,
                change_number: ::std::option::Option::None,
                missing_token: ::std::option::Option::None,
                sha: ::std::option::Option::None,
                buffer: ::std::option::Option::None,
                size: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PackageInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientPICSProductInfoResponse.PackageInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PackageInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PackageInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientPICSAccessTokenRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientPICSAccessTokenRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientPICSAccessTokenRequest.packageids)
    pub packageids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgClientPICSAccessTokenRequest.appids)
    pub appids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientPICSAccessTokenRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientPICSAccessTokenRequest {
    fn default() -> &'a CMsgClientPICSAccessTokenRequest {
        <CMsgClientPICSAccessTokenRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPICSAccessTokenRequest {
    pub fn new() -> CMsgClientPICSAccessTokenRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "packageids",
            |m: &CMsgClientPICSAccessTokenRequest| { &m.packageids },
            |m: &mut CMsgClientPICSAccessTokenRequest| { &mut m.packageids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "appids",
            |m: &CMsgClientPICSAccessTokenRequest| { &m.appids },
            |m: &mut CMsgClientPICSAccessTokenRequest| { &mut m.appids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientPICSAccessTokenRequest>(
            "CMsgClientPICSAccessTokenRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientPICSAccessTokenRequest {
    const NAME: &'static str = "CMsgClientPICSAccessTokenRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.packageids)?;
                },
                8 => {
                    self.packageids.push(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.appids)?;
                },
                16 => {
                    self.appids.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.packageids {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        for value in &self.appids {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.packageids {
            os.write_uint32(1, *v)?;
        };
        for v in &self.appids {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientPICSAccessTokenRequest {
        CMsgClientPICSAccessTokenRequest::new()
    }

    fn clear(&mut self) {
        self.packageids.clear();
        self.appids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientPICSAccessTokenRequest {
        static instance: CMsgClientPICSAccessTokenRequest = CMsgClientPICSAccessTokenRequest {
            packageids: ::std::vec::Vec::new(),
            appids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientPICSAccessTokenRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientPICSAccessTokenRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientPICSAccessTokenRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPICSAccessTokenRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientPICSAccessTokenResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientPICSAccessTokenResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientPICSAccessTokenResponse.package_access_tokens)
    pub package_access_tokens: ::std::vec::Vec<cmsg_client_picsaccess_token_response::PackageToken>,
    // @@protoc_insertion_point(field:CMsgClientPICSAccessTokenResponse.package_denied_tokens)
    pub package_denied_tokens: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgClientPICSAccessTokenResponse.app_access_tokens)
    pub app_access_tokens: ::std::vec::Vec<cmsg_client_picsaccess_token_response::AppToken>,
    // @@protoc_insertion_point(field:CMsgClientPICSAccessTokenResponse.app_denied_tokens)
    pub app_denied_tokens: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientPICSAccessTokenResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientPICSAccessTokenResponse {
    fn default() -> &'a CMsgClientPICSAccessTokenResponse {
        <CMsgClientPICSAccessTokenResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPICSAccessTokenResponse {
    pub fn new() -> CMsgClientPICSAccessTokenResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "package_access_tokens",
            |m: &CMsgClientPICSAccessTokenResponse| { &m.package_access_tokens },
            |m: &mut CMsgClientPICSAccessTokenResponse| { &mut m.package_access_tokens },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "package_denied_tokens",
            |m: &CMsgClientPICSAccessTokenResponse| { &m.package_denied_tokens },
            |m: &mut CMsgClientPICSAccessTokenResponse| { &mut m.package_denied_tokens },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "app_access_tokens",
            |m: &CMsgClientPICSAccessTokenResponse| { &m.app_access_tokens },
            |m: &mut CMsgClientPICSAccessTokenResponse| { &mut m.app_access_tokens },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "app_denied_tokens",
            |m: &CMsgClientPICSAccessTokenResponse| { &m.app_denied_tokens },
            |m: &mut CMsgClientPICSAccessTokenResponse| { &mut m.app_denied_tokens },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientPICSAccessTokenResponse>(
            "CMsgClientPICSAccessTokenResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientPICSAccessTokenResponse {
    const NAME: &'static str = "CMsgClientPICSAccessTokenResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.package_access_tokens.push(is.read_message()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.package_denied_tokens)?;
                },
                16 => {
                    self.package_denied_tokens.push(is.read_uint32()?);
                },
                26 => {
                    self.app_access_tokens.push(is.read_message()?);
                },
                34 => {
                    is.read_repeated_packed_uint32_into(&mut self.app_denied_tokens)?;
                },
                32 => {
                    self.app_denied_tokens.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.package_access_tokens {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.package_denied_tokens {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        for value in &self.app_access_tokens {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.app_denied_tokens {
            my_size += ::protobuf::rt::uint32_size(4, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.package_access_tokens {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.package_denied_tokens {
            os.write_uint32(2, *v)?;
        };
        for v in &self.app_access_tokens {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.app_denied_tokens {
            os.write_uint32(4, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientPICSAccessTokenResponse {
        CMsgClientPICSAccessTokenResponse::new()
    }

    fn clear(&mut self) {
        self.package_access_tokens.clear();
        self.package_denied_tokens.clear();
        self.app_access_tokens.clear();
        self.app_denied_tokens.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientPICSAccessTokenResponse {
        static instance: CMsgClientPICSAccessTokenResponse = CMsgClientPICSAccessTokenResponse {
            package_access_tokens: ::std::vec::Vec::new(),
            package_denied_tokens: ::std::vec::Vec::new(),
            app_access_tokens: ::std::vec::Vec::new(),
            app_denied_tokens: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientPICSAccessTokenResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientPICSAccessTokenResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientPICSAccessTokenResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPICSAccessTokenResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientPICSAccessTokenResponse`
pub mod cmsg_client_picsaccess_token_response {
    // @@protoc_insertion_point(message:CMsgClientPICSAccessTokenResponse.PackageToken)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PackageToken {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientPICSAccessTokenResponse.PackageToken.packageid)
        pub packageid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPICSAccessTokenResponse.PackageToken.access_token)
        pub access_token: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientPICSAccessTokenResponse.PackageToken.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PackageToken {
        fn default() -> &'a PackageToken {
            <PackageToken as ::protobuf::Message>::default_instance()
        }
    }

    impl PackageToken {
        pub fn new() -> PackageToken {
            ::std::default::Default::default()
        }

        // optional uint32 packageid = 1;

        pub fn packageid(&self) -> u32 {
            self.packageid.unwrap_or(0)
        }

        pub fn clear_packageid(&mut self) {
            self.packageid = ::std::option::Option::None;
        }

        pub fn has_packageid(&self) -> bool {
            self.packageid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_packageid(&mut self, v: u32) {
            self.packageid = ::std::option::Option::Some(v);
        }

        // optional uint64 access_token = 2;

        pub fn access_token(&self) -> u64 {
            self.access_token.unwrap_or(0)
        }

        pub fn clear_access_token(&mut self) {
            self.access_token = ::std::option::Option::None;
        }

        pub fn has_access_token(&self) -> bool {
            self.access_token.is_some()
        }

        // Param is passed by value, moved
        pub fn set_access_token(&mut self, v: u64) {
            self.access_token = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "packageid",
                |m: &PackageToken| { &m.packageid },
                |m: &mut PackageToken| { &mut m.packageid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "access_token",
                |m: &PackageToken| { &m.access_token },
                |m: &mut PackageToken| { &mut m.access_token },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PackageToken>(
                "CMsgClientPICSAccessTokenResponse.PackageToken",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PackageToken {
        const NAME: &'static str = "PackageToken";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.packageid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.access_token = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.packageid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.access_token {
                my_size += ::protobuf::rt::uint64_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.packageid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.access_token {
                os.write_uint64(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PackageToken {
            PackageToken::new()
        }

        fn clear(&mut self) {
            self.packageid = ::std::option::Option::None;
            self.access_token = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PackageToken {
            static instance: PackageToken = PackageToken {
                packageid: ::std::option::Option::None,
                access_token: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PackageToken {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientPICSAccessTokenResponse.PackageToken").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PackageToken {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PackageToken {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgClientPICSAccessTokenResponse.AppToken)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AppToken {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientPICSAccessTokenResponse.AppToken.appid)
        pub appid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientPICSAccessTokenResponse.AppToken.access_token)
        pub access_token: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientPICSAccessTokenResponse.AppToken.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AppToken {
        fn default() -> &'a AppToken {
            <AppToken as ::protobuf::Message>::default_instance()
        }
    }

    impl AppToken {
        pub fn new() -> AppToken {
            ::std::default::Default::default()
        }

        // optional uint32 appid = 1;

        pub fn appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional uint64 access_token = 2;

        pub fn access_token(&self) -> u64 {
            self.access_token.unwrap_or(0)
        }

        pub fn clear_access_token(&mut self) {
            self.access_token = ::std::option::Option::None;
        }

        pub fn has_access_token(&self) -> bool {
            self.access_token.is_some()
        }

        // Param is passed by value, moved
        pub fn set_access_token(&mut self, v: u64) {
            self.access_token = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "appid",
                |m: &AppToken| { &m.appid },
                |m: &mut AppToken| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "access_token",
                |m: &AppToken| { &m.access_token },
                |m: &mut AppToken| { &mut m.access_token },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AppToken>(
                "CMsgClientPICSAccessTokenResponse.AppToken",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AppToken {
        const NAME: &'static str = "AppToken";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.access_token = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.appid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.access_token {
                my_size += ::protobuf::rt::uint64_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.appid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.access_token {
                os.write_uint64(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AppToken {
            AppToken::new()
        }

        fn clear(&mut self) {
            self.appid = ::std::option::Option::None;
            self.access_token = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AppToken {
            static instance: AppToken = AppToken {
                appid: ::std::option::Option::None,
                access_token: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AppToken {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientPICSAccessTokenResponse.AppToken").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AppToken {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AppToken {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientUFSGetUGCDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUFSGetUGCDetails {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUFSGetUGCDetails.hcontent)
    pub hcontent: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUFSGetUGCDetails.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSGetUGCDetails {
    fn default() -> &'a CMsgClientUFSGetUGCDetails {
        <CMsgClientUFSGetUGCDetails as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSGetUGCDetails {
    pub fn new() -> CMsgClientUFSGetUGCDetails {
        ::std::default::Default::default()
    }

    // optional fixed64 hcontent = 1;

    pub fn hcontent(&self) -> u64 {
        self.hcontent.unwrap_or(18446744073709551615u64)
    }

    pub fn clear_hcontent(&mut self) {
        self.hcontent = ::std::option::Option::None;
    }

    pub fn has_hcontent(&self) -> bool {
        self.hcontent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hcontent(&mut self, v: u64) {
        self.hcontent = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hcontent",
            |m: &CMsgClientUFSGetUGCDetails| { &m.hcontent },
            |m: &mut CMsgClientUFSGetUGCDetails| { &mut m.hcontent },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUFSGetUGCDetails>(
            "CMsgClientUFSGetUGCDetails",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUFSGetUGCDetails {
    const NAME: &'static str = "CMsgClientUFSGetUGCDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.hcontent = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hcontent {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.hcontent {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUFSGetUGCDetails {
        CMsgClientUFSGetUGCDetails::new()
    }

    fn clear(&mut self) {
        self.hcontent = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUFSGetUGCDetails {
        static instance: CMsgClientUFSGetUGCDetails = CMsgClientUFSGetUGCDetails {
            hcontent: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUFSGetUGCDetails {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUFSGetUGCDetails").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUFSGetUGCDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSGetUGCDetails {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUFSGetUGCDetailsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUFSGetUGCDetailsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUFSGetUGCDetailsResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUFSGetUGCDetailsResponse.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUFSGetUGCDetailsResponse.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUFSGetUGCDetailsResponse.filename)
    pub filename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUFSGetUGCDetailsResponse.steamid_creator)
    pub steamid_creator: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUFSGetUGCDetailsResponse.file_size)
    pub file_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUFSGetUGCDetailsResponse.compressed_file_size)
    pub compressed_file_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUFSGetUGCDetailsResponse.rangecheck_host)
    pub rangecheck_host: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUFSGetUGCDetailsResponse.file_encoded_sha1)
    pub file_encoded_sha1: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUFSGetUGCDetailsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSGetUGCDetailsResponse {
    fn default() -> &'a CMsgClientUFSGetUGCDetailsResponse {
        <CMsgClientUFSGetUGCDetailsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSGetUGCDetailsResponse {
    pub fn new() -> CMsgClientUFSGetUGCDetailsResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 app_id = 3;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional string filename = 4;

    pub fn filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename = ::std::option::Option::None;
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 steamid_creator = 5;

    pub fn steamid_creator(&self) -> u64 {
        self.steamid_creator.unwrap_or(0)
    }

    pub fn clear_steamid_creator(&mut self) {
        self.steamid_creator = ::std::option::Option::None;
    }

    pub fn has_steamid_creator(&self) -> bool {
        self.steamid_creator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_creator(&mut self, v: u64) {
        self.steamid_creator = ::std::option::Option::Some(v);
    }

    // optional uint32 file_size = 6;

    pub fn file_size(&self) -> u32 {
        self.file_size.unwrap_or(0)
    }

    pub fn clear_file_size(&mut self) {
        self.file_size = ::std::option::Option::None;
    }

    pub fn has_file_size(&self) -> bool {
        self.file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: u32) {
        self.file_size = ::std::option::Option::Some(v);
    }

    // optional uint32 compressed_file_size = 7;

    pub fn compressed_file_size(&self) -> u32 {
        self.compressed_file_size.unwrap_or(0)
    }

    pub fn clear_compressed_file_size(&mut self) {
        self.compressed_file_size = ::std::option::Option::None;
    }

    pub fn has_compressed_file_size(&self) -> bool {
        self.compressed_file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_compressed_file_size(&mut self, v: u32) {
        self.compressed_file_size = ::std::option::Option::Some(v);
    }

    // optional string rangecheck_host = 8;

    pub fn rangecheck_host(&self) -> &str {
        match self.rangecheck_host.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_rangecheck_host(&mut self) {
        self.rangecheck_host = ::std::option::Option::None;
    }

    pub fn has_rangecheck_host(&self) -> bool {
        self.rangecheck_host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rangecheck_host(&mut self, v: ::std::string::String) {
        self.rangecheck_host = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rangecheck_host(&mut self) -> &mut ::std::string::String {
        if self.rangecheck_host.is_none() {
            self.rangecheck_host = ::std::option::Option::Some(::std::string::String::new());
        }
        self.rangecheck_host.as_mut().unwrap()
    }

    // Take field
    pub fn take_rangecheck_host(&mut self) -> ::std::string::String {
        self.rangecheck_host.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string file_encoded_sha1 = 9;

    pub fn file_encoded_sha1(&self) -> &str {
        match self.file_encoded_sha1.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_encoded_sha1(&mut self) {
        self.file_encoded_sha1 = ::std::option::Option::None;
    }

    pub fn has_file_encoded_sha1(&self) -> bool {
        self.file_encoded_sha1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_encoded_sha1(&mut self, v: ::std::string::String) {
        self.file_encoded_sha1 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_encoded_sha1(&mut self) -> &mut ::std::string::String {
        if self.file_encoded_sha1.is_none() {
            self.file_encoded_sha1 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.file_encoded_sha1.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_encoded_sha1(&mut self) -> ::std::string::String {
        self.file_encoded_sha1.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientUFSGetUGCDetailsResponse| { &m.eresult },
            |m: &mut CMsgClientUFSGetUGCDetailsResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgClientUFSGetUGCDetailsResponse| { &m.url },
            |m: &mut CMsgClientUFSGetUGCDetailsResponse| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientUFSGetUGCDetailsResponse| { &m.app_id },
            |m: &mut CMsgClientUFSGetUGCDetailsResponse| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "filename",
            |m: &CMsgClientUFSGetUGCDetailsResponse| { &m.filename },
            |m: &mut CMsgClientUFSGetUGCDetailsResponse| { &mut m.filename },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid_creator",
            |m: &CMsgClientUFSGetUGCDetailsResponse| { &m.steamid_creator },
            |m: &mut CMsgClientUFSGetUGCDetailsResponse| { &mut m.steamid_creator },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_size",
            |m: &CMsgClientUFSGetUGCDetailsResponse| { &m.file_size },
            |m: &mut CMsgClientUFSGetUGCDetailsResponse| { &mut m.file_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "compressed_file_size",
            |m: &CMsgClientUFSGetUGCDetailsResponse| { &m.compressed_file_size },
            |m: &mut CMsgClientUFSGetUGCDetailsResponse| { &mut m.compressed_file_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rangecheck_host",
            |m: &CMsgClientUFSGetUGCDetailsResponse| { &m.rangecheck_host },
            |m: &mut CMsgClientUFSGetUGCDetailsResponse| { &mut m.rangecheck_host },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_encoded_sha1",
            |m: &CMsgClientUFSGetUGCDetailsResponse| { &m.file_encoded_sha1 },
            |m: &mut CMsgClientUFSGetUGCDetailsResponse| { &mut m.file_encoded_sha1 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUFSGetUGCDetailsResponse>(
            "CMsgClientUFSGetUGCDetailsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUFSGetUGCDetailsResponse {
    const NAME: &'static str = "CMsgClientUFSGetUGCDetailsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.filename = ::std::option::Option::Some(is.read_string()?);
                },
                41 => {
                    self.steamid_creator = ::std::option::Option::Some(is.read_fixed64()?);
                },
                48 => {
                    self.file_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.compressed_file_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.rangecheck_host = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.file_encoded_sha1 = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.steamid_creator {
            my_size += 1 + 8;
        }
        if let Some(v) = self.file_size {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.compressed_file_size {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.rangecheck_host.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.file_encoded_sha1.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.filename.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.steamid_creator {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.file_size {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.compressed_file_size {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.rangecheck_host.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.file_encoded_sha1.as_ref() {
            os.write_string(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUFSGetUGCDetailsResponse {
        CMsgClientUFSGetUGCDetailsResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.filename = ::std::option::Option::None;
        self.steamid_creator = ::std::option::Option::None;
        self.file_size = ::std::option::Option::None;
        self.compressed_file_size = ::std::option::Option::None;
        self.rangecheck_host = ::std::option::Option::None;
        self.file_encoded_sha1 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUFSGetUGCDetailsResponse {
        static instance: CMsgClientUFSGetUGCDetailsResponse = CMsgClientUFSGetUGCDetailsResponse {
            eresult: ::std::option::Option::None,
            url: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            filename: ::std::option::Option::None,
            steamid_creator: ::std::option::Option::None,
            file_size: ::std::option::Option::None,
            compressed_file_size: ::std::option::Option::None,
            rangecheck_host: ::std::option::Option::None,
            file_encoded_sha1: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUFSGetUGCDetailsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUFSGetUGCDetailsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUFSGetUGCDetailsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSGetUGCDetailsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUFSGetSingleFileInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUFSGetSingleFileInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUFSGetSingleFileInfo.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUFSGetSingleFileInfo.file_name)
    pub file_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUFSGetSingleFileInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSGetSingleFileInfo {
    fn default() -> &'a CMsgClientUFSGetSingleFileInfo {
        <CMsgClientUFSGetSingleFileInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSGetSingleFileInfo {
    pub fn new() -> CMsgClientUFSGetSingleFileInfo {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional string file_name = 2;

    pub fn file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_name(&mut self) {
        self.file_name = ::std::option::Option::None;
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientUFSGetSingleFileInfo| { &m.app_id },
            |m: &mut CMsgClientUFSGetSingleFileInfo| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_name",
            |m: &CMsgClientUFSGetSingleFileInfo| { &m.file_name },
            |m: &mut CMsgClientUFSGetSingleFileInfo| { &mut m.file_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUFSGetSingleFileInfo>(
            "CMsgClientUFSGetSingleFileInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUFSGetSingleFileInfo {
    const NAME: &'static str = "CMsgClientUFSGetSingleFileInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.file_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.file_name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUFSGetSingleFileInfo {
        CMsgClientUFSGetSingleFileInfo::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.file_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUFSGetSingleFileInfo {
        static instance: CMsgClientUFSGetSingleFileInfo = CMsgClientUFSGetSingleFileInfo {
            app_id: ::std::option::Option::None,
            file_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUFSGetSingleFileInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUFSGetSingleFileInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUFSGetSingleFileInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSGetSingleFileInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUFSGetSingleFileInfoResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUFSGetSingleFileInfoResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUFSGetSingleFileInfoResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUFSGetSingleFileInfoResponse.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUFSGetSingleFileInfoResponse.file_name)
    pub file_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUFSGetSingleFileInfoResponse.sha_file)
    pub sha_file: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientUFSGetSingleFileInfoResponse.time_stamp)
    pub time_stamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUFSGetSingleFileInfoResponse.raw_file_size)
    pub raw_file_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUFSGetSingleFileInfoResponse.is_explicit_delete)
    pub is_explicit_delete: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUFSGetSingleFileInfoResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSGetSingleFileInfoResponse {
    fn default() -> &'a CMsgClientUFSGetSingleFileInfoResponse {
        <CMsgClientUFSGetSingleFileInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSGetSingleFileInfoResponse {
    pub fn new() -> CMsgClientUFSGetSingleFileInfoResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional string file_name = 3;

    pub fn file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_name(&mut self) {
        self.file_name = ::std::option::Option::None;
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes sha_file = 4;

    pub fn sha_file(&self) -> &[u8] {
        match self.sha_file.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sha_file(&mut self) {
        self.sha_file = ::std::option::Option::None;
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 time_stamp = 5;

    pub fn time_stamp(&self) -> u64 {
        self.time_stamp.unwrap_or(0)
    }

    pub fn clear_time_stamp(&mut self) {
        self.time_stamp = ::std::option::Option::None;
    }

    pub fn has_time_stamp(&self) -> bool {
        self.time_stamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_stamp(&mut self, v: u64) {
        self.time_stamp = ::std::option::Option::Some(v);
    }

    // optional uint32 raw_file_size = 6;

    pub fn raw_file_size(&self) -> u32 {
        self.raw_file_size.unwrap_or(0)
    }

    pub fn clear_raw_file_size(&mut self) {
        self.raw_file_size = ::std::option::Option::None;
    }

    pub fn has_raw_file_size(&self) -> bool {
        self.raw_file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_file_size(&mut self, v: u32) {
        self.raw_file_size = ::std::option::Option::Some(v);
    }

    // optional bool is_explicit_delete = 7;

    pub fn is_explicit_delete(&self) -> bool {
        self.is_explicit_delete.unwrap_or(false)
    }

    pub fn clear_is_explicit_delete(&mut self) {
        self.is_explicit_delete = ::std::option::Option::None;
    }

    pub fn has_is_explicit_delete(&self) -> bool {
        self.is_explicit_delete.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_explicit_delete(&mut self, v: bool) {
        self.is_explicit_delete = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientUFSGetSingleFileInfoResponse| { &m.eresult },
            |m: &mut CMsgClientUFSGetSingleFileInfoResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientUFSGetSingleFileInfoResponse| { &m.app_id },
            |m: &mut CMsgClientUFSGetSingleFileInfoResponse| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_name",
            |m: &CMsgClientUFSGetSingleFileInfoResponse| { &m.file_name },
            |m: &mut CMsgClientUFSGetSingleFileInfoResponse| { &mut m.file_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sha_file",
            |m: &CMsgClientUFSGetSingleFileInfoResponse| { &m.sha_file },
            |m: &mut CMsgClientUFSGetSingleFileInfoResponse| { &mut m.sha_file },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_stamp",
            |m: &CMsgClientUFSGetSingleFileInfoResponse| { &m.time_stamp },
            |m: &mut CMsgClientUFSGetSingleFileInfoResponse| { &mut m.time_stamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "raw_file_size",
            |m: &CMsgClientUFSGetSingleFileInfoResponse| { &m.raw_file_size },
            |m: &mut CMsgClientUFSGetSingleFileInfoResponse| { &mut m.raw_file_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_explicit_delete",
            |m: &CMsgClientUFSGetSingleFileInfoResponse| { &m.is_explicit_delete },
            |m: &mut CMsgClientUFSGetSingleFileInfoResponse| { &mut m.is_explicit_delete },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUFSGetSingleFileInfoResponse>(
            "CMsgClientUFSGetSingleFileInfoResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUFSGetSingleFileInfoResponse {
    const NAME: &'static str = "CMsgClientUFSGetSingleFileInfoResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.file_name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.sha_file = ::std::option::Option::Some(is.read_bytes()?);
                },
                40 => {
                    self.time_stamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.raw_file_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.is_explicit_delete = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.sha_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.time_stamp {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.raw_file_size {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.is_explicit_delete {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.file_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.sha_file.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.time_stamp {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.raw_file_size {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.is_explicit_delete {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUFSGetSingleFileInfoResponse {
        CMsgClientUFSGetSingleFileInfoResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.file_name = ::std::option::Option::None;
        self.sha_file = ::std::option::Option::None;
        self.time_stamp = ::std::option::Option::None;
        self.raw_file_size = ::std::option::Option::None;
        self.is_explicit_delete = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUFSGetSingleFileInfoResponse {
        static instance: CMsgClientUFSGetSingleFileInfoResponse = CMsgClientUFSGetSingleFileInfoResponse {
            eresult: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            file_name: ::std::option::Option::None,
            sha_file: ::std::option::Option::None,
            time_stamp: ::std::option::Option::None,
            raw_file_size: ::std::option::Option::None,
            is_explicit_delete: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUFSGetSingleFileInfoResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUFSGetSingleFileInfoResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUFSGetSingleFileInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSGetSingleFileInfoResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUFSShareFile)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUFSShareFile {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUFSShareFile.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUFSShareFile.file_name)
    pub file_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUFSShareFile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSShareFile {
    fn default() -> &'a CMsgClientUFSShareFile {
        <CMsgClientUFSShareFile as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSShareFile {
    pub fn new() -> CMsgClientUFSShareFile {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional string file_name = 2;

    pub fn file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_name(&mut self) {
        self.file_name = ::std::option::Option::None;
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientUFSShareFile| { &m.app_id },
            |m: &mut CMsgClientUFSShareFile| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_name",
            |m: &CMsgClientUFSShareFile| { &m.file_name },
            |m: &mut CMsgClientUFSShareFile| { &mut m.file_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUFSShareFile>(
            "CMsgClientUFSShareFile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUFSShareFile {
    const NAME: &'static str = "CMsgClientUFSShareFile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.file_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.file_name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUFSShareFile {
        CMsgClientUFSShareFile::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.file_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUFSShareFile {
        static instance: CMsgClientUFSShareFile = CMsgClientUFSShareFile {
            app_id: ::std::option::Option::None,
            file_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUFSShareFile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUFSShareFile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUFSShareFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSShareFile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientUFSShareFileResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUFSShareFileResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUFSShareFileResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientUFSShareFileResponse.hcontent)
    pub hcontent: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUFSShareFileResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSShareFileResponse {
    fn default() -> &'a CMsgClientUFSShareFileResponse {
        <CMsgClientUFSShareFileResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSShareFileResponse {
    pub fn new() -> CMsgClientUFSShareFileResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional fixed64 hcontent = 2;

    pub fn hcontent(&self) -> u64 {
        self.hcontent.unwrap_or(18446744073709551615u64)
    }

    pub fn clear_hcontent(&mut self) {
        self.hcontent = ::std::option::Option::None;
    }

    pub fn has_hcontent(&self) -> bool {
        self.hcontent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hcontent(&mut self, v: u64) {
        self.hcontent = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientUFSShareFileResponse| { &m.eresult },
            |m: &mut CMsgClientUFSShareFileResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hcontent",
            |m: &CMsgClientUFSShareFileResponse| { &m.hcontent },
            |m: &mut CMsgClientUFSShareFileResponse| { &mut m.hcontent },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUFSShareFileResponse>(
            "CMsgClientUFSShareFileResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUFSShareFileResponse {
    const NAME: &'static str = "CMsgClientUFSShareFileResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                17 => {
                    self.hcontent = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.hcontent {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.hcontent {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUFSShareFileResponse {
        CMsgClientUFSShareFileResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.hcontent = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUFSShareFileResponse {
        static instance: CMsgClientUFSShareFileResponse = CMsgClientUFSShareFileResponse {
            eresult: ::std::option::Option::None,
            hcontent: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUFSShareFileResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUFSShareFileResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUFSShareFileResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSShareFileResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientAMGetClanOfficers)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientAMGetClanOfficers {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientAMGetClanOfficers.steamid_clan)
    pub steamid_clan: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientAMGetClanOfficers.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientAMGetClanOfficers {
    fn default() -> &'a CMsgClientAMGetClanOfficers {
        <CMsgClientAMGetClanOfficers as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAMGetClanOfficers {
    pub fn new() -> CMsgClientAMGetClanOfficers {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_clan = 1;

    pub fn steamid_clan(&self) -> u64 {
        self.steamid_clan.unwrap_or(0)
    }

    pub fn clear_steamid_clan(&mut self) {
        self.steamid_clan = ::std::option::Option::None;
    }

    pub fn has_steamid_clan(&self) -> bool {
        self.steamid_clan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_clan(&mut self, v: u64) {
        self.steamid_clan = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid_clan",
            |m: &CMsgClientAMGetClanOfficers| { &m.steamid_clan },
            |m: &mut CMsgClientAMGetClanOfficers| { &mut m.steamid_clan },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientAMGetClanOfficers>(
            "CMsgClientAMGetClanOfficers",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientAMGetClanOfficers {
    const NAME: &'static str = "CMsgClientAMGetClanOfficers";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid_clan = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_clan {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid_clan {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientAMGetClanOfficers {
        CMsgClientAMGetClanOfficers::new()
    }

    fn clear(&mut self) {
        self.steamid_clan = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientAMGetClanOfficers {
        static instance: CMsgClientAMGetClanOfficers = CMsgClientAMGetClanOfficers {
            steamid_clan: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientAMGetClanOfficers {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientAMGetClanOfficers").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientAMGetClanOfficers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAMGetClanOfficers {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientAMGetClanOfficersResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientAMGetClanOfficersResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientAMGetClanOfficersResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientAMGetClanOfficersResponse.steamid_clan)
    pub steamid_clan: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientAMGetClanOfficersResponse.officer_count)
    pub officer_count: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientAMGetClanOfficersResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientAMGetClanOfficersResponse {
    fn default() -> &'a CMsgClientAMGetClanOfficersResponse {
        <CMsgClientAMGetClanOfficersResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAMGetClanOfficersResponse {
    pub fn new() -> CMsgClientAMGetClanOfficersResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid_clan = 2;

    pub fn steamid_clan(&self) -> u64 {
        self.steamid_clan.unwrap_or(0)
    }

    pub fn clear_steamid_clan(&mut self) {
        self.steamid_clan = ::std::option::Option::None;
    }

    pub fn has_steamid_clan(&self) -> bool {
        self.steamid_clan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_clan(&mut self, v: u64) {
        self.steamid_clan = ::std::option::Option::Some(v);
    }

    // optional int32 officer_count = 3;

    pub fn officer_count(&self) -> i32 {
        self.officer_count.unwrap_or(0)
    }

    pub fn clear_officer_count(&mut self) {
        self.officer_count = ::std::option::Option::None;
    }

    pub fn has_officer_count(&self) -> bool {
        self.officer_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_officer_count(&mut self, v: i32) {
        self.officer_count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgClientAMGetClanOfficersResponse| { &m.eresult },
            |m: &mut CMsgClientAMGetClanOfficersResponse| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid_clan",
            |m: &CMsgClientAMGetClanOfficersResponse| { &m.steamid_clan },
            |m: &mut CMsgClientAMGetClanOfficersResponse| { &mut m.steamid_clan },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "officer_count",
            |m: &CMsgClientAMGetClanOfficersResponse| { &m.officer_count },
            |m: &mut CMsgClientAMGetClanOfficersResponse| { &mut m.officer_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientAMGetClanOfficersResponse>(
            "CMsgClientAMGetClanOfficersResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientAMGetClanOfficersResponse {
    const NAME: &'static str = "CMsgClientAMGetClanOfficersResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                17 => {
                    self.steamid_clan = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.officer_count = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.steamid_clan {
            my_size += 1 + 8;
        }
        if let Some(v) = self.officer_count {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.steamid_clan {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.officer_count {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientAMGetClanOfficersResponse {
        CMsgClientAMGetClanOfficersResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.steamid_clan = ::std::option::Option::None;
        self.officer_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientAMGetClanOfficersResponse {
        static instance: CMsgClientAMGetClanOfficersResponse = CMsgClientAMGetClanOfficersResponse {
            eresult: ::std::option::Option::None,
            steamid_clan: ::std::option::Option::None,
            officer_count: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientAMGetClanOfficersResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientAMGetClanOfficersResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientAMGetClanOfficersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAMGetClanOfficersResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientAMGetPersonaNameHistory)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientAMGetPersonaNameHistory {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientAMGetPersonaNameHistory.id_count)
    pub id_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientAMGetPersonaNameHistory.Ids)
    pub Ids: ::std::vec::Vec<cmsg_client_amget_persona_name_history::IdInstance>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientAMGetPersonaNameHistory.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientAMGetPersonaNameHistory {
    fn default() -> &'a CMsgClientAMGetPersonaNameHistory {
        <CMsgClientAMGetPersonaNameHistory as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAMGetPersonaNameHistory {
    pub fn new() -> CMsgClientAMGetPersonaNameHistory {
        ::std::default::Default::default()
    }

    // optional int32 id_count = 1;

    pub fn id_count(&self) -> i32 {
        self.id_count.unwrap_or(0)
    }

    pub fn clear_id_count(&mut self) {
        self.id_count = ::std::option::Option::None;
    }

    pub fn has_id_count(&self) -> bool {
        self.id_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id_count(&mut self, v: i32) {
        self.id_count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id_count",
            |m: &CMsgClientAMGetPersonaNameHistory| { &m.id_count },
            |m: &mut CMsgClientAMGetPersonaNameHistory| { &mut m.id_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Ids",
            |m: &CMsgClientAMGetPersonaNameHistory| { &m.Ids },
            |m: &mut CMsgClientAMGetPersonaNameHistory| { &mut m.Ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientAMGetPersonaNameHistory>(
            "CMsgClientAMGetPersonaNameHistory",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientAMGetPersonaNameHistory {
    const NAME: &'static str = "CMsgClientAMGetPersonaNameHistory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id_count = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.Ids.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id_count {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.Ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id_count {
            os.write_int32(1, v)?;
        }
        for v in &self.Ids {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientAMGetPersonaNameHistory {
        CMsgClientAMGetPersonaNameHistory::new()
    }

    fn clear(&mut self) {
        self.id_count = ::std::option::Option::None;
        self.Ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientAMGetPersonaNameHistory {
        static instance: CMsgClientAMGetPersonaNameHistory = CMsgClientAMGetPersonaNameHistory {
            id_count: ::std::option::Option::None,
            Ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientAMGetPersonaNameHistory {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientAMGetPersonaNameHistory").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientAMGetPersonaNameHistory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAMGetPersonaNameHistory {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientAMGetPersonaNameHistory`
pub mod cmsg_client_amget_persona_name_history {
    // @@protoc_insertion_point(message:CMsgClientAMGetPersonaNameHistory.IdInstance)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct IdInstance {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientAMGetPersonaNameHistory.IdInstance.steamid)
        pub steamid: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientAMGetPersonaNameHistory.IdInstance.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a IdInstance {
        fn default() -> &'a IdInstance {
            <IdInstance as ::protobuf::Message>::default_instance()
        }
    }

    impl IdInstance {
        pub fn new() -> IdInstance {
            ::std::default::Default::default()
        }

        // optional fixed64 steamid = 1;

        pub fn steamid(&self) -> u64 {
            self.steamid.unwrap_or(0)
        }

        pub fn clear_steamid(&mut self) {
            self.steamid = ::std::option::Option::None;
        }

        pub fn has_steamid(&self) -> bool {
            self.steamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid(&mut self, v: u64) {
            self.steamid = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "steamid",
                |m: &IdInstance| { &m.steamid },
                |m: &mut IdInstance| { &mut m.steamid },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IdInstance>(
                "CMsgClientAMGetPersonaNameHistory.IdInstance",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for IdInstance {
        const NAME: &'static str = "IdInstance";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steamid {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.steamid {
                os.write_fixed64(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> IdInstance {
            IdInstance::new()
        }

        fn clear(&mut self) {
            self.steamid = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static IdInstance {
            static instance: IdInstance = IdInstance {
                steamid: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for IdInstance {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientAMGetPersonaNameHistory.IdInstance").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for IdInstance {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for IdInstance {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientAMGetPersonaNameHistoryResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientAMGetPersonaNameHistoryResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientAMGetPersonaNameHistoryResponse.responses)
    pub responses: ::std::vec::Vec<cmsg_client_amget_persona_name_history_response::NameTableInstance>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientAMGetPersonaNameHistoryResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientAMGetPersonaNameHistoryResponse {
    fn default() -> &'a CMsgClientAMGetPersonaNameHistoryResponse {
        <CMsgClientAMGetPersonaNameHistoryResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAMGetPersonaNameHistoryResponse {
    pub fn new() -> CMsgClientAMGetPersonaNameHistoryResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "responses",
            |m: &CMsgClientAMGetPersonaNameHistoryResponse| { &m.responses },
            |m: &mut CMsgClientAMGetPersonaNameHistoryResponse| { &mut m.responses },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientAMGetPersonaNameHistoryResponse>(
            "CMsgClientAMGetPersonaNameHistoryResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientAMGetPersonaNameHistoryResponse {
    const NAME: &'static str = "CMsgClientAMGetPersonaNameHistoryResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.responses.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.responses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.responses {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientAMGetPersonaNameHistoryResponse {
        CMsgClientAMGetPersonaNameHistoryResponse::new()
    }

    fn clear(&mut self) {
        self.responses.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientAMGetPersonaNameHistoryResponse {
        static instance: CMsgClientAMGetPersonaNameHistoryResponse = CMsgClientAMGetPersonaNameHistoryResponse {
            responses: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientAMGetPersonaNameHistoryResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientAMGetPersonaNameHistoryResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientAMGetPersonaNameHistoryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAMGetPersonaNameHistoryResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientAMGetPersonaNameHistoryResponse`
pub mod cmsg_client_amget_persona_name_history_response {
    // @@protoc_insertion_point(message:CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct NameTableInstance {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance.eresult)
        pub eresult: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance.steamid)
        pub steamid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance.names)
        pub names: ::std::vec::Vec<name_table_instance::NameInstance>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a NameTableInstance {
        fn default() -> &'a NameTableInstance {
            <NameTableInstance as ::protobuf::Message>::default_instance()
        }
    }

    impl NameTableInstance {
        pub fn new() -> NameTableInstance {
            ::std::default::Default::default()
        }

        // optional int32 eresult = 1;

        pub fn eresult(&self) -> i32 {
            self.eresult.unwrap_or(2i32)
        }

        pub fn clear_eresult(&mut self) {
            self.eresult = ::std::option::Option::None;
        }

        pub fn has_eresult(&self) -> bool {
            self.eresult.is_some()
        }

        // Param is passed by value, moved
        pub fn set_eresult(&mut self, v: i32) {
            self.eresult = ::std::option::Option::Some(v);
        }

        // optional fixed64 steamid = 2;

        pub fn steamid(&self) -> u64 {
            self.steamid.unwrap_or(0)
        }

        pub fn clear_steamid(&mut self) {
            self.steamid = ::std::option::Option::None;
        }

        pub fn has_steamid(&self) -> bool {
            self.steamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid(&mut self, v: u64) {
            self.steamid = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "eresult",
                |m: &NameTableInstance| { &m.eresult },
                |m: &mut NameTableInstance| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "steamid",
                |m: &NameTableInstance| { &m.steamid },
                |m: &mut NameTableInstance| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "names",
                |m: &NameTableInstance| { &m.names },
                |m: &mut NameTableInstance| { &mut m.names },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NameTableInstance>(
                "CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for NameTableInstance {
        const NAME: &'static str = "NameTableInstance";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.eresult = ::std::option::Option::Some(is.read_int32()?);
                    },
                    17 => {
                        self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    26 => {
                        self.names.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.eresult {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.steamid {
                my_size += 1 + 8;
            }
            for value in &self.names {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.eresult {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.steamid {
                os.write_fixed64(2, v)?;
            }
            for v in &self.names {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> NameTableInstance {
            NameTableInstance::new()
        }

        fn clear(&mut self) {
            self.eresult = ::std::option::Option::None;
            self.steamid = ::std::option::Option::None;
            self.names.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static NameTableInstance {
            static instance: NameTableInstance = NameTableInstance {
                eresult: ::std::option::Option::None,
                steamid: ::std::option::Option::None,
                names: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for NameTableInstance {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for NameTableInstance {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for NameTableInstance {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `NameTableInstance`
    pub mod name_table_instance {
        // @@protoc_insertion_point(message:CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance.NameInstance)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct NameInstance {
            // message fields
            // @@protoc_insertion_point(field:CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance.NameInstance.name_since)
            pub name_since: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance.NameInstance.name)
            pub name: ::std::option::Option<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance.NameInstance.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a NameInstance {
            fn default() -> &'a NameInstance {
                <NameInstance as ::protobuf::Message>::default_instance()
            }
        }

        impl NameInstance {
            pub fn new() -> NameInstance {
                ::std::default::Default::default()
            }

            // optional fixed32 name_since = 1;

            pub fn name_since(&self) -> u32 {
                self.name_since.unwrap_or(0)
            }

            pub fn clear_name_since(&mut self) {
                self.name_since = ::std::option::Option::None;
            }

            pub fn has_name_since(&self) -> bool {
                self.name_since.is_some()
            }

            // Param is passed by value, moved
            pub fn set_name_since(&mut self, v: u32) {
                self.name_since = ::std::option::Option::Some(v);
            }

            // optional string name = 2;

            pub fn name(&self) -> &str {
                match self.name.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_name(&mut self) {
                self.name = ::std::option::Option::None;
            }

            pub fn has_name(&self) -> bool {
                self.name.is_some()
            }

            // Param is passed by value, moved
            pub fn set_name(&mut self, v: ::std::string::String) {
                self.name = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_name(&mut self) -> &mut ::std::string::String {
                if self.name.is_none() {
                    self.name = ::std::option::Option::Some(::std::string::String::new());
                }
                self.name.as_mut().unwrap()
            }

            // Take field
            pub fn take_name(&mut self) -> ::std::string::String {
                self.name.take().unwrap_or_else(|| ::std::string::String::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "name_since",
                    |m: &NameInstance| { &m.name_since },
                    |m: &mut NameInstance| { &mut m.name_since },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "name",
                    |m: &NameInstance| { &m.name },
                    |m: &mut NameInstance| { &mut m.name },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NameInstance>(
                    "CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance.NameInstance",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for NameInstance {
            const NAME: &'static str = "NameInstance";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        13 => {
                            self.name_since = ::std::option::Option::Some(is.read_fixed32()?);
                        },
                        18 => {
                            self.name = ::std::option::Option::Some(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.name_since {
                    my_size += 1 + 4;
                }
                if let Some(v) = self.name.as_ref() {
                    my_size += ::protobuf::rt::string_size(2, &v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.name_since {
                    os.write_fixed32(1, v)?;
                }
                if let Some(v) = self.name.as_ref() {
                    os.write_string(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> NameInstance {
                NameInstance::new()
            }

            fn clear(&mut self) {
                self.name_since = ::std::option::Option::None;
                self.name = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static NameInstance {
                static instance: NameInstance = NameInstance {
                    name_since: ::std::option::Option::None,
                    name: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for NameInstance {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance.NameInstance").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for NameInstance {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for NameInstance {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientDeregisterWithServer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientDeregisterWithServer {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientDeregisterWithServer.eservertype)
    pub eservertype: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientDeregisterWithServer.app_id)
    pub app_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientDeregisterWithServer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientDeregisterWithServer {
    fn default() -> &'a CMsgClientDeregisterWithServer {
        <CMsgClientDeregisterWithServer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientDeregisterWithServer {
    pub fn new() -> CMsgClientDeregisterWithServer {
        ::std::default::Default::default()
    }

    // optional uint32 eservertype = 1;

    pub fn eservertype(&self) -> u32 {
        self.eservertype.unwrap_or(0)
    }

    pub fn clear_eservertype(&mut self) {
        self.eservertype = ::std::option::Option::None;
    }

    pub fn has_eservertype(&self) -> bool {
        self.eservertype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eservertype(&mut self, v: u32) {
        self.eservertype = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eservertype",
            |m: &CMsgClientDeregisterWithServer| { &m.eservertype },
            |m: &mut CMsgClientDeregisterWithServer| { &mut m.eservertype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientDeregisterWithServer| { &m.app_id },
            |m: &mut CMsgClientDeregisterWithServer| { &mut m.app_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientDeregisterWithServer>(
            "CMsgClientDeregisterWithServer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientDeregisterWithServer {
    const NAME: &'static str = "CMsgClientDeregisterWithServer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eservertype = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eservertype {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eservertype {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientDeregisterWithServer {
        CMsgClientDeregisterWithServer::new()
    }

    fn clear(&mut self) {
        self.eservertype = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientDeregisterWithServer {
        static instance: CMsgClientDeregisterWithServer = CMsgClientDeregisterWithServer {
            eservertype: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientDeregisterWithServer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientDeregisterWithServer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientDeregisterWithServer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientDeregisterWithServer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientClanState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientClanState {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientClanState.steamid_clan)
    pub steamid_clan: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientClanState.clan_account_flags)
    pub clan_account_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientClanState.name_info)
    pub name_info: ::protobuf::MessageField<cmsg_client_clan_state::NameInfo>,
    // @@protoc_insertion_point(field:CMsgClientClanState.user_counts)
    pub user_counts: ::protobuf::MessageField<cmsg_client_clan_state::UserCounts>,
    // @@protoc_insertion_point(field:CMsgClientClanState.events)
    pub events: ::std::vec::Vec<cmsg_client_clan_state::Event>,
    // @@protoc_insertion_point(field:CMsgClientClanState.announcements)
    pub announcements: ::std::vec::Vec<cmsg_client_clan_state::Event>,
    // @@protoc_insertion_point(field:CMsgClientClanState.chat_room_private)
    pub chat_room_private: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientClanState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientClanState {
    fn default() -> &'a CMsgClientClanState {
        <CMsgClientClanState as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientClanState {
    pub fn new() -> CMsgClientClanState {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_clan = 1;

    pub fn steamid_clan(&self) -> u64 {
        self.steamid_clan.unwrap_or(0)
    }

    pub fn clear_steamid_clan(&mut self) {
        self.steamid_clan = ::std::option::Option::None;
    }

    pub fn has_steamid_clan(&self) -> bool {
        self.steamid_clan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_clan(&mut self, v: u64) {
        self.steamid_clan = ::std::option::Option::Some(v);
    }

    // optional uint32 clan_account_flags = 3;

    pub fn clan_account_flags(&self) -> u32 {
        self.clan_account_flags.unwrap_or(0)
    }

    pub fn clear_clan_account_flags(&mut self) {
        self.clan_account_flags = ::std::option::Option::None;
    }

    pub fn has_clan_account_flags(&self) -> bool {
        self.clan_account_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clan_account_flags(&mut self, v: u32) {
        self.clan_account_flags = ::std::option::Option::Some(v);
    }

    // optional bool chat_room_private = 8;

    pub fn chat_room_private(&self) -> bool {
        self.chat_room_private.unwrap_or(false)
    }

    pub fn clear_chat_room_private(&mut self) {
        self.chat_room_private = ::std::option::Option::None;
    }

    pub fn has_chat_room_private(&self) -> bool {
        self.chat_room_private.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_room_private(&mut self, v: bool) {
        self.chat_room_private = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid_clan",
            |m: &CMsgClientClanState| { &m.steamid_clan },
            |m: &mut CMsgClientClanState| { &mut m.steamid_clan },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "clan_account_flags",
            |m: &CMsgClientClanState| { &m.clan_account_flags },
            |m: &mut CMsgClientClanState| { &mut m.clan_account_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_client_clan_state::NameInfo>(
            "name_info",
            |m: &CMsgClientClanState| { &m.name_info },
            |m: &mut CMsgClientClanState| { &mut m.name_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_client_clan_state::UserCounts>(
            "user_counts",
            |m: &CMsgClientClanState| { &m.user_counts },
            |m: &mut CMsgClientClanState| { &mut m.user_counts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "events",
            |m: &CMsgClientClanState| { &m.events },
            |m: &mut CMsgClientClanState| { &mut m.events },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "announcements",
            |m: &CMsgClientClanState| { &m.announcements },
            |m: &mut CMsgClientClanState| { &mut m.announcements },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_room_private",
            |m: &CMsgClientClanState| { &m.chat_room_private },
            |m: &mut CMsgClientClanState| { &mut m.chat_room_private },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientClanState>(
            "CMsgClientClanState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientClanState {
    const NAME: &'static str = "CMsgClientClanState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid_clan = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.clan_account_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.name_info)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_counts)?;
                },
                50 => {
                    self.events.push(is.read_message()?);
                },
                58 => {
                    self.announcements.push(is.read_message()?);
                },
                64 => {
                    self.chat_room_private = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_clan {
            my_size += 1 + 8;
        }
        if let Some(v) = self.clan_account_flags {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.name_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.user_counts.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.announcements {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.chat_room_private {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid_clan {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.clan_account_flags {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.name_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.user_counts.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        for v in &self.events {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.announcements {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if let Some(v) = self.chat_room_private {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientClanState {
        CMsgClientClanState::new()
    }

    fn clear(&mut self) {
        self.steamid_clan = ::std::option::Option::None;
        self.clan_account_flags = ::std::option::Option::None;
        self.name_info.clear();
        self.user_counts.clear();
        self.events.clear();
        self.announcements.clear();
        self.chat_room_private = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientClanState {
        static instance: CMsgClientClanState = CMsgClientClanState {
            steamid_clan: ::std::option::Option::None,
            clan_account_flags: ::std::option::Option::None,
            name_info: ::protobuf::MessageField::none(),
            user_counts: ::protobuf::MessageField::none(),
            events: ::std::vec::Vec::new(),
            announcements: ::std::vec::Vec::new(),
            chat_room_private: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientClanState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientClanState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientClanState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientClanState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientClanState`
pub mod cmsg_client_clan_state {
    // @@protoc_insertion_point(message:CMsgClientClanState.NameInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct NameInfo {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientClanState.NameInfo.clan_name)
        pub clan_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientClanState.NameInfo.sha_avatar)
        pub sha_avatar: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientClanState.NameInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a NameInfo {
        fn default() -> &'a NameInfo {
            <NameInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl NameInfo {
        pub fn new() -> NameInfo {
            ::std::default::Default::default()
        }

        // optional string clan_name = 1;

        pub fn clan_name(&self) -> &str {
            match self.clan_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_clan_name(&mut self) {
            self.clan_name = ::std::option::Option::None;
        }

        pub fn has_clan_name(&self) -> bool {
            self.clan_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_clan_name(&mut self, v: ::std::string::String) {
            self.clan_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_clan_name(&mut self) -> &mut ::std::string::String {
            if self.clan_name.is_none() {
                self.clan_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.clan_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_clan_name(&mut self) -> ::std::string::String {
            self.clan_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bytes sha_avatar = 2;

        pub fn sha_avatar(&self) -> &[u8] {
            match self.sha_avatar.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_sha_avatar(&mut self) {
            self.sha_avatar = ::std::option::Option::None;
        }

        pub fn has_sha_avatar(&self) -> bool {
            self.sha_avatar.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sha_avatar(&mut self, v: ::std::vec::Vec<u8>) {
            self.sha_avatar = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_sha_avatar(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.sha_avatar.is_none() {
                self.sha_avatar = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.sha_avatar.as_mut().unwrap()
        }

        // Take field
        pub fn take_sha_avatar(&mut self) -> ::std::vec::Vec<u8> {
            self.sha_avatar.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "clan_name",
                |m: &NameInfo| { &m.clan_name },
                |m: &mut NameInfo| { &mut m.clan_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sha_avatar",
                |m: &NameInfo| { &m.sha_avatar },
                |m: &mut NameInfo| { &mut m.sha_avatar },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NameInfo>(
                "CMsgClientClanState.NameInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for NameInfo {
        const NAME: &'static str = "NameInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.clan_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.sha_avatar = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.clan_name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.sha_avatar.as_ref() {
                my_size += ::protobuf::rt::bytes_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.clan_name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.sha_avatar.as_ref() {
                os.write_bytes(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> NameInfo {
            NameInfo::new()
        }

        fn clear(&mut self) {
            self.clan_name = ::std::option::Option::None;
            self.sha_avatar = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static NameInfo {
            static instance: NameInfo = NameInfo {
                clan_name: ::std::option::Option::None,
                sha_avatar: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for NameInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientClanState.NameInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for NameInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for NameInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgClientClanState.UserCounts)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UserCounts {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientClanState.UserCounts.members)
        pub members: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientClanState.UserCounts.online)
        pub online: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientClanState.UserCounts.chatting)
        pub chatting: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientClanState.UserCounts.in_game)
        pub in_game: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientClanState.UserCounts.chat_room_members)
        pub chat_room_members: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientClanState.UserCounts.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UserCounts {
        fn default() -> &'a UserCounts {
            <UserCounts as ::protobuf::Message>::default_instance()
        }
    }

    impl UserCounts {
        pub fn new() -> UserCounts {
            ::std::default::Default::default()
        }

        // optional uint32 members = 1;

        pub fn members(&self) -> u32 {
            self.members.unwrap_or(0)
        }

        pub fn clear_members(&mut self) {
            self.members = ::std::option::Option::None;
        }

        pub fn has_members(&self) -> bool {
            self.members.is_some()
        }

        // Param is passed by value, moved
        pub fn set_members(&mut self, v: u32) {
            self.members = ::std::option::Option::Some(v);
        }

        // optional uint32 online = 2;

        pub fn online(&self) -> u32 {
            self.online.unwrap_or(0)
        }

        pub fn clear_online(&mut self) {
            self.online = ::std::option::Option::None;
        }

        pub fn has_online(&self) -> bool {
            self.online.is_some()
        }

        // Param is passed by value, moved
        pub fn set_online(&mut self, v: u32) {
            self.online = ::std::option::Option::Some(v);
        }

        // optional uint32 chatting = 3;

        pub fn chatting(&self) -> u32 {
            self.chatting.unwrap_or(0)
        }

        pub fn clear_chatting(&mut self) {
            self.chatting = ::std::option::Option::None;
        }

        pub fn has_chatting(&self) -> bool {
            self.chatting.is_some()
        }

        // Param is passed by value, moved
        pub fn set_chatting(&mut self, v: u32) {
            self.chatting = ::std::option::Option::Some(v);
        }

        // optional uint32 in_game = 4;

        pub fn in_game(&self) -> u32 {
            self.in_game.unwrap_or(0)
        }

        pub fn clear_in_game(&mut self) {
            self.in_game = ::std::option::Option::None;
        }

        pub fn has_in_game(&self) -> bool {
            self.in_game.is_some()
        }

        // Param is passed by value, moved
        pub fn set_in_game(&mut self, v: u32) {
            self.in_game = ::std::option::Option::Some(v);
        }

        // optional uint32 chat_room_members = 5;

        pub fn chat_room_members(&self) -> u32 {
            self.chat_room_members.unwrap_or(0)
        }

        pub fn clear_chat_room_members(&mut self) {
            self.chat_room_members = ::std::option::Option::None;
        }

        pub fn has_chat_room_members(&self) -> bool {
            self.chat_room_members.is_some()
        }

        // Param is passed by value, moved
        pub fn set_chat_room_members(&mut self, v: u32) {
            self.chat_room_members = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "members",
                |m: &UserCounts| { &m.members },
                |m: &mut UserCounts| { &mut m.members },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "online",
                |m: &UserCounts| { &m.online },
                |m: &mut UserCounts| { &mut m.online },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "chatting",
                |m: &UserCounts| { &m.chatting },
                |m: &mut UserCounts| { &mut m.chatting },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "in_game",
                |m: &UserCounts| { &m.in_game },
                |m: &mut UserCounts| { &mut m.in_game },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "chat_room_members",
                |m: &UserCounts| { &m.chat_room_members },
                |m: &mut UserCounts| { &mut m.chat_room_members },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserCounts>(
                "CMsgClientClanState.UserCounts",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for UserCounts {
        const NAME: &'static str = "UserCounts";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.members = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.online = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.chatting = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.in_game = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.chat_room_members = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.members {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.online {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.chatting {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.in_game {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.chat_room_members {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.members {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.online {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.chatting {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.in_game {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.chat_room_members {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UserCounts {
            UserCounts::new()
        }

        fn clear(&mut self) {
            self.members = ::std::option::Option::None;
            self.online = ::std::option::Option::None;
            self.chatting = ::std::option::Option::None;
            self.in_game = ::std::option::Option::None;
            self.chat_room_members = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UserCounts {
            static instance: UserCounts = UserCounts {
                members: ::std::option::Option::None,
                online: ::std::option::Option::None,
                chatting: ::std::option::Option::None,
                in_game: ::std::option::Option::None,
                chat_room_members: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for UserCounts {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientClanState.UserCounts").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for UserCounts {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for UserCounts {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgClientClanState.Event)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Event {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientClanState.Event.gid)
        pub gid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientClanState.Event.event_time)
        pub event_time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientClanState.Event.headline)
        pub headline: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientClanState.Event.game_id)
        pub game_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientClanState.Event.just_posted)
        pub just_posted: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientClanState.Event.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Event {
        fn default() -> &'a Event {
            <Event as ::protobuf::Message>::default_instance()
        }
    }

    impl Event {
        pub fn new() -> Event {
            ::std::default::Default::default()
        }

        // optional fixed64 gid = 1;

        pub fn gid(&self) -> u64 {
            self.gid.unwrap_or(0)
        }

        pub fn clear_gid(&mut self) {
            self.gid = ::std::option::Option::None;
        }

        pub fn has_gid(&self) -> bool {
            self.gid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gid(&mut self, v: u64) {
            self.gid = ::std::option::Option::Some(v);
        }

        // optional uint32 event_time = 2;

        pub fn event_time(&self) -> u32 {
            self.event_time.unwrap_or(0)
        }

        pub fn clear_event_time(&mut self) {
            self.event_time = ::std::option::Option::None;
        }

        pub fn has_event_time(&self) -> bool {
            self.event_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event_time(&mut self, v: u32) {
            self.event_time = ::std::option::Option::Some(v);
        }

        // optional string headline = 3;

        pub fn headline(&self) -> &str {
            match self.headline.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_headline(&mut self) {
            self.headline = ::std::option::Option::None;
        }

        pub fn has_headline(&self) -> bool {
            self.headline.is_some()
        }

        // Param is passed by value, moved
        pub fn set_headline(&mut self, v: ::std::string::String) {
            self.headline = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_headline(&mut self) -> &mut ::std::string::String {
            if self.headline.is_none() {
                self.headline = ::std::option::Option::Some(::std::string::String::new());
            }
            self.headline.as_mut().unwrap()
        }

        // Take field
        pub fn take_headline(&mut self) -> ::std::string::String {
            self.headline.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional fixed64 game_id = 4;

        pub fn game_id(&self) -> u64 {
            self.game_id.unwrap_or(0)
        }

        pub fn clear_game_id(&mut self) {
            self.game_id = ::std::option::Option::None;
        }

        pub fn has_game_id(&self) -> bool {
            self.game_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_id(&mut self, v: u64) {
            self.game_id = ::std::option::Option::Some(v);
        }

        // optional bool just_posted = 5;

        pub fn just_posted(&self) -> bool {
            self.just_posted.unwrap_or(false)
        }

        pub fn clear_just_posted(&mut self) {
            self.just_posted = ::std::option::Option::None;
        }

        pub fn has_just_posted(&self) -> bool {
            self.just_posted.is_some()
        }

        // Param is passed by value, moved
        pub fn set_just_posted(&mut self, v: bool) {
            self.just_posted = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "gid",
                |m: &Event| { &m.gid },
                |m: &mut Event| { &mut m.gid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "event_time",
                |m: &Event| { &m.event_time },
                |m: &mut Event| { &mut m.event_time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "headline",
                |m: &Event| { &m.headline },
                |m: &mut Event| { &mut m.headline },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_id",
                |m: &Event| { &m.game_id },
                |m: &mut Event| { &mut m.game_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "just_posted",
                |m: &Event| { &m.just_posted },
                |m: &mut Event| { &mut m.just_posted },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Event>(
                "CMsgClientClanState.Event",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Event {
        const NAME: &'static str = "Event";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.gid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.event_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.headline = ::std::option::Option::Some(is.read_string()?);
                    },
                    33 => {
                        self.game_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    40 => {
                        self.just_posted = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.gid {
                my_size += 1 + 8;
            }
            if let Some(v) = self.event_time {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.headline.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.game_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.just_posted {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.gid {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.event_time {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.headline.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.game_id {
                os.write_fixed64(4, v)?;
            }
            if let Some(v) = self.just_posted {
                os.write_bool(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Event {
            Event::new()
        }

        fn clear(&mut self) {
            self.gid = ::std::option::Option::None;
            self.event_time = ::std::option::Option::None;
            self.headline = ::std::option::Option::None;
            self.game_id = ::std::option::Option::None;
            self.just_posted = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Event {
            static instance: Event = Event {
                gid: ::std::option::Option::None,
                event_time: ::std::option::Option::None,
                headline: ::std::option::Option::None,
                game_id: ::std::option::Option::None,
                just_posted: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Event {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientClanState.Event").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Event {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Event {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgClientUnsignedInstallScript)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientUnsignedInstallScript {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientUnsignedInstallScript.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUnsignedInstallScript.file_name)
    pub file_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientUnsignedInstallScript.file_size)
    pub file_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUnsignedInstallScript.signature_broken)
    pub signature_broken: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientUnsignedInstallScript.depot_id)
    pub depot_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientUnsignedInstallScript.manifest_id)
    pub manifest_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientUnsignedInstallScript.file_flags)
    pub file_flags: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientUnsignedInstallScript.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientUnsignedInstallScript {
    fn default() -> &'a CMsgClientUnsignedInstallScript {
        <CMsgClientUnsignedInstallScript as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUnsignedInstallScript {
    pub fn new() -> CMsgClientUnsignedInstallScript {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional string file_name = 2;

    pub fn file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_name(&mut self) {
        self.file_name = ::std::option::Option::None;
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 file_size = 3;

    pub fn file_size(&self) -> u32 {
        self.file_size.unwrap_or(0)
    }

    pub fn clear_file_size(&mut self) {
        self.file_size = ::std::option::Option::None;
    }

    pub fn has_file_size(&self) -> bool {
        self.file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: u32) {
        self.file_size = ::std::option::Option::Some(v);
    }

    // optional bool signature_broken = 4;

    pub fn signature_broken(&self) -> bool {
        self.signature_broken.unwrap_or(false)
    }

    pub fn clear_signature_broken(&mut self) {
        self.signature_broken = ::std::option::Option::None;
    }

    pub fn has_signature_broken(&self) -> bool {
        self.signature_broken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature_broken(&mut self, v: bool) {
        self.signature_broken = ::std::option::Option::Some(v);
    }

    // optional uint32 depot_id = 5;

    pub fn depot_id(&self) -> u32 {
        self.depot_id.unwrap_or(0)
    }

    pub fn clear_depot_id(&mut self) {
        self.depot_id = ::std::option::Option::None;
    }

    pub fn has_depot_id(&self) -> bool {
        self.depot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_depot_id(&mut self, v: u32) {
        self.depot_id = ::std::option::Option::Some(v);
    }

    // optional uint64 manifest_id = 6;

    pub fn manifest_id(&self) -> u64 {
        self.manifest_id.unwrap_or(0)
    }

    pub fn clear_manifest_id(&mut self) {
        self.manifest_id = ::std::option::Option::None;
    }

    pub fn has_manifest_id(&self) -> bool {
        self.manifest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manifest_id(&mut self, v: u64) {
        self.manifest_id = ::std::option::Option::Some(v);
    }

    // optional uint32 file_flags = 7;

    pub fn file_flags(&self) -> u32 {
        self.file_flags.unwrap_or(0)
    }

    pub fn clear_file_flags(&mut self) {
        self.file_flags = ::std::option::Option::None;
    }

    pub fn has_file_flags(&self) -> bool {
        self.file_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_flags(&mut self, v: u32) {
        self.file_flags = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgClientUnsignedInstallScript| { &m.app_id },
            |m: &mut CMsgClientUnsignedInstallScript| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_name",
            |m: &CMsgClientUnsignedInstallScript| { &m.file_name },
            |m: &mut CMsgClientUnsignedInstallScript| { &mut m.file_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_size",
            |m: &CMsgClientUnsignedInstallScript| { &m.file_size },
            |m: &mut CMsgClientUnsignedInstallScript| { &mut m.file_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "signature_broken",
            |m: &CMsgClientUnsignedInstallScript| { &m.signature_broken },
            |m: &mut CMsgClientUnsignedInstallScript| { &mut m.signature_broken },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "depot_id",
            |m: &CMsgClientUnsignedInstallScript| { &m.depot_id },
            |m: &mut CMsgClientUnsignedInstallScript| { &mut m.depot_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "manifest_id",
            |m: &CMsgClientUnsignedInstallScript| { &m.manifest_id },
            |m: &mut CMsgClientUnsignedInstallScript| { &mut m.manifest_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_flags",
            |m: &CMsgClientUnsignedInstallScript| { &m.file_flags },
            |m: &mut CMsgClientUnsignedInstallScript| { &mut m.file_flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientUnsignedInstallScript>(
            "CMsgClientUnsignedInstallScript",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientUnsignedInstallScript {
    const NAME: &'static str = "CMsgClientUnsignedInstallScript";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.file_name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.file_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.signature_broken = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.depot_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.manifest_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                56 => {
                    self.file_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.file_size {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.signature_broken {
            my_size += 1 + 1;
        }
        if let Some(v) = self.depot_id {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.manifest_id {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.file_flags {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.file_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.file_size {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.signature_broken {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.depot_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.manifest_id {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.file_flags {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientUnsignedInstallScript {
        CMsgClientUnsignedInstallScript::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.file_name = ::std::option::Option::None;
        self.file_size = ::std::option::Option::None;
        self.signature_broken = ::std::option::Option::None;
        self.depot_id = ::std::option::Option::None;
        self.manifest_id = ::std::option::Option::None;
        self.file_flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientUnsignedInstallScript {
        static instance: CMsgClientUnsignedInstallScript = CMsgClientUnsignedInstallScript {
            app_id: ::std::option::Option::None,
            file_name: ::std::option::Option::None,
            file_size: ::std::option::Option::None,
            signature_broken: ::std::option::Option::None,
            depot_id: ::std::option::Option::None,
            manifest_id: ::std::option::Option::None,
            file_flags: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientUnsignedInstallScript {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientUnsignedInstallScript").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientUnsignedInstallScript {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUnsignedInstallScript {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EMMSLobbyStatus)
pub enum EMMSLobbyStatus {
    // @@protoc_insertion_point(enum_value:EMMSLobbyStatus.k_EMMSLobbyStatusInvalid)
    k_EMMSLobbyStatusInvalid = 0,
    // @@protoc_insertion_point(enum_value:EMMSLobbyStatus.k_EMMSLobbyStatusExists)
    k_EMMSLobbyStatusExists = 1,
    // @@protoc_insertion_point(enum_value:EMMSLobbyStatus.k_EMMSLobbyStatusDoesNotExist)
    k_EMMSLobbyStatusDoesNotExist = 2,
    // @@protoc_insertion_point(enum_value:EMMSLobbyStatus.k_EMMSLobbyStatusNotAMember)
    k_EMMSLobbyStatusNotAMember = 3,
}

impl ::protobuf::Enum for EMMSLobbyStatus {
    const NAME: &'static str = "EMMSLobbyStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EMMSLobbyStatus> {
        match value {
            0 => ::std::option::Option::Some(EMMSLobbyStatus::k_EMMSLobbyStatusInvalid),
            1 => ::std::option::Option::Some(EMMSLobbyStatus::k_EMMSLobbyStatusExists),
            2 => ::std::option::Option::Some(EMMSLobbyStatus::k_EMMSLobbyStatusDoesNotExist),
            3 => ::std::option::Option::Some(EMMSLobbyStatus::k_EMMSLobbyStatusNotAMember),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EMMSLobbyStatus> {
        match str {
            "k_EMMSLobbyStatusInvalid" => ::std::option::Option::Some(EMMSLobbyStatus::k_EMMSLobbyStatusInvalid),
            "k_EMMSLobbyStatusExists" => ::std::option::Option::Some(EMMSLobbyStatus::k_EMMSLobbyStatusExists),
            "k_EMMSLobbyStatusDoesNotExist" => ::std::option::Option::Some(EMMSLobbyStatus::k_EMMSLobbyStatusDoesNotExist),
            "k_EMMSLobbyStatusNotAMember" => ::std::option::Option::Some(EMMSLobbyStatus::k_EMMSLobbyStatusNotAMember),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EMMSLobbyStatus] = &[
        EMMSLobbyStatus::k_EMMSLobbyStatusInvalid,
        EMMSLobbyStatus::k_EMMSLobbyStatusExists,
        EMMSLobbyStatus::k_EMMSLobbyStatusDoesNotExist,
        EMMSLobbyStatus::k_EMMSLobbyStatusNotAMember,
    ];
}

impl ::protobuf::EnumFull for EMMSLobbyStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EMMSLobbyStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EMMSLobbyStatus {
    fn default() -> Self {
        EMMSLobbyStatus::k_EMMSLobbyStatusInvalid
    }
}

impl EMMSLobbyStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EMMSLobbyStatus>("EMMSLobbyStatus")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x20steammessages_clientserver.proto\x1a\x18steammessages_base.proto\
    \x1a\x1aencrypted_app_ticket.proto\"]\n\x1eCMsgClientUDSP2PSessionStarte\
    d\x12%\n\x0esteamid_remote\x18\x01\x20\x01(\x06R\rsteamidRemote\x12\x14\
    \n\x05appid\x18\x02\x20\x01(\x05R\x05appid\"\x87\x03\n\x1cCMsgClientUDSP\
    2PSessionEnded\x12%\n\x0esteamid_remote\x18\x01\x20\x01(\x06R\rsteamidRe\
    mote\x12\x14\n\x05appid\x18\x02\x20\x01(\x05R\x05appid\x12,\n\x12session\
    _length_sec\x18\x03\x20\x01(\x05R\x10sessionLengthSec\x12#\n\rsession_er\
    ror\x18\x04\x20\x01(\x05R\x0csessionError\x12\x18\n\x07nattype\x18\x05\
    \x20\x01(\x05R\x07nattype\x12\x1d\n\nbytes_recv\x18\x06\x20\x01(\x05R\tb\
    ytesRecv\x12\x1d\n\nbytes_sent\x18\x07\x20\x01(\x05R\tbytesSent\x12(\n\
    \x10bytes_sent_relay\x18\x08\x20\x01(\x05R\x0ebytesSentRelay\x12(\n\x10b\
    ytes_recv_relay\x18\t\x20\x01(\x05R\x0ebytesRecvRelay\x12+\n\x12time_to_\
    connect_ms\x18\n\x20\x01(\x05R\x0ftimeToConnectMs\"\x95\x01\n\"CMsgClien\
    tRegisterAuthTicketWithCM\x12)\n\x10protocol_version\x18\x01\x20\x01(\rR\
    \x0fprotocolVersion\x12\x16\n\x06ticket\x18\x03\x20\x01(\x0cR\x06ticket\
    \x12,\n\x12client_instance_id\x18\x04\x20\x01(\x04R\x10clientInstanceId\
    \"\xbb\x02\n\x1cCMsgClientTicketAuthComplete\x12\x19\n\x08steam_id\x18\
    \x01\x20\x01(\x06R\x07steamId\x12\x17\n\x07game_id\x18\x02\x20\x01(\x06R\
    \x06gameId\x12\x16\n\x06estate\x18\x03\x20\x01(\rR\x06estate\x124\n\x16e\
    auth_session_response\x18\x04\x20\x01(\rR\x14eauthSessionResponse\x12+\n\
    \x11DEPRECATED_ticket\x18\x05\x20\x01(\x0cR\x10DEPRECATEDTicket\x12\x1d\
    \n\nticket_crc\x18\x06\x20\x01(\rR\tticketCrc\x12'\n\x0fticket_sequence\
    \x18\x07\x20\x01(\rR\x0eticketSequence\x12$\n\x0eowner_steam_id\x18\x08\
    \x20\x01(\x06R\x0cownerSteamId\"\xc7\x01\n\x10CMsgClientCMList\x12!\n\
    \x0ccm_addresses\x18\x01\x20\x03(\rR\x0bcmAddresses\x12\x19\n\x08cm_port\
    s\x18\x02\x20\x03(\rR\x07cmPorts\x124\n\x16cm_websocket_addresses\x18\
    \x03\x20\x03(\tR\x14cmWebsocketAddresses\x12?\n\x1cpercent_default_to_we\
    bsocket\x18\x04\x20\x01(\rR\x19percentDefaultToWebsocket\"\xf1\x01\n\x1b\
    CMsgClientP2PConnectionInfo\x12\"\n\rsteam_id_dest\x18\x01\x20\x01(\x06R\
    \x0bsteamIdDest\x12\x20\n\x0csteam_id_src\x18\x02\x20\x01(\x06R\nsteamId\
    Src\x12\x15\n\x06app_id\x18\x03\x20\x01(\rR\x05appId\x12\x1c\n\tcandidat\
    e\x18\x04\x20\x01(\x0cR\tcandidate\x127\n\x18legacy_connection_id_src\
    \x18\x05\x20\x01(\x06R\x15legacyConnectionIdSrc\x12\x1e\n\nrendezvous\
    \x18\x06\x20\x01(\x0cR\nrendezvous\"\xa2\x02\n\x1fCMsgClientP2PConnectio\
    nFailInfo\x12\"\n\rsteam_id_dest\x18\x01\x20\x01(\x06R\x0bsteamIdDest\
    \x12\x20\n\x0csteam_id_src\x18\x02\x20\x01(\x06R\nsteamIdSrc\x12\x15\n\
    \x06app_id\x18\x03\x20\x01(\rR\x05appId\x12,\n\x12ep2p_session_error\x18\
    \x04\x20\x01(\rR\x10ep2pSessionError\x12,\n\x12connection_id_dest\x18\
    \x05\x20\x01(\x06R\x10connectionIdDest\x12!\n\x0cclose_reason\x18\x07\
    \x20\x01(\rR\x0bcloseReason\x12#\n\rclose_message\x18\x08\x20\x01(\tR\
    \x0ccloseMessage\"S\n\x1fCMsgClientNetworkingCertRequest\x12\x19\n\x08ke\
    y_data\x18\x02\x20\x01(\x0cR\x07keyData\x12\x15\n\x06app_id\x18\x03\x20\
    \x01(\rR\x05appId\"r\n\x1dCMsgClientNetworkingCertReply\x12\x12\n\x04cer\
    t\x18\x04\x20\x01(\x0cR\x04cert\x12\x1a\n\tca_key_id\x18\x05\x20\x01(\
    \x06R\x07caKeyId\x12!\n\x0cca_signature\x18\x06\x20\x01(\x0cR\x0bcaSigna\
    ture\">\n%CMsgClientNetworkingMobileCertRequest\x12\x15\n\x06app_id\x18\
    \x01\x20\x01(\rR\x05appId\"H\n#CMsgClientNetworkingMobileCertReply\x12!\
    \n\x0cencoded_cert\x18\x01\x20\x01(\tR\x0bencodedCert\"8\n\x1fCMsgClient\
    GetAppOwnershipTicket\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\"\
    u\n'CMsgClientGetAppOwnershipTicketResponse\x12\x1b\n\x07eresult\x18\x01\
    \x20\x01(\r:\x012R\x07eresult\x12\x15\n\x06app_id\x18\x02\x20\x01(\rR\
    \x05appId\x12\x16\n\x06ticket\x18\x03\x20\x01(\x0cR\x06ticket\".\n\x16CM\
    sgClientSessionToken\x12\x14\n\x05token\x18\x01\x20\x01(\x04R\x05token\"\
    f\n\x1bCMsgClientGameConnectTokens\x12/\n\x12max_tokens_to_keep\x18\x01\
    \x20\x01(\r:\x0210R\x0fmaxTokensToKeep\x12\x16\n\x06tokens\x18\x02\x20\
    \x03(\x0cR\x06tokens\"\x8c\x02\n\x10CMsgGSServerType\x12\"\n\rapp_id_ser\
    ved\x18\x01\x20\x01(\rR\x0bappIdServed\x12\x14\n\x05flags\x18\x02\x20\
    \x01(\rR\x05flags\x12;\n\x1adeprecated_game_ip_address\x18\x03\x20\x01(\
    \rR\x17deprecatedGameIpAddress\x12\x1b\n\tgame_port\x18\x04\x20\x01(\rR\
    \x08gamePort\x12\x19\n\x08game_dir\x18\x05\x20\x01(\tR\x07gameDir\x12!\n\
    \x0cgame_version\x18\x06\x20\x01(\tR\x0bgameVersion\x12&\n\x0fgame_query\
    _port\x18\x07\x20\x01(\rR\rgameQueryPort\"0\n\x11CMsgGSStatusReply\x12\
    \x1b\n\tis_secure\x18\x01\x20\x01(\x08R\x08isSecure\"\xe1\x01\n\x10CMsgG\
    SPlayerList\x122\n\x07players\x18\x01\x20\x03(\x0b2\x18.CMsgGSPlayerList\
    .PlayerR\x07players\x1a\x98\x01\n\x06Player\x12\x19\n\x08steam_id\x18\
    \x01\x20\x01(\x04R\x07steamId\x120\n\x14deprecated_public_ip\x18\x02\x20\
    \x01(\rR\x12deprecatedPublicIp\x12\x14\n\x05token\x18\x03\x20\x01(\x0cR\
    \x05token\x12+\n\tpublic_ip\x18\x04\x20\x01(\x0b2\x0e.CMsgIPAddressR\x08\
    publicIp\"\xa3\x01\n\x11CMsgGSUserPlaying\x12\x19\n\x08steam_id\x18\x01\
    \x20\x01(\x06R\x07steamId\x120\n\x14deprecated_public_ip\x18\x02\x20\x01\
    (\rR\x12deprecatedPublicIp\x12\x14\n\x05token\x18\x03\x20\x01(\x0cR\x05t\
    oken\x12+\n\tpublic_ip\x18\x04\x20\x01(\x0b2\x0e.CMsgIPAddressR\x08publi\
    cIp\"3\n\x16CMsgGSDisconnectNotice\x12\x19\n\x08steam_id\x18\x01\x20\x01\
    (\x06R\x07steamId\"\xf9\t\n\x15CMsgClientGamesPlayed\x12D\n\x0cgames_pla\
    yed\x18\x01\x20\x03(\x0b2!.CMsgClientGamesPlayed.GamePlayedR\x0bgamesPla\
    yed\x12$\n\x0eclient_os_type\x18\x02\x20\x01(\rR\x0cclientOsType\x122\n\
    \x15cloud_gaming_platform\x18\x03\x20\x01(\rR\x13cloudGamingPlatform\x1a\
    \xbf\x08\n\nGamePlayed\x12\x1e\n\x0bsteam_id_gs\x18\x01\x20\x01(\x04R\ts\
    teamIdGs\x12\x17\n\x07game_id\x18\x02\x20\x01(\x06R\x06gameId\x12;\n\x1a\
    deprecated_game_ip_address\x18\x03\x20\x01(\rR\x17deprecatedGameIpAddres\
    s\x12\x1b\n\tgame_port\x18\x04\x20\x01(\rR\x08gamePort\x12\x1b\n\tis_sec\
    ure\x18\x05\x20\x01(\x08R\x08isSecure\x12\x14\n\x05token\x18\x06\x20\x01\
    (\x0cR\x05token\x12&\n\x0fgame_extra_info\x18\x07\x20\x01(\tR\rgameExtra\
    Info\x12$\n\x0egame_data_blob\x18\x08\x20\x01(\x0cR\x0cgameDataBlob\x12\
    \x1d\n\nprocess_id\x18\t\x20\x01(\rR\tprocessId\x122\n\x15streaming_prov\
    ider_id\x18\n\x20\x01(\rR\x13streamingProviderId\x12\x1d\n\ngame_flags\
    \x18\x0b\x20\x01(\rR\tgameFlags\x12\x19\n\x08owner_id\x18\x0c\x20\x01(\r\
    R\x07ownerId\x12\"\n\rvr_hmd_vendor\x18\r\x20\x01(\tR\x0bvrHmdVendor\x12\
    \x20\n\x0cvr_hmd_model\x18\x0e\x20\x01(\tR\nvrHmdModel\x12/\n\x12launch_\
    option_type\x18\x0f\x20\x01(\r:\x010R\x10launchOptionType\x12:\n\x17prim\
    ary_controller_type\x18\x10\x20\x01(\x05:\x02-1R\x15primaryControllerTyp\
    e\x12E\n\x1fprimary_steam_controller_serial\x18\x11\x20\x01(\tR\x1cprima\
    rySteamControllerSerial\x12B\n\x1ctotal_steam_controller_count\x18\x12\
    \x20\x01(\r:\x010R\x19totalSteamControllerCount\x12I\n\x20total_non_stea\
    m_controller_count\x18\x13\x20\x01(\r:\x010R\x1ctotalNonSteamControllerC\
    ount\x12@\n\x1bcontroller_workshop_file_id\x18\x14\x20\x01(\x04:\x010R\
    \x18controllerWorkshopFileId\x12&\n\rlaunch_source\x18\x15\x20\x01(\r:\
    \x010R\x0claunchSource\x12$\n\x0evr_hmd_runtime\x18\x16\x20\x01(\rR\x0cv\
    rHmdRuntime\x126\n\x0fgame_ip_address\x18\x17\x20\x01(\x0b2\x0e.CMsgIPAd\
    dressR\rgameIpAddress\x12?\n\x1acontroller_connection_type\x18\x18\x20\
    \x01(\r:\x010R\x18controllerConnectionType\"P\n\rCMsgGSApprove\x12\x19\n\
    \x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\x12$\n\x0eowner_steam_id\
    \x18\x02\x20\x01(\x06R\x0cownerSteamId\"k\n\nCMsgGSDeny\x12\x19\n\x08ste\
    am_id\x18\x01\x20\x01(\x06R\x07steamId\x12!\n\x0cedeny_reason\x18\x02\
    \x20\x01(\x05R\x0bedenyReason\x12\x1f\n\x0bdeny_string\x18\x03\x20\x01(\
    \tR\ndenyString\"J\n\nCMsgGSKick\x12\x19\n\x08steam_id\x18\x01\x20\x01(\
    \x06R\x07steamId\x12!\n\x0cedeny_reason\x18\x02\x20\x01(\x05R\x0bedenyRe\
    ason\"\x8e\x02\n\x12CMsgClientAuthList\x12\x1f\n\x0btokens_left\x18\x01\
    \x20\x01(\rR\ntokensLeft\x12(\n\x10last_request_seq\x18\x02\x20\x01(\rR\
    \x0elastRequestSeq\x12>\n\x1clast_request_seq_from_server\x18\x03\x20\
    \x01(\rR\x18lastRequestSeqFromServer\x12)\n\x07tickets\x18\x04\x20\x03(\
    \x0b2\x0f.CMsgAuthTicketR\x07tickets\x12\x17\n\x07app_ids\x18\x05\x20\
    \x03(\rR\x06appIds\x12)\n\x10message_sequence\x18\x06\x20\x01(\rR\x0fmes\
    sageSequence\"z\n\x15CMsgClientAuthListAck\x12\x1d\n\nticket_crc\x18\x01\
    \x20\x03(\rR\tticketCrc\x12\x17\n\x07app_ids\x18\x02\x20\x03(\rR\x06appI\
    ds\x12)\n\x10message_sequence\x18\x03\x20\x01(\rR\x0fmessageSequence\"\
    \xa0\x06\n\x15CMsgClientLicenseList\x12\x1b\n\x07eresult\x18\x01\x20\x01\
    (\x05:\x012R\x07eresult\x12:\n\x08licenses\x18\x02\x20\x03(\x0b2\x1e.CMs\
    gClientLicenseList.LicenseR\x08licenses\x1a\xad\x05\n\x07License\x12\x1d\
    \n\npackage_id\x18\x01\x20\x01(\rR\tpackageId\x12!\n\x0ctime_created\x18\
    \x02\x20\x01(\x07R\x0btimeCreated\x12*\n\x11time_next_process\x18\x03\
    \x20\x01(\x07R\x0ftimeNextProcess\x12!\n\x0cminute_limit\x18\x04\x20\x01\
    (\x05R\x0bminuteLimit\x12!\n\x0cminutes_used\x18\x05\x20\x01(\x05R\x0bmi\
    nutesUsed\x12%\n\x0epayment_method\x18\x06\x20\x01(\rR\rpaymentMethod\
    \x12\x14\n\x05flags\x18\x07\x20\x01(\rR\x05flags\x122\n\x15purchase_coun\
    try_code\x18\x08\x20\x01(\tR\x13purchaseCountryCode\x12!\n\x0clicense_ty\
    pe\x18\t\x20\x01(\rR\x0blicenseType\x12%\n\x0eterritory_code\x18\n\x20\
    \x01(\x05R\rterritoryCode\x12#\n\rchange_number\x18\x0b\x20\x01(\x05R\
    \x0cchangeNumber\x12\x19\n\x08owner_id\x18\x0c\x20\x01(\rR\x07ownerId\
    \x12%\n\x0einitial_period\x18\r\x20\x01(\rR\rinitialPeriod\x12*\n\x11ini\
    tial_time_unit\x18\x0e\x20\x01(\rR\x0finitialTimeUnit\x12%\n\x0erenewal_\
    period\x18\x0f\x20\x01(\rR\rrenewalPeriod\x12*\n\x11renewal_time_unit\
    \x18\x10\x20\x01(\rR\x0frenewalTimeUnit\x12!\n\x0caccess_token\x18\x11\
    \x20\x01(\x04R\x0baccessToken\x12*\n\x11master_package_id\x18\x12\x20\
    \x01(\rR\x0fmasterPackageId\"\xb5\x01\n\x15CMsgClientLBSSetScore\x12\x15\
    \n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12%\n\x0eleaderboard_id\x18\
    \x02\x20\x01(\x05R\rleaderboardId\x12\x14\n\x05score\x18\x03\x20\x01(\
    \x05R\x05score\x12\x18\n\x07details\x18\x04\x20\x01(\x0cR\x07details\x12\
    .\n\x13upload_score_method\x18\x05\x20\x01(\x05R\x11uploadScoreMethod\"\
    \xf3\x01\n\x1dCMsgClientLBSSetScoreResponse\x12\x1b\n\x07eresult\x18\x01\
    \x20\x01(\x05:\x012R\x07eresult\x126\n\x17leaderboard_entry_count\x18\
    \x02\x20\x01(\x05R\x15leaderboardEntryCount\x12#\n\rscore_changed\x18\
    \x03\x20\x01(\x08R\x0cscoreChanged\x120\n\x14global_rank_previous\x18\
    \x04\x20\x01(\x05R\x12globalRankPrevious\x12&\n\x0fglobal_rank_new\x18\
    \x05\x20\x01(\x05R\rglobalRankNew\"j\n\x13CMsgClientLBSSetUGC\x12\x15\n\
    \x06app_id\x18\x01\x20\x01(\rR\x05appId\x12%\n\x0eleaderboard_id\x18\x02\
    \x20\x01(\x05R\rleaderboardId\x12\x15\n\x06ugc_id\x18\x03\x20\x01(\x06R\
    \x05ugcId\":\n\x1bCMsgClientLBSSetUGCResponse\x12\x1b\n\x07eresult\x18\
    \x01\x20\x01(\x05:\x012R\x07eresult\"\x80\x02\n\x1bCMsgClientLBSFindOrCr\
    eateLB\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x126\n\x17leader\
    board_sort_method\x18\x02\x20\x01(\x05R\x15leaderboardSortMethod\x128\n\
    \x18leaderboard_display_type\x18\x03\x20\x01(\x05R\x16leaderboardDisplay\
    Type\x12-\n\x13create_if_not_found\x18\x04\x20\x01(\x08R\x10createIfNotF\
    ound\x12)\n\x10leaderboard_name\x18\x05\x20\x01(\tR\x0fleaderboardName\"\
    \xc4\x02\n#CMsgClientLBSFindOrCreateLBResponse\x12\x1b\n\x07eresult\x18\
    \x01\x20\x01(\x05:\x012R\x07eresult\x12%\n\x0eleaderboard_id\x18\x02\x20\
    \x01(\x05R\rleaderboardId\x126\n\x17leaderboard_entry_count\x18\x03\x20\
    \x01(\x05R\x15leaderboardEntryCount\x129\n\x17leaderboard_sort_method\
    \x18\x04\x20\x01(\x05:\x010R\x15leaderboardSortMethod\x12;\n\x18leaderbo\
    ard_display_type\x18\x05\x20\x01(\x05:\x010R\x16leaderboardDisplayType\
    \x12)\n\x10leaderboard_name\x18\x06\x20\x01(\tR\x0fleaderboardName\"\xed\
    \x01\n\x19CMsgClientLBSGetLBEntries\x12\x15\n\x06app_id\x18\x01\x20\x01(\
    \x05R\x05appId\x12%\n\x0eleaderboard_id\x18\x02\x20\x01(\x05R\rleaderboa\
    rdId\x12\x1f\n\x0brange_start\x18\x03\x20\x01(\x05R\nrangeStart\x12\x1b\
    \n\trange_end\x18\x04\x20\x01(\x05R\x08rangeEnd\x128\n\x18leaderboard_da\
    ta_request\x18\x05\x20\x01(\x05R\x16leaderboardDataRequest\x12\x1a\n\x08\
    steamids\x18\x06\x20\x03(\x06R\x08steamids\"\xd2\x02\n!CMsgClientLBSGetL\
    BEntriesResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07ere\
    sult\x126\n\x17leaderboard_entry_count\x18\x02\x20\x01(\x05R\x15leaderbo\
    ardEntryCount\x12B\n\x07entries\x18\x03\x20\x03(\x0b2(.CMsgClientLBSGetL\
    BEntriesResponse.EntryR\x07entries\x1a\x93\x01\n\x05Entry\x12\"\n\rsteam\
    _id_user\x18\x01\x20\x01(\x06R\x0bsteamIdUser\x12\x1f\n\x0bglobal_rank\
    \x18\x02\x20\x01(\x05R\nglobalRank\x12\x14\n\x05score\x18\x03\x20\x01(\
    \x05R\x05score\x12\x18\n\x07details\x18\x04\x20\x01(\x0cR\x07details\x12\
    \x15\n\x06ugc_id\x18\x05\x20\x01(\x06R\x05ugcId\"\x8c\x02\n\x1aCMsgClien\
    tIsLimitedAccount\x12.\n\x13bis_limited_account\x18\x01\x20\x01(\x08R\
    \x11bisLimitedAccount\x120\n\x14bis_community_banned\x18\x02\x20\x01(\
    \x08R\x12bisCommunityBanned\x12,\n\x12bis_locked_account\x18\x03\x20\x01\
    (\x08R\x10bisLockedAccount\x12^\n-bis_limited_account_allowed_to_invite_\
    friends\x18\x04\x20\x01(\x08R'bisLimitedAccountAllowedToInviteFriends\"\
    \xd5\x01\n\x1eCMsgClientRequestedClientStats\x12O\n\rstats_to_send\x18\
    \x01\x20\x03(\x0b2+.CMsgClientRequestedClientStats.StatsToSendR\x0bstats\
    ToSend\x1ab\n\x0bStatsToSend\x12\x1f\n\x0bclient_stat\x18\x01\x20\x01(\r\
    R\nclientStat\x122\n\x15stat_aggregate_method\x18\x02\x20\x01(\rR\x13sta\
    tAggregateMethod\"\x85\x02\n\x0fCMsgClientStat2\x12<\n\x0bstat_detail\
    \x18\x01\x20\x03(\x0b2\x1b.CMsgClientStat2.StatDetailR\nstatDetail\x1a\
    \xb3\x01\n\nStatDetail\x12\x1f\n\x0bclient_stat\x18\x01\x20\x01(\rR\ncli\
    entStat\x12\x19\n\x08ll_value\x18\x02\x20\x01(\x03R\x07llValue\x12\x1e\n\
    \x0btime_of_day\x18\x03\x20\x01(\rR\ttimeOfDay\x12\x17\n\x07cell_id\x18\
    \x04\x20\x01(\rR\x06cellId\x12\x19\n\x08depot_id\x18\x05\x20\x01(\rR\x07\
    depotId\x12\x15\n\x06app_id\x18\x06\x20\x01(\rR\x05appId\"\xdf\x01\n'CMs\
    gClientMMSSetRatelimitPolicyOnClient\x12\x15\n\x06app_id\x18\x01\x20\x01\
    (\rR\x05appId\x12,\n\x12enable_rate_limits\x18\x02\x20\x01(\x08R\x10enab\
    leRateLimits\x12.\n\x13seconds_per_message\x18\x03\x20\x01(\x05R\x11seco\
    ndsPerMessage\x12?\n\x1cmilliseconds_per_data_update\x18\x04\x20\x01(\
    \x05R\x19millisecondsPerDataUpdate\"\xd4\x02\n\x18CMsgClientMMSCreateLob\
    by\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12\x1f\n\x0bmax_mem\
    bers\x18\x02\x20\x01(\x05R\nmaxMembers\x12\x1d\n\nlobby_type\x18\x03\x20\
    \x01(\x05R\tlobbyType\x12\x1f\n\x0blobby_flags\x18\x04\x20\x01(\x05R\nlo\
    bbyFlags\x12\x17\n\x07cell_id\x18\x05\x20\x01(\rR\x06cellId\x120\n\x14de\
    precated_public_ip\x18\x06\x20\x01(\rR\x12deprecatedPublicIp\x12\x1a\n\
    \x08metadata\x18\x07\x20\x01(\x0cR\x08metadata\x12,\n\x12persona_name_ow\
    ner\x18\x08\x20\x01(\tR\x10personaNameOwner\x12+\n\tpublic_ip\x18\t\x20\
    \x01(\x0b2\x0e.CMsgIPAddressR\x08publicIp\"|\n\x20CMsgClientMMSCreateLob\
    byResponse\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0est\
    eam_id_lobby\x18\x02\x20\x01(\x06R\x0csteamIdLobby\x12\x1b\n\x07eresult\
    \x18\x03\x20\x01(\x05:\x012R\x07eresult\"x\n\x16CMsgClientMMSJoinLobby\
    \x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lob\
    by\x18\x02\x20\x01(\x06R\x0csteamIdLobby\x12!\n\x0cpersona_name\x18\x03\
    \x20\x01(\tR\x0bpersonaName\"\xdf\x03\n\x1eCMsgClientMMSJoinLobbyRespons\
    e\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lo\
    bby\x18\x02\x20\x01(\x06R\x0csteamIdLobby\x127\n\x18chat_room_enter_resp\
    onse\x18\x03\x20\x01(\x05R\x15chatRoomEnterResponse\x12\x1f\n\x0bmax_mem\
    bers\x18\x04\x20\x01(\x05R\nmaxMembers\x12\x1d\n\nlobby_type\x18\x05\x20\
    \x01(\x05R\tlobbyType\x12\x1f\n\x0blobby_flags\x18\x06\x20\x01(\x05R\nlo\
    bbyFlags\x12$\n\x0esteam_id_owner\x18\x07\x20\x01(\x06R\x0csteamIdOwner\
    \x12\x1a\n\x08metadata\x18\x08\x20\x01(\x0cR\x08metadata\x12@\n\x07membe\
    rs\x18\t\x20\x03(\x0b2&.CMsgClientMMSJoinLobbyResponse.MemberR\x07member\
    s\x1ab\n\x06Member\x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamI\
    d\x12!\n\x0cpersona_name\x18\x02\x20\x01(\tR\x0bpersonaName\x12\x1a\n\
    \x08metadata\x18\x03\x20\x01(\x0cR\x08metadata\"V\n\x17CMsgClientMMSLeav\
    eLobby\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_\
    id_lobby\x18\x02\x20\x01(\x06R\x0csteamIdLobby\"{\n\x1fCMsgClientMMSLeav\
    eLobbyResponse\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\
    \x0esteam_id_lobby\x18\x02\x20\x01(\x06R\x0csteamIdLobby\x12\x1b\n\x07er\
    esult\x18\x03\x20\x01(\x05:\x012R\x07eresult\"\x90\x03\n\x19CMsgClientMM\
    SGetLobbyList\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x122\n\
    \x15num_lobbies_requested\x18\x03\x20\x01(\x05R\x13numLobbiesRequested\
    \x12\x17\n\x07cell_id\x18\x04\x20\x01(\rR\x06cellId\x120\n\x14deprecated\
    _public_ip\x18\x05\x20\x01(\rR\x12deprecatedPublicIp\x12;\n\x07filters\
    \x18\x06\x20\x03(\x0b2!.CMsgClientMMSGetLobbyList.FilterR\x07filters\x12\
    +\n\tpublic_ip\x18\x07\x20\x01(\x0b2\x0e.CMsgIPAddressR\x08publicIp\x1as\
    \n\x06Filter\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05va\
    lue\x18\x02\x20\x01(\tR\x05value\x12\x20\n\x0bcomparision\x18\x03\x20\
    \x01(\x05R\x0bcomparision\x12\x1f\n\x0bfilter_type\x18\x04\x20\x01(\x05R\
    \nfilterType\"\x92\x03\n!CMsgClientMMSGetLobbyListResponse\x12\x15\n\x06\
    app_id\x18\x01\x20\x01(\rR\x05appId\x12\x1b\n\x07eresult\x18\x03\x20\x01\
    (\x05:\x012R\x07eresult\x12B\n\x07lobbies\x18\x04\x20\x03(\x0b2(.CMsgCli\
    entMMSGetLobbyListResponse.LobbyR\x07lobbies\x1a\xf4\x01\n\x05Lobby\x12\
    \x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\x12\x1f\n\x0bmax_mem\
    bers\x18\x02\x20\x01(\x05R\nmaxMembers\x12\x1d\n\nlobby_type\x18\x03\x20\
    \x01(\x05R\tlobbyType\x12\x1f\n\x0blobby_flags\x18\x04\x20\x01(\x05R\nlo\
    bbyFlags\x12\x1a\n\x08metadata\x18\x05\x20\x01(\x0cR\x08metadata\x12\x1f\
    \n\x0bnum_members\x18\x06\x20\x01(\x05R\nnumMembers\x12\x1a\n\x08distanc\
    e\x18\x07\x20\x01(\x02R\x08distance\x12\x16\n\x06weight\x18\x08\x20\x01(\
    \x03R\x06weight\"\xfd\x01\n\x19CMsgClientMMSSetLobbyData\x12\x15\n\x06ap\
    p_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\x18\x02\x20\
    \x01(\x06R\x0csteamIdLobby\x12&\n\x0fsteam_id_member\x18\x03\x20\x01(\
    \x06R\rsteamIdMember\x12\x1f\n\x0bmax_members\x18\x04\x20\x01(\x05R\nmax\
    Members\x12\x1d\n\nlobby_type\x18\x05\x20\x01(\x05R\tlobbyType\x12\x1f\n\
    \x0blobby_flags\x18\x06\x20\x01(\x05R\nlobbyFlags\x12\x1a\n\x08metadata\
    \x18\x07\x20\x01(\x0cR\x08metadata\"}\n!CMsgClientMMSSetLobbyDataRespons\
    e\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lo\
    bby\x18\x02\x20\x01(\x06R\x0csteamIdLobby\x12\x1b\n\x07eresult\x18\x03\
    \x20\x01(\x05:\x012R\x07eresult\"X\n\x19CMsgClientMMSGetLobbyData\x12\
    \x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\
    \x18\x02\x20\x01(\x06R\x0csteamIdLobby\"\x99\x04\n\x16CMsgClientMMSLobby\
    Data\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id\
    _lobby\x18\x02\x20\x01(\x06R\x0csteamIdLobby\x12\x1f\n\x0bnum_members\
    \x18\x03\x20\x01(\x05R\nnumMembers\x12\x1f\n\x0bmax_members\x18\x04\x20\
    \x01(\x05R\nmaxMembers\x12\x1d\n\nlobby_type\x18\x05\x20\x01(\x05R\tlobb\
    yType\x12\x1f\n\x0blobby_flags\x18\x06\x20\x01(\x05R\nlobbyFlags\x12$\n\
    \x0esteam_id_owner\x18\x07\x20\x01(\x06R\x0csteamIdOwner\x12\x1a\n\x08me\
    tadata\x18\x08\x20\x01(\x0cR\x08metadata\x128\n\x07members\x18\t\x20\x03\
    (\x0b2\x1e.CMsgClientMMSLobbyData.MemberR\x07members\x12!\n\x0clobby_cel\
    lid\x18\n\x20\x01(\rR\x0blobbyCellid\x12=\n\x1bowner_should_accept_chang\
    es\x18\x0b\x20\x01(\x08R\x18ownerShouldAcceptChanges\x1ab\n\x06Member\
    \x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\x12!\n\x0cperson\
    a_name\x18\x02\x20\x01(\tR\x0bpersonaName\x12\x1a\n\x08metadata\x18\x03\
    \x20\x01(\x0cR\x08metadata\"\xa9\x01\n\x1dCMsgClientMMSSendLobbyChatMsg\
    \x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lob\
    by\x18\x02\x20\x01(\x06R\x0csteamIdLobby\x12&\n\x0fsteam_id_target\x18\
    \x03\x20\x01(\x06R\rsteamIdTarget\x12#\n\rlobby_message\x18\x04\x20\x01(\
    \x0cR\x0clobbyMessage\"\xa5\x01\n\x19CMsgClientMMSLobbyChatMsg\x12\x15\n\
    \x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\x18\x02\
    \x20\x01(\x06R\x0csteamIdLobby\x12&\n\x0fsteam_id_sender\x18\x03\x20\x01\
    (\x06R\rsteamIdSender\x12#\n\rlobby_message\x18\x04\x20\x01(\x0cR\x0clob\
    byMessage\"\x86\x01\n\x1aCMsgClientMMSSetLobbyOwner\x12\x15\n\x06app_id\
    \x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\x18\x02\x20\x01(\
    \x06R\x0csteamIdLobby\x12+\n\x12steam_id_new_owner\x18\x03\x20\x01(\x06R\
    \x0fsteamIdNewOwner\"~\n\"CMsgClientMMSSetLobbyOwnerResponse\x12\x15\n\
    \x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\x18\x02\
    \x20\x01(\x06R\x0csteamIdLobby\x12\x1b\n\x07eresult\x18\x03\x20\x01(\x05\
    :\x012R\x07eresult\"\x82\x01\n\x1bCMsgClientMMSSetLobbyLinked\x12\x15\n\
    \x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\x18\x02\
    \x20\x01(\x06R\x0csteamIdLobby\x12&\n\x0fsteam_id_lobby2\x18\x03\x20\x01\
    (\x06R\rsteamIdLobby2\"\xaa\x02\n\x1fCMsgClientMMSSetLobbyGameServer\x12\
    \x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\
    \x18\x02\x20\x01(\x06R\x0csteamIdLobby\x129\n\x19deprecated_game_server_\
    ip\x18\x03\x20\x01(\rR\x16deprecatedGameServerIp\x12(\n\x10game_server_p\
    ort\x18\x04\x20\x01(\rR\x0egameServerPort\x12/\n\x14game_server_steam_id\
    \x18\x05\x20\x01(\x06R\x11gameServerSteamId\x124\n\x0egame_server_ip\x18\
    \x06\x20\x01(\x0b2\x0e.CMsgIPAddressR\x0cgameServerIp\"\xaa\x02\n\x1fCMs\
    gClientMMSLobbyGameServerSet\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05\
    appId\x12$\n\x0esteam_id_lobby\x18\x02\x20\x01(\x06R\x0csteamIdLobby\x12\
    9\n\x19deprecated_game_server_ip\x18\x03\x20\x01(\rR\x16deprecatedGameSe\
    rverIp\x12(\n\x10game_server_port\x18\x04\x20\x01(\rR\x0egameServerPort\
    \x12/\n\x14game_server_steam_id\x18\x05\x20\x01(\x06R\x11gameServerSteam\
    Id\x124\n\x0egame_server_ip\x18\x06\x20\x01(\x0b2\x0e.CMsgIPAddressR\x0c\
    gameServerIp\"\xa2\x01\n\x1cCMsgClientMMSUserJoinedLobby\x12\x15\n\x06ap\
    p_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\x18\x02\x20\
    \x01(\x06R\x0csteamIdLobby\x12\"\n\rsteam_id_user\x18\x03\x20\x01(\x06R\
    \x0bsteamIdUser\x12!\n\x0cpersona_name\x18\x04\x20\x01(\tR\x0bpersonaNam\
    e\"\xa0\x01\n\x1aCMsgClientMMSUserLeftLobby\x12\x15\n\x06app_id\x18\x01\
    \x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\x18\x02\x20\x01(\x06R\x0c\
    steamIdLobby\x12\"\n\rsteam_id_user\x18\x03\x20\x01(\x06R\x0bsteamIdUser\
    \x12!\n\x0cpersona_name\x18\x04\x20\x01(\tR\x0bpersonaName\"\x8c\x01\n\
    \x1aCMsgClientMMSInviteToLobby\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\
    \x05appId\x12$\n\x0esteam_id_lobby\x18\x02\x20\x01(\x06R\x0csteamIdLobby\
    \x121\n\x15steam_id_user_invited\x18\x03\x20\x01(\x06R\x12steamIdUserInv\
    ited\"\xae\x01\n\x1bCMsgClientMMSGetLobbyStatus\x12\x15\n\x06app_id\x18\
    \x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\x18\x02\x20\x01(\x06R\
    \x0csteamIdLobby\x12)\n\x10claim_membership\x18\x03\x20\x01(\x08R\x0fcla\
    imMembership\x12'\n\x0fclaim_ownership\x18\x04\x20\x01(\x08R\x0eclaimOwn\
    ership\"\xb1\x01\n#CMsgClientMMSGetLobbyStatusResponse\x12\x15\n\x06app_\
    id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\x18\x02\x20\x01\
    (\x06R\x0csteamIdLobby\x12M\n\x0clobby_status\x18\x03\x20\x01(\x0e2\x10.\
    EMMSLobbyStatus:\x18k_EMMSLobbyStatusInvalidR\x0blobbyStatus\"\xa6\x01\n\
    \x16CMsgClientInviteToGame\x12\"\n\rsteam_id_dest\x18\x01\x20\x01(\x06R\
    \x0bsteamIdDest\x12\x20\n\x0csteam_id_src\x18\x02\x20\x01(\x06R\nsteamId\
    Src\x12%\n\x0econnect_string\x18\x03\x20\x01(\tR\rconnectString\x12\x1f\
    \n\x0bremote_play\x18\x04\x20\x01(\tR\nremotePlay\"\x98\x02\n\x14CMsgCli\
    entChatInvite\x12(\n\x10steam_id_invited\x18\x01\x20\x01(\x06R\x0esteamI\
    dInvited\x12\"\n\rsteam_id_chat\x18\x02\x20\x01(\x06R\x0bsteamIdChat\x12\
    &\n\x0fsteam_id_patron\x18\x03\x20\x01(\x06R\rsteamIdPatron\x12#\n\rchat\
    room_type\x18\x04\x20\x01(\x05R\x0cchatroomType\x12/\n\x14steam_id_frien\
    d_chat\x18\x05\x20\x01(\x06R\x11steamIdFriendChat\x12\x1b\n\tchat_name\
    \x18\x06\x20\x01(\tR\x08chatName\x12\x17\n\x07game_id\x18\x07\x20\x01(\
    \x06R\x06gameId\"\x93\x0c\n\x19CMsgClientConnectionStats\x12G\n\x0bstats\
    _logon\x18\x01\x20\x01(\x0b2&.CMsgClientConnectionStats.Stats_LogonR\nst\
    atsLogon\x12G\n\x0bstats_vconn\x18\x02\x20\x01(\x0b2&.CMsgClientConnecti\
    onStats.Stats_VConnR\nstatsVconn\x1a\xc1\x02\n\x0bStats_Logon\x12)\n\x10\
    connect_attempts\x18\x01\x20\x01(\x05R\x0fconnectAttempts\x12+\n\x11conn\
    ect_successes\x18\x02\x20\x01(\x05R\x10connectSuccesses\x12)\n\x10connec\
    t_failures\x18\x03\x20\x01(\x05R\x0fconnectFailures\x12/\n\x13connection\
    s_dropped\x18\x04\x20\x01(\x05R\x12connectionsDropped\x12'\n\x0fseconds_\
    running\x18\x05\x20\x01(\rR\x0esecondsRunning\x121\n\x14msec_tologonthis\
    time\x18\x06\x20\x01(\rR\x13msecTologonthistime\x12\"\n\rcount_bad_cms\
    \x18\x07\x20\x01(\rR\x0bcountBadCms\x1a\xaa\x01\n\tStats_UDP\x12\x1b\n\t\
    pkts_sent\x18\x01\x20\x01(\x04R\x08pktsSent\x12\x1d\n\nbytes_sent\x18\
    \x02\x20\x01(\x04R\tbytesSent\x12\x1b\n\tpkts_recv\x18\x03\x20\x01(\x04R\
    \x08pktsRecv\x12%\n\x0epkts_processed\x18\x04\x20\x01(\x04R\rpktsProcess\
    ed\x12\x1d\n\nbytes_recv\x18\x05\x20\x01(\x04R\tbytesRecv\x1a\xf2\x06\n\
    \x0bStats_VConn\x12'\n\x0fconnections_udp\x18\x01\x20\x01(\rR\x0econnect\
    ionsUdp\x12'\n\x0fconnections_tcp\x18\x02\x20\x01(\rR\x0econnectionsTcp\
    \x12A\n\tstats_udp\x18\x03\x20\x01(\x0b2$.CMsgClientConnectionStats.Stat\
    s_UDPR\x08statsUdp\x12%\n\x0epkts_abandoned\x18\x04\x20\x01(\x04R\rpktsA\
    bandoned\x12*\n\x11conn_req_received\x18\x05\x20\x01(\x04R\x0fconnReqRec\
    eived\x12\x1f\n\x0bpkts_resent\x18\x06\x20\x01(\x04R\npktsResent\x12\x1b\
    \n\tmsgs_sent\x18\x07\x20\x01(\x04R\x08msgsSent\x12(\n\x10msgs_sent_fail\
    ed\x18\x08\x20\x01(\x04R\x0emsgsSentFailed\x12\x1b\n\tmsgs_recv\x18\t\
    \x20\x01(\x04R\x08msgsRecv\x12%\n\x0edatagrams_sent\x18\n\x20\x01(\x04R\
    \rdatagramsSent\x12%\n\x0edatagrams_recv\x18\x0b\x20\x01(\x04R\rdatagram\
    sRecv\x12\"\n\rbad_pkts_recv\x18\x0c\x20\x01(\x04R\x0bbadPktsRecv\x123\n\
    \x16unknown_conn_pkts_recv\x18\r\x20\x01(\x04R\x13unknownConnPktsRecv\
    \x12(\n\x10missed_pkts_recv\x18\x0e\x20\x01(\x04R\x0emissedPktsRecv\x12\
    \"\n\rdup_pkts_recv\x18\x0f\x20\x01(\x04R\x0bdupPktsRecv\x12:\n\x19faile\
    d_connect_challenges\x18\x10\x20\x01(\x04R\x17failedConnectChallenges\
    \x121\n\x15micro_sec_avg_latency\x18\x11\x20\x01(\rR\x12microSecAvgLaten\
    cy\x121\n\x15micro_sec_min_latency\x18\x12\x20\x01(\rR\x12microSecMinLat\
    ency\x121\n\x15micro_sec_max_latency\x18\x13\x20\x01(\rR\x12microSecMaxL\
    atency\x12,\n\x13mem_pool_msg_in_use\x18\x14\x20\x01(\rR\x0fmemPoolMsgIn\
    Use\"\x94\x02\n\x1aCMsgClientServersAvailable\x12h\n\x16server_types_ava\
    ilable\x18\x01\x20\x03(\x0b22.CMsgClientServersAvailable.Server_Types_Av\
    ailableR\x14serverTypesAvailable\x12@\n\x1dserver_type_for_auth_services\
    \x18\x02\x20\x01(\rR\x19serverTypeForAuthServices\x1aJ\n\x16Server_Types\
    _Available\x12\x16\n\x06server\x18\x01\x20\x01(\rR\x06server\x12\x18\n\
    \x07changed\x18\x02\x20\x01(\x08R\x07changed\"\xab\x01\n\x16CMsgClientGe\
    tUserStats\x12\x17\n\x07game_id\x18\x01\x20\x01(\x06R\x06gameId\x12\x1b\
    \n\tcrc_stats\x18\x02\x20\x01(\rR\x08crcStats\x120\n\x14schema_local_ver\
    sion\x18\x03\x20\x01(\x05R\x12schemaLocalVersion\x12)\n\x11steam_id_for_\
    user\x18\x04\x20\x01(\x06R\x0esteamIdForUser\"\xca\x03\n\x1eCMsgClientGe\
    tUserStatsResponse\x12\x17\n\x07game_id\x18\x01\x20\x01(\x06R\x06gameId\
    \x12\x1b\n\x07eresult\x18\x02\x20\x01(\x05:\x012R\x07eresult\x12\x1b\n\t\
    crc_stats\x18\x03\x20\x01(\rR\x08crcStats\x12\x16\n\x06schema\x18\x04\
    \x20\x01(\x0cR\x06schema\x12;\n\x05stats\x18\x05\x20\x03(\x0b2%.CMsgClie\
    ntGetUserStatsResponse.StatsR\x05stats\x12a\n\x12achievement_blocks\x18\
    \x06\x20\x03(\x0b22.CMsgClientGetUserStatsResponse.Achievement_BlocksR\
    \x11achievementBlocks\x1a?\n\x05Stats\x12\x17\n\x07stat_id\x18\x01\x20\
    \x01(\rR\x06statId\x12\x1d\n\nstat_value\x18\x02\x20\x01(\rR\tstatValue\
    \x1a\\\n\x12Achievement_Blocks\x12%\n\x0eachievement_id\x18\x01\x20\x01(\
    \rR\rachievementId\x12\x1f\n\x0bunlock_time\x18\x02\x20\x03(\x07R\nunloc\
    kTime\"\xf7\x02\n\x20CMsgClientStoreUserStatsResponse\x12\x17\n\x07game_\
    id\x18\x01\x20\x01(\x06R\x06gameId\x12\x1b\n\x07eresult\x18\x02\x20\x01(\
    \x05:\x012R\x07eresult\x12\x1b\n\tcrc_stats\x18\x03\x20\x01(\rR\x08crcSt\
    ats\x12q\n\x17stats_failed_validation\x18\x04\x20\x03(\x0b29.CMsgClientS\
    toreUserStatsResponse.Stats_Failed_ValidationR\x15statsFailedValidation\
    \x12)\n\x11stats_out_of_date\x18\x05\x20\x01(\x08R\x0estatsOutOfDate\x1a\
    b\n\x17Stats_Failed_Validation\x12\x17\n\x07stat_id\x18\x01\x20\x01(\rR\
    \x06statId\x12.\n\x13reverted_stat_value\x18\x02\x20\x01(\rR\x11reverted\
    StatValue\"\xc1\x02\n\x19CMsgClientStoreUserStats2\x12\x17\n\x07game_id\
    \x18\x01\x20\x01(\x06R\x06gameId\x12&\n\x0fsettor_steam_id\x18\x02\x20\
    \x01(\x06R\rsettorSteamId\x12&\n\x0fsettee_steam_id\x18\x03\x20\x01(\x06\
    R\rsetteeSteamId\x12\x1b\n\tcrc_stats\x18\x04\x20\x01(\rR\x08crcStats\
    \x12%\n\x0eexplicit_reset\x18\x05\x20\x01(\x08R\rexplicitReset\x126\n\
    \x05stats\x18\x06\x20\x03(\x0b2\x20.CMsgClientStoreUserStats2.StatsR\x05\
    stats\x1a?\n\x05Stats\x12\x17\n\x07stat_id\x18\x01\x20\x01(\rR\x06statId\
    \x12\x1d\n\nstat_value\x18\x02\x20\x01(\rR\tstatValue\"\xfe\x01\n\x16CMs\
    gClientStatsUpdated\x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steam\
    Id\x12\x17\n\x07game_id\x18\x02\x20\x01(\x06R\x06gameId\x12\x1b\n\tcrc_s\
    tats\x18\x03\x20\x01(\rR\x08crcStats\x12J\n\rupdated_stats\x18\x04\x20\
    \x03(\x0b2%.CMsgClientStatsUpdated.Updated_StatsR\x0cupdatedStats\x1aG\n\
    \rUpdated_Stats\x12\x17\n\x07stat_id\x18\x01\x20\x01(\rR\x06statId\x12\
    \x1d\n\nstat_value\x18\x02\x20\x01(\rR\tstatValue\"\xf4\x01\n\x18CMsgCli\
    entStoreUserStats\x12\x17\n\x07game_id\x18\x01\x20\x01(\x06R\x06gameId\
    \x12%\n\x0eexplicit_reset\x18\x02\x20\x01(\x08R\rexplicitReset\x12N\n\
    \x0estats_to_store\x18\x03\x20\x03(\x0b2(.CMsgClientStoreUserStats.Stats\
    _To_StoreR\x0cstatsToStore\x1aH\n\x0eStats_To_Store\x12\x17\n\x07stat_id\
    \x18\x01\x20\x01(\rR\x06statId\x12\x1d\n\nstat_value\x18\x02\x20\x01(\rR\
    \tstatValue\"\x1c\n\x1aCMsgClientGetClientDetails\"O\n$CMsgClientReportO\
    verlayDetourFailure\x12'\n\x0ffailure_strings\x18\x01\x20\x03(\tR\x0efai\
    lureStrings\"\xc6\x03\n\"CMsgClientGetClientDetailsResponse\x12'\n\x0fpa\
    ckage_version\x18\x01\x20\x01(\rR\x0epackageVersion\x12)\n\x10protocol_v\
    ersion\x18\x08\x20\x01(\rR\x0fprotocolVersion\x12\x0e\n\x02os\x18\x02\
    \x20\x01(\tR\x02os\x12!\n\x0cmachine_name\x18\x03\x20\x01(\tR\x0bmachine\
    Name\x12\x1b\n\tip_public\x18\x04\x20\x01(\tR\x08ipPublic\x12\x1d\n\nip_\
    private\x18\x05\x20\x01(\tR\tipPrivate\x12'\n\x0fbytes_available\x18\x07\
    \x20\x01(\x04R\x0ebytesAvailable\x12M\n\rgames_running\x18\x06\x20\x03(\
    \x0b2(.CMsgClientGetClientDetailsResponse.GameR\x0cgamesRunning\x1ae\n\
    \x04Game\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\x1d\n\nextr\
    a_info\x18\x02\x20\x01(\tR\textraInfo\x12(\n\x10time_running_sec\x18\x03\
    \x20\x01(\rR\x0etimeRunningSec\"\xc2\x01\n\x1aCMsgClientGetClientAppList\
    \x12\x14\n\x05media\x18\x01\x20\x01(\x08R\x05media\x12\x14\n\x05tools\
    \x18\x02\x20\x01(\x08R\x05tools\x12\x14\n\x05games\x18\x03\x20\x01(\x08R\
    \x05games\x12%\n\x0eonly_installed\x18\x04\x20\x01(\x08R\ronlyInstalled\
    \x12#\n\ronly_changing\x18\x05\x20\x01(\x08R\x0conlyChanging\x12\x16\n\
    \x06comics\x18\x06\x20\x01(\x08R\x06comics\"\xf5\x05\n\"CMsgClientGetCli\
    entAppListResponse\x12;\n\x04apps\x18\x01\x20\x03(\x0b2'.CMsgClientGetCl\
    ientAppListResponse.AppR\x04apps\x12'\n\x0fbytes_available\x18\x02\x20\
    \x01(\x04R\x0ebytesAvailable\x1a\xe8\x04\n\x03App\x12\x14\n\x05appid\x18\
    \x01\x20\x01(\rR\x05appid\x12\x1a\n\x08category\x18\x02\x20\x01(\tR\x08c\
    ategory\x12\x19\n\x08app_type\x18\n\x20\x01(\tR\x07appType\x12\x1a\n\x08\
    favorite\x18\x03\x20\x01(\x08R\x08favorite\x12\x1c\n\tinstalled\x18\x04\
    \x20\x01(\x08R\tinstalled\x12\x1f\n\x0bauto_update\x18\x05\x20\x01(\x08R\
    \nautoUpdate\x12)\n\x10bytes_downloaded\x18\x06\x20\x01(\x04R\x0fbytesDo\
    wnloaded\x12!\n\x0cbytes_needed\x18\x07\x20\x01(\x04R\x0bbytesNeeded\x12\
    .\n\x13bytes_download_rate\x18\x08\x20\x01(\rR\x11bytesDownloadRate\x12'\
    \n\x0fdownload_paused\x18\x0b\x20\x01(\x08R\x0edownloadPaused\x12'\n\x0f\
    num_downloading\x18\x0c\x20\x01(\rR\x0enumDownloading\x12\x1d\n\nnum_pau\
    sed\x18\r\x20\x01(\rR\tnumPaused\x12\x1a\n\x08changing\x18\x0e\x20\x01(\
    \x08R\x08changing\x122\n\x15available_on_platform\x18\x0f\x20\x01(\x08R\
    \x13availableOnPlatform\x12?\n\x04dlcs\x18\t\x20\x03(\x0b2+.CMsgClientGe\
    tClientAppListResponse.App.DLCR\x04dlcs\x1a9\n\x03DLC\x12\x14\n\x05appid\
    \x18\x01\x20\x01(\rR\x05appid\x12\x1c\n\tinstalled\x18\x02\x20\x01(\x08R\
    \tinstalled\"2\n\x1aCMsgClientInstallClientApp\x12\x14\n\x05appid\x18\
    \x01\x20\x01(\rR\x05appid\"<\n\"CMsgClientInstallClientAppResponse\x12\
    \x16\n\x06result\x18\x01\x20\x01(\rR\x06result\"4\n\x1cCMsgClientUninsta\
    llClientApp\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\">\n$CMsgCli\
    entUninstallClientAppResponse\x12\x16\n\x06result\x18\x01\x20\x01(\rR\
    \x06result\"Q\n!CMsgClientSetClientAppUpdateState\x12\x14\n\x05appid\x18\
    \x01\x20\x01(\rR\x05appid\x12\x16\n\x06update\x18\x02\x20\x01(\x08R\x06u\
    pdate\"C\n)CMsgClientSetClientAppUpdateStateResponse\x12\x16\n\x06result\
    \x18\x01\x20\x01(\rR\x06result\"\x82\x03\n\x1eCMsgClientUFSUploadFileReq\
    uest\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12\x1b\n\tfile_si\
    ze\x18\x02\x20\x01(\rR\x08fileSize\x12\"\n\rraw_file_size\x18\x03\x20\
    \x01(\rR\x0brawFileSize\x12\x19\n\x08sha_file\x18\x04\x20\x01(\x0cR\x07s\
    haFile\x12\x1d\n\ntime_stamp\x18\x05\x20\x01(\x04R\ttimeStamp\x12\x1b\n\
    \tfile_name\x18\x06\x20\x01(\tR\x08fileName\x12?\n\x1cplatforms_to_sync_\
    deprecated\x18\x07\x20\x01(\rR\x19platformsToSyncDeprecated\x126\n\x11pl\
    atforms_to_sync\x18\x08\x20\x01(\r:\n4294967295R\x0fplatformsToSync\x12\
    \x17\n\x07cell_id\x18\t\x20\x01(\rR\x06cellId\x12\x1f\n\x0bcan_encrypt\
    \x18\n\x20\x01(\x08R\ncanEncrypt\"\x8b\x02\n\x1fCMsgClientUFSUploadFileR\
    esponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\x12\
    \x19\n\x08sha_file\x18\x02\x20\x01(\x0cR\x07shaFile\x12\x19\n\x08use_htt\
    p\x18\x03\x20\x01(\x08R\x07useHttp\x12\x1b\n\thttp_host\x18\x04\x20\x01(\
    \tR\x08httpHost\x12\x19\n\x08http_url\x18\x05\x20\x01(\tR\x07httpUrl\x12\
    \x1d\n\nkv_headers\x18\x06\x20\x01(\x0cR\tkvHeaders\x12\x1b\n\tuse_https\
    \x18\x07\x20\x01(\x08R\x08useHttps\x12!\n\x0cencrypt_file\x18\x08\x20\
    \x01(\x08R\x0bencryptFile\"\xe2\x01\n\x19CMsgClientUFSUploadCommit\x125\
    \n\x05files\x18\x01\x20\x03(\x0b2\x1f.CMsgClientUFSUploadCommit.FileR\
    \x05files\x1a\x8d\x01\n\x04File\x12\x1b\n\x07eresult\x18\x01\x20\x01(\
    \x05:\x012R\x07eresult\x12\x15\n\x06app_id\x18\x02\x20\x01(\rR\x05appId\
    \x12\x19\n\x08sha_file\x18\x03\x20\x01(\x0cR\x07shaFile\x12\x19\n\x08cub\
    _file\x18\x04\x20\x01(\rR\x07cubFile\x12\x1b\n\tfile_name\x18\x05\x20\
    \x01(\tR\x08fileName\"\xb9\x01\n!CMsgClientUFSUploadCommitResponse\x12=\
    \n\x05files\x18\x01\x20\x03(\x0b2'.CMsgClientUFSUploadCommitResponse.Fil\
    eR\x05files\x1aU\n\x04File\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\
    \x012R\x07eresult\x12\x15\n\x06app_id\x18\x02\x20\x01(\rR\x05appId\x12\
    \x19\n\x08sha_file\x18\x03\x20\x01(\x0cR\x07shaFile\"f\n\x16CMsgClientUF\
    SFileChunk\x12\x19\n\x08sha_file\x18\x01\x20\x01(\x0cR\x07shaFile\x12\
    \x1d\n\nfile_start\x18\x02\x20\x01(\rR\tfileStart\x12\x12\n\x04data\x18\
    \x03\x20\x01(\x0cR\x04data\"\x20\n\x1eCMsgClientUFSTransferHeartbeat\"Y\
    \n\x1fCMsgClientUFSUploadFileFinished\x12\x1b\n\x07eresult\x18\x01\x20\
    \x01(\x05:\x012R\x07eresult\x12\x19\n\x08sha_file\x18\x02\x20\x01(\x0cR\
    \x07shaFile\"\x82\x01\n\x1eCMsgClientUFSDeleteFileRequest\x12\x15\n\x06a\
    pp_id\x18\x01\x20\x01(\rR\x05appId\x12\x1b\n\tfile_name\x18\x02\x20\x01(\
    \tR\x08fileName\x12,\n\x12is_explicit_delete\x18\x03\x20\x01(\x08R\x10is\
    ExplicitDelete\"[\n\x1fCMsgClientUFSDeleteFileResponse\x12\x1b\n\x07eres\
    ult\x18\x01\x20\x01(\x05:\x012R\x07eresult\x12\x1b\n\tfile_name\x18\x02\
    \x20\x01(\tR\x08fileName\"r\n\x1eCMsgClientUFSGetFileListForApp\x12\"\n\
    \rapps_to_query\x18\x01\x20\x03(\rR\x0bappsToQuery\x12,\n\x12send_path_p\
    refixes\x18\x02\x20\x01(\x08R\x10sendPathPrefixes\"\xbc\x03\n&CMsgClient\
    UFSGetFileListForAppResponse\x12B\n\x05files\x18\x01\x20\x03(\x0b2,.CMsg\
    ClientUFSGetFileListForAppResponse.FileR\x05files\x12#\n\rpath_prefixes\
    \x18\x02\x20\x03(\tR\x0cpathPrefixes\x1a\x9e\x02\n\x04File\x12\x15\n\x06\
    app_id\x18\x01\x20\x01(\rR\x05appId\x12\x1b\n\tfile_name\x18\x02\x20\x01\
    (\tR\x08fileName\x12\x19\n\x08sha_file\x18\x03\x20\x01(\x0cR\x07shaFile\
    \x12\x1d\n\ntime_stamp\x18\x04\x20\x01(\x04R\ttimeStamp\x12\"\n\rraw_fil\
    e_size\x18\x05\x20\x01(\rR\x0brawFileSize\x12,\n\x12is_explicit_delete\
    \x18\x06\x20\x01(\x08R\x10isExplicitDelete\x12*\n\x11platforms_to_sync\
    \x18\x07\x20\x01(\rR\x0fplatformsToSync\x12*\n\x11path_prefix_index\x18\
    \x08\x20\x01(\rR\x0fpathPrefixIndex:\x08\x80\xb5\x18\x08\x88\xb5\x18\x10\
    \"z\n\x1cCMsgClientUFSDownloadRequest\x12\x15\n\x06app_id\x18\x01\x20\
    \x01(\rR\x05appId\x12\x1b\n\tfile_name\x18\x02\x20\x01(\tR\x08fileName\
    \x12&\n\x0fcan_handle_http\x18\x03\x20\x01(\x08R\rcanHandleHttp\"\xa9\
    \x03\n\x1dCMsgClientUFSDownloadResponse\x12\x1b\n\x07eresult\x18\x01\x20\
    \x01(\x05:\x012R\x07eresult\x12\x15\n\x06app_id\x18\x02\x20\x01(\rR\x05a\
    ppId\x12\x1b\n\tfile_size\x18\x03\x20\x01(\rR\x08fileSize\x12\"\n\rraw_f\
    ile_size\x18\x04\x20\x01(\rR\x0brawFileSize\x12\x19\n\x08sha_file\x18\
    \x05\x20\x01(\x0cR\x07shaFile\x12\x1d\n\ntime_stamp\x18\x06\x20\x01(\x04\
    R\ttimeStamp\x12,\n\x12is_explicit_delete\x18\x07\x20\x01(\x08R\x10isExp\
    licitDelete\x12\x19\n\x08use_http\x18\x08\x20\x01(\x08R\x07useHttp\x12\
    \x1b\n\thttp_host\x18\t\x20\x01(\tR\x08httpHost\x12\x19\n\x08http_url\
    \x18\n\x20\x01(\tR\x07httpUrl\x12\x1d\n\nkv_headers\x18\x0b\x20\x01(\x0c\
    R\tkvHeaders\x12\x1b\n\tuse_https\x18\x0c\x20\x01(\x08R\x08useHttps\x12\
    \x1c\n\tencrypted\x18\r\x20\x01(\x08R\tencrypted\"\x84\x01\n\x19CMsgClie\
    ntUFSLoginRequest\x12)\n\x10protocol_version\x18\x01\x20\x01(\rR\x0fprot\
    ocolVersion\x12(\n\x10am_session_token\x18\x02\x20\x01(\x04R\x0eamSessio\
    nToken\x12\x12\n\x04apps\x18\x03\x20\x03(\rR\x04apps\"9\n\x1aCMsgClientU\
    FSLoginResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eres\
    ult\"X\n#CMsgClientRequestEncryptedAppTicket\x12\x15\n\x06app_id\x18\x01\
    \x20\x01(\rR\x05appId\x12\x1a\n\x08userdata\x18\x02\x20\x01(\x0cR\x08use\
    rdata\"\xa8\x01\n+CMsgClientRequestEncryptedAppTicketResponse\x12\x15\n\
    \x06app_id\x18\x01\x20\x01(\rR\x05appId\x12\x1b\n\x07eresult\x18\x02\x20\
    \x01(\x05:\x012R\x07eresult\x12E\n\x14encrypted_app_ticket\x18\x03\x20\
    \x01(\x0b2\x13.EncryptedAppTicketR\x12encryptedAppTicket\"\xf1\x01\n\x1a\
    CMsgClientWalletInfoUpdate\x12\x1d\n\nhas_wallet\x18\x01\x20\x01(\x08R\t\
    hasWallet\x12\x18\n\x07balance\x18\x02\x20\x01(\x05R\x07balance\x12\x1a\
    \n\x08currency\x18\x03\x20\x01(\x05R\x08currency\x12'\n\x0fbalance_delay\
    ed\x18\x04\x20\x01(\x05R\x0ebalanceDelayed\x12\"\n\tbalance64\x18\x05\
    \x20\x01(\x03R\tbalance64B\x04\xa0\xb6\x18\x01\x121\n\x11balance64_delay\
    ed\x18\x06\x20\x01(\x03R\x10balance64DelayedB\x04\xa0\xb6\x18\x01\"o\n\
    \x17CMsgClientAppInfoUpdate\x12+\n\x11last_changenumber\x18\x01\x20\x01(\
    \rR\x10lastChangenumber\x12'\n\x0fsend_changelist\x18\x02\x20\x01(\x08R\
    \x0esendChangelist\"\x92\x01\n\x18CMsgClientAppInfoChanges\x122\n\x15cur\
    rent_change_number\x18\x01\x20\x01(\rR\x13currentChangeNumber\x12*\n\x11\
    force_full_update\x18\x02\x20\x01(\x08R\x0fforceFullUpdate\x12\x16\n\x06\
    appIDs\x18\x03\x20\x03(\rR\x06appIDs\"\xe3\x01\n\x18CMsgClientAppInfoReq\
    uest\x121\n\x04apps\x18\x01\x20\x03(\x0b2\x1d.CMsgClientAppInfoRequest.A\
    ppR\x04apps\x120\n\x10supports_batches\x18\x02\x20\x01(\x08:\x05falseR\
    \x0fsupportsBatches\x1ab\n\x03App\x12\x15\n\x06app_id\x18\x01\x20\x01(\r\
    R\x05appId\x12#\n\rsection_flags\x18\x02\x20\x01(\rR\x0csectionFlags\x12\
    \x1f\n\x0bsection_CRC\x18\x03\x20\x03(\rR\nsectionCRC\"\xec\x02\n\x19CMs\
    gClientAppInfoResponse\x122\n\x04apps\x18\x01\x20\x03(\x0b2\x1e.CMsgClie\
    ntAppInfoResponse.AppR\x04apps\x12!\n\x0capps_unknown\x18\x02\x20\x03(\r\
    R\x0bappsUnknown\x12!\n\x0capps_pending\x18\x03\x20\x01(\rR\x0bappsPendi\
    ng\x1a\xce\x01\n\x03App\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\
    \x12#\n\rchange_number\x18\x02\x20\x01(\rR\x0cchangeNumber\x12B\n\x08sec\
    tions\x18\x03\x20\x03(\x0b2&.CMsgClientAppInfoResponse.App.SectionR\x08s\
    ections\x1aG\n\x07Section\x12\x1d\n\nsection_id\x18\x01\x20\x01(\rR\tsec\
    tionId\x12\x1d\n\nsection_kv\x18\x02\x20\x01(\x0cR\tsectionKv:\x04\x88\
    \xb5\x18\0\"e\n\x1cCMsgClientPackageInfoRequest\x12\x1f\n\x0bpackage_ids\
    \x18\x01\x20\x03(\rR\npackageIds\x12$\n\x0emeta_data_only\x18\x02\x20\
    \x01(\x08R\x0cmetaDataOnly\"\xb2\x02\n\x1dCMsgClientPackageInfoResponse\
    \x12B\n\x08packages\x18\x01\x20\x03(\x0b2&.CMsgClientPackageInfoResponse\
    .PackageR\x08packages\x12)\n\x10packages_unknown\x18\x02\x20\x03(\rR\x0f\
    packagesUnknown\x12)\n\x10packages_pending\x18\x03\x20\x01(\rR\x0fpackag\
    esPending\x1aw\n\x07Package\x12\x1d\n\npackage_id\x18\x01\x20\x01(\rR\tp\
    ackageId\x12#\n\rchange_number\x18\x02\x20\x01(\rR\x0cchangeNumber\x12\
    \x10\n\x03sha\x18\x03\x20\x01(\x0cR\x03sha\x12\x16\n\x06buffer\x18\x04\
    \x20\x01(\x0cR\x06buffer\"\xa7\x02\n!CMsgClientPICSChangesSinceRequest\
    \x12.\n\x13since_change_number\x18\x01\x20\x01(\rR\x11sinceChangeNumber\
    \x121\n\x15send_app_info_changes\x18\x02\x20\x01(\x08R\x12sendAppInfoCha\
    nges\x129\n\x19send_package_info_changes\x18\x03\x20\x01(\x08R\x16sendPa\
    ckageInfoChanges\x12-\n\x13num_app_info_cached\x18\x04\x20\x01(\rR\x10nu\
    mAppInfoCached\x125\n\x17num_package_info_cached\x18\x05\x20\x01(\rR\x14\
    numPackageInfoCached\"\xac\x05\n\"CMsgClientPICSChangesSinceResponse\x12\
    2\n\x15current_change_number\x18\x01\x20\x01(\rR\x13currentChangeNumber\
    \x12.\n\x13since_change_number\x18\x02\x20\x01(\rR\x11sinceChangeNumber\
    \x12*\n\x11force_full_update\x18\x03\x20\x01(\x08R\x0fforceFullUpdate\
    \x12Z\n\x0fpackage_changes\x18\x04\x20\x03(\x0b21.CMsgClientPICSChangesS\
    inceResponse.PackageChangeR\x0epackageChanges\x12N\n\x0bapp_changes\x18\
    \x05\x20\x03(\x0b2-.CMsgClientPICSChangesSinceResponse.AppChangeR\nappCh\
    anges\x121\n\x15force_full_app_update\x18\x06\x20\x01(\x08R\x12forceFull\
    AppUpdate\x129\n\x19force_full_package_update\x18\x07\x20\x01(\x08R\x16f\
    orceFullPackageUpdate\x1as\n\rPackageChange\x12\x1c\n\tpackageid\x18\x01\
    \x20\x01(\rR\tpackageid\x12#\n\rchange_number\x18\x02\x20\x01(\rR\x0ccha\
    ngeNumber\x12\x1f\n\x0bneeds_token\x18\x03\x20\x01(\x08R\nneedsToken\x1a\
    g\n\tAppChange\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12#\n\rc\
    hange_number\x18\x02\x20\x01(\rR\x0cchangeNumber\x12\x1f\n\x0bneeds_toke\
    n\x18\x03\x20\x01(\x08R\nneedsToken\"\xf8\x03\n\x20CMsgClientPICSProduct\
    InfoRequest\x12I\n\x08packages\x18\x01\x20\x03(\x0b2-.CMsgClientPICSProd\
    uctInfoRequest.PackageInfoR\x08packages\x12=\n\x04apps\x18\x02\x20\x03(\
    \x0b2).CMsgClientPICSProductInfoRequest.AppInfoR\x04apps\x12$\n\x0emeta_\
    data_only\x18\x03\x20\x01(\x08R\x0cmetaDataOnly\x12&\n\x0fnum_prev_faile\
    d\x18\x04\x20\x01(\rR\rnumPrevFailed\x126\n\x17supports_package_tokens\
    \x18\x05\x20\x01(\rR\x15supportsPackageTokens\x1at\n\x07AppInfo\x12\x14\
    \n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12!\n\x0caccess_token\x18\x02\
    \x20\x01(\x04R\x0baccessToken\x120\n\x14only_public_obsolete\x18\x03\x20\
    \x01(\x08R\x12onlyPublicObsolete\x1aN\n\x0bPackageInfo\x12\x1c\n\tpackag\
    eid\x18\x01\x20\x01(\rR\tpackageid\x12!\n\x0caccess_token\x18\x02\x20\
    \x01(\x04R\x0baccessToken\"\x9e\x06\n!CMsgClientPICSProductInfoResponse\
    \x12>\n\x04apps\x18\x01\x20\x03(\x0b2*.CMsgClientPICSProductInfoResponse\
    .AppInfoR\x04apps\x12%\n\x0eunknown_appids\x18\x02\x20\x03(\rR\runknownA\
    ppids\x12J\n\x08packages\x18\x03\x20\x03(\x0b2..CMsgClientPICSProductInf\
    oResponse.PackageInfoR\x08packages\x12-\n\x12unknown_packageids\x18\x04\
    \x20\x03(\rR\x11unknownPackageids\x12$\n\x0emeta_data_only\x18\x05\x20\
    \x01(\x08R\x0cmetaDataOnly\x12)\n\x10response_pending\x18\x06\x20\x01(\
    \x08R\x0fresponsePending\x12\"\n\rhttp_min_size\x18\x07\x20\x01(\rR\x0bh\
    ttpMinSize\x12\x1b\n\thttp_host\x18\x08\x20\x01(\tR\x08httpHost\x1a\xc8\
    \x01\n\x07AppInfo\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12#\n\
    \rchange_number\x18\x02\x20\x01(\rR\x0cchangeNumber\x12#\n\rmissing_toke\
    n\x18\x03\x20\x01(\x08R\x0cmissingToken\x12\x10\n\x03sha\x18\x04\x20\x01\
    (\x0cR\x03sha\x12\x16\n\x06buffer\x18\x05\x20\x01(\x0cR\x06buffer\x12\
    \x1f\n\x0bonly_public\x18\x06\x20\x01(\x08R\nonlyPublic\x12\x12\n\x04siz\
    e\x18\x07\x20\x01(\rR\x04size\x1a\xb3\x01\n\x0bPackageInfo\x12\x1c\n\tpa\
    ckageid\x18\x01\x20\x01(\rR\tpackageid\x12#\n\rchange_number\x18\x02\x20\
    \x01(\rR\x0cchangeNumber\x12#\n\rmissing_token\x18\x03\x20\x01(\x08R\x0c\
    missingToken\x12\x10\n\x03sha\x18\x04\x20\x01(\x0cR\x03sha\x12\x16\n\x06\
    buffer\x18\x05\x20\x01(\x0cR\x06buffer\x12\x12\n\x04size\x18\x06\x20\x01\
    (\rR\x04size:\x04\x88\xb5\x18\0\"Z\n\x20CMsgClientPICSAccessTokenRequest\
    \x12\x1e\n\npackageids\x18\x01\x20\x03(\rR\npackageids\x12\x16\n\x06appi\
    ds\x18\x02\x20\x03(\rR\x06appids\"\xd7\x03\n!CMsgClientPICSAccessTokenRe\
    sponse\x12c\n\x15package_access_tokens\x18\x01\x20\x03(\x0b2/.CMsgClient\
    PICSAccessTokenResponse.PackageTokenR\x13packageAccessTokens\x122\n\x15p\
    ackage_denied_tokens\x18\x02\x20\x03(\rR\x13packageDeniedTokens\x12W\n\
    \x11app_access_tokens\x18\x03\x20\x03(\x0b2+.CMsgClientPICSAccessTokenRe\
    sponse.AppTokenR\x0fappAccessTokens\x12*\n\x11app_denied_tokens\x18\x04\
    \x20\x03(\rR\x0fappDeniedTokens\x1aO\n\x0cPackageToken\x12\x1c\n\tpackag\
    eid\x18\x01\x20\x01(\rR\tpackageid\x12!\n\x0caccess_token\x18\x02\x20\
    \x01(\x04R\x0baccessToken\x1aC\n\x08AppToken\x12\x14\n\x05appid\x18\x01\
    \x20\x01(\rR\x05appid\x12!\n\x0caccess_token\x18\x02\x20\x01(\x04R\x0bac\
    cessToken\"N\n\x1aCMsgClientUFSGetUGCDetails\x120\n\x08hcontent\x18\x01\
    \x20\x01(\x06:\x1418446744073709551615R\x08hcontent\"\xd3\x02\n\"CMsgCli\
    entUFSGetUGCDetailsResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\
    \x012R\x07eresult\x12\x10\n\x03url\x18\x02\x20\x01(\tR\x03url\x12\x15\n\
    \x06app_id\x18\x03\x20\x01(\rR\x05appId\x12\x1a\n\x08filename\x18\x04\
    \x20\x01(\tR\x08filename\x12'\n\x0fsteamid_creator\x18\x05\x20\x01(\x06R\
    \x0esteamidCreator\x12\x1b\n\tfile_size\x18\x06\x20\x01(\rR\x08fileSize\
    \x120\n\x14compressed_file_size\x18\x07\x20\x01(\rR\x12compressedFileSiz\
    e\x12'\n\x0frangecheck_host\x18\x08\x20\x01(\tR\x0erangecheckHost\x12*\n\
    \x11file_encoded_sha1\x18\t\x20\x01(\tR\x0ffileEncodedSha1\"T\n\x1eCMsgC\
    lientUFSGetSingleFileInfo\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05app\
    Id\x12\x1b\n\tfile_name\x18\x02\x20\x01(\tR\x08fileName\"\x85\x02\n&CMsg\
    ClientUFSGetSingleFileInfoResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\
    \x05:\x012R\x07eresult\x12\x15\n\x06app_id\x18\x02\x20\x01(\rR\x05appId\
    \x12\x1b\n\tfile_name\x18\x03\x20\x01(\tR\x08fileName\x12\x19\n\x08sha_f\
    ile\x18\x04\x20\x01(\x0cR\x07shaFile\x12\x1d\n\ntime_stamp\x18\x05\x20\
    \x01(\x04R\ttimeStamp\x12\"\n\rraw_file_size\x18\x06\x20\x01(\rR\x0brawF\
    ileSize\x12,\n\x12is_explicit_delete\x18\x07\x20\x01(\x08R\x10isExplicit\
    Delete\"L\n\x16CMsgClientUFSShareFile\x12\x15\n\x06app_id\x18\x01\x20\
    \x01(\rR\x05appId\x12\x1b\n\tfile_name\x18\x02\x20\x01(\tR\x08fileName\"\
    o\n\x1eCMsgClientUFSShareFileResponse\x12\x1b\n\x07eresult\x18\x01\x20\
    \x01(\x05:\x012R\x07eresult\x120\n\x08hcontent\x18\x02\x20\x01(\x06:\x14\
    18446744073709551615R\x08hcontent\"@\n\x1bCMsgClientAMGetClanOfficers\
    \x12!\n\x0csteamid_clan\x18\x01\x20\x01(\x06R\x0bsteamidClan\"\x8a\x01\n\
    #CMsgClientAMGetClanOfficersResponse\x12\x1b\n\x07eresult\x18\x01\x20\
    \x01(\x05:\x012R\x07eresult\x12!\n\x0csteamid_clan\x18\x02\x20\x01(\x06R\
    \x0bsteamidClan\x12#\n\rofficer_count\x18\x03\x20\x01(\x05R\x0cofficerCo\
    unt\"\xa7\x01\n!CMsgClientAMGetPersonaNameHistory\x12\x19\n\x08id_count\
    \x18\x01\x20\x01(\x05R\x07idCount\x12?\n\x03Ids\x18\x02\x20\x03(\x0b2-.C\
    MsgClientAMGetPersonaNameHistory.IdInstanceR\x03Ids\x1a&\n\nIdInstance\
    \x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07steamid\"\xf8\x02\n)CMsgC\
    lientAMGetPersonaNameHistoryResponse\x12Z\n\tresponses\x18\x02\x20\x03(\
    \x0b2<.CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstanceR\tres\
    ponses\x1a\xee\x01\n\x11NameTableInstance\x12\x1b\n\x07eresult\x18\x01\
    \x20\x01(\x05:\x012R\x07eresult\x12\x18\n\x07steamid\x18\x02\x20\x01(\
    \x06R\x07steamid\x12_\n\x05names\x18\x03\x20\x03(\x0b2I.CMsgClientAMGetP\
    ersonaNameHistoryResponse.NameTableInstance.NameInstanceR\x05names\x1aA\
    \n\x0cNameInstance\x12\x1d\n\nname_since\x18\x01\x20\x01(\x07R\tnameSinc\
    e\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\"Y\n\x1eCMsgClientDeregi\
    sterWithServer\x12\x20\n\x0beservertype\x18\x01\x20\x01(\rR\x0beserverty\
    pe\x12\x15\n\x06app_id\x18\x02\x20\x01(\rR\x05appId\"\x81\x06\n\x13CMsgC\
    lientClanState\x12!\n\x0csteamid_clan\x18\x01\x20\x01(\x06R\x0bsteamidCl\
    an\x12,\n\x12clan_account_flags\x18\x03\x20\x01(\rR\x10clanAccountFlags\
    \x12:\n\tname_info\x18\x04\x20\x01(\x0b2\x1d.CMsgClientClanState.NameInf\
    oR\x08nameInfo\x12@\n\x0buser_counts\x18\x05\x20\x01(\x0b2\x1f.CMsgClien\
    tClanState.UserCountsR\nuserCounts\x122\n\x06events\x18\x06\x20\x03(\x0b\
    2\x1a.CMsgClientClanState.EventR\x06events\x12@\n\rannouncements\x18\x07\
    \x20\x03(\x0b2\x1a.CMsgClientClanState.EventR\rannouncements\x12*\n\x11c\
    hat_room_private\x18\x08\x20\x01(\x08R\x0fchatRoomPrivate\x1aF\n\x08Name\
    Info\x12\x1b\n\tclan_name\x18\x01\x20\x01(\tR\x08clanName\x12\x1d\n\nsha\
    _avatar\x18\x02\x20\x01(\x0cR\tshaAvatar\x1a\x9f\x01\n\nUserCounts\x12\
    \x18\n\x07members\x18\x01\x20\x01(\rR\x07members\x12\x16\n\x06online\x18\
    \x02\x20\x01(\rR\x06online\x12\x1a\n\x08chatting\x18\x03\x20\x01(\rR\x08\
    chatting\x12\x17\n\x07in_game\x18\x04\x20\x01(\rR\x06inGame\x12*\n\x11ch\
    at_room_members\x18\x05\x20\x01(\rR\x0fchatRoomMembers\x1a\x8e\x01\n\x05\
    Event\x12\x10\n\x03gid\x18\x01\x20\x01(\x06R\x03gid\x12\x1d\n\nevent_tim\
    e\x18\x02\x20\x01(\rR\teventTime\x12\x1a\n\x08headline\x18\x03\x20\x01(\
    \tR\x08headline\x12\x17\n\x07game_id\x18\x04\x20\x01(\x06R\x06gameId\x12\
    \x1f\n\x0bjust_posted\x18\x05\x20\x01(\x08R\njustPosted\"\xf8\x01\n\x1fC\
    MsgClientUnsignedInstallScript\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\
    \x05appId\x12\x1b\n\tfile_name\x18\x02\x20\x01(\tR\x08fileName\x12\x1b\n\
    \tfile_size\x18\x03\x20\x01(\rR\x08fileSize\x12)\n\x10signature_broken\
    \x18\x04\x20\x01(\x08R\x0fsignatureBroken\x12\x19\n\x08depot_id\x18\x05\
    \x20\x01(\rR\x07depotId\x12\x1f\n\x0bmanifest_id\x18\x06\x20\x01(\x04R\n\
    manifestId\x12\x1d\n\nfile_flags\x18\x07\x20\x01(\rR\tfileFlags*\x90\x01\
    \n\x0fEMMSLobbyStatus\x12\x1c\n\x18k_EMMSLobbyStatusInvalid\x10\0\x12\
    \x1b\n\x17k_EMMSLobbyStatusExists\x10\x01\x12!\n\x1dk_EMMSLobbyStatusDoe\
    sNotExist\x10\x02\x12\x1f\n\x1bk_EMMSLobbyStatusNotAMember\x10\x03B\x05H\
    \x01\x80\x01\0J\xdf\xcb\x03\n\x07\x12\x05\0\0\xbd\t\x01\n\t\n\x02\x03\0\
    \x12\x03\0\0\"\n\t\n\x02\x03\x01\x12\x03\x01\0$\n\x08\n\x01\x08\x12\x03\
    \x03\0\x1c\n\t\n\x02\x08\t\x12\x03\x03\0\x1c\n\x08\n\x01\x08\x12\x03\x04\
    \0#\n\t\n\x02\x08\x10\x12\x03\x04\0#\n\n\n\x02\x05\0\x12\x04\x06\0\x0b\
    \x01\n\n\n\x03\x05\0\x01\x12\x03\x06\x05\x14\n\x0b\n\x04\x05\0\x02\0\x12\
    \x03\x07\x08%\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\x07\x08\x20\n\x0c\n\
    \x05\x05\0\x02\0\x02\x12\x03\x07#$\n\x0b\n\x04\x05\0\x02\x01\x12\x03\x08\
    \x08$\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03\x08\x08\x1f\n\x0c\n\x05\x05\
    \0\x02\x01\x02\x12\x03\x08\"#\n\x0b\n\x04\x05\0\x02\x02\x12\x03\t\x08*\n\
    \x0c\n\x05\x05\0\x02\x02\x01\x12\x03\t\x08%\n\x0c\n\x05\x05\0\x02\x02\
    \x02\x12\x03\t()\n\x0b\n\x04\x05\0\x02\x03\x12\x03\n\x08(\n\x0c\n\x05\
    \x05\0\x02\x03\x01\x12\x03\n\x08#\n\x0c\n\x05\x05\0\x02\x03\x02\x12\x03\
    \n&'\n\n\n\x02\x04\0\x12\x04\r\0\x10\x01\n\n\n\x03\x04\0\x01\x12\x03\r\
    \x08&\n\x0b\n\x04\x04\0\x02\0\x12\x03\x0e\x08,\n\x0c\n\x05\x04\0\x02\0\
    \x04\x12\x03\x0e\x08\x10\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x0e\x11\x18\
    \n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x0e\x19'\n\x0c\n\x05\x04\0\x02\0\
    \x03\x12\x03\x0e*+\n\x0b\n\x04\x04\0\x02\x01\x12\x03\x0f\x08!\n\x0c\n\
    \x05\x04\0\x02\x01\x04\x12\x03\x0f\x08\x10\n\x0c\n\x05\x04\0\x02\x01\x05\
    \x12\x03\x0f\x11\x16\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x0f\x17\x1c\n\
    \x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x0f\x1f\x20\n\n\n\x02\x04\x01\x12\
    \x04\x12\0\x1d\x01\n\n\n\x03\x04\x01\x01\x12\x03\x12\x08$\n\x0b\n\x04\
    \x04\x01\x02\0\x12\x03\x13\x08,\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03\
    \x13\x08\x10\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03\x13\x11\x18\n\x0c\n\
    \x05\x04\x01\x02\0\x01\x12\x03\x13\x19'\n\x0c\n\x05\x04\x01\x02\0\x03\
    \x12\x03\x13*+\n\x0b\n\x04\x04\x01\x02\x01\x12\x03\x14\x08!\n\x0c\n\x05\
    \x04\x01\x02\x01\x04\x12\x03\x14\x08\x10\n\x0c\n\x05\x04\x01\x02\x01\x05\
    \x12\x03\x14\x11\x16\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\x14\x17\x1c\
    \n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03\x14\x1f\x20\n\x0b\n\x04\x04\x01\
    \x02\x02\x12\x03\x15\x08.\n\x0c\n\x05\x04\x01\x02\x02\x04\x12\x03\x15\
    \x08\x10\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03\x15\x11\x16\n\x0c\n\x05\
    \x04\x01\x02\x02\x01\x12\x03\x15\x17)\n\x0c\n\x05\x04\x01\x02\x02\x03\
    \x12\x03\x15,-\n\x0b\n\x04\x04\x01\x02\x03\x12\x03\x16\x08)\n\x0c\n\x05\
    \x04\x01\x02\x03\x04\x12\x03\x16\x08\x10\n\x0c\n\x05\x04\x01\x02\x03\x05\
    \x12\x03\x16\x11\x16\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x03\x16\x17$\n\
    \x0c\n\x05\x04\x01\x02\x03\x03\x12\x03\x16'(\n\x0b\n\x04\x04\x01\x02\x04\
    \x12\x03\x17\x08#\n\x0c\n\x05\x04\x01\x02\x04\x04\x12\x03\x17\x08\x10\n\
    \x0c\n\x05\x04\x01\x02\x04\x05\x12\x03\x17\x11\x16\n\x0c\n\x05\x04\x01\
    \x02\x04\x01\x12\x03\x17\x17\x1e\n\x0c\n\x05\x04\x01\x02\x04\x03\x12\x03\
    \x17!\"\n\x0b\n\x04\x04\x01\x02\x05\x12\x03\x18\x08&\n\x0c\n\x05\x04\x01\
    \x02\x05\x04\x12\x03\x18\x08\x10\n\x0c\n\x05\x04\x01\x02\x05\x05\x12\x03\
    \x18\x11\x16\n\x0c\n\x05\x04\x01\x02\x05\x01\x12\x03\x18\x17!\n\x0c\n\
    \x05\x04\x01\x02\x05\x03\x12\x03\x18$%\n\x0b\n\x04\x04\x01\x02\x06\x12\
    \x03\x19\x08&\n\x0c\n\x05\x04\x01\x02\x06\x04\x12\x03\x19\x08\x10\n\x0c\
    \n\x05\x04\x01\x02\x06\x05\x12\x03\x19\x11\x16\n\x0c\n\x05\x04\x01\x02\
    \x06\x01\x12\x03\x19\x17!\n\x0c\n\x05\x04\x01\x02\x06\x03\x12\x03\x19$%\
    \n\x0b\n\x04\x04\x01\x02\x07\x12\x03\x1a\x08,\n\x0c\n\x05\x04\x01\x02\
    \x07\x04\x12\x03\x1a\x08\x10\n\x0c\n\x05\x04\x01\x02\x07\x05\x12\x03\x1a\
    \x11\x16\n\x0c\n\x05\x04\x01\x02\x07\x01\x12\x03\x1a\x17'\n\x0c\n\x05\
    \x04\x01\x02\x07\x03\x12\x03\x1a*+\n\x0b\n\x04\x04\x01\x02\x08\x12\x03\
    \x1b\x08,\n\x0c\n\x05\x04\x01\x02\x08\x04\x12\x03\x1b\x08\x10\n\x0c\n\
    \x05\x04\x01\x02\x08\x05\x12\x03\x1b\x11\x16\n\x0c\n\x05\x04\x01\x02\x08\
    \x01\x12\x03\x1b\x17'\n\x0c\n\x05\x04\x01\x02\x08\x03\x12\x03\x1b*+\n\
    \x0b\n\x04\x04\x01\x02\t\x12\x03\x1c\x08/\n\x0c\n\x05\x04\x01\x02\t\x04\
    \x12\x03\x1c\x08\x10\n\x0c\n\x05\x04\x01\x02\t\x05\x12\x03\x1c\x11\x16\n\
    \x0c\n\x05\x04\x01\x02\t\x01\x12\x03\x1c\x17)\n\x0c\n\x05\x04\x01\x02\t\
    \x03\x12\x03\x1c,.\n\n\n\x02\x04\x02\x12\x04\x1f\0#\x01\n\n\n\x03\x04\
    \x02\x01\x12\x03\x1f\x08*\n\x0b\n\x04\x04\x02\x02\0\x12\x03\x20\x08-\n\
    \x0c\n\x05\x04\x02\x02\0\x04\x12\x03\x20\x08\x10\n\x0c\n\x05\x04\x02\x02\
    \0\x05\x12\x03\x20\x11\x17\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03\x20\x18\
    (\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03\x20+,\n\x0b\n\x04\x04\x02\x02\
    \x01\x12\x03!\x08\"\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03!\x08\x10\n\
    \x0c\n\x05\x04\x02\x02\x01\x05\x12\x03!\x11\x16\n\x0c\n\x05\x04\x02\x02\
    \x01\x01\x12\x03!\x17\x1d\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03!\x20!\
    \n\x0b\n\x04\x04\x02\x02\x02\x12\x03\"\x08/\n\x0c\n\x05\x04\x02\x02\x02\
    \x04\x12\x03\"\x08\x10\n\x0c\n\x05\x04\x02\x02\x02\x05\x12\x03\"\x11\x17\
    \n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x03\"\x18*\n\x0c\n\x05\x04\x02\x02\
    \x02\x03\x12\x03\"-.\n\n\n\x02\x04\x03\x12\x04%\0.\x01\n\n\n\x03\x04\x03\
    \x01\x12\x03%\x08$\n\x0b\n\x04\x04\x03\x02\0\x12\x03&\x08&\n\x0c\n\x05\
    \x04\x03\x02\0\x04\x12\x03&\x08\x10\n\x0c\n\x05\x04\x03\x02\0\x05\x12\
    \x03&\x11\x18\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03&\x19!\n\x0c\n\x05\
    \x04\x03\x02\0\x03\x12\x03&$%\n\x0b\n\x04\x04\x03\x02\x01\x12\x03'\x08%\
    \n\x0c\n\x05\x04\x03\x02\x01\x04\x12\x03'\x08\x10\n\x0c\n\x05\x04\x03\
    \x02\x01\x05\x12\x03'\x11\x18\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03'\
    \x19\x20\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03'#$\n\x0b\n\x04\x04\x03\
    \x02\x02\x12\x03(\x08#\n\x0c\n\x05\x04\x03\x02\x02\x04\x12\x03(\x08\x10\
    \n\x0c\n\x05\x04\x03\x02\x02\x05\x12\x03(\x11\x17\n\x0c\n\x05\x04\x03\
    \x02\x02\x01\x12\x03(\x18\x1e\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x03(!\
    \"\n\x0b\n\x04\x04\x03\x02\x03\x12\x03)\x083\n\x0c\n\x05\x04\x03\x02\x03\
    \x04\x12\x03)\x08\x10\n\x0c\n\x05\x04\x03\x02\x03\x05\x12\x03)\x11\x17\n\
    \x0c\n\x05\x04\x03\x02\x03\x01\x12\x03)\x18.\n\x0c\n\x05\x04\x03\x02\x03\
    \x03\x12\x03)12\n\x0b\n\x04\x04\x03\x02\x04\x12\x03*\x08-\n\x0c\n\x05\
    \x04\x03\x02\x04\x04\x12\x03*\x08\x10\n\x0c\n\x05\x04\x03\x02\x04\x05\
    \x12\x03*\x11\x16\n\x0c\n\x05\x04\x03\x02\x04\x01\x12\x03*\x17(\n\x0c\n\
    \x05\x04\x03\x02\x04\x03\x12\x03*+,\n\x0b\n\x04\x04\x03\x02\x05\x12\x03+\
    \x08'\n\x0c\n\x05\x04\x03\x02\x05\x04\x12\x03+\x08\x10\n\x0c\n\x05\x04\
    \x03\x02\x05\x05\x12\x03+\x11\x17\n\x0c\n\x05\x04\x03\x02\x05\x01\x12\
    \x03+\x18\"\n\x0c\n\x05\x04\x03\x02\x05\x03\x12\x03+%&\n\x0b\n\x04\x04\
    \x03\x02\x06\x12\x03,\x08,\n\x0c\n\x05\x04\x03\x02\x06\x04\x12\x03,\x08\
    \x10\n\x0c\n\x05\x04\x03\x02\x06\x05\x12\x03,\x11\x17\n\x0c\n\x05\x04\
    \x03\x02\x06\x01\x12\x03,\x18'\n\x0c\n\x05\x04\x03\x02\x06\x03\x12\x03,*\
    +\n\x0b\n\x04\x04\x03\x02\x07\x12\x03-\x08,\n\x0c\n\x05\x04\x03\x02\x07\
    \x04\x12\x03-\x08\x10\n\x0c\n\x05\x04\x03\x02\x07\x05\x12\x03-\x11\x18\n\
    \x0c\n\x05\x04\x03\x02\x07\x01\x12\x03-\x19'\n\x0c\n\x05\x04\x03\x02\x07\
    \x03\x12\x03-*+\n\n\n\x02\x04\x04\x12\x040\05\x01\n\n\n\x03\x04\x04\x01\
    \x12\x030\x08\x18\n\x0b\n\x04\x04\x04\x02\0\x12\x031\x08)\n\x0c\n\x05\
    \x04\x04\x02\0\x04\x12\x031\x08\x10\n\x0c\n\x05\x04\x04\x02\0\x05\x12\
    \x031\x11\x17\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x031\x18$\n\x0c\n\x05\
    \x04\x04\x02\0\x03\x12\x031'(\n\x0b\n\x04\x04\x04\x02\x01\x12\x032\x08%\
    \n\x0c\n\x05\x04\x04\x02\x01\x04\x12\x032\x08\x10\n\x0c\n\x05\x04\x04\
    \x02\x01\x05\x12\x032\x11\x17\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x032\
    \x18\x20\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x032#$\n\x0b\n\x04\x04\x04\
    \x02\x02\x12\x033\x083\n\x0c\n\x05\x04\x04\x02\x02\x04\x12\x033\x08\x10\
    \n\x0c\n\x05\x04\x04\x02\x02\x05\x12\x033\x11\x17\n\x0c\n\x05\x04\x04\
    \x02\x02\x01\x12\x033\x18.\n\x0c\n\x05\x04\x04\x02\x02\x03\x12\x03312\n\
    \x0b\n\x04\x04\x04\x02\x03\x12\x034\x089\n\x0c\n\x05\x04\x04\x02\x03\x04\
    \x12\x034\x08\x10\n\x0c\n\x05\x04\x04\x02\x03\x05\x12\x034\x11\x17\n\x0c\
    \n\x05\x04\x04\x02\x03\x01\x12\x034\x184\n\x0c\n\x05\x04\x04\x02\x03\x03\
    \x12\x03478\n\n\n\x02\x04\x05\x12\x047\0>\x01\n\n\n\x03\x04\x05\x01\x12\
    \x037\x08#\n\x0b\n\x04\x04\x05\x02\0\x12\x038\x08+\n\x0c\n\x05\x04\x05\
    \x02\0\x04\x12\x038\x08\x10\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x038\x11\
    \x18\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x038\x19&\n\x0c\n\x05\x04\x05\x02\
    \0\x03\x12\x038)*\n\x0b\n\x04\x04\x05\x02\x01\x12\x039\x08*\n\x0c\n\x05\
    \x04\x05\x02\x01\x04\x12\x039\x08\x10\n\x0c\n\x05\x04\x05\x02\x01\x05\
    \x12\x039\x11\x18\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x039\x19%\n\x0c\n\
    \x05\x04\x05\x02\x01\x03\x12\x039()\n\x0b\n\x04\x04\x05\x02\x02\x12\x03:\
    \x08#\n\x0c\n\x05\x04\x05\x02\x02\x04\x12\x03:\x08\x10\n\x0c\n\x05\x04\
    \x05\x02\x02\x05\x12\x03:\x11\x17\n\x0c\n\x05\x04\x05\x02\x02\x01\x12\
    \x03:\x18\x1e\n\x0c\n\x05\x04\x05\x02\x02\x03\x12\x03:!\"\n\x0b\n\x04\
    \x04\x05\x02\x03\x12\x03;\x08%\n\x0c\n\x05\x04\x05\x02\x03\x04\x12\x03;\
    \x08\x10\n\x0c\n\x05\x04\x05\x02\x03\x05\x12\x03;\x11\x16\n\x0c\n\x05\
    \x04\x05\x02\x03\x01\x12\x03;\x17\x20\n\x0c\n\x05\x04\x05\x02\x03\x03\
    \x12\x03;#$\n\x0b\n\x04\x04\x05\x02\x04\x12\x03<\x086\n\x0c\n\x05\x04\
    \x05\x02\x04\x04\x12\x03<\x08\x10\n\x0c\n\x05\x04\x05\x02\x04\x05\x12\
    \x03<\x11\x18\n\x0c\n\x05\x04\x05\x02\x04\x01\x12\x03<\x191\n\x0c\n\x05\
    \x04\x05\x02\x04\x03\x12\x03<45\n\x0b\n\x04\x04\x05\x02\x05\x12\x03=\x08\
    &\n\x0c\n\x05\x04\x05\x02\x05\x04\x12\x03=\x08\x10\n\x0c\n\x05\x04\x05\
    \x02\x05\x05\x12\x03=\x11\x16\n\x0c\n\x05\x04\x05\x02\x05\x01\x12\x03=\
    \x17!\n\x0c\n\x05\x04\x05\x02\x05\x03\x12\x03=$%\n\n\n\x02\x04\x06\x12\
    \x04@\0H\x01\n\n\n\x03\x04\x06\x01\x12\x03@\x08'\n\x0b\n\x04\x04\x06\x02\
    \0\x12\x03A\x08+\n\x0c\n\x05\x04\x06\x02\0\x04\x12\x03A\x08\x10\n\x0c\n\
    \x05\x04\x06\x02\0\x05\x12\x03A\x11\x18\n\x0c\n\x05\x04\x06\x02\0\x01\
    \x12\x03A\x19&\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03A)*\n\x0b\n\x04\x04\
    \x06\x02\x01\x12\x03B\x08*\n\x0c\n\x05\x04\x06\x02\x01\x04\x12\x03B\x08\
    \x10\n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x03B\x11\x18\n\x0c\n\x05\x04\
    \x06\x02\x01\x01\x12\x03B\x19%\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03B(\
    )\n\x0b\n\x04\x04\x06\x02\x02\x12\x03C\x08#\n\x0c\n\x05\x04\x06\x02\x02\
    \x04\x12\x03C\x08\x10\n\x0c\n\x05\x04\x06\x02\x02\x05\x12\x03C\x11\x17\n\
    \x0c\n\x05\x04\x06\x02\x02\x01\x12\x03C\x18\x1e\n\x0c\n\x05\x04\x06\x02\
    \x02\x03\x12\x03C!\"\n\x0b\n\x04\x04\x06\x02\x03\x12\x03D\x08/\n\x0c\n\
    \x05\x04\x06\x02\x03\x04\x12\x03D\x08\x10\n\x0c\n\x05\x04\x06\x02\x03\
    \x05\x12\x03D\x11\x17\n\x0c\n\x05\x04\x06\x02\x03\x01\x12\x03D\x18*\n\
    \x0c\n\x05\x04\x06\x02\x03\x03\x12\x03D-.\n\x0b\n\x04\x04\x06\x02\x04\
    \x12\x03E\x080\n\x0c\n\x05\x04\x06\x02\x04\x04\x12\x03E\x08\x10\n\x0c\n\
    \x05\x04\x06\x02\x04\x05\x12\x03E\x11\x18\n\x0c\n\x05\x04\x06\x02\x04\
    \x01\x12\x03E\x19+\n\x0c\n\x05\x04\x06\x02\x04\x03\x12\x03E./\n\x0b\n\
    \x04\x04\x06\x02\x05\x12\x03F\x08)\n\x0c\n\x05\x04\x06\x02\x05\x04\x12\
    \x03F\x08\x10\n\x0c\n\x05\x04\x06\x02\x05\x05\x12\x03F\x11\x17\n\x0c\n\
    \x05\x04\x06\x02\x05\x01\x12\x03F\x18$\n\x0c\n\x05\x04\x06\x02\x05\x03\
    \x12\x03F'(\n\x0b\n\x04\x04\x06\x02\x06\x12\x03G\x08*\n\x0c\n\x05\x04\
    \x06\x02\x06\x04\x12\x03G\x08\x10\n\x0c\n\x05\x04\x06\x02\x06\x05\x12\
    \x03G\x11\x17\n\x0c\n\x05\x04\x06\x02\x06\x01\x12\x03G\x18%\n\x0c\n\x05\
    \x04\x06\x02\x06\x03\x12\x03G()\n\n\n\x02\x04\x07\x12\x04J\0M\x01\n\n\n\
    \x03\x04\x07\x01\x12\x03J\x08'\n\x0b\n\x04\x04\x07\x02\0\x12\x03K\x08$\n\
    \x0c\n\x05\x04\x07\x02\0\x04\x12\x03K\x08\x10\n\x0c\n\x05\x04\x07\x02\0\
    \x05\x12\x03K\x11\x16\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03K\x17\x1f\n\
    \x0c\n\x05\x04\x07\x02\0\x03\x12\x03K\"#\n\x0b\n\x04\x04\x07\x02\x01\x12\
    \x03L\x08#\n\x0c\n\x05\x04\x07\x02\x01\x04\x12\x03L\x08\x10\n\x0c\n\x05\
    \x04\x07\x02\x01\x05\x12\x03L\x11\x17\n\x0c\n\x05\x04\x07\x02\x01\x01\
    \x12\x03L\x18\x1e\n\x0c\n\x05\x04\x07\x02\x01\x03\x12\x03L!\"\n\n\n\x02\
    \x04\x08\x12\x04O\0S\x01\n\n\n\x03\x04\x08\x01\x12\x03O\x08%\n\x0b\n\x04\
    \x04\x08\x02\0\x12\x03P\x08\x20\n\x0c\n\x05\x04\x08\x02\0\x04\x12\x03P\
    \x08\x10\n\x0c\n\x05\x04\x08\x02\0\x05\x12\x03P\x11\x16\n\x0c\n\x05\x04\
    \x08\x02\0\x01\x12\x03P\x17\x1b\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03P\
    \x1e\x1f\n\x0b\n\x04\x04\x08\x02\x01\x12\x03Q\x08'\n\x0c\n\x05\x04\x08\
    \x02\x01\x04\x12\x03Q\x08\x10\n\x0c\n\x05\x04\x08\x02\x01\x05\x12\x03Q\
    \x11\x18\n\x0c\n\x05\x04\x08\x02\x01\x01\x12\x03Q\x19\"\n\x0c\n\x05\x04\
    \x08\x02\x01\x03\x12\x03Q%&\n\x0b\n\x04\x04\x08\x02\x02\x12\x03R\x08(\n\
    \x0c\n\x05\x04\x08\x02\x02\x04\x12\x03R\x08\x10\n\x0c\n\x05\x04\x08\x02\
    \x02\x05\x12\x03R\x11\x16\n\x0c\n\x05\x04\x08\x02\x02\x01\x12\x03R\x17#\
    \n\x0c\n\x05\x04\x08\x02\x02\x03\x12\x03R&'\n\n\n\x02\x04\t\x12\x04U\0W\
    \x01\n\n\n\x03\x04\t\x01\x12\x03U\x08-\n\x0b\n\x04\x04\t\x02\0\x12\x03V\
    \x08#\n\x0c\n\x05\x04\t\x02\0\x04\x12\x03V\x08\x10\n\x0c\n\x05\x04\t\x02\
    \0\x05\x12\x03V\x11\x17\n\x0c\n\x05\x04\t\x02\0\x01\x12\x03V\x18\x1e\n\
    \x0c\n\x05\x04\t\x02\0\x03\x12\x03V!\"\n\n\n\x02\x04\n\x12\x04Y\0[\x01\n\
    \n\n\x03\x04\n\x01\x12\x03Y\x08+\n\x0b\n\x04\x04\n\x02\0\x12\x03Z\x08)\n\
    \x0c\n\x05\x04\n\x02\0\x04\x12\x03Z\x08\x10\n\x0c\n\x05\x04\n\x02\0\x05\
    \x12\x03Z\x11\x17\n\x0c\n\x05\x04\n\x02\0\x01\x12\x03Z\x18$\n\x0c\n\x05\
    \x04\n\x02\0\x03\x12\x03Z'(\n\n\n\x02\x04\x0b\x12\x04]\0_\x01\n\n\n\x03\
    \x04\x0b\x01\x12\x03]\x08'\n\x0b\n\x04\x04\x0b\x02\0\x12\x03^\x08#\n\x0c\
    \n\x05\x04\x0b\x02\0\x04\x12\x03^\x08\x10\n\x0c\n\x05\x04\x0b\x02\0\x05\
    \x12\x03^\x11\x17\n\x0c\n\x05\x04\x0b\x02\0\x01\x12\x03^\x18\x1e\n\x0c\n\
    \x05\x04\x0b\x02\0\x03\x12\x03^!\"\n\n\n\x02\x04\x0c\x12\x04a\0e\x01\n\n\
    \n\x03\x04\x0c\x01\x12\x03a\x08/\n\x0b\n\x04\x04\x0c\x02\0\x12\x03b\x082\
    \n\x0c\n\x05\x04\x0c\x02\0\x04\x12\x03b\x08\x10\n\x0c\n\x05\x04\x0c\x02\
    \0\x05\x12\x03b\x11\x17\n\x0c\n\x05\x04\x0c\x02\0\x01\x12\x03b\x18\x1f\n\
    \x0c\n\x05\x04\x0c\x02\0\x03\x12\x03b\"#\n\x0c\n\x05\x04\x0c\x02\0\x08\
    \x12\x03b$1\n\x0c\n\x05\x04\x0c\x02\0\x07\x12\x03b/0\n\x0b\n\x04\x04\x0c\
    \x02\x01\x12\x03c\x08#\n\x0c\n\x05\x04\x0c\x02\x01\x04\x12\x03c\x08\x10\
    \n\x0c\n\x05\x04\x0c\x02\x01\x05\x12\x03c\x11\x17\n\x0c\n\x05\x04\x0c\
    \x02\x01\x01\x12\x03c\x18\x1e\n\x0c\n\x05\x04\x0c\x02\x01\x03\x12\x03c!\
    \"\n\x0b\n\x04\x04\x0c\x02\x02\x12\x03d\x08\"\n\x0c\n\x05\x04\x0c\x02\
    \x02\x04\x12\x03d\x08\x10\n\x0c\n\x05\x04\x0c\x02\x02\x05\x12\x03d\x11\
    \x16\n\x0c\n\x05\x04\x0c\x02\x02\x01\x12\x03d\x17\x1d\n\x0c\n\x05\x04\
    \x0c\x02\x02\x03\x12\x03d\x20!\n\n\n\x02\x04\r\x12\x04g\0i\x01\n\n\n\x03\
    \x04\r\x01\x12\x03g\x08\x1e\n\x0b\n\x04\x04\r\x02\0\x12\x03h\x08\"\n\x0c\
    \n\x05\x04\r\x02\0\x04\x12\x03h\x08\x10\n\x0c\n\x05\x04\r\x02\0\x05\x12\
    \x03h\x11\x17\n\x0c\n\x05\x04\r\x02\0\x01\x12\x03h\x18\x1d\n\x0c\n\x05\
    \x04\r\x02\0\x03\x12\x03h\x20!\n\n\n\x02\x04\x0e\x12\x04k\0n\x01\n\n\n\
    \x03\x04\x0e\x01\x12\x03k\x08#\n\x0b\n\x04\x04\x0e\x02\0\x12\x03l\x08>\n\
    \x0c\n\x05\x04\x0e\x02\0\x04\x12\x03l\x08\x10\n\x0c\n\x05\x04\x0e\x02\0\
    \x05\x12\x03l\x11\x17\n\x0c\n\x05\x04\x0e\x02\0\x01\x12\x03l\x18*\n\x0c\
    \n\x05\x04\x0e\x02\0\x03\x12\x03l-.\n\x0c\n\x05\x04\x0e\x02\0\x08\x12\
    \x03l/=\n\x0c\n\x05\x04\x0e\x02\0\x07\x12\x03l:<\n\x0b\n\x04\x04\x0e\x02\
    \x01\x12\x03m\x08\"\n\x0c\n\x05\x04\x0e\x02\x01\x04\x12\x03m\x08\x10\n\
    \x0c\n\x05\x04\x0e\x02\x01\x05\x12\x03m\x11\x16\n\x0c\n\x05\x04\x0e\x02\
    \x01\x01\x12\x03m\x17\x1d\n\x0c\n\x05\x04\x0e\x02\x01\x03\x12\x03m\x20!\
    \n\n\n\x02\x04\x0f\x12\x04p\0x\x01\n\n\n\x03\x04\x0f\x01\x12\x03p\x08\
    \x18\n\x0b\n\x04\x04\x0f\x02\0\x12\x03q\x08*\n\x0c\n\x05\x04\x0f\x02\0\
    \x04\x12\x03q\x08\x10\n\x0c\n\x05\x04\x0f\x02\0\x05\x12\x03q\x11\x17\n\
    \x0c\n\x05\x04\x0f\x02\0\x01\x12\x03q\x18%\n\x0c\n\x05\x04\x0f\x02\0\x03\
    \x12\x03q()\n\x0b\n\x04\x04\x0f\x02\x01\x12\x03r\x08\"\n\x0c\n\x05\x04\
    \x0f\x02\x01\x04\x12\x03r\x08\x10\n\x0c\n\x05\x04\x0f\x02\x01\x05\x12\
    \x03r\x11\x17\n\x0c\n\x05\x04\x0f\x02\x01\x01\x12\x03r\x18\x1d\n\x0c\n\
    \x05\x04\x0f\x02\x01\x03\x12\x03r\x20!\n\x0b\n\x04\x04\x0f\x02\x02\x12\
    \x03s\x087\n\x0c\n\x05\x04\x0f\x02\x02\x04\x12\x03s\x08\x10\n\x0c\n\x05\
    \x04\x0f\x02\x02\x05\x12\x03s\x11\x17\n\x0c\n\x05\x04\x0f\x02\x02\x01\
    \x12\x03s\x182\n\x0c\n\x05\x04\x0f\x02\x02\x03\x12\x03s56\n\x0b\n\x04\
    \x04\x0f\x02\x03\x12\x03t\x08&\n\x0c\n\x05\x04\x0f\x02\x03\x04\x12\x03t\
    \x08\x10\n\x0c\n\x05\x04\x0f\x02\x03\x05\x12\x03t\x11\x17\n\x0c\n\x05\
    \x04\x0f\x02\x03\x01\x12\x03t\x18!\n\x0c\n\x05\x04\x0f\x02\x03\x03\x12\
    \x03t$%\n\x0b\n\x04\x04\x0f\x02\x04\x12\x03u\x08%\n\x0c\n\x05\x04\x0f\
    \x02\x04\x04\x12\x03u\x08\x10\n\x0c\n\x05\x04\x0f\x02\x04\x05\x12\x03u\
    \x11\x17\n\x0c\n\x05\x04\x0f\x02\x04\x01\x12\x03u\x18\x20\n\x0c\n\x05\
    \x04\x0f\x02\x04\x03\x12\x03u#$\n\x0b\n\x04\x04\x0f\x02\x05\x12\x03v\x08\
    )\n\x0c\n\x05\x04\x0f\x02\x05\x04\x12\x03v\x08\x10\n\x0c\n\x05\x04\x0f\
    \x02\x05\x05\x12\x03v\x11\x17\n\x0c\n\x05\x04\x0f\x02\x05\x01\x12\x03v\
    \x18$\n\x0c\n\x05\x04\x0f\x02\x05\x03\x12\x03v'(\n\x0b\n\x04\x04\x0f\x02\
    \x06\x12\x03w\x08,\n\x0c\n\x05\x04\x0f\x02\x06\x04\x12\x03w\x08\x10\n\
    \x0c\n\x05\x04\x0f\x02\x06\x05\x12\x03w\x11\x17\n\x0c\n\x05\x04\x0f\x02\
    \x06\x01\x12\x03w\x18'\n\x0c\n\x05\x04\x0f\x02\x06\x03\x12\x03w*+\n\n\n\
    \x02\x04\x10\x12\x04z\0|\x01\n\n\n\x03\x04\x10\x01\x12\x03z\x08\x19\n\
    \x0b\n\x04\x04\x10\x02\0\x12\x03{\x08$\n\x0c\n\x05\x04\x10\x02\0\x04\x12\
    \x03{\x08\x10\n\x0c\n\x05\x04\x10\x02\0\x05\x12\x03{\x11\x15\n\x0c\n\x05\
    \x04\x10\x02\0\x01\x12\x03{\x16\x1f\n\x0c\n\x05\x04\x10\x02\0\x03\x12\
    \x03{\"#\n\x0b\n\x02\x04\x11\x12\x05~\0\x87\x01\x01\n\n\n\x03\x04\x11\
    \x01\x12\x03~\x08\x18\n\r\n\x04\x04\x11\x03\0\x12\x05\x7f\x08\x84\x01\t\
    \n\x0c\n\x05\x04\x11\x03\0\x01\x12\x03\x7f\x10\x16\n\x0e\n\x06\x04\x11\
    \x03\0\x02\0\x12\x04\x80\x01\x10-\n\x0f\n\x07\x04\x11\x03\0\x02\0\x04\
    \x12\x04\x80\x01\x10\x18\n\x0f\n\x07\x04\x11\x03\0\x02\0\x05\x12\x04\x80\
    \x01\x19\x1f\n\x0f\n\x07\x04\x11\x03\0\x02\0\x01\x12\x04\x80\x01\x20(\n\
    \x0f\n\x07\x04\x11\x03\0\x02\0\x03\x12\x04\x80\x01+,\n\x0e\n\x06\x04\x11\
    \x03\0\x02\x01\x12\x04\x81\x01\x109\n\x0f\n\x07\x04\x11\x03\0\x02\x01\
    \x04\x12\x04\x81\x01\x10\x18\n\x0f\n\x07\x04\x11\x03\0\x02\x01\x05\x12\
    \x04\x81\x01\x19\x1f\n\x0f\n\x07\x04\x11\x03\0\x02\x01\x01\x12\x04\x81\
    \x01\x204\n\x0f\n\x07\x04\x11\x03\0\x02\x01\x03\x12\x04\x81\x0178\n\x0e\
    \n\x06\x04\x11\x03\0\x02\x02\x12\x04\x82\x01\x10)\n\x0f\n\x07\x04\x11\
    \x03\0\x02\x02\x04\x12\x04\x82\x01\x10\x18\n\x0f\n\x07\x04\x11\x03\0\x02\
    \x02\x05\x12\x04\x82\x01\x19\x1e\n\x0f\n\x07\x04\x11\x03\0\x02\x02\x01\
    \x12\x04\x82\x01\x1f$\n\x0f\n\x07\x04\x11\x03\0\x02\x02\x03\x12\x04\x82\
    \x01'(\n\x0e\n\x06\x04\x11\x03\0\x02\x03\x12\x04\x83\x01\x106\n\x0f\n\
    \x07\x04\x11\x03\0\x02\x03\x04\x12\x04\x83\x01\x10\x18\n\x0f\n\x07\x04\
    \x11\x03\0\x02\x03\x06\x12\x04\x83\x01\x19'\n\x0f\n\x07\x04\x11\x03\0\
    \x02\x03\x01\x12\x04\x83\x01(1\n\x0f\n\x07\x04\x11\x03\0\x02\x03\x03\x12\
    \x04\x83\x0145\n\x0c\n\x04\x04\x11\x02\0\x12\x04\x86\x01\x086\n\r\n\x05\
    \x04\x11\x02\0\x04\x12\x04\x86\x01\x08\x10\n\r\n\x05\x04\x11\x02\0\x06\
    \x12\x04\x86\x01\x11)\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\x86\x01*1\n\r\
    \n\x05\x04\x11\x02\0\x03\x12\x04\x86\x0145\n\x0c\n\x02\x04\x12\x12\x06\
    \x89\x01\0\x8e\x01\x01\n\x0b\n\x03\x04\x12\x01\x12\x04\x89\x01\x08\x19\n\
    \x0c\n\x04\x04\x12\x02\0\x12\x04\x8a\x01\x08&\n\r\n\x05\x04\x12\x02\0\
    \x04\x12\x04\x8a\x01\x08\x10\n\r\n\x05\x04\x12\x02\0\x05\x12\x04\x8a\x01\
    \x11\x18\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\x8a\x01\x19!\n\r\n\x05\x04\
    \x12\x02\0\x03\x12\x04\x8a\x01$%\n\x0c\n\x04\x04\x12\x02\x01\x12\x04\x8b\
    \x01\x081\n\r\n\x05\x04\x12\x02\x01\x04\x12\x04\x8b\x01\x08\x10\n\r\n\
    \x05\x04\x12\x02\x01\x05\x12\x04\x8b\x01\x11\x17\n\r\n\x05\x04\x12\x02\
    \x01\x01\x12\x04\x8b\x01\x18,\n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\x8b\
    \x01/0\n\x0c\n\x04\x04\x12\x02\x02\x12\x04\x8c\x01\x08!\n\r\n\x05\x04\
    \x12\x02\x02\x04\x12\x04\x8c\x01\x08\x10\n\r\n\x05\x04\x12\x02\x02\x05\
    \x12\x04\x8c\x01\x11\x16\n\r\n\x05\x04\x12\x02\x02\x01\x12\x04\x8c\x01\
    \x17\x1c\n\r\n\x05\x04\x12\x02\x02\x03\x12\x04\x8c\x01\x1f\x20\n\x0c\n\
    \x04\x04\x12\x02\x03\x12\x04\x8d\x01\x08.\n\r\n\x05\x04\x12\x02\x03\x04\
    \x12\x04\x8d\x01\x08\x10\n\r\n\x05\x04\x12\x02\x03\x06\x12\x04\x8d\x01\
    \x11\x1f\n\r\n\x05\x04\x12\x02\x03\x01\x12\x04\x8d\x01\x20)\n\r\n\x05\
    \x04\x12\x02\x03\x03\x12\x04\x8d\x01,-\n\x0c\n\x02\x04\x13\x12\x06\x90\
    \x01\0\x92\x01\x01\n\x0b\n\x03\x04\x13\x01\x12\x04\x90\x01\x08\x1e\n\x0c\
    \n\x04\x04\x13\x02\0\x12\x04\x91\x01\x08&\n\r\n\x05\x04\x13\x02\0\x04\
    \x12\x04\x91\x01\x08\x10\n\r\n\x05\x04\x13\x02\0\x05\x12\x04\x91\x01\x11\
    \x18\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\x91\x01\x19!\n\r\n\x05\x04\x13\
    \x02\0\x03\x12\x04\x91\x01$%\n\x0c\n\x02\x04\x14\x12\x06\x94\x01\0\xb3\
    \x01\x01\n\x0b\n\x03\x04\x14\x01\x12\x04\x94\x01\x08\x1d\n\x0e\n\x04\x04\
    \x14\x03\0\x12\x06\x95\x01\x08\xae\x01\t\n\r\n\x05\x04\x14\x03\0\x01\x12\
    \x04\x95\x01\x10\x1a\n\x0e\n\x06\x04\x14\x03\0\x02\0\x12\x04\x96\x01\x10\
    0\n\x0f\n\x07\x04\x14\x03\0\x02\0\x04\x12\x04\x96\x01\x10\x18\n\x0f\n\
    \x07\x04\x14\x03\0\x02\0\x05\x12\x04\x96\x01\x19\x1f\n\x0f\n\x07\x04\x14\
    \x03\0\x02\0\x01\x12\x04\x96\x01\x20+\n\x0f\n\x07\x04\x14\x03\0\x02\0\
    \x03\x12\x04\x96\x01./\n\x0e\n\x06\x04\x14\x03\0\x02\x01\x12\x04\x97\x01\
    \x10-\n\x0f\n\x07\x04\x14\x03\0\x02\x01\x04\x12\x04\x97\x01\x10\x18\n\
    \x0f\n\x07\x04\x14\x03\0\x02\x01\x05\x12\x04\x97\x01\x19\x20\n\x0f\n\x07\
    \x04\x14\x03\0\x02\x01\x01\x12\x04\x97\x01!(\n\x0f\n\x07\x04\x14\x03\0\
    \x02\x01\x03\x12\x04\x97\x01+,\n\x0e\n\x06\x04\x14\x03\0\x02\x02\x12\x04\
    \x98\x01\x10?\n\x0f\n\x07\x04\x14\x03\0\x02\x02\x04\x12\x04\x98\x01\x10\
    \x18\n\x0f\n\x07\x04\x14\x03\0\x02\x02\x05\x12\x04\x98\x01\x19\x1f\n\x0f\
    \n\x07\x04\x14\x03\0\x02\x02\x01\x12\x04\x98\x01\x20:\n\x0f\n\x07\x04\
    \x14\x03\0\x02\x02\x03\x12\x04\x98\x01=>\n\x0e\n\x06\x04\x14\x03\0\x02\
    \x03\x12\x04\x99\x01\x10.\n\x0f\n\x07\x04\x14\x03\0\x02\x03\x04\x12\x04\
    \x99\x01\x10\x18\n\x0f\n\x07\x04\x14\x03\0\x02\x03\x05\x12\x04\x99\x01\
    \x19\x1f\n\x0f\n\x07\x04\x14\x03\0\x02\x03\x01\x12\x04\x99\x01\x20)\n\
    \x0f\n\x07\x04\x14\x03\0\x02\x03\x03\x12\x04\x99\x01,-\n\x0e\n\x06\x04\
    \x14\x03\0\x02\x04\x12\x04\x9a\x01\x10,\n\x0f\n\x07\x04\x14\x03\0\x02\
    \x04\x04\x12\x04\x9a\x01\x10\x18\n\x0f\n\x07\x04\x14\x03\0\x02\x04\x05\
    \x12\x04\x9a\x01\x19\x1d\n\x0f\n\x07\x04\x14\x03\0\x02\x04\x01\x12\x04\
    \x9a\x01\x1e'\n\x0f\n\x07\x04\x14\x03\0\x02\x04\x03\x12\x04\x9a\x01*+\n\
    \x0e\n\x06\x04\x14\x03\0\x02\x05\x12\x04\x9b\x01\x10)\n\x0f\n\x07\x04\
    \x14\x03\0\x02\x05\x04\x12\x04\x9b\x01\x10\x18\n\x0f\n\x07\x04\x14\x03\0\
    \x02\x05\x05\x12\x04\x9b\x01\x19\x1e\n\x0f\n\x07\x04\x14\x03\0\x02\x05\
    \x01\x12\x04\x9b\x01\x1f$\n\x0f\n\x07\x04\x14\x03\0\x02\x05\x03\x12\x04\
    \x9b\x01'(\n\x0e\n\x06\x04\x14\x03\0\x02\x06\x12\x04\x9c\x01\x104\n\x0f\
    \n\x07\x04\x14\x03\0\x02\x06\x04\x12\x04\x9c\x01\x10\x18\n\x0f\n\x07\x04\
    \x14\x03\0\x02\x06\x05\x12\x04\x9c\x01\x19\x1f\n\x0f\n\x07\x04\x14\x03\0\
    \x02\x06\x01\x12\x04\x9c\x01\x20/\n\x0f\n\x07\x04\x14\x03\0\x02\x06\x03\
    \x12\x04\x9c\x0123\n\x0e\n\x06\x04\x14\x03\0\x02\x07\x12\x04\x9d\x01\x10\
    2\n\x0f\n\x07\x04\x14\x03\0\x02\x07\x04\x12\x04\x9d\x01\x10\x18\n\x0f\n\
    \x07\x04\x14\x03\0\x02\x07\x05\x12\x04\x9d\x01\x19\x1e\n\x0f\n\x07\x04\
    \x14\x03\0\x02\x07\x01\x12\x04\x9d\x01\x1f-\n\x0f\n\x07\x04\x14\x03\0\
    \x02\x07\x03\x12\x04\x9d\x0101\n\x0e\n\x06\x04\x14\x03\0\x02\x08\x12\x04\
    \x9e\x01\x10/\n\x0f\n\x07\x04\x14\x03\0\x02\x08\x04\x12\x04\x9e\x01\x10\
    \x18\n\x0f\n\x07\x04\x14\x03\0\x02\x08\x05\x12\x04\x9e\x01\x19\x1f\n\x0f\
    \n\x07\x04\x14\x03\0\x02\x08\x01\x12\x04\x9e\x01\x20*\n\x0f\n\x07\x04\
    \x14\x03\0\x02\x08\x03\x12\x04\x9e\x01-.\n\x0e\n\x06\x04\x14\x03\0\x02\t\
    \x12\x04\x9f\x01\x10;\n\x0f\n\x07\x04\x14\x03\0\x02\t\x04\x12\x04\x9f\
    \x01\x10\x18\n\x0f\n\x07\x04\x14\x03\0\x02\t\x05\x12\x04\x9f\x01\x19\x1f\
    \n\x0f\n\x07\x04\x14\x03\0\x02\t\x01\x12\x04\x9f\x01\x205\n\x0f\n\x07\
    \x04\x14\x03\0\x02\t\x03\x12\x04\x9f\x018:\n\x0e\n\x06\x04\x14\x03\0\x02\
    \n\x12\x04\xa0\x01\x100\n\x0f\n\x07\x04\x14\x03\0\x02\n\x04\x12\x04\xa0\
    \x01\x10\x18\n\x0f\n\x07\x04\x14\x03\0\x02\n\x05\x12\x04\xa0\x01\x19\x1f\
    \n\x0f\n\x07\x04\x14\x03\0\x02\n\x01\x12\x04\xa0\x01\x20*\n\x0f\n\x07\
    \x04\x14\x03\0\x02\n\x03\x12\x04\xa0\x01-/\n\x0e\n\x06\x04\x14\x03\0\x02\
    \x0b\x12\x04\xa1\x01\x10.\n\x0f\n\x07\x04\x14\x03\0\x02\x0b\x04\x12\x04\
    \xa1\x01\x10\x18\n\x0f\n\x07\x04\x14\x03\0\x02\x0b\x05\x12\x04\xa1\x01\
    \x19\x1f\n\x0f\n\x07\x04\x14\x03\0\x02\x0b\x01\x12\x04\xa1\x01\x20(\n\
    \x0f\n\x07\x04\x14\x03\0\x02\x0b\x03\x12\x04\xa1\x01+-\n\x0e\n\x06\x04\
    \x14\x03\0\x02\x0c\x12\x04\xa2\x01\x103\n\x0f\n\x07\x04\x14\x03\0\x02\
    \x0c\x04\x12\x04\xa2\x01\x10\x18\n\x0f\n\x07\x04\x14\x03\0\x02\x0c\x05\
    \x12\x04\xa2\x01\x19\x1f\n\x0f\n\x07\x04\x14\x03\0\x02\x0c\x01\x12\x04\
    \xa2\x01\x20-\n\x0f\n\x07\x04\x14\x03\0\x02\x0c\x03\x12\x04\xa2\x0102\n\
    \x0e\n\x06\x04\x14\x03\0\x02\r\x12\x04\xa3\x01\x102\n\x0f\n\x07\x04\x14\
    \x03\0\x02\r\x04\x12\x04\xa3\x01\x10\x18\n\x0f\n\x07\x04\x14\x03\0\x02\r\
    \x05\x12\x04\xa3\x01\x19\x1f\n\x0f\n\x07\x04\x14\x03\0\x02\r\x01\x12\x04\
    \xa3\x01\x20,\n\x0f\n\x07\x04\x14\x03\0\x02\r\x03\x12\x04\xa3\x01/1\n\
    \x0e\n\x06\x04\x14\x03\0\x02\x0e\x12\x04\xa4\x01\x10F\n\x0f\n\x07\x04\
    \x14\x03\0\x02\x0e\x04\x12\x04\xa4\x01\x10\x18\n\x0f\n\x07\x04\x14\x03\0\
    \x02\x0e\x05\x12\x04\xa4\x01\x19\x1f\n\x0f\n\x07\x04\x14\x03\0\x02\x0e\
    \x01\x12\x04\xa4\x01\x202\n\x0f\n\x07\x04\x14\x03\0\x02\x0e\x03\x12\x04\
    \xa4\x0157\n\x0f\n\x07\x04\x14\x03\0\x02\x0e\x08\x12\x04\xa4\x018E\n\x0f\
    \n\x07\x04\x14\x03\0\x02\x0e\x07\x12\x04\xa4\x01CD\n\x0e\n\x06\x04\x14\
    \x03\0\x02\x0f\x12\x04\xa5\x01\x10K\n\x0f\n\x07\x04\x14\x03\0\x02\x0f\
    \x04\x12\x04\xa5\x01\x10\x18\n\x0f\n\x07\x04\x14\x03\0\x02\x0f\x05\x12\
    \x04\xa5\x01\x19\x1e\n\x0f\n\x07\x04\x14\x03\0\x02\x0f\x01\x12\x04\xa5\
    \x01\x1f6\n\x0f\n\x07\x04\x14\x03\0\x02\x0f\x03\x12\x04\xa5\x019;\n\x0f\
    \n\x07\x04\x14\x03\0\x02\x0f\x08\x12\x04\xa5\x01<J\n\x0f\n\x07\x04\x14\
    \x03\0\x02\x0f\x07\x12\x04\xa5\x01GI\n\x0e\n\x06\x04\x14\x03\0\x02\x10\
    \x12\x04\xa6\x01\x10E\n\x0f\n\x07\x04\x14\x03\0\x02\x10\x04\x12\x04\xa6\
    \x01\x10\x18\n\x0f\n\x07\x04\x14\x03\0\x02\x10\x05\x12\x04\xa6\x01\x19\
    \x1f\n\x0f\n\x07\x04\x14\x03\0\x02\x10\x01\x12\x04\xa6\x01\x20?\n\x0f\n\
    \x07\x04\x14\x03\0\x02\x10\x03\x12\x04\xa6\x01BD\n\x0e\n\x06\x04\x14\x03\
    \0\x02\x11\x12\x04\xa7\x01\x10P\n\x0f\n\x07\x04\x14\x03\0\x02\x11\x04\
    \x12\x04\xa7\x01\x10\x18\n\x0f\n\x07\x04\x14\x03\0\x02\x11\x05\x12\x04\
    \xa7\x01\x19\x1f\n\x0f\n\x07\x04\x14\x03\0\x02\x11\x01\x12\x04\xa7\x01\
    \x20<\n\x0f\n\x07\x04\x14\x03\0\x02\x11\x03\x12\x04\xa7\x01?A\n\x0f\n\
    \x07\x04\x14\x03\0\x02\x11\x08\x12\x04\xa7\x01BO\n\x0f\n\x07\x04\x14\x03\
    \0\x02\x11\x07\x12\x04\xa7\x01MN\n\x0e\n\x06\x04\x14\x03\0\x02\x12\x12\
    \x04\xa8\x01\x10T\n\x0f\n\x07\x04\x14\x03\0\x02\x12\x04\x12\x04\xa8\x01\
    \x10\x18\n\x0f\n\x07\x04\x14\x03\0\x02\x12\x05\x12\x04\xa8\x01\x19\x1f\n\
    \x0f\n\x07\x04\x14\x03\0\x02\x12\x01\x12\x04\xa8\x01\x20@\n\x0f\n\x07\
    \x04\x14\x03\0\x02\x12\x03\x12\x04\xa8\x01CE\n\x0f\n\x07\x04\x14\x03\0\
    \x02\x12\x08\x12\x04\xa8\x01FS\n\x0f\n\x07\x04\x14\x03\0\x02\x12\x07\x12\
    \x04\xa8\x01QR\n\x0e\n\x06\x04\x14\x03\0\x02\x13\x12\x04\xa9\x01\x10O\n\
    \x0f\n\x07\x04\x14\x03\0\x02\x13\x04\x12\x04\xa9\x01\x10\x18\n\x0f\n\x07\
    \x04\x14\x03\0\x02\x13\x05\x12\x04\xa9\x01\x19\x1f\n\x0f\n\x07\x04\x14\
    \x03\0\x02\x13\x01\x12\x04\xa9\x01\x20;\n\x0f\n\x07\x04\x14\x03\0\x02\
    \x13\x03\x12\x04\xa9\x01>@\n\x0f\n\x07\x04\x14\x03\0\x02\x13\x08\x12\x04\
    \xa9\x01AN\n\x0f\n\x07\x04\x14\x03\0\x02\x13\x07\x12\x04\xa9\x01LM\n\x0e\
    \n\x06\x04\x14\x03\0\x02\x14\x12\x04\xaa\x01\x10A\n\x0f\n\x07\x04\x14\
    \x03\0\x02\x14\x04\x12\x04\xaa\x01\x10\x18\n\x0f\n\x07\x04\x14\x03\0\x02\
    \x14\x05\x12\x04\xaa\x01\x19\x1f\n\x0f\n\x07\x04\x14\x03\0\x02\x14\x01\
    \x12\x04\xaa\x01\x20-\n\x0f\n\x07\x04\x14\x03\0\x02\x14\x03\x12\x04\xaa\
    \x0102\n\x0f\n\x07\x04\x14\x03\0\x02\x14\x08\x12\x04\xaa\x013@\n\x0f\n\
    \x07\x04\x14\x03\0\x02\x14\x07\x12\x04\xaa\x01>?\n\x0e\n\x06\x04\x14\x03\
    \0\x02\x15\x12\x04\xab\x01\x104\n\x0f\n\x07\x04\x14\x03\0\x02\x15\x04\
    \x12\x04\xab\x01\x10\x18\n\x0f\n\x07\x04\x14\x03\0\x02\x15\x05\x12\x04\
    \xab\x01\x19\x1f\n\x0f\n\x07\x04\x14\x03\0\x02\x15\x01\x12\x04\xab\x01\
    \x20.\n\x0f\n\x07\x04\x14\x03\0\x02\x15\x03\x12\x04\xab\x0113\n\x0e\n\
    \x06\x04\x14\x03\0\x02\x16\x12\x04\xac\x01\x10=\n\x0f\n\x07\x04\x14\x03\
    \0\x02\x16\x04\x12\x04\xac\x01\x10\x18\n\x0f\n\x07\x04\x14\x03\0\x02\x16\
    \x06\x12\x04\xac\x01\x19'\n\x0f\n\x07\x04\x14\x03\0\x02\x16\x01\x12\x04\
    \xac\x01(7\n\x0f\n\x07\x04\x14\x03\0\x02\x16\x03\x12\x04\xac\x01:<\n\x0e\
    \n\x06\x04\x14\x03\0\x02\x17\x12\x04\xad\x01\x10N\n\x0f\n\x07\x04\x14\
    \x03\0\x02\x17\x04\x12\x04\xad\x01\x10\x18\n\x0f\n\x07\x04\x14\x03\0\x02\
    \x17\x05\x12\x04\xad\x01\x19\x1f\n\x0f\n\x07\x04\x14\x03\0\x02\x17\x01\
    \x12\x04\xad\x01\x20:\n\x0f\n\x07\x04\x14\x03\0\x02\x17\x03\x12\x04\xad\
    \x01=?\n\x0f\n\x07\x04\x14\x03\0\x02\x17\x08\x12\x04\xad\x01@M\n\x0f\n\
    \x07\x04\x14\x03\0\x02\x17\x07\x12\x04\xad\x01KL\n\x0c\n\x04\x04\x14\x02\
    \0\x12\x04\xb0\x01\x08D\n\r\n\x05\x04\x14\x02\0\x04\x12\x04\xb0\x01\x08\
    \x10\n\r\n\x05\x04\x14\x02\0\x06\x12\x04\xb0\x01\x112\n\r\n\x05\x04\x14\
    \x02\0\x01\x12\x04\xb0\x013?\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xb0\x01\
    BC\n\x0c\n\x04\x04\x14\x02\x01\x12\x04\xb1\x01\x08+\n\r\n\x05\x04\x14\
    \x02\x01\x04\x12\x04\xb1\x01\x08\x10\n\r\n\x05\x04\x14\x02\x01\x05\x12\
    \x04\xb1\x01\x11\x17\n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\xb1\x01\x18&\
    \n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\xb1\x01)*\n\x0c\n\x04\x04\x14\x02\
    \x02\x12\x04\xb2\x01\x082\n\r\n\x05\x04\x14\x02\x02\x04\x12\x04\xb2\x01\
    \x08\x10\n\r\n\x05\x04\x14\x02\x02\x05\x12\x04\xb2\x01\x11\x17\n\r\n\x05\
    \x04\x14\x02\x02\x01\x12\x04\xb2\x01\x18-\n\r\n\x05\x04\x14\x02\x02\x03\
    \x12\x04\xb2\x0101\n\x0c\n\x02\x04\x15\x12\x06\xb5\x01\0\xb8\x01\x01\n\
    \x0b\n\x03\x04\x15\x01\x12\x04\xb5\x01\x08\x15\n\x0c\n\x04\x04\x15\x02\0\
    \x12\x04\xb6\x01\x08&\n\r\n\x05\x04\x15\x02\0\x04\x12\x04\xb6\x01\x08\
    \x10\n\r\n\x05\x04\x15\x02\0\x05\x12\x04\xb6\x01\x11\x18\n\r\n\x05\x04\
    \x15\x02\0\x01\x12\x04\xb6\x01\x19!\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\
    \xb6\x01$%\n\x0c\n\x04\x04\x15\x02\x01\x12\x04\xb7\x01\x08,\n\r\n\x05\
    \x04\x15\x02\x01\x04\x12\x04\xb7\x01\x08\x10\n\r\n\x05\x04\x15\x02\x01\
    \x05\x12\x04\xb7\x01\x11\x18\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\xb7\
    \x01\x19'\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\xb7\x01*+\n\x0c\n\x02\
    \x04\x16\x12\x06\xba\x01\0\xbe\x01\x01\n\x0b\n\x03\x04\x16\x01\x12\x04\
    \xba\x01\x08\x12\n\x0c\n\x04\x04\x16\x02\0\x12\x04\xbb\x01\x08&\n\r\n\
    \x05\x04\x16\x02\0\x04\x12\x04\xbb\x01\x08\x10\n\r\n\x05\x04\x16\x02\0\
    \x05\x12\x04\xbb\x01\x11\x18\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\xbb\x01\
    \x19!\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\xbb\x01$%\n\x0c\n\x04\x04\x16\
    \x02\x01\x12\x04\xbc\x01\x08(\n\r\n\x05\x04\x16\x02\x01\x04\x12\x04\xbc\
    \x01\x08\x10\n\r\n\x05\x04\x16\x02\x01\x05\x12\x04\xbc\x01\x11\x16\n\r\n\
    \x05\x04\x16\x02\x01\x01\x12\x04\xbc\x01\x17#\n\r\n\x05\x04\x16\x02\x01\
    \x03\x12\x04\xbc\x01&'\n\x0c\n\x04\x04\x16\x02\x02\x12\x04\xbd\x01\x08(\
    \n\r\n\x05\x04\x16\x02\x02\x04\x12\x04\xbd\x01\x08\x10\n\r\n\x05\x04\x16\
    \x02\x02\x05\x12\x04\xbd\x01\x11\x17\n\r\n\x05\x04\x16\x02\x02\x01\x12\
    \x04\xbd\x01\x18#\n\r\n\x05\x04\x16\x02\x02\x03\x12\x04\xbd\x01&'\n\x0c\
    \n\x02\x04\x17\x12\x06\xc0\x01\0\xc3\x01\x01\n\x0b\n\x03\x04\x17\x01\x12\
    \x04\xc0\x01\x08\x12\n\x0c\n\x04\x04\x17\x02\0\x12\x04\xc1\x01\x08&\n\r\
    \n\x05\x04\x17\x02\0\x04\x12\x04\xc1\x01\x08\x10\n\r\n\x05\x04\x17\x02\0\
    \x05\x12\x04\xc1\x01\x11\x18\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xc1\x01\
    \x19!\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\xc1\x01$%\n\x0c\n\x04\x04\x17\
    \x02\x01\x12\x04\xc2\x01\x08(\n\r\n\x05\x04\x17\x02\x01\x04\x12\x04\xc2\
    \x01\x08\x10\n\r\n\x05\x04\x17\x02\x01\x05\x12\x04\xc2\x01\x11\x16\n\r\n\
    \x05\x04\x17\x02\x01\x01\x12\x04\xc2\x01\x17#\n\r\n\x05\x04\x17\x02\x01\
    \x03\x12\x04\xc2\x01&'\n\x0c\n\x02\x04\x18\x12\x06\xc5\x01\0\xcc\x01\x01\
    \n\x0b\n\x03\x04\x18\x01\x12\x04\xc5\x01\x08\x1a\n\x0c\n\x04\x04\x18\x02\
    \0\x12\x04\xc6\x01\x08(\n\r\n\x05\x04\x18\x02\0\x04\x12\x04\xc6\x01\x08\
    \x10\n\r\n\x05\x04\x18\x02\0\x05\x12\x04\xc6\x01\x11\x17\n\r\n\x05\x04\
    \x18\x02\0\x01\x12\x04\xc6\x01\x18#\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\
    \xc6\x01&'\n\x0c\n\x04\x04\x18\x02\x01\x12\x04\xc7\x01\x08-\n\r\n\x05\
    \x04\x18\x02\x01\x04\x12\x04\xc7\x01\x08\x10\n\r\n\x05\x04\x18\x02\x01\
    \x05\x12\x04\xc7\x01\x11\x17\n\r\n\x05\x04\x18\x02\x01\x01\x12\x04\xc7\
    \x01\x18(\n\r\n\x05\x04\x18\x02\x01\x03\x12\x04\xc7\x01+,\n\x0c\n\x04\
    \x04\x18\x02\x02\x12\x04\xc8\x01\x089\n\r\n\x05\x04\x18\x02\x02\x04\x12\
    \x04\xc8\x01\x08\x10\n\r\n\x05\x04\x18\x02\x02\x05\x12\x04\xc8\x01\x11\
    \x17\n\r\n\x05\x04\x18\x02\x02\x01\x12\x04\xc8\x01\x184\n\r\n\x05\x04\
    \x18\x02\x02\x03\x12\x04\xc8\x0178\n\x0c\n\x04\x04\x18\x02\x03\x12\x04\
    \xc9\x01\x08-\n\r\n\x05\x04\x18\x02\x03\x04\x12\x04\xc9\x01\x08\x10\n\r\
    \n\x05\x04\x18\x02\x03\x06\x12\x04\xc9\x01\x11\x20\n\r\n\x05\x04\x18\x02\
    \x03\x01\x12\x04\xc9\x01!(\n\r\n\x05\x04\x18\x02\x03\x03\x12\x04\xc9\x01\
    +,\n\x0c\n\x04\x04\x18\x02\x04\x12\x04\xca\x01\x08$\n\r\n\x05\x04\x18\
    \x02\x04\x04\x12\x04\xca\x01\x08\x10\n\r\n\x05\x04\x18\x02\x04\x05\x12\
    \x04\xca\x01\x11\x17\n\r\n\x05\x04\x18\x02\x04\x01\x12\x04\xca\x01\x18\
    \x1f\n\r\n\x05\x04\x18\x02\x04\x03\x12\x04\xca\x01\"#\n\x0c\n\x04\x04\
    \x18\x02\x05\x12\x04\xcb\x01\x08-\n\r\n\x05\x04\x18\x02\x05\x04\x12\x04\
    \xcb\x01\x08\x10\n\r\n\x05\x04\x18\x02\x05\x05\x12\x04\xcb\x01\x11\x17\n\
    \r\n\x05\x04\x18\x02\x05\x01\x12\x04\xcb\x01\x18(\n\r\n\x05\x04\x18\x02\
    \x05\x03\x12\x04\xcb\x01+,\n\x0c\n\x02\x04\x19\x12\x06\xce\x01\0\xd2\x01\
    \x01\n\x0b\n\x03\x04\x19\x01\x12\x04\xce\x01\x08\x1d\n\x0c\n\x04\x04\x19\
    \x02\0\x12\x04\xcf\x01\x08'\n\r\n\x05\x04\x19\x02\0\x04\x12\x04\xcf\x01\
    \x08\x10\n\r\n\x05\x04\x19\x02\0\x05\x12\x04\xcf\x01\x11\x17\n\r\n\x05\
    \x04\x19\x02\0\x01\x12\x04\xcf\x01\x18\"\n\r\n\x05\x04\x19\x02\0\x03\x12\
    \x04\xcf\x01%&\n\x0c\n\x04\x04\x19\x02\x01\x12\x04\xd0\x01\x08$\n\r\n\
    \x05\x04\x19\x02\x01\x04\x12\x04\xd0\x01\x08\x10\n\r\n\x05\x04\x19\x02\
    \x01\x05\x12\x04\xd0\x01\x11\x17\n\r\n\x05\x04\x19\x02\x01\x01\x12\x04\
    \xd0\x01\x18\x1f\n\r\n\x05\x04\x19\x02\x01\x03\x12\x04\xd0\x01\"#\n\x0c\
    \n\x04\x04\x19\x02\x02\x12\x04\xd1\x01\x08-\n\r\n\x05\x04\x19\x02\x02\
    \x04\x12\x04\xd1\x01\x08\x10\n\r\n\x05\x04\x19\x02\x02\x05\x12\x04\xd1\
    \x01\x11\x17\n\r\n\x05\x04\x19\x02\x02\x01\x12\x04\xd1\x01\x18(\n\r\n\
    \x05\x04\x19\x02\x02\x03\x12\x04\xd1\x01+,\n\x0c\n\x02\x04\x1a\x12\x06\
    \xd4\x01\0\xec\x01\x01\n\x0b\n\x03\x04\x1a\x01\x12\x04\xd4\x01\x08\x1d\n\
    \x0e\n\x04\x04\x1a\x03\0\x12\x06\xd5\x01\x08\xe8\x01\t\n\r\n\x05\x04\x1a\
    \x03\0\x01\x12\x04\xd5\x01\x10\x17\n\x0e\n\x06\x04\x1a\x03\0\x02\0\x12\
    \x04\xd6\x01\x10/\n\x0f\n\x07\x04\x1a\x03\0\x02\0\x04\x12\x04\xd6\x01\
    \x10\x18\n\x0f\n\x07\x04\x1a\x03\0\x02\0\x05\x12\x04\xd6\x01\x19\x1f\n\
    \x0f\n\x07\x04\x1a\x03\0\x02\0\x01\x12\x04\xd6\x01\x20*\n\x0f\n\x07\x04\
    \x1a\x03\0\x02\0\x03\x12\x04\xd6\x01-.\n\x0e\n\x06\x04\x1a\x03\0\x02\x01\
    \x12\x04\xd7\x01\x102\n\x0f\n\x07\x04\x1a\x03\0\x02\x01\x04\x12\x04\xd7\
    \x01\x10\x18\n\x0f\n\x07\x04\x1a\x03\0\x02\x01\x05\x12\x04\xd7\x01\x19\
    \x20\n\x0f\n\x07\x04\x1a\x03\0\x02\x01\x01\x12\x04\xd7\x01!-\n\x0f\n\x07\
    \x04\x1a\x03\0\x02\x01\x03\x12\x04\xd7\x0101\n\x0e\n\x06\x04\x1a\x03\0\
    \x02\x02\x12\x04\xd8\x01\x107\n\x0f\n\x07\x04\x1a\x03\0\x02\x02\x04\x12\
    \x04\xd8\x01\x10\x18\n\x0f\n\x07\x04\x1a\x03\0\x02\x02\x05\x12\x04\xd8\
    \x01\x19\x20\n\x0f\n\x07\x04\x1a\x03\0\x02\x02\x01\x12\x04\xd8\x01!2\n\
    \x0f\n\x07\x04\x1a\x03\0\x02\x02\x03\x12\x04\xd8\x0156\n\x0e\n\x06\x04\
    \x1a\x03\0\x02\x03\x12\x04\xd9\x01\x100\n\x0f\n\x07\x04\x1a\x03\0\x02\
    \x03\x04\x12\x04\xd9\x01\x10\x18\n\x0f\n\x07\x04\x1a\x03\0\x02\x03\x05\
    \x12\x04\xd9\x01\x19\x1e\n\x0f\n\x07\x04\x1a\x03\0\x02\x03\x01\x12\x04\
    \xd9\x01\x1f+\n\x0f\n\x07\x04\x1a\x03\0\x02\x03\x03\x12\x04\xd9\x01./\n\
    \x0e\n\x06\x04\x1a\x03\0\x02\x04\x12\x04\xda\x01\x100\n\x0f\n\x07\x04\
    \x1a\x03\0\x02\x04\x04\x12\x04\xda\x01\x10\x18\n\x0f\n\x07\x04\x1a\x03\0\
    \x02\x04\x05\x12\x04\xda\x01\x19\x1e\n\x0f\n\x07\x04\x1a\x03\0\x02\x04\
    \x01\x12\x04\xda\x01\x1f+\n\x0f\n\x07\x04\x1a\x03\0\x02\x04\x03\x12\x04\
    \xda\x01./\n\x0e\n\x06\x04\x1a\x03\0\x02\x05\x12\x04\xdb\x01\x103\n\x0f\
    \n\x07\x04\x1a\x03\0\x02\x05\x04\x12\x04\xdb\x01\x10\x18\n\x0f\n\x07\x04\
    \x1a\x03\0\x02\x05\x05\x12\x04\xdb\x01\x19\x1f\n\x0f\n\x07\x04\x1a\x03\0\
    \x02\x05\x01\x12\x04\xdb\x01\x20.\n\x0f\n\x07\x04\x1a\x03\0\x02\x05\x03\
    \x12\x04\xdb\x0112\n\x0e\n\x06\x04\x1a\x03\0\x02\x06\x12\x04\xdc\x01\x10\
    *\n\x0f\n\x07\x04\x1a\x03\0\x02\x06\x04\x12\x04\xdc\x01\x10\x18\n\x0f\n\
    \x07\x04\x1a\x03\0\x02\x06\x05\x12\x04\xdc\x01\x19\x1f\n\x0f\n\x07\x04\
    \x1a\x03\0\x02\x06\x01\x12\x04\xdc\x01\x20%\n\x0f\n\x07\x04\x1a\x03\0\
    \x02\x06\x03\x12\x04\xdc\x01()\n\x0e\n\x06\x04\x1a\x03\0\x02\x07\x12\x04\
    \xdd\x01\x10:\n\x0f\n\x07\x04\x1a\x03\0\x02\x07\x04\x12\x04\xdd\x01\x10\
    \x18\n\x0f\n\x07\x04\x1a\x03\0\x02\x07\x05\x12\x04\xdd\x01\x19\x1f\n\x0f\
    \n\x07\x04\x1a\x03\0\x02\x07\x01\x12\x04\xdd\x01\x205\n\x0f\n\x07\x04\
    \x1a\x03\0\x02\x07\x03\x12\x04\xdd\x0189\n\x0e\n\x06\x04\x1a\x03\0\x02\
    \x08\x12\x04\xde\x01\x101\n\x0f\n\x07\x04\x1a\x03\0\x02\x08\x04\x12\x04\
    \xde\x01\x10\x18\n\x0f\n\x07\x04\x1a\x03\0\x02\x08\x05\x12\x04\xde\x01\
    \x19\x1f\n\x0f\n\x07\x04\x1a\x03\0\x02\x08\x01\x12\x04\xde\x01\x20,\n\
    \x0f\n\x07\x04\x1a\x03\0\x02\x08\x03\x12\x04\xde\x01/0\n\x0e\n\x06\x04\
    \x1a\x03\0\x02\t\x12\x04\xdf\x01\x103\n\x0f\n\x07\x04\x1a\x03\0\x02\t\
    \x04\x12\x04\xdf\x01\x10\x18\n\x0f\n\x07\x04\x1a\x03\0\x02\t\x05\x12\x04\
    \xdf\x01\x19\x1e\n\x0f\n\x07\x04\x1a\x03\0\x02\t\x01\x12\x04\xdf\x01\x1f\
    -\n\x0f\n\x07\x04\x1a\x03\0\x02\t\x03\x12\x04\xdf\x0102\n\x0e\n\x06\x04\
    \x1a\x03\0\x02\n\x12\x04\xe0\x01\x102\n\x0f\n\x07\x04\x1a\x03\0\x02\n\
    \x04\x12\x04\xe0\x01\x10\x18\n\x0f\n\x07\x04\x1a\x03\0\x02\n\x05\x12\x04\
    \xe0\x01\x19\x1e\n\x0f\n\x07\x04\x1a\x03\0\x02\n\x01\x12\x04\xe0\x01\x1f\
    ,\n\x0f\n\x07\x04\x1a\x03\0\x02\n\x03\x12\x04\xe0\x01/1\n\x0e\n\x06\x04\
    \x1a\x03\0\x02\x0b\x12\x04\xe1\x01\x10.\n\x0f\n\x07\x04\x1a\x03\0\x02\
    \x0b\x04\x12\x04\xe1\x01\x10\x18\n\x0f\n\x07\x04\x1a\x03\0\x02\x0b\x05\
    \x12\x04\xe1\x01\x19\x1f\n\x0f\n\x07\x04\x1a\x03\0\x02\x0b\x01\x12\x04\
    \xe1\x01\x20(\n\x0f\n\x07\x04\x1a\x03\0\x02\x0b\x03\x12\x04\xe1\x01+-\n\
    \x0e\n\x06\x04\x1a\x03\0\x02\x0c\x12\x04\xe2\x01\x104\n\x0f\n\x07\x04\
    \x1a\x03\0\x02\x0c\x04\x12\x04\xe2\x01\x10\x18\n\x0f\n\x07\x04\x1a\x03\0\
    \x02\x0c\x05\x12\x04\xe2\x01\x19\x1f\n\x0f\n\x07\x04\x1a\x03\0\x02\x0c\
    \x01\x12\x04\xe2\x01\x20.\n\x0f\n\x07\x04\x1a\x03\0\x02\x0c\x03\x12\x04\
    \xe2\x0113\n\x0e\n\x06\x04\x1a\x03\0\x02\r\x12\x04\xe3\x01\x107\n\x0f\n\
    \x07\x04\x1a\x03\0\x02\r\x04\x12\x04\xe3\x01\x10\x18\n\x0f\n\x07\x04\x1a\
    \x03\0\x02\r\x05\x12\x04\xe3\x01\x19\x1f\n\x0f\n\x07\x04\x1a\x03\0\x02\r\
    \x01\x12\x04\xe3\x01\x201\n\x0f\n\x07\x04\x1a\x03\0\x02\r\x03\x12\x04\
    \xe3\x0146\n\x0e\n\x06\x04\x1a\x03\0\x02\x0e\x12\x04\xe4\x01\x104\n\x0f\
    \n\x07\x04\x1a\x03\0\x02\x0e\x04\x12\x04\xe4\x01\x10\x18\n\x0f\n\x07\x04\
    \x1a\x03\0\x02\x0e\x05\x12\x04\xe4\x01\x19\x1f\n\x0f\n\x07\x04\x1a\x03\0\
    \x02\x0e\x01\x12\x04\xe4\x01\x20.\n\x0f\n\x07\x04\x1a\x03\0\x02\x0e\x03\
    \x12\x04\xe4\x0113\n\x0e\n\x06\x04\x1a\x03\0\x02\x0f\x12\x04\xe5\x01\x10\
    7\n\x0f\n\x07\x04\x1a\x03\0\x02\x0f\x04\x12\x04\xe5\x01\x10\x18\n\x0f\n\
    \x07\x04\x1a\x03\0\x02\x0f\x05\x12\x04\xe5\x01\x19\x1f\n\x0f\n\x07\x04\
    \x1a\x03\0\x02\x0f\x01\x12\x04\xe5\x01\x201\n\x0f\n\x07\x04\x1a\x03\0\
    \x02\x0f\x03\x12\x04\xe5\x0146\n\x0e\n\x06\x04\x1a\x03\0\x02\x10\x12\x04\
    \xe6\x01\x102\n\x0f\n\x07\x04\x1a\x03\0\x02\x10\x04\x12\x04\xe6\x01\x10\
    \x18\n\x0f\n\x07\x04\x1a\x03\0\x02\x10\x05\x12\x04\xe6\x01\x19\x1f\n\x0f\
    \n\x07\x04\x1a\x03\0\x02\x10\x01\x12\x04\xe6\x01\x20,\n\x0f\n\x07\x04\
    \x1a\x03\0\x02\x10\x03\x12\x04\xe6\x01/1\n\x0e\n\x06\x04\x1a\x03\0\x02\
    \x11\x12\x04\xe7\x01\x107\n\x0f\n\x07\x04\x1a\x03\0\x02\x11\x04\x12\x04\
    \xe7\x01\x10\x18\n\x0f\n\x07\x04\x1a\x03\0\x02\x11\x05\x12\x04\xe7\x01\
    \x19\x1f\n\x0f\n\x07\x04\x1a\x03\0\x02\x11\x01\x12\x04\xe7\x01\x201\n\
    \x0f\n\x07\x04\x1a\x03\0\x02\x11\x03\x12\x04\xe7\x0146\n\x0c\n\x04\x04\
    \x1a\x02\0\x12\x04\xea\x01\x081\n\r\n\x05\x04\x1a\x02\0\x04\x12\x04\xea\
    \x01\x08\x10\n\r\n\x05\x04\x1a\x02\0\x05\x12\x04\xea\x01\x11\x16\n\r\n\
    \x05\x04\x1a\x02\0\x01\x12\x04\xea\x01\x17\x1e\n\r\n\x05\x04\x1a\x02\0\
    \x03\x12\x04\xea\x01!\"\n\r\n\x05\x04\x1a\x02\0\x08\x12\x04\xea\x01#0\n\
    \r\n\x05\x04\x1a\x02\0\x07\x12\x04\xea\x01./\n\x0c\n\x04\x04\x1a\x02\x01\
    \x12\x04\xeb\x01\x08=\n\r\n\x05\x04\x1a\x02\x01\x04\x12\x04\xeb\x01\x08\
    \x10\n\r\n\x05\x04\x1a\x02\x01\x06\x12\x04\xeb\x01\x11/\n\r\n\x05\x04\
    \x1a\x02\x01\x01\x12\x04\xeb\x0108\n\r\n\x05\x04\x1a\x02\x01\x03\x12\x04\
    \xeb\x01;<\n\x0c\n\x02\x04\x1b\x12\x06\xee\x01\0\xf4\x01\x01\n\x0b\n\x03\
    \x04\x1b\x01\x12\x04\xee\x01\x08\x1d\n\x0c\n\x04\x04\x1b\x02\0\x12\x04\
    \xef\x01\x08#\n\r\n\x05\x04\x1b\x02\0\x04\x12\x04\xef\x01\x08\x10\n\r\n\
    \x05\x04\x1b\x02\0\x05\x12\x04\xef\x01\x11\x17\n\r\n\x05\x04\x1b\x02\0\
    \x01\x12\x04\xef\x01\x18\x1e\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\xef\x01\
    !\"\n\x0c\n\x04\x04\x1b\x02\x01\x12\x04\xf0\x01\x08*\n\r\n\x05\x04\x1b\
    \x02\x01\x04\x12\x04\xf0\x01\x08\x10\n\r\n\x05\x04\x1b\x02\x01\x05\x12\
    \x04\xf0\x01\x11\x16\n\r\n\x05\x04\x1b\x02\x01\x01\x12\x04\xf0\x01\x17%\
    \n\r\n\x05\x04\x1b\x02\x01\x03\x12\x04\xf0\x01()\n\x0c\n\x04\x04\x1b\x02\
    \x02\x12\x04\xf1\x01\x08!\n\r\n\x05\x04\x1b\x02\x02\x04\x12\x04\xf1\x01\
    \x08\x10\n\r\n\x05\x04\x1b\x02\x02\x05\x12\x04\xf1\x01\x11\x16\n\r\n\x05\
    \x04\x1b\x02\x02\x01\x12\x04\xf1\x01\x17\x1c\n\r\n\x05\x04\x1b\x02\x02\
    \x03\x12\x04\xf1\x01\x1f\x20\n\x0c\n\x04\x04\x1b\x02\x03\x12\x04\xf2\x01\
    \x08#\n\r\n\x05\x04\x1b\x02\x03\x04\x12\x04\xf2\x01\x08\x10\n\r\n\x05\
    \x04\x1b\x02\x03\x05\x12\x04\xf2\x01\x11\x16\n\r\n\x05\x04\x1b\x02\x03\
    \x01\x12\x04\xf2\x01\x17\x1e\n\r\n\x05\x04\x1b\x02\x03\x03\x12\x04\xf2\
    \x01!\"\n\x0c\n\x04\x04\x1b\x02\x04\x12\x04\xf3\x01\x08/\n\r\n\x05\x04\
    \x1b\x02\x04\x04\x12\x04\xf3\x01\x08\x10\n\r\n\x05\x04\x1b\x02\x04\x05\
    \x12\x04\xf3\x01\x11\x16\n\r\n\x05\x04\x1b\x02\x04\x01\x12\x04\xf3\x01\
    \x17*\n\r\n\x05\x04\x1b\x02\x04\x03\x12\x04\xf3\x01-.\n\x0c\n\x02\x04\
    \x1c\x12\x06\xf6\x01\0\xfc\x01\x01\n\x0b\n\x03\x04\x1c\x01\x12\x04\xf6\
    \x01\x08%\n\x0c\n\x04\x04\x1c\x02\0\x12\x04\xf7\x01\x081\n\r\n\x05\x04\
    \x1c\x02\0\x04\x12\x04\xf7\x01\x08\x10\n\r\n\x05\x04\x1c\x02\0\x05\x12\
    \x04\xf7\x01\x11\x16\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\xf7\x01\x17\x1e\
    \n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\xf7\x01!\"\n\r\n\x05\x04\x1c\x02\0\
    \x08\x12\x04\xf7\x01#0\n\r\n\x05\x04\x1c\x02\0\x07\x12\x04\xf7\x01./\n\
    \x0c\n\x04\x04\x1c\x02\x01\x12\x04\xf8\x01\x083\n\r\n\x05\x04\x1c\x02\
    \x01\x04\x12\x04\xf8\x01\x08\x10\n\r\n\x05\x04\x1c\x02\x01\x05\x12\x04\
    \xf8\x01\x11\x16\n\r\n\x05\x04\x1c\x02\x01\x01\x12\x04\xf8\x01\x17.\n\r\
    \n\x05\x04\x1c\x02\x01\x03\x12\x04\xf8\x0112\n\x0c\n\x04\x04\x1c\x02\x02\
    \x12\x04\xf9\x01\x08(\n\r\n\x05\x04\x1c\x02\x02\x04\x12\x04\xf9\x01\x08\
    \x10\n\r\n\x05\x04\x1c\x02\x02\x05\x12\x04\xf9\x01\x11\x15\n\r\n\x05\x04\
    \x1c\x02\x02\x01\x12\x04\xf9\x01\x16#\n\r\n\x05\x04\x1c\x02\x02\x03\x12\
    \x04\xf9\x01&'\n\x0c\n\x04\x04\x1c\x02\x03\x12\x04\xfa\x01\x080\n\r\n\
    \x05\x04\x1c\x02\x03\x04\x12\x04\xfa\x01\x08\x10\n\r\n\x05\x04\x1c\x02\
    \x03\x05\x12\x04\xfa\x01\x11\x16\n\r\n\x05\x04\x1c\x02\x03\x01\x12\x04\
    \xfa\x01\x17+\n\r\n\x05\x04\x1c\x02\x03\x03\x12\x04\xfa\x01./\n\x0c\n\
    \x04\x04\x1c\x02\x04\x12\x04\xfb\x01\x08+\n\r\n\x05\x04\x1c\x02\x04\x04\
    \x12\x04\xfb\x01\x08\x10\n\r\n\x05\x04\x1c\x02\x04\x05\x12\x04\xfb\x01\
    \x11\x16\n\r\n\x05\x04\x1c\x02\x04\x01\x12\x04\xfb\x01\x17&\n\r\n\x05\
    \x04\x1c\x02\x04\x03\x12\x04\xfb\x01)*\n\x0c\n\x02\x04\x1d\x12\x06\xfe\
    \x01\0\x82\x02\x01\n\x0b\n\x03\x04\x1d\x01\x12\x04\xfe\x01\x08\x1b\n\x0c\
    \n\x04\x04\x1d\x02\0\x12\x04\xff\x01\x08#\n\r\n\x05\x04\x1d\x02\0\x04\
    \x12\x04\xff\x01\x08\x10\n\r\n\x05\x04\x1d\x02\0\x05\x12\x04\xff\x01\x11\
    \x17\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\xff\x01\x18\x1e\n\r\n\x05\x04\
    \x1d\x02\0\x03\x12\x04\xff\x01!\"\n\x0c\n\x04\x04\x1d\x02\x01\x12\x04\
    \x80\x02\x08*\n\r\n\x05\x04\x1d\x02\x01\x04\x12\x04\x80\x02\x08\x10\n\r\
    \n\x05\x04\x1d\x02\x01\x05\x12\x04\x80\x02\x11\x16\n\r\n\x05\x04\x1d\x02\
    \x01\x01\x12\x04\x80\x02\x17%\n\r\n\x05\x04\x1d\x02\x01\x03\x12\x04\x80\
    \x02()\n\x0c\n\x04\x04\x1d\x02\x02\x12\x04\x81\x02\x08$\n\r\n\x05\x04\
    \x1d\x02\x02\x04\x12\x04\x81\x02\x08\x10\n\r\n\x05\x04\x1d\x02\x02\x05\
    \x12\x04\x81\x02\x11\x18\n\r\n\x05\x04\x1d\x02\x02\x01\x12\x04\x81\x02\
    \x19\x1f\n\r\n\x05\x04\x1d\x02\x02\x03\x12\x04\x81\x02\"#\n\x0c\n\x02\
    \x04\x1e\x12\x06\x84\x02\0\x86\x02\x01\n\x0b\n\x03\x04\x1e\x01\x12\x04\
    \x84\x02\x08#\n\x0c\n\x04\x04\x1e\x02\0\x12\x04\x85\x02\x081\n\r\n\x05\
    \x04\x1e\x02\0\x04\x12\x04\x85\x02\x08\x10\n\r\n\x05\x04\x1e\x02\0\x05\
    \x12\x04\x85\x02\x11\x16\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\x85\x02\x17\
    \x1e\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\x85\x02!\"\n\r\n\x05\x04\x1e\
    \x02\0\x08\x12\x04\x85\x02#0\n\r\n\x05\x04\x1e\x02\0\x07\x12\x04\x85\x02\
    ./\n\x0c\n\x02\x04\x1f\x12\x06\x88\x02\0\x8e\x02\x01\n\x0b\n\x03\x04\x1f\
    \x01\x12\x04\x88\x02\x08#\n\x0c\n\x04\x04\x1f\x02\0\x12\x04\x89\x02\x08#\
    \n\r\n\x05\x04\x1f\x02\0\x04\x12\x04\x89\x02\x08\x10\n\r\n\x05\x04\x1f\
    \x02\0\x05\x12\x04\x89\x02\x11\x17\n\r\n\x05\x04\x1f\x02\0\x01\x12\x04\
    \x89\x02\x18\x1e\n\r\n\x05\x04\x1f\x02\0\x03\x12\x04\x89\x02!\"\n\x0c\n\
    \x04\x04\x1f\x02\x01\x12\x04\x8a\x02\x083\n\r\n\x05\x04\x1f\x02\x01\x04\
    \x12\x04\x8a\x02\x08\x10\n\r\n\x05\x04\x1f\x02\x01\x05\x12\x04\x8a\x02\
    \x11\x16\n\r\n\x05\x04\x1f\x02\x01\x01\x12\x04\x8a\x02\x17.\n\r\n\x05\
    \x04\x1f\x02\x01\x03\x12\x04\x8a\x0212\n\x0c\n\x04\x04\x1f\x02\x02\x12\
    \x04\x8b\x02\x084\n\r\n\x05\x04\x1f\x02\x02\x04\x12\x04\x8b\x02\x08\x10\
    \n\r\n\x05\x04\x1f\x02\x02\x05\x12\x04\x8b\x02\x11\x16\n\r\n\x05\x04\x1f\
    \x02\x02\x01\x12\x04\x8b\x02\x17/\n\r\n\x05\x04\x1f\x02\x02\x03\x12\x04\
    \x8b\x0223\n\x0c\n\x04\x04\x1f\x02\x03\x12\x04\x8c\x02\x08.\n\r\n\x05\
    \x04\x1f\x02\x03\x04\x12\x04\x8c\x02\x08\x10\n\r\n\x05\x04\x1f\x02\x03\
    \x05\x12\x04\x8c\x02\x11\x15\n\r\n\x05\x04\x1f\x02\x03\x01\x12\x04\x8c\
    \x02\x16)\n\r\n\x05\x04\x1f\x02\x03\x03\x12\x04\x8c\x02,-\n\x0c\n\x04\
    \x04\x1f\x02\x04\x12\x04\x8d\x02\x08-\n\r\n\x05\x04\x1f\x02\x04\x04\x12\
    \x04\x8d\x02\x08\x10\n\r\n\x05\x04\x1f\x02\x04\x05\x12\x04\x8d\x02\x11\
    \x17\n\r\n\x05\x04\x1f\x02\x04\x01\x12\x04\x8d\x02\x18(\n\r\n\x05\x04\
    \x1f\x02\x04\x03\x12\x04\x8d\x02+,\n\x0c\n\x02\x04\x20\x12\x06\x90\x02\0\
    \x97\x02\x01\n\x0b\n\x03\x04\x20\x01\x12\x04\x90\x02\x08+\n\x0c\n\x04\
    \x04\x20\x02\0\x12\x04\x91\x02\x081\n\r\n\x05\x04\x20\x02\0\x04\x12\x04\
    \x91\x02\x08\x10\n\r\n\x05\x04\x20\x02\0\x05\x12\x04\x91\x02\x11\x16\n\r\
    \n\x05\x04\x20\x02\0\x01\x12\x04\x91\x02\x17\x1e\n\r\n\x05\x04\x20\x02\0\
    \x03\x12\x04\x91\x02!\"\n\r\n\x05\x04\x20\x02\0\x08\x12\x04\x91\x02#0\n\
    \r\n\x05\x04\x20\x02\0\x07\x12\x04\x91\x02./\n\x0c\n\x04\x04\x20\x02\x01\
    \x12\x04\x92\x02\x08*\n\r\n\x05\x04\x20\x02\x01\x04\x12\x04\x92\x02\x08\
    \x10\n\r\n\x05\x04\x20\x02\x01\x05\x12\x04\x92\x02\x11\x16\n\r\n\x05\x04\
    \x20\x02\x01\x01\x12\x04\x92\x02\x17%\n\r\n\x05\x04\x20\x02\x01\x03\x12\
    \x04\x92\x02()\n\x0c\n\x04\x04\x20\x02\x02\x12\x04\x93\x02\x083\n\r\n\
    \x05\x04\x20\x02\x02\x04\x12\x04\x93\x02\x08\x10\n\r\n\x05\x04\x20\x02\
    \x02\x05\x12\x04\x93\x02\x11\x16\n\r\n\x05\x04\x20\x02\x02\x01\x12\x04\
    \x93\x02\x17.\n\r\n\x05\x04\x20\x02\x02\x03\x12\x04\x93\x0212\n\x0c\n\
    \x04\x04\x20\x02\x03\x12\x04\x94\x02\x08A\n\r\n\x05\x04\x20\x02\x03\x04\
    \x12\x04\x94\x02\x08\x10\n\r\n\x05\x04\x20\x02\x03\x05\x12\x04\x94\x02\
    \x11\x16\n\r\n\x05\x04\x20\x02\x03\x01\x12\x04\x94\x02\x17.\n\r\n\x05\
    \x04\x20\x02\x03\x03\x12\x04\x94\x0212\n\r\n\x05\x04\x20\x02\x03\x08\x12\
    \x04\x94\x023@\n\r\n\x05\x04\x20\x02\x03\x07\x12\x04\x94\x02>?\n\x0c\n\
    \x04\x04\x20\x02\x04\x12\x04\x95\x02\x08B\n\r\n\x05\x04\x20\x02\x04\x04\
    \x12\x04\x95\x02\x08\x10\n\r\n\x05\x04\x20\x02\x04\x05\x12\x04\x95\x02\
    \x11\x16\n\r\n\x05\x04\x20\x02\x04\x01\x12\x04\x95\x02\x17/\n\r\n\x05\
    \x04\x20\x02\x04\x03\x12\x04\x95\x0223\n\r\n\x05\x04\x20\x02\x04\x08\x12\
    \x04\x95\x024A\n\r\n\x05\x04\x20\x02\x04\x07\x12\x04\x95\x02?@\n\x0c\n\
    \x04\x04\x20\x02\x05\x12\x04\x96\x02\x08-\n\r\n\x05\x04\x20\x02\x05\x04\
    \x12\x04\x96\x02\x08\x10\n\r\n\x05\x04\x20\x02\x05\x05\x12\x04\x96\x02\
    \x11\x17\n\r\n\x05\x04\x20\x02\x05\x01\x12\x04\x96\x02\x18(\n\r\n\x05\
    \x04\x20\x02\x05\x03\x12\x04\x96\x02+,\n\x0c\n\x02\x04!\x12\x06\x99\x02\
    \0\xa0\x02\x01\n\x0b\n\x03\x04!\x01\x12\x04\x99\x02\x08!\n\x0c\n\x04\x04\
    !\x02\0\x12\x04\x9a\x02\x08\"\n\r\n\x05\x04!\x02\0\x04\x12\x04\x9a\x02\
    \x08\x10\n\r\n\x05\x04!\x02\0\x05\x12\x04\x9a\x02\x11\x16\n\r\n\x05\x04!\
    \x02\0\x01\x12\x04\x9a\x02\x17\x1d\n\r\n\x05\x04!\x02\0\x03\x12\x04\x9a\
    \x02\x20!\n\x0c\n\x04\x04!\x02\x01\x12\x04\x9b\x02\x08*\n\r\n\x05\x04!\
    \x02\x01\x04\x12\x04\x9b\x02\x08\x10\n\r\n\x05\x04!\x02\x01\x05\x12\x04\
    \x9b\x02\x11\x16\n\r\n\x05\x04!\x02\x01\x01\x12\x04\x9b\x02\x17%\n\r\n\
    \x05\x04!\x02\x01\x03\x12\x04\x9b\x02()\n\x0c\n\x04\x04!\x02\x02\x12\x04\
    \x9c\x02\x08'\n\r\n\x05\x04!\x02\x02\x04\x12\x04\x9c\x02\x08\x10\n\r\n\
    \x05\x04!\x02\x02\x05\x12\x04\x9c\x02\x11\x16\n\r\n\x05\x04!\x02\x02\x01\
    \x12\x04\x9c\x02\x17\"\n\r\n\x05\x04!\x02\x02\x03\x12\x04\x9c\x02%&\n\
    \x0c\n\x04\x04!\x02\x03\x12\x04\x9d\x02\x08%\n\r\n\x05\x04!\x02\x03\x04\
    \x12\x04\x9d\x02\x08\x10\n\r\n\x05\x04!\x02\x03\x05\x12\x04\x9d\x02\x11\
    \x16\n\r\n\x05\x04!\x02\x03\x01\x12\x04\x9d\x02\x17\x20\n\r\n\x05\x04!\
    \x02\x03\x03\x12\x04\x9d\x02#$\n\x0c\n\x04\x04!\x02\x04\x12\x04\x9e\x02\
    \x084\n\r\n\x05\x04!\x02\x04\x04\x12\x04\x9e\x02\x08\x10\n\r\n\x05\x04!\
    \x02\x04\x05\x12\x04\x9e\x02\x11\x16\n\r\n\x05\x04!\x02\x04\x01\x12\x04\
    \x9e\x02\x17/\n\r\n\x05\x04!\x02\x04\x03\x12\x04\x9e\x0223\n\x0c\n\x04\
    \x04!\x02\x05\x12\x04\x9f\x02\x08&\n\r\n\x05\x04!\x02\x05\x04\x12\x04\
    \x9f\x02\x08\x10\n\r\n\x05\x04!\x02\x05\x05\x12\x04\x9f\x02\x11\x18\n\r\
    \n\x05\x04!\x02\x05\x01\x12\x04\x9f\x02\x19!\n\r\n\x05\x04!\x02\x05\x03\
    \x12\x04\x9f\x02$%\n\x0c\n\x02\x04\"\x12\x06\xa2\x02\0\xae\x02\x01\n\x0b\
    \n\x03\x04\"\x01\x12\x04\xa2\x02\x08)\n\x0e\n\x04\x04\"\x03\0\x12\x06\
    \xa3\x02\x08\xa9\x02\t\n\r\n\x05\x04\"\x03\0\x01\x12\x04\xa3\x02\x10\x15\
    \n\x0e\n\x06\x04\"\x03\0\x02\0\x12\x04\xa4\x02\x103\n\x0f\n\x07\x04\"\
    \x03\0\x02\0\x04\x12\x04\xa4\x02\x10\x18\n\x0f\n\x07\x04\"\x03\0\x02\0\
    \x05\x12\x04\xa4\x02\x19\x20\n\x0f\n\x07\x04\"\x03\0\x02\0\x01\x12\x04\
    \xa4\x02!.\n\x0f\n\x07\x04\"\x03\0\x02\0\x03\x12\x04\xa4\x0212\n\x0e\n\
    \x06\x04\"\x03\0\x02\x01\x12\x04\xa5\x02\x10/\n\x0f\n\x07\x04\"\x03\0\
    \x02\x01\x04\x12\x04\xa5\x02\x10\x18\n\x0f\n\x07\x04\"\x03\0\x02\x01\x05\
    \x12\x04\xa5\x02\x19\x1e\n\x0f\n\x07\x04\"\x03\0\x02\x01\x01\x12\x04\xa5\
    \x02\x1f*\n\x0f\n\x07\x04\"\x03\0\x02\x01\x03\x12\x04\xa5\x02-.\n\x0e\n\
    \x06\x04\"\x03\0\x02\x02\x12\x04\xa6\x02\x10)\n\x0f\n\x07\x04\"\x03\0\
    \x02\x02\x04\x12\x04\xa6\x02\x10\x18\n\x0f\n\x07\x04\"\x03\0\x02\x02\x05\
    \x12\x04\xa6\x02\x19\x1e\n\x0f\n\x07\x04\"\x03\0\x02\x02\x01\x12\x04\xa6\
    \x02\x1f$\n\x0f\n\x07\x04\"\x03\0\x02\x02\x03\x12\x04\xa6\x02'(\n\x0e\n\
    \x06\x04\"\x03\0\x02\x03\x12\x04\xa7\x02\x10+\n\x0f\n\x07\x04\"\x03\0\
    \x02\x03\x04\x12\x04\xa7\x02\x10\x18\n\x0f\n\x07\x04\"\x03\0\x02\x03\x05\
    \x12\x04\xa7\x02\x19\x1e\n\x0f\n\x07\x04\"\x03\0\x02\x03\x01\x12\x04\xa7\
    \x02\x1f&\n\x0f\n\x07\x04\"\x03\0\x02\x03\x03\x12\x04\xa7\x02)*\n\x0e\n\
    \x06\x04\"\x03\0\x02\x04\x12\x04\xa8\x02\x10,\n\x0f\n\x07\x04\"\x03\0\
    \x02\x04\x04\x12\x04\xa8\x02\x10\x18\n\x0f\n\x07\x04\"\x03\0\x02\x04\x05\
    \x12\x04\xa8\x02\x19\x20\n\x0f\n\x07\x04\"\x03\0\x02\x04\x01\x12\x04\xa8\
    \x02!'\n\x0f\n\x07\x04\"\x03\0\x02\x04\x03\x12\x04\xa8\x02*+\n\x0c\n\x04\
    \x04\"\x02\0\x12\x04\xab\x02\x081\n\r\n\x05\x04\"\x02\0\x04\x12\x04\xab\
    \x02\x08\x10\n\r\n\x05\x04\"\x02\0\x05\x12\x04\xab\x02\x11\x16\n\r\n\x05\
    \x04\"\x02\0\x01\x12\x04\xab\x02\x17\x1e\n\r\n\x05\x04\"\x02\0\x03\x12\
    \x04\xab\x02!\"\n\r\n\x05\x04\"\x02\0\x08\x12\x04\xab\x02#0\n\r\n\x05\
    \x04\"\x02\0\x07\x12\x04\xab\x02./\n\x0c\n\x04\x04\"\x02\x01\x12\x04\xac\
    \x02\x083\n\r\n\x05\x04\"\x02\x01\x04\x12\x04\xac\x02\x08\x10\n\r\n\x05\
    \x04\"\x02\x01\x05\x12\x04\xac\x02\x11\x16\n\r\n\x05\x04\"\x02\x01\x01\
    \x12\x04\xac\x02\x17.\n\r\n\x05\x04\"\x02\x01\x03\x12\x04\xac\x0212\n\
    \x0c\n\x04\x04\"\x02\x02\x12\x04\xad\x02\x08F\n\r\n\x05\x04\"\x02\x02\
    \x04\x12\x04\xad\x02\x08\x10\n\r\n\x05\x04\"\x02\x02\x06\x12\x04\xad\x02\
    \x119\n\r\n\x05\x04\"\x02\x02\x01\x12\x04\xad\x02:A\n\r\n\x05\x04\"\x02\
    \x02\x03\x12\x04\xad\x02DE\n\x0c\n\x02\x04#\x12\x06\xb0\x02\0\xb5\x02\
    \x01\n\x0b\n\x03\x04#\x01\x12\x04\xb0\x02\x08\"\n\x0c\n\x04\x04#\x02\0\
    \x12\x04\xb1\x02\x08.\n\r\n\x05\x04#\x02\0\x04\x12\x04\xb1\x02\x08\x10\n\
    \r\n\x05\x04#\x02\0\x05\x12\x04\xb1\x02\x11\x15\n\r\n\x05\x04#\x02\0\x01\
    \x12\x04\xb1\x02\x16)\n\r\n\x05\x04#\x02\0\x03\x12\x04\xb1\x02,-\n\x0c\n\
    \x04\x04#\x02\x01\x12\x04\xb2\x02\x08/\n\r\n\x05\x04#\x02\x01\x04\x12\
    \x04\xb2\x02\x08\x10\n\r\n\x05\x04#\x02\x01\x05\x12\x04\xb2\x02\x11\x15\
    \n\r\n\x05\x04#\x02\x01\x01\x12\x04\xb2\x02\x16*\n\r\n\x05\x04#\x02\x01\
    \x03\x12\x04\xb2\x02-.\n\x0c\n\x04\x04#\x02\x02\x12\x04\xb3\x02\x08-\n\r\
    \n\x05\x04#\x02\x02\x04\x12\x04\xb3\x02\x08\x10\n\r\n\x05\x04#\x02\x02\
    \x05\x12\x04\xb3\x02\x11\x15\n\r\n\x05\x04#\x02\x02\x01\x12\x04\xb3\x02\
    \x16(\n\r\n\x05\x04#\x02\x02\x03\x12\x04\xb3\x02+,\n\x0c\n\x04\x04#\x02\
    \x03\x12\x04\xb4\x02\x08H\n\r\n\x05\x04#\x02\x03\x04\x12\x04\xb4\x02\x08\
    \x10\n\r\n\x05\x04#\x02\x03\x05\x12\x04\xb4\x02\x11\x15\n\r\n\x05\x04#\
    \x02\x03\x01\x12\x04\xb4\x02\x16C\n\r\n\x05\x04#\x02\x03\x03\x12\x04\xb4\
    \x02FG\n\x0c\n\x02\x04$\x12\x06\xb7\x02\0\xbe\x02\x01\n\x0b\n\x03\x04$\
    \x01\x12\x04\xb7\x02\x08&\n\x0e\n\x04\x04$\x03\0\x12\x06\xb8\x02\x08\xbb\
    \x02\t\n\r\n\x05\x04$\x03\0\x01\x12\x04\xb8\x02\x10\x1b\n\x0e\n\x06\x04$\
    \x03\0\x02\0\x12\x04\xb9\x02\x100\n\x0f\n\x07\x04$\x03\0\x02\0\x04\x12\
    \x04\xb9\x02\x10\x18\n\x0f\n\x07\x04$\x03\0\x02\0\x05\x12\x04\xb9\x02\
    \x19\x1f\n\x0f\n\x07\x04$\x03\0\x02\0\x01\x12\x04\xb9\x02\x20+\n\x0f\n\
    \x07\x04$\x03\0\x02\0\x03\x12\x04\xb9\x02./\n\x0e\n\x06\x04$\x03\0\x02\
    \x01\x12\x04\xba\x02\x10:\n\x0f\n\x07\x04$\x03\0\x02\x01\x04\x12\x04\xba\
    \x02\x10\x18\n\x0f\n\x07\x04$\x03\0\x02\x01\x05\x12\x04\xba\x02\x19\x1f\
    \n\x0f\n\x07\x04$\x03\0\x02\x01\x01\x12\x04\xba\x02\x205\n\x0f\n\x07\x04\
    $\x03\0\x02\x01\x03\x12\x04\xba\x0289\n\x0c\n\x04\x04$\x02\0\x12\x04\xbd\
    \x02\x08O\n\r\n\x05\x04$\x02\0\x04\x12\x04\xbd\x02\x08\x10\n\r\n\x05\x04\
    $\x02\0\x06\x12\x04\xbd\x02\x11<\n\r\n\x05\x04$\x02\0\x01\x12\x04\xbd\
    \x02=J\n\r\n\x05\x04$\x02\0\x03\x12\x04\xbd\x02MN\n\x0c\n\x02\x04%\x12\
    \x06\xc0\x02\0\xcb\x02\x01\n\x0b\n\x03\x04%\x01\x12\x04\xc0\x02\x08\x17\
    \n\x0e\n\x04\x04%\x03\0\x12\x06\xc1\x02\x08\xc8\x02\t\n\r\n\x05\x04%\x03\
    \0\x01\x12\x04\xc1\x02\x10\x1a\n\x0e\n\x06\x04%\x03\0\x02\0\x12\x04\xc2\
    \x02\x100\n\x0f\n\x07\x04%\x03\0\x02\0\x04\x12\x04\xc2\x02\x10\x18\n\x0f\
    \n\x07\x04%\x03\0\x02\0\x05\x12\x04\xc2\x02\x19\x1f\n\x0f\n\x07\x04%\x03\
    \0\x02\0\x01\x12\x04\xc2\x02\x20+\n\x0f\n\x07\x04%\x03\0\x02\0\x03\x12\
    \x04\xc2\x02./\n\x0e\n\x06\x04%\x03\0\x02\x01\x12\x04\xc3\x02\x10,\n\x0f\
    \n\x07\x04%\x03\0\x02\x01\x04\x12\x04\xc3\x02\x10\x18\n\x0f\n\x07\x04%\
    \x03\0\x02\x01\x05\x12\x04\xc3\x02\x19\x1e\n\x0f\n\x07\x04%\x03\0\x02\
    \x01\x01\x12\x04\xc3\x02\x1f'\n\x0f\n\x07\x04%\x03\0\x02\x01\x03\x12\x04\
    \xc3\x02*+\n\x0e\n\x06\x04%\x03\0\x02\x02\x12\x04\xc4\x02\x100\n\x0f\n\
    \x07\x04%\x03\0\x02\x02\x04\x12\x04\xc4\x02\x10\x18\n\x0f\n\x07\x04%\x03\
    \0\x02\x02\x05\x12\x04\xc4\x02\x19\x1f\n\x0f\n\x07\x04%\x03\0\x02\x02\
    \x01\x12\x04\xc4\x02\x20+\n\x0f\n\x07\x04%\x03\0\x02\x02\x03\x12\x04\xc4\
    \x02./\n\x0e\n\x06\x04%\x03\0\x02\x03\x12\x04\xc5\x02\x10,\n\x0f\n\x07\
    \x04%\x03\0\x02\x03\x04\x12\x04\xc5\x02\x10\x18\n\x0f\n\x07\x04%\x03\0\
    \x02\x03\x05\x12\x04\xc5\x02\x19\x1f\n\x0f\n\x07\x04%\x03\0\x02\x03\x01\
    \x12\x04\xc5\x02\x20'\n\x0f\n\x07\x04%\x03\0\x02\x03\x03\x12\x04\xc5\x02\
    *+\n\x0e\n\x06\x04%\x03\0\x02\x04\x12\x04\xc6\x02\x10-\n\x0f\n\x07\x04%\
    \x03\0\x02\x04\x04\x12\x04\xc6\x02\x10\x18\n\x0f\n\x07\x04%\x03\0\x02\
    \x04\x05\x12\x04\xc6\x02\x19\x1f\n\x0f\n\x07\x04%\x03\0\x02\x04\x01\x12\
    \x04\xc6\x02\x20(\n\x0f\n\x07\x04%\x03\0\x02\x04\x03\x12\x04\xc6\x02+,\n\
    \x0e\n\x06\x04%\x03\0\x02\x05\x12\x04\xc7\x02\x10+\n\x0f\n\x07\x04%\x03\
    \0\x02\x05\x04\x12\x04\xc7\x02\x10\x18\n\x0f\n\x07\x04%\x03\0\x02\x05\
    \x05\x12\x04\xc7\x02\x19\x1f\n\x0f\n\x07\x04%\x03\0\x02\x05\x01\x12\x04\
    \xc7\x02\x20&\n\x0f\n\x07\x04%\x03\0\x02\x05\x03\x12\x04\xc7\x02)*\n\x0c\
    \n\x04\x04%\x02\0\x12\x04\xca\x02\x08=\n\r\n\x05\x04%\x02\0\x04\x12\x04\
    \xca\x02\x08\x10\n\r\n\x05\x04%\x02\0\x06\x12\x04\xca\x02\x11,\n\r\n\x05\
    \x04%\x02\0\x01\x12\x04\xca\x02-8\n\r\n\x05\x04%\x02\0\x03\x12\x04\xca\
    \x02;<\n\x0c\n\x02\x04&\x12\x06\xcd\x02\0\xd2\x02\x01\n\x0b\n\x03\x04&\
    \x01\x12\x04\xcd\x02\x08/\n\x0c\n\x04\x04&\x02\0\x12\x04\xce\x02\x08#\n\
    \r\n\x05\x04&\x02\0\x04\x12\x04\xce\x02\x08\x10\n\r\n\x05\x04&\x02\0\x05\
    \x12\x04\xce\x02\x11\x17\n\r\n\x05\x04&\x02\0\x01\x12\x04\xce\x02\x18\
    \x1e\n\r\n\x05\x04&\x02\0\x03\x12\x04\xce\x02!\"\n\x0c\n\x04\x04&\x02\
    \x01\x12\x04\xcf\x02\x08-\n\r\n\x05\x04&\x02\x01\x04\x12\x04\xcf\x02\x08\
    \x10\n\r\n\x05\x04&\x02\x01\x05\x12\x04\xcf\x02\x11\x15\n\r\n\x05\x04&\
    \x02\x01\x01\x12\x04\xcf\x02\x16(\n\r\n\x05\x04&\x02\x01\x03\x12\x04\xcf\
    \x02+,\n\x0c\n\x04\x04&\x02\x02\x12\x04\xd0\x02\x08/\n\r\n\x05\x04&\x02\
    \x02\x04\x12\x04\xd0\x02\x08\x10\n\r\n\x05\x04&\x02\x02\x05\x12\x04\xd0\
    \x02\x11\x16\n\r\n\x05\x04&\x02\x02\x01\x12\x04\xd0\x02\x17*\n\r\n\x05\
    \x04&\x02\x02\x03\x12\x04\xd0\x02-.\n\x0c\n\x04\x04&\x02\x03\x12\x04\xd1\
    \x02\x088\n\r\n\x05\x04&\x02\x03\x04\x12\x04\xd1\x02\x08\x10\n\r\n\x05\
    \x04&\x02\x03\x05\x12\x04\xd1\x02\x11\x16\n\r\n\x05\x04&\x02\x03\x01\x12\
    \x04\xd1\x02\x173\n\r\n\x05\x04&\x02\x03\x03\x12\x04\xd1\x0267\n\x0c\n\
    \x02\x04'\x12\x06\xd4\x02\0\xde\x02\x01\n\x0b\n\x03\x04'\x01\x12\x04\xd4\
    \x02\x08\x20\n\x0c\n\x04\x04'\x02\0\x12\x04\xd5\x02\x08#\n\r\n\x05\x04'\
    \x02\0\x04\x12\x04\xd5\x02\x08\x10\n\r\n\x05\x04'\x02\0\x05\x12\x04\xd5\
    \x02\x11\x17\n\r\n\x05\x04'\x02\0\x01\x12\x04\xd5\x02\x18\x1e\n\r\n\x05\
    \x04'\x02\0\x03\x12\x04\xd5\x02!\"\n\x0c\n\x04\x04'\x02\x01\x12\x04\xd6\
    \x02\x08'\n\r\n\x05\x04'\x02\x01\x04\x12\x04\xd6\x02\x08\x10\n\r\n\x05\
    \x04'\x02\x01\x05\x12\x04\xd6\x02\x11\x16\n\r\n\x05\x04'\x02\x01\x01\x12\
    \x04\xd6\x02\x17\"\n\r\n\x05\x04'\x02\x01\x03\x12\x04\xd6\x02%&\n\x0c\n\
    \x04\x04'\x02\x02\x12\x04\xd7\x02\x08&\n\r\n\x05\x04'\x02\x02\x04\x12\
    \x04\xd7\x02\x08\x10\n\r\n\x05\x04'\x02\x02\x05\x12\x04\xd7\x02\x11\x16\
    \n\r\n\x05\x04'\x02\x02\x01\x12\x04\xd7\x02\x17!\n\r\n\x05\x04'\x02\x02\
    \x03\x12\x04\xd7\x02$%\n\x0c\n\x04\x04'\x02\x03\x12\x04\xd8\x02\x08'\n\r\
    \n\x05\x04'\x02\x03\x04\x12\x04\xd8\x02\x08\x10\n\r\n\x05\x04'\x02\x03\
    \x05\x12\x04\xd8\x02\x11\x16\n\r\n\x05\x04'\x02\x03\x01\x12\x04\xd8\x02\
    \x17\"\n\r\n\x05\x04'\x02\x03\x03\x12\x04\xd8\x02%&\n\x0c\n\x04\x04'\x02\
    \x04\x12\x04\xd9\x02\x08$\n\r\n\x05\x04'\x02\x04\x04\x12\x04\xd9\x02\x08\
    \x10\n\r\n\x05\x04'\x02\x04\x05\x12\x04\xd9\x02\x11\x17\n\r\n\x05\x04'\
    \x02\x04\x01\x12\x04\xd9\x02\x18\x1f\n\r\n\x05\x04'\x02\x04\x03\x12\x04\
    \xd9\x02\"#\n\x0c\n\x04\x04'\x02\x05\x12\x04\xda\x02\x081\n\r\n\x05\x04'\
    \x02\x05\x04\x12\x04\xda\x02\x08\x10\n\r\n\x05\x04'\x02\x05\x05\x12\x04\
    \xda\x02\x11\x17\n\r\n\x05\x04'\x02\x05\x01\x12\x04\xda\x02\x18,\n\r\n\
    \x05\x04'\x02\x05\x03\x12\x04\xda\x02/0\n\x0c\n\x04\x04'\x02\x06\x12\x04\
    \xdb\x02\x08$\n\r\n\x05\x04'\x02\x06\x04\x12\x04\xdb\x02\x08\x10\n\r\n\
    \x05\x04'\x02\x06\x05\x12\x04\xdb\x02\x11\x16\n\r\n\x05\x04'\x02\x06\x01\
    \x12\x04\xdb\x02\x17\x1f\n\r\n\x05\x04'\x02\x06\x03\x12\x04\xdb\x02\"#\n\
    \x0c\n\x04\x04'\x02\x07\x12\x04\xdc\x02\x08/\n\r\n\x05\x04'\x02\x07\x04\
    \x12\x04\xdc\x02\x08\x10\n\r\n\x05\x04'\x02\x07\x05\x12\x04\xdc\x02\x11\
    \x17\n\r\n\x05\x04'\x02\x07\x01\x12\x04\xdc\x02\x18*\n\r\n\x05\x04'\x02\
    \x07\x03\x12\x04\xdc\x02-.\n\x0c\n\x04\x04'\x02\x08\x12\x04\xdd\x02\x08.\
    \n\r\n\x05\x04'\x02\x08\x04\x12\x04\xdd\x02\x08\x10\n\r\n\x05\x04'\x02\
    \x08\x06\x12\x04\xdd\x02\x11\x1f\n\r\n\x05\x04'\x02\x08\x01\x12\x04\xdd\
    \x02\x20)\n\r\n\x05\x04'\x02\x08\x03\x12\x04\xdd\x02,-\n\x0c\n\x02\x04(\
    \x12\x06\xe0\x02\0\xe4\x02\x01\n\x0b\n\x03\x04(\x01\x12\x04\xe0\x02\x08(\
    \n\x0c\n\x04\x04(\x02\0\x12\x04\xe1\x02\x08#\n\r\n\x05\x04(\x02\0\x04\
    \x12\x04\xe1\x02\x08\x10\n\r\n\x05\x04(\x02\0\x05\x12\x04\xe1\x02\x11\
    \x17\n\r\n\x05\x04(\x02\0\x01\x12\x04\xe1\x02\x18\x1e\n\r\n\x05\x04(\x02\
    \0\x03\x12\x04\xe1\x02!\"\n\x0c\n\x04\x04(\x02\x01\x12\x04\xe2\x02\x08,\
    \n\r\n\x05\x04(\x02\x01\x04\x12\x04\xe2\x02\x08\x10\n\r\n\x05\x04(\x02\
    \x01\x05\x12\x04\xe2\x02\x11\x18\n\r\n\x05\x04(\x02\x01\x01\x12\x04\xe2\
    \x02\x19'\n\r\n\x05\x04(\x02\x01\x03\x12\x04\xe2\x02*+\n\x0c\n\x04\x04(\
    \x02\x02\x12\x04\xe3\x02\x081\n\r\n\x05\x04(\x02\x02\x04\x12\x04\xe3\x02\
    \x08\x10\n\r\n\x05\x04(\x02\x02\x05\x12\x04\xe3\x02\x11\x16\n\r\n\x05\
    \x04(\x02\x02\x01\x12\x04\xe3\x02\x17\x1e\n\r\n\x05\x04(\x02\x02\x03\x12\
    \x04\xe3\x02!\"\n\r\n\x05\x04(\x02\x02\x08\x12\x04\xe3\x02#0\n\r\n\x05\
    \x04(\x02\x02\x07\x12\x04\xe3\x02./\n\x0c\n\x02\x04)\x12\x06\xe6\x02\0\
    \xea\x02\x01\n\x0b\n\x03\x04)\x01\x12\x04\xe6\x02\x08\x1e\n\x0c\n\x04\
    \x04)\x02\0\x12\x04\xe7\x02\x08#\n\r\n\x05\x04)\x02\0\x04\x12\x04\xe7\
    \x02\x08\x10\n\r\n\x05\x04)\x02\0\x05\x12\x04\xe7\x02\x11\x17\n\r\n\x05\
    \x04)\x02\0\x01\x12\x04\xe7\x02\x18\x1e\n\r\n\x05\x04)\x02\0\x03\x12\x04\
    \xe7\x02!\"\n\x0c\n\x04\x04)\x02\x01\x12\x04\xe8\x02\x08,\n\r\n\x05\x04)\
    \x02\x01\x04\x12\x04\xe8\x02\x08\x10\n\r\n\x05\x04)\x02\x01\x05\x12\x04\
    \xe8\x02\x11\x18\n\r\n\x05\x04)\x02\x01\x01\x12\x04\xe8\x02\x19'\n\r\n\
    \x05\x04)\x02\x01\x03\x12\x04\xe8\x02*+\n\x0c\n\x04\x04)\x02\x02\x12\x04\
    \xe9\x02\x08)\n\r\n\x05\x04)\x02\x02\x04\x12\x04\xe9\x02\x08\x10\n\r\n\
    \x05\x04)\x02\x02\x05\x12\x04\xe9\x02\x11\x17\n\r\n\x05\x04)\x02\x02\x01\
    \x12\x04\xe9\x02\x18$\n\r\n\x05\x04)\x02\x02\x03\x12\x04\xe9\x02'(\n\x0c\
    \n\x02\x04*\x12\x06\xec\x02\0\xfc\x02\x01\n\x0b\n\x03\x04*\x01\x12\x04\
    \xec\x02\x08&\n\x0e\n\x04\x04*\x03\0\x12\x06\xed\x02\x08\xf1\x02\t\n\r\n\
    \x05\x04*\x03\0\x01\x12\x04\xed\x02\x10\x16\n\x0e\n\x06\x04*\x03\0\x02\0\
    \x12\x04\xee\x02\x10.\n\x0f\n\x07\x04*\x03\0\x02\0\x04\x12\x04\xee\x02\
    \x10\x18\n\x0f\n\x07\x04*\x03\0\x02\0\x05\x12\x04\xee\x02\x19\x20\n\x0f\
    \n\x07\x04*\x03\0\x02\0\x01\x12\x04\xee\x02!)\n\x0f\n\x07\x04*\x03\0\x02\
    \0\x03\x12\x04\xee\x02,-\n\x0e\n\x06\x04*\x03\0\x02\x01\x12\x04\xef\x02\
    \x101\n\x0f\n\x07\x04*\x03\0\x02\x01\x04\x12\x04\xef\x02\x10\x18\n\x0f\n\
    \x07\x04*\x03\0\x02\x01\x05\x12\x04\xef\x02\x19\x1f\n\x0f\n\x07\x04*\x03\
    \0\x02\x01\x01\x12\x04\xef\x02\x20,\n\x0f\n\x07\x04*\x03\0\x02\x01\x03\
    \x12\x04\xef\x02/0\n\x0e\n\x06\x04*\x03\0\x02\x02\x12\x04\xf0\x02\x10,\n\
    \x0f\n\x07\x04*\x03\0\x02\x02\x04\x12\x04\xf0\x02\x10\x18\n\x0f\n\x07\
    \x04*\x03\0\x02\x02\x05\x12\x04\xf0\x02\x19\x1e\n\x0f\n\x07\x04*\x03\0\
    \x02\x02\x01\x12\x04\xf0\x02\x1f'\n\x0f\n\x07\x04*\x03\0\x02\x02\x03\x12\
    \x04\xf0\x02*+\n\x0c\n\x04\x04*\x02\0\x12\x04\xf3\x02\x08#\n\r\n\x05\x04\
    *\x02\0\x04\x12\x04\xf3\x02\x08\x10\n\r\n\x05\x04*\x02\0\x05\x12\x04\xf3\
    \x02\x11\x17\n\r\n\x05\x04*\x02\0\x01\x12\x04\xf3\x02\x18\x1e\n\r\n\x05\
    \x04*\x02\0\x03\x12\x04\xf3\x02!\"\n\x0c\n\x04\x04*\x02\x01\x12\x04\xf4\
    \x02\x08,\n\r\n\x05\x04*\x02\x01\x04\x12\x04\xf4\x02\x08\x10\n\r\n\x05\
    \x04*\x02\x01\x05\x12\x04\xf4\x02\x11\x18\n\r\n\x05\x04*\x02\x01\x01\x12\
    \x04\xf4\x02\x19'\n\r\n\x05\x04*\x02\x01\x03\x12\x04\xf4\x02*+\n\x0c\n\
    \x04\x04*\x02\x02\x12\x04\xf5\x02\x084\n\r\n\x05\x04*\x02\x02\x04\x12\
    \x04\xf5\x02\x08\x10\n\r\n\x05\x04*\x02\x02\x05\x12\x04\xf5\x02\x11\x16\
    \n\r\n\x05\x04*\x02\x02\x01\x12\x04\xf5\x02\x17/\n\r\n\x05\x04*\x02\x02\
    \x03\x12\x04\xf5\x0223\n\x0c\n\x04\x04*\x02\x03\x12\x04\xf6\x02\x08'\n\r\
    \n\x05\x04*\x02\x03\x04\x12\x04\xf6\x02\x08\x10\n\r\n\x05\x04*\x02\x03\
    \x05\x12\x04\xf6\x02\x11\x16\n\r\n\x05\x04*\x02\x03\x01\x12\x04\xf6\x02\
    \x17\"\n\r\n\x05\x04*\x02\x03\x03\x12\x04\xf6\x02%&\n\x0c\n\x04\x04*\x02\
    \x04\x12\x04\xf7\x02\x08&\n\r\n\x05\x04*\x02\x04\x04\x12\x04\xf7\x02\x08\
    \x10\n\r\n\x05\x04*\x02\x04\x05\x12\x04\xf7\x02\x11\x16\n\r\n\x05\x04*\
    \x02\x04\x01\x12\x04\xf7\x02\x17!\n\r\n\x05\x04*\x02\x04\x03\x12\x04\xf7\
    \x02$%\n\x0c\n\x04\x04*\x02\x05\x12\x04\xf8\x02\x08'\n\r\n\x05\x04*\x02\
    \x05\x04\x12\x04\xf8\x02\x08\x10\n\r\n\x05\x04*\x02\x05\x05\x12\x04\xf8\
    \x02\x11\x16\n\r\n\x05\x04*\x02\x05\x01\x12\x04\xf8\x02\x17\"\n\r\n\x05\
    \x04*\x02\x05\x03\x12\x04\xf8\x02%&\n\x0c\n\x04\x04*\x02\x06\x12\x04\xf9\
    \x02\x08,\n\r\n\x05\x04*\x02\x06\x04\x12\x04\xf9\x02\x08\x10\n\r\n\x05\
    \x04*\x02\x06\x05\x12\x04\xf9\x02\x11\x18\n\r\n\x05\x04*\x02\x06\x01\x12\
    \x04\xf9\x02\x19'\n\r\n\x05\x04*\x02\x06\x03\x12\x04\xf9\x02*+\n\x0c\n\
    \x04\x04*\x02\x07\x12\x04\xfa\x02\x08$\n\r\n\x05\x04*\x02\x07\x04\x12\
    \x04\xfa\x02\x08\x10\n\r\n\x05\x04*\x02\x07\x05\x12\x04\xfa\x02\x11\x16\
    \n\r\n\x05\x04*\x02\x07\x01\x12\x04\xfa\x02\x17\x1f\n\r\n\x05\x04*\x02\
    \x07\x03\x12\x04\xfa\x02\"#\n\x0c\n\x04\x04*\x02\x08\x12\x04\xfb\x02\x08\
    D\n\r\n\x05\x04*\x02\x08\x04\x12\x04\xfb\x02\x08\x10\n\r\n\x05\x04*\x02\
    \x08\x06\x12\x04\xfb\x02\x117\n\r\n\x05\x04*\x02\x08\x01\x12\x04\xfb\x02\
    8?\n\r\n\x05\x04*\x02\x08\x03\x12\x04\xfb\x02BC\n\x0c\n\x02\x04+\x12\x06\
    \xfe\x02\0\x81\x03\x01\n\x0b\n\x03\x04+\x01\x12\x04\xfe\x02\x08\x1f\n\
    \x0c\n\x04\x04+\x02\0\x12\x04\xff\x02\x08#\n\r\n\x05\x04+\x02\0\x04\x12\
    \x04\xff\x02\x08\x10\n\r\n\x05\x04+\x02\0\x05\x12\x04\xff\x02\x11\x17\n\
    \r\n\x05\x04+\x02\0\x01\x12\x04\xff\x02\x18\x1e\n\r\n\x05\x04+\x02\0\x03\
    \x12\x04\xff\x02!\"\n\x0c\n\x04\x04+\x02\x01\x12\x04\x80\x03\x08,\n\r\n\
    \x05\x04+\x02\x01\x04\x12\x04\x80\x03\x08\x10\n\r\n\x05\x04+\x02\x01\x05\
    \x12\x04\x80\x03\x11\x18\n\r\n\x05\x04+\x02\x01\x01\x12\x04\x80\x03\x19'\
    \n\r\n\x05\x04+\x02\x01\x03\x12\x04\x80\x03*+\n\x0c\n\x02\x04,\x12\x06\
    \x83\x03\0\x87\x03\x01\n\x0b\n\x03\x04,\x01\x12\x04\x83\x03\x08'\n\x0c\n\
    \x04\x04,\x02\0\x12\x04\x84\x03\x08#\n\r\n\x05\x04,\x02\0\x04\x12\x04\
    \x84\x03\x08\x10\n\r\n\x05\x04,\x02\0\x05\x12\x04\x84\x03\x11\x17\n\r\n\
    \x05\x04,\x02\0\x01\x12\x04\x84\x03\x18\x1e\n\r\n\x05\x04,\x02\0\x03\x12\
    \x04\x84\x03!\"\n\x0c\n\x04\x04,\x02\x01\x12\x04\x85\x03\x08,\n\r\n\x05\
    \x04,\x02\x01\x04\x12\x04\x85\x03\x08\x10\n\r\n\x05\x04,\x02\x01\x05\x12\
    \x04\x85\x03\x11\x18\n\r\n\x05\x04,\x02\x01\x01\x12\x04\x85\x03\x19'\n\r\
    \n\x05\x04,\x02\x01\x03\x12\x04\x85\x03*+\n\x0c\n\x04\x04,\x02\x02\x12\
    \x04\x86\x03\x081\n\r\n\x05\x04,\x02\x02\x04\x12\x04\x86\x03\x08\x10\n\r\
    \n\x05\x04,\x02\x02\x05\x12\x04\x86\x03\x11\x16\n\r\n\x05\x04,\x02\x02\
    \x01\x12\x04\x86\x03\x17\x1e\n\r\n\x05\x04,\x02\x02\x03\x12\x04\x86\x03!\
    \"\n\r\n\x05\x04,\x02\x02\x08\x12\x04\x86\x03#0\n\r\n\x05\x04,\x02\x02\
    \x07\x12\x04\x86\x03./\n\x0c\n\x02\x04-\x12\x06\x89\x03\0\x97\x03\x01\n\
    \x0b\n\x03\x04-\x01\x12\x04\x89\x03\x08!\n\x0e\n\x04\x04-\x03\0\x12\x06\
    \x8a\x03\x08\x8f\x03\t\n\r\n\x05\x04-\x03\0\x01\x12\x04\x8a\x03\x10\x16\
    \n\x0e\n\x06\x04-\x03\0\x02\0\x12\x04\x8b\x03\x10(\n\x0f\n\x07\x04-\x03\
    \0\x02\0\x04\x12\x04\x8b\x03\x10\x18\n\x0f\n\x07\x04-\x03\0\x02\0\x05\
    \x12\x04\x8b\x03\x19\x1f\n\x0f\n\x07\x04-\x03\0\x02\0\x01\x12\x04\x8b\
    \x03\x20#\n\x0f\n\x07\x04-\x03\0\x02\0\x03\x12\x04\x8b\x03&'\n\x0e\n\x06\
    \x04-\x03\0\x02\x01\x12\x04\x8c\x03\x10*\n\x0f\n\x07\x04-\x03\0\x02\x01\
    \x04\x12\x04\x8c\x03\x10\x18\n\x0f\n\x07\x04-\x03\0\x02\x01\x05\x12\x04\
    \x8c\x03\x19\x1f\n\x0f\n\x07\x04-\x03\0\x02\x01\x01\x12\x04\x8c\x03\x20%\
    \n\x0f\n\x07\x04-\x03\0\x02\x01\x03\x12\x04\x8c\x03()\n\x0e\n\x06\x04-\
    \x03\0\x02\x02\x12\x04\x8d\x03\x10/\n\x0f\n\x07\x04-\x03\0\x02\x02\x04\
    \x12\x04\x8d\x03\x10\x18\n\x0f\n\x07\x04-\x03\0\x02\x02\x05\x12\x04\x8d\
    \x03\x19\x1e\n\x0f\n\x07\x04-\x03\0\x02\x02\x01\x12\x04\x8d\x03\x1f*\n\
    \x0f\n\x07\x04-\x03\0\x02\x02\x03\x12\x04\x8d\x03-.\n\x0e\n\x06\x04-\x03\
    \0\x02\x03\x12\x04\x8e\x03\x10/\n\x0f\n\x07\x04-\x03\0\x02\x03\x04\x12\
    \x04\x8e\x03\x10\x18\n\x0f\n\x07\x04-\x03\0\x02\x03\x05\x12\x04\x8e\x03\
    \x19\x1e\n\x0f\n\x07\x04-\x03\0\x02\x03\x01\x12\x04\x8e\x03\x1f*\n\x0f\n\
    \x07\x04-\x03\0\x02\x03\x03\x12\x04\x8e\x03-.\n\x0c\n\x04\x04-\x02\0\x12\
    \x04\x91\x03\x08#\n\r\n\x05\x04-\x02\0\x04\x12\x04\x91\x03\x08\x10\n\r\n\
    \x05\x04-\x02\0\x05\x12\x04\x91\x03\x11\x17\n\r\n\x05\x04-\x02\0\x01\x12\
    \x04\x91\x03\x18\x1e\n\r\n\x05\x04-\x02\0\x03\x12\x04\x91\x03!\"\n\x0c\n\
    \x04\x04-\x02\x01\x12\x04\x92\x03\x081\n\r\n\x05\x04-\x02\x01\x04\x12\
    \x04\x92\x03\x08\x10\n\r\n\x05\x04-\x02\x01\x05\x12\x04\x92\x03\x11\x16\
    \n\r\n\x05\x04-\x02\x01\x01\x12\x04\x92\x03\x17,\n\r\n\x05\x04-\x02\x01\
    \x03\x12\x04\x92\x03/0\n\x0c\n\x04\x04-\x02\x02\x12\x04\x93\x03\x08$\n\r\
    \n\x05\x04-\x02\x02\x04\x12\x04\x93\x03\x08\x10\n\r\n\x05\x04-\x02\x02\
    \x05\x12\x04\x93\x03\x11\x17\n\r\n\x05\x04-\x02\x02\x01\x12\x04\x93\x03\
    \x18\x1f\n\r\n\x05\x04-\x02\x02\x03\x12\x04\x93\x03\"#\n\x0c\n\x04\x04-\
    \x02\x03\x12\x04\x94\x03\x081\n\r\n\x05\x04-\x02\x03\x04\x12\x04\x94\x03\
    \x08\x10\n\r\n\x05\x04-\x02\x03\x05\x12\x04\x94\x03\x11\x17\n\r\n\x05\
    \x04-\x02\x03\x01\x12\x04\x94\x03\x18,\n\r\n\x05\x04-\x02\x03\x03\x12\
    \x04\x94\x03/0\n\x0c\n\x04\x04-\x02\x04\x12\x04\x95\x03\x08?\n\r\n\x05\
    \x04-\x02\x04\x04\x12\x04\x95\x03\x08\x10\n\r\n\x05\x04-\x02\x04\x06\x12\
    \x04\x95\x03\x112\n\r\n\x05\x04-\x02\x04\x01\x12\x04\x95\x033:\n\r\n\x05\
    \x04-\x02\x04\x03\x12\x04\x95\x03=>\n\x0c\n\x04\x04-\x02\x05\x12\x04\x96\
    \x03\x08.\n\r\n\x05\x04-\x02\x05\x04\x12\x04\x96\x03\x08\x10\n\r\n\x05\
    \x04-\x02\x05\x06\x12\x04\x96\x03\x11\x1f\n\r\n\x05\x04-\x02\x05\x01\x12\
    \x04\x96\x03\x20)\n\r\n\x05\x04-\x02\x05\x03\x12\x04\x96\x03,-\n\x0c\n\
    \x02\x04.\x12\x06\x99\x03\0\xa8\x03\x01\n\x0b\n\x03\x04.\x01\x12\x04\x99\
    \x03\x08)\n\x0e\n\x04\x04.\x03\0\x12\x06\x9a\x03\x08\xa3\x03\t\n\r\n\x05\
    \x04.\x03\0\x01\x12\x04\x9a\x03\x10\x15\n\x0e\n\x06\x04.\x03\0\x02\0\x12\
    \x04\x9b\x03\x10.\n\x0f\n\x07\x04.\x03\0\x02\0\x04\x12\x04\x9b\x03\x10\
    \x18\n\x0f\n\x07\x04.\x03\0\x02\0\x05\x12\x04\x9b\x03\x19\x20\n\x0f\n\
    \x07\x04.\x03\0\x02\0\x01\x12\x04\x9b\x03!)\n\x0f\n\x07\x04.\x03\0\x02\0\
    \x03\x12\x04\x9b\x03,-\n\x0e\n\x06\x04.\x03\0\x02\x01\x12\x04\x9c\x03\
    \x10/\n\x0f\n\x07\x04.\x03\0\x02\x01\x04\x12\x04\x9c\x03\x10\x18\n\x0f\n\
    \x07\x04.\x03\0\x02\x01\x05\x12\x04\x9c\x03\x19\x1e\n\x0f\n\x07\x04.\x03\
    \0\x02\x01\x01\x12\x04\x9c\x03\x1f*\n\x0f\n\x07\x04.\x03\0\x02\x01\x03\
    \x12\x04\x9c\x03-.\n\x0e\n\x06\x04.\x03\0\x02\x02\x12\x04\x9d\x03\x10.\n\
    \x0f\n\x07\x04.\x03\0\x02\x02\x04\x12\x04\x9d\x03\x10\x18\n\x0f\n\x07\
    \x04.\x03\0\x02\x02\x05\x12\x04\x9d\x03\x19\x1e\n\x0f\n\x07\x04.\x03\0\
    \x02\x02\x01\x12\x04\x9d\x03\x1f)\n\x0f\n\x07\x04.\x03\0\x02\x02\x03\x12\
    \x04\x9d\x03,-\n\x0e\n\x06\x04.\x03\0\x02\x03\x12\x04\x9e\x03\x10/\n\x0f\
    \n\x07\x04.\x03\0\x02\x03\x04\x12\x04\x9e\x03\x10\x18\n\x0f\n\x07\x04.\
    \x03\0\x02\x03\x05\x12\x04\x9e\x03\x19\x1e\n\x0f\n\x07\x04.\x03\0\x02\
    \x03\x01\x12\x04\x9e\x03\x1f*\n\x0f\n\x07\x04.\x03\0\x02\x03\x03\x12\x04\
    \x9e\x03-.\n\x0e\n\x06\x04.\x03\0\x02\x04\x12\x04\x9f\x03\x10,\n\x0f\n\
    \x07\x04.\x03\0\x02\x04\x04\x12\x04\x9f\x03\x10\x18\n\x0f\n\x07\x04.\x03\
    \0\x02\x04\x05\x12\x04\x9f\x03\x19\x1e\n\x0f\n\x07\x04.\x03\0\x02\x04\
    \x01\x12\x04\x9f\x03\x1f'\n\x0f\n\x07\x04.\x03\0\x02\x04\x03\x12\x04\x9f\
    \x03*+\n\x0e\n\x06\x04.\x03\0\x02\x05\x12\x04\xa0\x03\x10/\n\x0f\n\x07\
    \x04.\x03\0\x02\x05\x04\x12\x04\xa0\x03\x10\x18\n\x0f\n\x07\x04.\x03\0\
    \x02\x05\x05\x12\x04\xa0\x03\x19\x1e\n\x0f\n\x07\x04.\x03\0\x02\x05\x01\
    \x12\x04\xa0\x03\x1f*\n\x0f\n\x07\x04.\x03\0\x02\x05\x03\x12\x04\xa0\x03\
    -.\n\x0e\n\x06\x04.\x03\0\x02\x06\x12\x04\xa1\x03\x10,\n\x0f\n\x07\x04.\
    \x03\0\x02\x06\x04\x12\x04\xa1\x03\x10\x18\n\x0f\n\x07\x04.\x03\0\x02\
    \x06\x05\x12\x04\xa1\x03\x19\x1e\n\x0f\n\x07\x04.\x03\0\x02\x06\x01\x12\
    \x04\xa1\x03\x1f'\n\x0f\n\x07\x04.\x03\0\x02\x06\x03\x12\x04\xa1\x03*+\n\
    \x0e\n\x06\x04.\x03\0\x02\x07\x12\x04\xa2\x03\x10*\n\x0f\n\x07\x04.\x03\
    \0\x02\x07\x04\x12\x04\xa2\x03\x10\x18\n\x0f\n\x07\x04.\x03\0\x02\x07\
    \x05\x12\x04\xa2\x03\x19\x1e\n\x0f\n\x07\x04.\x03\0\x02\x07\x01\x12\x04\
    \xa2\x03\x1f%\n\x0f\n\x07\x04.\x03\0\x02\x07\x03\x12\x04\xa2\x03()\n\x0c\
    \n\x04\x04.\x02\0\x12\x04\xa5\x03\x08#\n\r\n\x05\x04.\x02\0\x04\x12\x04\
    \xa5\x03\x08\x10\n\r\n\x05\x04.\x02\0\x05\x12\x04\xa5\x03\x11\x17\n\r\n\
    \x05\x04.\x02\0\x01\x12\x04\xa5\x03\x18\x1e\n\r\n\x05\x04.\x02\0\x03\x12\
    \x04\xa5\x03!\"\n\x0c\n\x04\x04.\x02\x01\x12\x04\xa6\x03\x081\n\r\n\x05\
    \x04.\x02\x01\x04\x12\x04\xa6\x03\x08\x10\n\r\n\x05\x04.\x02\x01\x05\x12\
    \x04\xa6\x03\x11\x16\n\r\n\x05\x04.\x02\x01\x01\x12\x04\xa6\x03\x17\x1e\
    \n\r\n\x05\x04.\x02\x01\x03\x12\x04\xa6\x03!\"\n\r\n\x05\x04.\x02\x01\
    \x08\x12\x04\xa6\x03#0\n\r\n\x05\x04.\x02\x01\x07\x12\x04\xa6\x03./\n\
    \x0c\n\x04\x04.\x02\x02\x12\x04\xa7\x03\x08F\n\r\n\x05\x04.\x02\x02\x04\
    \x12\x04\xa7\x03\x08\x10\n\r\n\x05\x04.\x02\x02\x06\x12\x04\xa7\x03\x119\
    \n\r\n\x05\x04.\x02\x02\x01\x12\x04\xa7\x03:A\n\r\n\x05\x04.\x02\x02\x03\
    \x12\x04\xa7\x03DE\n\x0c\n\x02\x04/\x12\x06\xaa\x03\0\xb2\x03\x01\n\x0b\
    \n\x03\x04/\x01\x12\x04\xaa\x03\x08!\n\x0c\n\x04\x04/\x02\0\x12\x04\xab\
    \x03\x08#\n\r\n\x05\x04/\x02\0\x04\x12\x04\xab\x03\x08\x10\n\r\n\x05\x04\
    /\x02\0\x05\x12\x04\xab\x03\x11\x17\n\r\n\x05\x04/\x02\0\x01\x12\x04\xab\
    \x03\x18\x1e\n\r\n\x05\x04/\x02\0\x03\x12\x04\xab\x03!\"\n\x0c\n\x04\x04\
    /\x02\x01\x12\x04\xac\x03\x08,\n\r\n\x05\x04/\x02\x01\x04\x12\x04\xac\
    \x03\x08\x10\n\r\n\x05\x04/\x02\x01\x05\x12\x04\xac\x03\x11\x18\n\r\n\
    \x05\x04/\x02\x01\x01\x12\x04\xac\x03\x19'\n\r\n\x05\x04/\x02\x01\x03\
    \x12\x04\xac\x03*+\n\x0c\n\x04\x04/\x02\x02\x12\x04\xad\x03\x08-\n\r\n\
    \x05\x04/\x02\x02\x04\x12\x04\xad\x03\x08\x10\n\r\n\x05\x04/\x02\x02\x05\
    \x12\x04\xad\x03\x11\x18\n\r\n\x05\x04/\x02\x02\x01\x12\x04\xad\x03\x19(\
    \n\r\n\x05\x04/\x02\x02\x03\x12\x04\xad\x03+,\n\x0c\n\x04\x04/\x02\x03\
    \x12\x04\xae\x03\x08'\n\r\n\x05\x04/\x02\x03\x04\x12\x04\xae\x03\x08\x10\
    \n\r\n\x05\x04/\x02\x03\x05\x12\x04\xae\x03\x11\x16\n\r\n\x05\x04/\x02\
    \x03\x01\x12\x04\xae\x03\x17\"\n\r\n\x05\x04/\x02\x03\x03\x12\x04\xae\
    \x03%&\n\x0c\n\x04\x04/\x02\x04\x12\x04\xaf\x03\x08&\n\r\n\x05\x04/\x02\
    \x04\x04\x12\x04\xaf\x03\x08\x10\n\r\n\x05\x04/\x02\x04\x05\x12\x04\xaf\
    \x03\x11\x16\n\r\n\x05\x04/\x02\x04\x01\x12\x04\xaf\x03\x17!\n\r\n\x05\
    \x04/\x02\x04\x03\x12\x04\xaf\x03$%\n\x0c\n\x04\x04/\x02\x05\x12\x04\xb0\
    \x03\x08'\n\r\n\x05\x04/\x02\x05\x04\x12\x04\xb0\x03\x08\x10\n\r\n\x05\
    \x04/\x02\x05\x05\x12\x04\xb0\x03\x11\x16\n\r\n\x05\x04/\x02\x05\x01\x12\
    \x04\xb0\x03\x17\"\n\r\n\x05\x04/\x02\x05\x03\x12\x04\xb0\x03%&\n\x0c\n\
    \x04\x04/\x02\x06\x12\x04\xb1\x03\x08$\n\r\n\x05\x04/\x02\x06\x04\x12\
    \x04\xb1\x03\x08\x10\n\r\n\x05\x04/\x02\x06\x05\x12\x04\xb1\x03\x11\x16\
    \n\r\n\x05\x04/\x02\x06\x01\x12\x04\xb1\x03\x17\x1f\n\r\n\x05\x04/\x02\
    \x06\x03\x12\x04\xb1\x03\"#\n\x0c\n\x02\x040\x12\x06\xb4\x03\0\xb8\x03\
    \x01\n\x0b\n\x03\x040\x01\x12\x04\xb4\x03\x08)\n\x0c\n\x04\x040\x02\0\
    \x12\x04\xb5\x03\x08#\n\r\n\x05\x040\x02\0\x04\x12\x04\xb5\x03\x08\x10\n\
    \r\n\x05\x040\x02\0\x05\x12\x04\xb5\x03\x11\x17\n\r\n\x05\x040\x02\0\x01\
    \x12\x04\xb5\x03\x18\x1e\n\r\n\x05\x040\x02\0\x03\x12\x04\xb5\x03!\"\n\
    \x0c\n\x04\x040\x02\x01\x12\x04\xb6\x03\x08,\n\r\n\x05\x040\x02\x01\x04\
    \x12\x04\xb6\x03\x08\x10\n\r\n\x05\x040\x02\x01\x05\x12\x04\xb6\x03\x11\
    \x18\n\r\n\x05\x040\x02\x01\x01\x12\x04\xb6\x03\x19'\n\r\n\x05\x040\x02\
    \x01\x03\x12\x04\xb6\x03*+\n\x0c\n\x04\x040\x02\x02\x12\x04\xb7\x03\x081\
    \n\r\n\x05\x040\x02\x02\x04\x12\x04\xb7\x03\x08\x10\n\r\n\x05\x040\x02\
    \x02\x05\x12\x04\xb7\x03\x11\x16\n\r\n\x05\x040\x02\x02\x01\x12\x04\xb7\
    \x03\x17\x1e\n\r\n\x05\x040\x02\x02\x03\x12\x04\xb7\x03!\"\n\r\n\x05\x04\
    0\x02\x02\x08\x12\x04\xb7\x03#0\n\r\n\x05\x040\x02\x02\x07\x12\x04\xb7\
    \x03./\n\x0c\n\x02\x041\x12\x06\xba\x03\0\xbd\x03\x01\n\x0b\n\x03\x041\
    \x01\x12\x04\xba\x03\x08!\n\x0c\n\x04\x041\x02\0\x12\x04\xbb\x03\x08#\n\
    \r\n\x05\x041\x02\0\x04\x12\x04\xbb\x03\x08\x10\n\r\n\x05\x041\x02\0\x05\
    \x12\x04\xbb\x03\x11\x17\n\r\n\x05\x041\x02\0\x01\x12\x04\xbb\x03\x18\
    \x1e\n\r\n\x05\x041\x02\0\x03\x12\x04\xbb\x03!\"\n\x0c\n\x04\x041\x02\
    \x01\x12\x04\xbc\x03\x08,\n\r\n\x05\x041\x02\x01\x04\x12\x04\xbc\x03\x08\
    \x10\n\r\n\x05\x041\x02\x01\x05\x12\x04\xbc\x03\x11\x18\n\r\n\x05\x041\
    \x02\x01\x01\x12\x04\xbc\x03\x19'\n\r\n\x05\x041\x02\x01\x03\x12\x04\xbc\
    \x03*+\n\x0c\n\x02\x042\x12\x06\xbf\x03\0\xd1\x03\x01\n\x0b\n\x03\x042\
    \x01\x12\x04\xbf\x03\x08\x1e\n\x0e\n\x04\x042\x03\0\x12\x06\xc0\x03\x08\
    \xc4\x03\t\n\r\n\x05\x042\x03\0\x01\x12\x04\xc0\x03\x10\x16\n\x0e\n\x06\
    \x042\x03\0\x02\0\x12\x04\xc1\x03\x10.\n\x0f\n\x07\x042\x03\0\x02\0\x04\
    \x12\x04\xc1\x03\x10\x18\n\x0f\n\x07\x042\x03\0\x02\0\x05\x12\x04\xc1\
    \x03\x19\x20\n\x0f\n\x07\x042\x03\0\x02\0\x01\x12\x04\xc1\x03!)\n\x0f\n\
    \x07\x042\x03\0\x02\0\x03\x12\x04\xc1\x03,-\n\x0e\n\x06\x042\x03\0\x02\
    \x01\x12\x04\xc2\x03\x101\n\x0f\n\x07\x042\x03\0\x02\x01\x04\x12\x04\xc2\
    \x03\x10\x18\n\x0f\n\x07\x042\x03\0\x02\x01\x05\x12\x04\xc2\x03\x19\x1f\
    \n\x0f\n\x07\x042\x03\0\x02\x01\x01\x12\x04\xc2\x03\x20,\n\x0f\n\x07\x04\
    2\x03\0\x02\x01\x03\x12\x04\xc2\x03/0\n\x0e\n\x06\x042\x03\0\x02\x02\x12\
    \x04\xc3\x03\x10,\n\x0f\n\x07\x042\x03\0\x02\x02\x04\x12\x04\xc3\x03\x10\
    \x18\n\x0f\n\x07\x042\x03\0\x02\x02\x05\x12\x04\xc3\x03\x19\x1e\n\x0f\n\
    \x07\x042\x03\0\x02\x02\x01\x12\x04\xc3\x03\x1f'\n\x0f\n\x07\x042\x03\0\
    \x02\x02\x03\x12\x04\xc3\x03*+\n\x0c\n\x04\x042\x02\0\x12\x04\xc6\x03\
    \x08#\n\r\n\x05\x042\x02\0\x04\x12\x04\xc6\x03\x08\x10\n\r\n\x05\x042\
    \x02\0\x05\x12\x04\xc6\x03\x11\x17\n\r\n\x05\x042\x02\0\x01\x12\x04\xc6\
    \x03\x18\x1e\n\r\n\x05\x042\x02\0\x03\x12\x04\xc6\x03!\"\n\x0c\n\x04\x04\
    2\x02\x01\x12\x04\xc7\x03\x08,\n\r\n\x05\x042\x02\x01\x04\x12\x04\xc7\
    \x03\x08\x10\n\r\n\x05\x042\x02\x01\x05\x12\x04\xc7\x03\x11\x18\n\r\n\
    \x05\x042\x02\x01\x01\x12\x04\xc7\x03\x19'\n\r\n\x05\x042\x02\x01\x03\
    \x12\x04\xc7\x03*+\n\x0c\n\x04\x042\x02\x02\x12\x04\xc8\x03\x08'\n\r\n\
    \x05\x042\x02\x02\x04\x12\x04\xc8\x03\x08\x10\n\r\n\x05\x042\x02\x02\x05\
    \x12\x04\xc8\x03\x11\x16\n\r\n\x05\x042\x02\x02\x01\x12\x04\xc8\x03\x17\
    \"\n\r\n\x05\x042\x02\x02\x03\x12\x04\xc8\x03%&\n\x0c\n\x04\x042\x02\x03\
    \x12\x04\xc9\x03\x08'\n\r\n\x05\x042\x02\x03\x04\x12\x04\xc9\x03\x08\x10\
    \n\r\n\x05\x042\x02\x03\x05\x12\x04\xc9\x03\x11\x16\n\r\n\x05\x042\x02\
    \x03\x01\x12\x04\xc9\x03\x17\"\n\r\n\x05\x042\x02\x03\x03\x12\x04\xc9\
    \x03%&\n\x0c\n\x04\x042\x02\x04\x12\x04\xca\x03\x08&\n\r\n\x05\x042\x02\
    \x04\x04\x12\x04\xca\x03\x08\x10\n\r\n\x05\x042\x02\x04\x05\x12\x04\xca\
    \x03\x11\x16\n\r\n\x05\x042\x02\x04\x01\x12\x04\xca\x03\x17!\n\r\n\x05\
    \x042\x02\x04\x03\x12\x04\xca\x03$%\n\x0c\n\x04\x042\x02\x05\x12\x04\xcb\
    \x03\x08'\n\r\n\x05\x042\x02\x05\x04\x12\x04\xcb\x03\x08\x10\n\r\n\x05\
    \x042\x02\x05\x05\x12\x04\xcb\x03\x11\x16\n\r\n\x05\x042\x02\x05\x01\x12\
    \x04\xcb\x03\x17\"\n\r\n\x05\x042\x02\x05\x03\x12\x04\xcb\x03%&\n\x0c\n\
    \x04\x042\x02\x06\x12\x04\xcc\x03\x08,\n\r\n\x05\x042\x02\x06\x04\x12\
    \x04\xcc\x03\x08\x10\n\r\n\x05\x042\x02\x06\x05\x12\x04\xcc\x03\x11\x18\
    \n\r\n\x05\x042\x02\x06\x01\x12\x04\xcc\x03\x19'\n\r\n\x05\x042\x02\x06\
    \x03\x12\x04\xcc\x03*+\n\x0c\n\x04\x042\x02\x07\x12\x04\xcd\x03\x08$\n\r\
    \n\x05\x042\x02\x07\x04\x12\x04\xcd\x03\x08\x10\n\r\n\x05\x042\x02\x07\
    \x05\x12\x04\xcd\x03\x11\x16\n\r\n\x05\x042\x02\x07\x01\x12\x04\xcd\x03\
    \x17\x1f\n\r\n\x05\x042\x02\x07\x03\x12\x04\xcd\x03\"#\n\x0c\n\x04\x042\
    \x02\x08\x12\x04\xce\x03\x08<\n\r\n\x05\x042\x02\x08\x04\x12\x04\xce\x03\
    \x08\x10\n\r\n\x05\x042\x02\x08\x06\x12\x04\xce\x03\x11/\n\r\n\x05\x042\
    \x02\x08\x01\x12\x04\xce\x0307\n\r\n\x05\x042\x02\x08\x03\x12\x04\xce\
    \x03:;\n\x0c\n\x04\x042\x02\t\x12\x04\xcf\x03\x08*\n\r\n\x05\x042\x02\t\
    \x04\x12\x04\xcf\x03\x08\x10\n\r\n\x05\x042\x02\t\x05\x12\x04\xcf\x03\
    \x11\x17\n\r\n\x05\x042\x02\t\x01\x12\x04\xcf\x03\x18$\n\r\n\x05\x042\
    \x02\t\x03\x12\x04\xcf\x03')\n\x0c\n\x04\x042\x02\n\x12\x04\xd0\x03\x087\
    \n\r\n\x05\x042\x02\n\x04\x12\x04\xd0\x03\x08\x10\n\r\n\x05\x042\x02\n\
    \x05\x12\x04\xd0\x03\x11\x15\n\r\n\x05\x042\x02\n\x01\x12\x04\xd0\x03\
    \x161\n\r\n\x05\x042\x02\n\x03\x12\x04\xd0\x0346\n\x0c\n\x02\x043\x12\
    \x06\xd3\x03\0\xd8\x03\x01\n\x0b\n\x03\x043\x01\x12\x04\xd3\x03\x08%\n\
    \x0c\n\x04\x043\x02\0\x12\x04\xd4\x03\x08#\n\r\n\x05\x043\x02\0\x04\x12\
    \x04\xd4\x03\x08\x10\n\r\n\x05\x043\x02\0\x05\x12\x04\xd4\x03\x11\x17\n\
    \r\n\x05\x043\x02\0\x01\x12\x04\xd4\x03\x18\x1e\n\r\n\x05\x043\x02\0\x03\
    \x12\x04\xd4\x03!\"\n\x0c\n\x04\x043\x02\x01\x12\x04\xd5\x03\x08,\n\r\n\
    \x05\x043\x02\x01\x04\x12\x04\xd5\x03\x08\x10\n\r\n\x05\x043\x02\x01\x05\
    \x12\x04\xd5\x03\x11\x18\n\r\n\x05\x043\x02\x01\x01\x12\x04\xd5\x03\x19'\
    \n\r\n\x05\x043\x02\x01\x03\x12\x04\xd5\x03*+\n\x0c\n\x04\x043\x02\x02\
    \x12\x04\xd6\x03\x08-\n\r\n\x05\x043\x02\x02\x04\x12\x04\xd6\x03\x08\x10\
    \n\r\n\x05\x043\x02\x02\x05\x12\x04\xd6\x03\x11\x18\n\r\n\x05\x043\x02\
    \x02\x01\x12\x04\xd6\x03\x19(\n\r\n\x05\x043\x02\x02\x03\x12\x04\xd6\x03\
    +,\n\x0c\n\x04\x043\x02\x03\x12\x04\xd7\x03\x08)\n\r\n\x05\x043\x02\x03\
    \x04\x12\x04\xd7\x03\x08\x10\n\r\n\x05\x043\x02\x03\x05\x12\x04\xd7\x03\
    \x11\x16\n\r\n\x05\x043\x02\x03\x01\x12\x04\xd7\x03\x17$\n\r\n\x05\x043\
    \x02\x03\x03\x12\x04\xd7\x03'(\n\x0c\n\x02\x044\x12\x06\xda\x03\0\xdf\
    \x03\x01\n\x0b\n\x03\x044\x01\x12\x04\xda\x03\x08!\n\x0c\n\x04\x044\x02\
    \0\x12\x04\xdb\x03\x08#\n\r\n\x05\x044\x02\0\x04\x12\x04\xdb\x03\x08\x10\
    \n\r\n\x05\x044\x02\0\x05\x12\x04\xdb\x03\x11\x17\n\r\n\x05\x044\x02\0\
    \x01\x12\x04\xdb\x03\x18\x1e\n\r\n\x05\x044\x02\0\x03\x12\x04\xdb\x03!\"\
    \n\x0c\n\x04\x044\x02\x01\x12\x04\xdc\x03\x08,\n\r\n\x05\x044\x02\x01\
    \x04\x12\x04\xdc\x03\x08\x10\n\r\n\x05\x044\x02\x01\x05\x12\x04\xdc\x03\
    \x11\x18\n\r\n\x05\x044\x02\x01\x01\x12\x04\xdc\x03\x19'\n\r\n\x05\x044\
    \x02\x01\x03\x12\x04\xdc\x03*+\n\x0c\n\x04\x044\x02\x02\x12\x04\xdd\x03\
    \x08-\n\r\n\x05\x044\x02\x02\x04\x12\x04\xdd\x03\x08\x10\n\r\n\x05\x044\
    \x02\x02\x05\x12\x04\xdd\x03\x11\x18\n\r\n\x05\x044\x02\x02\x01\x12\x04\
    \xdd\x03\x19(\n\r\n\x05\x044\x02\x02\x03\x12\x04\xdd\x03+,\n\x0c\n\x04\
    \x044\x02\x03\x12\x04\xde\x03\x08)\n\r\n\x05\x044\x02\x03\x04\x12\x04\
    \xde\x03\x08\x10\n\r\n\x05\x044\x02\x03\x05\x12\x04\xde\x03\x11\x16\n\r\
    \n\x05\x044\x02\x03\x01\x12\x04\xde\x03\x17$\n\r\n\x05\x044\x02\x03\x03\
    \x12\x04\xde\x03'(\n\x0c\n\x02\x045\x12\x06\xe1\x03\0\xe5\x03\x01\n\x0b\
    \n\x03\x045\x01\x12\x04\xe1\x03\x08\"\n\x0c\n\x04\x045\x02\0\x12\x04\xe2\
    \x03\x08#\n\r\n\x05\x045\x02\0\x04\x12\x04\xe2\x03\x08\x10\n\r\n\x05\x04\
    5\x02\0\x05\x12\x04\xe2\x03\x11\x17\n\r\n\x05\x045\x02\0\x01\x12\x04\xe2\
    \x03\x18\x1e\n\r\n\x05\x045\x02\0\x03\x12\x04\xe2\x03!\"\n\x0c\n\x04\x04\
    5\x02\x01\x12\x04\xe3\x03\x08,\n\r\n\x05\x045\x02\x01\x04\x12\x04\xe3\
    \x03\x08\x10\n\r\n\x05\x045\x02\x01\x05\x12\x04\xe3\x03\x11\x18\n\r\n\
    \x05\x045\x02\x01\x01\x12\x04\xe3\x03\x19'\n\r\n\x05\x045\x02\x01\x03\
    \x12\x04\xe3\x03*+\n\x0c\n\x04\x045\x02\x02\x12\x04\xe4\x03\x080\n\r\n\
    \x05\x045\x02\x02\x04\x12\x04\xe4\x03\x08\x10\n\r\n\x05\x045\x02\x02\x05\
    \x12\x04\xe4\x03\x11\x18\n\r\n\x05\x045\x02\x02\x01\x12\x04\xe4\x03\x19+\
    \n\r\n\x05\x045\x02\x02\x03\x12\x04\xe4\x03./\n\x0c\n\x02\x046\x12\x06\
    \xe7\x03\0\xeb\x03\x01\n\x0b\n\x03\x046\x01\x12\x04\xe7\x03\x08*\n\x0c\n\
    \x04\x046\x02\0\x12\x04\xe8\x03\x08#\n\r\n\x05\x046\x02\0\x04\x12\x04\
    \xe8\x03\x08\x10\n\r\n\x05\x046\x02\0\x05\x12\x04\xe8\x03\x11\x17\n\r\n\
    \x05\x046\x02\0\x01\x12\x04\xe8\x03\x18\x1e\n\r\n\x05\x046\x02\0\x03\x12\
    \x04\xe8\x03!\"\n\x0c\n\x04\x046\x02\x01\x12\x04\xe9\x03\x08,\n\r\n\x05\
    \x046\x02\x01\x04\x12\x04\xe9\x03\x08\x10\n\r\n\x05\x046\x02\x01\x05\x12\
    \x04\xe9\x03\x11\x18\n\r\n\x05\x046\x02\x01\x01\x12\x04\xe9\x03\x19'\n\r\
    \n\x05\x046\x02\x01\x03\x12\x04\xe9\x03*+\n\x0c\n\x04\x046\x02\x02\x12\
    \x04\xea\x03\x081\n\r\n\x05\x046\x02\x02\x04\x12\x04\xea\x03\x08\x10\n\r\
    \n\x05\x046\x02\x02\x05\x12\x04\xea\x03\x11\x16\n\r\n\x05\x046\x02\x02\
    \x01\x12\x04\xea\x03\x17\x1e\n\r\n\x05\x046\x02\x02\x03\x12\x04\xea\x03!\
    \"\n\r\n\x05\x046\x02\x02\x08\x12\x04\xea\x03#0\n\r\n\x05\x046\x02\x02\
    \x07\x12\x04\xea\x03./\n\x0c\n\x02\x047\x12\x06\xed\x03\0\xf1\x03\x01\n\
    \x0b\n\x03\x047\x01\x12\x04\xed\x03\x08#\n\x0c\n\x04\x047\x02\0\x12\x04\
    \xee\x03\x08#\n\r\n\x05\x047\x02\0\x04\x12\x04\xee\x03\x08\x10\n\r\n\x05\
    \x047\x02\0\x05\x12\x04\xee\x03\x11\x17\n\r\n\x05\x047\x02\0\x01\x12\x04\
    \xee\x03\x18\x1e\n\r\n\x05\x047\x02\0\x03\x12\x04\xee\x03!\"\n\x0c\n\x04\
    \x047\x02\x01\x12\x04\xef\x03\x08,\n\r\n\x05\x047\x02\x01\x04\x12\x04\
    \xef\x03\x08\x10\n\r\n\x05\x047\x02\x01\x05\x12\x04\xef\x03\x11\x18\n\r\
    \n\x05\x047\x02\x01\x01\x12\x04\xef\x03\x19'\n\r\n\x05\x047\x02\x01\x03\
    \x12\x04\xef\x03*+\n\x0c\n\x04\x047\x02\x02\x12\x04\xf0\x03\x08-\n\r\n\
    \x05\x047\x02\x02\x04\x12\x04\xf0\x03\x08\x10\n\r\n\x05\x047\x02\x02\x05\
    \x12\x04\xf0\x03\x11\x18\n\r\n\x05\x047\x02\x02\x01\x12\x04\xf0\x03\x19(\
    \n\r\n\x05\x047\x02\x02\x03\x12\x04\xf0\x03+,\n\x0c\n\x02\x048\x12\x06\
    \xf3\x03\0\xfa\x03\x01\n\x0b\n\x03\x048\x01\x12\x04\xf3\x03\x08'\n\x0c\n\
    \x04\x048\x02\0\x12\x04\xf4\x03\x08#\n\r\n\x05\x048\x02\0\x04\x12\x04\
    \xf4\x03\x08\x10\n\r\n\x05\x048\x02\0\x05\x12\x04\xf4\x03\x11\x17\n\r\n\
    \x05\x048\x02\0\x01\x12\x04\xf4\x03\x18\x1e\n\r\n\x05\x048\x02\0\x03\x12\
    \x04\xf4\x03!\"\n\x0c\n\x04\x048\x02\x01\x12\x04\xf5\x03\x08,\n\r\n\x05\
    \x048\x02\x01\x04\x12\x04\xf5\x03\x08\x10\n\r\n\x05\x048\x02\x01\x05\x12\
    \x04\xf5\x03\x11\x18\n\r\n\x05\x048\x02\x01\x01\x12\x04\xf5\x03\x19'\n\r\
    \n\x05\x048\x02\x01\x03\x12\x04\xf5\x03*+\n\x0c\n\x04\x048\x02\x02\x12\
    \x04\xf6\x03\x086\n\r\n\x05\x048\x02\x02\x04\x12\x04\xf6\x03\x08\x10\n\r\
    \n\x05\x048\x02\x02\x05\x12\x04\xf6\x03\x11\x17\n\r\n\x05\x048\x02\x02\
    \x01\x12\x04\xf6\x03\x181\n\r\n\x05\x048\x02\x02\x03\x12\x04\xf6\x0345\n\
    \x0c\n\x04\x048\x02\x03\x12\x04\xf7\x03\x08-\n\r\n\x05\x048\x02\x03\x04\
    \x12\x04\xf7\x03\x08\x10\n\r\n\x05\x048\x02\x03\x05\x12\x04\xf7\x03\x11\
    \x17\n\r\n\x05\x048\x02\x03\x01\x12\x04\xf7\x03\x18(\n\r\n\x05\x048\x02\
    \x03\x03\x12\x04\xf7\x03+,\n\x0c\n\x04\x048\x02\x04\x12\x04\xf8\x03\x082\
    \n\r\n\x05\x048\x02\x04\x04\x12\x04\xf8\x03\x08\x10\n\r\n\x05\x048\x02\
    \x04\x05\x12\x04\xf8\x03\x11\x18\n\r\n\x05\x048\x02\x04\x01\x12\x04\xf8\
    \x03\x19-\n\r\n\x05\x048\x02\x04\x03\x12\x04\xf8\x0301\n\x0c\n\x04\x048\
    \x02\x05\x12\x04\xf9\x03\x083\n\r\n\x05\x048\x02\x05\x04\x12\x04\xf9\x03\
    \x08\x10\n\r\n\x05\x048\x02\x05\x06\x12\x04\xf9\x03\x11\x1f\n\r\n\x05\
    \x048\x02\x05\x01\x12\x04\xf9\x03\x20.\n\r\n\x05\x048\x02\x05\x03\x12\
    \x04\xf9\x0312\n\x0c\n\x02\x049\x12\x06\xfc\x03\0\x83\x04\x01\n\x0b\n\
    \x03\x049\x01\x12\x04\xfc\x03\x08'\n\x0c\n\x04\x049\x02\0\x12\x04\xfd\
    \x03\x08#\n\r\n\x05\x049\x02\0\x04\x12\x04\xfd\x03\x08\x10\n\r\n\x05\x04\
    9\x02\0\x05\x12\x04\xfd\x03\x11\x17\n\r\n\x05\x049\x02\0\x01\x12\x04\xfd\
    \x03\x18\x1e\n\r\n\x05\x049\x02\0\x03\x12\x04\xfd\x03!\"\n\x0c\n\x04\x04\
    9\x02\x01\x12\x04\xfe\x03\x08,\n\r\n\x05\x049\x02\x01\x04\x12\x04\xfe\
    \x03\x08\x10\n\r\n\x05\x049\x02\x01\x05\x12\x04\xfe\x03\x11\x18\n\r\n\
    \x05\x049\x02\x01\x01\x12\x04\xfe\x03\x19'\n\r\n\x05\x049\x02\x01\x03\
    \x12\x04\xfe\x03*+\n\x0c\n\x04\x049\x02\x02\x12\x04\xff\x03\x086\n\r\n\
    \x05\x049\x02\x02\x04\x12\x04\xff\x03\x08\x10\n\r\n\x05\x049\x02\x02\x05\
    \x12\x04\xff\x03\x11\x17\n\r\n\x05\x049\x02\x02\x01\x12\x04\xff\x03\x181\
    \n\r\n\x05\x049\x02\x02\x03\x12\x04\xff\x0345\n\x0c\n\x04\x049\x02\x03\
    \x12\x04\x80\x04\x08-\n\r\n\x05\x049\x02\x03\x04\x12\x04\x80\x04\x08\x10\
    \n\r\n\x05\x049\x02\x03\x05\x12\x04\x80\x04\x11\x17\n\r\n\x05\x049\x02\
    \x03\x01\x12\x04\x80\x04\x18(\n\r\n\x05\x049\x02\x03\x03\x12\x04\x80\x04\
    +,\n\x0c\n\x04\x049\x02\x04\x12\x04\x81\x04\x082\n\r\n\x05\x049\x02\x04\
    \x04\x12\x04\x81\x04\x08\x10\n\r\n\x05\x049\x02\x04\x05\x12\x04\x81\x04\
    \x11\x18\n\r\n\x05\x049\x02\x04\x01\x12\x04\x81\x04\x19-\n\r\n\x05\x049\
    \x02\x04\x03\x12\x04\x81\x0401\n\x0c\n\x04\x049\x02\x05\x12\x04\x82\x04\
    \x083\n\r\n\x05\x049\x02\x05\x04\x12\x04\x82\x04\x08\x10\n\r\n\x05\x049\
    \x02\x05\x06\x12\x04\x82\x04\x11\x1f\n\r\n\x05\x049\x02\x05\x01\x12\x04\
    \x82\x04\x20.\n\r\n\x05\x049\x02\x05\x03\x12\x04\x82\x0412\n\x0c\n\x02\
    \x04:\x12\x06\x85\x04\0\x8a\x04\x01\n\x0b\n\x03\x04:\x01\x12\x04\x85\x04\
    \x08$\n\x0c\n\x04\x04:\x02\0\x12\x04\x86\x04\x08#\n\r\n\x05\x04:\x02\0\
    \x04\x12\x04\x86\x04\x08\x10\n\r\n\x05\x04:\x02\0\x05\x12\x04\x86\x04\
    \x11\x17\n\r\n\x05\x04:\x02\0\x01\x12\x04\x86\x04\x18\x1e\n\r\n\x05\x04:\
    \x02\0\x03\x12\x04\x86\x04!\"\n\x0c\n\x04\x04:\x02\x01\x12\x04\x87\x04\
    \x08,\n\r\n\x05\x04:\x02\x01\x04\x12\x04\x87\x04\x08\x10\n\r\n\x05\x04:\
    \x02\x01\x05\x12\x04\x87\x04\x11\x18\n\r\n\x05\x04:\x02\x01\x01\x12\x04\
    \x87\x04\x19'\n\r\n\x05\x04:\x02\x01\x03\x12\x04\x87\x04*+\n\x0c\n\x04\
    \x04:\x02\x02\x12\x04\x88\x04\x08+\n\r\n\x05\x04:\x02\x02\x04\x12\x04\
    \x88\x04\x08\x10\n\r\n\x05\x04:\x02\x02\x05\x12\x04\x88\x04\x11\x18\n\r\
    \n\x05\x04:\x02\x02\x01\x12\x04\x88\x04\x19&\n\r\n\x05\x04:\x02\x02\x03\
    \x12\x04\x88\x04)*\n\x0c\n\x04\x04:\x02\x03\x12\x04\x89\x04\x08)\n\r\n\
    \x05\x04:\x02\x03\x04\x12\x04\x89\x04\x08\x10\n\r\n\x05\x04:\x02\x03\x05\
    \x12\x04\x89\x04\x11\x17\n\r\n\x05\x04:\x02\x03\x01\x12\x04\x89\x04\x18$\
    \n\r\n\x05\x04:\x02\x03\x03\x12\x04\x89\x04'(\n\x0c\n\x02\x04;\x12\x06\
    \x8c\x04\0\x91\x04\x01\n\x0b\n\x03\x04;\x01\x12\x04\x8c\x04\x08\"\n\x0c\
    \n\x04\x04;\x02\0\x12\x04\x8d\x04\x08#\n\r\n\x05\x04;\x02\0\x04\x12\x04\
    \x8d\x04\x08\x10\n\r\n\x05\x04;\x02\0\x05\x12\x04\x8d\x04\x11\x17\n\r\n\
    \x05\x04;\x02\0\x01\x12\x04\x8d\x04\x18\x1e\n\r\n\x05\x04;\x02\0\x03\x12\
    \x04\x8d\x04!\"\n\x0c\n\x04\x04;\x02\x01\x12\x04\x8e\x04\x08,\n\r\n\x05\
    \x04;\x02\x01\x04\x12\x04\x8e\x04\x08\x10\n\r\n\x05\x04;\x02\x01\x05\x12\
    \x04\x8e\x04\x11\x18\n\r\n\x05\x04;\x02\x01\x01\x12\x04\x8e\x04\x19'\n\r\
    \n\x05\x04;\x02\x01\x03\x12\x04\x8e\x04*+\n\x0c\n\x04\x04;\x02\x02\x12\
    \x04\x8f\x04\x08+\n\r\n\x05\x04;\x02\x02\x04\x12\x04\x8f\x04\x08\x10\n\r\
    \n\x05\x04;\x02\x02\x05\x12\x04\x8f\x04\x11\x18\n\r\n\x05\x04;\x02\x02\
    \x01\x12\x04\x8f\x04\x19&\n\r\n\x05\x04;\x02\x02\x03\x12\x04\x8f\x04)*\n\
    \x0c\n\x04\x04;\x02\x03\x12\x04\x90\x04\x08)\n\r\n\x05\x04;\x02\x03\x04\
    \x12\x04\x90\x04\x08\x10\n\r\n\x05\x04;\x02\x03\x05\x12\x04\x90\x04\x11\
    \x17\n\r\n\x05\x04;\x02\x03\x01\x12\x04\x90\x04\x18$\n\r\n\x05\x04;\x02\
    \x03\x03\x12\x04\x90\x04'(\n\x0c\n\x02\x04<\x12\x06\x93\x04\0\x97\x04\
    \x01\n\x0b\n\x03\x04<\x01\x12\x04\x93\x04\x08\"\n\x0c\n\x04\x04<\x02\0\
    \x12\x04\x94\x04\x08#\n\r\n\x05\x04<\x02\0\x04\x12\x04\x94\x04\x08\x10\n\
    \r\n\x05\x04<\x02\0\x05\x12\x04\x94\x04\x11\x17\n\r\n\x05\x04<\x02\0\x01\
    \x12\x04\x94\x04\x18\x1e\n\r\n\x05\x04<\x02\0\x03\x12\x04\x94\x04!\"\n\
    \x0c\n\x04\x04<\x02\x01\x12\x04\x95\x04\x08,\n\r\n\x05\x04<\x02\x01\x04\
    \x12\x04\x95\x04\x08\x10\n\r\n\x05\x04<\x02\x01\x05\x12\x04\x95\x04\x11\
    \x18\n\r\n\x05\x04<\x02\x01\x01\x12\x04\x95\x04\x19'\n\r\n\x05\x04<\x02\
    \x01\x03\x12\x04\x95\x04*+\n\x0c\n\x04\x04<\x02\x02\x12\x04\x96\x04\x083\
    \n\r\n\x05\x04<\x02\x02\x04\x12\x04\x96\x04\x08\x10\n\r\n\x05\x04<\x02\
    \x02\x05\x12\x04\x96\x04\x11\x18\n\r\n\x05\x04<\x02\x02\x01\x12\x04\x96\
    \x04\x19.\n\r\n\x05\x04<\x02\x02\x03\x12\x04\x96\x0412\n\x0c\n\x02\x04=\
    \x12\x06\x99\x04\0\x9e\x04\x01\n\x0b\n\x03\x04=\x01\x12\x04\x99\x04\x08#\
    \n\x0c\n\x04\x04=\x02\0\x12\x04\x9a\x04\x08#\n\r\n\x05\x04=\x02\0\x04\
    \x12\x04\x9a\x04\x08\x10\n\r\n\x05\x04=\x02\0\x05\x12\x04\x9a\x04\x11\
    \x17\n\r\n\x05\x04=\x02\0\x01\x12\x04\x9a\x04\x18\x1e\n\r\n\x05\x04=\x02\
    \0\x03\x12\x04\x9a\x04!\"\n\x0c\n\x04\x04=\x02\x01\x12\x04\x9b\x04\x08,\
    \n\r\n\x05\x04=\x02\x01\x04\x12\x04\x9b\x04\x08\x10\n\r\n\x05\x04=\x02\
    \x01\x05\x12\x04\x9b\x04\x11\x18\n\r\n\x05\x04=\x02\x01\x01\x12\x04\x9b\
    \x04\x19'\n\r\n\x05\x04=\x02\x01\x03\x12\x04\x9b\x04*+\n\x0c\n\x04\x04=\
    \x02\x02\x12\x04\x9c\x04\x08+\n\r\n\x05\x04=\x02\x02\x04\x12\x04\x9c\x04\
    \x08\x10\n\r\n\x05\x04=\x02\x02\x05\x12\x04\x9c\x04\x11\x15\n\r\n\x05\
    \x04=\x02\x02\x01\x12\x04\x9c\x04\x16&\n\r\n\x05\x04=\x02\x02\x03\x12\
    \x04\x9c\x04)*\n\x0c\n\x04\x04=\x02\x03\x12\x04\x9d\x04\x08*\n\r\n\x05\
    \x04=\x02\x03\x04\x12\x04\x9d\x04\x08\x10\n\r\n\x05\x04=\x02\x03\x05\x12\
    \x04\x9d\x04\x11\x15\n\r\n\x05\x04=\x02\x03\x01\x12\x04\x9d\x04\x16%\n\r\
    \n\x05\x04=\x02\x03\x03\x12\x04\x9d\x04()\n\x0c\n\x02\x04>\x12\x06\xa0\
    \x04\0\xa4\x04\x01\n\x0b\n\x03\x04>\x01\x12\x04\xa0\x04\x08+\n\x0c\n\x04\
    \x04>\x02\0\x12\x04\xa1\x04\x08#\n\r\n\x05\x04>\x02\0\x04\x12\x04\xa1\
    \x04\x08\x10\n\r\n\x05\x04>\x02\0\x05\x12\x04\xa1\x04\x11\x17\n\r\n\x05\
    \x04>\x02\0\x01\x12\x04\xa1\x04\x18\x1e\n\r\n\x05\x04>\x02\0\x03\x12\x04\
    \xa1\x04!\"\n\x0c\n\x04\x04>\x02\x01\x12\x04\xa2\x04\x08,\n\r\n\x05\x04>\
    \x02\x01\x04\x12\x04\xa2\x04\x08\x10\n\r\n\x05\x04>\x02\x01\x05\x12\x04\
    \xa2\x04\x11\x18\n\r\n\x05\x04>\x02\x01\x01\x12\x04\xa2\x04\x19'\n\r\n\
    \x05\x04>\x02\x01\x03\x12\x04\xa2\x04*+\n\x0c\n\x04\x04>\x02\x02\x12\x04\
    \xa3\x04\x08X\n\r\n\x05\x04>\x02\x02\x04\x12\x04\xa3\x04\x08\x10\n\r\n\
    \x05\x04>\x02\x02\x06\x12\x04\xa3\x04\x11!\n\r\n\x05\x04>\x02\x02\x01\
    \x12\x04\xa3\x04\".\n\r\n\x05\x04>\x02\x02\x03\x12\x04\xa3\x0412\n\r\n\
    \x05\x04>\x02\x02\x08\x12\x04\xa3\x043W\n\r\n\x05\x04>\x02\x02\x07\x12\
    \x04\xa3\x04>V\n\x0c\n\x02\x04?\x12\x06\xa6\x04\0\xab\x04\x01\n\x0b\n\
    \x03\x04?\x01\x12\x04\xa6\x04\x08\x1e\n\x0c\n\x04\x04?\x02\0\x12\x04\xa7\
    \x04\x08+\n\r\n\x05\x04?\x02\0\x04\x12\x04\xa7\x04\x08\x10\n\r\n\x05\x04\
    ?\x02\0\x05\x12\x04\xa7\x04\x11\x18\n\r\n\x05\x04?\x02\0\x01\x12\x04\xa7\
    \x04\x19&\n\r\n\x05\x04?\x02\0\x03\x12\x04\xa7\x04)*\n\x0c\n\x04\x04?\
    \x02\x01\x12\x04\xa8\x04\x08*\n\r\n\x05\x04?\x02\x01\x04\x12\x04\xa8\x04\
    \x08\x10\n\r\n\x05\x04?\x02\x01\x05\x12\x04\xa8\x04\x11\x18\n\r\n\x05\
    \x04?\x02\x01\x01\x12\x04\xa8\x04\x19%\n\r\n\x05\x04?\x02\x01\x03\x12\
    \x04\xa8\x04()\n\x0c\n\x04\x04?\x02\x02\x12\x04\xa9\x04\x08+\n\r\n\x05\
    \x04?\x02\x02\x04\x12\x04\xa9\x04\x08\x10\n\r\n\x05\x04?\x02\x02\x05\x12\
    \x04\xa9\x04\x11\x17\n\r\n\x05\x04?\x02\x02\x01\x12\x04\xa9\x04\x18&\n\r\
    \n\x05\x04?\x02\x02\x03\x12\x04\xa9\x04)*\n\x0c\n\x04\x04?\x02\x03\x12\
    \x04\xaa\x04\x08(\n\r\n\x05\x04?\x02\x03\x04\x12\x04\xaa\x04\x08\x10\n\r\
    \n\x05\x04?\x02\x03\x05\x12\x04\xaa\x04\x11\x17\n\r\n\x05\x04?\x02\x03\
    \x01\x12\x04\xaa\x04\x18#\n\r\n\x05\x04?\x02\x03\x03\x12\x04\xaa\x04&'\n\
    \x0c\n\x02\x04@\x12\x06\xad\x04\0\xb5\x04\x01\n\x0b\n\x03\x04@\x01\x12\
    \x04\xad\x04\x08\x1c\n\x0c\n\x04\x04@\x02\0\x12\x04\xae\x04\x08.\n\r\n\
    \x05\x04@\x02\0\x04\x12\x04\xae\x04\x08\x10\n\r\n\x05\x04@\x02\0\x05\x12\
    \x04\xae\x04\x11\x18\n\r\n\x05\x04@\x02\0\x01\x12\x04\xae\x04\x19)\n\r\n\
    \x05\x04@\x02\0\x03\x12\x04\xae\x04,-\n\x0c\n\x04\x04@\x02\x01\x12\x04\
    \xaf\x04\x08+\n\r\n\x05\x04@\x02\x01\x04\x12\x04\xaf\x04\x08\x10\n\r\n\
    \x05\x04@\x02\x01\x05\x12\x04\xaf\x04\x11\x18\n\r\n\x05\x04@\x02\x01\x01\
    \x12\x04\xaf\x04\x19&\n\r\n\x05\x04@\x02\x01\x03\x12\x04\xaf\x04)*\n\x0c\
    \n\x04\x04@\x02\x02\x12\x04\xb0\x04\x08-\n\r\n\x05\x04@\x02\x02\x04\x12\
    \x04\xb0\x04\x08\x10\n\r\n\x05\x04@\x02\x02\x05\x12\x04\xb0\x04\x11\x18\
    \n\r\n\x05\x04@\x02\x02\x01\x12\x04\xb0\x04\x19(\n\r\n\x05\x04@\x02\x02\
    \x03\x12\x04\xb0\x04+,\n\x0c\n\x04\x04@\x02\x03\x12\x04\xb1\x04\x08)\n\r\
    \n\x05\x04@\x02\x03\x04\x12\x04\xb1\x04\x08\x10\n\r\n\x05\x04@\x02\x03\
    \x05\x12\x04\xb1\x04\x11\x16\n\r\n\x05\x04@\x02\x03\x01\x12\x04\xb1\x04\
    \x17$\n\r\n\x05\x04@\x02\x03\x03\x12\x04\xb1\x04'(\n\x0c\n\x04\x04@\x02\
    \x04\x12\x04\xb2\x04\x082\n\r\n\x05\x04@\x02\x04\x04\x12\x04\xb2\x04\x08\
    \x10\n\r\n\x05\x04@\x02\x04\x05\x12\x04\xb2\x04\x11\x18\n\r\n\x05\x04@\
    \x02\x04\x01\x12\x04\xb2\x04\x19-\n\r\n\x05\x04@\x02\x04\x03\x12\x04\xb2\
    \x0401\n\x0c\n\x04\x04@\x02\x05\x12\x04\xb3\x04\x08&\n\r\n\x05\x04@\x02\
    \x05\x04\x12\x04\xb3\x04\x08\x10\n\r\n\x05\x04@\x02\x05\x05\x12\x04\xb3\
    \x04\x11\x17\n\r\n\x05\x04@\x02\x05\x01\x12\x04\xb3\x04\x18!\n\r\n\x05\
    \x04@\x02\x05\x03\x12\x04\xb3\x04$%\n\x0c\n\x04\x04@\x02\x06\x12\x04\xb4\
    \x04\x08%\n\r\n\x05\x04@\x02\x06\x04\x12\x04\xb4\x04\x08\x10\n\r\n\x05\
    \x04@\x02\x06\x05\x12\x04\xb4\x04\x11\x18\n\r\n\x05\x04@\x02\x06\x01\x12\
    \x04\xb4\x04\x19\x20\n\r\n\x05\x04@\x02\x06\x03\x12\x04\xb4\x04#$\n\x0c\
    \n\x02\x04A\x12\x06\xb7\x04\0\xe3\x04\x01\n\x0b\n\x03\x04A\x01\x12\x04\
    \xb7\x04\x08!\n\x0e\n\x04\x04A\x03\0\x12\x06\xb8\x04\x08\xc0\x04\t\n\r\n\
    \x05\x04A\x03\0\x01\x12\x04\xb8\x04\x10\x1b\n\x0e\n\x06\x04A\x03\0\x02\0\
    \x12\x04\xb9\x04\x104\n\x0f\n\x07\x04A\x03\0\x02\0\x04\x12\x04\xb9\x04\
    \x10\x18\n\x0f\n\x07\x04A\x03\0\x02\0\x05\x12\x04\xb9\x04\x19\x1e\n\x0f\
    \n\x07\x04A\x03\0\x02\0\x01\x12\x04\xb9\x04\x1f/\n\x0f\n\x07\x04A\x03\0\
    \x02\0\x03\x12\x04\xb9\x0423\n\x0e\n\x06\x04A\x03\0\x02\x01\x12\x04\xba\
    \x04\x105\n\x0f\n\x07\x04A\x03\0\x02\x01\x04\x12\x04\xba\x04\x10\x18\n\
    \x0f\n\x07\x04A\x03\0\x02\x01\x05\x12\x04\xba\x04\x19\x1e\n\x0f\n\x07\
    \x04A\x03\0\x02\x01\x01\x12\x04\xba\x04\x1f0\n\x0f\n\x07\x04A\x03\0\x02\
    \x01\x03\x12\x04\xba\x0434\n\x0e\n\x06\x04A\x03\0\x02\x02\x12\x04\xbb\
    \x04\x104\n\x0f\n\x07\x04A\x03\0\x02\x02\x04\x12\x04\xbb\x04\x10\x18\n\
    \x0f\n\x07\x04A\x03\0\x02\x02\x05\x12\x04\xbb\x04\x19\x1e\n\x0f\n\x07\
    \x04A\x03\0\x02\x02\x01\x12\x04\xbb\x04\x1f/\n\x0f\n\x07\x04A\x03\0\x02\
    \x02\x03\x12\x04\xbb\x0423\n\x0e\n\x06\x04A\x03\0\x02\x03\x12\x04\xbc\
    \x04\x107\n\x0f\n\x07\x04A\x03\0\x02\x03\x04\x12\x04\xbc\x04\x10\x18\n\
    \x0f\n\x07\x04A\x03\0\x02\x03\x05\x12\x04\xbc\x04\x19\x1e\n\x0f\n\x07\
    \x04A\x03\0\x02\x03\x01\x12\x04\xbc\x04\x1f2\n\x0f\n\x07\x04A\x03\0\x02\
    \x03\x03\x12\x04\xbc\x0456\n\x0e\n\x06\x04A\x03\0\x02\x04\x12\x04\xbd\
    \x04\x104\n\x0f\n\x07\x04A\x03\0\x02\x04\x04\x12\x04\xbd\x04\x10\x18\n\
    \x0f\n\x07\x04A\x03\0\x02\x04\x05\x12\x04\xbd\x04\x19\x1f\n\x0f\n\x07\
    \x04A\x03\0\x02\x04\x01\x12\x04\xbd\x04\x20/\n\x0f\n\x07\x04A\x03\0\x02\
    \x04\x03\x12\x04\xbd\x0423\n\x0e\n\x06\x04A\x03\0\x02\x05\x12\x04\xbe\
    \x04\x109\n\x0f\n\x07\x04A\x03\0\x02\x05\x04\x12\x04\xbe\x04\x10\x18\n\
    \x0f\n\x07\x04A\x03\0\x02\x05\x05\x12\x04\xbe\x04\x19\x1f\n\x0f\n\x07\
    \x04A\x03\0\x02\x05\x01\x12\x04\xbe\x04\x204\n\x0f\n\x07\x04A\x03\0\x02\
    \x05\x03\x12\x04\xbe\x0478\n\x0e\n\x06\x04A\x03\0\x02\x06\x12\x04\xbf\
    \x04\x102\n\x0f\n\x07\x04A\x03\0\x02\x06\x04\x12\x04\xbf\x04\x10\x18\n\
    \x0f\n\x07\x04A\x03\0\x02\x06\x05\x12\x04\xbf\x04\x19\x1f\n\x0f\n\x07\
    \x04A\x03\0\x02\x06\x01\x12\x04\xbf\x04\x20-\n\x0f\n\x07\x04A\x03\0\x02\
    \x06\x03\x12\x04\xbf\x0401\n\x0e\n\x04\x04A\x03\x01\x12\x06\xc2\x04\x08\
    \xc8\x04\t\n\r\n\x05\x04A\x03\x01\x01\x12\x04\xc2\x04\x10\x19\n\x0e\n\
    \x06\x04A\x03\x01\x02\0\x12\x04\xc3\x04\x10.\n\x0f\n\x07\x04A\x03\x01\
    \x02\0\x04\x12\x04\xc3\x04\x10\x18\n\x0f\n\x07\x04A\x03\x01\x02\0\x05\
    \x12\x04\xc3\x04\x19\x1f\n\x0f\n\x07\x04A\x03\x01\x02\0\x01\x12\x04\xc3\
    \x04\x20)\n\x0f\n\x07\x04A\x03\x01\x02\0\x03\x12\x04\xc3\x04,-\n\x0e\n\
    \x06\x04A\x03\x01\x02\x01\x12\x04\xc4\x04\x10/\n\x0f\n\x07\x04A\x03\x01\
    \x02\x01\x04\x12\x04\xc4\x04\x10\x18\n\x0f\n\x07\x04A\x03\x01\x02\x01\
    \x05\x12\x04\xc4\x04\x19\x1f\n\x0f\n\x07\x04A\x03\x01\x02\x01\x01\x12\
    \x04\xc4\x04\x20*\n\x0f\n\x07\x04A\x03\x01\x02\x01\x03\x12\x04\xc4\x04-.\
    \n\x0e\n\x06\x04A\x03\x01\x02\x02\x12\x04\xc5\x04\x10.\n\x0f\n\x07\x04A\
    \x03\x01\x02\x02\x04\x12\x04\xc5\x04\x10\x18\n\x0f\n\x07\x04A\x03\x01\
    \x02\x02\x05\x12\x04\xc5\x04\x19\x1f\n\x0f\n\x07\x04A\x03\x01\x02\x02\
    \x01\x12\x04\xc5\x04\x20)\n\x0f\n\x07\x04A\x03\x01\x02\x02\x03\x12\x04\
    \xc5\x04,-\n\x0e\n\x06\x04A\x03\x01\x02\x03\x12\x04\xc6\x04\x103\n\x0f\n\
    \x07\x04A\x03\x01\x02\x03\x04\x12\x04\xc6\x04\x10\x18\n\x0f\n\x07\x04A\
    \x03\x01\x02\x03\x05\x12\x04\xc6\x04\x19\x1f\n\x0f\n\x07\x04A\x03\x01\
    \x02\x03\x01\x12\x04\xc6\x04\x20.\n\x0f\n\x07\x04A\x03\x01\x02\x03\x03\
    \x12\x04\xc6\x0412\n\x0e\n\x06\x04A\x03\x01\x02\x04\x12\x04\xc7\x04\x10/\
    \n\x0f\n\x07\x04A\x03\x01\x02\x04\x04\x12\x04\xc7\x04\x10\x18\n\x0f\n\
    \x07\x04A\x03\x01\x02\x04\x05\x12\x04\xc7\x04\x19\x1f\n\x0f\n\x07\x04A\
    \x03\x01\x02\x04\x01\x12\x04\xc7\x04\x20*\n\x0f\n\x07\x04A\x03\x01\x02\
    \x04\x03\x12\x04\xc7\x04-.\n\x0e\n\x04\x04A\x03\x02\x12\x06\xca\x04\x08\
    \xdf\x04\t\n\r\n\x05\x04A\x03\x02\x01\x12\x04\xca\x04\x10\x1b\n\x0e\n\
    \x06\x04A\x03\x02\x02\0\x12\x04\xcb\x04\x104\n\x0f\n\x07\x04A\x03\x02\
    \x02\0\x04\x12\x04\xcb\x04\x10\x18\n\x0f\n\x07\x04A\x03\x02\x02\0\x05\
    \x12\x04\xcb\x04\x19\x1f\n\x0f\n\x07\x04A\x03\x02\x02\0\x01\x12\x04\xcb\
    \x04\x20/\n\x0f\n\x07\x04A\x03\x02\x02\0\x03\x12\x04\xcb\x0423\n\x0e\n\
    \x06\x04A\x03\x02\x02\x01\x12\x04\xcc\x04\x104\n\x0f\n\x07\x04A\x03\x02\
    \x02\x01\x04\x12\x04\xcc\x04\x10\x18\n\x0f\n\x07\x04A\x03\x02\x02\x01\
    \x05\x12\x04\xcc\x04\x19\x1f\n\x0f\n\x07\x04A\x03\x02\x02\x01\x01\x12\
    \x04\xcc\x04\x20/\n\x0f\n\x07\x04A\x03\x02\x02\x01\x03\x12\x04\xcc\x0423\
    \n\x0e\n\x06\x04A\x03\x02\x02\x02\x12\x04\xcd\x04\x10L\n\x0f\n\x07\x04A\
    \x03\x02\x02\x02\x04\x12\x04\xcd\x04\x10\x18\n\x0f\n\x07\x04A\x03\x02\
    \x02\x02\x06\x12\x04\xcd\x04\x19=\n\x0f\n\x07\x04A\x03\x02\x02\x02\x01\
    \x12\x04\xcd\x04>G\n\x0f\n\x07\x04A\x03\x02\x02\x02\x03\x12\x04\xcd\x04J\
    K\n\x0e\n\x06\x04A\x03\x02\x02\x03\x12\x04\xce\x04\x103\n\x0f\n\x07\x04A\
    \x03\x02\x02\x03\x04\x12\x04\xce\x04\x10\x18\n\x0f\n\x07\x04A\x03\x02\
    \x02\x03\x05\x12\x04\xce\x04\x19\x1f\n\x0f\n\x07\x04A\x03\x02\x02\x03\
    \x01\x12\x04\xce\x04\x20.\n\x0f\n\x07\x04A\x03\x02\x02\x03\x03\x12\x04\
    \xce\x0412\n\x0e\n\x06\x04A\x03\x02\x02\x04\x12\x04\xcf\x04\x106\n\x0f\n\
    \x07\x04A\x03\x02\x02\x04\x04\x12\x04\xcf\x04\x10\x18\n\x0f\n\x07\x04A\
    \x03\x02\x02\x04\x05\x12\x04\xcf\x04\x19\x1f\n\x0f\n\x07\x04A\x03\x02\
    \x02\x04\x01\x12\x04\xcf\x04\x201\n\x0f\n\x07\x04A\x03\x02\x02\x04\x03\
    \x12\x04\xcf\x0445\n\x0e\n\x06\x04A\x03\x02\x02\x05\x12\x04\xd0\x04\x100\
    \n\x0f\n\x07\x04A\x03\x02\x02\x05\x04\x12\x04\xd0\x04\x10\x18\n\x0f\n\
    \x07\x04A\x03\x02\x02\x05\x05\x12\x04\xd0\x04\x19\x1f\n\x0f\n\x07\x04A\
    \x03\x02\x02\x05\x01\x12\x04\xd0\x04\x20+\n\x0f\n\x07\x04A\x03\x02\x02\
    \x05\x03\x12\x04\xd0\x04./\n\x0e\n\x06\x04A\x03\x02\x02\x06\x12\x04\xd1\
    \x04\x10.\n\x0f\n\x07\x04A\x03\x02\x02\x06\x04\x12\x04\xd1\x04\x10\x18\n\
    \x0f\n\x07\x04A\x03\x02\x02\x06\x05\x12\x04\xd1\x04\x19\x1f\n\x0f\n\x07\
    \x04A\x03\x02\x02\x06\x01\x12\x04\xd1\x04\x20)\n\x0f\n\x07\x04A\x03\x02\
    \x02\x06\x03\x12\x04\xd1\x04,-\n\x0e\n\x06\x04A\x03\x02\x02\x07\x12\x04\
    \xd2\x04\x105\n\x0f\n\x07\x04A\x03\x02\x02\x07\x04\x12\x04\xd2\x04\x10\
    \x18\n\x0f\n\x07\x04A\x03\x02\x02\x07\x05\x12\x04\xd2\x04\x19\x1f\n\x0f\
    \n\x07\x04A\x03\x02\x02\x07\x01\x12\x04\xd2\x04\x200\n\x0f\n\x07\x04A\
    \x03\x02\x02\x07\x03\x12\x04\xd2\x0434\n\x0e\n\x06\x04A\x03\x02\x02\x08\
    \x12\x04\xd3\x04\x10.\n\x0f\n\x07\x04A\x03\x02\x02\x08\x04\x12\x04\xd3\
    \x04\x10\x18\n\x0f\n\x07\x04A\x03\x02\x02\x08\x05\x12\x04\xd3\x04\x19\
    \x1f\n\x0f\n\x07\x04A\x03\x02\x02\x08\x01\x12\x04\xd3\x04\x20)\n\x0f\n\
    \x07\x04A\x03\x02\x02\x08\x03\x12\x04\xd3\x04,-\n\x0e\n\x06\x04A\x03\x02\
    \x02\t\x12\x04\xd4\x04\x104\n\x0f\n\x07\x04A\x03\x02\x02\t\x04\x12\x04\
    \xd4\x04\x10\x18\n\x0f\n\x07\x04A\x03\x02\x02\t\x05\x12\x04\xd4\x04\x19\
    \x1f\n\x0f\n\x07\x04A\x03\x02\x02\t\x01\x12\x04\xd4\x04\x20.\n\x0f\n\x07\
    \x04A\x03\x02\x02\t\x03\x12\x04\xd4\x0413\n\x0e\n\x06\x04A\x03\x02\x02\n\
    \x12\x04\xd5\x04\x104\n\x0f\n\x07\x04A\x03\x02\x02\n\x04\x12\x04\xd5\x04\
    \x10\x18\n\x0f\n\x07\x04A\x03\x02\x02\n\x05\x12\x04\xd5\x04\x19\x1f\n\
    \x0f\n\x07\x04A\x03\x02\x02\n\x01\x12\x04\xd5\x04\x20.\n\x0f\n\x07\x04A\
    \x03\x02\x02\n\x03\x12\x04\xd5\x0413\n\x0e\n\x06\x04A\x03\x02\x02\x0b\
    \x12\x04\xd6\x04\x103\n\x0f\n\x07\x04A\x03\x02\x02\x0b\x04\x12\x04\xd6\
    \x04\x10\x18\n\x0f\n\x07\x04A\x03\x02\x02\x0b\x05\x12\x04\xd6\x04\x19\
    \x1f\n\x0f\n\x07\x04A\x03\x02\x02\x0b\x01\x12\x04\xd6\x04\x20-\n\x0f\n\
    \x07\x04A\x03\x02\x02\x0b\x03\x12\x04\xd6\x0402\n\x0e\n\x06\x04A\x03\x02\
    \x02\x0c\x12\x04\xd7\x04\x10<\n\x0f\n\x07\x04A\x03\x02\x02\x0c\x04\x12\
    \x04\xd7\x04\x10\x18\n\x0f\n\x07\x04A\x03\x02\x02\x0c\x05\x12\x04\xd7\
    \x04\x19\x1f\n\x0f\n\x07\x04A\x03\x02\x02\x0c\x01\x12\x04\xd7\x04\x206\n\
    \x0f\n\x07\x04A\x03\x02\x02\x0c\x03\x12\x04\xd7\x049;\n\x0e\n\x06\x04A\
    \x03\x02\x02\r\x12\x04\xd8\x04\x106\n\x0f\n\x07\x04A\x03\x02\x02\r\x04\
    \x12\x04\xd8\x04\x10\x18\n\x0f\n\x07\x04A\x03\x02\x02\r\x05\x12\x04\xd8\
    \x04\x19\x1f\n\x0f\n\x07\x04A\x03\x02\x02\r\x01\x12\x04\xd8\x04\x200\n\
    \x0f\n\x07\x04A\x03\x02\x02\r\x03\x12\x04\xd8\x0435\n\x0e\n\x06\x04A\x03\
    \x02\x02\x0e\x12\x04\xd9\x04\x103\n\x0f\n\x07\x04A\x03\x02\x02\x0e\x04\
    \x12\x04\xd9\x04\x10\x18\n\x0f\n\x07\x04A\x03\x02\x02\x0e\x05\x12\x04\
    \xd9\x04\x19\x1f\n\x0f\n\x07\x04A\x03\x02\x02\x0e\x01\x12\x04\xd9\x04\
    \x20-\n\x0f\n\x07\x04A\x03\x02\x02\x0e\x03\x12\x04\xd9\x0402\n\x0e\n\x06\
    \x04A\x03\x02\x02\x0f\x12\x04\xda\x04\x10?\n\x0f\n\x07\x04A\x03\x02\x02\
    \x0f\x04\x12\x04\xda\x04\x10\x18\n\x0f\n\x07\x04A\x03\x02\x02\x0f\x05\
    \x12\x04\xda\x04\x19\x1f\n\x0f\n\x07\x04A\x03\x02\x02\x0f\x01\x12\x04\
    \xda\x04\x209\n\x0f\n\x07\x04A\x03\x02\x02\x0f\x03\x12\x04\xda\x04<>\n\
    \x0e\n\x06\x04A\x03\x02\x02\x10\x12\x04\xdb\x04\x10;\n\x0f\n\x07\x04A\
    \x03\x02\x02\x10\x04\x12\x04\xdb\x04\x10\x18\n\x0f\n\x07\x04A\x03\x02\
    \x02\x10\x05\x12\x04\xdb\x04\x19\x1f\n\x0f\n\x07\x04A\x03\x02\x02\x10\
    \x01\x12\x04\xdb\x04\x205\n\x0f\n\x07\x04A\x03\x02\x02\x10\x03\x12\x04\
    \xdb\x048:\n\x0e\n\x06\x04A\x03\x02\x02\x11\x12\x04\xdc\x04\x10;\n\x0f\n\
    \x07\x04A\x03\x02\x02\x11\x04\x12\x04\xdc\x04\x10\x18\n\x0f\n\x07\x04A\
    \x03\x02\x02\x11\x05\x12\x04\xdc\x04\x19\x1f\n\x0f\n\x07\x04A\x03\x02\
    \x02\x11\x01\x12\x04\xdc\x04\x205\n\x0f\n\x07\x04A\x03\x02\x02\x11\x03\
    \x12\x04\xdc\x048:\n\x0e\n\x06\x04A\x03\x02\x02\x12\x12\x04\xdd\x04\x10;\
    \n\x0f\n\x07\x04A\x03\x02\x02\x12\x04\x12\x04\xdd\x04\x10\x18\n\x0f\n\
    \x07\x04A\x03\x02\x02\x12\x05\x12\x04\xdd\x04\x19\x1f\n\x0f\n\x07\x04A\
    \x03\x02\x02\x12\x01\x12\x04\xdd\x04\x205\n\x0f\n\x07\x04A\x03\x02\x02\
    \x12\x03\x12\x04\xdd\x048:\n\x0e\n\x06\x04A\x03\x02\x02\x13\x12\x04\xde\
    \x04\x109\n\x0f\n\x07\x04A\x03\x02\x02\x13\x04\x12\x04\xde\x04\x10\x18\n\
    \x0f\n\x07\x04A\x03\x02\x02\x13\x05\x12\x04\xde\x04\x19\x1f\n\x0f\n\x07\
    \x04A\x03\x02\x02\x13\x01\x12\x04\xde\x04\x203\n\x0f\n\x07\x04A\x03\x02\
    \x02\x13\x03\x12\x04\xde\x0468\n\x0c\n\x04\x04A\x02\0\x12\x04\xe1\x04\
    \x08H\n\r\n\x05\x04A\x02\0\x04\x12\x04\xe1\x04\x08\x10\n\r\n\x05\x04A\
    \x02\0\x06\x12\x04\xe1\x04\x117\n\r\n\x05\x04A\x02\0\x01\x12\x04\xe1\x04\
    8C\n\r\n\x05\x04A\x02\0\x03\x12\x04\xe1\x04FG\n\x0c\n\x04\x04A\x02\x01\
    \x12\x04\xe2\x04\x08H\n\r\n\x05\x04A\x02\x01\x04\x12\x04\xe2\x04\x08\x10\
    \n\r\n\x05\x04A\x02\x01\x06\x12\x04\xe2\x04\x117\n\r\n\x05\x04A\x02\x01\
    \x01\x12\x04\xe2\x048C\n\r\n\x05\x04A\x02\x01\x03\x12\x04\xe2\x04FG\n\
    \x0c\n\x02\x04B\x12\x06\xe5\x04\0\xed\x04\x01\n\x0b\n\x03\x04B\x01\x12\
    \x04\xe5\x04\x08\"\n\x0e\n\x04\x04B\x03\0\x12\x06\xe6\x04\x08\xe9\x04\t\
    \n\r\n\x05\x04B\x03\0\x01\x12\x04\xe6\x04\x10&\n\x0e\n\x06\x04B\x03\0\
    \x02\0\x12\x04\xe7\x04\x10+\n\x0f\n\x07\x04B\x03\0\x02\0\x04\x12\x04\xe7\
    \x04\x10\x18\n\x0f\n\x07\x04B\x03\0\x02\0\x05\x12\x04\xe7\x04\x19\x1f\n\
    \x0f\n\x07\x04B\x03\0\x02\0\x01\x12\x04\xe7\x04\x20&\n\x0f\n\x07\x04B\
    \x03\0\x02\0\x03\x12\x04\xe7\x04)*\n\x0e\n\x06\x04B\x03\0\x02\x01\x12\
    \x04\xe8\x04\x10*\n\x0f\n\x07\x04B\x03\0\x02\x01\x04\x12\x04\xe8\x04\x10\
    \x18\n\x0f\n\x07\x04B\x03\0\x02\x01\x05\x12\x04\xe8\x04\x19\x1d\n\x0f\n\
    \x07\x04B\x03\0\x02\x01\x01\x12\x04\xe8\x04\x1e%\n\x0f\n\x07\x04B\x03\0\
    \x02\x01\x03\x12\x04\xe8\x04()\n\x0c\n\x04\x04B\x02\0\x12\x04\xeb\x04\
    \x08_\n\r\n\x05\x04B\x02\0\x04\x12\x04\xeb\x04\x08\x10\n\r\n\x05\x04B\
    \x02\0\x06\x12\x04\xeb\x04\x11C\n\r\n\x05\x04B\x02\0\x01\x12\x04\xeb\x04\
    DZ\n\r\n\x05\x04B\x02\0\x03\x12\x04\xeb\x04]^\n\x0c\n\x04\x04B\x02\x01\
    \x12\x04\xec\x04\x08:\n\r\n\x05\x04B\x02\x01\x04\x12\x04\xec\x04\x08\x10\
    \n\r\n\x05\x04B\x02\x01\x05\x12\x04\xec\x04\x11\x17\n\r\n\x05\x04B\x02\
    \x01\x01\x12\x04\xec\x04\x185\n\r\n\x05\x04B\x02\x01\x03\x12\x04\xec\x04\
    89\n\x0c\n\x02\x04C\x12\x06\xef\x04\0\xf4\x04\x01\n\x0b\n\x03\x04C\x01\
    \x12\x04\xef\x04\x08\x1e\n\x0c\n\x04\x04C\x02\0\x12\x04\xf0\x04\x08%\n\r\
    \n\x05\x04C\x02\0\x04\x12\x04\xf0\x04\x08\x10\n\r\n\x05\x04C\x02\0\x05\
    \x12\x04\xf0\x04\x11\x18\n\r\n\x05\x04C\x02\0\x01\x12\x04\xf0\x04\x19\
    \x20\n\r\n\x05\x04C\x02\0\x03\x12\x04\xf0\x04#$\n\x0c\n\x04\x04C\x02\x01\
    \x12\x04\xf1\x04\x08&\n\r\n\x05\x04C\x02\x01\x04\x12\x04\xf1\x04\x08\x10\
    \n\r\n\x05\x04C\x02\x01\x05\x12\x04\xf1\x04\x11\x17\n\r\n\x05\x04C\x02\
    \x01\x01\x12\x04\xf1\x04\x18!\n\r\n\x05\x04C\x02\x01\x03\x12\x04\xf1\x04\
    $%\n\x0c\n\x04\x04C\x02\x02\x12\x04\xf2\x04\x080\n\r\n\x05\x04C\x02\x02\
    \x04\x12\x04\xf2\x04\x08\x10\n\r\n\x05\x04C\x02\x02\x05\x12\x04\xf2\x04\
    \x11\x16\n\r\n\x05\x04C\x02\x02\x01\x12\x04\xf2\x04\x17+\n\r\n\x05\x04C\
    \x02\x02\x03\x12\x04\xf2\x04./\n\x0c\n\x04\x04C\x02\x03\x12\x04\xf3\x04\
    \x08/\n\r\n\x05\x04C\x02\x03\x04\x12\x04\xf3\x04\x08\x10\n\r\n\x05\x04C\
    \x02\x03\x05\x12\x04\xf3\x04\x11\x18\n\r\n\x05\x04C\x02\x03\x01\x12\x04\
    \xf3\x04\x19*\n\r\n\x05\x04C\x02\x03\x03\x12\x04\xf3\x04-.\n\x0c\n\x02\
    \x04D\x12\x06\xf6\x04\0\x87\x05\x01\n\x0b\n\x03\x04D\x01\x12\x04\xf6\x04\
    \x08&\n\x0e\n\x04\x04D\x03\0\x12\x06\xf7\x04\x08\xfa\x04\t\n\r\n\x05\x04\
    D\x03\0\x01\x12\x04\xf7\x04\x10\x15\n\x0e\n\x06\x04D\x03\0\x02\0\x12\x04\
    \xf8\x04\x10,\n\x0f\n\x07\x04D\x03\0\x02\0\x04\x12\x04\xf8\x04\x10\x18\n\
    \x0f\n\x07\x04D\x03\0\x02\0\x05\x12\x04\xf8\x04\x19\x1f\n\x0f\n\x07\x04D\
    \x03\0\x02\0\x01\x12\x04\xf8\x04\x20'\n\x0f\n\x07\x04D\x03\0\x02\0\x03\
    \x12\x04\xf8\x04*+\n\x0e\n\x06\x04D\x03\0\x02\x01\x12\x04\xf9\x04\x10/\n\
    \x0f\n\x07\x04D\x03\0\x02\x01\x04\x12\x04\xf9\x04\x10\x18\n\x0f\n\x07\
    \x04D\x03\0\x02\x01\x05\x12\x04\xf9\x04\x19\x1f\n\x0f\n\x07\x04D\x03\0\
    \x02\x01\x01\x12\x04\xf9\x04\x20*\n\x0f\n\x07\x04D\x03\0\x02\x01\x03\x12\
    \x04\xf9\x04-.\n\x0e\n\x04\x04D\x03\x01\x12\x06\xfc\x04\x08\xff\x04\t\n\
    \r\n\x05\x04D\x03\x01\x01\x12\x04\xfc\x04\x10\"\n\x0e\n\x06\x04D\x03\x01\
    \x02\0\x12\x04\xfd\x04\x103\n\x0f\n\x07\x04D\x03\x01\x02\0\x04\x12\x04\
    \xfd\x04\x10\x18\n\x0f\n\x07\x04D\x03\x01\x02\0\x05\x12\x04\xfd\x04\x19\
    \x1f\n\x0f\n\x07\x04D\x03\x01\x02\0\x01\x12\x04\xfd\x04\x20.\n\x0f\n\x07\
    \x04D\x03\x01\x02\0\x03\x12\x04\xfd\x0412\n\x0e\n\x06\x04D\x03\x01\x02\
    \x01\x12\x04\xfe\x04\x101\n\x0f\n\x07\x04D\x03\x01\x02\x01\x04\x12\x04\
    \xfe\x04\x10\x18\n\x0f\n\x07\x04D\x03\x01\x02\x01\x05\x12\x04\xfe\x04\
    \x19\x20\n\x0f\n\x07\x04D\x03\x01\x02\x01\x01\x12\x04\xfe\x04!,\n\x0f\n\
    \x07\x04D\x03\x01\x02\x01\x03\x12\x04\xfe\x04/0\n\x0c\n\x04\x04D\x02\0\
    \x12\x04\x81\x05\x08%\n\r\n\x05\x04D\x02\0\x04\x12\x04\x81\x05\x08\x10\n\
    \r\n\x05\x04D\x02\0\x05\x12\x04\x81\x05\x11\x18\n\r\n\x05\x04D\x02\0\x01\
    \x12\x04\x81\x05\x19\x20\n\r\n\x05\x04D\x02\0\x03\x12\x04\x81\x05#$\n\
    \x0c\n\x04\x04D\x02\x01\x12\x04\x82\x05\x081\n\r\n\x05\x04D\x02\x01\x04\
    \x12\x04\x82\x05\x08\x10\n\r\n\x05\x04D\x02\x01\x05\x12\x04\x82\x05\x11\
    \x16\n\r\n\x05\x04D\x02\x01\x01\x12\x04\x82\x05\x17\x1e\n\r\n\x05\x04D\
    \x02\x01\x03\x12\x04\x82\x05!\"\n\r\n\x05\x04D\x02\x01\x08\x12\x04\x82\
    \x05#0\n\r\n\x05\x04D\x02\x01\x07\x12\x04\x82\x05./\n\x0c\n\x04\x04D\x02\
    \x02\x12\x04\x83\x05\x08&\n\r\n\x05\x04D\x02\x02\x04\x12\x04\x83\x05\x08\
    \x10\n\r\n\x05\x04D\x02\x02\x05\x12\x04\x83\x05\x11\x17\n\r\n\x05\x04D\
    \x02\x02\x01\x12\x04\x83\x05\x18!\n\r\n\x05\x04D\x02\x02\x03\x12\x04\x83\
    \x05$%\n\x0c\n\x04\x04D\x02\x03\x12\x04\x84\x05\x08\"\n\r\n\x05\x04D\x02\
    \x03\x04\x12\x04\x84\x05\x08\x10\n\r\n\x05\x04D\x02\x03\x05\x12\x04\x84\
    \x05\x11\x16\n\r\n\x05\x04D\x02\x03\x01\x12\x04\x84\x05\x17\x1d\n\r\n\
    \x05\x04D\x02\x03\x03\x12\x04\x84\x05\x20!\n\x0c\n\x04\x04D\x02\x04\x12\
    \x04\x85\x05\x08A\n\r\n\x05\x04D\x02\x04\x04\x12\x04\x85\x05\x08\x10\n\r\
    \n\x05\x04D\x02\x04\x06\x12\x04\x85\x05\x116\n\r\n\x05\x04D\x02\x04\x01\
    \x12\x04\x85\x057<\n\r\n\x05\x04D\x02\x04\x03\x12\x04\x85\x05?@\n\x0c\n\
    \x04\x04D\x02\x05\x12\x04\x86\x05\x08[\n\r\n\x05\x04D\x02\x05\x04\x12\
    \x04\x86\x05\x08\x10\n\r\n\x05\x04D\x02\x05\x06\x12\x04\x86\x05\x11C\n\r\
    \n\x05\x04D\x02\x05\x01\x12\x04\x86\x05DV\n\r\n\x05\x04D\x02\x05\x03\x12\
    \x04\x86\x05YZ\n\x0c\n\x02\x04E\x12\x06\x89\x05\0\x94\x05\x01\n\x0b\n\
    \x03\x04E\x01\x12\x04\x89\x05\x08(\n\x0e\n\x04\x04E\x03\0\x12\x06\x8a\
    \x05\x08\x8d\x05\t\n\r\n\x05\x04E\x03\0\x01\x12\x04\x8a\x05\x10'\n\x0e\n\
    \x06\x04E\x03\0\x02\0\x12\x04\x8b\x05\x10,\n\x0f\n\x07\x04E\x03\0\x02\0\
    \x04\x12\x04\x8b\x05\x10\x18\n\x0f\n\x07\x04E\x03\0\x02\0\x05\x12\x04\
    \x8b\x05\x19\x1f\n\x0f\n\x07\x04E\x03\0\x02\0\x01\x12\x04\x8b\x05\x20'\n\
    \x0f\n\x07\x04E\x03\0\x02\0\x03\x12\x04\x8b\x05*+\n\x0e\n\x06\x04E\x03\0\
    \x02\x01\x12\x04\x8c\x05\x108\n\x0f\n\x07\x04E\x03\0\x02\x01\x04\x12\x04\
    \x8c\x05\x10\x18\n\x0f\n\x07\x04E\x03\0\x02\x01\x05\x12\x04\x8c\x05\x19\
    \x1f\n\x0f\n\x07\x04E\x03\0\x02\x01\x01\x12\x04\x8c\x05\x203\n\x0f\n\x07\
    \x04E\x03\0\x02\x01\x03\x12\x04\x8c\x0567\n\x0c\n\x04\x04E\x02\0\x12\x04\
    \x8f\x05\x08%\n\r\n\x05\x04E\x02\0\x04\x12\x04\x8f\x05\x08\x10\n\r\n\x05\
    \x04E\x02\0\x05\x12\x04\x8f\x05\x11\x18\n\r\n\x05\x04E\x02\0\x01\x12\x04\
    \x8f\x05\x19\x20\n\r\n\x05\x04E\x02\0\x03\x12\x04\x8f\x05#$\n\x0c\n\x04\
    \x04E\x02\x01\x12\x04\x90\x05\x081\n\r\n\x05\x04E\x02\x01\x04\x12\x04\
    \x90\x05\x08\x10\n\r\n\x05\x04E\x02\x01\x05\x12\x04\x90\x05\x11\x16\n\r\
    \n\x05\x04E\x02\x01\x01\x12\x04\x90\x05\x17\x1e\n\r\n\x05\x04E\x02\x01\
    \x03\x12\x04\x90\x05!\"\n\r\n\x05\x04E\x02\x01\x08\x12\x04\x90\x05#0\n\r\
    \n\x05\x04E\x02\x01\x07\x12\x04\x90\x05./\n\x0c\n\x04\x04E\x02\x02\x12\
    \x04\x91\x05\x08&\n\r\n\x05\x04E\x02\x02\x04\x12\x04\x91\x05\x08\x10\n\r\
    \n\x05\x04E\x02\x02\x05\x12\x04\x91\x05\x11\x17\n\r\n\x05\x04E\x02\x02\
    \x01\x12\x04\x91\x05\x18!\n\r\n\x05\x04E\x02\x02\x03\x12\x04\x91\x05$%\n\
    \x0c\n\x04\x04E\x02\x03\x12\x04\x92\x05\x08g\n\r\n\x05\x04E\x02\x03\x04\
    \x12\x04\x92\x05\x08\x10\n\r\n\x05\x04E\x02\x03\x06\x12\x04\x92\x05\x11J\
    \n\r\n\x05\x04E\x02\x03\x01\x12\x04\x92\x05Kb\n\r\n\x05\x04E\x02\x03\x03\
    \x12\x04\x92\x05ef\n\x0c\n\x04\x04E\x02\x04\x12\x04\x93\x05\x08,\n\r\n\
    \x05\x04E\x02\x04\x04\x12\x04\x93\x05\x08\x10\n\r\n\x05\x04E\x02\x04\x05\
    \x12\x04\x93\x05\x11\x15\n\r\n\x05\x04E\x02\x04\x01\x12\x04\x93\x05\x16'\
    \n\r\n\x05\x04E\x02\x04\x03\x12\x04\x93\x05*+\n\x0c\n\x02\x04F\x12\x06\
    \x96\x05\0\xa2\x05\x01\n\x0b\n\x03\x04F\x01\x12\x04\x96\x05\x08!\n\x0e\n\
    \x04\x04F\x03\0\x12\x06\x97\x05\x08\x9a\x05\t\n\r\n\x05\x04F\x03\0\x01\
    \x12\x04\x97\x05\x10\x15\n\x0e\n\x06\x04F\x03\0\x02\0\x12\x04\x98\x05\
    \x10,\n\x0f\n\x07\x04F\x03\0\x02\0\x04\x12\x04\x98\x05\x10\x18\n\x0f\n\
    \x07\x04F\x03\0\x02\0\x05\x12\x04\x98\x05\x19\x1f\n\x0f\n\x07\x04F\x03\0\
    \x02\0\x01\x12\x04\x98\x05\x20'\n\x0f\n\x07\x04F\x03\0\x02\0\x03\x12\x04\
    \x98\x05*+\n\x0e\n\x06\x04F\x03\0\x02\x01\x12\x04\x99\x05\x10/\n\x0f\n\
    \x07\x04F\x03\0\x02\x01\x04\x12\x04\x99\x05\x10\x18\n\x0f\n\x07\x04F\x03\
    \0\x02\x01\x05\x12\x04\x99\x05\x19\x1f\n\x0f\n\x07\x04F\x03\0\x02\x01\
    \x01\x12\x04\x99\x05\x20*\n\x0f\n\x07\x04F\x03\0\x02\x01\x03\x12\x04\x99\
    \x05-.\n\x0c\n\x04\x04F\x02\0\x12\x04\x9c\x05\x08%\n\r\n\x05\x04F\x02\0\
    \x04\x12\x04\x9c\x05\x08\x10\n\r\n\x05\x04F\x02\0\x05\x12\x04\x9c\x05\
    \x11\x18\n\r\n\x05\x04F\x02\0\x01\x12\x04\x9c\x05\x19\x20\n\r\n\x05\x04F\
    \x02\0\x03\x12\x04\x9c\x05#$\n\x0c\n\x04\x04F\x02\x01\x12\x04\x9d\x05\
    \x08-\n\r\n\x05\x04F\x02\x01\x04\x12\x04\x9d\x05\x08\x10\n\r\n\x05\x04F\
    \x02\x01\x05\x12\x04\x9d\x05\x11\x18\n\r\n\x05\x04F\x02\x01\x01\x12\x04\
    \x9d\x05\x19(\n\r\n\x05\x04F\x02\x01\x03\x12\x04\x9d\x05+,\n\x0c\n\x04\
    \x04F\x02\x02\x12\x04\x9e\x05\x08-\n\r\n\x05\x04F\x02\x02\x04\x12\x04\
    \x9e\x05\x08\x10\n\r\n\x05\x04F\x02\x02\x05\x12\x04\x9e\x05\x11\x18\n\r\
    \n\x05\x04F\x02\x02\x01\x12\x04\x9e\x05\x19(\n\r\n\x05\x04F\x02\x02\x03\
    \x12\x04\x9e\x05+,\n\x0c\n\x04\x04F\x02\x03\x12\x04\x9f\x05\x08&\n\r\n\
    \x05\x04F\x02\x03\x04\x12\x04\x9f\x05\x08\x10\n\r\n\x05\x04F\x02\x03\x05\
    \x12\x04\x9f\x05\x11\x17\n\r\n\x05\x04F\x02\x03\x01\x12\x04\x9f\x05\x18!\
    \n\r\n\x05\x04F\x02\x03\x03\x12\x04\x9f\x05$%\n\x0c\n\x04\x04F\x02\x04\
    \x12\x04\xa0\x05\x08)\n\r\n\x05\x04F\x02\x04\x04\x12\x04\xa0\x05\x08\x10\
    \n\r\n\x05\x04F\x02\x04\x05\x12\x04\xa0\x05\x11\x15\n\r\n\x05\x04F\x02\
    \x04\x01\x12\x04\xa0\x05\x16$\n\r\n\x05\x04F\x02\x04\x03\x12\x04\xa0\x05\
    '(\n\x0c\n\x04\x04F\x02\x05\x12\x04\xa1\x05\x08<\n\r\n\x05\x04F\x02\x05\
    \x04\x12\x04\xa1\x05\x08\x10\n\r\n\x05\x04F\x02\x05\x06\x12\x04\xa1\x05\
    \x111\n\r\n\x05\x04F\x02\x05\x01\x12\x04\xa1\x0527\n\r\n\x05\x04F\x02\
    \x05\x03\x12\x04\xa1\x05:;\n\x0c\n\x02\x04G\x12\x06\xa4\x05\0\xae\x05\
    \x01\n\x0b\n\x03\x04G\x01\x12\x04\xa4\x05\x08\x1e\n\x0e\n\x04\x04G\x03\0\
    \x12\x06\xa5\x05\x08\xa8\x05\t\n\r\n\x05\x04G\x03\0\x01\x12\x04\xa5\x05\
    \x10\x1d\n\x0e\n\x06\x04G\x03\0\x02\0\x12\x04\xa6\x05\x10,\n\x0f\n\x07\
    \x04G\x03\0\x02\0\x04\x12\x04\xa6\x05\x10\x18\n\x0f\n\x07\x04G\x03\0\x02\
    \0\x05\x12\x04\xa6\x05\x19\x1f\n\x0f\n\x07\x04G\x03\0\x02\0\x01\x12\x04\
    \xa6\x05\x20'\n\x0f\n\x07\x04G\x03\0\x02\0\x03\x12\x04\xa6\x05*+\n\x0e\n\
    \x06\x04G\x03\0\x02\x01\x12\x04\xa7\x05\x10/\n\x0f\n\x07\x04G\x03\0\x02\
    \x01\x04\x12\x04\xa7\x05\x10\x18\n\x0f\n\x07\x04G\x03\0\x02\x01\x05\x12\
    \x04\xa7\x05\x19\x1f\n\x0f\n\x07\x04G\x03\0\x02\x01\x01\x12\x04\xa7\x05\
    \x20*\n\x0f\n\x07\x04G\x03\0\x02\x01\x03\x12\x04\xa7\x05-.\n\x0c\n\x04\
    \x04G\x02\0\x12\x04\xaa\x05\x08&\n\r\n\x05\x04G\x02\0\x04\x12\x04\xaa\
    \x05\x08\x10\n\r\n\x05\x04G\x02\0\x05\x12\x04\xaa\x05\x11\x18\n\r\n\x05\
    \x04G\x02\0\x01\x12\x04\xaa\x05\x19!\n\r\n\x05\x04G\x02\0\x03\x12\x04\
    \xaa\x05$%\n\x0c\n\x04\x04G\x02\x01\x12\x04\xab\x05\x08%\n\r\n\x05\x04G\
    \x02\x01\x04\x12\x04\xab\x05\x08\x10\n\r\n\x05\x04G\x02\x01\x05\x12\x04\
    \xab\x05\x11\x18\n\r\n\x05\x04G\x02\x01\x01\x12\x04\xab\x05\x19\x20\n\r\
    \n\x05\x04G\x02\x01\x03\x12\x04\xab\x05#$\n\x0c\n\x04\x04G\x02\x02\x12\
    \x04\xac\x05\x08&\n\r\n\x05\x04G\x02\x02\x04\x12\x04\xac\x05\x08\x10\n\r\
    \n\x05\x04G\x02\x02\x05\x12\x04\xac\x05\x11\x17\n\r\n\x05\x04G\x02\x02\
    \x01\x12\x04\xac\x05\x18!\n\r\n\x05\x04G\x02\x02\x03\x12\x04\xac\x05$%\n\
    \x0c\n\x04\x04G\x02\x03\x12\x04\xad\x05\x08I\n\r\n\x05\x04G\x02\x03\x04\
    \x12\x04\xad\x05\x08\x10\n\r\n\x05\x04G\x02\x03\x06\x12\x04\xad\x05\x116\
    \n\r\n\x05\x04G\x02\x03\x01\x12\x04\xad\x057D\n\r\n\x05\x04G\x02\x03\x03\
    \x12\x04\xad\x05GH\n\x0c\n\x02\x04H\x12\x06\xb0\x05\0\xb9\x05\x01\n\x0b\
    \n\x03\x04H\x01\x12\x04\xb0\x05\x08\x20\n\x0e\n\x04\x04H\x03\0\x12\x06\
    \xb1\x05\x08\xb4\x05\t\n\r\n\x05\x04H\x03\0\x01\x12\x04\xb1\x05\x10\x1e\
    \n\x0e\n\x06\x04H\x03\0\x02\0\x12\x04\xb2\x05\x10,\n\x0f\n\x07\x04H\x03\
    \0\x02\0\x04\x12\x04\xb2\x05\x10\x18\n\x0f\n\x07\x04H\x03\0\x02\0\x05\
    \x12\x04\xb2\x05\x19\x1f\n\x0f\n\x07\x04H\x03\0\x02\0\x01\x12\x04\xb2\
    \x05\x20'\n\x0f\n\x07\x04H\x03\0\x02\0\x03\x12\x04\xb2\x05*+\n\x0e\n\x06\
    \x04H\x03\0\x02\x01\x12\x04\xb3\x05\x10/\n\x0f\n\x07\x04H\x03\0\x02\x01\
    \x04\x12\x04\xb3\x05\x10\x18\n\x0f\n\x07\x04H\x03\0\x02\x01\x05\x12\x04\
    \xb3\x05\x19\x1f\n\x0f\n\x07\x04H\x03\0\x02\x01\x01\x12\x04\xb3\x05\x20*\
    \n\x0f\n\x07\x04H\x03\0\x02\x01\x03\x12\x04\xb3\x05-.\n\x0c\n\x04\x04H\
    \x02\0\x12\x04\xb6\x05\x08%\n\r\n\x05\x04H\x02\0\x04\x12\x04\xb6\x05\x08\
    \x10\n\r\n\x05\x04H\x02\0\x05\x12\x04\xb6\x05\x11\x18\n\r\n\x05\x04H\x02\
    \0\x01\x12\x04\xb6\x05\x19\x20\n\r\n\x05\x04H\x02\0\x03\x12\x04\xb6\x05#\
    $\n\x0c\n\x04\x04H\x02\x01\x12\x04\xb7\x05\x08)\n\r\n\x05\x04H\x02\x01\
    \x04\x12\x04\xb7\x05\x08\x10\n\r\n\x05\x04H\x02\x01\x05\x12\x04\xb7\x05\
    \x11\x15\n\r\n\x05\x04H\x02\x01\x01\x12\x04\xb7\x05\x16$\n\r\n\x05\x04H\
    \x02\x01\x03\x12\x04\xb7\x05'(\n\x0c\n\x04\x04H\x02\x02\x12\x04\xb8\x05\
    \x08M\n\r\n\x05\x04H\x02\x02\x04\x12\x04\xb8\x05\x08\x10\n\r\n\x05\x04H\
    \x02\x02\x06\x12\x04\xb8\x05\x119\n\r\n\x05\x04H\x02\x02\x01\x12\x04\xb8\
    \x05:H\n\r\n\x05\x04H\x02\x02\x03\x12\x04\xb8\x05KL\n\x0c\n\x02\x04I\x12\
    \x06\xbb\x05\0\xbc\x05\x01\n\x0b\n\x03\x04I\x01\x12\x04\xbb\x05\x08\"\n\
    \x0c\n\x02\x04J\x12\x06\xbe\x05\0\xc0\x05\x01\n\x0b\n\x03\x04J\x01\x12\
    \x04\xbe\x05\x08,\n\x0c\n\x04\x04J\x02\0\x12\x04\xbf\x05\x08,\n\r\n\x05\
    \x04J\x02\0\x04\x12\x04\xbf\x05\x08\x10\n\r\n\x05\x04J\x02\0\x05\x12\x04\
    \xbf\x05\x11\x17\n\r\n\x05\x04J\x02\0\x01\x12\x04\xbf\x05\x18'\n\r\n\x05\
    \x04J\x02\0\x03\x12\x04\xbf\x05*+\n\x0c\n\x02\x04K\x12\x06\xc2\x05\0\xd1\
    \x05\x01\n\x0b\n\x03\x04K\x01\x12\x04\xc2\x05\x08*\n\x0e\n\x04\x04K\x03\
    \0\x12\x06\xc3\x05\x08\xc7\x05\t\n\r\n\x05\x04K\x03\0\x01\x12\x04\xc3\
    \x05\x10\x14\n\x0e\n\x06\x04K\x03\0\x02\0\x12\x04\xc4\x05\x10*\n\x0f\n\
    \x07\x04K\x03\0\x02\0\x04\x12\x04\xc4\x05\x10\x18\n\x0f\n\x07\x04K\x03\0\
    \x02\0\x05\x12\x04\xc4\x05\x19\x1f\n\x0f\n\x07\x04K\x03\0\x02\0\x01\x12\
    \x04\xc4\x05\x20%\n\x0f\n\x07\x04K\x03\0\x02\0\x03\x12\x04\xc4\x05()\n\
    \x0e\n\x06\x04K\x03\0\x02\x01\x12\x04\xc5\x05\x10/\n\x0f\n\x07\x04K\x03\
    \0\x02\x01\x04\x12\x04\xc5\x05\x10\x18\n\x0f\n\x07\x04K\x03\0\x02\x01\
    \x05\x12\x04\xc5\x05\x19\x1f\n\x0f\n\x07\x04K\x03\0\x02\x01\x01\x12\x04\
    \xc5\x05\x20*\n\x0f\n\x07\x04K\x03\0\x02\x01\x03\x12\x04\xc5\x05-.\n\x0e\
    \n\x06\x04K\x03\0\x02\x02\x12\x04\xc6\x05\x105\n\x0f\n\x07\x04K\x03\0\
    \x02\x02\x04\x12\x04\xc6\x05\x10\x18\n\x0f\n\x07\x04K\x03\0\x02\x02\x05\
    \x12\x04\xc6\x05\x19\x1f\n\x0f\n\x07\x04K\x03\0\x02\x02\x01\x12\x04\xc6\
    \x05\x200\n\x0f\n\x07\x04K\x03\0\x02\x02\x03\x12\x04\xc6\x0534\n\x0c\n\
    \x04\x04K\x02\0\x12\x04\xc9\x05\x08,\n\r\n\x05\x04K\x02\0\x04\x12\x04\
    \xc9\x05\x08\x10\n\r\n\x05\x04K\x02\0\x05\x12\x04\xc9\x05\x11\x17\n\r\n\
    \x05\x04K\x02\0\x01\x12\x04\xc9\x05\x18'\n\r\n\x05\x04K\x02\0\x03\x12\
    \x04\xc9\x05*+\n\x0c\n\x04\x04K\x02\x01\x12\x04\xca\x05\x08-\n\r\n\x05\
    \x04K\x02\x01\x04\x12\x04\xca\x05\x08\x10\n\r\n\x05\x04K\x02\x01\x05\x12\
    \x04\xca\x05\x11\x17\n\r\n\x05\x04K\x02\x01\x01\x12\x04\xca\x05\x18(\n\r\
    \n\x05\x04K\x02\x01\x03\x12\x04\xca\x05+,\n\x0c\n\x04\x04K\x02\x02\x12\
    \x04\xcb\x05\x08\x1f\n\r\n\x05\x04K\x02\x02\x04\x12\x04\xcb\x05\x08\x10\
    \n\r\n\x05\x04K\x02\x02\x05\x12\x04\xcb\x05\x11\x17\n\r\n\x05\x04K\x02\
    \x02\x01\x12\x04\xcb\x05\x18\x1a\n\r\n\x05\x04K\x02\x02\x03\x12\x04\xcb\
    \x05\x1d\x1e\n\x0c\n\x04\x04K\x02\x03\x12\x04\xcc\x05\x08)\n\r\n\x05\x04\
    K\x02\x03\x04\x12\x04\xcc\x05\x08\x10\n\r\n\x05\x04K\x02\x03\x05\x12\x04\
    \xcc\x05\x11\x17\n\r\n\x05\x04K\x02\x03\x01\x12\x04\xcc\x05\x18$\n\r\n\
    \x05\x04K\x02\x03\x03\x12\x04\xcc\x05'(\n\x0c\n\x04\x04K\x02\x04\x12\x04\
    \xcd\x05\x08&\n\r\n\x05\x04K\x02\x04\x04\x12\x04\xcd\x05\x08\x10\n\r\n\
    \x05\x04K\x02\x04\x05\x12\x04\xcd\x05\x11\x17\n\r\n\x05\x04K\x02\x04\x01\
    \x12\x04\xcd\x05\x18!\n\r\n\x05\x04K\x02\x04\x03\x12\x04\xcd\x05$%\n\x0c\
    \n\x04\x04K\x02\x05\x12\x04\xce\x05\x08'\n\r\n\x05\x04K\x02\x05\x04\x12\
    \x04\xce\x05\x08\x10\n\r\n\x05\x04K\x02\x05\x05\x12\x04\xce\x05\x11\x17\
    \n\r\n\x05\x04K\x02\x05\x01\x12\x04\xce\x05\x18\"\n\r\n\x05\x04K\x02\x05\
    \x03\x12\x04\xce\x05%&\n\x0c\n\x04\x04K\x02\x06\x12\x04\xcf\x05\x08,\n\r\
    \n\x05\x04K\x02\x06\x04\x12\x04\xcf\x05\x08\x10\n\r\n\x05\x04K\x02\x06\
    \x05\x12\x04\xcf\x05\x11\x17\n\r\n\x05\x04K\x02\x06\x01\x12\x04\xcf\x05\
    \x18'\n\r\n\x05\x04K\x02\x06\x03\x12\x04\xcf\x05*+\n\x0c\n\x04\x04K\x02\
    \x07\x12\x04\xd0\x05\x08L\n\r\n\x05\x04K\x02\x07\x04\x12\x04\xd0\x05\x08\
    \x10\n\r\n\x05\x04K\x02\x07\x06\x12\x04\xd0\x05\x119\n\r\n\x05\x04K\x02\
    \x07\x01\x12\x04\xd0\x05:G\n\r\n\x05\x04K\x02\x07\x03\x12\x04\xd0\x05JK\
    \n\x0c\n\x02\x04L\x12\x06\xd3\x05\0\xda\x05\x01\n\x0b\n\x03\x04L\x01\x12\
    \x04\xd3\x05\x08\"\n\x0c\n\x04\x04L\x02\0\x12\x04\xd4\x05\x08\x20\n\r\n\
    \x05\x04L\x02\0\x04\x12\x04\xd4\x05\x08\x10\n\r\n\x05\x04L\x02\0\x05\x12\
    \x04\xd4\x05\x11\x15\n\r\n\x05\x04L\x02\0\x01\x12\x04\xd4\x05\x16\x1b\n\
    \r\n\x05\x04L\x02\0\x03\x12\x04\xd4\x05\x1e\x1f\n\x0c\n\x04\x04L\x02\x01\
    \x12\x04\xd5\x05\x08\x20\n\r\n\x05\x04L\x02\x01\x04\x12\x04\xd5\x05\x08\
    \x10\n\r\n\x05\x04L\x02\x01\x05\x12\x04\xd5\x05\x11\x15\n\r\n\x05\x04L\
    \x02\x01\x01\x12\x04\xd5\x05\x16\x1b\n\r\n\x05\x04L\x02\x01\x03\x12\x04\
    \xd5\x05\x1e\x1f\n\x0c\n\x04\x04L\x02\x02\x12\x04\xd6\x05\x08\x20\n\r\n\
    \x05\x04L\x02\x02\x04\x12\x04\xd6\x05\x08\x10\n\r\n\x05\x04L\x02\x02\x05\
    \x12\x04\xd6\x05\x11\x15\n\r\n\x05\x04L\x02\x02\x01\x12\x04\xd6\x05\x16\
    \x1b\n\r\n\x05\x04L\x02\x02\x03\x12\x04\xd6\x05\x1e\x1f\n\x0c\n\x04\x04L\
    \x02\x03\x12\x04\xd7\x05\x08)\n\r\n\x05\x04L\x02\x03\x04\x12\x04\xd7\x05\
    \x08\x10\n\r\n\x05\x04L\x02\x03\x05\x12\x04\xd7\x05\x11\x15\n\r\n\x05\
    \x04L\x02\x03\x01\x12\x04\xd7\x05\x16$\n\r\n\x05\x04L\x02\x03\x03\x12\
    \x04\xd7\x05'(\n\x0c\n\x04\x04L\x02\x04\x12\x04\xd8\x05\x08(\n\r\n\x05\
    \x04L\x02\x04\x04\x12\x04\xd8\x05\x08\x10\n\r\n\x05\x04L\x02\x04\x05\x12\
    \x04\xd8\x05\x11\x15\n\r\n\x05\x04L\x02\x04\x01\x12\x04\xd8\x05\x16#\n\r\
    \n\x05\x04L\x02\x04\x03\x12\x04\xd8\x05&'\n\x0c\n\x04\x04L\x02\x05\x12\
    \x04\xd9\x05\x08!\n\r\n\x05\x04L\x02\x05\x04\x12\x04\xd9\x05\x08\x10\n\r\
    \n\x05\x04L\x02\x05\x05\x12\x04\xd9\x05\x11\x15\n\r\n\x05\x04L\x02\x05\
    \x01\x12\x04\xd9\x05\x16\x1c\n\r\n\x05\x04L\x02\x05\x03\x12\x04\xd9\x05\
    \x1f\x20\n\x0c\n\x02\x04M\x12\x06\xdc\x05\0\xf6\x05\x01\n\x0b\n\x03\x04M\
    \x01\x12\x04\xdc\x05\x08*\n\x0e\n\x04\x04M\x03\0\x12\x06\xdd\x05\x08\xf2\
    \x05\t\n\r\n\x05\x04M\x03\0\x01\x12\x04\xdd\x05\x10\x13\n\x10\n\x06\x04M\
    \x03\0\x03\0\x12\x06\xde\x05\x10\xe1\x05\x11\n\x0f\n\x07\x04M\x03\0\x03\
    \0\x01\x12\x04\xde\x05\x18\x1b\n\x10\n\x08\x04M\x03\0\x03\0\x02\0\x12\
    \x04\xdf\x05\x182\n\x11\n\t\x04M\x03\0\x03\0\x02\0\x04\x12\x04\xdf\x05\
    \x18\x20\n\x11\n\t\x04M\x03\0\x03\0\x02\0\x05\x12\x04\xdf\x05!'\n\x11\n\
    \t\x04M\x03\0\x03\0\x02\0\x01\x12\x04\xdf\x05(-\n\x11\n\t\x04M\x03\0\x03\
    \0\x02\0\x03\x12\x04\xdf\x0501\n\x10\n\x08\x04M\x03\0\x03\0\x02\x01\x12\
    \x04\xe0\x05\x184\n\x11\n\t\x04M\x03\0\x03\0\x02\x01\x04\x12\x04\xe0\x05\
    \x18\x20\n\x11\n\t\x04M\x03\0\x03\0\x02\x01\x05\x12\x04\xe0\x05!%\n\x11\
    \n\t\x04M\x03\0\x03\0\x02\x01\x01\x12\x04\xe0\x05&/\n\x11\n\t\x04M\x03\0\
    \x03\0\x02\x01\x03\x12\x04\xe0\x0523\n\x0e\n\x06\x04M\x03\0\x02\0\x12\
    \x04\xe3\x05\x10*\n\x0f\n\x07\x04M\x03\0\x02\0\x04\x12\x04\xe3\x05\x10\
    \x18\n\x0f\n\x07\x04M\x03\0\x02\0\x05\x12\x04\xe3\x05\x19\x1f\n\x0f\n\
    \x07\x04M\x03\0\x02\0\x01\x12\x04\xe3\x05\x20%\n\x0f\n\x07\x04M\x03\0\
    \x02\0\x03\x12\x04\xe3\x05()\n\x0e\n\x06\x04M\x03\0\x02\x01\x12\x04\xe4\
    \x05\x10-\n\x0f\n\x07\x04M\x03\0\x02\x01\x04\x12\x04\xe4\x05\x10\x18\n\
    \x0f\n\x07\x04M\x03\0\x02\x01\x05\x12\x04\xe4\x05\x19\x1f\n\x0f\n\x07\
    \x04M\x03\0\x02\x01\x01\x12\x04\xe4\x05\x20(\n\x0f\n\x07\x04M\x03\0\x02\
    \x01\x03\x12\x04\xe4\x05+,\n\x0e\n\x06\x04M\x03\0\x02\x02\x12\x04\xe5\
    \x05\x10.\n\x0f\n\x07\x04M\x03\0\x02\x02\x04\x12\x04\xe5\x05\x10\x18\n\
    \x0f\n\x07\x04M\x03\0\x02\x02\x05\x12\x04\xe5\x05\x19\x1f\n\x0f\n\x07\
    \x04M\x03\0\x02\x02\x01\x12\x04\xe5\x05\x20(\n\x0f\n\x07\x04M\x03\0\x02\
    \x02\x03\x12\x04\xe5\x05+-\n\x0e\n\x06\x04M\x03\0\x02\x03\x12\x04\xe6\
    \x05\x10+\n\x0f\n\x07\x04M\x03\0\x02\x03\x04\x12\x04\xe6\x05\x10\x18\n\
    \x0f\n\x07\x04M\x03\0\x02\x03\x05\x12\x04\xe6\x05\x19\x1d\n\x0f\n\x07\
    \x04M\x03\0\x02\x03\x01\x12\x04\xe6\x05\x1e&\n\x0f\n\x07\x04M\x03\0\x02\
    \x03\x03\x12\x04\xe6\x05)*\n\x0e\n\x06\x04M\x03\0\x02\x04\x12\x04\xe7\
    \x05\x10,\n\x0f\n\x07\x04M\x03\0\x02\x04\x04\x12\x04\xe7\x05\x10\x18\n\
    \x0f\n\x07\x04M\x03\0\x02\x04\x05\x12\x04\xe7\x05\x19\x1d\n\x0f\n\x07\
    \x04M\x03\0\x02\x04\x01\x12\x04\xe7\x05\x1e'\n\x0f\n\x07\x04M\x03\0\x02\
    \x04\x03\x12\x04\xe7\x05*+\n\x0e\n\x06\x04M\x03\0\x02\x05\x12\x04\xe8\
    \x05\x10.\n\x0f\n\x07\x04M\x03\0\x02\x05\x04\x12\x04\xe8\x05\x10\x18\n\
    \x0f\n\x07\x04M\x03\0\x02\x05\x05\x12\x04\xe8\x05\x19\x1d\n\x0f\n\x07\
    \x04M\x03\0\x02\x05\x01\x12\x04\xe8\x05\x1e)\n\x0f\n\x07\x04M\x03\0\x02\
    \x05\x03\x12\x04\xe8\x05,-\n\x0e\n\x06\x04M\x03\0\x02\x06\x12\x04\xe9\
    \x05\x105\n\x0f\n\x07\x04M\x03\0\x02\x06\x04\x12\x04\xe9\x05\x10\x18\n\
    \x0f\n\x07\x04M\x03\0\x02\x06\x05\x12\x04\xe9\x05\x19\x1f\n\x0f\n\x07\
    \x04M\x03\0\x02\x06\x01\x12\x04\xe9\x05\x200\n\x0f\n\x07\x04M\x03\0\x02\
    \x06\x03\x12\x04\xe9\x0534\n\x0e\n\x06\x04M\x03\0\x02\x07\x12\x04\xea\
    \x05\x101\n\x0f\n\x07\x04M\x03\0\x02\x07\x04\x12\x04\xea\x05\x10\x18\n\
    \x0f\n\x07\x04M\x03\0\x02\x07\x05\x12\x04\xea\x05\x19\x1f\n\x0f\n\x07\
    \x04M\x03\0\x02\x07\x01\x12\x04\xea\x05\x20,\n\x0f\n\x07\x04M\x03\0\x02\
    \x07\x03\x12\x04\xea\x05/0\n\x0e\n\x06\x04M\x03\0\x02\x08\x12\x04\xeb\
    \x05\x108\n\x0f\n\x07\x04M\x03\0\x02\x08\x04\x12\x04\xeb\x05\x10\x18\n\
    \x0f\n\x07\x04M\x03\0\x02\x08\x05\x12\x04\xeb\x05\x19\x1f\n\x0f\n\x07\
    \x04M\x03\0\x02\x08\x01\x12\x04\xeb\x05\x203\n\x0f\n\x07\x04M\x03\0\x02\
    \x08\x03\x12\x04\xeb\x0567\n\x0e\n\x06\x04M\x03\0\x02\t\x12\x04\xec\x05\
    \x103\n\x0f\n\x07\x04M\x03\0\x02\t\x04\x12\x04\xec\x05\x10\x18\n\x0f\n\
    \x07\x04M\x03\0\x02\t\x05\x12\x04\xec\x05\x19\x1d\n\x0f\n\x07\x04M\x03\0\
    \x02\t\x01\x12\x04\xec\x05\x1e-\n\x0f\n\x07\x04M\x03\0\x02\t\x03\x12\x04\
    \xec\x0502\n\x0e\n\x06\x04M\x03\0\x02\n\x12\x04\xed\x05\x105\n\x0f\n\x07\
    \x04M\x03\0\x02\n\x04\x12\x04\xed\x05\x10\x18\n\x0f\n\x07\x04M\x03\0\x02\
    \n\x05\x12\x04\xed\x05\x19\x1f\n\x0f\n\x07\x04M\x03\0\x02\n\x01\x12\x04\
    \xed\x05\x20/\n\x0f\n\x07\x04M\x03\0\x02\n\x03\x12\x04\xed\x0524\n\x0e\n\
    \x06\x04M\x03\0\x02\x0b\x12\x04\xee\x05\x100\n\x0f\n\x07\x04M\x03\0\x02\
    \x0b\x04\x12\x04\xee\x05\x10\x18\n\x0f\n\x07\x04M\x03\0\x02\x0b\x05\x12\
    \x04\xee\x05\x19\x1f\n\x0f\n\x07\x04M\x03\0\x02\x0b\x01\x12\x04\xee\x05\
    \x20*\n\x0f\n\x07\x04M\x03\0\x02\x0b\x03\x12\x04\xee\x05-/\n\x0e\n\x06\
    \x04M\x03\0\x02\x0c\x12\x04\xef\x05\x10,\n\x0f\n\x07\x04M\x03\0\x02\x0c\
    \x04\x12\x04\xef\x05\x10\x18\n\x0f\n\x07\x04M\x03\0\x02\x0c\x05\x12\x04\
    \xef\x05\x19\x1d\n\x0f\n\x07\x04M\x03\0\x02\x0c\x01\x12\x04\xef\x05\x1e&\
    \n\x0f\n\x07\x04M\x03\0\x02\x0c\x03\x12\x04\xef\x05)+\n\x0e\n\x06\x04M\
    \x03\0\x02\r\x12\x04\xf0\x05\x109\n\x0f\n\x07\x04M\x03\0\x02\r\x04\x12\
    \x04\xf0\x05\x10\x18\n\x0f\n\x07\x04M\x03\0\x02\r\x05\x12\x04\xf0\x05\
    \x19\x1d\n\x0f\n\x07\x04M\x03\0\x02\r\x01\x12\x04\xf0\x05\x1e3\n\x0f\n\
    \x07\x04M\x03\0\x02\r\x03\x12\x04\xf0\x0568\n\x0e\n\x06\x04M\x03\0\x02\
    \x0e\x12\x04\xf1\x05\x10N\n\x0f\n\x07\x04M\x03\0\x02\x0e\x04\x12\x04\xf1\
    \x05\x10\x18\n\x0f\n\x07\x04M\x03\0\x02\x0e\x06\x12\x04\xf1\x05\x19D\n\
    \x0f\n\x07\x04M\x03\0\x02\x0e\x01\x12\x04\xf1\x05EI\n\x0f\n\x07\x04M\x03\
    \0\x02\x0e\x03\x12\x04\xf1\x05LM\n\x0c\n\x04\x04M\x02\0\x12\x04\xf4\x05\
    \x08B\n\r\n\x05\x04M\x02\0\x04\x12\x04\xf4\x05\x08\x10\n\r\n\x05\x04M\
    \x02\0\x06\x12\x04\xf4\x05\x118\n\r\n\x05\x04M\x02\0\x01\x12\x04\xf4\x05\
    9=\n\r\n\x05\x04M\x02\0\x03\x12\x04\xf4\x05@A\n\x0c\n\x04\x04M\x02\x01\
    \x12\x04\xf5\x05\x08,\n\r\n\x05\x04M\x02\x01\x04\x12\x04\xf5\x05\x08\x10\
    \n\r\n\x05\x04M\x02\x01\x05\x12\x04\xf5\x05\x11\x17\n\r\n\x05\x04M\x02\
    \x01\x01\x12\x04\xf5\x05\x18'\n\r\n\x05\x04M\x02\x01\x03\x12\x04\xf5\x05\
    *+\n\x0c\n\x02\x04N\x12\x06\xf8\x05\0\xfa\x05\x01\n\x0b\n\x03\x04N\x01\
    \x12\x04\xf8\x05\x08\"\n\x0c\n\x04\x04N\x02\0\x12\x04\xf9\x05\x08\"\n\r\
    \n\x05\x04N\x02\0\x04\x12\x04\xf9\x05\x08\x10\n\r\n\x05\x04N\x02\0\x05\
    \x12\x04\xf9\x05\x11\x17\n\r\n\x05\x04N\x02\0\x01\x12\x04\xf9\x05\x18\
    \x1d\n\r\n\x05\x04N\x02\0\x03\x12\x04\xf9\x05\x20!\n\x0c\n\x02\x04O\x12\
    \x06\xfc\x05\0\xfe\x05\x01\n\x0b\n\x03\x04O\x01\x12\x04\xfc\x05\x08*\n\
    \x0c\n\x04\x04O\x02\0\x12\x04\xfd\x05\x08#\n\r\n\x05\x04O\x02\0\x04\x12\
    \x04\xfd\x05\x08\x10\n\r\n\x05\x04O\x02\0\x05\x12\x04\xfd\x05\x11\x17\n\
    \r\n\x05\x04O\x02\0\x01\x12\x04\xfd\x05\x18\x1e\n\r\n\x05\x04O\x02\0\x03\
    \x12\x04\xfd\x05!\"\n\x0c\n\x02\x04P\x12\x06\x80\x06\0\x82\x06\x01\n\x0b\
    \n\x03\x04P\x01\x12\x04\x80\x06\x08$\n\x0c\n\x04\x04P\x02\0\x12\x04\x81\
    \x06\x08\"\n\r\n\x05\x04P\x02\0\x04\x12\x04\x81\x06\x08\x10\n\r\n\x05\
    \x04P\x02\0\x05\x12\x04\x81\x06\x11\x17\n\r\n\x05\x04P\x02\0\x01\x12\x04\
    \x81\x06\x18\x1d\n\r\n\x05\x04P\x02\0\x03\x12\x04\x81\x06\x20!\n\x0c\n\
    \x02\x04Q\x12\x06\x84\x06\0\x86\x06\x01\n\x0b\n\x03\x04Q\x01\x12\x04\x84\
    \x06\x08,\n\x0c\n\x04\x04Q\x02\0\x12\x04\x85\x06\x08#\n\r\n\x05\x04Q\x02\
    \0\x04\x12\x04\x85\x06\x08\x10\n\r\n\x05\x04Q\x02\0\x05\x12\x04\x85\x06\
    \x11\x17\n\r\n\x05\x04Q\x02\0\x01\x12\x04\x85\x06\x18\x1e\n\r\n\x05\x04Q\
    \x02\0\x03\x12\x04\x85\x06!\"\n\x0c\n\x02\x04R\x12\x06\x88\x06\0\x8b\x06\
    \x01\n\x0b\n\x03\x04R\x01\x12\x04\x88\x06\x08)\n\x0c\n\x04\x04R\x02\0\
    \x12\x04\x89\x06\x08\"\n\r\n\x05\x04R\x02\0\x04\x12\x04\x89\x06\x08\x10\
    \n\r\n\x05\x04R\x02\0\x05\x12\x04\x89\x06\x11\x17\n\r\n\x05\x04R\x02\0\
    \x01\x12\x04\x89\x06\x18\x1d\n\r\n\x05\x04R\x02\0\x03\x12\x04\x89\x06\
    \x20!\n\x0c\n\x04\x04R\x02\x01\x12\x04\x8a\x06\x08!\n\r\n\x05\x04R\x02\
    \x01\x04\x12\x04\x8a\x06\x08\x10\n\r\n\x05\x04R\x02\x01\x05\x12\x04\x8a\
    \x06\x11\x15\n\r\n\x05\x04R\x02\x01\x01\x12\x04\x8a\x06\x16\x1c\n\r\n\
    \x05\x04R\x02\x01\x03\x12\x04\x8a\x06\x1f\x20\n\x0c\n\x02\x04S\x12\x06\
    \x8d\x06\0\x8f\x06\x01\n\x0b\n\x03\x04S\x01\x12\x04\x8d\x06\x081\n\x0c\n\
    \x04\x04S\x02\0\x12\x04\x8e\x06\x08#\n\r\n\x05\x04S\x02\0\x04\x12\x04\
    \x8e\x06\x08\x10\n\r\n\x05\x04S\x02\0\x05\x12\x04\x8e\x06\x11\x17\n\r\n\
    \x05\x04S\x02\0\x01\x12\x04\x8e\x06\x18\x1e\n\r\n\x05\x04S\x02\0\x03\x12\
    \x04\x8e\x06!\"\n\x0c\n\x02\x04T\x12\x06\x91\x06\0\x9c\x06\x01\n\x0b\n\
    \x03\x04T\x01\x12\x04\x91\x06\x08&\n\x0c\n\x04\x04T\x02\0\x12\x04\x92\
    \x06\x08#\n\r\n\x05\x04T\x02\0\x04\x12\x04\x92\x06\x08\x10\n\r\n\x05\x04\
    T\x02\0\x05\x12\x04\x92\x06\x11\x17\n\r\n\x05\x04T\x02\0\x01\x12\x04\x92\
    \x06\x18\x1e\n\r\n\x05\x04T\x02\0\x03\x12\x04\x92\x06!\"\n\x0c\n\x04\x04\
    T\x02\x01\x12\x04\x93\x06\x08&\n\r\n\x05\x04T\x02\x01\x04\x12\x04\x93\
    \x06\x08\x10\n\r\n\x05\x04T\x02\x01\x05\x12\x04\x93\x06\x11\x17\n\r\n\
    \x05\x04T\x02\x01\x01\x12\x04\x93\x06\x18!\n\r\n\x05\x04T\x02\x01\x03\
    \x12\x04\x93\x06$%\n\x0c\n\x04\x04T\x02\x02\x12\x04\x94\x06\x08*\n\r\n\
    \x05\x04T\x02\x02\x04\x12\x04\x94\x06\x08\x10\n\r\n\x05\x04T\x02\x02\x05\
    \x12\x04\x94\x06\x11\x17\n\r\n\x05\x04T\x02\x02\x01\x12\x04\x94\x06\x18%\
    \n\r\n\x05\x04T\x02\x02\x03\x12\x04\x94\x06()\n\x0c\n\x04\x04T\x02\x03\
    \x12\x04\x95\x06\x08$\n\r\n\x05\x04T\x02\x03\x04\x12\x04\x95\x06\x08\x10\
    \n\r\n\x05\x04T\x02\x03\x05\x12\x04\x95\x06\x11\x16\n\r\n\x05\x04T\x02\
    \x03\x01\x12\x04\x95\x06\x17\x1f\n\r\n\x05\x04T\x02\x03\x03\x12\x04\x95\
    \x06\"#\n\x0c\n\x04\x04T\x02\x04\x12\x04\x96\x06\x08'\n\r\n\x05\x04T\x02\
    \x04\x04\x12\x04\x96\x06\x08\x10\n\r\n\x05\x04T\x02\x04\x05\x12\x04\x96\
    \x06\x11\x17\n\r\n\x05\x04T\x02\x04\x01\x12\x04\x96\x06\x18\"\n\r\n\x05\
    \x04T\x02\x04\x03\x12\x04\x96\x06%&\n\x0c\n\x04\x04T\x02\x05\x12\x04\x97\
    \x06\x08&\n\r\n\x05\x04T\x02\x05\x04\x12\x04\x97\x06\x08\x10\n\r\n\x05\
    \x04T\x02\x05\x05\x12\x04\x97\x06\x11\x17\n\r\n\x05\x04T\x02\x05\x01\x12\
    \x04\x97\x06\x18!\n\r\n\x05\x04T\x02\x05\x03\x12\x04\x97\x06$%\n\x0c\n\
    \x04\x04T\x02\x06\x12\x04\x98\x06\x089\n\r\n\x05\x04T\x02\x06\x04\x12\
    \x04\x98\x06\x08\x10\n\r\n\x05\x04T\x02\x06\x05\x12\x04\x98\x06\x11\x17\
    \n\r\n\x05\x04T\x02\x06\x01\x12\x04\x98\x06\x184\n\r\n\x05\x04T\x02\x06\
    \x03\x12\x04\x98\x0678\n\x0c\n\x04\x04T\x02\x07\x12\x04\x99\x06\x08E\n\r\
    \n\x05\x04T\x02\x07\x04\x12\x04\x99\x06\x08\x10\n\r\n\x05\x04T\x02\x07\
    \x05\x12\x04\x99\x06\x11\x17\n\r\n\x05\x04T\x02\x07\x01\x12\x04\x99\x06\
    \x18)\n\r\n\x05\x04T\x02\x07\x03\x12\x04\x99\x06,-\n\r\n\x05\x04T\x02\
    \x07\x08\x12\x04\x99\x06.D\n\r\n\x05\x04T\x02\x07\x07\x12\x04\x99\x069C\
    \n\x0c\n\x04\x04T\x02\x08\x12\x04\x9a\x06\x08$\n\r\n\x05\x04T\x02\x08\
    \x04\x12\x04\x9a\x06\x08\x10\n\r\n\x05\x04T\x02\x08\x05\x12\x04\x9a\x06\
    \x11\x17\n\r\n\x05\x04T\x02\x08\x01\x12\x04\x9a\x06\x18\x1f\n\r\n\x05\
    \x04T\x02\x08\x03\x12\x04\x9a\x06\"#\n\x0c\n\x04\x04T\x02\t\x12\x04\x9b\
    \x06\x08'\n\r\n\x05\x04T\x02\t\x04\x12\x04\x9b\x06\x08\x10\n\r\n\x05\x04\
    T\x02\t\x05\x12\x04\x9b\x06\x11\x15\n\r\n\x05\x04T\x02\t\x01\x12\x04\x9b\
    \x06\x16!\n\r\n\x05\x04T\x02\t\x03\x12\x04\x9b\x06$&\n\x0c\n\x02\x04U\
    \x12\x06\x9e\x06\0\xa7\x06\x01\n\x0b\n\x03\x04U\x01\x12\x04\x9e\x06\x08'\
    \n\x0c\n\x04\x04U\x02\0\x12\x04\x9f\x06\x081\n\r\n\x05\x04U\x02\0\x04\
    \x12\x04\x9f\x06\x08\x10\n\r\n\x05\x04U\x02\0\x05\x12\x04\x9f\x06\x11\
    \x16\n\r\n\x05\x04U\x02\0\x01\x12\x04\x9f\x06\x17\x1e\n\r\n\x05\x04U\x02\
    \0\x03\x12\x04\x9f\x06!\"\n\r\n\x05\x04U\x02\0\x08\x12\x04\x9f\x06#0\n\r\
    \n\x05\x04U\x02\0\x07\x12\x04\x9f\x06./\n\x0c\n\x04\x04U\x02\x01\x12\x04\
    \xa0\x06\x08$\n\r\n\x05\x04U\x02\x01\x04\x12\x04\xa0\x06\x08\x10\n\r\n\
    \x05\x04U\x02\x01\x05\x12\x04\xa0\x06\x11\x16\n\r\n\x05\x04U\x02\x01\x01\
    \x12\x04\xa0\x06\x17\x1f\n\r\n\x05\x04U\x02\x01\x03\x12\x04\xa0\x06\"#\n\
    \x0c\n\x04\x04U\x02\x02\x12\x04\xa1\x06\x08#\n\r\n\x05\x04U\x02\x02\x04\
    \x12\x04\xa1\x06\x08\x10\n\r\n\x05\x04U\x02\x02\x05\x12\x04\xa1\x06\x11\
    \x15\n\r\n\x05\x04U\x02\x02\x01\x12\x04\xa1\x06\x16\x1e\n\r\n\x05\x04U\
    \x02\x02\x03\x12\x04\xa1\x06!\"\n\x0c\n\x04\x04U\x02\x03\x12\x04\xa2\x06\
    \x08&\n\r\n\x05\x04U\x02\x03\x04\x12\x04\xa2\x06\x08\x10\n\r\n\x05\x04U\
    \x02\x03\x05\x12\x04\xa2\x06\x11\x17\n\r\n\x05\x04U\x02\x03\x01\x12\x04\
    \xa2\x06\x18!\n\r\n\x05\x04U\x02\x03\x03\x12\x04\xa2\x06$%\n\x0c\n\x04\
    \x04U\x02\x04\x12\x04\xa3\x06\x08%\n\r\n\x05\x04U\x02\x04\x04\x12\x04\
    \xa3\x06\x08\x10\n\r\n\x05\x04U\x02\x04\x05\x12\x04\xa3\x06\x11\x17\n\r\
    \n\x05\x04U\x02\x04\x01\x12\x04\xa3\x06\x18\x20\n\r\n\x05\x04U\x02\x04\
    \x03\x12\x04\xa3\x06#$\n\x0c\n\x04\x04U\x02\x05\x12\x04\xa4\x06\x08&\n\r\
    \n\x05\x04U\x02\x05\x04\x12\x04\xa4\x06\x08\x10\n\r\n\x05\x04U\x02\x05\
    \x05\x12\x04\xa4\x06\x11\x16\n\r\n\x05\x04U\x02\x05\x01\x12\x04\xa4\x06\
    \x17!\n\r\n\x05\x04U\x02\x05\x03\x12\x04\xa4\x06$%\n\x0c\n\x04\x04U\x02\
    \x06\x12\x04\xa5\x06\x08$\n\r\n\x05\x04U\x02\x06\x04\x12\x04\xa5\x06\x08\
    \x10\n\r\n\x05\x04U\x02\x06\x05\x12\x04\xa5\x06\x11\x15\n\r\n\x05\x04U\
    \x02\x06\x01\x12\x04\xa5\x06\x16\x1f\n\r\n\x05\x04U\x02\x06\x03\x12\x04\
    \xa5\x06\"#\n\x0c\n\x04\x04U\x02\x07\x12\x04\xa6\x06\x08'\n\r\n\x05\x04U\
    \x02\x07\x04\x12\x04\xa6\x06\x08\x10\n\r\n\x05\x04U\x02\x07\x05\x12\x04\
    \xa6\x06\x11\x15\n\r\n\x05\x04U\x02\x07\x01\x12\x04\xa6\x06\x16\"\n\r\n\
    \x05\x04U\x02\x07\x03\x12\x04\xa6\x06%&\n\x0c\n\x02\x04V\x12\x06\xa9\x06\
    \0\xb3\x06\x01\n\x0b\n\x03\x04V\x01\x12\x04\xa9\x06\x08!\n\x0e\n\x04\x04\
    V\x03\0\x12\x06\xaa\x06\x08\xb0\x06\t\n\r\n\x05\x04V\x03\0\x01\x12\x04\
    \xaa\x06\x10\x14\n\x0e\n\x06\x04V\x03\0\x02\0\x12\x04\xab\x06\x109\n\x0f\
    \n\x07\x04V\x03\0\x02\0\x04\x12\x04\xab\x06\x10\x18\n\x0f\n\x07\x04V\x03\
    \0\x02\0\x05\x12\x04\xab\x06\x19\x1e\n\x0f\n\x07\x04V\x03\0\x02\0\x01\
    \x12\x04\xab\x06\x1f&\n\x0f\n\x07\x04V\x03\0\x02\0\x03\x12\x04\xab\x06)*\
    \n\x0f\n\x07\x04V\x03\0\x02\0\x08\x12\x04\xab\x06+8\n\x0f\n\x07\x04V\x03\
    \0\x02\0\x07\x12\x04\xab\x0667\n\x0e\n\x06\x04V\x03\0\x02\x01\x12\x04\
    \xac\x06\x10+\n\x0f\n\x07\x04V\x03\0\x02\x01\x04\x12\x04\xac\x06\x10\x18\
    \n\x0f\n\x07\x04V\x03\0\x02\x01\x05\x12\x04\xac\x06\x19\x1f\n\x0f\n\x07\
    \x04V\x03\0\x02\x01\x01\x12\x04\xac\x06\x20&\n\x0f\n\x07\x04V\x03\0\x02\
    \x01\x03\x12\x04\xac\x06)*\n\x0e\n\x06\x04V\x03\0\x02\x02\x12\x04\xad\
    \x06\x10,\n\x0f\n\x07\x04V\x03\0\x02\x02\x04\x12\x04\xad\x06\x10\x18\n\
    \x0f\n\x07\x04V\x03\0\x02\x02\x05\x12\x04\xad\x06\x19\x1e\n\x0f\n\x07\
    \x04V\x03\0\x02\x02\x01\x12\x04\xad\x06\x1f'\n\x0f\n\x07\x04V\x03\0\x02\
    \x02\x03\x12\x04\xad\x06*+\n\x0e\n\x06\x04V\x03\0\x02\x03\x12\x04\xae\
    \x06\x10-\n\x0f\n\x07\x04V\x03\0\x02\x03\x04\x12\x04\xae\x06\x10\x18\n\
    \x0f\n\x07\x04V\x03\0\x02\x03\x05\x12\x04\xae\x06\x19\x1f\n\x0f\n\x07\
    \x04V\x03\0\x02\x03\x01\x12\x04\xae\x06\x20(\n\x0f\n\x07\x04V\x03\0\x02\
    \x03\x03\x12\x04\xae\x06+,\n\x0e\n\x06\x04V\x03\0\x02\x04\x12\x04\xaf\
    \x06\x10.\n\x0f\n\x07\x04V\x03\0\x02\x04\x04\x12\x04\xaf\x06\x10\x18\n\
    \x0f\n\x07\x04V\x03\0\x02\x04\x05\x12\x04\xaf\x06\x19\x1f\n\x0f\n\x07\
    \x04V\x03\0\x02\x04\x01\x12\x04\xaf\x06\x20)\n\x0f\n\x07\x04V\x03\0\x02\
    \x04\x03\x12\x04\xaf\x06,-\n\x0c\n\x04\x04V\x02\0\x12\x04\xb2\x06\x08;\n\
    \r\n\x05\x04V\x02\0\x04\x12\x04\xb2\x06\x08\x10\n\r\n\x05\x04V\x02\0\x06\
    \x12\x04\xb2\x06\x110\n\r\n\x05\x04V\x02\0\x01\x12\x04\xb2\x0616\n\r\n\
    \x05\x04V\x02\0\x03\x12\x04\xb2\x069:\n\x0c\n\x02\x04W\x12\x06\xb5\x06\0\
    \xbd\x06\x01\n\x0b\n\x03\x04W\x01\x12\x04\xb5\x06\x08)\n\x0e\n\x04\x04W\
    \x03\0\x12\x06\xb6\x06\x08\xba\x06\t\n\r\n\x05\x04W\x03\0\x01\x12\x04\
    \xb6\x06\x10\x14\n\x0e\n\x06\x04W\x03\0\x02\0\x12\x04\xb7\x06\x109\n\x0f\
    \n\x07\x04W\x03\0\x02\0\x04\x12\x04\xb7\x06\x10\x18\n\x0f\n\x07\x04W\x03\
    \0\x02\0\x05\x12\x04\xb7\x06\x19\x1e\n\x0f\n\x07\x04W\x03\0\x02\0\x01\
    \x12\x04\xb7\x06\x1f&\n\x0f\n\x07\x04W\x03\0\x02\0\x03\x12\x04\xb7\x06)*\
    \n\x0f\n\x07\x04W\x03\0\x02\0\x08\x12\x04\xb7\x06+8\n\x0f\n\x07\x04W\x03\
    \0\x02\0\x07\x12\x04\xb7\x0667\n\x0e\n\x06\x04W\x03\0\x02\x01\x12\x04\
    \xb8\x06\x10+\n\x0f\n\x07\x04W\x03\0\x02\x01\x04\x12\x04\xb8\x06\x10\x18\
    \n\x0f\n\x07\x04W\x03\0\x02\x01\x05\x12\x04\xb8\x06\x19\x1f\n\x0f\n\x07\
    \x04W\x03\0\x02\x01\x01\x12\x04\xb8\x06\x20&\n\x0f\n\x07\x04W\x03\0\x02\
    \x01\x03\x12\x04\xb8\x06)*\n\x0e\n\x06\x04W\x03\0\x02\x02\x12\x04\xb9\
    \x06\x10,\n\x0f\n\x07\x04W\x03\0\x02\x02\x04\x12\x04\xb9\x06\x10\x18\n\
    \x0f\n\x07\x04W\x03\0\x02\x02\x05\x12\x04\xb9\x06\x19\x1e\n\x0f\n\x07\
    \x04W\x03\0\x02\x02\x01\x12\x04\xb9\x06\x1f'\n\x0f\n\x07\x04W\x03\0\x02\
    \x02\x03\x12\x04\xb9\x06*+\n\x0c\n\x04\x04W\x02\0\x12\x04\xbc\x06\x08C\n\
    \r\n\x05\x04W\x02\0\x04\x12\x04\xbc\x06\x08\x10\n\r\n\x05\x04W\x02\0\x06\
    \x12\x04\xbc\x06\x118\n\r\n\x05\x04W\x02\0\x01\x12\x04\xbc\x069>\n\r\n\
    \x05\x04W\x02\0\x03\x12\x04\xbc\x06AB\n\x0c\n\x02\x04X\x12\x06\xbf\x06\0\
    \xc3\x06\x01\n\x0b\n\x03\x04X\x01\x12\x04\xbf\x06\x08\x1e\n\x0c\n\x04\
    \x04X\x02\0\x12\x04\xc0\x06\x08$\n\r\n\x05\x04X\x02\0\x04\x12\x04\xc0\
    \x06\x08\x10\n\r\n\x05\x04X\x02\0\x05\x12\x04\xc0\x06\x11\x16\n\r\n\x05\
    \x04X\x02\0\x01\x12\x04\xc0\x06\x17\x1f\n\r\n\x05\x04X\x02\0\x03\x12\x04\
    \xc0\x06\"#\n\x0c\n\x04\x04X\x02\x01\x12\x04\xc1\x06\x08'\n\r\n\x05\x04X\
    \x02\x01\x04\x12\x04\xc1\x06\x08\x10\n\r\n\x05\x04X\x02\x01\x05\x12\x04\
    \xc1\x06\x11\x17\n\r\n\x05\x04X\x02\x01\x01\x12\x04\xc1\x06\x18\"\n\r\n\
    \x05\x04X\x02\x01\x03\x12\x04\xc1\x06%&\n\x0c\n\x04\x04X\x02\x02\x12\x04\
    \xc2\x06\x08\x20\n\r\n\x05\x04X\x02\x02\x04\x12\x04\xc2\x06\x08\x10\n\r\
    \n\x05\x04X\x02\x02\x05\x12\x04\xc2\x06\x11\x16\n\r\n\x05\x04X\x02\x02\
    \x01\x12\x04\xc2\x06\x17\x1b\n\r\n\x05\x04X\x02\x02\x03\x12\x04\xc2\x06\
    \x1e\x1f\n\x0c\n\x02\x04Y\x12\x06\xc5\x06\0\xc6\x06\x01\n\x0b\n\x03\x04Y\
    \x01\x12\x04\xc5\x06\x08&\n\x0c\n\x02\x04Z\x12\x06\xc8\x06\0\xcb\x06\x01\
    \n\x0b\n\x03\x04Z\x01\x12\x04\xc8\x06\x08'\n\x0c\n\x04\x04Z\x02\0\x12\
    \x04\xc9\x06\x081\n\r\n\x05\x04Z\x02\0\x04\x12\x04\xc9\x06\x08\x10\n\r\n\
    \x05\x04Z\x02\0\x05\x12\x04\xc9\x06\x11\x16\n\r\n\x05\x04Z\x02\0\x01\x12\
    \x04\xc9\x06\x17\x1e\n\r\n\x05\x04Z\x02\0\x03\x12\x04\xc9\x06!\"\n\r\n\
    \x05\x04Z\x02\0\x08\x12\x04\xc9\x06#0\n\r\n\x05\x04Z\x02\0\x07\x12\x04\
    \xc9\x06./\n\x0c\n\x04\x04Z\x02\x01\x12\x04\xca\x06\x08$\n\r\n\x05\x04Z\
    \x02\x01\x04\x12\x04\xca\x06\x08\x10\n\r\n\x05\x04Z\x02\x01\x05\x12\x04\
    \xca\x06\x11\x16\n\r\n\x05\x04Z\x02\x01\x01\x12\x04\xca\x06\x17\x1f\n\r\
    \n\x05\x04Z\x02\x01\x03\x12\x04\xca\x06\"#\n\x0c\n\x02\x04[\x12\x06\xcd\
    \x06\0\xd1\x06\x01\n\x0b\n\x03\x04[\x01\x12\x04\xcd\x06\x08&\n\x0c\n\x04\
    \x04[\x02\0\x12\x04\xce\x06\x08#\n\r\n\x05\x04[\x02\0\x04\x12\x04\xce\
    \x06\x08\x10\n\r\n\x05\x04[\x02\0\x05\x12\x04\xce\x06\x11\x17\n\r\n\x05\
    \x04[\x02\0\x01\x12\x04\xce\x06\x18\x1e\n\r\n\x05\x04[\x02\0\x03\x12\x04\
    \xce\x06!\"\n\x0c\n\x04\x04[\x02\x01\x12\x04\xcf\x06\x08&\n\r\n\x05\x04[\
    \x02\x01\x04\x12\x04\xcf\x06\x08\x10\n\r\n\x05\x04[\x02\x01\x05\x12\x04\
    \xcf\x06\x11\x17\n\r\n\x05\x04[\x02\x01\x01\x12\x04\xcf\x06\x18!\n\r\n\
    \x05\x04[\x02\x01\x03\x12\x04\xcf\x06$%\n\x0c\n\x04\x04[\x02\x02\x12\x04\
    \xd0\x06\x08-\n\r\n\x05\x04[\x02\x02\x04\x12\x04\xd0\x06\x08\x10\n\r\n\
    \x05\x04[\x02\x02\x05\x12\x04\xd0\x06\x11\x15\n\r\n\x05\x04[\x02\x02\x01\
    \x12\x04\xd0\x06\x16(\n\r\n\x05\x04[\x02\x02\x03\x12\x04\xd0\x06+,\n\x0c\
    \n\x02\x04\\\x12\x06\xd3\x06\0\xd6\x06\x01\n\x0b\n\x03\x04\\\x01\x12\x04\
    \xd3\x06\x08'\n\x0c\n\x04\x04\\\x02\0\x12\x04\xd4\x06\x081\n\r\n\x05\x04\
    \\\x02\0\x04\x12\x04\xd4\x06\x08\x10\n\r\n\x05\x04\\\x02\0\x05\x12\x04\
    \xd4\x06\x11\x16\n\r\n\x05\x04\\\x02\0\x01\x12\x04\xd4\x06\x17\x1e\n\r\n\
    \x05\x04\\\x02\0\x03\x12\x04\xd4\x06!\"\n\r\n\x05\x04\\\x02\0\x08\x12\
    \x04\xd4\x06#0\n\r\n\x05\x04\\\x02\0\x07\x12\x04\xd4\x06./\n\x0c\n\x04\
    \x04\\\x02\x01\x12\x04\xd5\x06\x08&\n\r\n\x05\x04\\\x02\x01\x04\x12\x04\
    \xd5\x06\x08\x10\n\r\n\x05\x04\\\x02\x01\x05\x12\x04\xd5\x06\x11\x17\n\r\
    \n\x05\x04\\\x02\x01\x01\x12\x04\xd5\x06\x18!\n\r\n\x05\x04\\\x02\x01\
    \x03\x12\x04\xd5\x06$%\n\x0c\n\x02\x04]\x12\x06\xd8\x06\0\xdb\x06\x01\n\
    \x0b\n\x03\x04]\x01\x12\x04\xd8\x06\x08&\n\x0c\n\x04\x04]\x02\0\x12\x04\
    \xd9\x06\x08*\n\r\n\x05\x04]\x02\0\x04\x12\x04\xd9\x06\x08\x10\n\r\n\x05\
    \x04]\x02\0\x05\x12\x04\xd9\x06\x11\x17\n\r\n\x05\x04]\x02\0\x01\x12\x04\
    \xd9\x06\x18%\n\r\n\x05\x04]\x02\0\x03\x12\x04\xd9\x06()\n\x0c\n\x04\x04\
    ]\x02\x01\x12\x04\xda\x06\x08-\n\r\n\x05\x04]\x02\x01\x04\x12\x04\xda\
    \x06\x08\x10\n\r\n\x05\x04]\x02\x01\x05\x12\x04\xda\x06\x11\x15\n\r\n\
    \x05\x04]\x02\x01\x01\x12\x04\xda\x06\x16(\n\r\n\x05\x04]\x02\x01\x03\
    \x12\x04\xda\x06+,\n\x0c\n\x02\x04^\x12\x06\xdd\x06\0\xee\x06\x01\n\x0b\
    \n\x03\x04^\x01\x12\x04\xdd\x06\x08.\n\x0b\n\x03\x04^\x07\x12\x04\xde\
    \x06\x08(\n\x0e\n\x06\x04^\x07\xd0\x86\x03\x12\x04\xde\x06\x08(\n\x0b\n\
    \x03\x04^\x07\x12\x04\xdf\x06\x08)\n\x0e\n\x06\x04^\x07\xd1\x86\x03\x12\
    \x04\xdf\x06\x08)\n\x0e\n\x04\x04^\x03\0\x12\x06\xe1\x06\x08\xea\x06\t\n\
    \r\n\x05\x04^\x03\0\x01\x12\x04\xe1\x06\x10\x14\n\x0e\n\x06\x04^\x03\0\
    \x02\0\x12\x04\xe2\x06\x10+\n\x0f\n\x07\x04^\x03\0\x02\0\x04\x12\x04\xe2\
    \x06\x10\x18\n\x0f\n\x07\x04^\x03\0\x02\0\x05\x12\x04\xe2\x06\x19\x1f\n\
    \x0f\n\x07\x04^\x03\0\x02\0\x01\x12\x04\xe2\x06\x20&\n\x0f\n\x07\x04^\
    \x03\0\x02\0\x03\x12\x04\xe2\x06)*\n\x0e\n\x06\x04^\x03\0\x02\x01\x12\
    \x04\xe3\x06\x10.\n\x0f\n\x07\x04^\x03\0\x02\x01\x04\x12\x04\xe3\x06\x10\
    \x18\n\x0f\n\x07\x04^\x03\0\x02\x01\x05\x12\x04\xe3\x06\x19\x1f\n\x0f\n\
    \x07\x04^\x03\0\x02\x01\x01\x12\x04\xe3\x06\x20)\n\x0f\n\x07\x04^\x03\0\
    \x02\x01\x03\x12\x04\xe3\x06,-\n\x0e\n\x06\x04^\x03\0\x02\x02\x12\x04\
    \xe4\x06\x10,\n\x0f\n\x07\x04^\x03\0\x02\x02\x04\x12\x04\xe4\x06\x10\x18\
    \n\x0f\n\x07\x04^\x03\0\x02\x02\x05\x12\x04\xe4\x06\x19\x1e\n\x0f\n\x07\
    \x04^\x03\0\x02\x02\x01\x12\x04\xe4\x06\x1f'\n\x0f\n\x07\x04^\x03\0\x02\
    \x02\x03\x12\x04\xe4\x06*+\n\x0e\n\x06\x04^\x03\0\x02\x03\x12\x04\xe5\
    \x06\x10/\n\x0f\n\x07\x04^\x03\0\x02\x03\x04\x12\x04\xe5\x06\x10\x18\n\
    \x0f\n\x07\x04^\x03\0\x02\x03\x05\x12\x04\xe5\x06\x19\x1f\n\x0f\n\x07\
    \x04^\x03\0\x02\x03\x01\x12\x04\xe5\x06\x20*\n\x0f\n\x07\x04^\x03\0\x02\
    \x03\x03\x12\x04\xe5\x06-.\n\x0e\n\x06\x04^\x03\0\x02\x04\x12\x04\xe6\
    \x06\x102\n\x0f\n\x07\x04^\x03\0\x02\x04\x04\x12\x04\xe6\x06\x10\x18\n\
    \x0f\n\x07\x04^\x03\0\x02\x04\x05\x12\x04\xe6\x06\x19\x1f\n\x0f\n\x07\
    \x04^\x03\0\x02\x04\x01\x12\x04\xe6\x06\x20-\n\x0f\n\x07\x04^\x03\0\x02\
    \x04\x03\x12\x04\xe6\x0601\n\x0e\n\x06\x04^\x03\0\x02\x05\x12\x04\xe7\
    \x06\x105\n\x0f\n\x07\x04^\x03\0\x02\x05\x04\x12\x04\xe7\x06\x10\x18\n\
    \x0f\n\x07\x04^\x03\0\x02\x05\x05\x12\x04\xe7\x06\x19\x1d\n\x0f\n\x07\
    \x04^\x03\0\x02\x05\x01\x12\x04\xe7\x06\x1e0\n\x0f\n\x07\x04^\x03\0\x02\
    \x05\x03\x12\x04\xe7\x0634\n\x0e\n\x06\x04^\x03\0\x02\x06\x12\x04\xe8\
    \x06\x106\n\x0f\n\x07\x04^\x03\0\x02\x06\x04\x12\x04\xe8\x06\x10\x18\n\
    \x0f\n\x07\x04^\x03\0\x02\x06\x05\x12\x04\xe8\x06\x19\x1f\n\x0f\n\x07\
    \x04^\x03\0\x02\x06\x01\x12\x04\xe8\x06\x201\n\x0f\n\x07\x04^\x03\0\x02\
    \x06\x03\x12\x04\xe8\x0645\n\x0e\n\x06\x04^\x03\0\x02\x07\x12\x04\xe9\
    \x06\x106\n\x0f\n\x07\x04^\x03\0\x02\x07\x04\x12\x04\xe9\x06\x10\x18\n\
    \x0f\n\x07\x04^\x03\0\x02\x07\x05\x12\x04\xe9\x06\x19\x1f\n\x0f\n\x07\
    \x04^\x03\0\x02\x07\x01\x12\x04\xe9\x06\x201\n\x0f\n\x07\x04^\x03\0\x02\
    \x07\x03\x12\x04\xe9\x0645\n\x0c\n\x04\x04^\x02\0\x12\x04\xec\x06\x08H\n\
    \r\n\x05\x04^\x02\0\x04\x12\x04\xec\x06\x08\x10\n\r\n\x05\x04^\x02\0\x06\
    \x12\x04\xec\x06\x11=\n\r\n\x05\x04^\x02\0\x01\x12\x04\xec\x06>C\n\r\n\
    \x05\x04^\x02\0\x03\x12\x04\xec\x06FG\n\x0c\n\x04\x04^\x02\x01\x12\x04\
    \xed\x06\x08*\n\r\n\x05\x04^\x02\x01\x04\x12\x04\xed\x06\x08\x10\n\r\n\
    \x05\x04^\x02\x01\x05\x12\x04\xed\x06\x11\x17\n\r\n\x05\x04^\x02\x01\x01\
    \x12\x04\xed\x06\x18%\n\r\n\x05\x04^\x02\x01\x03\x12\x04\xed\x06()\n\x0c\
    \n\x02\x04_\x12\x06\xf0\x06\0\xf4\x06\x01\n\x0b\n\x03\x04_\x01\x12\x04\
    \xf0\x06\x08$\n\x0c\n\x04\x04_\x02\0\x12\x04\xf1\x06\x08#\n\r\n\x05\x04_\
    \x02\0\x04\x12\x04\xf1\x06\x08\x10\n\r\n\x05\x04_\x02\0\x05\x12\x04\xf1\
    \x06\x11\x17\n\r\n\x05\x04_\x02\0\x01\x12\x04\xf1\x06\x18\x1e\n\r\n\x05\
    \x04_\x02\0\x03\x12\x04\xf1\x06!\"\n\x0c\n\x04\x04_\x02\x01\x12\x04\xf2\
    \x06\x08&\n\r\n\x05\x04_\x02\x01\x04\x12\x04\xf2\x06\x08\x10\n\r\n\x05\
    \x04_\x02\x01\x05\x12\x04\xf2\x06\x11\x17\n\r\n\x05\x04_\x02\x01\x01\x12\
    \x04\xf2\x06\x18!\n\r\n\x05\x04_\x02\x01\x03\x12\x04\xf2\x06$%\n\x0c\n\
    \x04\x04_\x02\x02\x12\x04\xf3\x06\x08*\n\r\n\x05\x04_\x02\x02\x04\x12\
    \x04\xf3\x06\x08\x10\n\r\n\x05\x04_\x02\x02\x05\x12\x04\xf3\x06\x11\x15\
    \n\r\n\x05\x04_\x02\x02\x01\x12\x04\xf3\x06\x16%\n\r\n\x05\x04_\x02\x02\
    \x03\x12\x04\xf3\x06()\n\x0c\n\x02\x04`\x12\x06\xf6\x06\0\x84\x07\x01\n\
    \x0b\n\x03\x04`\x01\x12\x04\xf6\x06\x08%\n\x0c\n\x04\x04`\x02\0\x12\x04\
    \xf7\x06\x081\n\r\n\x05\x04`\x02\0\x04\x12\x04\xf7\x06\x08\x10\n\r\n\x05\
    \x04`\x02\0\x05\x12\x04\xf7\x06\x11\x16\n\r\n\x05\x04`\x02\0\x01\x12\x04\
    \xf7\x06\x17\x1e\n\r\n\x05\x04`\x02\0\x03\x12\x04\xf7\x06!\"\n\r\n\x05\
    \x04`\x02\0\x08\x12\x04\xf7\x06#0\n\r\n\x05\x04`\x02\0\x07\x12\x04\xf7\
    \x06./\n\x0c\n\x04\x04`\x02\x01\x12\x04\xf8\x06\x08#\n\r\n\x05\x04`\x02\
    \x01\x04\x12\x04\xf8\x06\x08\x10\n\r\n\x05\x04`\x02\x01\x05\x12\x04\xf8\
    \x06\x11\x17\n\r\n\x05\x04`\x02\x01\x01\x12\x04\xf8\x06\x18\x1e\n\r\n\
    \x05\x04`\x02\x01\x03\x12\x04\xf8\x06!\"\n\x0c\n\x04\x04`\x02\x02\x12\
    \x04\xf9\x06\x08&\n\r\n\x05\x04`\x02\x02\x04\x12\x04\xf9\x06\x08\x10\n\r\
    \n\x05\x04`\x02\x02\x05\x12\x04\xf9\x06\x11\x17\n\r\n\x05\x04`\x02\x02\
    \x01\x12\x04\xf9\x06\x18!\n\r\n\x05\x04`\x02\x02\x03\x12\x04\xf9\x06$%\n\
    \x0c\n\x04\x04`\x02\x03\x12\x04\xfa\x06\x08*\n\r\n\x05\x04`\x02\x03\x04\
    \x12\x04\xfa\x06\x08\x10\n\r\n\x05\x04`\x02\x03\x05\x12\x04\xfa\x06\x11\
    \x17\n\r\n\x05\x04`\x02\x03\x01\x12\x04\xfa\x06\x18%\n\r\n\x05\x04`\x02\
    \x03\x03\x12\x04\xfa\x06()\n\x0c\n\x04\x04`\x02\x04\x12\x04\xfb\x06\x08$\
    \n\r\n\x05\x04`\x02\x04\x04\x12\x04\xfb\x06\x08\x10\n\r\n\x05\x04`\x02\
    \x04\x05\x12\x04\xfb\x06\x11\x16\n\r\n\x05\x04`\x02\x04\x01\x12\x04\xfb\
    \x06\x17\x1f\n\r\n\x05\x04`\x02\x04\x03\x12\x04\xfb\x06\"#\n\x0c\n\x04\
    \x04`\x02\x05\x12\x04\xfc\x06\x08'\n\r\n\x05\x04`\x02\x05\x04\x12\x04\
    \xfc\x06\x08\x10\n\r\n\x05\x04`\x02\x05\x05\x12\x04\xfc\x06\x11\x17\n\r\
    \n\x05\x04`\x02\x05\x01\x12\x04\xfc\x06\x18\"\n\r\n\x05\x04`\x02\x05\x03\
    \x12\x04\xfc\x06%&\n\x0c\n\x04\x04`\x02\x06\x12\x04\xfd\x06\x08-\n\r\n\
    \x05\x04`\x02\x06\x04\x12\x04\xfd\x06\x08\x10\n\r\n\x05\x04`\x02\x06\x05\
    \x12\x04\xfd\x06\x11\x15\n\r\n\x05\x04`\x02\x06\x01\x12\x04\xfd\x06\x16(\
    \n\r\n\x05\x04`\x02\x06\x03\x12\x04\xfd\x06+,\n\x0c\n\x04\x04`\x02\x07\
    \x12\x04\xfe\x06\x08#\n\r\n\x05\x04`\x02\x07\x04\x12\x04\xfe\x06\x08\x10\
    \n\r\n\x05\x04`\x02\x07\x05\x12\x04\xfe\x06\x11\x15\n\r\n\x05\x04`\x02\
    \x07\x01\x12\x04\xfe\x06\x16\x1e\n\r\n\x05\x04`\x02\x07\x03\x12\x04\xfe\
    \x06!\"\n\x0c\n\x04\x04`\x02\x08\x12\x04\xff\x06\x08&\n\r\n\x05\x04`\x02\
    \x08\x04\x12\x04\xff\x06\x08\x10\n\r\n\x05\x04`\x02\x08\x05\x12\x04\xff\
    \x06\x11\x17\n\r\n\x05\x04`\x02\x08\x01\x12\x04\xff\x06\x18!\n\r\n\x05\
    \x04`\x02\x08\x03\x12\x04\xff\x06$%\n\x0c\n\x04\x04`\x02\t\x12\x04\x80\
    \x07\x08&\n\r\n\x05\x04`\x02\t\x04\x12\x04\x80\x07\x08\x10\n\r\n\x05\x04\
    `\x02\t\x05\x12\x04\x80\x07\x11\x17\n\r\n\x05\x04`\x02\t\x01\x12\x04\x80\
    \x07\x18\x20\n\r\n\x05\x04`\x02\t\x03\x12\x04\x80\x07#%\n\x0c\n\x04\x04`\
    \x02\n\x12\x04\x81\x07\x08'\n\r\n\x05\x04`\x02\n\x04\x12\x04\x81\x07\x08\
    \x10\n\r\n\x05\x04`\x02\n\x05\x12\x04\x81\x07\x11\x16\n\r\n\x05\x04`\x02\
    \n\x01\x12\x04\x81\x07\x17!\n\r\n\x05\x04`\x02\n\x03\x12\x04\x81\x07$&\n\
    \x0c\n\x04\x04`\x02\x0b\x12\x04\x82\x07\x08%\n\r\n\x05\x04`\x02\x0b\x04\
    \x12\x04\x82\x07\x08\x10\n\r\n\x05\x04`\x02\x0b\x05\x12\x04\x82\x07\x11\
    \x15\n\r\n\x05\x04`\x02\x0b\x01\x12\x04\x82\x07\x16\x1f\n\r\n\x05\x04`\
    \x02\x0b\x03\x12\x04\x82\x07\"$\n\x0c\n\x04\x04`\x02\x0c\x12\x04\x83\x07\
    \x08%\n\r\n\x05\x04`\x02\x0c\x04\x12\x04\x83\x07\x08\x10\n\r\n\x05\x04`\
    \x02\x0c\x05\x12\x04\x83\x07\x11\x15\n\r\n\x05\x04`\x02\x0c\x01\x12\x04\
    \x83\x07\x16\x1f\n\r\n\x05\x04`\x02\x0c\x03\x12\x04\x83\x07\"$\n\x0c\n\
    \x02\x04a\x12\x06\x86\x07\0\x8a\x07\x01\n\x0b\n\x03\x04a\x01\x12\x04\x86\
    \x07\x08!\n\x0c\n\x04\x04a\x02\0\x12\x04\x87\x07\x08-\n\r\n\x05\x04a\x02\
    \0\x04\x12\x04\x87\x07\x08\x10\n\r\n\x05\x04a\x02\0\x05\x12\x04\x87\x07\
    \x11\x17\n\r\n\x05\x04a\x02\0\x01\x12\x04\x87\x07\x18(\n\r\n\x05\x04a\
    \x02\0\x03\x12\x04\x87\x07+,\n\x0c\n\x04\x04a\x02\x01\x12\x04\x88\x07\
    \x08-\n\r\n\x05\x04a\x02\x01\x04\x12\x04\x88\x07\x08\x10\n\r\n\x05\x04a\
    \x02\x01\x05\x12\x04\x88\x07\x11\x17\n\r\n\x05\x04a\x02\x01\x01\x12\x04\
    \x88\x07\x18(\n\r\n\x05\x04a\x02\x01\x03\x12\x04\x88\x07+,\n\x0c\n\x04\
    \x04a\x02\x02\x12\x04\x89\x07\x08!\n\r\n\x05\x04a\x02\x02\x04\x12\x04\
    \x89\x07\x08\x10\n\r\n\x05\x04a\x02\x02\x05\x12\x04\x89\x07\x11\x17\n\r\
    \n\x05\x04a\x02\x02\x01\x12\x04\x89\x07\x18\x1c\n\r\n\x05\x04a\x02\x02\
    \x03\x12\x04\x89\x07\x1f\x20\n\x0c\n\x02\x04b\x12\x06\x8c\x07\0\x8e\x07\
    \x01\n\x0b\n\x03\x04b\x01\x12\x04\x8c\x07\x08\"\n\x0c\n\x04\x04b\x02\0\
    \x12\x04\x8d\x07\x081\n\r\n\x05\x04b\x02\0\x04\x12\x04\x8d\x07\x08\x10\n\
    \r\n\x05\x04b\x02\0\x05\x12\x04\x8d\x07\x11\x16\n\r\n\x05\x04b\x02\0\x01\
    \x12\x04\x8d\x07\x17\x1e\n\r\n\x05\x04b\x02\0\x03\x12\x04\x8d\x07!\"\n\r\
    \n\x05\x04b\x02\0\x08\x12\x04\x8d\x07#0\n\r\n\x05\x04b\x02\0\x07\x12\x04\
    \x8d\x07./\n\x0c\n\x02\x04c\x12\x06\x90\x07\0\x93\x07\x01\n\x0b\n\x03\
    \x04c\x01\x12\x04\x90\x07\x08+\n\x0c\n\x04\x04c\x02\0\x12\x04\x91\x07\
    \x08#\n\r\n\x05\x04c\x02\0\x04\x12\x04\x91\x07\x08\x10\n\r\n\x05\x04c\
    \x02\0\x05\x12\x04\x91\x07\x11\x17\n\r\n\x05\x04c\x02\0\x01\x12\x04\x91\
    \x07\x18\x1e\n\r\n\x05\x04c\x02\0\x03\x12\x04\x91\x07!\"\n\x0c\n\x04\x04\
    c\x02\x01\x12\x04\x92\x07\x08$\n\r\n\x05\x04c\x02\x01\x04\x12\x04\x92\
    \x07\x08\x10\n\r\n\x05\x04c\x02\x01\x05\x12\x04\x92\x07\x11\x16\n\r\n\
    \x05\x04c\x02\x01\x01\x12\x04\x92\x07\x17\x1f\n\r\n\x05\x04c\x02\x01\x03\
    \x12\x04\x92\x07\"#\n\x0c\n\x02\x04d\x12\x06\x95\x07\0\x99\x07\x01\n\x0b\
    \n\x03\x04d\x01\x12\x04\x95\x07\x083\n\x0c\n\x04\x04d\x02\0\x12\x04\x96\
    \x07\x08#\n\r\n\x05\x04d\x02\0\x04\x12\x04\x96\x07\x08\x10\n\r\n\x05\x04\
    d\x02\0\x05\x12\x04\x96\x07\x11\x17\n\r\n\x05\x04d\x02\0\x01\x12\x04\x96\
    \x07\x18\x1e\n\r\n\x05\x04d\x02\0\x03\x12\x04\x96\x07!\"\n\x0c\n\x04\x04\
    d\x02\x01\x12\x04\x97\x07\x081\n\r\n\x05\x04d\x02\x01\x04\x12\x04\x97\
    \x07\x08\x10\n\r\n\x05\x04d\x02\x01\x05\x12\x04\x97\x07\x11\x16\n\r\n\
    \x05\x04d\x02\x01\x01\x12\x04\x97\x07\x17\x1e\n\r\n\x05\x04d\x02\x01\x03\
    \x12\x04\x97\x07!\"\n\r\n\x05\x04d\x02\x01\x08\x12\x04\x97\x07#0\n\r\n\
    \x05\x04d\x02\x01\x07\x12\x04\x97\x07./\n\x0c\n\x04\x04d\x02\x02\x12\x04\
    \x98\x07\x08>\n\r\n\x05\x04d\x02\x02\x04\x12\x04\x98\x07\x08\x10\n\r\n\
    \x05\x04d\x02\x02\x06\x12\x04\x98\x07\x11$\n\r\n\x05\x04d\x02\x02\x01\
    \x12\x04\x98\x07%9\n\r\n\x05\x04d\x02\x02\x03\x12\x04\x98\x07<=\n\x0c\n\
    \x02\x04e\x12\x06\x9b\x07\0\xa2\x07\x01\n\x0b\n\x03\x04e\x01\x12\x04\x9b\
    \x07\x08\"\n\x0c\n\x04\x04e\x02\0\x12\x04\x9c\x07\x08%\n\r\n\x05\x04e\
    \x02\0\x04\x12\x04\x9c\x07\x08\x10\n\r\n\x05\x04e\x02\0\x05\x12\x04\x9c\
    \x07\x11\x15\n\r\n\x05\x04e\x02\0\x01\x12\x04\x9c\x07\x16\x20\n\r\n\x05\
    \x04e\x02\0\x03\x12\x04\x9c\x07#$\n\x0c\n\x04\x04e\x02\x01\x12\x04\x9d\
    \x07\x08#\n\r\n\x05\x04e\x02\x01\x04\x12\x04\x9d\x07\x08\x10\n\r\n\x05\
    \x04e\x02\x01\x05\x12\x04\x9d\x07\x11\x16\n\r\n\x05\x04e\x02\x01\x01\x12\
    \x04\x9d\x07\x17\x1e\n\r\n\x05\x04e\x02\x01\x03\x12\x04\x9d\x07!\"\n\x0c\
    \n\x04\x04e\x02\x02\x12\x04\x9e\x07\x08$\n\r\n\x05\x04e\x02\x02\x04\x12\
    \x04\x9e\x07\x08\x10\n\r\n\x05\x04e\x02\x02\x05\x12\x04\x9e\x07\x11\x16\
    \n\r\n\x05\x04e\x02\x02\x01\x12\x04\x9e\x07\x17\x1f\n\r\n\x05\x04e\x02\
    \x02\x03\x12\x04\x9e\x07\"#\n\x0c\n\x04\x04e\x02\x03\x12\x04\x9f\x07\x08\
    +\n\r\n\x05\x04e\x02\x03\x04\x12\x04\x9f\x07\x08\x10\n\r\n\x05\x04e\x02\
    \x03\x05\x12\x04\x9f\x07\x11\x16\n\r\n\x05\x04e\x02\x03\x01\x12\x04\x9f\
    \x07\x17&\n\r\n\x05\x04e\x02\x03\x03\x12\x04\x9f\x07)*\n\x0c\n\x04\x04e\
    \x02\x04\x12\x04\xa0\x07\x08I\n\r\n\x05\x04e\x02\x04\x04\x12\x04\xa0\x07\
    \x08\x10\n\r\n\x05\x04e\x02\x04\x05\x12\x04\xa0\x07\x11\x16\n\r\n\x05\
    \x04e\x02\x04\x01\x12\x04\xa0\x07\x17\x20\n\r\n\x05\x04e\x02\x04\x03\x12\
    \x04\xa0\x07#$\n\r\n\x05\x04e\x02\x04\x08\x12\x04\xa0\x07%H\n\x10\n\x08\
    \x04e\x02\x04\x08\xe4\x86\x03\x12\x04\xa0\x07&G\n\x0c\n\x04\x04e\x02\x05\
    \x12\x04\xa1\x07\x08Q\n\r\n\x05\x04e\x02\x05\x04\x12\x04\xa1\x07\x08\x10\
    \n\r\n\x05\x04e\x02\x05\x05\x12\x04\xa1\x07\x11\x16\n\r\n\x05\x04e\x02\
    \x05\x01\x12\x04\xa1\x07\x17(\n\r\n\x05\x04e\x02\x05\x03\x12\x04\xa1\x07\
    +,\n\r\n\x05\x04e\x02\x05\x08\x12\x04\xa1\x07-P\n\x10\n\x08\x04e\x02\x05\
    \x08\xe4\x86\x03\x12\x04\xa1\x07.O\n\x0c\n\x02\x04f\x12\x06\xa4\x07\0\
    \xa7\x07\x01\n\x0b\n\x03\x04f\x01\x12\x04\xa4\x07\x08\x1f\n\x0c\n\x04\
    \x04f\x02\0\x12\x04\xa5\x07\x08.\n\r\n\x05\x04f\x02\0\x04\x12\x04\xa5\
    \x07\x08\x10\n\r\n\x05\x04f\x02\0\x05\x12\x04\xa5\x07\x11\x17\n\r\n\x05\
    \x04f\x02\0\x01\x12\x04\xa5\x07\x18)\n\r\n\x05\x04f\x02\0\x03\x12\x04\
    \xa5\x07,-\n\x0c\n\x04\x04f\x02\x01\x12\x04\xa6\x07\x08*\n\r\n\x05\x04f\
    \x02\x01\x04\x12\x04\xa6\x07\x08\x10\n\r\n\x05\x04f\x02\x01\x05\x12\x04\
    \xa6\x07\x11\x15\n\r\n\x05\x04f\x02\x01\x01\x12\x04\xa6\x07\x16%\n\r\n\
    \x05\x04f\x02\x01\x03\x12\x04\xa6\x07()\n\x0c\n\x02\x04g\x12\x06\xa9\x07\
    \0\xad\x07\x01\n\x0b\n\x03\x04g\x01\x12\x04\xa9\x07\x08\x20\n\x0c\n\x04\
    \x04g\x02\0\x12\x04\xaa\x07\x082\n\r\n\x05\x04g\x02\0\x04\x12\x04\xaa\
    \x07\x08\x10\n\r\n\x05\x04g\x02\0\x05\x12\x04\xaa\x07\x11\x17\n\r\n\x05\
    \x04g\x02\0\x01\x12\x04\xaa\x07\x18-\n\r\n\x05\x04g\x02\0\x03\x12\x04\
    \xaa\x0701\n\x0c\n\x04\x04g\x02\x01\x12\x04\xab\x07\x08,\n\r\n\x05\x04g\
    \x02\x01\x04\x12\x04\xab\x07\x08\x10\n\r\n\x05\x04g\x02\x01\x05\x12\x04\
    \xab\x07\x11\x15\n\r\n\x05\x04g\x02\x01\x01\x12\x04\xab\x07\x16'\n\r\n\
    \x05\x04g\x02\x01\x03\x12\x04\xab\x07*+\n\x0c\n\x04\x04g\x02\x02\x12\x04\
    \xac\x07\x08#\n\r\n\x05\x04g\x02\x02\x04\x12\x04\xac\x07\x08\x10\n\r\n\
    \x05\x04g\x02\x02\x05\x12\x04\xac\x07\x11\x17\n\r\n\x05\x04g\x02\x02\x01\
    \x12\x04\xac\x07\x18\x1e\n\r\n\x05\x04g\x02\x02\x03\x12\x04\xac\x07!\"\n\
    \x0c\n\x02\x04h\x12\x06\xaf\x07\0\xb8\x07\x01\n\x0b\n\x03\x04h\x01\x12\
    \x04\xaf\x07\x08\x20\n\x0e\n\x04\x04h\x03\0\x12\x06\xb0\x07\x08\xb4\x07\
    \t\n\r\n\x05\x04h\x03\0\x01\x12\x04\xb0\x07\x10\x13\n\x0e\n\x06\x04h\x03\
    \0\x02\0\x12\x04\xb1\x07\x10+\n\x0f\n\x07\x04h\x03\0\x02\0\x04\x12\x04\
    \xb1\x07\x10\x18\n\x0f\n\x07\x04h\x03\0\x02\0\x05\x12\x04\xb1\x07\x19\
    \x1f\n\x0f\n\x07\x04h\x03\0\x02\0\x01\x12\x04\xb1\x07\x20&\n\x0f\n\x07\
    \x04h\x03\0\x02\0\x03\x12\x04\xb1\x07)*\n\x0e\n\x06\x04h\x03\0\x02\x01\
    \x12\x04\xb2\x07\x102\n\x0f\n\x07\x04h\x03\0\x02\x01\x04\x12\x04\xb2\x07\
    \x10\x18\n\x0f\n\x07\x04h\x03\0\x02\x01\x05\x12\x04\xb2\x07\x19\x1f\n\
    \x0f\n\x07\x04h\x03\0\x02\x01\x01\x12\x04\xb2\x07\x20-\n\x0f\n\x07\x04h\
    \x03\0\x02\x01\x03\x12\x04\xb2\x0701\n\x0e\n\x06\x04h\x03\0\x02\x02\x12\
    \x04\xb3\x07\x100\n\x0f\n\x07\x04h\x03\0\x02\x02\x04\x12\x04\xb3\x07\x10\
    \x18\n\x0f\n\x07\x04h\x03\0\x02\x02\x05\x12\x04\xb3\x07\x19\x1f\n\x0f\n\
    \x07\x04h\x03\0\x02\x02\x01\x12\x04\xb3\x07\x20+\n\x0f\n\x07\x04h\x03\0\
    \x02\x02\x03\x12\x04\xb3\x07./\n\x0c\n\x04\x04h\x02\0\x12\x04\xb6\x07\
    \x088\n\r\n\x05\x04h\x02\0\x04\x12\x04\xb6\x07\x08\x10\n\r\n\x05\x04h\
    \x02\0\x06\x12\x04\xb6\x07\x11.\n\r\n\x05\x04h\x02\0\x01\x12\x04\xb6\x07\
    /3\n\r\n\x05\x04h\x02\0\x03\x12\x04\xb6\x0767\n\x0c\n\x04\x04h\x02\x01\
    \x12\x04\xb7\x07\x08=\n\r\n\x05\x04h\x02\x01\x04\x12\x04\xb7\x07\x08\x10\
    \n\r\n\x05\x04h\x02\x01\x05\x12\x04\xb7\x07\x11\x15\n\r\n\x05\x04h\x02\
    \x01\x01\x12\x04\xb7\x07\x16&\n\r\n\x05\x04h\x02\x01\x03\x12\x04\xb7\x07\
    )*\n\r\n\x05\x04h\x02\x01\x08\x12\x04\xb7\x07+<\n\r\n\x05\x04h\x02\x01\
    \x07\x12\x04\xb7\x076;\n\x0c\n\x02\x04i\x12\x06\xba\x07\0\xcb\x07\x01\n\
    \x0b\n\x03\x04i\x01\x12\x04\xba\x07\x08!\n\x0b\n\x03\x04i\x07\x12\x04\
    \xbb\x07\x08(\n\x0e\n\x06\x04i\x07\xd1\x86\x03\x12\x04\xbb\x07\x08(\n\
    \x0e\n\x04\x04i\x03\0\x12\x06\xbd\x07\x08\xc6\x07\t\n\r\n\x05\x04i\x03\0\
    \x01\x12\x04\xbd\x07\x10\x13\n\x10\n\x06\x04i\x03\0\x03\0\x12\x06\xbe\
    \x07\x10\xc1\x07\x11\n\x0f\n\x07\x04i\x03\0\x03\0\x01\x12\x04\xbe\x07\
    \x18\x1f\n\x10\n\x08\x04i\x03\0\x03\0\x02\0\x12\x04\xbf\x07\x187\n\x11\n\
    \t\x04i\x03\0\x03\0\x02\0\x04\x12\x04\xbf\x07\x18\x20\n\x11\n\t\x04i\x03\
    \0\x03\0\x02\0\x05\x12\x04\xbf\x07!'\n\x11\n\t\x04i\x03\0\x03\0\x02\0\
    \x01\x12\x04\xbf\x07(2\n\x11\n\t\x04i\x03\0\x03\0\x02\0\x03\x12\x04\xbf\
    \x0756\n\x10\n\x08\x04i\x03\0\x03\0\x02\x01\x12\x04\xc0\x07\x186\n\x11\n\
    \t\x04i\x03\0\x03\0\x02\x01\x04\x12\x04\xc0\x07\x18\x20\n\x11\n\t\x04i\
    \x03\0\x03\0\x02\x01\x05\x12\x04\xc0\x07!&\n\x11\n\t\x04i\x03\0\x03\0\
    \x02\x01\x01\x12\x04\xc0\x07'1\n\x11\n\t\x04i\x03\0\x03\0\x02\x01\x03\
    \x12\x04\xc0\x0745\n\x0e\n\x06\x04i\x03\0\x02\0\x12\x04\xc3\x07\x10+\n\
    \x0f\n\x07\x04i\x03\0\x02\0\x04\x12\x04\xc3\x07\x10\x18\n\x0f\n\x07\x04i\
    \x03\0\x02\0\x05\x12\x04\xc3\x07\x19\x1f\n\x0f\n\x07\x04i\x03\0\x02\0\
    \x01\x12\x04\xc3\x07\x20&\n\x0f\n\x07\x04i\x03\0\x02\0\x03\x12\x04\xc3\
    \x07)*\n\x0e\n\x06\x04i\x03\0\x02\x01\x12\x04\xc4\x07\x102\n\x0f\n\x07\
    \x04i\x03\0\x02\x01\x04\x12\x04\xc4\x07\x10\x18\n\x0f\n\x07\x04i\x03\0\
    \x02\x01\x05\x12\x04\xc4\x07\x19\x1f\n\x0f\n\x07\x04i\x03\0\x02\x01\x01\
    \x12\x04\xc4\x07\x20-\n\x0f\n\x07\x04i\x03\0\x02\x01\x03\x12\x04\xc4\x07\
    01\n\x0e\n\x06\x04i\x03\0\x02\x02\x12\x04\xc5\x07\x10M\n\x0f\n\x07\x04i\
    \x03\0\x02\x02\x04\x12\x04\xc5\x07\x10\x18\n\x0f\n\x07\x04i\x03\0\x02\
    \x02\x06\x12\x04\xc5\x07\x19?\n\x0f\n\x07\x04i\x03\0\x02\x02\x01\x12\x04\
    \xc5\x07@H\n\x0f\n\x07\x04i\x03\0\x02\x02\x03\x12\x04\xc5\x07KL\n\x0c\n\
    \x04\x04i\x02\0\x12\x04\xc8\x07\x089\n\r\n\x05\x04i\x02\0\x04\x12\x04\
    \xc8\x07\x08\x10\n\r\n\x05\x04i\x02\0\x06\x12\x04\xc8\x07\x11/\n\r\n\x05\
    \x04i\x02\0\x01\x12\x04\xc8\x0704\n\r\n\x05\x04i\x02\0\x03\x12\x04\xc8\
    \x0778\n\x0c\n\x04\x04i\x02\x01\x12\x04\xc9\x07\x08)\n\r\n\x05\x04i\x02\
    \x01\x04\x12\x04\xc9\x07\x08\x10\n\r\n\x05\x04i\x02\x01\x05\x12\x04\xc9\
    \x07\x11\x17\n\r\n\x05\x04i\x02\x01\x01\x12\x04\xc9\x07\x18$\n\r\n\x05\
    \x04i\x02\x01\x03\x12\x04\xc9\x07'(\n\x0c\n\x04\x04i\x02\x02\x12\x04\xca\
    \x07\x08)\n\r\n\x05\x04i\x02\x02\x04\x12\x04\xca\x07\x08\x10\n\r\n\x05\
    \x04i\x02\x02\x05\x12\x04\xca\x07\x11\x17\n\r\n\x05\x04i\x02\x02\x01\x12\
    \x04\xca\x07\x18$\n\r\n\x05\x04i\x02\x02\x03\x12\x04\xca\x07'(\n\x0c\n\
    \x02\x04j\x12\x06\xcd\x07\0\xd0\x07\x01\n\x0b\n\x03\x04j\x01\x12\x04\xcd\
    \x07\x08$\n\x0c\n\x04\x04j\x02\0\x12\x04\xce\x07\x08(\n\r\n\x05\x04j\x02\
    \0\x04\x12\x04\xce\x07\x08\x10\n\r\n\x05\x04j\x02\0\x05\x12\x04\xce\x07\
    \x11\x17\n\r\n\x05\x04j\x02\0\x01\x12\x04\xce\x07\x18#\n\r\n\x05\x04j\
    \x02\0\x03\x12\x04\xce\x07&'\n\x0c\n\x04\x04j\x02\x01\x12\x04\xcf\x07\
    \x08)\n\r\n\x05\x04j\x02\x01\x04\x12\x04\xcf\x07\x08\x10\n\r\n\x05\x04j\
    \x02\x01\x05\x12\x04\xcf\x07\x11\x15\n\r\n\x05\x04j\x02\x01\x01\x12\x04\
    \xcf\x07\x16$\n\r\n\x05\x04j\x02\x01\x03\x12\x04\xcf\x07'(\n\x0c\n\x02\
    \x04k\x12\x06\xd2\x07\0\xdd\x07\x01\n\x0b\n\x03\x04k\x01\x12\x04\xd2\x07\
    \x08%\n\x0e\n\x04\x04k\x03\0\x12\x06\xd3\x07\x08\xd8\x07\t\n\r\n\x05\x04\
    k\x03\0\x01\x12\x04\xd3\x07\x10\x17\n\x0e\n\x06\x04k\x03\0\x02\0\x12\x04\
    \xd4\x07\x10/\n\x0f\n\x07\x04k\x03\0\x02\0\x04\x12\x04\xd4\x07\x10\x18\n\
    \x0f\n\x07\x04k\x03\0\x02\0\x05\x12\x04\xd4\x07\x19\x1f\n\x0f\n\x07\x04k\
    \x03\0\x02\0\x01\x12\x04\xd4\x07\x20*\n\x0f\n\x07\x04k\x03\0\x02\0\x03\
    \x12\x04\xd4\x07-.\n\x0e\n\x06\x04k\x03\0\x02\x01\x12\x04\xd5\x07\x102\n\
    \x0f\n\x07\x04k\x03\0\x02\x01\x04\x12\x04\xd5\x07\x10\x18\n\x0f\n\x07\
    \x04k\x03\0\x02\x01\x05\x12\x04\xd5\x07\x19\x1f\n\x0f\n\x07\x04k\x03\0\
    \x02\x01\x01\x12\x04\xd5\x07\x20-\n\x0f\n\x07\x04k\x03\0\x02\x01\x03\x12\
    \x04\xd5\x0701\n\x0e\n\x06\x04k\x03\0\x02\x02\x12\x04\xd6\x07\x10'\n\x0f\
    \n\x07\x04k\x03\0\x02\x02\x04\x12\x04\xd6\x07\x10\x18\n\x0f\n\x07\x04k\
    \x03\0\x02\x02\x05\x12\x04\xd6\x07\x19\x1e\n\x0f\n\x07\x04k\x03\0\x02\
    \x02\x01\x12\x04\xd6\x07\x1f\"\n\x0f\n\x07\x04k\x03\0\x02\x02\x03\x12\
    \x04\xd6\x07%&\n\x0e\n\x06\x04k\x03\0\x02\x03\x12\x04\xd7\x07\x10*\n\x0f\
    \n\x07\x04k\x03\0\x02\x03\x04\x12\x04\xd7\x07\x10\x18\n\x0f\n\x07\x04k\
    \x03\0\x02\x03\x05\x12\x04\xd7\x07\x19\x1e\n\x0f\n\x07\x04k\x03\0\x02\
    \x03\x01\x12\x04\xd7\x07\x1f%\n\x0f\n\x07\x04k\x03\0\x02\x03\x03\x12\x04\
    \xd7\x07()\n\x0c\n\x04\x04k\x02\0\x12\x04\xda\x07\x08E\n\r\n\x05\x04k\
    \x02\0\x04\x12\x04\xda\x07\x08\x10\n\r\n\x05\x04k\x02\0\x06\x12\x04\xda\
    \x07\x117\n\r\n\x05\x04k\x02\0\x01\x12\x04\xda\x078@\n\r\n\x05\x04k\x02\
    \0\x03\x12\x04\xda\x07CD\n\x0c\n\x04\x04k\x02\x01\x12\x04\xdb\x07\x08-\n\
    \r\n\x05\x04k\x02\x01\x04\x12\x04\xdb\x07\x08\x10\n\r\n\x05\x04k\x02\x01\
    \x05\x12\x04\xdb\x07\x11\x17\n\r\n\x05\x04k\x02\x01\x01\x12\x04\xdb\x07\
    \x18(\n\r\n\x05\x04k\x02\x01\x03\x12\x04\xdb\x07+,\n\x0c\n\x04\x04k\x02\
    \x02\x12\x04\xdc\x07\x08-\n\r\n\x05\x04k\x02\x02\x04\x12\x04\xdc\x07\x08\
    \x10\n\r\n\x05\x04k\x02\x02\x05\x12\x04\xdc\x07\x11\x17\n\r\n\x05\x04k\
    \x02\x02\x01\x12\x04\xdc\x07\x18(\n\r\n\x05\x04k\x02\x02\x03\x12\x04\xdc\
    \x07+,\n\x0c\n\x02\x04l\x12\x06\xdf\x07\0\xe5\x07\x01\n\x0b\n\x03\x04l\
    \x01\x12\x04\xdf\x07\x08)\n\x0c\n\x04\x04l\x02\0\x12\x04\xe0\x07\x080\n\
    \r\n\x05\x04l\x02\0\x04\x12\x04\xe0\x07\x08\x10\n\r\n\x05\x04l\x02\0\x05\
    \x12\x04\xe0\x07\x11\x17\n\r\n\x05\x04l\x02\0\x01\x12\x04\xe0\x07\x18+\n\
    \r\n\x05\x04l\x02\0\x03\x12\x04\xe0\x07./\n\x0c\n\x04\x04l\x02\x01\x12\
    \x04\xe1\x07\x080\n\r\n\x05\x04l\x02\x01\x04\x12\x04\xe1\x07\x08\x10\n\r\
    \n\x05\x04l\x02\x01\x05\x12\x04\xe1\x07\x11\x15\n\r\n\x05\x04l\x02\x01\
    \x01\x12\x04\xe1\x07\x16+\n\r\n\x05\x04l\x02\x01\x03\x12\x04\xe1\x07./\n\
    \x0c\n\x04\x04l\x02\x02\x12\x04\xe2\x07\x084\n\r\n\x05\x04l\x02\x02\x04\
    \x12\x04\xe2\x07\x08\x10\n\r\n\x05\x04l\x02\x02\x05\x12\x04\xe2\x07\x11\
    \x15\n\r\n\x05\x04l\x02\x02\x01\x12\x04\xe2\x07\x16/\n\r\n\x05\x04l\x02\
    \x02\x03\x12\x04\xe2\x0723\n\x0c\n\x04\x04l\x02\x03\x12\x04\xe3\x07\x080\
    \n\r\n\x05\x04l\x02\x03\x04\x12\x04\xe3\x07\x08\x10\n\r\n\x05\x04l\x02\
    \x03\x05\x12\x04\xe3\x07\x11\x17\n\r\n\x05\x04l\x02\x03\x01\x12\x04\xe3\
    \x07\x18+\n\r\n\x05\x04l\x02\x03\x03\x12\x04\xe3\x07./\n\x0c\n\x04\x04l\
    \x02\x04\x12\x04\xe4\x07\x084\n\r\n\x05\x04l\x02\x04\x04\x12\x04\xe4\x07\
    \x08\x10\n\r\n\x05\x04l\x02\x04\x05\x12\x04\xe4\x07\x11\x17\n\r\n\x05\
    \x04l\x02\x04\x01\x12\x04\xe4\x07\x18/\n\r\n\x05\x04l\x02\x04\x03\x12\
    \x04\xe4\x0723\n\x0c\n\x02\x04m\x12\x06\xe7\x07\0\xfb\x07\x01\n\x0b\n\
    \x03\x04m\x01\x12\x04\xe7\x07\x08*\n\x0e\n\x04\x04m\x03\0\x12\x06\xe8\
    \x07\x08\xec\x07\t\n\r\n\x05\x04m\x03\0\x01\x12\x04\xe8\x07\x10\x1d\n\
    \x0e\n\x06\x04m\x03\0\x02\0\x12\x04\xe9\x07\x10.\n\x0f\n\x07\x04m\x03\0\
    \x02\0\x04\x12\x04\xe9\x07\x10\x18\n\x0f\n\x07\x04m\x03\0\x02\0\x05\x12\
    \x04\xe9\x07\x19\x1f\n\x0f\n\x07\x04m\x03\0\x02\0\x01\x12\x04\xe9\x07\
    \x20)\n\x0f\n\x07\x04m\x03\0\x02\0\x03\x12\x04\xe9\x07,-\n\x0e\n\x06\x04\
    m\x03\0\x02\x01\x12\x04\xea\x07\x102\n\x0f\n\x07\x04m\x03\0\x02\x01\x04\
    \x12\x04\xea\x07\x10\x18\n\x0f\n\x07\x04m\x03\0\x02\x01\x05\x12\x04\xea\
    \x07\x19\x1f\n\x0f\n\x07\x04m\x03\0\x02\x01\x01\x12\x04\xea\x07\x20-\n\
    \x0f\n\x07\x04m\x03\0\x02\x01\x03\x12\x04\xea\x0701\n\x0e\n\x06\x04m\x03\
    \0\x02\x02\x12\x04\xeb\x07\x10.\n\x0f\n\x07\x04m\x03\0\x02\x02\x04\x12\
    \x04\xeb\x07\x10\x18\n\x0f\n\x07\x04m\x03\0\x02\x02\x05\x12\x04\xeb\x07\
    \x19\x1d\n\x0f\n\x07\x04m\x03\0\x02\x02\x01\x12\x04\xeb\x07\x1e)\n\x0f\n\
    \x07\x04m\x03\0\x02\x02\x03\x12\x04\xeb\x07,-\n\x0e\n\x04\x04m\x03\x01\
    \x12\x06\xee\x07\x08\xf2\x07\t\n\r\n\x05\x04m\x03\x01\x01\x12\x04\xee\
    \x07\x10\x19\n\x0e\n\x06\x04m\x03\x01\x02\0\x12\x04\xef\x07\x10*\n\x0f\n\
    \x07\x04m\x03\x01\x02\0\x04\x12\x04\xef\x07\x10\x18\n\x0f\n\x07\x04m\x03\
    \x01\x02\0\x05\x12\x04\xef\x07\x19\x1f\n\x0f\n\x07\x04m\x03\x01\x02\0\
    \x01\x12\x04\xef\x07\x20%\n\x0f\n\x07\x04m\x03\x01\x02\0\x03\x12\x04\xef\
    \x07()\n\x0e\n\x06\x04m\x03\x01\x02\x01\x12\x04\xf0\x07\x102\n\x0f\n\x07\
    \x04m\x03\x01\x02\x01\x04\x12\x04\xf0\x07\x10\x18\n\x0f\n\x07\x04m\x03\
    \x01\x02\x01\x05\x12\x04\xf0\x07\x19\x1f\n\x0f\n\x07\x04m\x03\x01\x02\
    \x01\x01\x12\x04\xf0\x07\x20-\n\x0f\n\x07\x04m\x03\x01\x02\x01\x03\x12\
    \x04\xf0\x0701\n\x0e\n\x06\x04m\x03\x01\x02\x02\x12\x04\xf1\x07\x10.\n\
    \x0f\n\x07\x04m\x03\x01\x02\x02\x04\x12\x04\xf1\x07\x10\x18\n\x0f\n\x07\
    \x04m\x03\x01\x02\x02\x05\x12\x04\xf1\x07\x19\x1d\n\x0f\n\x07\x04m\x03\
    \x01\x02\x02\x01\x12\x04\xf1\x07\x1e)\n\x0f\n\x07\x04m\x03\x01\x02\x02\
    \x03\x12\x04\xf1\x07,-\n\x0c\n\x04\x04m\x02\0\x12\x04\xf4\x07\x082\n\r\n\
    \x05\x04m\x02\0\x04\x12\x04\xf4\x07\x08\x10\n\r\n\x05\x04m\x02\0\x05\x12\
    \x04\xf4\x07\x11\x17\n\r\n\x05\x04m\x02\0\x01\x12\x04\xf4\x07\x18-\n\r\n\
    \x05\x04m\x02\0\x03\x12\x04\xf4\x0701\n\x0c\n\x04\x04m\x02\x01\x12\x04\
    \xf5\x07\x080\n\r\n\x05\x04m\x02\x01\x04\x12\x04\xf5\x07\x08\x10\n\r\n\
    \x05\x04m\x02\x01\x05\x12\x04\xf5\x07\x11\x17\n\r\n\x05\x04m\x02\x01\x01\
    \x12\x04\xf5\x07\x18+\n\r\n\x05\x04m\x02\x01\x03\x12\x04\xf5\x07./\n\x0c\
    \n\x04\x04m\x02\x02\x12\x04\xf6\x07\x08,\n\r\n\x05\x04m\x02\x02\x04\x12\
    \x04\xf6\x07\x08\x10\n\r\n\x05\x04m\x02\x02\x05\x12\x04\xf6\x07\x11\x15\
    \n\r\n\x05\x04m\x02\x02\x01\x12\x04\xf6\x07\x16'\n\r\n\x05\x04m\x02\x02\
    \x03\x12\x04\xf6\x07*+\n\x0c\n\x04\x04m\x02\x03\x12\x04\xf7\x07\x08W\n\r\
    \n\x05\x04m\x02\x03\x04\x12\x04\xf7\x07\x08\x10\n\r\n\x05\x04m\x02\x03\
    \x06\x12\x04\xf7\x07\x11B\n\r\n\x05\x04m\x02\x03\x01\x12\x04\xf7\x07CR\n\
    \r\n\x05\x04m\x02\x03\x03\x12\x04\xf7\x07UV\n\x0c\n\x04\x04m\x02\x04\x12\
    \x04\xf8\x07\x08O\n\r\n\x05\x04m\x02\x04\x04\x12\x04\xf8\x07\x08\x10\n\r\
    \n\x05\x04m\x02\x04\x06\x12\x04\xf8\x07\x11>\n\r\n\x05\x04m\x02\x04\x01\
    \x12\x04\xf8\x07?J\n\r\n\x05\x04m\x02\x04\x03\x12\x04\xf8\x07MN\n\x0c\n\
    \x04\x04m\x02\x05\x12\x04\xf9\x07\x080\n\r\n\x05\x04m\x02\x05\x04\x12\
    \x04\xf9\x07\x08\x10\n\r\n\x05\x04m\x02\x05\x05\x12\x04\xf9\x07\x11\x15\
    \n\r\n\x05\x04m\x02\x05\x01\x12\x04\xf9\x07\x16+\n\r\n\x05\x04m\x02\x05\
    \x03\x12\x04\xf9\x07./\n\x0c\n\x04\x04m\x02\x06\x12\x04\xfa\x07\x084\n\r\
    \n\x05\x04m\x02\x06\x04\x12\x04\xfa\x07\x08\x10\n\r\n\x05\x04m\x02\x06\
    \x05\x12\x04\xfa\x07\x11\x15\n\r\n\x05\x04m\x02\x06\x01\x12\x04\xfa\x07\
    \x16/\n\r\n\x05\x04m\x02\x06\x03\x12\x04\xfa\x0723\n\x0c\n\x02\x04n\x12\
    \x06\xfd\x07\0\x8e\x08\x01\n\x0b\n\x03\x04n\x01\x12\x04\xfd\x07\x08(\n\
    \x0e\n\x04\x04n\x03\0\x12\x06\xfe\x07\x08\x82\x08\t\n\r\n\x05\x04n\x03\0\
    \x01\x12\x04\xfe\x07\x10\x17\n\x0e\n\x06\x04n\x03\0\x02\0\x12\x04\xff\
    \x07\x10*\n\x0f\n\x07\x04n\x03\0\x02\0\x04\x12\x04\xff\x07\x10\x18\n\x0f\
    \n\x07\x04n\x03\0\x02\0\x05\x12\x04\xff\x07\x19\x1f\n\x0f\n\x07\x04n\x03\
    \0\x02\0\x01\x12\x04\xff\x07\x20%\n\x0f\n\x07\x04n\x03\0\x02\0\x03\x12\
    \x04\xff\x07()\n\x0e\n\x06\x04n\x03\0\x02\x01\x12\x04\x80\x08\x101\n\x0f\
    \n\x07\x04n\x03\0\x02\x01\x04\x12\x04\x80\x08\x10\x18\n\x0f\n\x07\x04n\
    \x03\0\x02\x01\x05\x12\x04\x80\x08\x19\x1f\n\x0f\n\x07\x04n\x03\0\x02\
    \x01\x01\x12\x04\x80\x08\x20,\n\x0f\n\x07\x04n\x03\0\x02\x01\x03\x12\x04\
    \x80\x08/0\n\x0e\n\x06\x04n\x03\0\x02\x02\x12\x04\x81\x08\x107\n\x0f\n\
    \x07\x04n\x03\0\x02\x02\x04\x12\x04\x81\x08\x10\x18\n\x0f\n\x07\x04n\x03\
    \0\x02\x02\x05\x12\x04\x81\x08\x19\x1d\n\x0f\n\x07\x04n\x03\0\x02\x02\
    \x01\x12\x04\x81\x08\x1e2\n\x0f\n\x07\x04n\x03\0\x02\x02\x03\x12\x04\x81\
    \x0856\n\x0e\n\x04\x04n\x03\x01\x12\x06\x84\x08\x08\x87\x08\t\n\r\n\x05\
    \x04n\x03\x01\x01\x12\x04\x84\x08\x10\x1b\n\x0e\n\x06\x04n\x03\x01\x02\0\
    \x12\x04\x85\x08\x10.\n\x0f\n\x07\x04n\x03\x01\x02\0\x04\x12\x04\x85\x08\
    \x10\x18\n\x0f\n\x07\x04n\x03\x01\x02\0\x05\x12\x04\x85\x08\x19\x1f\n\
    \x0f\n\x07\x04n\x03\x01\x02\0\x01\x12\x04\x85\x08\x20)\n\x0f\n\x07\x04n\
    \x03\x01\x02\0\x03\x12\x04\x85\x08,-\n\x0e\n\x06\x04n\x03\x01\x02\x01\
    \x12\x04\x86\x08\x101\n\x0f\n\x07\x04n\x03\x01\x02\x01\x04\x12\x04\x86\
    \x08\x10\x18\n\x0f\n\x07\x04n\x03\x01\x02\x01\x05\x12\x04\x86\x08\x19\
    \x1f\n\x0f\n\x07\x04n\x03\x01\x02\x01\x01\x12\x04\x86\x08\x20,\n\x0f\n\
    \x07\x04n\x03\x01\x02\x01\x03\x12\x04\x86\x08/0\n\x0c\n\x04\x04n\x02\0\
    \x12\x04\x89\x08\x08L\n\r\n\x05\x04n\x02\0\x04\x12\x04\x89\x08\x08\x10\n\
    \r\n\x05\x04n\x02\0\x06\x12\x04\x89\x08\x11>\n\r\n\x05\x04n\x02\0\x01\
    \x12\x04\x89\x08?G\n\r\n\x05\x04n\x02\0\x03\x12\x04\x89\x08JK\n\x0c\n\
    \x04\x04n\x02\x01\x12\x04\x8a\x08\x08D\n\r\n\x05\x04n\x02\x01\x04\x12\
    \x04\x8a\x08\x08\x10\n\r\n\x05\x04n\x02\x01\x06\x12\x04\x8a\x08\x11:\n\r\
    \n\x05\x04n\x02\x01\x01\x12\x04\x8a\x08;?\n\r\n\x05\x04n\x02\x01\x03\x12\
    \x04\x8a\x08BC\n\x0c\n\x04\x04n\x02\x02\x12\x04\x8b\x08\x08)\n\r\n\x05\
    \x04n\x02\x02\x04\x12\x04\x8b\x08\x08\x10\n\r\n\x05\x04n\x02\x02\x05\x12\
    \x04\x8b\x08\x11\x15\n\r\n\x05\x04n\x02\x02\x01\x12\x04\x8b\x08\x16$\n\r\
    \n\x05\x04n\x02\x02\x03\x12\x04\x8b\x08'(\n\x0c\n\x04\x04n\x02\x03\x12\
    \x04\x8c\x08\x08,\n\r\n\x05\x04n\x02\x03\x04\x12\x04\x8c\x08\x08\x10\n\r\
    \n\x05\x04n\x02\x03\x05\x12\x04\x8c\x08\x11\x17\n\r\n\x05\x04n\x02\x03\
    \x01\x12\x04\x8c\x08\x18'\n\r\n\x05\x04n\x02\x03\x03\x12\x04\x8c\x08*+\n\
    \x0c\n\x04\x04n\x02\x04\x12\x04\x8d\x08\x084\n\r\n\x05\x04n\x02\x04\x04\
    \x12\x04\x8d\x08\x08\x10\n\r\n\x05\x04n\x02\x04\x05\x12\x04\x8d\x08\x11\
    \x17\n\r\n\x05\x04n\x02\x04\x01\x12\x04\x8d\x08\x18/\n\r\n\x05\x04n\x02\
    \x04\x03\x12\x04\x8d\x0823\n\x0c\n\x02\x04o\x12\x06\x90\x08\0\xae\x08\
    \x01\n\x0b\n\x03\x04o\x01\x12\x04\x90\x08\x08)\n\x0b\n\x03\x04o\x07\x12\
    \x04\x91\x08\x08(\n\x0e\n\x06\x04o\x07\xd1\x86\x03\x12\x04\x91\x08\x08(\
    \n\x0e\n\x04\x04o\x03\0\x12\x06\x93\x08\x08\x9b\x08\t\n\r\n\x05\x04o\x03\
    \0\x01\x12\x04\x93\x08\x10\x17\n\x0e\n\x06\x04o\x03\0\x02\0\x12\x04\x94\
    \x08\x10*\n\x0f\n\x07\x04o\x03\0\x02\0\x04\x12\x04\x94\x08\x10\x18\n\x0f\
    \n\x07\x04o\x03\0\x02\0\x05\x12\x04\x94\x08\x19\x1f\n\x0f\n\x07\x04o\x03\
    \0\x02\0\x01\x12\x04\x94\x08\x20%\n\x0f\n\x07\x04o\x03\0\x02\0\x03\x12\
    \x04\x94\x08()\n\x0e\n\x06\x04o\x03\0\x02\x01\x12\x04\x95\x08\x102\n\x0f\
    \n\x07\x04o\x03\0\x02\x01\x04\x12\x04\x95\x08\x10\x18\n\x0f\n\x07\x04o\
    \x03\0\x02\x01\x05\x12\x04\x95\x08\x19\x1f\n\x0f\n\x07\x04o\x03\0\x02\
    \x01\x01\x12\x04\x95\x08\x20-\n\x0f\n\x07\x04o\x03\0\x02\x01\x03\x12\x04\
    \x95\x0801\n\x0e\n\x06\x04o\x03\0\x02\x02\x12\x04\x96\x08\x100\n\x0f\n\
    \x07\x04o\x03\0\x02\x02\x04\x12\x04\x96\x08\x10\x18\n\x0f\n\x07\x04o\x03\
    \0\x02\x02\x05\x12\x04\x96\x08\x19\x1d\n\x0f\n\x07\x04o\x03\0\x02\x02\
    \x01\x12\x04\x96\x08\x1e+\n\x0f\n\x07\x04o\x03\0\x02\x02\x03\x12\x04\x96\
    \x08./\n\x0e\n\x06\x04o\x03\0\x02\x03\x12\x04\x97\x08\x10'\n\x0f\n\x07\
    \x04o\x03\0\x02\x03\x04\x12\x04\x97\x08\x10\x18\n\x0f\n\x07\x04o\x03\0\
    \x02\x03\x05\x12\x04\x97\x08\x19\x1e\n\x0f\n\x07\x04o\x03\0\x02\x03\x01\
    \x12\x04\x97\x08\x1f\"\n\x0f\n\x07\x04o\x03\0\x02\x03\x03\x12\x04\x97\
    \x08%&\n\x0e\n\x06\x04o\x03\0\x02\x04\x12\x04\x98\x08\x10*\n\x0f\n\x07\
    \x04o\x03\0\x02\x04\x04\x12\x04\x98\x08\x10\x18\n\x0f\n\x07\x04o\x03\0\
    \x02\x04\x05\x12\x04\x98\x08\x19\x1e\n\x0f\n\x07\x04o\x03\0\x02\x04\x01\
    \x12\x04\x98\x08\x1f%\n\x0f\n\x07\x04o\x03\0\x02\x04\x03\x12\x04\x98\x08\
    ()\n\x0e\n\x06\x04o\x03\0\x02\x05\x12\x04\x99\x08\x10.\n\x0f\n\x07\x04o\
    \x03\0\x02\x05\x04\x12\x04\x99\x08\x10\x18\n\x0f\n\x07\x04o\x03\0\x02\
    \x05\x05\x12\x04\x99\x08\x19\x1d\n\x0f\n\x07\x04o\x03\0\x02\x05\x01\x12\
    \x04\x99\x08\x1e)\n\x0f\n\x07\x04o\x03\0\x02\x05\x03\x12\x04\x99\x08,-\n\
    \x0e\n\x06\x04o\x03\0\x02\x06\x12\x04\x9a\x08\x10)\n\x0f\n\x07\x04o\x03\
    \0\x02\x06\x04\x12\x04\x9a\x08\x10\x18\n\x0f\n\x07\x04o\x03\0\x02\x06\
    \x05\x12\x04\x9a\x08\x19\x1f\n\x0f\n\x07\x04o\x03\0\x02\x06\x01\x12\x04\
    \x9a\x08\x20$\n\x0f\n\x07\x04o\x03\0\x02\x06\x03\x12\x04\x9a\x08'(\n\x0e\
    \n\x04\x04o\x03\x01\x12\x06\x9d\x08\x08\xa4\x08\t\n\r\n\x05\x04o\x03\x01\
    \x01\x12\x04\x9d\x08\x10\x1b\n\x0e\n\x06\x04o\x03\x01\x02\0\x12\x04\x9e\
    \x08\x10.\n\x0f\n\x07\x04o\x03\x01\x02\0\x04\x12\x04\x9e\x08\x10\x18\n\
    \x0f\n\x07\x04o\x03\x01\x02\0\x05\x12\x04\x9e\x08\x19\x1f\n\x0f\n\x07\
    \x04o\x03\x01\x02\0\x01\x12\x04\x9e\x08\x20)\n\x0f\n\x07\x04o\x03\x01\
    \x02\0\x03\x12\x04\x9e\x08,-\n\x0e\n\x06\x04o\x03\x01\x02\x01\x12\x04\
    \x9f\x08\x102\n\x0f\n\x07\x04o\x03\x01\x02\x01\x04\x12\x04\x9f\x08\x10\
    \x18\n\x0f\n\x07\x04o\x03\x01\x02\x01\x05\x12\x04\x9f\x08\x19\x1f\n\x0f\
    \n\x07\x04o\x03\x01\x02\x01\x01\x12\x04\x9f\x08\x20-\n\x0f\n\x07\x04o\
    \x03\x01\x02\x01\x03\x12\x04\x9f\x0801\n\x0e\n\x06\x04o\x03\x01\x02\x02\
    \x12\x04\xa0\x08\x100\n\x0f\n\x07\x04o\x03\x01\x02\x02\x04\x12\x04\xa0\
    \x08\x10\x18\n\x0f\n\x07\x04o\x03\x01\x02\x02\x05\x12\x04\xa0\x08\x19\
    \x1d\n\x0f\n\x07\x04o\x03\x01\x02\x02\x01\x12\x04\xa0\x08\x1e+\n\x0f\n\
    \x07\x04o\x03\x01\x02\x02\x03\x12\x04\xa0\x08./\n\x0e\n\x06\x04o\x03\x01\
    \x02\x03\x12\x04\xa1\x08\x10'\n\x0f\n\x07\x04o\x03\x01\x02\x03\x04\x12\
    \x04\xa1\x08\x10\x18\n\x0f\n\x07\x04o\x03\x01\x02\x03\x05\x12\x04\xa1\
    \x08\x19\x1e\n\x0f\n\x07\x04o\x03\x01\x02\x03\x01\x12\x04\xa1\x08\x1f\"\
    \n\x0f\n\x07\x04o\x03\x01\x02\x03\x03\x12\x04\xa1\x08%&\n\x0e\n\x06\x04o\
    \x03\x01\x02\x04\x12\x04\xa2\x08\x10*\n\x0f\n\x07\x04o\x03\x01\x02\x04\
    \x04\x12\x04\xa2\x08\x10\x18\n\x0f\n\x07\x04o\x03\x01\x02\x04\x05\x12\
    \x04\xa2\x08\x19\x1e\n\x0f\n\x07\x04o\x03\x01\x02\x04\x01\x12\x04\xa2\
    \x08\x1f%\n\x0f\n\x07\x04o\x03\x01\x02\x04\x03\x12\x04\xa2\x08()\n\x0e\n\
    \x06\x04o\x03\x01\x02\x05\x12\x04\xa3\x08\x10)\n\x0f\n\x07\x04o\x03\x01\
    \x02\x05\x04\x12\x04\xa3\x08\x10\x18\n\x0f\n\x07\x04o\x03\x01\x02\x05\
    \x05\x12\x04\xa3\x08\x19\x1f\n\x0f\n\x07\x04o\x03\x01\x02\x05\x01\x12\
    \x04\xa3\x08\x20$\n\x0f\n\x07\x04o\x03\x01\x02\x05\x03\x12\x04\xa3\x08'(\
    \n\x0c\n\x04\x04o\x02\0\x12\x04\xa6\x08\x08E\n\r\n\x05\x04o\x02\0\x04\
    \x12\x04\xa6\x08\x08\x10\n\r\n\x05\x04o\x02\0\x06\x12\x04\xa6\x08\x11;\n\
    \r\n\x05\x04o\x02\0\x01\x12\x04\xa6\x08<@\n\r\n\x05\x04o\x02\0\x03\x12\
    \x04\xa6\x08CD\n\x0c\n\x04\x04o\x02\x01\x12\x04\xa7\x08\x08+\n\r\n\x05\
    \x04o\x02\x01\x04\x12\x04\xa7\x08\x08\x10\n\r\n\x05\x04o\x02\x01\x05\x12\
    \x04\xa7\x08\x11\x17\n\r\n\x05\x04o\x02\x01\x01\x12\x04\xa7\x08\x18&\n\r\
    \n\x05\x04o\x02\x01\x03\x12\x04\xa7\x08)*\n\x0c\n\x04\x04o\x02\x02\x12\
    \x04\xa8\x08\x08M\n\r\n\x05\x04o\x02\x02\x04\x12\x04\xa8\x08\x08\x10\n\r\
    \n\x05\x04o\x02\x02\x06\x12\x04\xa8\x08\x11?\n\r\n\x05\x04o\x02\x02\x01\
    \x12\x04\xa8\x08@H\n\r\n\x05\x04o\x02\x02\x03\x12\x04\xa8\x08KL\n\x0c\n\
    \x04\x04o\x02\x03\x12\x04\xa9\x08\x08/\n\r\n\x05\x04o\x02\x03\x04\x12\
    \x04\xa9\x08\x08\x10\n\r\n\x05\x04o\x02\x03\x05\x12\x04\xa9\x08\x11\x17\
    \n\r\n\x05\x04o\x02\x03\x01\x12\x04\xa9\x08\x18*\n\r\n\x05\x04o\x02\x03\
    \x03\x12\x04\xa9\x08-.\n\x0c\n\x04\x04o\x02\x04\x12\x04\xaa\x08\x08)\n\r\
    \n\x05\x04o\x02\x04\x04\x12\x04\xaa\x08\x08\x10\n\r\n\x05\x04o\x02\x04\
    \x05\x12\x04\xaa\x08\x11\x15\n\r\n\x05\x04o\x02\x04\x01\x12\x04\xaa\x08\
    \x16$\n\r\n\x05\x04o\x02\x04\x03\x12\x04\xaa\x08'(\n\x0c\n\x04\x04o\x02\
    \x05\x12\x04\xab\x08\x08+\n\r\n\x05\x04o\x02\x05\x04\x12\x04\xab\x08\x08\
    \x10\n\r\n\x05\x04o\x02\x05\x05\x12\x04\xab\x08\x11\x15\n\r\n\x05\x04o\
    \x02\x05\x01\x12\x04\xab\x08\x16&\n\r\n\x05\x04o\x02\x05\x03\x12\x04\xab\
    \x08)*\n\x0c\n\x04\x04o\x02\x06\x12\x04\xac\x08\x08*\n\r\n\x05\x04o\x02\
    \x06\x04\x12\x04\xac\x08\x08\x10\n\r\n\x05\x04o\x02\x06\x05\x12\x04\xac\
    \x08\x11\x17\n\r\n\x05\x04o\x02\x06\x01\x12\x04\xac\x08\x18%\n\r\n\x05\
    \x04o\x02\x06\x03\x12\x04\xac\x08()\n\x0c\n\x04\x04o\x02\x07\x12\x04\xad\
    \x08\x08&\n\r\n\x05\x04o\x02\x07\x04\x12\x04\xad\x08\x08\x10\n\r\n\x05\
    \x04o\x02\x07\x05\x12\x04\xad\x08\x11\x17\n\r\n\x05\x04o\x02\x07\x01\x12\
    \x04\xad\x08\x18!\n\r\n\x05\x04o\x02\x07\x03\x12\x04\xad\x08$%\n\x0c\n\
    \x02\x04p\x12\x06\xb0\x08\0\xb3\x08\x01\n\x0b\n\x03\x04p\x01\x12\x04\xb0\
    \x08\x08(\n\x0c\n\x04\x04p\x02\0\x12\x04\xb1\x08\x08'\n\r\n\x05\x04p\x02\
    \0\x04\x12\x04\xb1\x08\x08\x10\n\r\n\x05\x04p\x02\0\x05\x12\x04\xb1\x08\
    \x11\x17\n\r\n\x05\x04p\x02\0\x01\x12\x04\xb1\x08\x18\"\n\r\n\x05\x04p\
    \x02\0\x03\x12\x04\xb1\x08%&\n\x0c\n\x04\x04p\x02\x01\x12\x04\xb2\x08\
    \x08#\n\r\n\x05\x04p\x02\x01\x04\x12\x04\xb2\x08\x08\x10\n\r\n\x05\x04p\
    \x02\x01\x05\x12\x04\xb2\x08\x11\x17\n\r\n\x05\x04p\x02\x01\x01\x12\x04\
    \xb2\x08\x18\x1e\n\r\n\x05\x04p\x02\x01\x03\x12\x04\xb2\x08!\"\n\x0c\n\
    \x02\x04q\x12\x06\xb5\x08\0\xc4\x08\x01\n\x0b\n\x03\x04q\x01\x12\x04\xb5\
    \x08\x08)\n\x0e\n\x04\x04q\x03\0\x12\x06\xb6\x08\x08\xb9\x08\t\n\r\n\x05\
    \x04q\x03\0\x01\x12\x04\xb6\x08\x10\x1c\n\x0e\n\x06\x04q\x03\0\x02\0\x12\
    \x04\xb7\x08\x10.\n\x0f\n\x07\x04q\x03\0\x02\0\x04\x12\x04\xb7\x08\x10\
    \x18\n\x0f\n\x07\x04q\x03\0\x02\0\x05\x12\x04\xb7\x08\x19\x1f\n\x0f\n\
    \x07\x04q\x03\0\x02\0\x01\x12\x04\xb7\x08\x20)\n\x0f\n\x07\x04q\x03\0\
    \x02\0\x03\x12\x04\xb7\x08,-\n\x0e\n\x06\x04q\x03\0\x02\x01\x12\x04\xb8\
    \x08\x101\n\x0f\n\x07\x04q\x03\0\x02\x01\x04\x12\x04\xb8\x08\x10\x18\n\
    \x0f\n\x07\x04q\x03\0\x02\x01\x05\x12\x04\xb8\x08\x19\x1f\n\x0f\n\x07\
    \x04q\x03\0\x02\x01\x01\x12\x04\xb8\x08\x20,\n\x0f\n\x07\x04q\x03\0\x02\
    \x01\x03\x12\x04\xb8\x08/0\n\x0e\n\x04\x04q\x03\x01\x12\x06\xbb\x08\x08\
    \xbe\x08\t\n\r\n\x05\x04q\x03\x01\x01\x12\x04\xbb\x08\x10\x18\n\x0e\n\
    \x06\x04q\x03\x01\x02\0\x12\x04\xbc\x08\x10*\n\x0f\n\x07\x04q\x03\x01\
    \x02\0\x04\x12\x04\xbc\x08\x10\x18\n\x0f\n\x07\x04q\x03\x01\x02\0\x05\
    \x12\x04\xbc\x08\x19\x1f\n\x0f\n\x07\x04q\x03\x01\x02\0\x01\x12\x04\xbc\
    \x08\x20%\n\x0f\n\x07\x04q\x03\x01\x02\0\x03\x12\x04\xbc\x08()\n\x0e\n\
    \x06\x04q\x03\x01\x02\x01\x12\x04\xbd\x08\x101\n\x0f\n\x07\x04q\x03\x01\
    \x02\x01\x04\x12\x04\xbd\x08\x10\x18\n\x0f\n\x07\x04q\x03\x01\x02\x01\
    \x05\x12\x04\xbd\x08\x19\x1f\n\x0f\n\x07\x04q\x03\x01\x02\x01\x01\x12\
    \x04\xbd\x08\x20,\n\x0f\n\x07\x04q\x03\x01\x02\x01\x03\x12\x04\xbd\x08/0\
    \n\x0c\n\x04\x04q\x02\0\x12\x04\xc0\x08\x08[\n\r\n\x05\x04q\x02\0\x04\
    \x12\x04\xc0\x08\x08\x10\n\r\n\x05\x04q\x02\0\x06\x12\x04\xc0\x08\x11@\n\
    \r\n\x05\x04q\x02\0\x01\x12\x04\xc0\x08AV\n\r\n\x05\x04q\x02\0\x03\x12\
    \x04\xc0\x08YZ\n\x0c\n\x04\x04q\x02\x01\x12\x04\xc1\x08\x082\n\r\n\x05\
    \x04q\x02\x01\x04\x12\x04\xc1\x08\x08\x10\n\r\n\x05\x04q\x02\x01\x05\x12\
    \x04\xc1\x08\x11\x17\n\r\n\x05\x04q\x02\x01\x01\x12\x04\xc1\x08\x18-\n\r\
    \n\x05\x04q\x02\x01\x03\x12\x04\xc1\x0801\n\x0c\n\x04\x04q\x02\x02\x12\
    \x04\xc2\x08\x08S\n\r\n\x05\x04q\x02\x02\x04\x12\x04\xc2\x08\x08\x10\n\r\
    \n\x05\x04q\x02\x02\x06\x12\x04\xc2\x08\x11<\n\r\n\x05\x04q\x02\x02\x01\
    \x12\x04\xc2\x08=N\n\r\n\x05\x04q\x02\x02\x03\x12\x04\xc2\x08QR\n\x0c\n\
    \x04\x04q\x02\x03\x12\x04\xc3\x08\x08.\n\r\n\x05\x04q\x02\x03\x04\x12\
    \x04\xc3\x08\x08\x10\n\r\n\x05\x04q\x02\x03\x05\x12\x04\xc3\x08\x11\x17\
    \n\r\n\x05\x04q\x02\x03\x01\x12\x04\xc3\x08\x18)\n\r\n\x05\x04q\x02\x03\
    \x03\x12\x04\xc3\x08,-\n\x0c\n\x02\x04r\x12\x06\xc6\x08\0\xc8\x08\x01\n\
    \x0b\n\x03\x04r\x01\x12\x04\xc6\x08\x08\"\n\x0c\n\x04\x04r\x02\0\x12\x04\
    \xc7\x08\x08G\n\r\n\x05\x04r\x02\0\x04\x12\x04\xc7\x08\x08\x10\n\r\n\x05\
    \x04r\x02\0\x05\x12\x04\xc7\x08\x11\x18\n\r\n\x05\x04r\x02\0\x01\x12\x04\
    \xc7\x08\x19!\n\r\n\x05\x04r\x02\0\x03\x12\x04\xc7\x08$%\n\r\n\x05\x04r\
    \x02\0\x08\x12\x04\xc7\x08&F\n\r\n\x05\x04r\x02\0\x07\x12\x04\xc7\x081E\
    \n\x0c\n\x02\x04s\x12\x06\xca\x08\0\xd4\x08\x01\n\x0b\n\x03\x04s\x01\x12\
    \x04\xca\x08\x08*\n\x0c\n\x04\x04s\x02\0\x12\x04\xcb\x08\x081\n\r\n\x05\
    \x04s\x02\0\x04\x12\x04\xcb\x08\x08\x10\n\r\n\x05\x04s\x02\0\x05\x12\x04\
    \xcb\x08\x11\x16\n\r\n\x05\x04s\x02\0\x01\x12\x04\xcb\x08\x17\x1e\n\r\n\
    \x05\x04s\x02\0\x03\x12\x04\xcb\x08!\"\n\r\n\x05\x04s\x02\0\x08\x12\x04\
    \xcb\x08#0\n\r\n\x05\x04s\x02\0\x07\x12\x04\xcb\x08./\n\x0c\n\x04\x04s\
    \x02\x01\x12\x04\xcc\x08\x08\x20\n\r\n\x05\x04s\x02\x01\x04\x12\x04\xcc\
    \x08\x08\x10\n\r\n\x05\x04s\x02\x01\x05\x12\x04\xcc\x08\x11\x17\n\r\n\
    \x05\x04s\x02\x01\x01\x12\x04\xcc\x08\x18\x1b\n\r\n\x05\x04s\x02\x01\x03\
    \x12\x04\xcc\x08\x1e\x1f\n\x0c\n\x04\x04s\x02\x02\x12\x04\xcd\x08\x08#\n\
    \r\n\x05\x04s\x02\x02\x04\x12\x04\xcd\x08\x08\x10\n\r\n\x05\x04s\x02\x02\
    \x05\x12\x04\xcd\x08\x11\x17\n\r\n\x05\x04s\x02\x02\x01\x12\x04\xcd\x08\
    \x18\x1e\n\r\n\x05\x04s\x02\x02\x03\x12\x04\xcd\x08!\"\n\x0c\n\x04\x04s\
    \x02\x03\x12\x04\xce\x08\x08%\n\r\n\x05\x04s\x02\x03\x04\x12\x04\xce\x08\
    \x08\x10\n\r\n\x05\x04s\x02\x03\x05\x12\x04\xce\x08\x11\x17\n\r\n\x05\
    \x04s\x02\x03\x01\x12\x04\xce\x08\x18\x20\n\r\n\x05\x04s\x02\x03\x03\x12\
    \x04\xce\x08#$\n\x0c\n\x04\x04s\x02\x04\x12\x04\xcf\x08\x08-\n\r\n\x05\
    \x04s\x02\x04\x04\x12\x04\xcf\x08\x08\x10\n\r\n\x05\x04s\x02\x04\x05\x12\
    \x04\xcf\x08\x11\x18\n\r\n\x05\x04s\x02\x04\x01\x12\x04\xcf\x08\x19(\n\r\
    \n\x05\x04s\x02\x04\x03\x12\x04\xcf\x08+,\n\x0c\n\x04\x04s\x02\x05\x12\
    \x04\xd0\x08\x08&\n\r\n\x05\x04s\x02\x05\x04\x12\x04\xd0\x08\x08\x10\n\r\
    \n\x05\x04s\x02\x05\x05\x12\x04\xd0\x08\x11\x17\n\r\n\x05\x04s\x02\x05\
    \x01\x12\x04\xd0\x08\x18!\n\r\n\x05\x04s\x02\x05\x03\x12\x04\xd0\x08$%\n\
    \x0c\n\x04\x04s\x02\x06\x12\x04\xd1\x08\x081\n\r\n\x05\x04s\x02\x06\x04\
    \x12\x04\xd1\x08\x08\x10\n\r\n\x05\x04s\x02\x06\x05\x12\x04\xd1\x08\x11\
    \x17\n\r\n\x05\x04s\x02\x06\x01\x12\x04\xd1\x08\x18,\n\r\n\x05\x04s\x02\
    \x06\x03\x12\x04\xd1\x08/0\n\x0c\n\x04\x04s\x02\x07\x12\x04\xd2\x08\x08,\
    \n\r\n\x05\x04s\x02\x07\x04\x12\x04\xd2\x08\x08\x10\n\r\n\x05\x04s\x02\
    \x07\x05\x12\x04\xd2\x08\x11\x17\n\r\n\x05\x04s\x02\x07\x01\x12\x04\xd2\
    \x08\x18'\n\r\n\x05\x04s\x02\x07\x03\x12\x04\xd2\x08*+\n\x0c\n\x04\x04s\
    \x02\x08\x12\x04\xd3\x08\x08.\n\r\n\x05\x04s\x02\x08\x04\x12\x04\xd3\x08\
    \x08\x10\n\r\n\x05\x04s\x02\x08\x05\x12\x04\xd3\x08\x11\x17\n\r\n\x05\
    \x04s\x02\x08\x01\x12\x04\xd3\x08\x18)\n\r\n\x05\x04s\x02\x08\x03\x12\
    \x04\xd3\x08,-\n\x0c\n\x02\x04t\x12\x06\xd6\x08\0\xd9\x08\x01\n\x0b\n\
    \x03\x04t\x01\x12\x04\xd6\x08\x08&\n\x0c\n\x04\x04t\x02\0\x12\x04\xd7\
    \x08\x08#\n\r\n\x05\x04t\x02\0\x04\x12\x04\xd7\x08\x08\x10\n\r\n\x05\x04\
    t\x02\0\x05\x12\x04\xd7\x08\x11\x17\n\r\n\x05\x04t\x02\0\x01\x12\x04\xd7\
    \x08\x18\x1e\n\r\n\x05\x04t\x02\0\x03\x12\x04\xd7\x08!\"\n\x0c\n\x04\x04\
    t\x02\x01\x12\x04\xd8\x08\x08&\n\r\n\x05\x04t\x02\x01\x04\x12\x04\xd8\
    \x08\x08\x10\n\r\n\x05\x04t\x02\x01\x05\x12\x04\xd8\x08\x11\x17\n\r\n\
    \x05\x04t\x02\x01\x01\x12\x04\xd8\x08\x18!\n\r\n\x05\x04t\x02\x01\x03\
    \x12\x04\xd8\x08$%\n\x0c\n\x02\x04u\x12\x06\xdb\x08\0\xe3\x08\x01\n\x0b\
    \n\x03\x04u\x01\x12\x04\xdb\x08\x08.\n\x0c\n\x04\x04u\x02\0\x12\x04\xdc\
    \x08\x081\n\r\n\x05\x04u\x02\0\x04\x12\x04\xdc\x08\x08\x10\n\r\n\x05\x04\
    u\x02\0\x05\x12\x04\xdc\x08\x11\x16\n\r\n\x05\x04u\x02\0\x01\x12\x04\xdc\
    \x08\x17\x1e\n\r\n\x05\x04u\x02\0\x03\x12\x04\xdc\x08!\"\n\r\n\x05\x04u\
    \x02\0\x08\x12\x04\xdc\x08#0\n\r\n\x05\x04u\x02\0\x07\x12\x04\xdc\x08./\
    \n\x0c\n\x04\x04u\x02\x01\x12\x04\xdd\x08\x08#\n\r\n\x05\x04u\x02\x01\
    \x04\x12\x04\xdd\x08\x08\x10\n\r\n\x05\x04u\x02\x01\x05\x12\x04\xdd\x08\
    \x11\x17\n\r\n\x05\x04u\x02\x01\x01\x12\x04\xdd\x08\x18\x1e\n\r\n\x05\
    \x04u\x02\x01\x03\x12\x04\xdd\x08!\"\n\x0c\n\x04\x04u\x02\x02\x12\x04\
    \xde\x08\x08&\n\r\n\x05\x04u\x02\x02\x04\x12\x04\xde\x08\x08\x10\n\r\n\
    \x05\x04u\x02\x02\x05\x12\x04\xde\x08\x11\x17\n\r\n\x05\x04u\x02\x02\x01\
    \x12\x04\xde\x08\x18!\n\r\n\x05\x04u\x02\x02\x03\x12\x04\xde\x08$%\n\x0c\
    \n\x04\x04u\x02\x03\x12\x04\xdf\x08\x08$\n\r\n\x05\x04u\x02\x03\x04\x12\
    \x04\xdf\x08\x08\x10\n\r\n\x05\x04u\x02\x03\x05\x12\x04\xdf\x08\x11\x16\
    \n\r\n\x05\x04u\x02\x03\x01\x12\x04\xdf\x08\x17\x1f\n\r\n\x05\x04u\x02\
    \x03\x03\x12\x04\xdf\x08\"#\n\x0c\n\x04\x04u\x02\x04\x12\x04\xe0\x08\x08\
    '\n\r\n\x05\x04u\x02\x04\x04\x12\x04\xe0\x08\x08\x10\n\r\n\x05\x04u\x02\
    \x04\x05\x12\x04\xe0\x08\x11\x17\n\r\n\x05\x04u\x02\x04\x01\x12\x04\xe0\
    \x08\x18\"\n\r\n\x05\x04u\x02\x04\x03\x12\x04\xe0\x08%&\n\x0c\n\x04\x04u\
    \x02\x05\x12\x04\xe1\x08\x08*\n\r\n\x05\x04u\x02\x05\x04\x12\x04\xe1\x08\
    \x08\x10\n\r\n\x05\x04u\x02\x05\x05\x12\x04\xe1\x08\x11\x17\n\r\n\x05\
    \x04u\x02\x05\x01\x12\x04\xe1\x08\x18%\n\r\n\x05\x04u\x02\x05\x03\x12\
    \x04\xe1\x08()\n\x0c\n\x04\x04u\x02\x06\x12\x04\xe2\x08\x08-\n\r\n\x05\
    \x04u\x02\x06\x04\x12\x04\xe2\x08\x08\x10\n\r\n\x05\x04u\x02\x06\x05\x12\
    \x04\xe2\x08\x11\x15\n\r\n\x05\x04u\x02\x06\x01\x12\x04\xe2\x08\x16(\n\r\
    \n\x05\x04u\x02\x06\x03\x12\x04\xe2\x08+,\n\x0c\n\x02\x04v\x12\x06\xe5\
    \x08\0\xe8\x08\x01\n\x0b\n\x03\x04v\x01\x12\x04\xe5\x08\x08\x1e\n\x0c\n\
    \x04\x04v\x02\0\x12\x04\xe6\x08\x08#\n\r\n\x05\x04v\x02\0\x04\x12\x04\
    \xe6\x08\x08\x10\n\r\n\x05\x04v\x02\0\x05\x12\x04\xe6\x08\x11\x17\n\r\n\
    \x05\x04v\x02\0\x01\x12\x04\xe6\x08\x18\x1e\n\r\n\x05\x04v\x02\0\x03\x12\
    \x04\xe6\x08!\"\n\x0c\n\x04\x04v\x02\x01\x12\x04\xe7\x08\x08&\n\r\n\x05\
    \x04v\x02\x01\x04\x12\x04\xe7\x08\x08\x10\n\r\n\x05\x04v\x02\x01\x05\x12\
    \x04\xe7\x08\x11\x17\n\r\n\x05\x04v\x02\x01\x01\x12\x04\xe7\x08\x18!\n\r\
    \n\x05\x04v\x02\x01\x03\x12\x04\xe7\x08$%\n\x0c\n\x02\x04w\x12\x06\xea\
    \x08\0\xed\x08\x01\n\x0b\n\x03\x04w\x01\x12\x04\xea\x08\x08&\n\x0c\n\x04\
    \x04w\x02\0\x12\x04\xeb\x08\x081\n\r\n\x05\x04w\x02\0\x04\x12\x04\xeb\
    \x08\x08\x10\n\r\n\x05\x04w\x02\0\x05\x12\x04\xeb\x08\x11\x16\n\r\n\x05\
    \x04w\x02\0\x01\x12\x04\xeb\x08\x17\x1e\n\r\n\x05\x04w\x02\0\x03\x12\x04\
    \xeb\x08!\"\n\r\n\x05\x04w\x02\0\x08\x12\x04\xeb\x08#0\n\r\n\x05\x04w\
    \x02\0\x07\x12\x04\xeb\x08./\n\x0c\n\x04\x04w\x02\x01\x12\x04\xec\x08\
    \x08G\n\r\n\x05\x04w\x02\x01\x04\x12\x04\xec\x08\x08\x10\n\r\n\x05\x04w\
    \x02\x01\x05\x12\x04\xec\x08\x11\x18\n\r\n\x05\x04w\x02\x01\x01\x12\x04\
    \xec\x08\x19!\n\r\n\x05\x04w\x02\x01\x03\x12\x04\xec\x08$%\n\r\n\x05\x04\
    w\x02\x01\x08\x12\x04\xec\x08&F\n\r\n\x05\x04w\x02\x01\x07\x12\x04\xec\
    \x081E\n\x0c\n\x02\x04x\x12\x06\xef\x08\0\xf1\x08\x01\n\x0b\n\x03\x04x\
    \x01\x12\x04\xef\x08\x08#\n\x0c\n\x04\x04x\x02\0\x12\x04\xf0\x08\x08*\n\
    \r\n\x05\x04x\x02\0\x04\x12\x04\xf0\x08\x08\x10\n\r\n\x05\x04x\x02\0\x05\
    \x12\x04\xf0\x08\x11\x18\n\r\n\x05\x04x\x02\0\x01\x12\x04\xf0\x08\x19%\n\
    \r\n\x05\x04x\x02\0\x03\x12\x04\xf0\x08()\n\x0c\n\x02\x04y\x12\x06\xf3\
    \x08\0\xf7\x08\x01\n\x0b\n\x03\x04y\x01\x12\x04\xf3\x08\x08+\n\x0c\n\x04\
    \x04y\x02\0\x12\x04\xf4\x08\x081\n\r\n\x05\x04y\x02\0\x04\x12\x04\xf4\
    \x08\x08\x10\n\r\n\x05\x04y\x02\0\x05\x12\x04\xf4\x08\x11\x16\n\r\n\x05\
    \x04y\x02\0\x01\x12\x04\xf4\x08\x17\x1e\n\r\n\x05\x04y\x02\0\x03\x12\x04\
    \xf4\x08!\"\n\r\n\x05\x04y\x02\0\x08\x12\x04\xf4\x08#0\n\r\n\x05\x04y\
    \x02\0\x07\x12\x04\xf4\x08./\n\x0c\n\x04\x04y\x02\x01\x12\x04\xf5\x08\
    \x08*\n\r\n\x05\x04y\x02\x01\x04\x12\x04\xf5\x08\x08\x10\n\r\n\x05\x04y\
    \x02\x01\x05\x12\x04\xf5\x08\x11\x18\n\r\n\x05\x04y\x02\x01\x01\x12\x04\
    \xf5\x08\x19%\n\r\n\x05\x04y\x02\x01\x03\x12\x04\xf5\x08()\n\x0c\n\x04\
    \x04y\x02\x02\x12\x04\xf6\x08\x08)\n\r\n\x05\x04y\x02\x02\x04\x12\x04\
    \xf6\x08\x08\x10\n\r\n\x05\x04y\x02\x02\x05\x12\x04\xf6\x08\x11\x16\n\r\
    \n\x05\x04y\x02\x02\x01\x12\x04\xf6\x08\x17$\n\r\n\x05\x04y\x02\x02\x03\
    \x12\x04\xf6\x08'(\n\x0c\n\x02\x04z\x12\x06\xf9\x08\0\x80\t\x01\n\x0b\n\
    \x03\x04z\x01\x12\x04\xf9\x08\x08)\n\x0e\n\x04\x04z\x03\0\x12\x06\xfa\
    \x08\x08\xfc\x08\t\n\r\n\x05\x04z\x03\0\x01\x12\x04\xfa\x08\x10\x1a\n\
    \x0e\n\x06\x04z\x03\0\x02\0\x12\x04\xfb\x08\x10-\n\x0f\n\x07\x04z\x03\0\
    \x02\0\x04\x12\x04\xfb\x08\x10\x18\n\x0f\n\x07\x04z\x03\0\x02\0\x05\x12\
    \x04\xfb\x08\x19\x20\n\x0f\n\x07\x04z\x03\0\x02\0\x01\x12\x04\xfb\x08!(\
    \n\x0f\n\x07\x04z\x03\0\x02\0\x03\x12\x04\xfb\x08+,\n\x0c\n\x04\x04z\x02\
    \0\x12\x04\xfe\x08\x08$\n\r\n\x05\x04z\x02\0\x04\x12\x04\xfe\x08\x08\x10\
    \n\r\n\x05\x04z\x02\0\x05\x12\x04\xfe\x08\x11\x16\n\r\n\x05\x04z\x02\0\
    \x01\x12\x04\xfe\x08\x17\x1f\n\r\n\x05\x04z\x02\0\x03\x12\x04\xfe\x08\"#\
    \n\x0c\n\x04\x04z\x02\x01\x12\x04\xff\x08\x08G\n\r\n\x05\x04z\x02\x01\
    \x04\x12\x04\xff\x08\x08\x10\n\r\n\x05\x04z\x02\x01\x06\x12\x04\xff\x08\
    \x11>\n\r\n\x05\x04z\x02\x01\x01\x12\x04\xff\x08?B\n\r\n\x05\x04z\x02\
    \x01\x03\x12\x04\xff\x08EF\n\x0c\n\x02\x04{\x12\x06\x82\t\0\x8f\t\x01\n\
    \x0b\n\x03\x04{\x01\x12\x04\x82\t\x081\n\x0e\n\x04\x04{\x03\0\x12\x06\
    \x83\t\x08\x8c\t\t\n\r\n\x05\x04{\x03\0\x01\x12\x04\x83\t\x10!\n\x10\n\
    \x06\x04{\x03\0\x03\0\x12\x06\x84\t\x10\x87\t\x11\n\x0f\n\x07\x04{\x03\0\
    \x03\0\x01\x12\x04\x84\t\x18$\n\x10\n\x08\x04{\x03\0\x03\0\x02\0\x12\x04\
    \x85\t\x188\n\x11\n\t\x04{\x03\0\x03\0\x02\0\x04\x12\x04\x85\t\x18\x20\n\
    \x11\n\t\x04{\x03\0\x03\0\x02\0\x05\x12\x04\x85\t!(\n\x11\n\t\x04{\x03\0\
    \x03\0\x02\0\x01\x12\x04\x85\t)3\n\x11\n\t\x04{\x03\0\x03\0\x02\0\x03\
    \x12\x04\x85\t67\n\x10\n\x08\x04{\x03\0\x03\0\x02\x01\x12\x04\x86\t\x181\
    \n\x11\n\t\x04{\x03\0\x03\0\x02\x01\x04\x12\x04\x86\t\x18\x20\n\x11\n\t\
    \x04{\x03\0\x03\0\x02\x01\x05\x12\x04\x86\t!'\n\x11\n\t\x04{\x03\0\x03\0\
    \x02\x01\x01\x12\x04\x86\t(,\n\x11\n\t\x04{\x03\0\x03\0\x02\x01\x03\x12\
    \x04\x86\t/0\n\x0e\n\x06\x04{\x03\0\x02\0\x12\x04\x89\t\x109\n\x0f\n\x07\
    \x04{\x03\0\x02\0\x04\x12\x04\x89\t\x10\x18\n\x0f\n\x07\x04{\x03\0\x02\0\
    \x05\x12\x04\x89\t\x19\x1e\n\x0f\n\x07\x04{\x03\0\x02\0\x01\x12\x04\x89\
    \t\x1f&\n\x0f\n\x07\x04{\x03\0\x02\0\x03\x12\x04\x89\t)*\n\x0f\n\x07\x04\
    {\x03\0\x02\0\x08\x12\x04\x89\t+8\n\x0f\n\x07\x04{\x03\0\x02\0\x07\x12\
    \x04\x89\t67\n\x0e\n\x06\x04{\x03\0\x02\x01\x12\x04\x8a\t\x10-\n\x0f\n\
    \x07\x04{\x03\0\x02\x01\x04\x12\x04\x8a\t\x10\x18\n\x0f\n\x07\x04{\x03\0\
    \x02\x01\x05\x12\x04\x8a\t\x19\x20\n\x0f\n\x07\x04{\x03\0\x02\x01\x01\
    \x12\x04\x8a\t!(\n\x0f\n\x07\x04{\x03\0\x02\x01\x03\x12\x04\x8a\t+,\n\
    \x0e\n\x06\x04{\x03\0\x02\x02\x12\x04\x8b\t\x10m\n\x0f\n\x07\x04{\x03\0\
    \x02\x02\x04\x12\x04\x8b\t\x10\x18\n\x0f\n\x07\x04{\x03\0\x02\x02\x06\
    \x12\x04\x8b\t\x19b\n\x0f\n\x07\x04{\x03\0\x02\x02\x01\x12\x04\x8b\tch\n\
    \x0f\n\x07\x04{\x03\0\x02\x02\x03\x12\x04\x8b\tkl\n\x0c\n\x04\x04{\x02\0\
    \x12\x04\x8e\t\x08\\\n\r\n\x05\x04{\x02\0\x04\x12\x04\x8e\t\x08\x10\n\r\
    \n\x05\x04{\x02\0\x06\x12\x04\x8e\t\x11M\n\r\n\x05\x04{\x02\0\x01\x12\
    \x04\x8e\tNW\n\r\n\x05\x04{\x02\0\x03\x12\x04\x8e\tZ[\n\x0c\n\x02\x04|\
    \x12\x06\x91\t\0\x94\t\x01\n\x0b\n\x03\x04|\x01\x12\x04\x91\t\x08&\n\x0c\
    \n\x04\x04|\x02\0\x12\x04\x92\t\x08(\n\r\n\x05\x04|\x02\0\x04\x12\x04\
    \x92\t\x08\x10\n\r\n\x05\x04|\x02\0\x05\x12\x04\x92\t\x11\x17\n\r\n\x05\
    \x04|\x02\0\x01\x12\x04\x92\t\x18#\n\r\n\x05\x04|\x02\0\x03\x12\x04\x92\
    \t&'\n\x0c\n\x04\x04|\x02\x01\x12\x04\x93\t\x08#\n\r\n\x05\x04|\x02\x01\
    \x04\x12\x04\x93\t\x08\x10\n\r\n\x05\x04|\x02\x01\x05\x12\x04\x93\t\x11\
    \x17\n\r\n\x05\x04|\x02\x01\x01\x12\x04\x93\t\x18\x1e\n\r\n\x05\x04|\x02\
    \x01\x03\x12\x04\x93\t!\"\n\x0c\n\x02\x04}\x12\x06\x96\t\0\xb3\t\x01\n\
    \x0b\n\x03\x04}\x01\x12\x04\x96\t\x08\x1b\n\x0e\n\x04\x04}\x03\0\x12\x06\
    \x97\t\x08\x9a\t\t\n\r\n\x05\x04}\x03\0\x01\x12\x04\x97\t\x10\x18\n\x0e\
    \n\x06\x04}\x03\0\x02\0\x12\x04\x98\t\x10.\n\x0f\n\x07\x04}\x03\0\x02\0\
    \x04\x12\x04\x98\t\x10\x18\n\x0f\n\x07\x04}\x03\0\x02\0\x05\x12\x04\x98\
    \t\x19\x1f\n\x0f\n\x07\x04}\x03\0\x02\0\x01\x12\x04\x98\t\x20)\n\x0f\n\
    \x07\x04}\x03\0\x02\0\x03\x12\x04\x98\t,-\n\x0e\n\x06\x04}\x03\0\x02\x01\
    \x12\x04\x99\t\x10.\n\x0f\n\x07\x04}\x03\0\x02\x01\x04\x12\x04\x99\t\x10\
    \x18\n\x0f\n\x07\x04}\x03\0\x02\x01\x05\x12\x04\x99\t\x19\x1e\n\x0f\n\
    \x07\x04}\x03\0\x02\x01\x01\x12\x04\x99\t\x1f)\n\x0f\n\x07\x04}\x03\0\
    \x02\x01\x03\x12\x04\x99\t,-\n\x0e\n\x04\x04}\x03\x01\x12\x06\x9c\t\x08\
    \xa2\t\t\n\r\n\x05\x04}\x03\x01\x01\x12\x04\x9c\t\x10\x1a\n\x0e\n\x06\
    \x04}\x03\x01\x02\0\x12\x04\x9d\t\x10,\n\x0f\n\x07\x04}\x03\x01\x02\0\
    \x04\x12\x04\x9d\t\x10\x18\n\x0f\n\x07\x04}\x03\x01\x02\0\x05\x12\x04\
    \x9d\t\x19\x1f\n\x0f\n\x07\x04}\x03\x01\x02\0\x01\x12\x04\x9d\t\x20'\n\
    \x0f\n\x07\x04}\x03\x01\x02\0\x03\x12\x04\x9d\t*+\n\x0e\n\x06\x04}\x03\
    \x01\x02\x01\x12\x04\x9e\t\x10+\n\x0f\n\x07\x04}\x03\x01\x02\x01\x04\x12\
    \x04\x9e\t\x10\x18\n\x0f\n\x07\x04}\x03\x01\x02\x01\x05\x12\x04\x9e\t\
    \x19\x1f\n\x0f\n\x07\x04}\x03\x01\x02\x01\x01\x12\x04\x9e\t\x20&\n\x0f\n\
    \x07\x04}\x03\x01\x02\x01\x03\x12\x04\x9e\t)*\n\x0e\n\x06\x04}\x03\x01\
    \x02\x02\x12\x04\x9f\t\x10-\n\x0f\n\x07\x04}\x03\x01\x02\x02\x04\x12\x04\
    \x9f\t\x10\x18\n\x0f\n\x07\x04}\x03\x01\x02\x02\x05\x12\x04\x9f\t\x19\
    \x1f\n\x0f\n\x07\x04}\x03\x01\x02\x02\x01\x12\x04\x9f\t\x20(\n\x0f\n\x07\
    \x04}\x03\x01\x02\x02\x03\x12\x04\x9f\t+,\n\x0e\n\x06\x04}\x03\x01\x02\
    \x03\x12\x04\xa0\t\x10,\n\x0f\n\x07\x04}\x03\x01\x02\x03\x04\x12\x04\xa0\
    \t\x10\x18\n\x0f\n\x07\x04}\x03\x01\x02\x03\x05\x12\x04\xa0\t\x19\x1f\n\
    \x0f\n\x07\x04}\x03\x01\x02\x03\x01\x12\x04\xa0\t\x20'\n\x0f\n\x07\x04}\
    \x03\x01\x02\x03\x03\x12\x04\xa0\t*+\n\x0e\n\x06\x04}\x03\x01\x02\x04\
    \x12\x04\xa1\t\x106\n\x0f\n\x07\x04}\x03\x01\x02\x04\x04\x12\x04\xa1\t\
    \x10\x18\n\x0f\n\x07\x04}\x03\x01\x02\x04\x05\x12\x04\xa1\t\x19\x1f\n\
    \x0f\n\x07\x04}\x03\x01\x02\x04\x01\x12\x04\xa1\t\x201\n\x0f\n\x07\x04}\
    \x03\x01\x02\x04\x03\x12\x04\xa1\t45\n\x0e\n\x04\x04}\x03\x02\x12\x06\
    \xa4\t\x08\xaa\t\t\n\r\n\x05\x04}\x03\x02\x01\x12\x04\xa4\t\x10\x15\n\
    \x0e\n\x06\x04}\x03\x02\x02\0\x12\x04\xa5\t\x10)\n\x0f\n\x07\x04}\x03\
    \x02\x02\0\x04\x12\x04\xa5\t\x10\x18\n\x0f\n\x07\x04}\x03\x02\x02\0\x05\
    \x12\x04\xa5\t\x19\x20\n\x0f\n\x07\x04}\x03\x02\x02\0\x01\x12\x04\xa5\t!\
    $\n\x0f\n\x07\x04}\x03\x02\x02\0\x03\x12\x04\xa5\t'(\n\x0e\n\x06\x04}\
    \x03\x02\x02\x01\x12\x04\xa6\t\x10/\n\x0f\n\x07\x04}\x03\x02\x02\x01\x04\
    \x12\x04\xa6\t\x10\x18\n\x0f\n\x07\x04}\x03\x02\x02\x01\x05\x12\x04\xa6\
    \t\x19\x1f\n\x0f\n\x07\x04}\x03\x02\x02\x01\x01\x12\x04\xa6\t\x20*\n\x0f\
    \n\x07\x04}\x03\x02\x02\x01\x03\x12\x04\xa6\t-.\n\x0e\n\x06\x04}\x03\x02\
    \x02\x02\x12\x04\xa7\t\x10-\n\x0f\n\x07\x04}\x03\x02\x02\x02\x04\x12\x04\
    \xa7\t\x10\x18\n\x0f\n\x07\x04}\x03\x02\x02\x02\x05\x12\x04\xa7\t\x19\
    \x1f\n\x0f\n\x07\x04}\x03\x02\x02\x02\x01\x12\x04\xa7\t\x20(\n\x0f\n\x07\
    \x04}\x03\x02\x02\x02\x03\x12\x04\xa7\t+,\n\x0e\n\x06\x04}\x03\x02\x02\
    \x03\x12\x04\xa8\t\x10-\n\x0f\n\x07\x04}\x03\x02\x02\x03\x04\x12\x04\xa8\
    \t\x10\x18\n\x0f\n\x07\x04}\x03\x02\x02\x03\x05\x12\x04\xa8\t\x19\x20\n\
    \x0f\n\x07\x04}\x03\x02\x02\x03\x01\x12\x04\xa8\t!(\n\x0f\n\x07\x04}\x03\
    \x02\x02\x03\x03\x12\x04\xa8\t+,\n\x0e\n\x06\x04}\x03\x02\x02\x04\x12\
    \x04\xa9\t\x10.\n\x0f\n\x07\x04}\x03\x02\x02\x04\x04\x12\x04\xa9\t\x10\
    \x18\n\x0f\n\x07\x04}\x03\x02\x02\x04\x05\x12\x04\xa9\t\x19\x1d\n\x0f\n\
    \x07\x04}\x03\x02\x02\x04\x01\x12\x04\xa9\t\x1e)\n\x0f\n\x07\x04}\x03\
    \x02\x02\x04\x03\x12\x04\xa9\t,-\n\x0c\n\x04\x04}\x02\0\x12\x04\xac\t\
    \x08*\n\r\n\x05\x04}\x02\0\x04\x12\x04\xac\t\x08\x10\n\r\n\x05\x04}\x02\
    \0\x05\x12\x04\xac\t\x11\x18\n\r\n\x05\x04}\x02\0\x01\x12\x04\xac\t\x19%\
    \n\r\n\x05\x04}\x02\0\x03\x12\x04\xac\t()\n\x0c\n\x04\x04}\x02\x01\x12\
    \x04\xad\t\x08/\n\r\n\x05\x04}\x02\x01\x04\x12\x04\xad\t\x08\x10\n\r\n\
    \x05\x04}\x02\x01\x05\x12\x04\xad\t\x11\x17\n\r\n\x05\x04}\x02\x01\x01\
    \x12\x04\xad\t\x18*\n\r\n\x05\x04}\x02\x01\x03\x12\x04\xad\t-.\n\x0c\n\
    \x04\x04}\x02\x02\x12\x04\xae\t\x08=\n\r\n\x05\x04}\x02\x02\x04\x12\x04\
    \xae\t\x08\x10\n\r\n\x05\x04}\x02\x02\x06\x12\x04\xae\t\x11.\n\r\n\x05\
    \x04}\x02\x02\x01\x12\x04\xae\t/8\n\r\n\x05\x04}\x02\x02\x03\x12\x04\xae\
    \t;<\n\x0c\n\x04\x04}\x02\x03\x12\x04\xaf\t\x08A\n\r\n\x05\x04}\x02\x03\
    \x04\x12\x04\xaf\t\x08\x10\n\r\n\x05\x04}\x02\x03\x06\x12\x04\xaf\t\x110\
    \n\r\n\x05\x04}\x02\x03\x01\x12\x04\xaf\t1<\n\r\n\x05\x04}\x02\x03\x03\
    \x12\x04\xaf\t?@\n\x0c\n\x04\x04}\x02\x04\x12\x04\xb0\t\x087\n\r\n\x05\
    \x04}\x02\x04\x04\x12\x04\xb0\t\x08\x10\n\r\n\x05\x04}\x02\x04\x06\x12\
    \x04\xb0\t\x11+\n\r\n\x05\x04}\x02\x04\x01\x12\x04\xb0\t,2\n\r\n\x05\x04\
    }\x02\x04\x03\x12\x04\xb0\t56\n\x0c\n\x04\x04}\x02\x05\x12\x04\xb1\t\x08\
    >\n\r\n\x05\x04}\x02\x05\x04\x12\x04\xb1\t\x08\x10\n\r\n\x05\x04}\x02\
    \x05\x06\x12\x04\xb1\t\x11+\n\r\n\x05\x04}\x02\x05\x01\x12\x04\xb1\t,9\n\
    \r\n\x05\x04}\x02\x05\x03\x12\x04\xb1\t<=\n\x0c\n\x04\x04}\x02\x06\x12\
    \x04\xb2\t\x08,\n\r\n\x05\x04}\x02\x06\x04\x12\x04\xb2\t\x08\x10\n\r\n\
    \x05\x04}\x02\x06\x05\x12\x04\xb2\t\x11\x15\n\r\n\x05\x04}\x02\x06\x01\
    \x12\x04\xb2\t\x16'\n\r\n\x05\x04}\x02\x06\x03\x12\x04\xb2\t*+\n\x0c\n\
    \x02\x04~\x12\x06\xb5\t\0\xbd\t\x01\n\x0b\n\x03\x04~\x01\x12\x04\xb5\t\
    \x08'\n\x0c\n\x04\x04~\x02\0\x12\x04\xb6\t\x08#\n\r\n\x05\x04~\x02\0\x04\
    \x12\x04\xb6\t\x08\x10\n\r\n\x05\x04~\x02\0\x05\x12\x04\xb6\t\x11\x17\n\
    \r\n\x05\x04~\x02\0\x01\x12\x04\xb6\t\x18\x1e\n\r\n\x05\x04~\x02\0\x03\
    \x12\x04\xb6\t!\"\n\x0c\n\x04\x04~\x02\x01\x12\x04\xb7\t\x08&\n\r\n\x05\
    \x04~\x02\x01\x04\x12\x04\xb7\t\x08\x10\n\r\n\x05\x04~\x02\x01\x05\x12\
    \x04\xb7\t\x11\x17\n\r\n\x05\x04~\x02\x01\x01\x12\x04\xb7\t\x18!\n\r\n\
    \x05\x04~\x02\x01\x03\x12\x04\xb7\t$%\n\x0c\n\x04\x04~\x02\x02\x12\x04\
    \xb8\t\x08&\n\r\n\x05\x04~\x02\x02\x04\x12\x04\xb8\t\x08\x10\n\r\n\x05\
    \x04~\x02\x02\x05\x12\x04\xb8\t\x11\x17\n\r\n\x05\x04~\x02\x02\x01\x12\
    \x04\xb8\t\x18!\n\r\n\x05\x04~\x02\x02\x03\x12\x04\xb8\t$%\n\x0c\n\x04\
    \x04~\x02\x03\x12\x04\xb9\t\x08+\n\r\n\x05\x04~\x02\x03\x04\x12\x04\xb9\
    \t\x08\x10\n\r\n\x05\x04~\x02\x03\x05\x12\x04\xb9\t\x11\x15\n\r\n\x05\
    \x04~\x02\x03\x01\x12\x04\xb9\t\x16&\n\r\n\x05\x04~\x02\x03\x03\x12\x04\
    \xb9\t)*\n\x0c\n\x04\x04~\x02\x04\x12\x04\xba\t\x08%\n\r\n\x05\x04~\x02\
    \x04\x04\x12\x04\xba\t\x08\x10\n\r\n\x05\x04~\x02\x04\x05\x12\x04\xba\t\
    \x11\x17\n\r\n\x05\x04~\x02\x04\x01\x12\x04\xba\t\x18\x20\n\r\n\x05\x04~\
    \x02\x04\x03\x12\x04\xba\t#$\n\x0c\n\x04\x04~\x02\x05\x12\x04\xbb\t\x08(\
    \n\r\n\x05\x04~\x02\x05\x04\x12\x04\xbb\t\x08\x10\n\r\n\x05\x04~\x02\x05\
    \x05\x12\x04\xbb\t\x11\x17\n\r\n\x05\x04~\x02\x05\x01\x12\x04\xbb\t\x18#\
    \n\r\n\x05\x04~\x02\x05\x03\x12\x04\xbb\t&'\n\x0c\n\x04\x04~\x02\x06\x12\
    \x04\xbc\t\x08'\n\r\n\x05\x04~\x02\x06\x04\x12\x04\xbc\t\x08\x10\n\r\n\
    \x05\x04~\x02\x06\x05\x12\x04\xbc\t\x11\x17\n\r\n\x05\x04~\x02\x06\x01\
    \x12\x04\xbc\t\x18\"\n\r\n\x05\x04~\x02\x06\x03\x12\x04\xbc\t%&\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(super::steammessages_base::file_descriptor().clone());
            deps.push(super::encrypted_app_ticket::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(171);
            messages.push(CMsgClientUDSP2PSessionStarted::generated_message_descriptor_data());
            messages.push(CMsgClientUDSP2PSessionEnded::generated_message_descriptor_data());
            messages.push(CMsgClientRegisterAuthTicketWithCM::generated_message_descriptor_data());
            messages.push(CMsgClientTicketAuthComplete::generated_message_descriptor_data());
            messages.push(CMsgClientCMList::generated_message_descriptor_data());
            messages.push(CMsgClientP2PConnectionInfo::generated_message_descriptor_data());
            messages.push(CMsgClientP2PConnectionFailInfo::generated_message_descriptor_data());
            messages.push(CMsgClientNetworkingCertRequest::generated_message_descriptor_data());
            messages.push(CMsgClientNetworkingCertReply::generated_message_descriptor_data());
            messages.push(CMsgClientNetworkingMobileCertRequest::generated_message_descriptor_data());
            messages.push(CMsgClientNetworkingMobileCertReply::generated_message_descriptor_data());
            messages.push(CMsgClientGetAppOwnershipTicket::generated_message_descriptor_data());
            messages.push(CMsgClientGetAppOwnershipTicketResponse::generated_message_descriptor_data());
            messages.push(CMsgClientSessionToken::generated_message_descriptor_data());
            messages.push(CMsgClientGameConnectTokens::generated_message_descriptor_data());
            messages.push(CMsgGSServerType::generated_message_descriptor_data());
            messages.push(CMsgGSStatusReply::generated_message_descriptor_data());
            messages.push(CMsgGSPlayerList::generated_message_descriptor_data());
            messages.push(CMsgGSUserPlaying::generated_message_descriptor_data());
            messages.push(CMsgGSDisconnectNotice::generated_message_descriptor_data());
            messages.push(CMsgClientGamesPlayed::generated_message_descriptor_data());
            messages.push(CMsgGSApprove::generated_message_descriptor_data());
            messages.push(CMsgGSDeny::generated_message_descriptor_data());
            messages.push(CMsgGSKick::generated_message_descriptor_data());
            messages.push(CMsgClientAuthList::generated_message_descriptor_data());
            messages.push(CMsgClientAuthListAck::generated_message_descriptor_data());
            messages.push(CMsgClientLicenseList::generated_message_descriptor_data());
            messages.push(CMsgClientLBSSetScore::generated_message_descriptor_data());
            messages.push(CMsgClientLBSSetScoreResponse::generated_message_descriptor_data());
            messages.push(CMsgClientLBSSetUGC::generated_message_descriptor_data());
            messages.push(CMsgClientLBSSetUGCResponse::generated_message_descriptor_data());
            messages.push(CMsgClientLBSFindOrCreateLB::generated_message_descriptor_data());
            messages.push(CMsgClientLBSFindOrCreateLBResponse::generated_message_descriptor_data());
            messages.push(CMsgClientLBSGetLBEntries::generated_message_descriptor_data());
            messages.push(CMsgClientLBSGetLBEntriesResponse::generated_message_descriptor_data());
            messages.push(CMsgClientIsLimitedAccount::generated_message_descriptor_data());
            messages.push(CMsgClientRequestedClientStats::generated_message_descriptor_data());
            messages.push(CMsgClientStat2::generated_message_descriptor_data());
            messages.push(CMsgClientMMSSetRatelimitPolicyOnClient::generated_message_descriptor_data());
            messages.push(CMsgClientMMSCreateLobby::generated_message_descriptor_data());
            messages.push(CMsgClientMMSCreateLobbyResponse::generated_message_descriptor_data());
            messages.push(CMsgClientMMSJoinLobby::generated_message_descriptor_data());
            messages.push(CMsgClientMMSJoinLobbyResponse::generated_message_descriptor_data());
            messages.push(CMsgClientMMSLeaveLobby::generated_message_descriptor_data());
            messages.push(CMsgClientMMSLeaveLobbyResponse::generated_message_descriptor_data());
            messages.push(CMsgClientMMSGetLobbyList::generated_message_descriptor_data());
            messages.push(CMsgClientMMSGetLobbyListResponse::generated_message_descriptor_data());
            messages.push(CMsgClientMMSSetLobbyData::generated_message_descriptor_data());
            messages.push(CMsgClientMMSSetLobbyDataResponse::generated_message_descriptor_data());
            messages.push(CMsgClientMMSGetLobbyData::generated_message_descriptor_data());
            messages.push(CMsgClientMMSLobbyData::generated_message_descriptor_data());
            messages.push(CMsgClientMMSSendLobbyChatMsg::generated_message_descriptor_data());
            messages.push(CMsgClientMMSLobbyChatMsg::generated_message_descriptor_data());
            messages.push(CMsgClientMMSSetLobbyOwner::generated_message_descriptor_data());
            messages.push(CMsgClientMMSSetLobbyOwnerResponse::generated_message_descriptor_data());
            messages.push(CMsgClientMMSSetLobbyLinked::generated_message_descriptor_data());
            messages.push(CMsgClientMMSSetLobbyGameServer::generated_message_descriptor_data());
            messages.push(CMsgClientMMSLobbyGameServerSet::generated_message_descriptor_data());
            messages.push(CMsgClientMMSUserJoinedLobby::generated_message_descriptor_data());
            messages.push(CMsgClientMMSUserLeftLobby::generated_message_descriptor_data());
            messages.push(CMsgClientMMSInviteToLobby::generated_message_descriptor_data());
            messages.push(CMsgClientMMSGetLobbyStatus::generated_message_descriptor_data());
            messages.push(CMsgClientMMSGetLobbyStatusResponse::generated_message_descriptor_data());
            messages.push(CMsgClientInviteToGame::generated_message_descriptor_data());
            messages.push(CMsgClientChatInvite::generated_message_descriptor_data());
            messages.push(CMsgClientConnectionStats::generated_message_descriptor_data());
            messages.push(CMsgClientServersAvailable::generated_message_descriptor_data());
            messages.push(CMsgClientGetUserStats::generated_message_descriptor_data());
            messages.push(CMsgClientGetUserStatsResponse::generated_message_descriptor_data());
            messages.push(CMsgClientStoreUserStatsResponse::generated_message_descriptor_data());
            messages.push(CMsgClientStoreUserStats2::generated_message_descriptor_data());
            messages.push(CMsgClientStatsUpdated::generated_message_descriptor_data());
            messages.push(CMsgClientStoreUserStats::generated_message_descriptor_data());
            messages.push(CMsgClientGetClientDetails::generated_message_descriptor_data());
            messages.push(CMsgClientReportOverlayDetourFailure::generated_message_descriptor_data());
            messages.push(CMsgClientGetClientDetailsResponse::generated_message_descriptor_data());
            messages.push(CMsgClientGetClientAppList::generated_message_descriptor_data());
            messages.push(CMsgClientGetClientAppListResponse::generated_message_descriptor_data());
            messages.push(CMsgClientInstallClientApp::generated_message_descriptor_data());
            messages.push(CMsgClientInstallClientAppResponse::generated_message_descriptor_data());
            messages.push(CMsgClientUninstallClientApp::generated_message_descriptor_data());
            messages.push(CMsgClientUninstallClientAppResponse::generated_message_descriptor_data());
            messages.push(CMsgClientSetClientAppUpdateState::generated_message_descriptor_data());
            messages.push(CMsgClientSetClientAppUpdateStateResponse::generated_message_descriptor_data());
            messages.push(CMsgClientUFSUploadFileRequest::generated_message_descriptor_data());
            messages.push(CMsgClientUFSUploadFileResponse::generated_message_descriptor_data());
            messages.push(CMsgClientUFSUploadCommit::generated_message_descriptor_data());
            messages.push(CMsgClientUFSUploadCommitResponse::generated_message_descriptor_data());
            messages.push(CMsgClientUFSFileChunk::generated_message_descriptor_data());
            messages.push(CMsgClientUFSTransferHeartbeat::generated_message_descriptor_data());
            messages.push(CMsgClientUFSUploadFileFinished::generated_message_descriptor_data());
            messages.push(CMsgClientUFSDeleteFileRequest::generated_message_descriptor_data());
            messages.push(CMsgClientUFSDeleteFileResponse::generated_message_descriptor_data());
            messages.push(CMsgClientUFSGetFileListForApp::generated_message_descriptor_data());
            messages.push(CMsgClientUFSGetFileListForAppResponse::generated_message_descriptor_data());
            messages.push(CMsgClientUFSDownloadRequest::generated_message_descriptor_data());
            messages.push(CMsgClientUFSDownloadResponse::generated_message_descriptor_data());
            messages.push(CMsgClientUFSLoginRequest::generated_message_descriptor_data());
            messages.push(CMsgClientUFSLoginResponse::generated_message_descriptor_data());
            messages.push(CMsgClientRequestEncryptedAppTicket::generated_message_descriptor_data());
            messages.push(CMsgClientRequestEncryptedAppTicketResponse::generated_message_descriptor_data());
            messages.push(CMsgClientWalletInfoUpdate::generated_message_descriptor_data());
            messages.push(CMsgClientAppInfoUpdate::generated_message_descriptor_data());
            messages.push(CMsgClientAppInfoChanges::generated_message_descriptor_data());
            messages.push(CMsgClientAppInfoRequest::generated_message_descriptor_data());
            messages.push(CMsgClientAppInfoResponse::generated_message_descriptor_data());
            messages.push(CMsgClientPackageInfoRequest::generated_message_descriptor_data());
            messages.push(CMsgClientPackageInfoResponse::generated_message_descriptor_data());
            messages.push(CMsgClientPICSChangesSinceRequest::generated_message_descriptor_data());
            messages.push(CMsgClientPICSChangesSinceResponse::generated_message_descriptor_data());
            messages.push(CMsgClientPICSProductInfoRequest::generated_message_descriptor_data());
            messages.push(CMsgClientPICSProductInfoResponse::generated_message_descriptor_data());
            messages.push(CMsgClientPICSAccessTokenRequest::generated_message_descriptor_data());
            messages.push(CMsgClientPICSAccessTokenResponse::generated_message_descriptor_data());
            messages.push(CMsgClientUFSGetUGCDetails::generated_message_descriptor_data());
            messages.push(CMsgClientUFSGetUGCDetailsResponse::generated_message_descriptor_data());
            messages.push(CMsgClientUFSGetSingleFileInfo::generated_message_descriptor_data());
            messages.push(CMsgClientUFSGetSingleFileInfoResponse::generated_message_descriptor_data());
            messages.push(CMsgClientUFSShareFile::generated_message_descriptor_data());
            messages.push(CMsgClientUFSShareFileResponse::generated_message_descriptor_data());
            messages.push(CMsgClientAMGetClanOfficers::generated_message_descriptor_data());
            messages.push(CMsgClientAMGetClanOfficersResponse::generated_message_descriptor_data());
            messages.push(CMsgClientAMGetPersonaNameHistory::generated_message_descriptor_data());
            messages.push(CMsgClientAMGetPersonaNameHistoryResponse::generated_message_descriptor_data());
            messages.push(CMsgClientDeregisterWithServer::generated_message_descriptor_data());
            messages.push(CMsgClientClanState::generated_message_descriptor_data());
            messages.push(CMsgClientUnsignedInstallScript::generated_message_descriptor_data());
            messages.push(cmsg_gsplayer_list::Player::generated_message_descriptor_data());
            messages.push(cmsg_client_games_played::GamePlayed::generated_message_descriptor_data());
            messages.push(cmsg_client_license_list::License::generated_message_descriptor_data());
            messages.push(cmsg_client_lbsget_lbentries_response::Entry::generated_message_descriptor_data());
            messages.push(cmsg_client_requested_client_stats::StatsToSend::generated_message_descriptor_data());
            messages.push(cmsg_client_stat2::StatDetail::generated_message_descriptor_data());
            messages.push(cmsg_client_mmsjoin_lobby_response::Member::generated_message_descriptor_data());
            messages.push(cmsg_client_mmsget_lobby_list::Filter::generated_message_descriptor_data());
            messages.push(cmsg_client_mmsget_lobby_list_response::Lobby::generated_message_descriptor_data());
            messages.push(cmsg_client_mmslobby_data::Member::generated_message_descriptor_data());
            messages.push(cmsg_client_connection_stats::Stats_Logon::generated_message_descriptor_data());
            messages.push(cmsg_client_connection_stats::Stats_UDP::generated_message_descriptor_data());
            messages.push(cmsg_client_connection_stats::Stats_VConn::generated_message_descriptor_data());
            messages.push(cmsg_client_servers_available::Server_Types_Available::generated_message_descriptor_data());
            messages.push(cmsg_client_get_user_stats_response::Stats::generated_message_descriptor_data());
            messages.push(cmsg_client_get_user_stats_response::Achievement_Blocks::generated_message_descriptor_data());
            messages.push(cmsg_client_store_user_stats_response::Stats_Failed_Validation::generated_message_descriptor_data());
            messages.push(cmsg_client_store_user_stats2::Stats::generated_message_descriptor_data());
            messages.push(cmsg_client_stats_updated::Updated_Stats::generated_message_descriptor_data());
            messages.push(cmsg_client_store_user_stats::Stats_To_Store::generated_message_descriptor_data());
            messages.push(cmsg_client_get_client_details_response::Game::generated_message_descriptor_data());
            messages.push(cmsg_client_get_client_app_list_response::App::generated_message_descriptor_data());
            messages.push(cmsg_client_get_client_app_list_response::app::DLC::generated_message_descriptor_data());
            messages.push(cmsg_client_ufsupload_commit::File::generated_message_descriptor_data());
            messages.push(cmsg_client_ufsupload_commit_response::File::generated_message_descriptor_data());
            messages.push(cmsg_client_ufsget_file_list_for_app_response::File::generated_message_descriptor_data());
            messages.push(cmsg_client_app_info_request::App::generated_message_descriptor_data());
            messages.push(cmsg_client_app_info_response::App::generated_message_descriptor_data());
            messages.push(cmsg_client_app_info_response::app::Section::generated_message_descriptor_data());
            messages.push(cmsg_client_package_info_response::Package::generated_message_descriptor_data());
            messages.push(cmsg_client_picschanges_since_response::PackageChange::generated_message_descriptor_data());
            messages.push(cmsg_client_picschanges_since_response::AppChange::generated_message_descriptor_data());
            messages.push(cmsg_client_picsproduct_info_request::AppInfo::generated_message_descriptor_data());
            messages.push(cmsg_client_picsproduct_info_request::PackageInfo::generated_message_descriptor_data());
            messages.push(cmsg_client_picsproduct_info_response::AppInfo::generated_message_descriptor_data());
            messages.push(cmsg_client_picsproduct_info_response::PackageInfo::generated_message_descriptor_data());
            messages.push(cmsg_client_picsaccess_token_response::PackageToken::generated_message_descriptor_data());
            messages.push(cmsg_client_picsaccess_token_response::AppToken::generated_message_descriptor_data());
            messages.push(cmsg_client_amget_persona_name_history::IdInstance::generated_message_descriptor_data());
            messages.push(cmsg_client_amget_persona_name_history_response::NameTableInstance::generated_message_descriptor_data());
            messages.push(cmsg_client_amget_persona_name_history_response::name_table_instance::NameInstance::generated_message_descriptor_data());
            messages.push(cmsg_client_clan_state::NameInfo::generated_message_descriptor_data());
            messages.push(cmsg_client_clan_state::UserCounts::generated_message_descriptor_data());
            messages.push(cmsg_client_clan_state::Event::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(EMMSLobbyStatus::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
