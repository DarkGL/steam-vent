// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `htmlmessages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:CMsgKeyUp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgKeyUp {
    // message fields
    // @@protoc_insertion_point(field:CMsgKeyUp.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgKeyUp.keyCode)
    pub keyCode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgKeyUp.modifiers)
    pub modifiers: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgKeyUp.nativeKeyCode)
    pub nativeKeyCode: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgKeyUp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgKeyUp {
    fn default() -> &'a CMsgKeyUp {
        <CMsgKeyUp as ::protobuf::Message>::default_instance()
    }
}

impl CMsgKeyUp {
    pub fn new() -> CMsgKeyUp {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 keyCode = 2;

    pub fn keyCode(&self) -> u32 {
        self.keyCode.unwrap_or(0)
    }

    pub fn clear_keyCode(&mut self) {
        self.keyCode = ::std::option::Option::None;
    }

    pub fn has_keyCode(&self) -> bool {
        self.keyCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyCode(&mut self, v: u32) {
        self.keyCode = ::std::option::Option::Some(v);
    }

    // optional uint32 modifiers = 3;

    pub fn modifiers(&self) -> u32 {
        self.modifiers.unwrap_or(0)
    }

    pub fn clear_modifiers(&mut self) {
        self.modifiers = ::std::option::Option::None;
    }

    pub fn has_modifiers(&self) -> bool {
        self.modifiers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifiers(&mut self, v: u32) {
        self.modifiers = ::std::option::Option::Some(v);
    }

    // optional uint32 nativeKeyCode = 4;

    pub fn nativeKeyCode(&self) -> u32 {
        self.nativeKeyCode.unwrap_or(0)
    }

    pub fn clear_nativeKeyCode(&mut self) {
        self.nativeKeyCode = ::std::option::Option::None;
    }

    pub fn has_nativeKeyCode(&self) -> bool {
        self.nativeKeyCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nativeKeyCode(&mut self, v: u32) {
        self.nativeKeyCode = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgKeyUp| { &m.browser_handle },
            |m: &mut CMsgKeyUp| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "keyCode",
            |m: &CMsgKeyUp| { &m.keyCode },
            |m: &mut CMsgKeyUp| { &mut m.keyCode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "modifiers",
            |m: &CMsgKeyUp| { &m.modifiers },
            |m: &mut CMsgKeyUp| { &mut m.modifiers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nativeKeyCode",
            |m: &CMsgKeyUp| { &m.nativeKeyCode },
            |m: &mut CMsgKeyUp| { &mut m.nativeKeyCode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgKeyUp>(
            "CMsgKeyUp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgKeyUp {
    const NAME: &'static str = "CMsgKeyUp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.keyCode = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.modifiers = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.nativeKeyCode = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.keyCode {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.modifiers {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.nativeKeyCode {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.keyCode {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.modifiers {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.nativeKeyCode {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgKeyUp {
        CMsgKeyUp::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.keyCode = ::std::option::Option::None;
        self.modifiers = ::std::option::Option::None;
        self.nativeKeyCode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgKeyUp {
        static instance: CMsgKeyUp = CMsgKeyUp {
            browser_handle: ::std::option::Option::None,
            keyCode: ::std::option::Option::None,
            modifiers: ::std::option::Option::None,
            nativeKeyCode: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgKeyUp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgKeyUp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgKeyUp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgKeyUp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgKeyDown)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgKeyDown {
    // message fields
    // @@protoc_insertion_point(field:CMsgKeyDown.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgKeyDown.keyCode)
    pub keyCode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgKeyDown.modifiers)
    pub modifiers: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgKeyDown.is_system_key)
    pub is_system_key: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgKeyDown.nativeKeyCode)
    pub nativeKeyCode: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgKeyDown.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgKeyDown {
    fn default() -> &'a CMsgKeyDown {
        <CMsgKeyDown as ::protobuf::Message>::default_instance()
    }
}

impl CMsgKeyDown {
    pub fn new() -> CMsgKeyDown {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 keyCode = 2;

    pub fn keyCode(&self) -> u32 {
        self.keyCode.unwrap_or(0)
    }

    pub fn clear_keyCode(&mut self) {
        self.keyCode = ::std::option::Option::None;
    }

    pub fn has_keyCode(&self) -> bool {
        self.keyCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyCode(&mut self, v: u32) {
        self.keyCode = ::std::option::Option::Some(v);
    }

    // optional uint32 modifiers = 3;

    pub fn modifiers(&self) -> u32 {
        self.modifiers.unwrap_or(0)
    }

    pub fn clear_modifiers(&mut self) {
        self.modifiers = ::std::option::Option::None;
    }

    pub fn has_modifiers(&self) -> bool {
        self.modifiers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifiers(&mut self, v: u32) {
        self.modifiers = ::std::option::Option::Some(v);
    }

    // optional bool is_system_key = 4;

    pub fn is_system_key(&self) -> bool {
        self.is_system_key.unwrap_or(false)
    }

    pub fn clear_is_system_key(&mut self) {
        self.is_system_key = ::std::option::Option::None;
    }

    pub fn has_is_system_key(&self) -> bool {
        self.is_system_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_system_key(&mut self, v: bool) {
        self.is_system_key = ::std::option::Option::Some(v);
    }

    // optional uint32 nativeKeyCode = 5;

    pub fn nativeKeyCode(&self) -> u32 {
        self.nativeKeyCode.unwrap_or(0)
    }

    pub fn clear_nativeKeyCode(&mut self) {
        self.nativeKeyCode = ::std::option::Option::None;
    }

    pub fn has_nativeKeyCode(&self) -> bool {
        self.nativeKeyCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nativeKeyCode(&mut self, v: u32) {
        self.nativeKeyCode = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgKeyDown| { &m.browser_handle },
            |m: &mut CMsgKeyDown| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "keyCode",
            |m: &CMsgKeyDown| { &m.keyCode },
            |m: &mut CMsgKeyDown| { &mut m.keyCode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "modifiers",
            |m: &CMsgKeyDown| { &m.modifiers },
            |m: &mut CMsgKeyDown| { &mut m.modifiers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_system_key",
            |m: &CMsgKeyDown| { &m.is_system_key },
            |m: &mut CMsgKeyDown| { &mut m.is_system_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nativeKeyCode",
            |m: &CMsgKeyDown| { &m.nativeKeyCode },
            |m: &mut CMsgKeyDown| { &mut m.nativeKeyCode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgKeyDown>(
            "CMsgKeyDown",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgKeyDown {
    const NAME: &'static str = "CMsgKeyDown";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.keyCode = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.modifiers = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.is_system_key = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.nativeKeyCode = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.keyCode {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.modifiers {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.is_system_key {
            my_size += 1 + 1;
        }
        if let Some(v) = self.nativeKeyCode {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.keyCode {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.modifiers {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.is_system_key {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.nativeKeyCode {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgKeyDown {
        CMsgKeyDown::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.keyCode = ::std::option::Option::None;
        self.modifiers = ::std::option::Option::None;
        self.is_system_key = ::std::option::Option::None;
        self.nativeKeyCode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgKeyDown {
        static instance: CMsgKeyDown = CMsgKeyDown {
            browser_handle: ::std::option::Option::None,
            keyCode: ::std::option::Option::None,
            modifiers: ::std::option::Option::None,
            is_system_key: ::std::option::Option::None,
            nativeKeyCode: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgKeyDown {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgKeyDown").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgKeyDown {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgKeyDown {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgKeyChar)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgKeyChar {
    // message fields
    // @@protoc_insertion_point(field:CMsgKeyChar.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgKeyChar.unichar)
    pub unichar: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgKeyChar.modifiers)
    pub modifiers: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgKeyChar.keyCode)
    pub keyCode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgKeyChar.nativeKeyCode)
    pub nativeKeyCode: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgKeyChar.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgKeyChar {
    fn default() -> &'a CMsgKeyChar {
        <CMsgKeyChar as ::protobuf::Message>::default_instance()
    }
}

impl CMsgKeyChar {
    pub fn new() -> CMsgKeyChar {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 unichar = 2;

    pub fn unichar(&self) -> u32 {
        self.unichar.unwrap_or(0)
    }

    pub fn clear_unichar(&mut self) {
        self.unichar = ::std::option::Option::None;
    }

    pub fn has_unichar(&self) -> bool {
        self.unichar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unichar(&mut self, v: u32) {
        self.unichar = ::std::option::Option::Some(v);
    }

    // optional uint32 modifiers = 3;

    pub fn modifiers(&self) -> u32 {
        self.modifiers.unwrap_or(0)
    }

    pub fn clear_modifiers(&mut self) {
        self.modifiers = ::std::option::Option::None;
    }

    pub fn has_modifiers(&self) -> bool {
        self.modifiers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifiers(&mut self, v: u32) {
        self.modifiers = ::std::option::Option::Some(v);
    }

    // optional uint32 keyCode = 4;

    pub fn keyCode(&self) -> u32 {
        self.keyCode.unwrap_or(0)
    }

    pub fn clear_keyCode(&mut self) {
        self.keyCode = ::std::option::Option::None;
    }

    pub fn has_keyCode(&self) -> bool {
        self.keyCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyCode(&mut self, v: u32) {
        self.keyCode = ::std::option::Option::Some(v);
    }

    // optional uint32 nativeKeyCode = 5;

    pub fn nativeKeyCode(&self) -> u32 {
        self.nativeKeyCode.unwrap_or(0)
    }

    pub fn clear_nativeKeyCode(&mut self) {
        self.nativeKeyCode = ::std::option::Option::None;
    }

    pub fn has_nativeKeyCode(&self) -> bool {
        self.nativeKeyCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nativeKeyCode(&mut self, v: u32) {
        self.nativeKeyCode = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgKeyChar| { &m.browser_handle },
            |m: &mut CMsgKeyChar| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unichar",
            |m: &CMsgKeyChar| { &m.unichar },
            |m: &mut CMsgKeyChar| { &mut m.unichar },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "modifiers",
            |m: &CMsgKeyChar| { &m.modifiers },
            |m: &mut CMsgKeyChar| { &mut m.modifiers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "keyCode",
            |m: &CMsgKeyChar| { &m.keyCode },
            |m: &mut CMsgKeyChar| { &mut m.keyCode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nativeKeyCode",
            |m: &CMsgKeyChar| { &m.nativeKeyCode },
            |m: &mut CMsgKeyChar| { &mut m.nativeKeyCode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgKeyChar>(
            "CMsgKeyChar",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgKeyChar {
    const NAME: &'static str = "CMsgKeyChar";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.unichar = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.modifiers = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.keyCode = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.nativeKeyCode = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.unichar {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.modifiers {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.keyCode {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.nativeKeyCode {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.unichar {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.modifiers {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.keyCode {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.nativeKeyCode {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgKeyChar {
        CMsgKeyChar::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unichar = ::std::option::Option::None;
        self.modifiers = ::std::option::Option::None;
        self.keyCode = ::std::option::Option::None;
        self.nativeKeyCode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgKeyChar {
        static instance: CMsgKeyChar = CMsgKeyChar {
            browser_handle: ::std::option::Option::None,
            unichar: ::std::option::Option::None,
            modifiers: ::std::option::Option::None,
            keyCode: ::std::option::Option::None,
            nativeKeyCode: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgKeyChar {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgKeyChar").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgKeyChar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgKeyChar {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgMouseDown)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMouseDown {
    // message fields
    // @@protoc_insertion_point(field:CMsgMouseDown.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMouseDown.mouse_button)
    pub mouse_button: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMouseDown.modifiers)
    pub modifiers: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMouseDown.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMouseDown {
    fn default() -> &'a CMsgMouseDown {
        <CMsgMouseDown as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMouseDown {
    pub fn new() -> CMsgMouseDown {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 mouse_button = 2;

    pub fn mouse_button(&self) -> u32 {
        self.mouse_button.unwrap_or(0)
    }

    pub fn clear_mouse_button(&mut self) {
        self.mouse_button = ::std::option::Option::None;
    }

    pub fn has_mouse_button(&self) -> bool {
        self.mouse_button.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mouse_button(&mut self, v: u32) {
        self.mouse_button = ::std::option::Option::Some(v);
    }

    // optional uint32 modifiers = 3;

    pub fn modifiers(&self) -> u32 {
        self.modifiers.unwrap_or(0)
    }

    pub fn clear_modifiers(&mut self) {
        self.modifiers = ::std::option::Option::None;
    }

    pub fn has_modifiers(&self) -> bool {
        self.modifiers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifiers(&mut self, v: u32) {
        self.modifiers = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgMouseDown| { &m.browser_handle },
            |m: &mut CMsgMouseDown| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mouse_button",
            |m: &CMsgMouseDown| { &m.mouse_button },
            |m: &mut CMsgMouseDown| { &mut m.mouse_button },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "modifiers",
            |m: &CMsgMouseDown| { &m.modifiers },
            |m: &mut CMsgMouseDown| { &mut m.modifiers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgMouseDown>(
            "CMsgMouseDown",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgMouseDown {
    const NAME: &'static str = "CMsgMouseDown";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.mouse_button = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.modifiers = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.mouse_button {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.modifiers {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.mouse_button {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.modifiers {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMouseDown {
        CMsgMouseDown::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.mouse_button = ::std::option::Option::None;
        self.modifiers = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMouseDown {
        static instance: CMsgMouseDown = CMsgMouseDown {
            browser_handle: ::std::option::Option::None,
            mouse_button: ::std::option::Option::None,
            modifiers: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgMouseDown {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgMouseDown").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgMouseDown {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMouseDown {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgMouseUp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMouseUp {
    // message fields
    // @@protoc_insertion_point(field:CMsgMouseUp.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMouseUp.mouse_button)
    pub mouse_button: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMouseUp.modifiers)
    pub modifiers: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMouseUp.is_off_panel)
    pub is_off_panel: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgMouseUp.x)
    pub x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgMouseUp.y)
    pub y: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMouseUp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMouseUp {
    fn default() -> &'a CMsgMouseUp {
        <CMsgMouseUp as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMouseUp {
    pub fn new() -> CMsgMouseUp {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 mouse_button = 2;

    pub fn mouse_button(&self) -> u32 {
        self.mouse_button.unwrap_or(0)
    }

    pub fn clear_mouse_button(&mut self) {
        self.mouse_button = ::std::option::Option::None;
    }

    pub fn has_mouse_button(&self) -> bool {
        self.mouse_button.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mouse_button(&mut self, v: u32) {
        self.mouse_button = ::std::option::Option::Some(v);
    }

    // optional uint32 modifiers = 3;

    pub fn modifiers(&self) -> u32 {
        self.modifiers.unwrap_or(0)
    }

    pub fn clear_modifiers(&mut self) {
        self.modifiers = ::std::option::Option::None;
    }

    pub fn has_modifiers(&self) -> bool {
        self.modifiers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifiers(&mut self, v: u32) {
        self.modifiers = ::std::option::Option::Some(v);
    }

    // optional bool is_off_panel = 4;

    pub fn is_off_panel(&self) -> bool {
        self.is_off_panel.unwrap_or(false)
    }

    pub fn clear_is_off_panel(&mut self) {
        self.is_off_panel = ::std::option::Option::None;
    }

    pub fn has_is_off_panel(&self) -> bool {
        self.is_off_panel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_off_panel(&mut self, v: bool) {
        self.is_off_panel = ::std::option::Option::Some(v);
    }

    // optional int32 x = 5;

    pub fn x(&self) -> i32 {
        self.x.unwrap_or(0)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: i32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional int32 y = 6;

    pub fn y(&self) -> i32 {
        self.y.unwrap_or(0)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: i32) {
        self.y = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgMouseUp| { &m.browser_handle },
            |m: &mut CMsgMouseUp| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mouse_button",
            |m: &CMsgMouseUp| { &m.mouse_button },
            |m: &mut CMsgMouseUp| { &mut m.mouse_button },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "modifiers",
            |m: &CMsgMouseUp| { &m.modifiers },
            |m: &mut CMsgMouseUp| { &mut m.modifiers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_off_panel",
            |m: &CMsgMouseUp| { &m.is_off_panel },
            |m: &mut CMsgMouseUp| { &mut m.is_off_panel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &CMsgMouseUp| { &m.x },
            |m: &mut CMsgMouseUp| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &CMsgMouseUp| { &m.y },
            |m: &mut CMsgMouseUp| { &mut m.y },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgMouseUp>(
            "CMsgMouseUp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgMouseUp {
    const NAME: &'static str = "CMsgMouseUp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.mouse_button = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.modifiers = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.is_off_panel = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.x = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.y = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.mouse_button {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.modifiers {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.is_off_panel {
            my_size += 1 + 1;
        }
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.mouse_button {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.modifiers {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.is_off_panel {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.x {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.y {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMouseUp {
        CMsgMouseUp::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.mouse_button = ::std::option::Option::None;
        self.modifiers = ::std::option::Option::None;
        self.is_off_panel = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMouseUp {
        static instance: CMsgMouseUp = CMsgMouseUp {
            browser_handle: ::std::option::Option::None,
            mouse_button: ::std::option::Option::None,
            modifiers: ::std::option::Option::None,
            is_off_panel: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgMouseUp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgMouseUp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgMouseUp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMouseUp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgMouseDblClick)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMouseDblClick {
    // message fields
    // @@protoc_insertion_point(field:CMsgMouseDblClick.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMouseDblClick.mouse_button)
    pub mouse_button: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMouseDblClick.modifiers)
    pub modifiers: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMouseDblClick.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMouseDblClick {
    fn default() -> &'a CMsgMouseDblClick {
        <CMsgMouseDblClick as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMouseDblClick {
    pub fn new() -> CMsgMouseDblClick {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 mouse_button = 2;

    pub fn mouse_button(&self) -> u32 {
        self.mouse_button.unwrap_or(0)
    }

    pub fn clear_mouse_button(&mut self) {
        self.mouse_button = ::std::option::Option::None;
    }

    pub fn has_mouse_button(&self) -> bool {
        self.mouse_button.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mouse_button(&mut self, v: u32) {
        self.mouse_button = ::std::option::Option::Some(v);
    }

    // optional uint32 modifiers = 3;

    pub fn modifiers(&self) -> u32 {
        self.modifiers.unwrap_or(0)
    }

    pub fn clear_modifiers(&mut self) {
        self.modifiers = ::std::option::Option::None;
    }

    pub fn has_modifiers(&self) -> bool {
        self.modifiers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifiers(&mut self, v: u32) {
        self.modifiers = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgMouseDblClick| { &m.browser_handle },
            |m: &mut CMsgMouseDblClick| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mouse_button",
            |m: &CMsgMouseDblClick| { &m.mouse_button },
            |m: &mut CMsgMouseDblClick| { &mut m.mouse_button },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "modifiers",
            |m: &CMsgMouseDblClick| { &m.modifiers },
            |m: &mut CMsgMouseDblClick| { &mut m.modifiers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgMouseDblClick>(
            "CMsgMouseDblClick",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgMouseDblClick {
    const NAME: &'static str = "CMsgMouseDblClick";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.mouse_button = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.modifiers = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.mouse_button {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.modifiers {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.mouse_button {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.modifiers {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMouseDblClick {
        CMsgMouseDblClick::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.mouse_button = ::std::option::Option::None;
        self.modifiers = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMouseDblClick {
        static instance: CMsgMouseDblClick = CMsgMouseDblClick {
            browser_handle: ::std::option::Option::None,
            mouse_button: ::std::option::Option::None,
            modifiers: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgMouseDblClick {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgMouseDblClick").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgMouseDblClick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMouseDblClick {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgMouseWheel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMouseWheel {
    // message fields
    // @@protoc_insertion_point(field:CMsgMouseWheel.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMouseWheel.deltax)
    pub deltax: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgMouseWheel.deltay)
    pub deltay: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgMouseWheel.modifiers)
    pub modifiers: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMouseWheel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMouseWheel {
    fn default() -> &'a CMsgMouseWheel {
        <CMsgMouseWheel as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMouseWheel {
    pub fn new() -> CMsgMouseWheel {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional int32 deltax = 2;

    pub fn deltax(&self) -> i32 {
        self.deltax.unwrap_or(0)
    }

    pub fn clear_deltax(&mut self) {
        self.deltax = ::std::option::Option::None;
    }

    pub fn has_deltax(&self) -> bool {
        self.deltax.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deltax(&mut self, v: i32) {
        self.deltax = ::std::option::Option::Some(v);
    }

    // optional int32 deltay = 3;

    pub fn deltay(&self) -> i32 {
        self.deltay.unwrap_or(0)
    }

    pub fn clear_deltay(&mut self) {
        self.deltay = ::std::option::Option::None;
    }

    pub fn has_deltay(&self) -> bool {
        self.deltay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deltay(&mut self, v: i32) {
        self.deltay = ::std::option::Option::Some(v);
    }

    // optional uint32 modifiers = 4;

    pub fn modifiers(&self) -> u32 {
        self.modifiers.unwrap_or(0)
    }

    pub fn clear_modifiers(&mut self) {
        self.modifiers = ::std::option::Option::None;
    }

    pub fn has_modifiers(&self) -> bool {
        self.modifiers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifiers(&mut self, v: u32) {
        self.modifiers = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgMouseWheel| { &m.browser_handle },
            |m: &mut CMsgMouseWheel| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deltax",
            |m: &CMsgMouseWheel| { &m.deltax },
            |m: &mut CMsgMouseWheel| { &mut m.deltax },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deltay",
            |m: &CMsgMouseWheel| { &m.deltay },
            |m: &mut CMsgMouseWheel| { &mut m.deltay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "modifiers",
            |m: &CMsgMouseWheel| { &m.modifiers },
            |m: &mut CMsgMouseWheel| { &mut m.modifiers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgMouseWheel>(
            "CMsgMouseWheel",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgMouseWheel {
    const NAME: &'static str = "CMsgMouseWheel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.deltax = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.deltay = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.modifiers = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.deltax {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.deltay {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.modifiers {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.deltax {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.deltay {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.modifiers {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMouseWheel {
        CMsgMouseWheel::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.deltax = ::std::option::Option::None;
        self.deltay = ::std::option::Option::None;
        self.modifiers = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMouseWheel {
        static instance: CMsgMouseWheel = CMsgMouseWheel {
            browser_handle: ::std::option::Option::None,
            deltax: ::std::option::Option::None,
            deltay: ::std::option::Option::None,
            modifiers: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgMouseWheel {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgMouseWheel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgMouseWheel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMouseWheel {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgMouseMove)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMouseMove {
    // message fields
    // @@protoc_insertion_point(field:CMsgMouseMove.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMouseMove.x)
    pub x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgMouseMove.y)
    pub y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgMouseMove.modifiers)
    pub modifiers: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMouseMove.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMouseMove {
    fn default() -> &'a CMsgMouseMove {
        <CMsgMouseMove as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMouseMove {
    pub fn new() -> CMsgMouseMove {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional int32 x = 2;

    pub fn x(&self) -> i32 {
        self.x.unwrap_or(0)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: i32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional int32 y = 3;

    pub fn y(&self) -> i32 {
        self.y.unwrap_or(0)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: i32) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional uint32 modifiers = 4;

    pub fn modifiers(&self) -> u32 {
        self.modifiers.unwrap_or(0)
    }

    pub fn clear_modifiers(&mut self) {
        self.modifiers = ::std::option::Option::None;
    }

    pub fn has_modifiers(&self) -> bool {
        self.modifiers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifiers(&mut self, v: u32) {
        self.modifiers = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgMouseMove| { &m.browser_handle },
            |m: &mut CMsgMouseMove| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &CMsgMouseMove| { &m.x },
            |m: &mut CMsgMouseMove| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &CMsgMouseMove| { &m.y },
            |m: &mut CMsgMouseMove| { &mut m.y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "modifiers",
            |m: &CMsgMouseMove| { &m.modifiers },
            |m: &mut CMsgMouseMove| { &mut m.modifiers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgMouseMove>(
            "CMsgMouseMove",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgMouseMove {
    const NAME: &'static str = "CMsgMouseMove";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.x = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.y = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.modifiers = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.modifiers {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.modifiers {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMouseMove {
        CMsgMouseMove::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.modifiers = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMouseMove {
        static instance: CMsgMouseMove = CMsgMouseMove {
            browser_handle: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            modifiers: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgMouseMove {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgMouseMove").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgMouseMove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMouseMove {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgMouseLeave)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMouseLeave {
    // message fields
    // @@protoc_insertion_point(field:CMsgMouseLeave.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMouseLeave.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMouseLeave {
    fn default() -> &'a CMsgMouseLeave {
        <CMsgMouseLeave as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMouseLeave {
    pub fn new() -> CMsgMouseLeave {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgMouseLeave| { &m.browser_handle },
            |m: &mut CMsgMouseLeave| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgMouseLeave>(
            "CMsgMouseLeave",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgMouseLeave {
    const NAME: &'static str = "CMsgMouseLeave";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMouseLeave {
        CMsgMouseLeave::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMouseLeave {
        static instance: CMsgMouseLeave = CMsgMouseLeave {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgMouseLeave {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgMouseLeave").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgMouseLeave {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMouseLeave {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgBrowserCreate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBrowserCreate {
    // message fields
    // @@protoc_insertion_point(field:CMsgBrowserCreate.request_id)
    pub request_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.useragent)
    pub useragent: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.user_css)
    pub user_css: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.native_dropdowns)
    pub native_dropdowns: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.dpi_scaling)
    pub dpi_scaling: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.offscreen)
    pub offscreen: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.initial_width)
    pub initial_width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.initial_height)
    pub initial_height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.window_icon)
    pub window_icon: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.borderless)
    pub borderless: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.vroverlay_key)
    pub vroverlay_key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.browser_type)
    pub browser_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.initial_top)
    pub initial_top: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.initial_left)
    pub initial_left: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.only_allow_trusted_popups)
    pub only_allow_trusted_popups: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.initial_url)
    pub initial_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBrowserCreate.hwnd_parent)
    pub hwnd_parent: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBrowserCreate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserCreate {
    fn default() -> &'a CMsgBrowserCreate {
        <CMsgBrowserCreate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBrowserCreate {
    pub fn new() -> CMsgBrowserCreate {
        ::std::default::Default::default()
    }

    // optional uint32 request_id = 1;

    pub fn request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional string useragent = 3;

    pub fn useragent(&self) -> &str {
        match self.useragent.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_useragent(&mut self) {
        self.useragent = ::std::option::Option::None;
    }

    pub fn has_useragent(&self) -> bool {
        self.useragent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_useragent(&mut self, v: ::std::string::String) {
        self.useragent = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_useragent(&mut self) -> &mut ::std::string::String {
        if self.useragent.is_none() {
            self.useragent = ::std::option::Option::Some(::std::string::String::new());
        }
        self.useragent.as_mut().unwrap()
    }

    // Take field
    pub fn take_useragent(&mut self) -> ::std::string::String {
        self.useragent.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string user_css = 5;

    pub fn user_css(&self) -> &str {
        match self.user_css.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_user_css(&mut self) {
        self.user_css = ::std::option::Option::None;
    }

    pub fn has_user_css(&self) -> bool {
        self.user_css.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_css(&mut self, v: ::std::string::String) {
        self.user_css = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_css(&mut self) -> &mut ::std::string::String {
        if self.user_css.is_none() {
            self.user_css = ::std::option::Option::Some(::std::string::String::new());
        }
        self.user_css.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_css(&mut self) -> ::std::string::String {
        self.user_css.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool native_dropdowns = 6;

    pub fn native_dropdowns(&self) -> bool {
        self.native_dropdowns.unwrap_or(false)
    }

    pub fn clear_native_dropdowns(&mut self) {
        self.native_dropdowns = ::std::option::Option::None;
    }

    pub fn has_native_dropdowns(&self) -> bool {
        self.native_dropdowns.is_some()
    }

    // Param is passed by value, moved
    pub fn set_native_dropdowns(&mut self, v: bool) {
        self.native_dropdowns = ::std::option::Option::Some(v);
    }

    // optional float dpi_scaling = 7;

    pub fn dpi_scaling(&self) -> f32 {
        self.dpi_scaling.unwrap_or(0.)
    }

    pub fn clear_dpi_scaling(&mut self) {
        self.dpi_scaling = ::std::option::Option::None;
    }

    pub fn has_dpi_scaling(&self) -> bool {
        self.dpi_scaling.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dpi_scaling(&mut self, v: f32) {
        self.dpi_scaling = ::std::option::Option::Some(v);
    }

    // optional bool offscreen = 8;

    pub fn offscreen(&self) -> bool {
        self.offscreen.unwrap_or(true)
    }

    pub fn clear_offscreen(&mut self) {
        self.offscreen = ::std::option::Option::None;
    }

    pub fn has_offscreen(&self) -> bool {
        self.offscreen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offscreen(&mut self, v: bool) {
        self.offscreen = ::std::option::Option::Some(v);
    }

    // optional uint32 initial_width = 9;

    pub fn initial_width(&self) -> u32 {
        self.initial_width.unwrap_or(0u32)
    }

    pub fn clear_initial_width(&mut self) {
        self.initial_width = ::std::option::Option::None;
    }

    pub fn has_initial_width(&self) -> bool {
        self.initial_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_width(&mut self, v: u32) {
        self.initial_width = ::std::option::Option::Some(v);
    }

    // optional uint32 initial_height = 10;

    pub fn initial_height(&self) -> u32 {
        self.initial_height.unwrap_or(0u32)
    }

    pub fn clear_initial_height(&mut self) {
        self.initial_height = ::std::option::Option::None;
    }

    pub fn has_initial_height(&self) -> bool {
        self.initial_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_height(&mut self, v: u32) {
        self.initial_height = ::std::option::Option::Some(v);
    }

    // optional string window_icon = 11;

    pub fn window_icon(&self) -> &str {
        match self.window_icon.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_window_icon(&mut self) {
        self.window_icon = ::std::option::Option::None;
    }

    pub fn has_window_icon(&self) -> bool {
        self.window_icon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_window_icon(&mut self, v: ::std::string::String) {
        self.window_icon = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_window_icon(&mut self) -> &mut ::std::string::String {
        if self.window_icon.is_none() {
            self.window_icon = ::std::option::Option::Some(::std::string::String::new());
        }
        self.window_icon.as_mut().unwrap()
    }

    // Take field
    pub fn take_window_icon(&mut self) -> ::std::string::String {
        self.window_icon.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool borderless = 12;

    pub fn borderless(&self) -> bool {
        self.borderless.unwrap_or(false)
    }

    pub fn clear_borderless(&mut self) {
        self.borderless = ::std::option::Option::None;
    }

    pub fn has_borderless(&self) -> bool {
        self.borderless.is_some()
    }

    // Param is passed by value, moved
    pub fn set_borderless(&mut self, v: bool) {
        self.borderless = ::std::option::Option::Some(v);
    }

    // optional string vroverlay_key = 13;

    pub fn vroverlay_key(&self) -> &str {
        match self.vroverlay_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_vroverlay_key(&mut self) {
        self.vroverlay_key = ::std::option::Option::None;
    }

    pub fn has_vroverlay_key(&self) -> bool {
        self.vroverlay_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vroverlay_key(&mut self, v: ::std::string::String) {
        self.vroverlay_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vroverlay_key(&mut self) -> &mut ::std::string::String {
        if self.vroverlay_key.is_none() {
            self.vroverlay_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.vroverlay_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_vroverlay_key(&mut self) -> ::std::string::String {
        self.vroverlay_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 browser_type = 14;

    pub fn browser_type(&self) -> u32 {
        self.browser_type.unwrap_or(0u32)
    }

    pub fn clear_browser_type(&mut self) {
        self.browser_type = ::std::option::Option::None;
    }

    pub fn has_browser_type(&self) -> bool {
        self.browser_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_type(&mut self, v: u32) {
        self.browser_type = ::std::option::Option::Some(v);
    }

    // optional int32 initial_top = 15;

    pub fn initial_top(&self) -> i32 {
        self.initial_top.unwrap_or(-2147483648i32)
    }

    pub fn clear_initial_top(&mut self) {
        self.initial_top = ::std::option::Option::None;
    }

    pub fn has_initial_top(&self) -> bool {
        self.initial_top.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_top(&mut self, v: i32) {
        self.initial_top = ::std::option::Option::Some(v);
    }

    // optional int32 initial_left = 16;

    pub fn initial_left(&self) -> i32 {
        self.initial_left.unwrap_or(-2147483648i32)
    }

    pub fn clear_initial_left(&mut self) {
        self.initial_left = ::std::option::Option::None;
    }

    pub fn has_initial_left(&self) -> bool {
        self.initial_left.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_left(&mut self, v: i32) {
        self.initial_left = ::std::option::Option::Some(v);
    }

    // optional bool only_allow_trusted_popups = 17;

    pub fn only_allow_trusted_popups(&self) -> bool {
        self.only_allow_trusted_popups.unwrap_or(false)
    }

    pub fn clear_only_allow_trusted_popups(&mut self) {
        self.only_allow_trusted_popups = ::std::option::Option::None;
    }

    pub fn has_only_allow_trusted_popups(&self) -> bool {
        self.only_allow_trusted_popups.is_some()
    }

    // Param is passed by value, moved
    pub fn set_only_allow_trusted_popups(&mut self, v: bool) {
        self.only_allow_trusted_popups = ::std::option::Option::Some(v);
    }

    // optional string initial_url = 18;

    pub fn initial_url(&self) -> &str {
        match self.initial_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_initial_url(&mut self) {
        self.initial_url = ::std::option::Option::None;
    }

    pub fn has_initial_url(&self) -> bool {
        self.initial_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_url(&mut self, v: ::std::string::String) {
        self.initial_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initial_url(&mut self) -> &mut ::std::string::String {
        if self.initial_url.is_none() {
            self.initial_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.initial_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_initial_url(&mut self) -> ::std::string::String {
        self.initial_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 hwnd_parent = 19;

    pub fn hwnd_parent(&self) -> u64 {
        self.hwnd_parent.unwrap_or(0)
    }

    pub fn clear_hwnd_parent(&mut self) {
        self.hwnd_parent = ::std::option::Option::None;
    }

    pub fn has_hwnd_parent(&self) -> bool {
        self.hwnd_parent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hwnd_parent(&mut self, v: u64) {
        self.hwnd_parent = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(17);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_id",
            |m: &CMsgBrowserCreate| { &m.request_id },
            |m: &mut CMsgBrowserCreate| { &mut m.request_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "useragent",
            |m: &CMsgBrowserCreate| { &m.useragent },
            |m: &mut CMsgBrowserCreate| { &mut m.useragent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user_css",
            |m: &CMsgBrowserCreate| { &m.user_css },
            |m: &mut CMsgBrowserCreate| { &mut m.user_css },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "native_dropdowns",
            |m: &CMsgBrowserCreate| { &m.native_dropdowns },
            |m: &mut CMsgBrowserCreate| { &mut m.native_dropdowns },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dpi_scaling",
            |m: &CMsgBrowserCreate| { &m.dpi_scaling },
            |m: &mut CMsgBrowserCreate| { &mut m.dpi_scaling },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "offscreen",
            |m: &CMsgBrowserCreate| { &m.offscreen },
            |m: &mut CMsgBrowserCreate| { &mut m.offscreen },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "initial_width",
            |m: &CMsgBrowserCreate| { &m.initial_width },
            |m: &mut CMsgBrowserCreate| { &mut m.initial_width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "initial_height",
            |m: &CMsgBrowserCreate| { &m.initial_height },
            |m: &mut CMsgBrowserCreate| { &mut m.initial_height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "window_icon",
            |m: &CMsgBrowserCreate| { &m.window_icon },
            |m: &mut CMsgBrowserCreate| { &mut m.window_icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "borderless",
            |m: &CMsgBrowserCreate| { &m.borderless },
            |m: &mut CMsgBrowserCreate| { &mut m.borderless },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vroverlay_key",
            |m: &CMsgBrowserCreate| { &m.vroverlay_key },
            |m: &mut CMsgBrowserCreate| { &mut m.vroverlay_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_type",
            |m: &CMsgBrowserCreate| { &m.browser_type },
            |m: &mut CMsgBrowserCreate| { &mut m.browser_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "initial_top",
            |m: &CMsgBrowserCreate| { &m.initial_top },
            |m: &mut CMsgBrowserCreate| { &mut m.initial_top },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "initial_left",
            |m: &CMsgBrowserCreate| { &m.initial_left },
            |m: &mut CMsgBrowserCreate| { &mut m.initial_left },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "only_allow_trusted_popups",
            |m: &CMsgBrowserCreate| { &m.only_allow_trusted_popups },
            |m: &mut CMsgBrowserCreate| { &mut m.only_allow_trusted_popups },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "initial_url",
            |m: &CMsgBrowserCreate| { &m.initial_url },
            |m: &mut CMsgBrowserCreate| { &mut m.initial_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hwnd_parent",
            |m: &CMsgBrowserCreate| { &m.hwnd_parent },
            |m: &mut CMsgBrowserCreate| { &mut m.hwnd_parent },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBrowserCreate>(
            "CMsgBrowserCreate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgBrowserCreate {
    const NAME: &'static str = "CMsgBrowserCreate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.useragent = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.user_css = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.native_dropdowns = ::std::option::Option::Some(is.read_bool()?);
                },
                61 => {
                    self.dpi_scaling = ::std::option::Option::Some(is.read_float()?);
                },
                64 => {
                    self.offscreen = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.initial_width = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.initial_height = ::std::option::Option::Some(is.read_uint32()?);
                },
                90 => {
                    self.window_icon = ::std::option::Option::Some(is.read_string()?);
                },
                96 => {
                    self.borderless = ::std::option::Option::Some(is.read_bool()?);
                },
                106 => {
                    self.vroverlay_key = ::std::option::Option::Some(is.read_string()?);
                },
                112 => {
                    self.browser_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.initial_top = ::std::option::Option::Some(is.read_int32()?);
                },
                128 => {
                    self.initial_left = ::std::option::Option::Some(is.read_int32()?);
                },
                136 => {
                    self.only_allow_trusted_popups = ::std::option::Option::Some(is.read_bool()?);
                },
                146 => {
                    self.initial_url = ::std::option::Option::Some(is.read_string()?);
                },
                153 => {
                    self.hwnd_parent = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.useragent.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.user_css.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.native_dropdowns {
            my_size += 1 + 1;
        }
        if let Some(v) = self.dpi_scaling {
            my_size += 1 + 4;
        }
        if let Some(v) = self.offscreen {
            my_size += 1 + 1;
        }
        if let Some(v) = self.initial_width {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.initial_height {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.window_icon.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.borderless {
            my_size += 1 + 1;
        }
        if let Some(v) = self.vroverlay_key.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.browser_type {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.initial_top {
            my_size += ::protobuf::rt::int32_size(15, v);
        }
        if let Some(v) = self.initial_left {
            my_size += ::protobuf::rt::int32_size(16, v);
        }
        if let Some(v) = self.only_allow_trusted_popups {
            my_size += 2 + 1;
        }
        if let Some(v) = self.initial_url.as_ref() {
            my_size += ::protobuf::rt::string_size(18, &v);
        }
        if let Some(v) = self.hwnd_parent {
            my_size += 2 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.request_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.useragent.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.user_css.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.native_dropdowns {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.dpi_scaling {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.offscreen {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.initial_width {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.initial_height {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.window_icon.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.borderless {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.vroverlay_key.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.browser_type {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.initial_top {
            os.write_int32(15, v)?;
        }
        if let Some(v) = self.initial_left {
            os.write_int32(16, v)?;
        }
        if let Some(v) = self.only_allow_trusted_popups {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.initial_url.as_ref() {
            os.write_string(18, v)?;
        }
        if let Some(v) = self.hwnd_parent {
            os.write_fixed64(19, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBrowserCreate {
        CMsgBrowserCreate::new()
    }

    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.useragent = ::std::option::Option::None;
        self.user_css = ::std::option::Option::None;
        self.native_dropdowns = ::std::option::Option::None;
        self.dpi_scaling = ::std::option::Option::None;
        self.offscreen = ::std::option::Option::None;
        self.initial_width = ::std::option::Option::None;
        self.initial_height = ::std::option::Option::None;
        self.window_icon = ::std::option::Option::None;
        self.borderless = ::std::option::Option::None;
        self.vroverlay_key = ::std::option::Option::None;
        self.browser_type = ::std::option::Option::None;
        self.initial_top = ::std::option::Option::None;
        self.initial_left = ::std::option::Option::None;
        self.only_allow_trusted_popups = ::std::option::Option::None;
        self.initial_url = ::std::option::Option::None;
        self.hwnd_parent = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBrowserCreate {
        static instance: CMsgBrowserCreate = CMsgBrowserCreate {
            request_id: ::std::option::Option::None,
            useragent: ::std::option::Option::None,
            user_css: ::std::option::Option::None,
            native_dropdowns: ::std::option::Option::None,
            dpi_scaling: ::std::option::Option::None,
            offscreen: ::std::option::Option::None,
            initial_width: ::std::option::Option::None,
            initial_height: ::std::option::Option::None,
            window_icon: ::std::option::Option::None,
            borderless: ::std::option::Option::None,
            vroverlay_key: ::std::option::Option::None,
            browser_type: ::std::option::Option::None,
            initial_top: ::std::option::Option::None,
            initial_left: ::std::option::Option::None,
            only_allow_trusted_popups: ::std::option::Option::None,
            initial_url: ::std::option::Option::None,
            hwnd_parent: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgBrowserCreate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBrowserCreate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBrowserCreate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBrowserCreate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgBrowserCreateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBrowserCreateResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgBrowserCreateResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserCreateResponse.request_id)
    pub request_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBrowserCreateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserCreateResponse {
    fn default() -> &'a CMsgBrowserCreateResponse {
        <CMsgBrowserCreateResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBrowserCreateResponse {
    pub fn new() -> CMsgBrowserCreateResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 request_id = 2;

    pub fn request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgBrowserCreateResponse| { &m.browser_handle },
            |m: &mut CMsgBrowserCreateResponse| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_id",
            |m: &CMsgBrowserCreateResponse| { &m.request_id },
            |m: &mut CMsgBrowserCreateResponse| { &mut m.request_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBrowserCreateResponse>(
            "CMsgBrowserCreateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgBrowserCreateResponse {
    const NAME: &'static str = "CMsgBrowserCreateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBrowserCreateResponse {
        CMsgBrowserCreateResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.request_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBrowserCreateResponse {
        static instance: CMsgBrowserCreateResponse = CMsgBrowserCreateResponse {
            browser_handle: ::std::option::Option::None,
            request_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgBrowserCreateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBrowserCreateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBrowserCreateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBrowserCreateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgBrowserRemove)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBrowserRemove {
    // message fields
    // @@protoc_insertion_point(field:CMsgBrowserRemove.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBrowserRemove.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserRemove {
    fn default() -> &'a CMsgBrowserRemove {
        <CMsgBrowserRemove as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBrowserRemove {
    pub fn new() -> CMsgBrowserRemove {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgBrowserRemove| { &m.browser_handle },
            |m: &mut CMsgBrowserRemove| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBrowserRemove>(
            "CMsgBrowserRemove",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgBrowserRemove {
    const NAME: &'static str = "CMsgBrowserRemove";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBrowserRemove {
        CMsgBrowserRemove::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBrowserRemove {
        static instance: CMsgBrowserRemove = CMsgBrowserRemove {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgBrowserRemove {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBrowserRemove").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBrowserRemove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBrowserRemove {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSetLocalFileRequestMapping)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetLocalFileRequestMapping {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetLocalFileRequestMapping.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetLocalFileRequestMapping.request_url)
    pub request_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSetLocalFileRequestMapping.default_local_path)
    pub default_local_path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSetLocalFileRequestMapping.routes)
    pub routes: ::std::vec::Vec<cmsg_set_local_file_request_mapping::AdditionalRoute>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetLocalFileRequestMapping.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetLocalFileRequestMapping {
    fn default() -> &'a CMsgSetLocalFileRequestMapping {
        <CMsgSetLocalFileRequestMapping as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetLocalFileRequestMapping {
    pub fn new() -> CMsgSetLocalFileRequestMapping {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string request_url = 2;

    pub fn request_url(&self) -> &str {
        match self.request_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_request_url(&mut self) {
        self.request_url = ::std::option::Option::None;
    }

    pub fn has_request_url(&self) -> bool {
        self.request_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_url(&mut self, v: ::std::string::String) {
        self.request_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_request_url(&mut self) -> &mut ::std::string::String {
        if self.request_url.is_none() {
            self.request_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.request_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_request_url(&mut self) -> ::std::string::String {
        self.request_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string default_local_path = 3;

    pub fn default_local_path(&self) -> &str {
        match self.default_local_path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_default_local_path(&mut self) {
        self.default_local_path = ::std::option::Option::None;
    }

    pub fn has_default_local_path(&self) -> bool {
        self.default_local_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_local_path(&mut self, v: ::std::string::String) {
        self.default_local_path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_local_path(&mut self) -> &mut ::std::string::String {
        if self.default_local_path.is_none() {
            self.default_local_path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.default_local_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_default_local_path(&mut self) -> ::std::string::String {
        self.default_local_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgSetLocalFileRequestMapping| { &m.browser_handle },
            |m: &mut CMsgSetLocalFileRequestMapping| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_url",
            |m: &CMsgSetLocalFileRequestMapping| { &m.request_url },
            |m: &mut CMsgSetLocalFileRequestMapping| { &mut m.request_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "default_local_path",
            |m: &CMsgSetLocalFileRequestMapping| { &m.default_local_path },
            |m: &mut CMsgSetLocalFileRequestMapping| { &mut m.default_local_path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "routes",
            |m: &CMsgSetLocalFileRequestMapping| { &m.routes },
            |m: &mut CMsgSetLocalFileRequestMapping| { &mut m.routes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetLocalFileRequestMapping>(
            "CMsgSetLocalFileRequestMapping",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSetLocalFileRequestMapping {
    const NAME: &'static str = "CMsgSetLocalFileRequestMapping";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.request_url = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.default_local_path = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.routes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.request_url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.default_local_path.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.routes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.request_url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.default_local_path.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.routes {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetLocalFileRequestMapping {
        CMsgSetLocalFileRequestMapping::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.request_url = ::std::option::Option::None;
        self.default_local_path = ::std::option::Option::None;
        self.routes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetLocalFileRequestMapping {
        static instance: CMsgSetLocalFileRequestMapping = CMsgSetLocalFileRequestMapping {
            browser_handle: ::std::option::Option::None,
            request_url: ::std::option::Option::None,
            default_local_path: ::std::option::Option::None,
            routes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSetLocalFileRequestMapping {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetLocalFileRequestMapping").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetLocalFileRequestMapping {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetLocalFileRequestMapping {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSetLocalFileRequestMapping`
pub mod cmsg_set_local_file_request_mapping {
    // @@protoc_insertion_point(message:CMsgSetLocalFileRequestMapping.AdditionalRoute)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AdditionalRoute {
        // message fields
        // @@protoc_insertion_point(field:CMsgSetLocalFileRequestMapping.AdditionalRoute.relative_url)
        pub relative_url: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgSetLocalFileRequestMapping.AdditionalRoute.local_path)
        pub local_path: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgSetLocalFileRequestMapping.AdditionalRoute.allowed_extensions)
        pub allowed_extensions: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSetLocalFileRequestMapping.AdditionalRoute.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AdditionalRoute {
        fn default() -> &'a AdditionalRoute {
            <AdditionalRoute as ::protobuf::Message>::default_instance()
        }
    }

    impl AdditionalRoute {
        pub fn new() -> AdditionalRoute {
            ::std::default::Default::default()
        }

        // optional string relative_url = 1;

        pub fn relative_url(&self) -> &str {
            match self.relative_url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_relative_url(&mut self) {
            self.relative_url = ::std::option::Option::None;
        }

        pub fn has_relative_url(&self) -> bool {
            self.relative_url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_relative_url(&mut self, v: ::std::string::String) {
            self.relative_url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_relative_url(&mut self) -> &mut ::std::string::String {
            if self.relative_url.is_none() {
                self.relative_url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.relative_url.as_mut().unwrap()
        }

        // Take field
        pub fn take_relative_url(&mut self) -> ::std::string::String {
            self.relative_url.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string local_path = 2;

        pub fn local_path(&self) -> &str {
            match self.local_path.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_local_path(&mut self) {
            self.local_path = ::std::option::Option::None;
        }

        pub fn has_local_path(&self) -> bool {
            self.local_path.is_some()
        }

        // Param is passed by value, moved
        pub fn set_local_path(&mut self, v: ::std::string::String) {
            self.local_path = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_local_path(&mut self) -> &mut ::std::string::String {
            if self.local_path.is_none() {
                self.local_path = ::std::option::Option::Some(::std::string::String::new());
            }
            self.local_path.as_mut().unwrap()
        }

        // Take field
        pub fn take_local_path(&mut self) -> ::std::string::String {
            self.local_path.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string allowed_extensions = 3;

        pub fn allowed_extensions(&self) -> &str {
            match self.allowed_extensions.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_allowed_extensions(&mut self) {
            self.allowed_extensions = ::std::option::Option::None;
        }

        pub fn has_allowed_extensions(&self) -> bool {
            self.allowed_extensions.is_some()
        }

        // Param is passed by value, moved
        pub fn set_allowed_extensions(&mut self, v: ::std::string::String) {
            self.allowed_extensions = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_allowed_extensions(&mut self) -> &mut ::std::string::String {
            if self.allowed_extensions.is_none() {
                self.allowed_extensions = ::std::option::Option::Some(::std::string::String::new());
            }
            self.allowed_extensions.as_mut().unwrap()
        }

        // Take field
        pub fn take_allowed_extensions(&mut self) -> ::std::string::String {
            self.allowed_extensions.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "relative_url",
                |m: &AdditionalRoute| { &m.relative_url },
                |m: &mut AdditionalRoute| { &mut m.relative_url },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "local_path",
                |m: &AdditionalRoute| { &m.local_path },
                |m: &mut AdditionalRoute| { &mut m.local_path },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "allowed_extensions",
                |m: &AdditionalRoute| { &m.allowed_extensions },
                |m: &mut AdditionalRoute| { &mut m.allowed_extensions },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AdditionalRoute>(
                "CMsgSetLocalFileRequestMapping.AdditionalRoute",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AdditionalRoute {
        const NAME: &'static str = "AdditionalRoute";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.relative_url = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.local_path = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.allowed_extensions = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.relative_url.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.local_path.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.allowed_extensions.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.relative_url.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.local_path.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.allowed_extensions.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AdditionalRoute {
            AdditionalRoute::new()
        }

        fn clear(&mut self) {
            self.relative_url = ::std::option::Option::None;
            self.local_path = ::std::option::Option::None;
            self.allowed_extensions = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AdditionalRoute {
            static instance: AdditionalRoute = AdditionalRoute {
                relative_url: ::std::option::Option::None,
                local_path: ::std::option::Option::None,
                allowed_extensions: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AdditionalRoute {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSetLocalFileRequestMapping.AdditionalRoute").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AdditionalRoute {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AdditionalRoute {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgBrowserErrorStrings)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBrowserErrorStrings {
    // message fields
    // @@protoc_insertion_point(field:CMsgBrowserErrorStrings.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserErrorStrings.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBrowserErrorStrings.header)
    pub header: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBrowserErrorStrings.cache_miss)
    pub cache_miss: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBrowserErrorStrings.bad_url)
    pub bad_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBrowserErrorStrings.connection_problem)
    pub connection_problem: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBrowserErrorStrings.proxy_problem)
    pub proxy_problem: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBrowserErrorStrings.unknown)
    pub unknown: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBrowserErrorStrings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserErrorStrings {
    fn default() -> &'a CMsgBrowserErrorStrings {
        <CMsgBrowserErrorStrings as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBrowserErrorStrings {
    pub fn new() -> CMsgBrowserErrorStrings {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string title = 2;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string header = 3;

    pub fn header(&self) -> &str {
        match self.header.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_header(&mut self) {
        self.header = ::std::option::Option::None;
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ::std::string::String) {
        self.header = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ::std::string::String {
        if self.header.is_none() {
            self.header = ::std::option::Option::Some(::std::string::String::new());
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ::std::string::String {
        self.header.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string cache_miss = 4;

    pub fn cache_miss(&self) -> &str {
        match self.cache_miss.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_cache_miss(&mut self) {
        self.cache_miss = ::std::option::Option::None;
    }

    pub fn has_cache_miss(&self) -> bool {
        self.cache_miss.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cache_miss(&mut self, v: ::std::string::String) {
        self.cache_miss = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cache_miss(&mut self) -> &mut ::std::string::String {
        if self.cache_miss.is_none() {
            self.cache_miss = ::std::option::Option::Some(::std::string::String::new());
        }
        self.cache_miss.as_mut().unwrap()
    }

    // Take field
    pub fn take_cache_miss(&mut self) -> ::std::string::String {
        self.cache_miss.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string bad_url = 5;

    pub fn bad_url(&self) -> &str {
        match self.bad_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_bad_url(&mut self) {
        self.bad_url = ::std::option::Option::None;
    }

    pub fn has_bad_url(&self) -> bool {
        self.bad_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bad_url(&mut self, v: ::std::string::String) {
        self.bad_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bad_url(&mut self) -> &mut ::std::string::String {
        if self.bad_url.is_none() {
            self.bad_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.bad_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_bad_url(&mut self) -> ::std::string::String {
        self.bad_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string connection_problem = 6;

    pub fn connection_problem(&self) -> &str {
        match self.connection_problem.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_connection_problem(&mut self) {
        self.connection_problem = ::std::option::Option::None;
    }

    pub fn has_connection_problem(&self) -> bool {
        self.connection_problem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_problem(&mut self, v: ::std::string::String) {
        self.connection_problem = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connection_problem(&mut self) -> &mut ::std::string::String {
        if self.connection_problem.is_none() {
            self.connection_problem = ::std::option::Option::Some(::std::string::String::new());
        }
        self.connection_problem.as_mut().unwrap()
    }

    // Take field
    pub fn take_connection_problem(&mut self) -> ::std::string::String {
        self.connection_problem.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string proxy_problem = 7;

    pub fn proxy_problem(&self) -> &str {
        match self.proxy_problem.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_proxy_problem(&mut self) {
        self.proxy_problem = ::std::option::Option::None;
    }

    pub fn has_proxy_problem(&self) -> bool {
        self.proxy_problem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proxy_problem(&mut self, v: ::std::string::String) {
        self.proxy_problem = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proxy_problem(&mut self) -> &mut ::std::string::String {
        if self.proxy_problem.is_none() {
            self.proxy_problem = ::std::option::Option::Some(::std::string::String::new());
        }
        self.proxy_problem.as_mut().unwrap()
    }

    // Take field
    pub fn take_proxy_problem(&mut self) -> ::std::string::String {
        self.proxy_problem.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string unknown = 8;

    pub fn unknown(&self) -> &str {
        match self.unknown.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_unknown(&mut self) {
        self.unknown = ::std::option::Option::None;
    }

    pub fn has_unknown(&self) -> bool {
        self.unknown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unknown(&mut self, v: ::std::string::String) {
        self.unknown = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unknown(&mut self) -> &mut ::std::string::String {
        if self.unknown.is_none() {
            self.unknown = ::std::option::Option::Some(::std::string::String::new());
        }
        self.unknown.as_mut().unwrap()
    }

    // Take field
    pub fn take_unknown(&mut self) -> ::std::string::String {
        self.unknown.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgBrowserErrorStrings| { &m.browser_handle },
            |m: &mut CMsgBrowserErrorStrings| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &CMsgBrowserErrorStrings| { &m.title },
            |m: &mut CMsgBrowserErrorStrings| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "header",
            |m: &CMsgBrowserErrorStrings| { &m.header },
            |m: &mut CMsgBrowserErrorStrings| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cache_miss",
            |m: &CMsgBrowserErrorStrings| { &m.cache_miss },
            |m: &mut CMsgBrowserErrorStrings| { &mut m.cache_miss },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bad_url",
            |m: &CMsgBrowserErrorStrings| { &m.bad_url },
            |m: &mut CMsgBrowserErrorStrings| { &mut m.bad_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "connection_problem",
            |m: &CMsgBrowserErrorStrings| { &m.connection_problem },
            |m: &mut CMsgBrowserErrorStrings| { &mut m.connection_problem },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "proxy_problem",
            |m: &CMsgBrowserErrorStrings| { &m.proxy_problem },
            |m: &mut CMsgBrowserErrorStrings| { &mut m.proxy_problem },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unknown",
            |m: &CMsgBrowserErrorStrings| { &m.unknown },
            |m: &mut CMsgBrowserErrorStrings| { &mut m.unknown },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBrowserErrorStrings>(
            "CMsgBrowserErrorStrings",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgBrowserErrorStrings {
    const NAME: &'static str = "CMsgBrowserErrorStrings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.header = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.cache_miss = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.bad_url = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.connection_problem = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.proxy_problem = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.unknown = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.header.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.cache_miss.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.bad_url.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.connection_problem.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.proxy_problem.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.unknown.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.header.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.cache_miss.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.bad_url.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.connection_problem.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.proxy_problem.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.unknown.as_ref() {
            os.write_string(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBrowserErrorStrings {
        CMsgBrowserErrorStrings::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.header = ::std::option::Option::None;
        self.cache_miss = ::std::option::Option::None;
        self.bad_url = ::std::option::Option::None;
        self.connection_problem = ::std::option::Option::None;
        self.proxy_problem = ::std::option::Option::None;
        self.unknown = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBrowserErrorStrings {
        static instance: CMsgBrowserErrorStrings = CMsgBrowserErrorStrings {
            browser_handle: ::std::option::Option::None,
            title: ::std::option::Option::None,
            header: ::std::option::Option::None,
            cache_miss: ::std::option::Option::None,
            bad_url: ::std::option::Option::None,
            connection_problem: ::std::option::Option::None,
            proxy_problem: ::std::option::Option::None,
            unknown: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgBrowserErrorStrings {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBrowserErrorStrings").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBrowserErrorStrings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBrowserErrorStrings {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgBrowserSize)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBrowserSize {
    // message fields
    // @@protoc_insertion_point(field:CMsgBrowserSize.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserSize.width)
    pub width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserSize.height)
    pub height: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBrowserSize.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserSize {
    fn default() -> &'a CMsgBrowserSize {
        <CMsgBrowserSize as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBrowserSize {
    pub fn new() -> CMsgBrowserSize {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 width = 2;

    pub fn width(&self) -> u32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 3;

    pub fn height(&self) -> u32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgBrowserSize| { &m.browser_handle },
            |m: &mut CMsgBrowserSize| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &CMsgBrowserSize| { &m.width },
            |m: &mut CMsgBrowserSize| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &CMsgBrowserSize| { &m.height },
            |m: &mut CMsgBrowserSize| { &mut m.height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBrowserSize>(
            "CMsgBrowserSize",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgBrowserSize {
    const NAME: &'static str = "CMsgBrowserSize";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.width = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.height = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.width {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBrowserSize {
        CMsgBrowserSize::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBrowserSize {
        static instance: CMsgBrowserSize = CMsgBrowserSize {
            browser_handle: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgBrowserSize {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBrowserSize").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBrowserSize {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBrowserSize {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgBrowserSetMinSize)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBrowserSetMinSize {
    // message fields
    // @@protoc_insertion_point(field:CMsgBrowserSetMinSize.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserSetMinSize.width)
    pub width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserSetMinSize.height)
    pub height: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBrowserSetMinSize.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserSetMinSize {
    fn default() -> &'a CMsgBrowserSetMinSize {
        <CMsgBrowserSetMinSize as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBrowserSetMinSize {
    pub fn new() -> CMsgBrowserSetMinSize {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 width = 2;

    pub fn width(&self) -> u32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 3;

    pub fn height(&self) -> u32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgBrowserSetMinSize| { &m.browser_handle },
            |m: &mut CMsgBrowserSetMinSize| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &CMsgBrowserSetMinSize| { &m.width },
            |m: &mut CMsgBrowserSetMinSize| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &CMsgBrowserSetMinSize| { &m.height },
            |m: &mut CMsgBrowserSetMinSize| { &mut m.height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBrowserSetMinSize>(
            "CMsgBrowserSetMinSize",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgBrowserSetMinSize {
    const NAME: &'static str = "CMsgBrowserSetMinSize";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.width = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.height = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.width {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBrowserSetMinSize {
        CMsgBrowserSetMinSize::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBrowserSetMinSize {
        static instance: CMsgBrowserSetMinSize = CMsgBrowserSetMinSize {
            browser_handle: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgBrowserSetMinSize {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBrowserSetMinSize").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBrowserSetMinSize {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBrowserSetMinSize {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgBrowserPosition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBrowserPosition {
    // message fields
    // @@protoc_insertion_point(field:CMsgBrowserPosition.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserPosition.x)
    pub x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgBrowserPosition.y)
    pub y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgBrowserPosition.x_local)
    pub x_local: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgBrowserPosition.y_local)
    pub y_local: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBrowserPosition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserPosition {
    fn default() -> &'a CMsgBrowserPosition {
        <CMsgBrowserPosition as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBrowserPosition {
    pub fn new() -> CMsgBrowserPosition {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional int32 x = 2;

    pub fn x(&self) -> i32 {
        self.x.unwrap_or(0)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: i32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional int32 y = 3;

    pub fn y(&self) -> i32 {
        self.y.unwrap_or(0)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: i32) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional int32 x_local = 4;

    pub fn x_local(&self) -> i32 {
        self.x_local.unwrap_or(0)
    }

    pub fn clear_x_local(&mut self) {
        self.x_local = ::std::option::Option::None;
    }

    pub fn has_x_local(&self) -> bool {
        self.x_local.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x_local(&mut self, v: i32) {
        self.x_local = ::std::option::Option::Some(v);
    }

    // optional int32 y_local = 5;

    pub fn y_local(&self) -> i32 {
        self.y_local.unwrap_or(0)
    }

    pub fn clear_y_local(&mut self) {
        self.y_local = ::std::option::Option::None;
    }

    pub fn has_y_local(&self) -> bool {
        self.y_local.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y_local(&mut self, v: i32) {
        self.y_local = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgBrowserPosition| { &m.browser_handle },
            |m: &mut CMsgBrowserPosition| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &CMsgBrowserPosition| { &m.x },
            |m: &mut CMsgBrowserPosition| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &CMsgBrowserPosition| { &m.y },
            |m: &mut CMsgBrowserPosition| { &mut m.y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "x_local",
            |m: &CMsgBrowserPosition| { &m.x_local },
            |m: &mut CMsgBrowserPosition| { &mut m.x_local },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "y_local",
            |m: &CMsgBrowserPosition| { &m.y_local },
            |m: &mut CMsgBrowserPosition| { &mut m.y_local },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBrowserPosition>(
            "CMsgBrowserPosition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgBrowserPosition {
    const NAME: &'static str = "CMsgBrowserPosition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.x = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.y = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.x_local = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.y_local = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.x_local {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.y_local {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.x_local {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.y_local {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBrowserPosition {
        CMsgBrowserPosition::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.x_local = ::std::option::Option::None;
        self.y_local = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBrowserPosition {
        static instance: CMsgBrowserPosition = CMsgBrowserPosition {
            browser_handle: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            x_local: ::std::option::Option::None,
            y_local: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgBrowserPosition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBrowserPosition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBrowserPosition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBrowserPosition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgBrowserResized)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBrowserResized {
    // message fields
    // @@protoc_insertion_point(field:CMsgBrowserResized.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserResized.x)
    pub x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgBrowserResized.y)
    pub y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgBrowserResized.width)
    pub width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserResized.height)
    pub height: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBrowserResized.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserResized {
    fn default() -> &'a CMsgBrowserResized {
        <CMsgBrowserResized as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBrowserResized {
    pub fn new() -> CMsgBrowserResized {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional int32 x = 2;

    pub fn x(&self) -> i32 {
        self.x.unwrap_or(0)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: i32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional int32 y = 3;

    pub fn y(&self) -> i32 {
        self.y.unwrap_or(0)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: i32) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional uint32 width = 4;

    pub fn width(&self) -> u32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 5;

    pub fn height(&self) -> u32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgBrowserResized| { &m.browser_handle },
            |m: &mut CMsgBrowserResized| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &CMsgBrowserResized| { &m.x },
            |m: &mut CMsgBrowserResized| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &CMsgBrowserResized| { &m.y },
            |m: &mut CMsgBrowserResized| { &mut m.y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &CMsgBrowserResized| { &m.width },
            |m: &mut CMsgBrowserResized| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &CMsgBrowserResized| { &m.height },
            |m: &mut CMsgBrowserResized| { &mut m.height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBrowserResized>(
            "CMsgBrowserResized",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgBrowserResized {
    const NAME: &'static str = "CMsgBrowserResized";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.x = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.y = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.width = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.height = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.width {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBrowserResized {
        CMsgBrowserResized::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBrowserResized {
        static instance: CMsgBrowserResized = CMsgBrowserResized {
            browser_handle: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgBrowserResized {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBrowserResized").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBrowserResized {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBrowserResized {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPostURL)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPostURL {
    // message fields
    // @@protoc_insertion_point(field:CMsgPostURL.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPostURL.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgPostURL.post)
    pub post: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgPostURL.pageserial)
    pub pageserial: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPostURL.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPostURL {
    fn default() -> &'a CMsgPostURL {
        <CMsgPostURL as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPostURL {
    pub fn new() -> CMsgPostURL {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string post = 3;

    pub fn post(&self) -> &str {
        match self.post.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_post(&mut self) {
        self.post = ::std::option::Option::None;
    }

    pub fn has_post(&self) -> bool {
        self.post.is_some()
    }

    // Param is passed by value, moved
    pub fn set_post(&mut self, v: ::std::string::String) {
        self.post = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_post(&mut self) -> &mut ::std::string::String {
        if self.post.is_none() {
            self.post = ::std::option::Option::Some(::std::string::String::new());
        }
        self.post.as_mut().unwrap()
    }

    // Take field
    pub fn take_post(&mut self) -> ::std::string::String {
        self.post.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 pageserial = 4;

    pub fn pageserial(&self) -> u32 {
        self.pageserial.unwrap_or(0)
    }

    pub fn clear_pageserial(&mut self) {
        self.pageserial = ::std::option::Option::None;
    }

    pub fn has_pageserial(&self) -> bool {
        self.pageserial.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pageserial(&mut self, v: u32) {
        self.pageserial = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgPostURL| { &m.browser_handle },
            |m: &mut CMsgPostURL| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgPostURL| { &m.url },
            |m: &mut CMsgPostURL| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "post",
            |m: &CMsgPostURL| { &m.post },
            |m: &mut CMsgPostURL| { &mut m.post },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pageserial",
            |m: &CMsgPostURL| { &m.pageserial },
            |m: &mut CMsgPostURL| { &mut m.pageserial },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPostURL>(
            "CMsgPostURL",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPostURL {
    const NAME: &'static str = "CMsgPostURL";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.post = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.pageserial = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.post.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.pageserial {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.post.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.pageserial {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPostURL {
        CMsgPostURL::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.post = ::std::option::Option::None;
        self.pageserial = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPostURL {
        static instance: CMsgPostURL = CMsgPostURL {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            post: ::std::option::Option::None,
            pageserial: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPostURL {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPostURL").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPostURL {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPostURL {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgAddHeader)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAddHeader {
    // message fields
    // @@protoc_insertion_point(field:CMsgAddHeader.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAddHeader.key)
    pub key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgAddHeader.value)
    pub value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAddHeader.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAddHeader {
    fn default() -> &'a CMsgAddHeader {
        <CMsgAddHeader as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAddHeader {
    pub fn new() -> CMsgAddHeader {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string key = 2;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 3;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgAddHeader| { &m.browser_handle },
            |m: &mut CMsgAddHeader| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &CMsgAddHeader| { &m.key },
            |m: &mut CMsgAddHeader| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CMsgAddHeader| { &m.value },
            |m: &mut CMsgAddHeader| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAddHeader>(
            "CMsgAddHeader",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgAddHeader {
    const NAME: &'static str = "CMsgAddHeader";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.key.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAddHeader {
        CMsgAddHeader::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.key = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAddHeader {
        static instance: CMsgAddHeader = CMsgAddHeader {
            browser_handle: ::std::option::Option::None,
            key: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgAddHeader {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAddHeader").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAddHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAddHeader {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgStopLoad)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgStopLoad {
    // message fields
    // @@protoc_insertion_point(field:CMsgStopLoad.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgStopLoad.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStopLoad {
    fn default() -> &'a CMsgStopLoad {
        <CMsgStopLoad as ::protobuf::Message>::default_instance()
    }
}

impl CMsgStopLoad {
    pub fn new() -> CMsgStopLoad {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgStopLoad| { &m.browser_handle },
            |m: &mut CMsgStopLoad| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgStopLoad>(
            "CMsgStopLoad",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgStopLoad {
    const NAME: &'static str = "CMsgStopLoad";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStopLoad {
        CMsgStopLoad::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStopLoad {
        static instance: CMsgStopLoad = CMsgStopLoad {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgStopLoad {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgStopLoad").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgStopLoad {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgStopLoad {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgReload)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgReload {
    // message fields
    // @@protoc_insertion_point(field:CMsgReload.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgReload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgReload {
    fn default() -> &'a CMsgReload {
        <CMsgReload as ::protobuf::Message>::default_instance()
    }
}

impl CMsgReload {
    pub fn new() -> CMsgReload {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgReload| { &m.browser_handle },
            |m: &mut CMsgReload| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgReload>(
            "CMsgReload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgReload {
    const NAME: &'static str = "CMsgReload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgReload {
        CMsgReload::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgReload {
        static instance: CMsgReload = CMsgReload {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgReload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgReload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgReload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgReload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGoForward)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGoForward {
    // message fields
    // @@protoc_insertion_point(field:CMsgGoForward.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGoForward.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGoForward {
    fn default() -> &'a CMsgGoForward {
        <CMsgGoForward as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGoForward {
    pub fn new() -> CMsgGoForward {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgGoForward| { &m.browser_handle },
            |m: &mut CMsgGoForward| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGoForward>(
            "CMsgGoForward",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGoForward {
    const NAME: &'static str = "CMsgGoForward";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGoForward {
        CMsgGoForward::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGoForward {
        static instance: CMsgGoForward = CMsgGoForward {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGoForward {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGoForward").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGoForward {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGoForward {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGoBack)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGoBack {
    // message fields
    // @@protoc_insertion_point(field:CMsgGoBack.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGoBack.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGoBack {
    fn default() -> &'a CMsgGoBack {
        <CMsgGoBack as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGoBack {
    pub fn new() -> CMsgGoBack {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgGoBack| { &m.browser_handle },
            |m: &mut CMsgGoBack| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGoBack>(
            "CMsgGoBack",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGoBack {
    const NAME: &'static str = "CMsgGoBack";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGoBack {
        CMsgGoBack::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGoBack {
        static instance: CMsgGoBack = CMsgGoBack {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGoBack {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGoBack").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGoBack {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGoBack {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgWasHidden)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgWasHidden {
    // message fields
    // @@protoc_insertion_point(field:CMsgWasHidden.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgWasHidden.hidden)
    pub hidden: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgWasHidden.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgWasHidden {
    fn default() -> &'a CMsgWasHidden {
        <CMsgWasHidden as ::protobuf::Message>::default_instance()
    }
}

impl CMsgWasHidden {
    pub fn new() -> CMsgWasHidden {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool hidden = 2;

    pub fn hidden(&self) -> bool {
        self.hidden.unwrap_or(false)
    }

    pub fn clear_hidden(&mut self) {
        self.hidden = ::std::option::Option::None;
    }

    pub fn has_hidden(&self) -> bool {
        self.hidden.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hidden(&mut self, v: bool) {
        self.hidden = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgWasHidden| { &m.browser_handle },
            |m: &mut CMsgWasHidden| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hidden",
            |m: &CMsgWasHidden| { &m.hidden },
            |m: &mut CMsgWasHidden| { &mut m.hidden },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgWasHidden>(
            "CMsgWasHidden",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgWasHidden {
    const NAME: &'static str = "CMsgWasHidden";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.hidden = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.hidden {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.hidden {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgWasHidden {
        CMsgWasHidden::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.hidden = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgWasHidden {
        static instance: CMsgWasHidden = CMsgWasHidden {
            browser_handle: ::std::option::Option::None,
            hidden: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgWasHidden {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgWasHidden").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgWasHidden {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgWasHidden {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClearHistory)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClearHistory {
    // message fields
    // @@protoc_insertion_point(field:CMsgClearHistory.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClearHistory.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClearHistory {
    fn default() -> &'a CMsgClearHistory {
        <CMsgClearHistory as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClearHistory {
    pub fn new() -> CMsgClearHistory {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgClearHistory| { &m.browser_handle },
            |m: &mut CMsgClearHistory| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClearHistory>(
            "CMsgClearHistory",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClearHistory {
    const NAME: &'static str = "CMsgClearHistory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClearHistory {
        CMsgClearHistory::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClearHistory {
        static instance: CMsgClearHistory = CMsgClearHistory {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClearHistory {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClearHistory").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClearHistory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClearHistory {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClearAllBrowsingData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClearAllBrowsingData {
    // message fields
    // @@protoc_insertion_point(field:CMsgClearAllBrowsingData.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClearAllBrowsingData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClearAllBrowsingData {
    fn default() -> &'a CMsgClearAllBrowsingData {
        <CMsgClearAllBrowsingData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClearAllBrowsingData {
    pub fn new() -> CMsgClearAllBrowsingData {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgClearAllBrowsingData| { &m.browser_handle },
            |m: &mut CMsgClearAllBrowsingData| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClearAllBrowsingData>(
            "CMsgClearAllBrowsingData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClearAllBrowsingData {
    const NAME: &'static str = "CMsgClearAllBrowsingData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClearAllBrowsingData {
        CMsgClearAllBrowsingData::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClearAllBrowsingData {
        static instance: CMsgClearAllBrowsingData = CMsgClearAllBrowsingData {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClearAllBrowsingData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClearAllBrowsingData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClearAllBrowsingData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClearAllBrowsingData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgCopy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCopy {
    // message fields
    // @@protoc_insertion_point(field:CMsgCopy.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCopy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCopy {
    fn default() -> &'a CMsgCopy {
        <CMsgCopy as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCopy {
    pub fn new() -> CMsgCopy {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgCopy| { &m.browser_handle },
            |m: &mut CMsgCopy| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCopy>(
            "CMsgCopy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgCopy {
    const NAME: &'static str = "CMsgCopy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCopy {
        CMsgCopy::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCopy {
        static instance: CMsgCopy = CMsgCopy {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgCopy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCopy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCopy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCopy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPaste)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPaste {
    // message fields
    // @@protoc_insertion_point(field:CMsgPaste.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPaste.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPaste {
    fn default() -> &'a CMsgPaste {
        <CMsgPaste as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPaste {
    pub fn new() -> CMsgPaste {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgPaste| { &m.browser_handle },
            |m: &mut CMsgPaste| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPaste>(
            "CMsgPaste",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPaste {
    const NAME: &'static str = "CMsgPaste";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPaste {
        CMsgPaste::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPaste {
        static instance: CMsgPaste = CMsgPaste {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPaste {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPaste").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPaste {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPaste {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgExecuteJavaScript)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgExecuteJavaScript {
    // message fields
    // @@protoc_insertion_point(field:CMsgExecuteJavaScript.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgExecuteJavaScript.script)
    pub script: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgExecuteJavaScript.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgExecuteJavaScript {
    fn default() -> &'a CMsgExecuteJavaScript {
        <CMsgExecuteJavaScript as ::protobuf::Message>::default_instance()
    }
}

impl CMsgExecuteJavaScript {
    pub fn new() -> CMsgExecuteJavaScript {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string script = 2;

    pub fn script(&self) -> &str {
        match self.script.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_script(&mut self) {
        self.script = ::std::option::Option::None;
    }

    pub fn has_script(&self) -> bool {
        self.script.is_some()
    }

    // Param is passed by value, moved
    pub fn set_script(&mut self, v: ::std::string::String) {
        self.script = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_script(&mut self) -> &mut ::std::string::String {
        if self.script.is_none() {
            self.script = ::std::option::Option::Some(::std::string::String::new());
        }
        self.script.as_mut().unwrap()
    }

    // Take field
    pub fn take_script(&mut self) -> ::std::string::String {
        self.script.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgExecuteJavaScript| { &m.browser_handle },
            |m: &mut CMsgExecuteJavaScript| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "script",
            |m: &CMsgExecuteJavaScript| { &m.script },
            |m: &mut CMsgExecuteJavaScript| { &mut m.script },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgExecuteJavaScript>(
            "CMsgExecuteJavaScript",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgExecuteJavaScript {
    const NAME: &'static str = "CMsgExecuteJavaScript";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.script = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.script.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.script.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgExecuteJavaScript {
        CMsgExecuteJavaScript::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.script = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgExecuteJavaScript {
        static instance: CMsgExecuteJavaScript = CMsgExecuteJavaScript {
            browser_handle: ::std::option::Option::None,
            script: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgExecuteJavaScript {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgExecuteJavaScript").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgExecuteJavaScript {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgExecuteJavaScript {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSetFocus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetFocus {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetFocus.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetFocus.focus)
    pub focus: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetFocus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetFocus {
    fn default() -> &'a CMsgSetFocus {
        <CMsgSetFocus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetFocus {
    pub fn new() -> CMsgSetFocus {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool focus = 2;

    pub fn focus(&self) -> bool {
        self.focus.unwrap_or(false)
    }

    pub fn clear_focus(&mut self) {
        self.focus = ::std::option::Option::None;
    }

    pub fn has_focus(&self) -> bool {
        self.focus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_focus(&mut self, v: bool) {
        self.focus = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgSetFocus| { &m.browser_handle },
            |m: &mut CMsgSetFocus| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "focus",
            |m: &CMsgSetFocus| { &m.focus },
            |m: &mut CMsgSetFocus| { &mut m.focus },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetFocus>(
            "CMsgSetFocus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSetFocus {
    const NAME: &'static str = "CMsgSetFocus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.focus = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.focus {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.focus {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetFocus {
        CMsgSetFocus::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.focus = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetFocus {
        static instance: CMsgSetFocus = CMsgSetFocus {
            browser_handle: ::std::option::Option::None,
            focus: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSetFocus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetFocus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetFocus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetFocus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgHorizontalScrollBarSize)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHorizontalScrollBarSize {
    // message fields
    // @@protoc_insertion_point(field:CMsgHorizontalScrollBarSize.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgHorizontalScrollBarSize.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHorizontalScrollBarSize {
    fn default() -> &'a CMsgHorizontalScrollBarSize {
        <CMsgHorizontalScrollBarSize as ::protobuf::Message>::default_instance()
    }
}

impl CMsgHorizontalScrollBarSize {
    pub fn new() -> CMsgHorizontalScrollBarSize {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgHorizontalScrollBarSize| { &m.browser_handle },
            |m: &mut CMsgHorizontalScrollBarSize| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgHorizontalScrollBarSize>(
            "CMsgHorizontalScrollBarSize",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgHorizontalScrollBarSize {
    const NAME: &'static str = "CMsgHorizontalScrollBarSize";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHorizontalScrollBarSize {
        CMsgHorizontalScrollBarSize::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHorizontalScrollBarSize {
        static instance: CMsgHorizontalScrollBarSize = CMsgHorizontalScrollBarSize {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgHorizontalScrollBarSize {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgHorizontalScrollBarSize").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgHorizontalScrollBarSize {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgHorizontalScrollBarSize {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgHorizontalScrollBarSizeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHorizontalScrollBarSizeResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgHorizontalScrollBarSizeResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHorizontalScrollBarSizeResponse.scroll_max)
    pub scroll_max: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHorizontalScrollBarSizeResponse.scroll)
    pub scroll: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHorizontalScrollBarSizeResponse.zoom)
    pub zoom: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgHorizontalScrollBarSizeResponse.visible)
    pub visible: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgHorizontalScrollBarSizeResponse.page_size)
    pub page_size: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgHorizontalScrollBarSizeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHorizontalScrollBarSizeResponse {
    fn default() -> &'a CMsgHorizontalScrollBarSizeResponse {
        <CMsgHorizontalScrollBarSizeResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgHorizontalScrollBarSizeResponse {
    pub fn new() -> CMsgHorizontalScrollBarSizeResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 scroll_max = 6;

    pub fn scroll_max(&self) -> u32 {
        self.scroll_max.unwrap_or(0)
    }

    pub fn clear_scroll_max(&mut self) {
        self.scroll_max = ::std::option::Option::None;
    }

    pub fn has_scroll_max(&self) -> bool {
        self.scroll_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scroll_max(&mut self, v: u32) {
        self.scroll_max = ::std::option::Option::Some(v);
    }

    // optional uint32 scroll = 7;

    pub fn scroll(&self) -> u32 {
        self.scroll.unwrap_or(0)
    }

    pub fn clear_scroll(&mut self) {
        self.scroll = ::std::option::Option::None;
    }

    pub fn has_scroll(&self) -> bool {
        self.scroll.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scroll(&mut self, v: u32) {
        self.scroll = ::std::option::Option::Some(v);
    }

    // optional float zoom = 8;

    pub fn zoom(&self) -> f32 {
        self.zoom.unwrap_or(0.)
    }

    pub fn clear_zoom(&mut self) {
        self.zoom = ::std::option::Option::None;
    }

    pub fn has_zoom(&self) -> bool {
        self.zoom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zoom(&mut self, v: f32) {
        self.zoom = ::std::option::Option::Some(v);
    }

    // optional bool visible = 9;

    pub fn visible(&self) -> bool {
        self.visible.unwrap_or(false)
    }

    pub fn clear_visible(&mut self) {
        self.visible = ::std::option::Option::None;
    }

    pub fn has_visible(&self) -> bool {
        self.visible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visible(&mut self, v: bool) {
        self.visible = ::std::option::Option::Some(v);
    }

    // optional uint32 page_size = 10;

    pub fn page_size(&self) -> u32 {
        self.page_size.unwrap_or(0)
    }

    pub fn clear_page_size(&mut self) {
        self.page_size = ::std::option::Option::None;
    }

    pub fn has_page_size(&self) -> bool {
        self.page_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: u32) {
        self.page_size = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgHorizontalScrollBarSizeResponse| { &m.browser_handle },
            |m: &mut CMsgHorizontalScrollBarSizeResponse| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scroll_max",
            |m: &CMsgHorizontalScrollBarSizeResponse| { &m.scroll_max },
            |m: &mut CMsgHorizontalScrollBarSizeResponse| { &mut m.scroll_max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scroll",
            |m: &CMsgHorizontalScrollBarSizeResponse| { &m.scroll },
            |m: &mut CMsgHorizontalScrollBarSizeResponse| { &mut m.scroll },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "zoom",
            |m: &CMsgHorizontalScrollBarSizeResponse| { &m.zoom },
            |m: &mut CMsgHorizontalScrollBarSizeResponse| { &mut m.zoom },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "visible",
            |m: &CMsgHorizontalScrollBarSizeResponse| { &m.visible },
            |m: &mut CMsgHorizontalScrollBarSizeResponse| { &mut m.visible },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "page_size",
            |m: &CMsgHorizontalScrollBarSizeResponse| { &m.page_size },
            |m: &mut CMsgHorizontalScrollBarSizeResponse| { &mut m.page_size },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgHorizontalScrollBarSizeResponse>(
            "CMsgHorizontalScrollBarSizeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgHorizontalScrollBarSizeResponse {
    const NAME: &'static str = "CMsgHorizontalScrollBarSizeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.scroll_max = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.scroll = ::std::option::Option::Some(is.read_uint32()?);
                },
                69 => {
                    self.zoom = ::std::option::Option::Some(is.read_float()?);
                },
                72 => {
                    self.visible = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.page_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.scroll_max {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.scroll {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.zoom {
            my_size += 1 + 4;
        }
        if let Some(v) = self.visible {
            my_size += 1 + 1;
        }
        if let Some(v) = self.page_size {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scroll_max {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.scroll {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.zoom {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.visible {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.page_size {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHorizontalScrollBarSizeResponse {
        CMsgHorizontalScrollBarSizeResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.scroll_max = ::std::option::Option::None;
        self.scroll = ::std::option::Option::None;
        self.zoom = ::std::option::Option::None;
        self.visible = ::std::option::Option::None;
        self.page_size = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHorizontalScrollBarSizeResponse {
        static instance: CMsgHorizontalScrollBarSizeResponse = CMsgHorizontalScrollBarSizeResponse {
            browser_handle: ::std::option::Option::None,
            scroll_max: ::std::option::Option::None,
            scroll: ::std::option::Option::None,
            zoom: ::std::option::Option::None,
            visible: ::std::option::Option::None,
            page_size: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgHorizontalScrollBarSizeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgHorizontalScrollBarSizeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgHorizontalScrollBarSizeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgHorizontalScrollBarSizeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgVerticalScrollBarSize)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgVerticalScrollBarSize {
    // message fields
    // @@protoc_insertion_point(field:CMsgVerticalScrollBarSize.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgVerticalScrollBarSize.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgVerticalScrollBarSize {
    fn default() -> &'a CMsgVerticalScrollBarSize {
        <CMsgVerticalScrollBarSize as ::protobuf::Message>::default_instance()
    }
}

impl CMsgVerticalScrollBarSize {
    pub fn new() -> CMsgVerticalScrollBarSize {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgVerticalScrollBarSize| { &m.browser_handle },
            |m: &mut CMsgVerticalScrollBarSize| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgVerticalScrollBarSize>(
            "CMsgVerticalScrollBarSize",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgVerticalScrollBarSize {
    const NAME: &'static str = "CMsgVerticalScrollBarSize";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgVerticalScrollBarSize {
        CMsgVerticalScrollBarSize::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgVerticalScrollBarSize {
        static instance: CMsgVerticalScrollBarSize = CMsgVerticalScrollBarSize {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgVerticalScrollBarSize {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgVerticalScrollBarSize").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgVerticalScrollBarSize {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgVerticalScrollBarSize {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgVerticalScrollBarSizeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgVerticalScrollBarSizeResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgVerticalScrollBarSizeResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgVerticalScrollBarSizeResponse.scroll_max)
    pub scroll_max: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgVerticalScrollBarSizeResponse.scroll)
    pub scroll: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgVerticalScrollBarSizeResponse.zoom)
    pub zoom: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgVerticalScrollBarSizeResponse.visible)
    pub visible: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgVerticalScrollBarSizeResponse.page_size)
    pub page_size: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgVerticalScrollBarSizeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgVerticalScrollBarSizeResponse {
    fn default() -> &'a CMsgVerticalScrollBarSizeResponse {
        <CMsgVerticalScrollBarSizeResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgVerticalScrollBarSizeResponse {
    pub fn new() -> CMsgVerticalScrollBarSizeResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 scroll_max = 6;

    pub fn scroll_max(&self) -> u32 {
        self.scroll_max.unwrap_or(0)
    }

    pub fn clear_scroll_max(&mut self) {
        self.scroll_max = ::std::option::Option::None;
    }

    pub fn has_scroll_max(&self) -> bool {
        self.scroll_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scroll_max(&mut self, v: u32) {
        self.scroll_max = ::std::option::Option::Some(v);
    }

    // optional uint32 scroll = 7;

    pub fn scroll(&self) -> u32 {
        self.scroll.unwrap_or(0)
    }

    pub fn clear_scroll(&mut self) {
        self.scroll = ::std::option::Option::None;
    }

    pub fn has_scroll(&self) -> bool {
        self.scroll.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scroll(&mut self, v: u32) {
        self.scroll = ::std::option::Option::Some(v);
    }

    // optional float zoom = 8;

    pub fn zoom(&self) -> f32 {
        self.zoom.unwrap_or(0.)
    }

    pub fn clear_zoom(&mut self) {
        self.zoom = ::std::option::Option::None;
    }

    pub fn has_zoom(&self) -> bool {
        self.zoom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zoom(&mut self, v: f32) {
        self.zoom = ::std::option::Option::Some(v);
    }

    // optional bool visible = 9;

    pub fn visible(&self) -> bool {
        self.visible.unwrap_or(false)
    }

    pub fn clear_visible(&mut self) {
        self.visible = ::std::option::Option::None;
    }

    pub fn has_visible(&self) -> bool {
        self.visible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visible(&mut self, v: bool) {
        self.visible = ::std::option::Option::Some(v);
    }

    // optional uint32 page_size = 10;

    pub fn page_size(&self) -> u32 {
        self.page_size.unwrap_or(0)
    }

    pub fn clear_page_size(&mut self) {
        self.page_size = ::std::option::Option::None;
    }

    pub fn has_page_size(&self) -> bool {
        self.page_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: u32) {
        self.page_size = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgVerticalScrollBarSizeResponse| { &m.browser_handle },
            |m: &mut CMsgVerticalScrollBarSizeResponse| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scroll_max",
            |m: &CMsgVerticalScrollBarSizeResponse| { &m.scroll_max },
            |m: &mut CMsgVerticalScrollBarSizeResponse| { &mut m.scroll_max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scroll",
            |m: &CMsgVerticalScrollBarSizeResponse| { &m.scroll },
            |m: &mut CMsgVerticalScrollBarSizeResponse| { &mut m.scroll },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "zoom",
            |m: &CMsgVerticalScrollBarSizeResponse| { &m.zoom },
            |m: &mut CMsgVerticalScrollBarSizeResponse| { &mut m.zoom },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "visible",
            |m: &CMsgVerticalScrollBarSizeResponse| { &m.visible },
            |m: &mut CMsgVerticalScrollBarSizeResponse| { &mut m.visible },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "page_size",
            |m: &CMsgVerticalScrollBarSizeResponse| { &m.page_size },
            |m: &mut CMsgVerticalScrollBarSizeResponse| { &mut m.page_size },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgVerticalScrollBarSizeResponse>(
            "CMsgVerticalScrollBarSizeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgVerticalScrollBarSizeResponse {
    const NAME: &'static str = "CMsgVerticalScrollBarSizeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.scroll_max = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.scroll = ::std::option::Option::Some(is.read_uint32()?);
                },
                69 => {
                    self.zoom = ::std::option::Option::Some(is.read_float()?);
                },
                72 => {
                    self.visible = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.page_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.scroll_max {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.scroll {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.zoom {
            my_size += 1 + 4;
        }
        if let Some(v) = self.visible {
            my_size += 1 + 1;
        }
        if let Some(v) = self.page_size {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scroll_max {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.scroll {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.zoom {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.visible {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.page_size {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgVerticalScrollBarSizeResponse {
        CMsgVerticalScrollBarSizeResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.scroll_max = ::std::option::Option::None;
        self.scroll = ::std::option::Option::None;
        self.zoom = ::std::option::Option::None;
        self.visible = ::std::option::Option::None;
        self.page_size = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgVerticalScrollBarSizeResponse {
        static instance: CMsgVerticalScrollBarSizeResponse = CMsgVerticalScrollBarSizeResponse {
            browser_handle: ::std::option::Option::None,
            scroll_max: ::std::option::Option::None,
            scroll: ::std::option::Option::None,
            zoom: ::std::option::Option::None,
            visible: ::std::option::Option::None,
            page_size: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgVerticalScrollBarSizeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgVerticalScrollBarSizeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgVerticalScrollBarSizeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgVerticalScrollBarSizeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgFind)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFind {
    // message fields
    // @@protoc_insertion_point(field:CMsgFind.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgFind.find)
    pub find: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgFind.infind)
    pub infind: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgFind.reverse)
    pub reverse: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFind.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFind {
    fn default() -> &'a CMsgFind {
        <CMsgFind as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFind {
    pub fn new() -> CMsgFind {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string find = 2;

    pub fn find(&self) -> &str {
        match self.find.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_find(&mut self) {
        self.find = ::std::option::Option::None;
    }

    pub fn has_find(&self) -> bool {
        self.find.is_some()
    }

    // Param is passed by value, moved
    pub fn set_find(&mut self, v: ::std::string::String) {
        self.find = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_find(&mut self) -> &mut ::std::string::String {
        if self.find.is_none() {
            self.find = ::std::option::Option::Some(::std::string::String::new());
        }
        self.find.as_mut().unwrap()
    }

    // Take field
    pub fn take_find(&mut self) -> ::std::string::String {
        self.find.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool infind = 3;

    pub fn infind(&self) -> bool {
        self.infind.unwrap_or(false)
    }

    pub fn clear_infind(&mut self) {
        self.infind = ::std::option::Option::None;
    }

    pub fn has_infind(&self) -> bool {
        self.infind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_infind(&mut self, v: bool) {
        self.infind = ::std::option::Option::Some(v);
    }

    // optional bool reverse = 4;

    pub fn reverse(&self) -> bool {
        self.reverse.unwrap_or(false)
    }

    pub fn clear_reverse(&mut self) {
        self.reverse = ::std::option::Option::None;
    }

    pub fn has_reverse(&self) -> bool {
        self.reverse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reverse(&mut self, v: bool) {
        self.reverse = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgFind| { &m.browser_handle },
            |m: &mut CMsgFind| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "find",
            |m: &CMsgFind| { &m.find },
            |m: &mut CMsgFind| { &mut m.find },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "infind",
            |m: &CMsgFind| { &m.infind },
            |m: &mut CMsgFind| { &mut m.infind },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reverse",
            |m: &CMsgFind| { &m.reverse },
            |m: &mut CMsgFind| { &mut m.reverse },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgFind>(
            "CMsgFind",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgFind {
    const NAME: &'static str = "CMsgFind";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.find = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.infind = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.reverse = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.find.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.infind {
            my_size += 1 + 1;
        }
        if let Some(v) = self.reverse {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.find.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.infind {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.reverse {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFind {
        CMsgFind::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.find = ::std::option::Option::None;
        self.infind = ::std::option::Option::None;
        self.reverse = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFind {
        static instance: CMsgFind = CMsgFind {
            browser_handle: ::std::option::Option::None,
            find: ::std::option::Option::None,
            infind: ::std::option::Option::None,
            reverse: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgFind {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgFind").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgFind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFind {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgStopFind)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgStopFind {
    // message fields
    // @@protoc_insertion_point(field:CMsgStopFind.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgStopFind.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStopFind {
    fn default() -> &'a CMsgStopFind {
        <CMsgStopFind as ::protobuf::Message>::default_instance()
    }
}

impl CMsgStopFind {
    pub fn new() -> CMsgStopFind {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgStopFind| { &m.browser_handle },
            |m: &mut CMsgStopFind| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgStopFind>(
            "CMsgStopFind",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgStopFind {
    const NAME: &'static str = "CMsgStopFind";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStopFind {
        CMsgStopFind::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStopFind {
        static instance: CMsgStopFind = CMsgStopFind {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgStopFind {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgStopFind").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgStopFind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgStopFind {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSetHorizontalScroll)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetHorizontalScroll {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetHorizontalScroll.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetHorizontalScroll.scroll)
    pub scroll: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetHorizontalScroll.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetHorizontalScroll {
    fn default() -> &'a CMsgSetHorizontalScroll {
        <CMsgSetHorizontalScroll as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetHorizontalScroll {
    pub fn new() -> CMsgSetHorizontalScroll {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 scroll = 2;

    pub fn scroll(&self) -> u32 {
        self.scroll.unwrap_or(0)
    }

    pub fn clear_scroll(&mut self) {
        self.scroll = ::std::option::Option::None;
    }

    pub fn has_scroll(&self) -> bool {
        self.scroll.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scroll(&mut self, v: u32) {
        self.scroll = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgSetHorizontalScroll| { &m.browser_handle },
            |m: &mut CMsgSetHorizontalScroll| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scroll",
            |m: &CMsgSetHorizontalScroll| { &m.scroll },
            |m: &mut CMsgSetHorizontalScroll| { &mut m.scroll },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetHorizontalScroll>(
            "CMsgSetHorizontalScroll",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSetHorizontalScroll {
    const NAME: &'static str = "CMsgSetHorizontalScroll";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.scroll = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.scroll {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scroll {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetHorizontalScroll {
        CMsgSetHorizontalScroll::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.scroll = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetHorizontalScroll {
        static instance: CMsgSetHorizontalScroll = CMsgSetHorizontalScroll {
            browser_handle: ::std::option::Option::None,
            scroll: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSetHorizontalScroll {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetHorizontalScroll").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetHorizontalScroll {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetHorizontalScroll {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSetVerticalScroll)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetVerticalScroll {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetVerticalScroll.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetVerticalScroll.scroll)
    pub scroll: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetVerticalScroll.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetVerticalScroll {
    fn default() -> &'a CMsgSetVerticalScroll {
        <CMsgSetVerticalScroll as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetVerticalScroll {
    pub fn new() -> CMsgSetVerticalScroll {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 scroll = 2;

    pub fn scroll(&self) -> u32 {
        self.scroll.unwrap_or(0)
    }

    pub fn clear_scroll(&mut self) {
        self.scroll = ::std::option::Option::None;
    }

    pub fn has_scroll(&self) -> bool {
        self.scroll.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scroll(&mut self, v: u32) {
        self.scroll = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgSetVerticalScroll| { &m.browser_handle },
            |m: &mut CMsgSetVerticalScroll| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scroll",
            |m: &CMsgSetVerticalScroll| { &m.scroll },
            |m: &mut CMsgSetVerticalScroll| { &mut m.scroll },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetVerticalScroll>(
            "CMsgSetVerticalScroll",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSetVerticalScroll {
    const NAME: &'static str = "CMsgSetVerticalScroll";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.scroll = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.scroll {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scroll {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetVerticalScroll {
        CMsgSetVerticalScroll::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.scroll = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetVerticalScroll {
        static instance: CMsgSetVerticalScroll = CMsgSetVerticalScroll {
            browser_handle: ::std::option::Option::None,
            scroll: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSetVerticalScroll {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetVerticalScroll").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetVerticalScroll {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetVerticalScroll {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSetZoomLevel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetZoomLevel {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetZoomLevel.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetZoomLevel.zoom)
    pub zoom: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetZoomLevel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetZoomLevel {
    fn default() -> &'a CMsgSetZoomLevel {
        <CMsgSetZoomLevel as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetZoomLevel {
    pub fn new() -> CMsgSetZoomLevel {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional double zoom = 2;

    pub fn zoom(&self) -> f64 {
        self.zoom.unwrap_or(0.)
    }

    pub fn clear_zoom(&mut self) {
        self.zoom = ::std::option::Option::None;
    }

    pub fn has_zoom(&self) -> bool {
        self.zoom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zoom(&mut self, v: f64) {
        self.zoom = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgSetZoomLevel| { &m.browser_handle },
            |m: &mut CMsgSetZoomLevel| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "zoom",
            |m: &CMsgSetZoomLevel| { &m.zoom },
            |m: &mut CMsgSetZoomLevel| { &mut m.zoom },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetZoomLevel>(
            "CMsgSetZoomLevel",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSetZoomLevel {
    const NAME: &'static str = "CMsgSetZoomLevel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.zoom = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.zoom {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.zoom {
            os.write_double(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetZoomLevel {
        CMsgSetZoomLevel::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.zoom = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetZoomLevel {
        static instance: CMsgSetZoomLevel = CMsgSetZoomLevel {
            browser_handle: ::std::option::Option::None,
            zoom: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSetZoomLevel {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetZoomLevel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetZoomLevel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetZoomLevel {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgViewSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgViewSource {
    // message fields
    // @@protoc_insertion_point(field:CMsgViewSource.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgViewSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgViewSource {
    fn default() -> &'a CMsgViewSource {
        <CMsgViewSource as ::protobuf::Message>::default_instance()
    }
}

impl CMsgViewSource {
    pub fn new() -> CMsgViewSource {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgViewSource| { &m.browser_handle },
            |m: &mut CMsgViewSource| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgViewSource>(
            "CMsgViewSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgViewSource {
    const NAME: &'static str = "CMsgViewSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgViewSource {
        CMsgViewSource::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgViewSource {
        static instance: CMsgViewSource = CMsgViewSource {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgViewSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgViewSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgViewSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgViewSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgBrowserReady)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBrowserReady {
    // message fields
    // @@protoc_insertion_point(field:CMsgBrowserReady.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBrowserReady.vr_overlay_key)
    pub vr_overlay_key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBrowserReady.hwnd_browser)
    pub hwnd_browser: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBrowserReady.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserReady {
    fn default() -> &'a CMsgBrowserReady {
        <CMsgBrowserReady as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBrowserReady {
    pub fn new() -> CMsgBrowserReady {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string vr_overlay_key = 2;

    pub fn vr_overlay_key(&self) -> &str {
        match self.vr_overlay_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_vr_overlay_key(&mut self) {
        self.vr_overlay_key = ::std::option::Option::None;
    }

    pub fn has_vr_overlay_key(&self) -> bool {
        self.vr_overlay_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vr_overlay_key(&mut self, v: ::std::string::String) {
        self.vr_overlay_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vr_overlay_key(&mut self) -> &mut ::std::string::String {
        if self.vr_overlay_key.is_none() {
            self.vr_overlay_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.vr_overlay_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_vr_overlay_key(&mut self) -> ::std::string::String {
        self.vr_overlay_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 hwnd_browser = 3;

    pub fn hwnd_browser(&self) -> u64 {
        self.hwnd_browser.unwrap_or(0)
    }

    pub fn clear_hwnd_browser(&mut self) {
        self.hwnd_browser = ::std::option::Option::None;
    }

    pub fn has_hwnd_browser(&self) -> bool {
        self.hwnd_browser.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hwnd_browser(&mut self, v: u64) {
        self.hwnd_browser = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgBrowserReady| { &m.browser_handle },
            |m: &mut CMsgBrowserReady| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vr_overlay_key",
            |m: &CMsgBrowserReady| { &m.vr_overlay_key },
            |m: &mut CMsgBrowserReady| { &mut m.vr_overlay_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hwnd_browser",
            |m: &CMsgBrowserReady| { &m.hwnd_browser },
            |m: &mut CMsgBrowserReady| { &mut m.hwnd_browser },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBrowserReady>(
            "CMsgBrowserReady",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgBrowserReady {
    const NAME: &'static str = "CMsgBrowserReady";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.vr_overlay_key = ::std::option::Option::Some(is.read_string()?);
                },
                25 => {
                    self.hwnd_browser = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.vr_overlay_key.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.hwnd_browser {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.vr_overlay_key.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.hwnd_browser {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBrowserReady {
        CMsgBrowserReady::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.vr_overlay_key = ::std::option::Option::None;
        self.hwnd_browser = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBrowserReady {
        static instance: CMsgBrowserReady = CMsgBrowserReady {
            browser_handle: ::std::option::Option::None,
            vr_overlay_key: ::std::option::Option::None,
            hwnd_browser: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgBrowserReady {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBrowserReady").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBrowserReady {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBrowserReady {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgURLChanged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgURLChanged {
    // message fields
    // @@protoc_insertion_point(field:CMsgURLChanged.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgURLChanged.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgURLChanged.postData)
    pub postData: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgURLChanged.bIsRedirect)
    pub bIsRedirect: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgURLChanged.pagetitle)
    pub pagetitle: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgURLChanged.bNewNavigation)
    pub bNewNavigation: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgURLChanged.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgURLChanged {
    fn default() -> &'a CMsgURLChanged {
        <CMsgURLChanged as ::protobuf::Message>::default_instance()
    }
}

impl CMsgURLChanged {
    pub fn new() -> CMsgURLChanged {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string postData = 3;

    pub fn postData(&self) -> &str {
        match self.postData.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_postData(&mut self) {
        self.postData = ::std::option::Option::None;
    }

    pub fn has_postData(&self) -> bool {
        self.postData.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postData(&mut self, v: ::std::string::String) {
        self.postData = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_postData(&mut self) -> &mut ::std::string::String {
        if self.postData.is_none() {
            self.postData = ::std::option::Option::Some(::std::string::String::new());
        }
        self.postData.as_mut().unwrap()
    }

    // Take field
    pub fn take_postData(&mut self) -> ::std::string::String {
        self.postData.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool bIsRedirect = 4;

    pub fn bIsRedirect(&self) -> bool {
        self.bIsRedirect.unwrap_or(false)
    }

    pub fn clear_bIsRedirect(&mut self) {
        self.bIsRedirect = ::std::option::Option::None;
    }

    pub fn has_bIsRedirect(&self) -> bool {
        self.bIsRedirect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bIsRedirect(&mut self, v: bool) {
        self.bIsRedirect = ::std::option::Option::Some(v);
    }

    // optional string pagetitle = 5;

    pub fn pagetitle(&self) -> &str {
        match self.pagetitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pagetitle(&mut self) {
        self.pagetitle = ::std::option::Option::None;
    }

    pub fn has_pagetitle(&self) -> bool {
        self.pagetitle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagetitle(&mut self, v: ::std::string::String) {
        self.pagetitle = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagetitle(&mut self) -> &mut ::std::string::String {
        if self.pagetitle.is_none() {
            self.pagetitle = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pagetitle.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagetitle(&mut self) -> ::std::string::String {
        self.pagetitle.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool bNewNavigation = 6;

    pub fn bNewNavigation(&self) -> bool {
        self.bNewNavigation.unwrap_or(false)
    }

    pub fn clear_bNewNavigation(&mut self) {
        self.bNewNavigation = ::std::option::Option::None;
    }

    pub fn has_bNewNavigation(&self) -> bool {
        self.bNewNavigation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bNewNavigation(&mut self, v: bool) {
        self.bNewNavigation = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgURLChanged| { &m.browser_handle },
            |m: &mut CMsgURLChanged| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgURLChanged| { &m.url },
            |m: &mut CMsgURLChanged| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "postData",
            |m: &CMsgURLChanged| { &m.postData },
            |m: &mut CMsgURLChanged| { &mut m.postData },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bIsRedirect",
            |m: &CMsgURLChanged| { &m.bIsRedirect },
            |m: &mut CMsgURLChanged| { &mut m.bIsRedirect },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pagetitle",
            |m: &CMsgURLChanged| { &m.pagetitle },
            |m: &mut CMsgURLChanged| { &mut m.pagetitle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bNewNavigation",
            |m: &CMsgURLChanged| { &m.bNewNavigation },
            |m: &mut CMsgURLChanged| { &mut m.bNewNavigation },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgURLChanged>(
            "CMsgURLChanged",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgURLChanged {
    const NAME: &'static str = "CMsgURLChanged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.postData = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.bIsRedirect = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    self.pagetitle = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.bNewNavigation = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.postData.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.bIsRedirect {
            my_size += 1 + 1;
        }
        if let Some(v) = self.pagetitle.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.bNewNavigation {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.postData.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.bIsRedirect {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.pagetitle.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.bNewNavigation {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgURLChanged {
        CMsgURLChanged::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.postData = ::std::option::Option::None;
        self.bIsRedirect = ::std::option::Option::None;
        self.pagetitle = ::std::option::Option::None;
        self.bNewNavigation = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgURLChanged {
        static instance: CMsgURLChanged = CMsgURLChanged {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            postData: ::std::option::Option::None,
            bIsRedirect: ::std::option::Option::None,
            pagetitle: ::std::option::Option::None,
            bNewNavigation: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgURLChanged {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgURLChanged").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgURLChanged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgURLChanged {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CHTMLHeader)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CHTMLHeader {
    // message fields
    // @@protoc_insertion_point(field:CHTMLHeader.key)
    pub key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CHTMLHeader.value)
    pub value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CHTMLHeader.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CHTMLHeader {
    fn default() -> &'a CHTMLHeader {
        <CHTMLHeader as ::protobuf::Message>::default_instance()
    }
}

impl CHTMLHeader {
    pub fn new() -> CHTMLHeader {
        ::std::default::Default::default()
    }

    // optional string key = 1;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &CHTMLHeader| { &m.key },
            |m: &mut CHTMLHeader| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CHTMLHeader| { &m.value },
            |m: &mut CHTMLHeader| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CHTMLHeader>(
            "CHTMLHeader",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CHTMLHeader {
    const NAME: &'static str = "CHTMLHeader";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CHTMLHeader {
        CHTMLHeader::new()
    }

    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CHTMLHeader {
        static instance: CHTMLHeader = CHTMLHeader {
            key: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CHTMLHeader {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CHTMLHeader").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CHTMLHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CHTMLHeader {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CHTMLPageSecurityInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CHTMLPageSecurityInfo {
    // message fields
    // @@protoc_insertion_point(field:CHTMLPageSecurityInfo.bIsSecure)
    pub bIsSecure: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CHTMLPageSecurityInfo.bHasCertError)
    pub bHasCertError: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CHTMLPageSecurityInfo.issuerName)
    pub issuerName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CHTMLPageSecurityInfo.certName)
    pub certName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CHTMLPageSecurityInfo.certExpiry)
    pub certExpiry: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CHTMLPageSecurityInfo.nCertBits)
    pub nCertBits: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CHTMLPageSecurityInfo.bIsEVCert)
    pub bIsEVCert: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CHTMLPageSecurityInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CHTMLPageSecurityInfo {
    fn default() -> &'a CHTMLPageSecurityInfo {
        <CHTMLPageSecurityInfo as ::protobuf::Message>::default_instance()
    }
}

impl CHTMLPageSecurityInfo {
    pub fn new() -> CHTMLPageSecurityInfo {
        ::std::default::Default::default()
    }

    // optional bool bIsSecure = 1;

    pub fn bIsSecure(&self) -> bool {
        self.bIsSecure.unwrap_or(false)
    }

    pub fn clear_bIsSecure(&mut self) {
        self.bIsSecure = ::std::option::Option::None;
    }

    pub fn has_bIsSecure(&self) -> bool {
        self.bIsSecure.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bIsSecure(&mut self, v: bool) {
        self.bIsSecure = ::std::option::Option::Some(v);
    }

    // optional bool bHasCertError = 2;

    pub fn bHasCertError(&self) -> bool {
        self.bHasCertError.unwrap_or(false)
    }

    pub fn clear_bHasCertError(&mut self) {
        self.bHasCertError = ::std::option::Option::None;
    }

    pub fn has_bHasCertError(&self) -> bool {
        self.bHasCertError.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bHasCertError(&mut self, v: bool) {
        self.bHasCertError = ::std::option::Option::Some(v);
    }

    // optional string issuerName = 3;

    pub fn issuerName(&self) -> &str {
        match self.issuerName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_issuerName(&mut self) {
        self.issuerName = ::std::option::Option::None;
    }

    pub fn has_issuerName(&self) -> bool {
        self.issuerName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_issuerName(&mut self, v: ::std::string::String) {
        self.issuerName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_issuerName(&mut self) -> &mut ::std::string::String {
        if self.issuerName.is_none() {
            self.issuerName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.issuerName.as_mut().unwrap()
    }

    // Take field
    pub fn take_issuerName(&mut self) -> ::std::string::String {
        self.issuerName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string certName = 4;

    pub fn certName(&self) -> &str {
        match self.certName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_certName(&mut self) {
        self.certName = ::std::option::Option::None;
    }

    pub fn has_certName(&self) -> bool {
        self.certName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_certName(&mut self, v: ::std::string::String) {
        self.certName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_certName(&mut self) -> &mut ::std::string::String {
        if self.certName.is_none() {
            self.certName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.certName.as_mut().unwrap()
    }

    // Take field
    pub fn take_certName(&mut self) -> ::std::string::String {
        self.certName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 certExpiry = 5;

    pub fn certExpiry(&self) -> i32 {
        self.certExpiry.unwrap_or(0i32)
    }

    pub fn clear_certExpiry(&mut self) {
        self.certExpiry = ::std::option::Option::None;
    }

    pub fn has_certExpiry(&self) -> bool {
        self.certExpiry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_certExpiry(&mut self, v: i32) {
        self.certExpiry = ::std::option::Option::Some(v);
    }

    // optional int32 nCertBits = 6;

    pub fn nCertBits(&self) -> i32 {
        self.nCertBits.unwrap_or(0i32)
    }

    pub fn clear_nCertBits(&mut self) {
        self.nCertBits = ::std::option::Option::None;
    }

    pub fn has_nCertBits(&self) -> bool {
        self.nCertBits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nCertBits(&mut self, v: i32) {
        self.nCertBits = ::std::option::Option::Some(v);
    }

    // optional bool bIsEVCert = 7;

    pub fn bIsEVCert(&self) -> bool {
        self.bIsEVCert.unwrap_or(false)
    }

    pub fn clear_bIsEVCert(&mut self) {
        self.bIsEVCert = ::std::option::Option::None;
    }

    pub fn has_bIsEVCert(&self) -> bool {
        self.bIsEVCert.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bIsEVCert(&mut self, v: bool) {
        self.bIsEVCert = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bIsSecure",
            |m: &CHTMLPageSecurityInfo| { &m.bIsSecure },
            |m: &mut CHTMLPageSecurityInfo| { &mut m.bIsSecure },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bHasCertError",
            |m: &CHTMLPageSecurityInfo| { &m.bHasCertError },
            |m: &mut CHTMLPageSecurityInfo| { &mut m.bHasCertError },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "issuerName",
            |m: &CHTMLPageSecurityInfo| { &m.issuerName },
            |m: &mut CHTMLPageSecurityInfo| { &mut m.issuerName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "certName",
            |m: &CHTMLPageSecurityInfo| { &m.certName },
            |m: &mut CHTMLPageSecurityInfo| { &mut m.certName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "certExpiry",
            |m: &CHTMLPageSecurityInfo| { &m.certExpiry },
            |m: &mut CHTMLPageSecurityInfo| { &mut m.certExpiry },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nCertBits",
            |m: &CHTMLPageSecurityInfo| { &m.nCertBits },
            |m: &mut CHTMLPageSecurityInfo| { &mut m.nCertBits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bIsEVCert",
            |m: &CHTMLPageSecurityInfo| { &m.bIsEVCert },
            |m: &mut CHTMLPageSecurityInfo| { &mut m.bIsEVCert },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CHTMLPageSecurityInfo>(
            "CHTMLPageSecurityInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CHTMLPageSecurityInfo {
    const NAME: &'static str = "CHTMLPageSecurityInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.bIsSecure = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.bHasCertError = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.issuerName = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.certName = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.certExpiry = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.nCertBits = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.bIsEVCert = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.bIsSecure {
            my_size += 1 + 1;
        }
        if let Some(v) = self.bHasCertError {
            my_size += 1 + 1;
        }
        if let Some(v) = self.issuerName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.certName.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.certExpiry {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.nCertBits {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.bIsEVCert {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.bIsSecure {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.bHasCertError {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.issuerName.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.certName.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.certExpiry {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.nCertBits {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.bIsEVCert {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CHTMLPageSecurityInfo {
        CHTMLPageSecurityInfo::new()
    }

    fn clear(&mut self) {
        self.bIsSecure = ::std::option::Option::None;
        self.bHasCertError = ::std::option::Option::None;
        self.issuerName = ::std::option::Option::None;
        self.certName = ::std::option::Option::None;
        self.certExpiry = ::std::option::Option::None;
        self.nCertBits = ::std::option::Option::None;
        self.bIsEVCert = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CHTMLPageSecurityInfo {
        static instance: CHTMLPageSecurityInfo = CHTMLPageSecurityInfo {
            bIsSecure: ::std::option::Option::None,
            bHasCertError: ::std::option::Option::None,
            issuerName: ::std::option::Option::None,
            certName: ::std::option::Option::None,
            certExpiry: ::std::option::Option::None,
            nCertBits: ::std::option::Option::None,
            bIsEVCert: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CHTMLPageSecurityInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CHTMLPageSecurityInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CHTMLPageSecurityInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CHTMLPageSecurityInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgFinishedRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFinishedRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgFinishedRequest.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgFinishedRequest.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgFinishedRequest.pageTitle)
    pub pageTitle: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFinishedRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFinishedRequest {
    fn default() -> &'a CMsgFinishedRequest {
        <CMsgFinishedRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFinishedRequest {
    pub fn new() -> CMsgFinishedRequest {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string pageTitle = 3;

    pub fn pageTitle(&self) -> &str {
        match self.pageTitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pageTitle(&mut self) {
        self.pageTitle = ::std::option::Option::None;
    }

    pub fn has_pageTitle(&self) -> bool {
        self.pageTitle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pageTitle(&mut self, v: ::std::string::String) {
        self.pageTitle = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pageTitle(&mut self) -> &mut ::std::string::String {
        if self.pageTitle.is_none() {
            self.pageTitle = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pageTitle.as_mut().unwrap()
    }

    // Take field
    pub fn take_pageTitle(&mut self) -> ::std::string::String {
        self.pageTitle.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgFinishedRequest| { &m.browser_handle },
            |m: &mut CMsgFinishedRequest| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgFinishedRequest| { &m.url },
            |m: &mut CMsgFinishedRequest| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pageTitle",
            |m: &CMsgFinishedRequest| { &m.pageTitle },
            |m: &mut CMsgFinishedRequest| { &mut m.pageTitle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgFinishedRequest>(
            "CMsgFinishedRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgFinishedRequest {
    const NAME: &'static str = "CMsgFinishedRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.pageTitle = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.pageTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.pageTitle.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFinishedRequest {
        CMsgFinishedRequest::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.pageTitle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFinishedRequest {
        static instance: CMsgFinishedRequest = CMsgFinishedRequest {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            pageTitle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgFinishedRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgFinishedRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgFinishedRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFinishedRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgLoadedRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLoadedRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgLoadedRequest.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLoadedRequest.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgLoadedRequest.pageTitle)
    pub pageTitle: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgLoadedRequest.headers)
    pub headers: ::std::vec::Vec<CHTMLHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLoadedRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLoadedRequest {
    fn default() -> &'a CMsgLoadedRequest {
        <CMsgLoadedRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLoadedRequest {
    pub fn new() -> CMsgLoadedRequest {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string pageTitle = 3;

    pub fn pageTitle(&self) -> &str {
        match self.pageTitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pageTitle(&mut self) {
        self.pageTitle = ::std::option::Option::None;
    }

    pub fn has_pageTitle(&self) -> bool {
        self.pageTitle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pageTitle(&mut self, v: ::std::string::String) {
        self.pageTitle = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pageTitle(&mut self) -> &mut ::std::string::String {
        if self.pageTitle.is_none() {
            self.pageTitle = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pageTitle.as_mut().unwrap()
    }

    // Take field
    pub fn take_pageTitle(&mut self) -> ::std::string::String {
        self.pageTitle.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgLoadedRequest| { &m.browser_handle },
            |m: &mut CMsgLoadedRequest| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgLoadedRequest| { &m.url },
            |m: &mut CMsgLoadedRequest| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pageTitle",
            |m: &CMsgLoadedRequest| { &m.pageTitle },
            |m: &mut CMsgLoadedRequest| { &mut m.pageTitle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "headers",
            |m: &CMsgLoadedRequest| { &m.headers },
            |m: &mut CMsgLoadedRequest| { &mut m.headers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLoadedRequest>(
            "CMsgLoadedRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgLoadedRequest {
    const NAME: &'static str = "CMsgLoadedRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.pageTitle = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.headers.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.pageTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.headers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.pageTitle.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.headers {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLoadedRequest {
        CMsgLoadedRequest::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.pageTitle = ::std::option::Option::None;
        self.headers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLoadedRequest {
        static instance: CMsgLoadedRequest = CMsgLoadedRequest {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            pageTitle: ::std::option::Option::None,
            headers: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgLoadedRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLoadedRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLoadedRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLoadedRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPageSecurity)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPageSecurity {
    // message fields
    // @@protoc_insertion_point(field:CMsgPageSecurity.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPageSecurity.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgPageSecurity.security_info)
    pub security_info: ::protobuf::MessageField<CHTMLPageSecurityInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPageSecurity.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPageSecurity {
    fn default() -> &'a CMsgPageSecurity {
        <CMsgPageSecurity as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPageSecurity {
    pub fn new() -> CMsgPageSecurity {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgPageSecurity| { &m.browser_handle },
            |m: &mut CMsgPageSecurity| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgPageSecurity| { &m.url },
            |m: &mut CMsgPageSecurity| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CHTMLPageSecurityInfo>(
            "security_info",
            |m: &CMsgPageSecurity| { &m.security_info },
            |m: &mut CMsgPageSecurity| { &mut m.security_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPageSecurity>(
            "CMsgPageSecurity",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPageSecurity {
    const NAME: &'static str = "CMsgPageSecurity";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.security_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.security_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.security_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPageSecurity {
        CMsgPageSecurity::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.security_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPageSecurity {
        static instance: CMsgPageSecurity = CMsgPageSecurity {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            security_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPageSecurity {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPageSecurity").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPageSecurity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPageSecurity {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgStartRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgStartRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgStartRequest.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgStartRequest.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgStartRequest.target)
    pub target: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgStartRequest.postData)
    pub postData: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgStartRequest.bIsRedirect)
    pub bIsRedirect: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgStartRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStartRequest {
    fn default() -> &'a CMsgStartRequest {
        <CMsgStartRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgStartRequest {
    pub fn new() -> CMsgStartRequest {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string target = 3;

    pub fn target(&self) -> &str {
        match self.target.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_target(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target(&self) -> bool {
        self.target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: ::std::string::String) {
        self.target = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target(&mut self) -> &mut ::std::string::String {
        if self.target.is_none() {
            self.target = ::std::option::Option::Some(::std::string::String::new());
        }
        self.target.as_mut().unwrap()
    }

    // Take field
    pub fn take_target(&mut self) -> ::std::string::String {
        self.target.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string postData = 4;

    pub fn postData(&self) -> &str {
        match self.postData.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_postData(&mut self) {
        self.postData = ::std::option::Option::None;
    }

    pub fn has_postData(&self) -> bool {
        self.postData.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postData(&mut self, v: ::std::string::String) {
        self.postData = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_postData(&mut self) -> &mut ::std::string::String {
        if self.postData.is_none() {
            self.postData = ::std::option::Option::Some(::std::string::String::new());
        }
        self.postData.as_mut().unwrap()
    }

    // Take field
    pub fn take_postData(&mut self) -> ::std::string::String {
        self.postData.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool bIsRedirect = 5;

    pub fn bIsRedirect(&self) -> bool {
        self.bIsRedirect.unwrap_or(false)
    }

    pub fn clear_bIsRedirect(&mut self) {
        self.bIsRedirect = ::std::option::Option::None;
    }

    pub fn has_bIsRedirect(&self) -> bool {
        self.bIsRedirect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bIsRedirect(&mut self, v: bool) {
        self.bIsRedirect = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgStartRequest| { &m.browser_handle },
            |m: &mut CMsgStartRequest| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgStartRequest| { &m.url },
            |m: &mut CMsgStartRequest| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target",
            |m: &CMsgStartRequest| { &m.target },
            |m: &mut CMsgStartRequest| { &mut m.target },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "postData",
            |m: &CMsgStartRequest| { &m.postData },
            |m: &mut CMsgStartRequest| { &mut m.postData },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bIsRedirect",
            |m: &CMsgStartRequest| { &m.bIsRedirect },
            |m: &mut CMsgStartRequest| { &mut m.bIsRedirect },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgStartRequest>(
            "CMsgStartRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgStartRequest {
    const NAME: &'static str = "CMsgStartRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.target = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.postData = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.bIsRedirect = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.target.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.postData.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.bIsRedirect {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.target.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.postData.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.bIsRedirect {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStartRequest {
        CMsgStartRequest::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.postData = ::std::option::Option::None;
        self.bIsRedirect = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStartRequest {
        static instance: CMsgStartRequest = CMsgStartRequest {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            target: ::std::option::Option::None,
            postData: ::std::option::Option::None,
            bIsRedirect: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgStartRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgStartRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgStartRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgStartRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgStartRequestResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgStartRequestResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgStartRequestResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgStartRequestResponse.bAllow)
    pub bAllow: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgStartRequestResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStartRequestResponse {
    fn default() -> &'a CMsgStartRequestResponse {
        <CMsgStartRequestResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgStartRequestResponse {
    pub fn new() -> CMsgStartRequestResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool bAllow = 2;

    pub fn bAllow(&self) -> bool {
        self.bAllow.unwrap_or(false)
    }

    pub fn clear_bAllow(&mut self) {
        self.bAllow = ::std::option::Option::None;
    }

    pub fn has_bAllow(&self) -> bool {
        self.bAllow.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bAllow(&mut self, v: bool) {
        self.bAllow = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgStartRequestResponse| { &m.browser_handle },
            |m: &mut CMsgStartRequestResponse| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bAllow",
            |m: &CMsgStartRequestResponse| { &m.bAllow },
            |m: &mut CMsgStartRequestResponse| { &mut m.bAllow },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgStartRequestResponse>(
            "CMsgStartRequestResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgStartRequestResponse {
    const NAME: &'static str = "CMsgStartRequestResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.bAllow = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.bAllow {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.bAllow {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStartRequestResponse {
        CMsgStartRequestResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.bAllow = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStartRequestResponse {
        static instance: CMsgStartRequestResponse = CMsgStartRequestResponse {
            browser_handle: ::std::option::Option::None,
            bAllow: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgStartRequestResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgStartRequestResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgStartRequestResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgStartRequestResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgShowPopup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgShowPopup {
    // message fields
    // @@protoc_insertion_point(field:CMsgShowPopup.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgShowPopup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgShowPopup {
    fn default() -> &'a CMsgShowPopup {
        <CMsgShowPopup as ::protobuf::Message>::default_instance()
    }
}

impl CMsgShowPopup {
    pub fn new() -> CMsgShowPopup {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgShowPopup| { &m.browser_handle },
            |m: &mut CMsgShowPopup| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgShowPopup>(
            "CMsgShowPopup",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgShowPopup {
    const NAME: &'static str = "CMsgShowPopup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgShowPopup {
        CMsgShowPopup::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgShowPopup {
        static instance: CMsgShowPopup = CMsgShowPopup {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgShowPopup {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgShowPopup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgShowPopup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgShowPopup {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgHidePopup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHidePopup {
    // message fields
    // @@protoc_insertion_point(field:CMsgHidePopup.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgHidePopup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHidePopup {
    fn default() -> &'a CMsgHidePopup {
        <CMsgHidePopup as ::protobuf::Message>::default_instance()
    }
}

impl CMsgHidePopup {
    pub fn new() -> CMsgHidePopup {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgHidePopup| { &m.browser_handle },
            |m: &mut CMsgHidePopup| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgHidePopup>(
            "CMsgHidePopup",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgHidePopup {
    const NAME: &'static str = "CMsgHidePopup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHidePopup {
        CMsgHidePopup::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHidePopup {
        static instance: CMsgHidePopup = CMsgHidePopup {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgHidePopup {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgHidePopup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgHidePopup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgHidePopup {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSizePopup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSizePopup {
    // message fields
    // @@protoc_insertion_point(field:CMsgSizePopup.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSizePopup.x)
    pub x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSizePopup.y)
    pub y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSizePopup.wide)
    pub wide: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSizePopup.tall)
    pub tall: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSizePopup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSizePopup {
    fn default() -> &'a CMsgSizePopup {
        <CMsgSizePopup as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSizePopup {
    pub fn new() -> CMsgSizePopup {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional int32 x = 2;

    pub fn x(&self) -> i32 {
        self.x.unwrap_or(0)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: i32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional int32 y = 3;

    pub fn y(&self) -> i32 {
        self.y.unwrap_or(0)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: i32) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional uint32 wide = 4;

    pub fn wide(&self) -> u32 {
        self.wide.unwrap_or(0)
    }

    pub fn clear_wide(&mut self) {
        self.wide = ::std::option::Option::None;
    }

    pub fn has_wide(&self) -> bool {
        self.wide.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wide(&mut self, v: u32) {
        self.wide = ::std::option::Option::Some(v);
    }

    // optional uint32 tall = 5;

    pub fn tall(&self) -> u32 {
        self.tall.unwrap_or(0)
    }

    pub fn clear_tall(&mut self) {
        self.tall = ::std::option::Option::None;
    }

    pub fn has_tall(&self) -> bool {
        self.tall.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tall(&mut self, v: u32) {
        self.tall = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgSizePopup| { &m.browser_handle },
            |m: &mut CMsgSizePopup| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &CMsgSizePopup| { &m.x },
            |m: &mut CMsgSizePopup| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &CMsgSizePopup| { &m.y },
            |m: &mut CMsgSizePopup| { &mut m.y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "wide",
            |m: &CMsgSizePopup| { &m.wide },
            |m: &mut CMsgSizePopup| { &mut m.wide },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tall",
            |m: &CMsgSizePopup| { &m.tall },
            |m: &mut CMsgSizePopup| { &mut m.tall },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSizePopup>(
            "CMsgSizePopup",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSizePopup {
    const NAME: &'static str = "CMsgSizePopup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.x = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.y = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.wide = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.tall = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.wide {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.tall {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.wide {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.tall {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSizePopup {
        CMsgSizePopup::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.wide = ::std::option::Option::None;
        self.tall = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSizePopup {
        static instance: CMsgSizePopup = CMsgSizePopup {
            browser_handle: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            wide: ::std::option::Option::None,
            tall: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSizePopup {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSizePopup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSizePopup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSizePopup {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgOpenNewTab)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgOpenNewTab {
    // message fields
    // @@protoc_insertion_point(field:CMsgOpenNewTab.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgOpenNewTab.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgOpenNewTab.bForeground)
    pub bForeground: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgOpenNewTab.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgOpenNewTab {
    fn default() -> &'a CMsgOpenNewTab {
        <CMsgOpenNewTab as ::protobuf::Message>::default_instance()
    }
}

impl CMsgOpenNewTab {
    pub fn new() -> CMsgOpenNewTab {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool bForeground = 3;

    pub fn bForeground(&self) -> bool {
        self.bForeground.unwrap_or(false)
    }

    pub fn clear_bForeground(&mut self) {
        self.bForeground = ::std::option::Option::None;
    }

    pub fn has_bForeground(&self) -> bool {
        self.bForeground.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bForeground(&mut self, v: bool) {
        self.bForeground = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgOpenNewTab| { &m.browser_handle },
            |m: &mut CMsgOpenNewTab| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgOpenNewTab| { &m.url },
            |m: &mut CMsgOpenNewTab| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bForeground",
            |m: &CMsgOpenNewTab| { &m.bForeground },
            |m: &mut CMsgOpenNewTab| { &mut m.bForeground },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgOpenNewTab>(
            "CMsgOpenNewTab",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgOpenNewTab {
    const NAME: &'static str = "CMsgOpenNewTab";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.bForeground = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.bForeground {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.bForeground {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgOpenNewTab {
        CMsgOpenNewTab::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.bForeground = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgOpenNewTab {
        static instance: CMsgOpenNewTab = CMsgOpenNewTab {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            bForeground: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgOpenNewTab {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgOpenNewTab").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgOpenNewTab {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgOpenNewTab {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPopupHTMLWindow)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPopupHTMLWindow {
    // message fields
    // @@protoc_insertion_point(field:CMsgPopupHTMLWindow.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPopupHTMLWindow.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgPopupHTMLWindow.x)
    pub x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgPopupHTMLWindow.y)
    pub y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgPopupHTMLWindow.wide)
    pub wide: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPopupHTMLWindow.tall)
    pub tall: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPopupHTMLWindow.popup_index)
    pub popup_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPopupHTMLWindow.trusted_creator)
    pub trusted_creator: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPopupHTMLWindow.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPopupHTMLWindow {
    fn default() -> &'a CMsgPopupHTMLWindow {
        <CMsgPopupHTMLWindow as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPopupHTMLWindow {
    pub fn new() -> CMsgPopupHTMLWindow {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 x = 3;

    pub fn x(&self) -> i32 {
        self.x.unwrap_or(-2147483648i32)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: i32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional int32 y = 4;

    pub fn y(&self) -> i32 {
        self.y.unwrap_or(-2147483648i32)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: i32) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional uint32 wide = 5;

    pub fn wide(&self) -> u32 {
        self.wide.unwrap_or(0)
    }

    pub fn clear_wide(&mut self) {
        self.wide = ::std::option::Option::None;
    }

    pub fn has_wide(&self) -> bool {
        self.wide.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wide(&mut self, v: u32) {
        self.wide = ::std::option::Option::Some(v);
    }

    // optional uint32 tall = 6;

    pub fn tall(&self) -> u32 {
        self.tall.unwrap_or(0)
    }

    pub fn clear_tall(&mut self) {
        self.tall = ::std::option::Option::None;
    }

    pub fn has_tall(&self) -> bool {
        self.tall.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tall(&mut self, v: u32) {
        self.tall = ::std::option::Option::Some(v);
    }

    // optional uint32 popup_index = 7;

    pub fn popup_index(&self) -> u32 {
        self.popup_index.unwrap_or(0)
    }

    pub fn clear_popup_index(&mut self) {
        self.popup_index = ::std::option::Option::None;
    }

    pub fn has_popup_index(&self) -> bool {
        self.popup_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_popup_index(&mut self, v: u32) {
        self.popup_index = ::std::option::Option::Some(v);
    }

    // optional bool trusted_creator = 8;

    pub fn trusted_creator(&self) -> bool {
        self.trusted_creator.unwrap_or(false)
    }

    pub fn clear_trusted_creator(&mut self) {
        self.trusted_creator = ::std::option::Option::None;
    }

    pub fn has_trusted_creator(&self) -> bool {
        self.trusted_creator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trusted_creator(&mut self, v: bool) {
        self.trusted_creator = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgPopupHTMLWindow| { &m.browser_handle },
            |m: &mut CMsgPopupHTMLWindow| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgPopupHTMLWindow| { &m.url },
            |m: &mut CMsgPopupHTMLWindow| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &CMsgPopupHTMLWindow| { &m.x },
            |m: &mut CMsgPopupHTMLWindow| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &CMsgPopupHTMLWindow| { &m.y },
            |m: &mut CMsgPopupHTMLWindow| { &mut m.y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "wide",
            |m: &CMsgPopupHTMLWindow| { &m.wide },
            |m: &mut CMsgPopupHTMLWindow| { &mut m.wide },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tall",
            |m: &CMsgPopupHTMLWindow| { &m.tall },
            |m: &mut CMsgPopupHTMLWindow| { &mut m.tall },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "popup_index",
            |m: &CMsgPopupHTMLWindow| { &m.popup_index },
            |m: &mut CMsgPopupHTMLWindow| { &mut m.popup_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "trusted_creator",
            |m: &CMsgPopupHTMLWindow| { &m.trusted_creator },
            |m: &mut CMsgPopupHTMLWindow| { &mut m.trusted_creator },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPopupHTMLWindow>(
            "CMsgPopupHTMLWindow",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPopupHTMLWindow {
    const NAME: &'static str = "CMsgPopupHTMLWindow";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.x = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.y = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.wide = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.tall = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.popup_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.trusted_creator = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.wide {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.tall {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.popup_index {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.trusted_creator {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.x {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.y {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.wide {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.tall {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.popup_index {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.trusted_creator {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPopupHTMLWindow {
        CMsgPopupHTMLWindow::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.wide = ::std::option::Option::None;
        self.tall = ::std::option::Option::None;
        self.popup_index = ::std::option::Option::None;
        self.trusted_creator = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPopupHTMLWindow {
        static instance: CMsgPopupHTMLWindow = CMsgPopupHTMLWindow {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            wide: ::std::option::Option::None,
            tall: ::std::option::Option::None,
            popup_index: ::std::option::Option::None,
            trusted_creator: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPopupHTMLWindow {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPopupHTMLWindow").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPopupHTMLWindow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPopupHTMLWindow {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPopupHTMLWindowResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPopupHTMLWindowResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgPopupHTMLWindowResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPopupHTMLWindowResponse.bAllow)
    pub bAllow: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPopupHTMLWindowResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPopupHTMLWindowResponse {
    fn default() -> &'a CMsgPopupHTMLWindowResponse {
        <CMsgPopupHTMLWindowResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPopupHTMLWindowResponse {
    pub fn new() -> CMsgPopupHTMLWindowResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool bAllow = 2;

    pub fn bAllow(&self) -> bool {
        self.bAllow.unwrap_or(false)
    }

    pub fn clear_bAllow(&mut self) {
        self.bAllow = ::std::option::Option::None;
    }

    pub fn has_bAllow(&self) -> bool {
        self.bAllow.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bAllow(&mut self, v: bool) {
        self.bAllow = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgPopupHTMLWindowResponse| { &m.browser_handle },
            |m: &mut CMsgPopupHTMLWindowResponse| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bAllow",
            |m: &CMsgPopupHTMLWindowResponse| { &m.bAllow },
            |m: &mut CMsgPopupHTMLWindowResponse| { &mut m.bAllow },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPopupHTMLWindowResponse>(
            "CMsgPopupHTMLWindowResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPopupHTMLWindowResponse {
    const NAME: &'static str = "CMsgPopupHTMLWindowResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.bAllow = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.bAllow {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.bAllow {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPopupHTMLWindowResponse {
        CMsgPopupHTMLWindowResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.bAllow = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPopupHTMLWindowResponse {
        static instance: CMsgPopupHTMLWindowResponse = CMsgPopupHTMLWindowResponse {
            browser_handle: ::std::option::Option::None,
            bAllow: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPopupHTMLWindowResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPopupHTMLWindowResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPopupHTMLWindowResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPopupHTMLWindowResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSetHTMLTitle)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetHTMLTitle {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetHTMLTitle.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetHTMLTitle.title)
    pub title: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetHTMLTitle.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetHTMLTitle {
    fn default() -> &'a CMsgSetHTMLTitle {
        <CMsgSetHTMLTitle as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetHTMLTitle {
    pub fn new() -> CMsgSetHTMLTitle {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string title = 2;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgSetHTMLTitle| { &m.browser_handle },
            |m: &mut CMsgSetHTMLTitle| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &CMsgSetHTMLTitle| { &m.title },
            |m: &mut CMsgSetHTMLTitle| { &mut m.title },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetHTMLTitle>(
            "CMsgSetHTMLTitle",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSetHTMLTitle {
    const NAME: &'static str = "CMsgSetHTMLTitle";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetHTMLTitle {
        CMsgSetHTMLTitle::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetHTMLTitle {
        static instance: CMsgSetHTMLTitle = CMsgSetHTMLTitle {
            browser_handle: ::std::option::Option::None,
            title: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSetHTMLTitle {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetHTMLTitle").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetHTMLTitle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetHTMLTitle {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgLoadingResource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLoadingResource {
    // message fields
    // @@protoc_insertion_point(field:CMsgLoadingResource.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLoadingResource.url)
    pub url: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLoadingResource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLoadingResource {
    fn default() -> &'a CMsgLoadingResource {
        <CMsgLoadingResource as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLoadingResource {
    pub fn new() -> CMsgLoadingResource {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgLoadingResource| { &m.browser_handle },
            |m: &mut CMsgLoadingResource| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgLoadingResource| { &m.url },
            |m: &mut CMsgLoadingResource| { &mut m.url },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLoadingResource>(
            "CMsgLoadingResource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgLoadingResource {
    const NAME: &'static str = "CMsgLoadingResource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLoadingResource {
        CMsgLoadingResource::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLoadingResource {
        static instance: CMsgLoadingResource = CMsgLoadingResource {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgLoadingResource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLoadingResource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLoadingResource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLoadingResource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgStatusText)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgStatusText {
    // message fields
    // @@protoc_insertion_point(field:CMsgStatusText.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgStatusText.text)
    pub text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgStatusText.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStatusText {
    fn default() -> &'a CMsgStatusText {
        <CMsgStatusText as ::protobuf::Message>::default_instance()
    }
}

impl CMsgStatusText {
    pub fn new() -> CMsgStatusText {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgStatusText| { &m.browser_handle },
            |m: &mut CMsgStatusText| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &CMsgStatusText| { &m.text },
            |m: &mut CMsgStatusText| { &mut m.text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgStatusText>(
            "CMsgStatusText",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgStatusText {
    const NAME: &'static str = "CMsgStatusText";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStatusText {
        CMsgStatusText::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStatusText {
        static instance: CMsgStatusText = CMsgStatusText {
            browser_handle: ::std::option::Option::None,
            text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgStatusText {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgStatusText").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgStatusText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgStatusText {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSetCursor)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetCursor {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetCursor.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetCursor.cursor)
    pub cursor: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetCursor.custom_data)
    pub custom_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgSetCursor.wide)
    pub wide: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetCursor.tall)
    pub tall: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetCursor.xhotspot)
    pub xhotspot: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetCursor.yhotspot)
    pub yhotspot: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetCursor.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetCursor {
    fn default() -> &'a CMsgSetCursor {
        <CMsgSetCursor as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetCursor {
    pub fn new() -> CMsgSetCursor {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 cursor = 2;

    pub fn cursor(&self) -> u32 {
        self.cursor.unwrap_or(0)
    }

    pub fn clear_cursor(&mut self) {
        self.cursor = ::std::option::Option::None;
    }

    pub fn has_cursor(&self) -> bool {
        self.cursor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cursor(&mut self, v: u32) {
        self.cursor = ::std::option::Option::Some(v);
    }

    // optional bytes custom_data = 3;

    pub fn custom_data(&self) -> &[u8] {
        match self.custom_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_custom_data(&mut self) {
        self.custom_data = ::std::option::Option::None;
    }

    pub fn has_custom_data(&self) -> bool {
        self.custom_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.custom_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.custom_data.is_none() {
            self.custom_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.custom_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_data(&mut self) -> ::std::vec::Vec<u8> {
        self.custom_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 wide = 4;

    pub fn wide(&self) -> u32 {
        self.wide.unwrap_or(0)
    }

    pub fn clear_wide(&mut self) {
        self.wide = ::std::option::Option::None;
    }

    pub fn has_wide(&self) -> bool {
        self.wide.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wide(&mut self, v: u32) {
        self.wide = ::std::option::Option::Some(v);
    }

    // optional uint32 tall = 5;

    pub fn tall(&self) -> u32 {
        self.tall.unwrap_or(0)
    }

    pub fn clear_tall(&mut self) {
        self.tall = ::std::option::Option::None;
    }

    pub fn has_tall(&self) -> bool {
        self.tall.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tall(&mut self, v: u32) {
        self.tall = ::std::option::Option::Some(v);
    }

    // optional uint32 xhotspot = 6;

    pub fn xhotspot(&self) -> u32 {
        self.xhotspot.unwrap_or(0)
    }

    pub fn clear_xhotspot(&mut self) {
        self.xhotspot = ::std::option::Option::None;
    }

    pub fn has_xhotspot(&self) -> bool {
        self.xhotspot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xhotspot(&mut self, v: u32) {
        self.xhotspot = ::std::option::Option::Some(v);
    }

    // optional uint32 yhotspot = 7;

    pub fn yhotspot(&self) -> u32 {
        self.yhotspot.unwrap_or(0)
    }

    pub fn clear_yhotspot(&mut self) {
        self.yhotspot = ::std::option::Option::None;
    }

    pub fn has_yhotspot(&self) -> bool {
        self.yhotspot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_yhotspot(&mut self, v: u32) {
        self.yhotspot = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgSetCursor| { &m.browser_handle },
            |m: &mut CMsgSetCursor| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cursor",
            |m: &CMsgSetCursor| { &m.cursor },
            |m: &mut CMsgSetCursor| { &mut m.cursor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_data",
            |m: &CMsgSetCursor| { &m.custom_data },
            |m: &mut CMsgSetCursor| { &mut m.custom_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "wide",
            |m: &CMsgSetCursor| { &m.wide },
            |m: &mut CMsgSetCursor| { &mut m.wide },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tall",
            |m: &CMsgSetCursor| { &m.tall },
            |m: &mut CMsgSetCursor| { &mut m.tall },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "xhotspot",
            |m: &CMsgSetCursor| { &m.xhotspot },
            |m: &mut CMsgSetCursor| { &mut m.xhotspot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "yhotspot",
            |m: &CMsgSetCursor| { &m.yhotspot },
            |m: &mut CMsgSetCursor| { &mut m.yhotspot },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetCursor>(
            "CMsgSetCursor",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSetCursor {
    const NAME: &'static str = "CMsgSetCursor";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.cursor = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.custom_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                32 => {
                    self.wide = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.tall = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.xhotspot = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.yhotspot = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.cursor {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.custom_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.wide {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.tall {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.xhotspot {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.yhotspot {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.cursor {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.custom_data.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.wide {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.tall {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.xhotspot {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.yhotspot {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetCursor {
        CMsgSetCursor::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.cursor = ::std::option::Option::None;
        self.custom_data = ::std::option::Option::None;
        self.wide = ::std::option::Option::None;
        self.tall = ::std::option::Option::None;
        self.xhotspot = ::std::option::Option::None;
        self.yhotspot = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetCursor {
        static instance: CMsgSetCursor = CMsgSetCursor {
            browser_handle: ::std::option::Option::None,
            cursor: ::std::option::Option::None,
            custom_data: ::std::option::Option::None,
            wide: ::std::option::Option::None,
            tall: ::std::option::Option::None,
            xhotspot: ::std::option::Option::None,
            yhotspot: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSetCursor {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetCursor").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetCursor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetCursor {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgFileLoadDialog)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFileLoadDialog {
    // message fields
    // @@protoc_insertion_point(field:CMsgFileLoadDialog.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgFileLoadDialog.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgFileLoadDialog.initialFile)
    pub initialFile: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgFileLoadDialog.accept_types)
    pub accept_types: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgFileLoadDialog.is_save)
    pub is_save: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFileLoadDialog.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFileLoadDialog {
    fn default() -> &'a CMsgFileLoadDialog {
        <CMsgFileLoadDialog as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFileLoadDialog {
    pub fn new() -> CMsgFileLoadDialog {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string title = 2;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string initialFile = 3;

    pub fn initialFile(&self) -> &str {
        match self.initialFile.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_initialFile(&mut self) {
        self.initialFile = ::std::option::Option::None;
    }

    pub fn has_initialFile(&self) -> bool {
        self.initialFile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initialFile(&mut self, v: ::std::string::String) {
        self.initialFile = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initialFile(&mut self) -> &mut ::std::string::String {
        if self.initialFile.is_none() {
            self.initialFile = ::std::option::Option::Some(::std::string::String::new());
        }
        self.initialFile.as_mut().unwrap()
    }

    // Take field
    pub fn take_initialFile(&mut self) -> ::std::string::String {
        self.initialFile.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_save = 5;

    pub fn is_save(&self) -> bool {
        self.is_save.unwrap_or(false)
    }

    pub fn clear_is_save(&mut self) {
        self.is_save = ::std::option::Option::None;
    }

    pub fn has_is_save(&self) -> bool {
        self.is_save.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_save(&mut self, v: bool) {
        self.is_save = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgFileLoadDialog| { &m.browser_handle },
            |m: &mut CMsgFileLoadDialog| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &CMsgFileLoadDialog| { &m.title },
            |m: &mut CMsgFileLoadDialog| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "initialFile",
            |m: &CMsgFileLoadDialog| { &m.initialFile },
            |m: &mut CMsgFileLoadDialog| { &mut m.initialFile },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "accept_types",
            |m: &CMsgFileLoadDialog| { &m.accept_types },
            |m: &mut CMsgFileLoadDialog| { &mut m.accept_types },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_save",
            |m: &CMsgFileLoadDialog| { &m.is_save },
            |m: &mut CMsgFileLoadDialog| { &mut m.is_save },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgFileLoadDialog>(
            "CMsgFileLoadDialog",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgFileLoadDialog {
    const NAME: &'static str = "CMsgFileLoadDialog";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.initialFile = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.accept_types.push(is.read_string()?);
                },
                40 => {
                    self.is_save = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.initialFile.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.accept_types {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(v) = self.is_save {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.initialFile.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.accept_types {
            os.write_string(4, &v)?;
        };
        if let Some(v) = self.is_save {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFileLoadDialog {
        CMsgFileLoadDialog::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.initialFile = ::std::option::Option::None;
        self.accept_types.clear();
        self.is_save = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFileLoadDialog {
        static instance: CMsgFileLoadDialog = CMsgFileLoadDialog {
            browser_handle: ::std::option::Option::None,
            title: ::std::option::Option::None,
            initialFile: ::std::option::Option::None,
            accept_types: ::std::vec::Vec::new(),
            is_save: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgFileLoadDialog {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgFileLoadDialog").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgFileLoadDialog {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFileLoadDialog {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgFileLoadDialogResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFileLoadDialogResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgFileLoadDialogResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgFileLoadDialogResponse.files)
    pub files: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFileLoadDialogResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFileLoadDialogResponse {
    fn default() -> &'a CMsgFileLoadDialogResponse {
        <CMsgFileLoadDialogResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFileLoadDialogResponse {
    pub fn new() -> CMsgFileLoadDialogResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgFileLoadDialogResponse| { &m.browser_handle },
            |m: &mut CMsgFileLoadDialogResponse| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "files",
            |m: &CMsgFileLoadDialogResponse| { &m.files },
            |m: &mut CMsgFileLoadDialogResponse| { &mut m.files },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgFileLoadDialogResponse>(
            "CMsgFileLoadDialogResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgFileLoadDialogResponse {
    const NAME: &'static str = "CMsgFileLoadDialogResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.files.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.files {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        for v in &self.files {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFileLoadDialogResponse {
        CMsgFileLoadDialogResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.files.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFileLoadDialogResponse {
        static instance: CMsgFileLoadDialogResponse = CMsgFileLoadDialogResponse {
            browser_handle: ::std::option::Option::None,
            files: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgFileLoadDialogResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgFileLoadDialogResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgFileLoadDialogResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFileLoadDialogResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgShowToolTip)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgShowToolTip {
    // message fields
    // @@protoc_insertion_point(field:CMsgShowToolTip.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgShowToolTip.text)
    pub text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgShowToolTip.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgShowToolTip {
    fn default() -> &'a CMsgShowToolTip {
        <CMsgShowToolTip as ::protobuf::Message>::default_instance()
    }
}

impl CMsgShowToolTip {
    pub fn new() -> CMsgShowToolTip {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgShowToolTip| { &m.browser_handle },
            |m: &mut CMsgShowToolTip| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &CMsgShowToolTip| { &m.text },
            |m: &mut CMsgShowToolTip| { &mut m.text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgShowToolTip>(
            "CMsgShowToolTip",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgShowToolTip {
    const NAME: &'static str = "CMsgShowToolTip";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgShowToolTip {
        CMsgShowToolTip::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgShowToolTip {
        static instance: CMsgShowToolTip = CMsgShowToolTip {
            browser_handle: ::std::option::Option::None,
            text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgShowToolTip {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgShowToolTip").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgShowToolTip {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgShowToolTip {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgUpdateToolTip)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgUpdateToolTip {
    // message fields
    // @@protoc_insertion_point(field:CMsgUpdateToolTip.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgUpdateToolTip.text)
    pub text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgUpdateToolTip.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgUpdateToolTip {
    fn default() -> &'a CMsgUpdateToolTip {
        <CMsgUpdateToolTip as ::protobuf::Message>::default_instance()
    }
}

impl CMsgUpdateToolTip {
    pub fn new() -> CMsgUpdateToolTip {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgUpdateToolTip| { &m.browser_handle },
            |m: &mut CMsgUpdateToolTip| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &CMsgUpdateToolTip| { &m.text },
            |m: &mut CMsgUpdateToolTip| { &mut m.text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgUpdateToolTip>(
            "CMsgUpdateToolTip",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgUpdateToolTip {
    const NAME: &'static str = "CMsgUpdateToolTip";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgUpdateToolTip {
        CMsgUpdateToolTip::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgUpdateToolTip {
        static instance: CMsgUpdateToolTip = CMsgUpdateToolTip {
            browser_handle: ::std::option::Option::None,
            text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgUpdateToolTip {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgUpdateToolTip").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgUpdateToolTip {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgUpdateToolTip {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgHideToolTip)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHideToolTip {
    // message fields
    // @@protoc_insertion_point(field:CMsgHideToolTip.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgHideToolTip.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHideToolTip {
    fn default() -> &'a CMsgHideToolTip {
        <CMsgHideToolTip as ::protobuf::Message>::default_instance()
    }
}

impl CMsgHideToolTip {
    pub fn new() -> CMsgHideToolTip {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgHideToolTip| { &m.browser_handle },
            |m: &mut CMsgHideToolTip| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgHideToolTip>(
            "CMsgHideToolTip",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgHideToolTip {
    const NAME: &'static str = "CMsgHideToolTip";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHideToolTip {
        CMsgHideToolTip::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHideToolTip {
        static instance: CMsgHideToolTip = CMsgHideToolTip {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgHideToolTip {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgHideToolTip").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgHideToolTip {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgHideToolTip {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSearchResults)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSearchResults {
    // message fields
    // @@protoc_insertion_point(field:CMsgSearchResults.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSearchResults.activeMatch)
    pub activeMatch: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSearchResults.results)
    pub results: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSearchResults.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSearchResults {
    fn default() -> &'a CMsgSearchResults {
        <CMsgSearchResults as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSearchResults {
    pub fn new() -> CMsgSearchResults {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional int32 activeMatch = 2;

    pub fn activeMatch(&self) -> i32 {
        self.activeMatch.unwrap_or(0)
    }

    pub fn clear_activeMatch(&mut self) {
        self.activeMatch = ::std::option::Option::None;
    }

    pub fn has_activeMatch(&self) -> bool {
        self.activeMatch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_activeMatch(&mut self, v: i32) {
        self.activeMatch = ::std::option::Option::Some(v);
    }

    // optional int32 results = 3;

    pub fn results(&self) -> i32 {
        self.results.unwrap_or(0)
    }

    pub fn clear_results(&mut self) {
        self.results = ::std::option::Option::None;
    }

    pub fn has_results(&self) -> bool {
        self.results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: i32) {
        self.results = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgSearchResults| { &m.browser_handle },
            |m: &mut CMsgSearchResults| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "activeMatch",
            |m: &CMsgSearchResults| { &m.activeMatch },
            |m: &mut CMsgSearchResults| { &mut m.activeMatch },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "results",
            |m: &CMsgSearchResults| { &m.results },
            |m: &mut CMsgSearchResults| { &mut m.results },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSearchResults>(
            "CMsgSearchResults",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSearchResults {
    const NAME: &'static str = "CMsgSearchResults";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.activeMatch = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.results = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.activeMatch {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.results {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.activeMatch {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.results {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSearchResults {
        CMsgSearchResults::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.activeMatch = ::std::option::Option::None;
        self.results = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSearchResults {
        static instance: CMsgSearchResults = CMsgSearchResults {
            browser_handle: ::std::option::Option::None,
            activeMatch: ::std::option::Option::None,
            results: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSearchResults {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSearchResults").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSearchResults {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSearchResults {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClose)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClose {
    // message fields
    // @@protoc_insertion_point(field:CMsgClose.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClose.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClose {
    fn default() -> &'a CMsgClose {
        <CMsgClose as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClose {
    pub fn new() -> CMsgClose {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgClose| { &m.browser_handle },
            |m: &mut CMsgClose| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClose>(
            "CMsgClose",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClose {
    const NAME: &'static str = "CMsgClose";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClose {
        CMsgClose::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClose {
        static instance: CMsgClose = CMsgClose {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClose {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClose").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClose {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClose {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSetSharedPaintBuffers)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetSharedPaintBuffers {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetSharedPaintBuffers.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetSharedPaintBuffers.wide)
    pub wide: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetSharedPaintBuffers.tall)
    pub tall: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetSharedPaintBuffers.source_pid)
    pub source_pid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSetSharedPaintBuffers.source_handle)
    pub source_handle: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSetSharedPaintBuffers.handle)
    pub handle: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetSharedPaintBuffers.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetSharedPaintBuffers {
    fn default() -> &'a CMsgSetSharedPaintBuffers {
        <CMsgSetSharedPaintBuffers as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetSharedPaintBuffers {
    pub fn new() -> CMsgSetSharedPaintBuffers {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 wide = 2;

    pub fn wide(&self) -> u32 {
        self.wide.unwrap_or(0)
    }

    pub fn clear_wide(&mut self) {
        self.wide = ::std::option::Option::None;
    }

    pub fn has_wide(&self) -> bool {
        self.wide.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wide(&mut self, v: u32) {
        self.wide = ::std::option::Option::Some(v);
    }

    // optional uint32 tall = 3;

    pub fn tall(&self) -> u32 {
        self.tall.unwrap_or(0)
    }

    pub fn clear_tall(&mut self) {
        self.tall = ::std::option::Option::None;
    }

    pub fn has_tall(&self) -> bool {
        self.tall.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tall(&mut self, v: u32) {
        self.tall = ::std::option::Option::Some(v);
    }

    // optional uint64 source_pid = 4;

    pub fn source_pid(&self) -> u64 {
        self.source_pid.unwrap_or(0)
    }

    pub fn clear_source_pid(&mut self) {
        self.source_pid = ::std::option::Option::None;
    }

    pub fn has_source_pid(&self) -> bool {
        self.source_pid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_pid(&mut self, v: u64) {
        self.source_pid = ::std::option::Option::Some(v);
    }

    // optional uint64 source_handle = 5;

    pub fn source_handle(&self) -> u64 {
        self.source_handle.unwrap_or(0)
    }

    pub fn clear_source_handle(&mut self) {
        self.source_handle = ::std::option::Option::None;
    }

    pub fn has_source_handle(&self) -> bool {
        self.source_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_handle(&mut self, v: u64) {
        self.source_handle = ::std::option::Option::Some(v);
    }

    // optional uint64 handle = 6;

    pub fn handle(&self) -> u64 {
        self.handle.unwrap_or(0)
    }

    pub fn clear_handle(&mut self) {
        self.handle = ::std::option::Option::None;
    }

    pub fn has_handle(&self) -> bool {
        self.handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_handle(&mut self, v: u64) {
        self.handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgSetSharedPaintBuffers| { &m.browser_handle },
            |m: &mut CMsgSetSharedPaintBuffers| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "wide",
            |m: &CMsgSetSharedPaintBuffers| { &m.wide },
            |m: &mut CMsgSetSharedPaintBuffers| { &mut m.wide },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tall",
            |m: &CMsgSetSharedPaintBuffers| { &m.tall },
            |m: &mut CMsgSetSharedPaintBuffers| { &mut m.tall },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source_pid",
            |m: &CMsgSetSharedPaintBuffers| { &m.source_pid },
            |m: &mut CMsgSetSharedPaintBuffers| { &mut m.source_pid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source_handle",
            |m: &CMsgSetSharedPaintBuffers| { &m.source_handle },
            |m: &mut CMsgSetSharedPaintBuffers| { &mut m.source_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "handle",
            |m: &CMsgSetSharedPaintBuffers| { &m.handle },
            |m: &mut CMsgSetSharedPaintBuffers| { &mut m.handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetSharedPaintBuffers>(
            "CMsgSetSharedPaintBuffers",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSetSharedPaintBuffers {
    const NAME: &'static str = "CMsgSetSharedPaintBuffers";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.wide = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.tall = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.source_pid = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.source_handle = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.handle = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.wide {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.tall {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.source_pid {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.source_handle {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.handle {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.wide {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.tall {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.source_pid {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.source_handle {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.handle {
            os.write_uint64(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetSharedPaintBuffers {
        CMsgSetSharedPaintBuffers::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.wide = ::std::option::Option::None;
        self.tall = ::std::option::Option::None;
        self.source_pid = ::std::option::Option::None;
        self.source_handle = ::std::option::Option::None;
        self.handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetSharedPaintBuffers {
        static instance: CMsgSetSharedPaintBuffers = CMsgSetSharedPaintBuffers {
            browser_handle: ::std::option::Option::None,
            wide: ::std::option::Option::None,
            tall: ::std::option::Option::None,
            source_pid: ::std::option::Option::None,
            source_handle: ::std::option::Option::None,
            handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSetSharedPaintBuffers {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetSharedPaintBuffers").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetSharedPaintBuffers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetSharedPaintBuffers {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgAckSharedPaintBuffers)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAckSharedPaintBuffers {
    // message fields
    // @@protoc_insertion_point(field:CMsgAckSharedPaintBuffers.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAckSharedPaintBuffers.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAckSharedPaintBuffers {
    fn default() -> &'a CMsgAckSharedPaintBuffers {
        <CMsgAckSharedPaintBuffers as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAckSharedPaintBuffers {
    pub fn new() -> CMsgAckSharedPaintBuffers {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgAckSharedPaintBuffers| { &m.browser_handle },
            |m: &mut CMsgAckSharedPaintBuffers| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAckSharedPaintBuffers>(
            "CMsgAckSharedPaintBuffers",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgAckSharedPaintBuffers {
    const NAME: &'static str = "CMsgAckSharedPaintBuffers";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAckSharedPaintBuffers {
        CMsgAckSharedPaintBuffers::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAckSharedPaintBuffers {
        static instance: CMsgAckSharedPaintBuffers = CMsgAckSharedPaintBuffers {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgAckSharedPaintBuffers {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAckSharedPaintBuffers").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAckSharedPaintBuffers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAckSharedPaintBuffers {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgNeedsPaint)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgNeedsPaint {
    // message fields
    // @@protoc_insertion_point(field:CMsgNeedsPaint.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgNeedsPaint.scrollx)
    pub scrollx: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgNeedsPaint.scrolly)
    pub scrolly: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgNeedsPaint.pagescale)
    pub pagescale: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgNeedsPaint.pageserial)
    pub pageserial: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgNeedsPaint.avg_frame_ms)
    pub avg_frame_ms: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgNeedsPaint.stddev_sum_frame_ms)
    pub stddev_sum_frame_ms: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgNeedsPaint.long_frame_ms)
    pub long_frame_ms: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgNeedsPaint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgNeedsPaint {
    fn default() -> &'a CMsgNeedsPaint {
        <CMsgNeedsPaint as ::protobuf::Message>::default_instance()
    }
}

impl CMsgNeedsPaint {
    pub fn new() -> CMsgNeedsPaint {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 scrollx = 10;

    pub fn scrollx(&self) -> u32 {
        self.scrollx.unwrap_or(0)
    }

    pub fn clear_scrollx(&mut self) {
        self.scrollx = ::std::option::Option::None;
    }

    pub fn has_scrollx(&self) -> bool {
        self.scrollx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scrollx(&mut self, v: u32) {
        self.scrollx = ::std::option::Option::Some(v);
    }

    // optional uint32 scrolly = 11;

    pub fn scrolly(&self) -> u32 {
        self.scrolly.unwrap_or(0)
    }

    pub fn clear_scrolly(&mut self) {
        self.scrolly = ::std::option::Option::None;
    }

    pub fn has_scrolly(&self) -> bool {
        self.scrolly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scrolly(&mut self, v: u32) {
        self.scrolly = ::std::option::Option::Some(v);
    }

    // optional float pagescale = 12;

    pub fn pagescale(&self) -> f32 {
        self.pagescale.unwrap_or(0.)
    }

    pub fn clear_pagescale(&mut self) {
        self.pagescale = ::std::option::Option::None;
    }

    pub fn has_pagescale(&self) -> bool {
        self.pagescale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagescale(&mut self, v: f32) {
        self.pagescale = ::std::option::Option::Some(v);
    }

    // optional uint32 pageserial = 15;

    pub fn pageserial(&self) -> u32 {
        self.pageserial.unwrap_or(0)
    }

    pub fn clear_pageserial(&mut self) {
        self.pageserial = ::std::option::Option::None;
    }

    pub fn has_pageserial(&self) -> bool {
        self.pageserial.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pageserial(&mut self, v: u32) {
        self.pageserial = ::std::option::Option::Some(v);
    }

    // optional uint32 avg_frame_ms = 20;

    pub fn avg_frame_ms(&self) -> u32 {
        self.avg_frame_ms.unwrap_or(0)
    }

    pub fn clear_avg_frame_ms(&mut self) {
        self.avg_frame_ms = ::std::option::Option::None;
    }

    pub fn has_avg_frame_ms(&self) -> bool {
        self.avg_frame_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_frame_ms(&mut self, v: u32) {
        self.avg_frame_ms = ::std::option::Option::Some(v);
    }

    // optional float stddev_sum_frame_ms = 21;

    pub fn stddev_sum_frame_ms(&self) -> f32 {
        self.stddev_sum_frame_ms.unwrap_or(0.)
    }

    pub fn clear_stddev_sum_frame_ms(&mut self) {
        self.stddev_sum_frame_ms = ::std::option::Option::None;
    }

    pub fn has_stddev_sum_frame_ms(&self) -> bool {
        self.stddev_sum_frame_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stddev_sum_frame_ms(&mut self, v: f32) {
        self.stddev_sum_frame_ms = ::std::option::Option::Some(v);
    }

    // optional uint32 long_frame_ms = 22;

    pub fn long_frame_ms(&self) -> u32 {
        self.long_frame_ms.unwrap_or(0)
    }

    pub fn clear_long_frame_ms(&mut self) {
        self.long_frame_ms = ::std::option::Option::None;
    }

    pub fn has_long_frame_ms(&self) -> bool {
        self.long_frame_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_long_frame_ms(&mut self, v: u32) {
        self.long_frame_ms = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgNeedsPaint| { &m.browser_handle },
            |m: &mut CMsgNeedsPaint| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scrollx",
            |m: &CMsgNeedsPaint| { &m.scrollx },
            |m: &mut CMsgNeedsPaint| { &mut m.scrollx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scrolly",
            |m: &CMsgNeedsPaint| { &m.scrolly },
            |m: &mut CMsgNeedsPaint| { &mut m.scrolly },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pagescale",
            |m: &CMsgNeedsPaint| { &m.pagescale },
            |m: &mut CMsgNeedsPaint| { &mut m.pagescale },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pageserial",
            |m: &CMsgNeedsPaint| { &m.pageserial },
            |m: &mut CMsgNeedsPaint| { &mut m.pageserial },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "avg_frame_ms",
            |m: &CMsgNeedsPaint| { &m.avg_frame_ms },
            |m: &mut CMsgNeedsPaint| { &mut m.avg_frame_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stddev_sum_frame_ms",
            |m: &CMsgNeedsPaint| { &m.stddev_sum_frame_ms },
            |m: &mut CMsgNeedsPaint| { &mut m.stddev_sum_frame_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "long_frame_ms",
            |m: &CMsgNeedsPaint| { &m.long_frame_ms },
            |m: &mut CMsgNeedsPaint| { &mut m.long_frame_ms },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgNeedsPaint>(
            "CMsgNeedsPaint",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgNeedsPaint {
    const NAME: &'static str = "CMsgNeedsPaint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.scrollx = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.scrolly = ::std::option::Option::Some(is.read_uint32()?);
                },
                101 => {
                    self.pagescale = ::std::option::Option::Some(is.read_float()?);
                },
                120 => {
                    self.pageserial = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.avg_frame_ms = ::std::option::Option::Some(is.read_uint32()?);
                },
                173 => {
                    self.stddev_sum_frame_ms = ::std::option::Option::Some(is.read_float()?);
                },
                176 => {
                    self.long_frame_ms = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.scrollx {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.scrolly {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.pagescale {
            my_size += 1 + 4;
        }
        if let Some(v) = self.pageserial {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.avg_frame_ms {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.stddev_sum_frame_ms {
            my_size += 2 + 4;
        }
        if let Some(v) = self.long_frame_ms {
            my_size += ::protobuf::rt::uint32_size(22, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scrollx {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.scrolly {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.pagescale {
            os.write_float(12, v)?;
        }
        if let Some(v) = self.pageserial {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.avg_frame_ms {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.stddev_sum_frame_ms {
            os.write_float(21, v)?;
        }
        if let Some(v) = self.long_frame_ms {
            os.write_uint32(22, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgNeedsPaint {
        CMsgNeedsPaint::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.scrollx = ::std::option::Option::None;
        self.scrolly = ::std::option::Option::None;
        self.pagescale = ::std::option::Option::None;
        self.pageserial = ::std::option::Option::None;
        self.avg_frame_ms = ::std::option::Option::None;
        self.stddev_sum_frame_ms = ::std::option::Option::None;
        self.long_frame_ms = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgNeedsPaint {
        static instance: CMsgNeedsPaint = CMsgNeedsPaint {
            browser_handle: ::std::option::Option::None,
            scrollx: ::std::option::Option::None,
            scrolly: ::std::option::Option::None,
            pagescale: ::std::option::Option::None,
            pageserial: ::std::option::Option::None,
            avg_frame_ms: ::std::option::Option::None,
            stddev_sum_frame_ms: ::std::option::Option::None,
            long_frame_ms: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgNeedsPaint {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgNeedsPaint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgNeedsPaint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgNeedsPaint {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgComboNeedsPaint)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgComboNeedsPaint {
    // message fields
    // @@protoc_insertion_point(field:CMsgComboNeedsPaint.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgComboNeedsPaint.rgba)
    pub rgba: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgComboNeedsPaint.combobox_wide)
    pub combobox_wide: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgComboNeedsPaint.combobox_tall)
    pub combobox_tall: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgComboNeedsPaint.shared_memory_handle)
    pub shared_memory_handle: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgComboNeedsPaint.shared_memory_size)
    pub shared_memory_size: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgComboNeedsPaint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgComboNeedsPaint {
    fn default() -> &'a CMsgComboNeedsPaint {
        <CMsgComboNeedsPaint as ::protobuf::Message>::default_instance()
    }
}

impl CMsgComboNeedsPaint {
    pub fn new() -> CMsgComboNeedsPaint {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint64 rgba = 2;

    pub fn rgba(&self) -> u64 {
        self.rgba.unwrap_or(0)
    }

    pub fn clear_rgba(&mut self) {
        self.rgba = ::std::option::Option::None;
    }

    pub fn has_rgba(&self) -> bool {
        self.rgba.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rgba(&mut self, v: u64) {
        self.rgba = ::std::option::Option::Some(v);
    }

    // optional uint32 combobox_wide = 3;

    pub fn combobox_wide(&self) -> u32 {
        self.combobox_wide.unwrap_or(0u32)
    }

    pub fn clear_combobox_wide(&mut self) {
        self.combobox_wide = ::std::option::Option::None;
    }

    pub fn has_combobox_wide(&self) -> bool {
        self.combobox_wide.is_some()
    }

    // Param is passed by value, moved
    pub fn set_combobox_wide(&mut self, v: u32) {
        self.combobox_wide = ::std::option::Option::Some(v);
    }

    // optional uint32 combobox_tall = 4;

    pub fn combobox_tall(&self) -> u32 {
        self.combobox_tall.unwrap_or(0u32)
    }

    pub fn clear_combobox_tall(&mut self) {
        self.combobox_tall = ::std::option::Option::None;
    }

    pub fn has_combobox_tall(&self) -> bool {
        self.combobox_tall.is_some()
    }

    // Param is passed by value, moved
    pub fn set_combobox_tall(&mut self, v: u32) {
        self.combobox_tall = ::std::option::Option::Some(v);
    }

    // optional uint64 shared_memory_handle = 5;

    pub fn shared_memory_handle(&self) -> u64 {
        self.shared_memory_handle.unwrap_or(0u64)
    }

    pub fn clear_shared_memory_handle(&mut self) {
        self.shared_memory_handle = ::std::option::Option::None;
    }

    pub fn has_shared_memory_handle(&self) -> bool {
        self.shared_memory_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shared_memory_handle(&mut self, v: u64) {
        self.shared_memory_handle = ::std::option::Option::Some(v);
    }

    // optional uint64 shared_memory_size = 7;

    pub fn shared_memory_size(&self) -> u64 {
        self.shared_memory_size.unwrap_or(0u64)
    }

    pub fn clear_shared_memory_size(&mut self) {
        self.shared_memory_size = ::std::option::Option::None;
    }

    pub fn has_shared_memory_size(&self) -> bool {
        self.shared_memory_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shared_memory_size(&mut self, v: u64) {
        self.shared_memory_size = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgComboNeedsPaint| { &m.browser_handle },
            |m: &mut CMsgComboNeedsPaint| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rgba",
            |m: &CMsgComboNeedsPaint| { &m.rgba },
            |m: &mut CMsgComboNeedsPaint| { &mut m.rgba },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "combobox_wide",
            |m: &CMsgComboNeedsPaint| { &m.combobox_wide },
            |m: &mut CMsgComboNeedsPaint| { &mut m.combobox_wide },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "combobox_tall",
            |m: &CMsgComboNeedsPaint| { &m.combobox_tall },
            |m: &mut CMsgComboNeedsPaint| { &mut m.combobox_tall },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shared_memory_handle",
            |m: &CMsgComboNeedsPaint| { &m.shared_memory_handle },
            |m: &mut CMsgComboNeedsPaint| { &mut m.shared_memory_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shared_memory_size",
            |m: &CMsgComboNeedsPaint| { &m.shared_memory_size },
            |m: &mut CMsgComboNeedsPaint| { &mut m.shared_memory_size },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgComboNeedsPaint>(
            "CMsgComboNeedsPaint",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgComboNeedsPaint {
    const NAME: &'static str = "CMsgComboNeedsPaint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.rgba = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.combobox_wide = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.combobox_tall = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.shared_memory_handle = ::std::option::Option::Some(is.read_uint64()?);
                },
                56 => {
                    self.shared_memory_size = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.rgba {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.combobox_wide {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.combobox_tall {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.shared_memory_handle {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.shared_memory_size {
            my_size += ::protobuf::rt::uint64_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.rgba {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.combobox_wide {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.combobox_tall {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.shared_memory_handle {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.shared_memory_size {
            os.write_uint64(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgComboNeedsPaint {
        CMsgComboNeedsPaint::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.rgba = ::std::option::Option::None;
        self.combobox_wide = ::std::option::Option::None;
        self.combobox_tall = ::std::option::Option::None;
        self.shared_memory_handle = ::std::option::Option::None;
        self.shared_memory_size = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgComboNeedsPaint {
        static instance: CMsgComboNeedsPaint = CMsgComboNeedsPaint {
            browser_handle: ::std::option::Option::None,
            rgba: ::std::option::Option::None,
            combobox_wide: ::std::option::Option::None,
            combobox_tall: ::std::option::Option::None,
            shared_memory_handle: ::std::option::Option::None,
            shared_memory_size: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgComboNeedsPaint {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgComboNeedsPaint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgComboNeedsPaint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgComboNeedsPaint {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgNeedsSharedTexturePaint)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgNeedsSharedTexturePaint {
    // message fields
    // @@protoc_insertion_point(field:CMsgNeedsSharedTexturePaint.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgNeedsSharedTexturePaint.share_handle)
    pub share_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgNeedsSharedTexturePaint.width)
    pub width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgNeedsSharedTexturePaint.height)
    pub height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgNeedsSharedTexturePaint.scrollx)
    pub scrollx: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgNeedsSharedTexturePaint.scrolly)
    pub scrolly: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgNeedsSharedTexturePaint.pagescale)
    pub pagescale: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgNeedsSharedTexturePaint.pageserial)
    pub pageserial: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgNeedsSharedTexturePaint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgNeedsSharedTexturePaint {
    fn default() -> &'a CMsgNeedsSharedTexturePaint {
        <CMsgNeedsSharedTexturePaint as ::protobuf::Message>::default_instance()
    }
}

impl CMsgNeedsSharedTexturePaint {
    pub fn new() -> CMsgNeedsSharedTexturePaint {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 share_handle = 2;

    pub fn share_handle(&self) -> u32 {
        self.share_handle.unwrap_or(0)
    }

    pub fn clear_share_handle(&mut self) {
        self.share_handle = ::std::option::Option::None;
    }

    pub fn has_share_handle(&self) -> bool {
        self.share_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_share_handle(&mut self, v: u32) {
        self.share_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 width = 3;

    pub fn width(&self) -> u32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 4;

    pub fn height(&self) -> u32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional uint32 scrollx = 5;

    pub fn scrollx(&self) -> u32 {
        self.scrollx.unwrap_or(0)
    }

    pub fn clear_scrollx(&mut self) {
        self.scrollx = ::std::option::Option::None;
    }

    pub fn has_scrollx(&self) -> bool {
        self.scrollx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scrollx(&mut self, v: u32) {
        self.scrollx = ::std::option::Option::Some(v);
    }

    // optional uint32 scrolly = 6;

    pub fn scrolly(&self) -> u32 {
        self.scrolly.unwrap_or(0)
    }

    pub fn clear_scrolly(&mut self) {
        self.scrolly = ::std::option::Option::None;
    }

    pub fn has_scrolly(&self) -> bool {
        self.scrolly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scrolly(&mut self, v: u32) {
        self.scrolly = ::std::option::Option::Some(v);
    }

    // optional float pagescale = 7;

    pub fn pagescale(&self) -> f32 {
        self.pagescale.unwrap_or(0.)
    }

    pub fn clear_pagescale(&mut self) {
        self.pagescale = ::std::option::Option::None;
    }

    pub fn has_pagescale(&self) -> bool {
        self.pagescale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagescale(&mut self, v: f32) {
        self.pagescale = ::std::option::Option::Some(v);
    }

    // optional uint32 pageserial = 8;

    pub fn pageserial(&self) -> u32 {
        self.pageserial.unwrap_or(0)
    }

    pub fn clear_pageserial(&mut self) {
        self.pageserial = ::std::option::Option::None;
    }

    pub fn has_pageserial(&self) -> bool {
        self.pageserial.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pageserial(&mut self, v: u32) {
        self.pageserial = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgNeedsSharedTexturePaint| { &m.browser_handle },
            |m: &mut CMsgNeedsSharedTexturePaint| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "share_handle",
            |m: &CMsgNeedsSharedTexturePaint| { &m.share_handle },
            |m: &mut CMsgNeedsSharedTexturePaint| { &mut m.share_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &CMsgNeedsSharedTexturePaint| { &m.width },
            |m: &mut CMsgNeedsSharedTexturePaint| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &CMsgNeedsSharedTexturePaint| { &m.height },
            |m: &mut CMsgNeedsSharedTexturePaint| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scrollx",
            |m: &CMsgNeedsSharedTexturePaint| { &m.scrollx },
            |m: &mut CMsgNeedsSharedTexturePaint| { &mut m.scrollx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scrolly",
            |m: &CMsgNeedsSharedTexturePaint| { &m.scrolly },
            |m: &mut CMsgNeedsSharedTexturePaint| { &mut m.scrolly },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pagescale",
            |m: &CMsgNeedsSharedTexturePaint| { &m.pagescale },
            |m: &mut CMsgNeedsSharedTexturePaint| { &mut m.pagescale },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pageserial",
            |m: &CMsgNeedsSharedTexturePaint| { &m.pageserial },
            |m: &mut CMsgNeedsSharedTexturePaint| { &mut m.pageserial },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgNeedsSharedTexturePaint>(
            "CMsgNeedsSharedTexturePaint",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgNeedsSharedTexturePaint {
    const NAME: &'static str = "CMsgNeedsSharedTexturePaint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.share_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.width = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.height = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.scrollx = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.scrolly = ::std::option::Option::Some(is.read_uint32()?);
                },
                61 => {
                    self.pagescale = ::std::option::Option::Some(is.read_float()?);
                },
                64 => {
                    self.pageserial = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.share_handle {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.scrollx {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.scrolly {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.pagescale {
            my_size += 1 + 4;
        }
        if let Some(v) = self.pageserial {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.share_handle {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.width {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.scrollx {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.scrolly {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.pagescale {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.pageserial {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgNeedsSharedTexturePaint {
        CMsgNeedsSharedTexturePaint::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.share_handle = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.scrollx = ::std::option::Option::None;
        self.scrolly = ::std::option::Option::None;
        self.pagescale = ::std::option::Option::None;
        self.pageserial = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgNeedsSharedTexturePaint {
        static instance: CMsgNeedsSharedTexturePaint = CMsgNeedsSharedTexturePaint {
            browser_handle: ::std::option::Option::None,
            share_handle: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            scrollx: ::std::option::Option::None,
            scrolly: ::std::option::Option::None,
            pagescale: ::std::option::Option::None,
            pageserial: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgNeedsSharedTexturePaint {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgNeedsSharedTexturePaint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgNeedsSharedTexturePaint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgNeedsSharedTexturePaint {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGameOverlayTexturePaint)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameOverlayTexturePaint {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameOverlayTexturePaint.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameOverlayTexturePaint.width)
    pub width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameOverlayTexturePaint.height)
    pub height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameOverlayTexturePaint.scrollx)
    pub scrollx: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameOverlayTexturePaint.scrolly)
    pub scrolly: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameOverlayTexturePaint.pagescale)
    pub pagescale: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgGameOverlayTexturePaint.pageserial)
    pub pageserial: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameOverlayTexturePaint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameOverlayTexturePaint {
    fn default() -> &'a CMsgGameOverlayTexturePaint {
        <CMsgGameOverlayTexturePaint as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameOverlayTexturePaint {
    pub fn new() -> CMsgGameOverlayTexturePaint {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 width = 3;

    pub fn width(&self) -> u32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 4;

    pub fn height(&self) -> u32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional uint32 scrollx = 5;

    pub fn scrollx(&self) -> u32 {
        self.scrollx.unwrap_or(0)
    }

    pub fn clear_scrollx(&mut self) {
        self.scrollx = ::std::option::Option::None;
    }

    pub fn has_scrollx(&self) -> bool {
        self.scrollx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scrollx(&mut self, v: u32) {
        self.scrollx = ::std::option::Option::Some(v);
    }

    // optional uint32 scrolly = 6;

    pub fn scrolly(&self) -> u32 {
        self.scrolly.unwrap_or(0)
    }

    pub fn clear_scrolly(&mut self) {
        self.scrolly = ::std::option::Option::None;
    }

    pub fn has_scrolly(&self) -> bool {
        self.scrolly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scrolly(&mut self, v: u32) {
        self.scrolly = ::std::option::Option::Some(v);
    }

    // optional float pagescale = 7;

    pub fn pagescale(&self) -> f32 {
        self.pagescale.unwrap_or(0.)
    }

    pub fn clear_pagescale(&mut self) {
        self.pagescale = ::std::option::Option::None;
    }

    pub fn has_pagescale(&self) -> bool {
        self.pagescale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagescale(&mut self, v: f32) {
        self.pagescale = ::std::option::Option::Some(v);
    }

    // optional uint32 pageserial = 8;

    pub fn pageserial(&self) -> u32 {
        self.pageserial.unwrap_or(0)
    }

    pub fn clear_pageserial(&mut self) {
        self.pageserial = ::std::option::Option::None;
    }

    pub fn has_pageserial(&self) -> bool {
        self.pageserial.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pageserial(&mut self, v: u32) {
        self.pageserial = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgGameOverlayTexturePaint| { &m.browser_handle },
            |m: &mut CMsgGameOverlayTexturePaint| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &CMsgGameOverlayTexturePaint| { &m.width },
            |m: &mut CMsgGameOverlayTexturePaint| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &CMsgGameOverlayTexturePaint| { &m.height },
            |m: &mut CMsgGameOverlayTexturePaint| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scrollx",
            |m: &CMsgGameOverlayTexturePaint| { &m.scrollx },
            |m: &mut CMsgGameOverlayTexturePaint| { &mut m.scrollx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scrolly",
            |m: &CMsgGameOverlayTexturePaint| { &m.scrolly },
            |m: &mut CMsgGameOverlayTexturePaint| { &mut m.scrolly },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pagescale",
            |m: &CMsgGameOverlayTexturePaint| { &m.pagescale },
            |m: &mut CMsgGameOverlayTexturePaint| { &mut m.pagescale },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pageserial",
            |m: &CMsgGameOverlayTexturePaint| { &m.pageserial },
            |m: &mut CMsgGameOverlayTexturePaint| { &mut m.pageserial },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGameOverlayTexturePaint>(
            "CMsgGameOverlayTexturePaint",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGameOverlayTexturePaint {
    const NAME: &'static str = "CMsgGameOverlayTexturePaint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.width = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.height = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.scrollx = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.scrolly = ::std::option::Option::Some(is.read_uint32()?);
                },
                61 => {
                    self.pagescale = ::std::option::Option::Some(is.read_float()?);
                },
                64 => {
                    self.pageserial = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.scrollx {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.scrolly {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.pagescale {
            my_size += 1 + 4;
        }
        if let Some(v) = self.pageserial {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.width {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.scrollx {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.scrolly {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.pagescale {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.pageserial {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameOverlayTexturePaint {
        CMsgGameOverlayTexturePaint::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.scrollx = ::std::option::Option::None;
        self.scrolly = ::std::option::Option::None;
        self.pagescale = ::std::option::Option::None;
        self.pageserial = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameOverlayTexturePaint {
        static instance: CMsgGameOverlayTexturePaint = CMsgGameOverlayTexturePaint {
            browser_handle: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            scrollx: ::std::option::Option::None,
            scrolly: ::std::option::Option::None,
            pagescale: ::std::option::Option::None,
            pageserial: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGameOverlayTexturePaint {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGameOverlayTexturePaint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGameOverlayTexturePaint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameOverlayTexturePaint {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGetZoom)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGetZoom {
    // message fields
    // @@protoc_insertion_point(field:CMsgGetZoom.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGetZoom.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGetZoom {
    fn default() -> &'a CMsgGetZoom {
        <CMsgGetZoom as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGetZoom {
    pub fn new() -> CMsgGetZoom {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgGetZoom| { &m.browser_handle },
            |m: &mut CMsgGetZoom| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGetZoom>(
            "CMsgGetZoom",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGetZoom {
    const NAME: &'static str = "CMsgGetZoom";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGetZoom {
        CMsgGetZoom::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGetZoom {
        static instance: CMsgGetZoom = CMsgGetZoom {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGetZoom {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGetZoom").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGetZoom {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGetZoom {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGetZoomResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGetZoomResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGetZoomResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGetZoomResponse.zoom)
    pub zoom: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGetZoomResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGetZoomResponse {
    fn default() -> &'a CMsgGetZoomResponse {
        <CMsgGetZoomResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGetZoomResponse {
    pub fn new() -> CMsgGetZoomResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional float zoom = 2;

    pub fn zoom(&self) -> f32 {
        self.zoom.unwrap_or(0.)
    }

    pub fn clear_zoom(&mut self) {
        self.zoom = ::std::option::Option::None;
    }

    pub fn has_zoom(&self) -> bool {
        self.zoom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zoom(&mut self, v: f32) {
        self.zoom = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgGetZoomResponse| { &m.browser_handle },
            |m: &mut CMsgGetZoomResponse| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "zoom",
            |m: &CMsgGetZoomResponse| { &m.zoom },
            |m: &mut CMsgGetZoomResponse| { &mut m.zoom },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGetZoomResponse>(
            "CMsgGetZoomResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGetZoomResponse {
    const NAME: &'static str = "CMsgGetZoomResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.zoom = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.zoom {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.zoom {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGetZoomResponse {
        CMsgGetZoomResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.zoom = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGetZoomResponse {
        static instance: CMsgGetZoomResponse = CMsgGetZoomResponse {
            browser_handle: ::std::option::Option::None,
            zoom: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGetZoomResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGetZoomResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGetZoomResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGetZoomResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgLinkAtPosition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLinkAtPosition {
    // message fields
    // @@protoc_insertion_point(field:CMsgLinkAtPosition.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLinkAtPosition.x)
    pub x: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLinkAtPosition.y)
    pub y: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLinkAtPosition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLinkAtPosition {
    fn default() -> &'a CMsgLinkAtPosition {
        <CMsgLinkAtPosition as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLinkAtPosition {
    pub fn new() -> CMsgLinkAtPosition {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 x = 2;

    pub fn x(&self) -> u32 {
        self.x.unwrap_or(0)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: u32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional uint32 y = 3;

    pub fn y(&self) -> u32 {
        self.y.unwrap_or(0)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: u32) {
        self.y = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgLinkAtPosition| { &m.browser_handle },
            |m: &mut CMsgLinkAtPosition| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &CMsgLinkAtPosition| { &m.x },
            |m: &mut CMsgLinkAtPosition| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &CMsgLinkAtPosition| { &m.y },
            |m: &mut CMsgLinkAtPosition| { &mut m.y },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLinkAtPosition>(
            "CMsgLinkAtPosition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgLinkAtPosition {
    const NAME: &'static str = "CMsgLinkAtPosition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.x = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.y = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLinkAtPosition {
        CMsgLinkAtPosition::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLinkAtPosition {
        static instance: CMsgLinkAtPosition = CMsgLinkAtPosition {
            browser_handle: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgLinkAtPosition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLinkAtPosition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLinkAtPosition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLinkAtPosition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgLinkAtPositionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLinkAtPositionResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgLinkAtPositionResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLinkAtPositionResponse.x)
    pub x: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLinkAtPositionResponse.y)
    pub y: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLinkAtPositionResponse.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgLinkAtPositionResponse.blivelink)
    pub blivelink: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgLinkAtPositionResponse.binput)
    pub binput: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLinkAtPositionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLinkAtPositionResponse {
    fn default() -> &'a CMsgLinkAtPositionResponse {
        <CMsgLinkAtPositionResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLinkAtPositionResponse {
    pub fn new() -> CMsgLinkAtPositionResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 x = 2;

    pub fn x(&self) -> u32 {
        self.x.unwrap_or(0)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: u32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional uint32 y = 3;

    pub fn y(&self) -> u32 {
        self.y.unwrap_or(0)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: u32) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional string url = 4;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool blivelink = 5;

    pub fn blivelink(&self) -> bool {
        self.blivelink.unwrap_or(false)
    }

    pub fn clear_blivelink(&mut self) {
        self.blivelink = ::std::option::Option::None;
    }

    pub fn has_blivelink(&self) -> bool {
        self.blivelink.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blivelink(&mut self, v: bool) {
        self.blivelink = ::std::option::Option::Some(v);
    }

    // optional bool binput = 6;

    pub fn binput(&self) -> bool {
        self.binput.unwrap_or(false)
    }

    pub fn clear_binput(&mut self) {
        self.binput = ::std::option::Option::None;
    }

    pub fn has_binput(&self) -> bool {
        self.binput.is_some()
    }

    // Param is passed by value, moved
    pub fn set_binput(&mut self, v: bool) {
        self.binput = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgLinkAtPositionResponse| { &m.browser_handle },
            |m: &mut CMsgLinkAtPositionResponse| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &CMsgLinkAtPositionResponse| { &m.x },
            |m: &mut CMsgLinkAtPositionResponse| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &CMsgLinkAtPositionResponse| { &m.y },
            |m: &mut CMsgLinkAtPositionResponse| { &mut m.y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgLinkAtPositionResponse| { &m.url },
            |m: &mut CMsgLinkAtPositionResponse| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "blivelink",
            |m: &CMsgLinkAtPositionResponse| { &m.blivelink },
            |m: &mut CMsgLinkAtPositionResponse| { &mut m.blivelink },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "binput",
            |m: &CMsgLinkAtPositionResponse| { &m.binput },
            |m: &mut CMsgLinkAtPositionResponse| { &mut m.binput },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLinkAtPositionResponse>(
            "CMsgLinkAtPositionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgLinkAtPositionResponse {
    const NAME: &'static str = "CMsgLinkAtPositionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.x = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.y = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.blivelink = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.binput = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.blivelink {
            my_size += 1 + 1;
        }
        if let Some(v) = self.binput {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.blivelink {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.binput {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLinkAtPositionResponse {
        CMsgLinkAtPositionResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.blivelink = ::std::option::Option::None;
        self.binput = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLinkAtPositionResponse {
        static instance: CMsgLinkAtPositionResponse = CMsgLinkAtPositionResponse {
            browser_handle: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            url: ::std::option::Option::None,
            blivelink: ::std::option::Option::None,
            binput: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgLinkAtPositionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLinkAtPositionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLinkAtPositionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLinkAtPositionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgZoomToElementAtPosition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgZoomToElementAtPosition {
    // message fields
    // @@protoc_insertion_point(field:CMsgZoomToElementAtPosition.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgZoomToElementAtPosition.x)
    pub x: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgZoomToElementAtPosition.y)
    pub y: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgZoomToElementAtPosition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgZoomToElementAtPosition {
    fn default() -> &'a CMsgZoomToElementAtPosition {
        <CMsgZoomToElementAtPosition as ::protobuf::Message>::default_instance()
    }
}

impl CMsgZoomToElementAtPosition {
    pub fn new() -> CMsgZoomToElementAtPosition {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 x = 2;

    pub fn x(&self) -> u32 {
        self.x.unwrap_or(0)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: u32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional uint32 y = 3;

    pub fn y(&self) -> u32 {
        self.y.unwrap_or(0)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: u32) {
        self.y = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgZoomToElementAtPosition| { &m.browser_handle },
            |m: &mut CMsgZoomToElementAtPosition| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &CMsgZoomToElementAtPosition| { &m.x },
            |m: &mut CMsgZoomToElementAtPosition| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &CMsgZoomToElementAtPosition| { &m.y },
            |m: &mut CMsgZoomToElementAtPosition| { &mut m.y },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgZoomToElementAtPosition>(
            "CMsgZoomToElementAtPosition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgZoomToElementAtPosition {
    const NAME: &'static str = "CMsgZoomToElementAtPosition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.x = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.y = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgZoomToElementAtPosition {
        CMsgZoomToElementAtPosition::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgZoomToElementAtPosition {
        static instance: CMsgZoomToElementAtPosition = CMsgZoomToElementAtPosition {
            browser_handle: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgZoomToElementAtPosition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgZoomToElementAtPosition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgZoomToElementAtPosition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgZoomToElementAtPosition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgZoomToElementAtPositionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgZoomToElementAtPositionResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgZoomToElementAtPositionResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgZoomToElementAtPositionResponse.scale)
    pub scale: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgZoomToElementAtPositionResponse.duration)
    pub duration: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgZoomToElementAtPositionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgZoomToElementAtPositionResponse {
    fn default() -> &'a CMsgZoomToElementAtPositionResponse {
        <CMsgZoomToElementAtPositionResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgZoomToElementAtPositionResponse {
    pub fn new() -> CMsgZoomToElementAtPositionResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional float scale = 2;

    pub fn scale(&self) -> f32 {
        self.scale.unwrap_or(0.)
    }

    pub fn clear_scale(&mut self) {
        self.scale = ::std::option::Option::None;
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: f32) {
        self.scale = ::std::option::Option::Some(v);
    }

    // optional float duration = 3;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgZoomToElementAtPositionResponse| { &m.browser_handle },
            |m: &mut CMsgZoomToElementAtPositionResponse| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scale",
            |m: &CMsgZoomToElementAtPositionResponse| { &m.scale },
            |m: &mut CMsgZoomToElementAtPositionResponse| { &mut m.scale },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CMsgZoomToElementAtPositionResponse| { &m.duration },
            |m: &mut CMsgZoomToElementAtPositionResponse| { &mut m.duration },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgZoomToElementAtPositionResponse>(
            "CMsgZoomToElementAtPositionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgZoomToElementAtPositionResponse {
    const NAME: &'static str = "CMsgZoomToElementAtPositionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.scale = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.scale {
            my_size += 1 + 4;
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scale {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgZoomToElementAtPositionResponse {
        CMsgZoomToElementAtPositionResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.scale = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgZoomToElementAtPositionResponse {
        static instance: CMsgZoomToElementAtPositionResponse = CMsgZoomToElementAtPositionResponse {
            browser_handle: ::std::option::Option::None,
            scale: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgZoomToElementAtPositionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgZoomToElementAtPositionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgZoomToElementAtPositionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgZoomToElementAtPositionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgScalePageToValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgScalePageToValue {
    // message fields
    // @@protoc_insertion_point(field:CMsgScalePageToValue.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgScalePageToValue.scale)
    pub scale: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgScalePageToValue.x)
    pub x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgScalePageToValue.y)
    pub y: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgScalePageToValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgScalePageToValue {
    fn default() -> &'a CMsgScalePageToValue {
        <CMsgScalePageToValue as ::protobuf::Message>::default_instance()
    }
}

impl CMsgScalePageToValue {
    pub fn new() -> CMsgScalePageToValue {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional float scale = 2;

    pub fn scale(&self) -> f32 {
        self.scale.unwrap_or(0.)
    }

    pub fn clear_scale(&mut self) {
        self.scale = ::std::option::Option::None;
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: f32) {
        self.scale = ::std::option::Option::Some(v);
    }

    // optional float x = 3;

    pub fn x(&self) -> f32 {
        self.x.unwrap_or(0.)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional float y = 4;

    pub fn y(&self) -> f32 {
        self.y.unwrap_or(0.)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgScalePageToValue| { &m.browser_handle },
            |m: &mut CMsgScalePageToValue| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scale",
            |m: &CMsgScalePageToValue| { &m.scale },
            |m: &mut CMsgScalePageToValue| { &mut m.scale },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &CMsgScalePageToValue| { &m.x },
            |m: &mut CMsgScalePageToValue| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &CMsgScalePageToValue| { &m.y },
            |m: &mut CMsgScalePageToValue| { &mut m.y },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgScalePageToValue>(
            "CMsgScalePageToValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgScalePageToValue {
    const NAME: &'static str = "CMsgScalePageToValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.scale = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.x = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.y = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.scale {
            my_size += 1 + 4;
        }
        if let Some(v) = self.x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.y {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scale {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.x {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.y {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgScalePageToValue {
        CMsgScalePageToValue::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.scale = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgScalePageToValue {
        static instance: CMsgScalePageToValue = CMsgScalePageToValue {
            browser_handle: ::std::option::Option::None,
            scale: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgScalePageToValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgScalePageToValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgScalePageToValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgScalePageToValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgForcePopupsToDirectHWND)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgForcePopupsToDirectHWND {
    // message fields
    // @@protoc_insertion_point(field:CMsgForcePopupsToDirectHWND.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgForcePopupsToDirectHWND.force_direct_hwnd_popups)
    pub force_direct_hwnd_popups: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgForcePopupsToDirectHWND.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgForcePopupsToDirectHWND {
    fn default() -> &'a CMsgForcePopupsToDirectHWND {
        <CMsgForcePopupsToDirectHWND as ::protobuf::Message>::default_instance()
    }
}

impl CMsgForcePopupsToDirectHWND {
    pub fn new() -> CMsgForcePopupsToDirectHWND {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool force_direct_hwnd_popups = 2;

    pub fn force_direct_hwnd_popups(&self) -> bool {
        self.force_direct_hwnd_popups.unwrap_or(false)
    }

    pub fn clear_force_direct_hwnd_popups(&mut self) {
        self.force_direct_hwnd_popups = ::std::option::Option::None;
    }

    pub fn has_force_direct_hwnd_popups(&self) -> bool {
        self.force_direct_hwnd_popups.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_direct_hwnd_popups(&mut self, v: bool) {
        self.force_direct_hwnd_popups = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgForcePopupsToDirectHWND| { &m.browser_handle },
            |m: &mut CMsgForcePopupsToDirectHWND| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "force_direct_hwnd_popups",
            |m: &CMsgForcePopupsToDirectHWND| { &m.force_direct_hwnd_popups },
            |m: &mut CMsgForcePopupsToDirectHWND| { &mut m.force_direct_hwnd_popups },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgForcePopupsToDirectHWND>(
            "CMsgForcePopupsToDirectHWND",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgForcePopupsToDirectHWND {
    const NAME: &'static str = "CMsgForcePopupsToDirectHWND";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.force_direct_hwnd_popups = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.force_direct_hwnd_popups {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.force_direct_hwnd_popups {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgForcePopupsToDirectHWND {
        CMsgForcePopupsToDirectHWND::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.force_direct_hwnd_popups = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgForcePopupsToDirectHWND {
        static instance: CMsgForcePopupsToDirectHWND = CMsgForcePopupsToDirectHWND {
            browser_handle: ::std::option::Option::None,
            force_direct_hwnd_popups: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgForcePopupsToDirectHWND {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgForcePopupsToDirectHWND").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgForcePopupsToDirectHWND {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgForcePopupsToDirectHWND {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgScalePageToValueResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgScalePageToValueResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgScalePageToValueResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgScalePageToValueResponse.zoom)
    pub zoom: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgScalePageToValueResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgScalePageToValueResponse {
    fn default() -> &'a CMsgScalePageToValueResponse {
        <CMsgScalePageToValueResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgScalePageToValueResponse {
    pub fn new() -> CMsgScalePageToValueResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional float zoom = 2;

    pub fn zoom(&self) -> f32 {
        self.zoom.unwrap_or(0.)
    }

    pub fn clear_zoom(&mut self) {
        self.zoom = ::std::option::Option::None;
    }

    pub fn has_zoom(&self) -> bool {
        self.zoom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zoom(&mut self, v: f32) {
        self.zoom = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgScalePageToValueResponse| { &m.browser_handle },
            |m: &mut CMsgScalePageToValueResponse| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "zoom",
            |m: &CMsgScalePageToValueResponse| { &m.zoom },
            |m: &mut CMsgScalePageToValueResponse| { &mut m.zoom },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgScalePageToValueResponse>(
            "CMsgScalePageToValueResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgScalePageToValueResponse {
    const NAME: &'static str = "CMsgScalePageToValueResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.zoom = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.zoom {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.zoom {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgScalePageToValueResponse {
        CMsgScalePageToValueResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.zoom = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgScalePageToValueResponse {
        static instance: CMsgScalePageToValueResponse = CMsgScalePageToValueResponse {
            browser_handle: ::std::option::Option::None,
            zoom: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgScalePageToValueResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgScalePageToValueResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgScalePageToValueResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgScalePageToValueResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSavePageToJPEG)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSavePageToJPEG {
    // message fields
    // @@protoc_insertion_point(field:CMsgSavePageToJPEG.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSavePageToJPEG.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSavePageToJPEG.filename)
    pub filename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSavePageToJPEG.width)
    pub width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSavePageToJPEG.height)
    pub height: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSavePageToJPEG.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSavePageToJPEG {
    fn default() -> &'a CMsgSavePageToJPEG {
        <CMsgSavePageToJPEG as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSavePageToJPEG {
    pub fn new() -> CMsgSavePageToJPEG {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string filename = 3;

    pub fn filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename = ::std::option::Option::None;
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 width = 4;

    pub fn width(&self) -> u32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 5;

    pub fn height(&self) -> u32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgSavePageToJPEG| { &m.browser_handle },
            |m: &mut CMsgSavePageToJPEG| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgSavePageToJPEG| { &m.url },
            |m: &mut CMsgSavePageToJPEG| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "filename",
            |m: &CMsgSavePageToJPEG| { &m.filename },
            |m: &mut CMsgSavePageToJPEG| { &mut m.filename },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &CMsgSavePageToJPEG| { &m.width },
            |m: &mut CMsgSavePageToJPEG| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &CMsgSavePageToJPEG| { &m.height },
            |m: &mut CMsgSavePageToJPEG| { &mut m.height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSavePageToJPEG>(
            "CMsgSavePageToJPEG",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSavePageToJPEG {
    const NAME: &'static str = "CMsgSavePageToJPEG";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.filename = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.width = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.height = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.filename.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.width {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSavePageToJPEG {
        CMsgSavePageToJPEG::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.filename = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSavePageToJPEG {
        static instance: CMsgSavePageToJPEG = CMsgSavePageToJPEG {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            filename: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSavePageToJPEG {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSavePageToJPEG").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSavePageToJPEG {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSavePageToJPEG {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSavePageToJPEGResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSavePageToJPEGResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgSavePageToJPEGResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSavePageToJPEGResponse.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSavePageToJPEGResponse.filename)
    pub filename: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSavePageToJPEGResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSavePageToJPEGResponse {
    fn default() -> &'a CMsgSavePageToJPEGResponse {
        <CMsgSavePageToJPEGResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSavePageToJPEGResponse {
    pub fn new() -> CMsgSavePageToJPEGResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string filename = 3;

    pub fn filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename = ::std::option::Option::None;
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgSavePageToJPEGResponse| { &m.browser_handle },
            |m: &mut CMsgSavePageToJPEGResponse| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgSavePageToJPEGResponse| { &m.url },
            |m: &mut CMsgSavePageToJPEGResponse| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "filename",
            |m: &CMsgSavePageToJPEGResponse| { &m.filename },
            |m: &mut CMsgSavePageToJPEGResponse| { &mut m.filename },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSavePageToJPEGResponse>(
            "CMsgSavePageToJPEGResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSavePageToJPEGResponse {
    const NAME: &'static str = "CMsgSavePageToJPEGResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.filename = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.filename.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSavePageToJPEGResponse {
        CMsgSavePageToJPEGResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.filename = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSavePageToJPEGResponse {
        static instance: CMsgSavePageToJPEGResponse = CMsgSavePageToJPEGResponse {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            filename: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSavePageToJPEGResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSavePageToJPEGResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSavePageToJPEGResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSavePageToJPEGResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgJSAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgJSAlert {
    // message fields
    // @@protoc_insertion_point(field:CMsgJSAlert.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJSAlert.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgJSAlert.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgJSAlert {
    fn default() -> &'a CMsgJSAlert {
        <CMsgJSAlert as ::protobuf::Message>::default_instance()
    }
}

impl CMsgJSAlert {
    pub fn new() -> CMsgJSAlert {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string message = 2;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgJSAlert| { &m.browser_handle },
            |m: &mut CMsgJSAlert| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &CMsgJSAlert| { &m.message },
            |m: &mut CMsgJSAlert| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgJSAlert>(
            "CMsgJSAlert",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgJSAlert {
    const NAME: &'static str = "CMsgJSAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgJSAlert {
        CMsgJSAlert::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgJSAlert {
        static instance: CMsgJSAlert = CMsgJSAlert {
            browser_handle: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgJSAlert {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgJSAlert").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgJSAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgJSAlert {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgJSConfirm)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgJSConfirm {
    // message fields
    // @@protoc_insertion_point(field:CMsgJSConfirm.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJSConfirm.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgJSConfirm.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgJSConfirm {
    fn default() -> &'a CMsgJSConfirm {
        <CMsgJSConfirm as ::protobuf::Message>::default_instance()
    }
}

impl CMsgJSConfirm {
    pub fn new() -> CMsgJSConfirm {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string message = 2;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgJSConfirm| { &m.browser_handle },
            |m: &mut CMsgJSConfirm| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &CMsgJSConfirm| { &m.message },
            |m: &mut CMsgJSConfirm| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgJSConfirm>(
            "CMsgJSConfirm",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgJSConfirm {
    const NAME: &'static str = "CMsgJSConfirm";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgJSConfirm {
        CMsgJSConfirm::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgJSConfirm {
        static instance: CMsgJSConfirm = CMsgJSConfirm {
            browser_handle: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgJSConfirm {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgJSConfirm").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgJSConfirm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgJSConfirm {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgJSDialogResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgJSDialogResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgJSDialogResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJSDialogResponse.result)
    pub result: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgJSDialogResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgJSDialogResponse {
    fn default() -> &'a CMsgJSDialogResponse {
        <CMsgJSDialogResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgJSDialogResponse {
    pub fn new() -> CMsgJSDialogResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool result = 2;

    pub fn result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgJSDialogResponse| { &m.browser_handle },
            |m: &mut CMsgJSDialogResponse| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgJSDialogResponse| { &m.result },
            |m: &mut CMsgJSDialogResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgJSDialogResponse>(
            "CMsgJSDialogResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgJSDialogResponse {
    const NAME: &'static str = "CMsgJSDialogResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.result = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.result {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.result {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgJSDialogResponse {
        CMsgJSDialogResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgJSDialogResponse {
        static instance: CMsgJSDialogResponse = CMsgJSDialogResponse {
            browser_handle: ::std::option::Option::None,
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgJSDialogResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgJSDialogResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgJSDialogResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgJSDialogResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgCanGoBackAndForward)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCanGoBackAndForward {
    // message fields
    // @@protoc_insertion_point(field:CMsgCanGoBackAndForward.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgCanGoBackAndForward.bgoback)
    pub bgoback: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgCanGoBackAndForward.bgoforward)
    pub bgoforward: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCanGoBackAndForward.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCanGoBackAndForward {
    fn default() -> &'a CMsgCanGoBackAndForward {
        <CMsgCanGoBackAndForward as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCanGoBackAndForward {
    pub fn new() -> CMsgCanGoBackAndForward {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool bgoback = 2;

    pub fn bgoback(&self) -> bool {
        self.bgoback.unwrap_or(false)
    }

    pub fn clear_bgoback(&mut self) {
        self.bgoback = ::std::option::Option::None;
    }

    pub fn has_bgoback(&self) -> bool {
        self.bgoback.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bgoback(&mut self, v: bool) {
        self.bgoback = ::std::option::Option::Some(v);
    }

    // optional bool bgoforward = 3;

    pub fn bgoforward(&self) -> bool {
        self.bgoforward.unwrap_or(false)
    }

    pub fn clear_bgoforward(&mut self) {
        self.bgoforward = ::std::option::Option::None;
    }

    pub fn has_bgoforward(&self) -> bool {
        self.bgoforward.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bgoforward(&mut self, v: bool) {
        self.bgoforward = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgCanGoBackAndForward| { &m.browser_handle },
            |m: &mut CMsgCanGoBackAndForward| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bgoback",
            |m: &CMsgCanGoBackAndForward| { &m.bgoback },
            |m: &mut CMsgCanGoBackAndForward| { &mut m.bgoback },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bgoforward",
            |m: &CMsgCanGoBackAndForward| { &m.bgoforward },
            |m: &mut CMsgCanGoBackAndForward| { &mut m.bgoforward },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCanGoBackAndForward>(
            "CMsgCanGoBackAndForward",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgCanGoBackAndForward {
    const NAME: &'static str = "CMsgCanGoBackAndForward";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.bgoback = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.bgoforward = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.bgoback {
            my_size += 1 + 1;
        }
        if let Some(v) = self.bgoforward {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.bgoback {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.bgoforward {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCanGoBackAndForward {
        CMsgCanGoBackAndForward::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.bgoback = ::std::option::Option::None;
        self.bgoforward = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCanGoBackAndForward {
        static instance: CMsgCanGoBackAndForward = CMsgCanGoBackAndForward {
            browser_handle: ::std::option::Option::None,
            bgoback: ::std::option::Option::None,
            bgoforward: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgCanGoBackAndForward {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCanGoBackAndForward").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCanGoBackAndForward {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCanGoBackAndForward {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgOpenSteamURL)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgOpenSteamURL {
    // message fields
    // @@protoc_insertion_point(field:CMsgOpenSteamURL.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgOpenSteamURL.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgOpenSteamURL.referrer)
    pub referrer: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgOpenSteamURL.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgOpenSteamURL {
    fn default() -> &'a CMsgOpenSteamURL {
        <CMsgOpenSteamURL as ::protobuf::Message>::default_instance()
    }
}

impl CMsgOpenSteamURL {
    pub fn new() -> CMsgOpenSteamURL {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string referrer = 3;

    pub fn referrer(&self) -> &str {
        match self.referrer.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_referrer(&mut self) {
        self.referrer = ::std::option::Option::None;
    }

    pub fn has_referrer(&self) -> bool {
        self.referrer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_referrer(&mut self, v: ::std::string::String) {
        self.referrer = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_referrer(&mut self) -> &mut ::std::string::String {
        if self.referrer.is_none() {
            self.referrer = ::std::option::Option::Some(::std::string::String::new());
        }
        self.referrer.as_mut().unwrap()
    }

    // Take field
    pub fn take_referrer(&mut self) -> ::std::string::String {
        self.referrer.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgOpenSteamURL| { &m.browser_handle },
            |m: &mut CMsgOpenSteamURL| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgOpenSteamURL| { &m.url },
            |m: &mut CMsgOpenSteamURL| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "referrer",
            |m: &CMsgOpenSteamURL| { &m.referrer },
            |m: &mut CMsgOpenSteamURL| { &mut m.referrer },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgOpenSteamURL>(
            "CMsgOpenSteamURL",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgOpenSteamURL {
    const NAME: &'static str = "CMsgOpenSteamURL";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.referrer = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.referrer.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.referrer.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgOpenSteamURL {
        CMsgOpenSteamURL::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.referrer = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgOpenSteamURL {
        static instance: CMsgOpenSteamURL = CMsgOpenSteamURL {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            referrer: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgOpenSteamURL {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgOpenSteamURL").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgOpenSteamURL {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgOpenSteamURL {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSetCookie)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetCookie {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetCookie.key)
    pub key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSetCookie.value)
    pub value: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSetCookie.path)
    pub path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSetCookie.host)
    pub host: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSetCookie.expires)
    pub expires: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetCookie.secure)
    pub secure: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSetCookie.httponly)
    pub httponly: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetCookie.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetCookie {
    fn default() -> &'a CMsgSetCookie {
        <CMsgSetCookie as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetCookie {
    pub fn new() -> CMsgSetCookie {
        ::std::default::Default::default()
    }

    // optional string key = 1;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string path = 3;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string host = 4;

    pub fn host(&self) -> &str {
        match self.host.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_host(&mut self) {
        self.host = ::std::option::Option::None;
    }

    pub fn has_host(&self) -> bool {
        self.host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        if self.host.is_none() {
            self.host = ::std::option::Option::Some(::std::string::String::new());
        }
        self.host.as_mut().unwrap()
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        self.host.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 expires = 5;

    pub fn expires(&self) -> u32 {
        self.expires.unwrap_or(0)
    }

    pub fn clear_expires(&mut self) {
        self.expires = ::std::option::Option::None;
    }

    pub fn has_expires(&self) -> bool {
        self.expires.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expires(&mut self, v: u32) {
        self.expires = ::std::option::Option::Some(v);
    }

    // optional bool secure = 6;

    pub fn secure(&self) -> bool {
        self.secure.unwrap_or(false)
    }

    pub fn clear_secure(&mut self) {
        self.secure = ::std::option::Option::None;
    }

    pub fn has_secure(&self) -> bool {
        self.secure.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secure(&mut self, v: bool) {
        self.secure = ::std::option::Option::Some(v);
    }

    // optional bool httponly = 7;

    pub fn httponly(&self) -> bool {
        self.httponly.unwrap_or(false)
    }

    pub fn clear_httponly(&mut self) {
        self.httponly = ::std::option::Option::None;
    }

    pub fn has_httponly(&self) -> bool {
        self.httponly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_httponly(&mut self, v: bool) {
        self.httponly = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &CMsgSetCookie| { &m.key },
            |m: &mut CMsgSetCookie| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CMsgSetCookie| { &m.value },
            |m: &mut CMsgSetCookie| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "path",
            |m: &CMsgSetCookie| { &m.path },
            |m: &mut CMsgSetCookie| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "host",
            |m: &CMsgSetCookie| { &m.host },
            |m: &mut CMsgSetCookie| { &mut m.host },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expires",
            |m: &CMsgSetCookie| { &m.expires },
            |m: &mut CMsgSetCookie| { &mut m.expires },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "secure",
            |m: &CMsgSetCookie| { &m.secure },
            |m: &mut CMsgSetCookie| { &mut m.secure },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "httponly",
            |m: &CMsgSetCookie| { &m.httponly },
            |m: &mut CMsgSetCookie| { &mut m.httponly },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetCookie>(
            "CMsgSetCookie",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSetCookie {
    const NAME: &'static str = "CMsgSetCookie";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.host = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.expires = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.secure = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.httponly = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.host.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.expires {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.secure {
            my_size += 1 + 1;
        }
        if let Some(v) = self.httponly {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.path.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.host.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.expires {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.secure {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.httponly {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetCookie {
        CMsgSetCookie::new()
    }

    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.path = ::std::option::Option::None;
        self.host = ::std::option::Option::None;
        self.expires = ::std::option::Option::None;
        self.secure = ::std::option::Option::None;
        self.httponly = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetCookie {
        static instance: CMsgSetCookie = CMsgSetCookie {
            key: ::std::option::Option::None,
            value: ::std::option::Option::None,
            path: ::std::option::Option::None,
            host: ::std::option::Option::None,
            expires: ::std::option::Option::None,
            secure: ::std::option::Option::None,
            httponly: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSetCookie {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetCookie").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetCookie {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetCookie {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSetTargetFrameRate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetTargetFrameRate {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetTargetFrameRate.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetTargetFrameRate.nTargetFrameRate)
    pub nTargetFrameRate: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetTargetFrameRate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetTargetFrameRate {
    fn default() -> &'a CMsgSetTargetFrameRate {
        <CMsgSetTargetFrameRate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetTargetFrameRate {
    pub fn new() -> CMsgSetTargetFrameRate {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 nTargetFrameRate = 2;

    pub fn nTargetFrameRate(&self) -> u32 {
        self.nTargetFrameRate.unwrap_or(0)
    }

    pub fn clear_nTargetFrameRate(&mut self) {
        self.nTargetFrameRate = ::std::option::Option::None;
    }

    pub fn has_nTargetFrameRate(&self) -> bool {
        self.nTargetFrameRate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nTargetFrameRate(&mut self, v: u32) {
        self.nTargetFrameRate = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgSetTargetFrameRate| { &m.browser_handle },
            |m: &mut CMsgSetTargetFrameRate| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nTargetFrameRate",
            |m: &CMsgSetTargetFrameRate| { &m.nTargetFrameRate },
            |m: &mut CMsgSetTargetFrameRate| { &mut m.nTargetFrameRate },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetTargetFrameRate>(
            "CMsgSetTargetFrameRate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSetTargetFrameRate {
    const NAME: &'static str = "CMsgSetTargetFrameRate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.nTargetFrameRate = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.nTargetFrameRate {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.nTargetFrameRate {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetTargetFrameRate {
        CMsgSetTargetFrameRate::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.nTargetFrameRate = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetTargetFrameRate {
        static instance: CMsgSetTargetFrameRate = CMsgSetTargetFrameRate {
            browser_handle: ::std::option::Option::None,
            nTargetFrameRate: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSetTargetFrameRate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetTargetFrameRate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetTargetFrameRate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetTargetFrameRate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPauseRepaint)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPauseRepaint {
    // message fields
    // @@protoc_insertion_point(field:CMsgPauseRepaint.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPauseRepaint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPauseRepaint {
    fn default() -> &'a CMsgPauseRepaint {
        <CMsgPauseRepaint as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPauseRepaint {
    pub fn new() -> CMsgPauseRepaint {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgPauseRepaint| { &m.browser_handle },
            |m: &mut CMsgPauseRepaint| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPauseRepaint>(
            "CMsgPauseRepaint",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPauseRepaint {
    const NAME: &'static str = "CMsgPauseRepaint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPauseRepaint {
        CMsgPauseRepaint::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPauseRepaint {
        static instance: CMsgPauseRepaint = CMsgPauseRepaint {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPauseRepaint {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPauseRepaint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPauseRepaint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPauseRepaint {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgFullRepaint)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFullRepaint {
    // message fields
    // @@protoc_insertion_point(field:CMsgFullRepaint.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFullRepaint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFullRepaint {
    fn default() -> &'a CMsgFullRepaint {
        <CMsgFullRepaint as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFullRepaint {
    pub fn new() -> CMsgFullRepaint {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgFullRepaint| { &m.browser_handle },
            |m: &mut CMsgFullRepaint| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgFullRepaint>(
            "CMsgFullRepaint",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgFullRepaint {
    const NAME: &'static str = "CMsgFullRepaint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFullRepaint {
        CMsgFullRepaint::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFullRepaint {
        static instance: CMsgFullRepaint = CMsgFullRepaint {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgFullRepaint {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgFullRepaint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgFullRepaint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFullRepaint {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgRequestFullScreen)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRequestFullScreen {
    // message fields
    // @@protoc_insertion_point(field:CMsgRequestFullScreen.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRequestFullScreen.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRequestFullScreen {
    fn default() -> &'a CMsgRequestFullScreen {
        <CMsgRequestFullScreen as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRequestFullScreen {
    pub fn new() -> CMsgRequestFullScreen {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgRequestFullScreen| { &m.browser_handle },
            |m: &mut CMsgRequestFullScreen| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRequestFullScreen>(
            "CMsgRequestFullScreen",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRequestFullScreen {
    const NAME: &'static str = "CMsgRequestFullScreen";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRequestFullScreen {
        CMsgRequestFullScreen::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRequestFullScreen {
        static instance: CMsgRequestFullScreen = CMsgRequestFullScreen {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRequestFullScreen {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRequestFullScreen").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRequestFullScreen {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRequestFullScreen {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgExitFullScreen)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgExitFullScreen {
    // message fields
    // @@protoc_insertion_point(field:CMsgExitFullScreen.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgExitFullScreen.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgExitFullScreen {
    fn default() -> &'a CMsgExitFullScreen {
        <CMsgExitFullScreen as ::protobuf::Message>::default_instance()
    }
}

impl CMsgExitFullScreen {
    pub fn new() -> CMsgExitFullScreen {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgExitFullScreen| { &m.browser_handle },
            |m: &mut CMsgExitFullScreen| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgExitFullScreen>(
            "CMsgExitFullScreen",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgExitFullScreen {
    const NAME: &'static str = "CMsgExitFullScreen";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgExitFullScreen {
        CMsgExitFullScreen::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgExitFullScreen {
        static instance: CMsgExitFullScreen = CMsgExitFullScreen {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgExitFullScreen {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgExitFullScreen").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgExitFullScreen {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgExitFullScreen {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgToggleFindInPageDialog)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgToggleFindInPageDialog {
    // message fields
    // @@protoc_insertion_point(field:CMsgToggleFindInPageDialog.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgToggleFindInPageDialog.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgToggleFindInPageDialog {
    fn default() -> &'a CMsgToggleFindInPageDialog {
        <CMsgToggleFindInPageDialog as ::protobuf::Message>::default_instance()
    }
}

impl CMsgToggleFindInPageDialog {
    pub fn new() -> CMsgToggleFindInPageDialog {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgToggleFindInPageDialog| { &m.browser_handle },
            |m: &mut CMsgToggleFindInPageDialog| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgToggleFindInPageDialog>(
            "CMsgToggleFindInPageDialog",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgToggleFindInPageDialog {
    const NAME: &'static str = "CMsgToggleFindInPageDialog";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgToggleFindInPageDialog {
        CMsgToggleFindInPageDialog::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgToggleFindInPageDialog {
        static instance: CMsgToggleFindInPageDialog = CMsgToggleFindInPageDialog {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgToggleFindInPageDialog {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgToggleFindInPageDialog").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgToggleFindInPageDialog {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgToggleFindInPageDialog {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSetPIDShuttingDown)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetPIDShuttingDown {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetPIDShuttingDown.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetPIDShuttingDown.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetPIDShuttingDown {
    fn default() -> &'a CMsgSetPIDShuttingDown {
        <CMsgSetPIDShuttingDown as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetPIDShuttingDown {
    pub fn new() -> CMsgSetPIDShuttingDown {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgSetPIDShuttingDown| { &m.browser_handle },
            |m: &mut CMsgSetPIDShuttingDown| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetPIDShuttingDown>(
            "CMsgSetPIDShuttingDown",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSetPIDShuttingDown {
    const NAME: &'static str = "CMsgSetPIDShuttingDown";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetPIDShuttingDown {
        CMsgSetPIDShuttingDown::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetPIDShuttingDown {
        static instance: CMsgSetPIDShuttingDown = CMsgSetPIDShuttingDown {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSetPIDShuttingDown {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetPIDShuttingDown").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetPIDShuttingDown {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetPIDShuttingDown {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgDisableBackgroundThrottling)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDisableBackgroundThrottling {
    // message fields
    // @@protoc_insertion_point(field:CMsgDisableBackgroundThrottling.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDisableBackgroundThrottling.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDisableBackgroundThrottling {
    fn default() -> &'a CMsgDisableBackgroundThrottling {
        <CMsgDisableBackgroundThrottling as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDisableBackgroundThrottling {
    pub fn new() -> CMsgDisableBackgroundThrottling {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgDisableBackgroundThrottling| { &m.browser_handle },
            |m: &mut CMsgDisableBackgroundThrottling| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDisableBackgroundThrottling>(
            "CMsgDisableBackgroundThrottling",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDisableBackgroundThrottling {
    const NAME: &'static str = "CMsgDisableBackgroundThrottling";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDisableBackgroundThrottling {
        CMsgDisableBackgroundThrottling::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDisableBackgroundThrottling {
        static instance: CMsgDisableBackgroundThrottling = CMsgDisableBackgroundThrottling {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDisableBackgroundThrottling {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDisableBackgroundThrottling").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDisableBackgroundThrottling {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDisableBackgroundThrottling {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgAckPIDShuttingDown)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAckPIDShuttingDown {
    // message fields
    // @@protoc_insertion_point(field:CMsgAckPIDShuttingDown.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAckPIDShuttingDown.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAckPIDShuttingDown {
    fn default() -> &'a CMsgAckPIDShuttingDown {
        <CMsgAckPIDShuttingDown as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAckPIDShuttingDown {
    pub fn new() -> CMsgAckPIDShuttingDown {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgAckPIDShuttingDown| { &m.browser_handle },
            |m: &mut CMsgAckPIDShuttingDown| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAckPIDShuttingDown>(
            "CMsgAckPIDShuttingDown",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgAckPIDShuttingDown {
    const NAME: &'static str = "CMsgAckPIDShuttingDown";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAckPIDShuttingDown {
        CMsgAckPIDShuttingDown::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAckPIDShuttingDown {
        static instance: CMsgAckPIDShuttingDown = CMsgAckPIDShuttingDown {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgAckPIDShuttingDown {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAckPIDShuttingDown").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAckPIDShuttingDown {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAckPIDShuttingDown {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGetCookiesForURL)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGetCookiesForURL {
    // message fields
    // @@protoc_insertion_point(field:CMsgGetCookiesForURL.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGetCookiesForURL.url)
    pub url: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGetCookiesForURL.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGetCookiesForURL {
    fn default() -> &'a CMsgGetCookiesForURL {
        <CMsgGetCookiesForURL as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGetCookiesForURL {
    pub fn new() -> CMsgGetCookiesForURL {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgGetCookiesForURL| { &m.browser_handle },
            |m: &mut CMsgGetCookiesForURL| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgGetCookiesForURL| { &m.url },
            |m: &mut CMsgGetCookiesForURL| { &mut m.url },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGetCookiesForURL>(
            "CMsgGetCookiesForURL",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGetCookiesForURL {
    const NAME: &'static str = "CMsgGetCookiesForURL";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGetCookiesForURL {
        CMsgGetCookiesForURL::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGetCookiesForURL {
        static instance: CMsgGetCookiesForURL = CMsgGetCookiesForURL {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGetCookiesForURL {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGetCookiesForURL").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGetCookiesForURL {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGetCookiesForURL {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCookie)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCookie {
    // message fields
    // @@protoc_insertion_point(field:CCookie.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCookie.value)
    pub value: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCookie.domain)
    pub domain: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCookie.path)
    pub path: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCookie.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCookie {
    fn default() -> &'a CCookie {
        <CCookie as ::protobuf::Message>::default_instance()
    }
}

impl CCookie {
    pub fn new() -> CCookie {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string domain = 3;

    pub fn domain(&self) -> &str {
        match self.domain.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_domain(&mut self) {
        self.domain = ::std::option::Option::None;
    }

    pub fn has_domain(&self) -> bool {
        self.domain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_domain(&mut self, v: ::std::string::String) {
        self.domain = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_domain(&mut self) -> &mut ::std::string::String {
        if self.domain.is_none() {
            self.domain = ::std::option::Option::Some(::std::string::String::new());
        }
        self.domain.as_mut().unwrap()
    }

    // Take field
    pub fn take_domain(&mut self) -> ::std::string::String {
        self.domain.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string path = 4;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CCookie| { &m.name },
            |m: &mut CCookie| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CCookie| { &m.value },
            |m: &mut CCookie| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "domain",
            |m: &CCookie| { &m.domain },
            |m: &mut CCookie| { &mut m.domain },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "path",
            |m: &CCookie| { &m.path },
            |m: &mut CCookie| { &mut m.path },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCookie>(
            "CCookie",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCookie {
    const NAME: &'static str = "CCookie";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.domain = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.domain.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.domain.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.path.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCookie {
        CCookie::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.domain = ::std::option::Option::None;
        self.path = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCookie {
        static instance: CCookie = CCookie {
            name: ::std::option::Option::None,
            value: ::std::option::Option::None,
            domain: ::std::option::Option::None,
            path: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCookie {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCookie").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCookie {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCookie {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGetCookiesForURLResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGetCookiesForURLResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGetCookiesForURLResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGetCookiesForURLResponse.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGetCookiesForURLResponse.cookies)
    pub cookies: ::std::vec::Vec<CCookie>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGetCookiesForURLResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGetCookiesForURLResponse {
    fn default() -> &'a CMsgGetCookiesForURLResponse {
        <CMsgGetCookiesForURLResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGetCookiesForURLResponse {
    pub fn new() -> CMsgGetCookiesForURLResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgGetCookiesForURLResponse| { &m.browser_handle },
            |m: &mut CMsgGetCookiesForURLResponse| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgGetCookiesForURLResponse| { &m.url },
            |m: &mut CMsgGetCookiesForURLResponse| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "cookies",
            |m: &CMsgGetCookiesForURLResponse| { &m.cookies },
            |m: &mut CMsgGetCookiesForURLResponse| { &mut m.cookies },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGetCookiesForURLResponse>(
            "CMsgGetCookiesForURLResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGetCookiesForURLResponse {
    const NAME: &'static str = "CMsgGetCookiesForURLResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.cookies.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.cookies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.cookies {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGetCookiesForURLResponse {
        CMsgGetCookiesForURLResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.cookies.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGetCookiesForURLResponse {
        static instance: CMsgGetCookiesForURLResponse = CMsgGetCookiesForURLResponse {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            cookies: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGetCookiesForURLResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGetCookiesForURLResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGetCookiesForURLResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGetCookiesForURLResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgNodeHasFocus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgNodeHasFocus {
    // message fields
    // @@protoc_insertion_point(field:CMsgNodeHasFocus.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgNodeHasFocus.bInput)
    pub bInput: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgNodeHasFocus.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgNodeHasFocus.elementtagname)
    pub elementtagname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgNodeHasFocus.searchbuttontext)
    pub searchbuttontext: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgNodeHasFocus.bHasMultipleInputs)
    pub bHasMultipleInputs: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgNodeHasFocus.input_type)
    pub input_type: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgNodeHasFocus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgNodeHasFocus {
    fn default() -> &'a CMsgNodeHasFocus {
        <CMsgNodeHasFocus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgNodeHasFocus {
    pub fn new() -> CMsgNodeHasFocus {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool bInput = 2;

    pub fn bInput(&self) -> bool {
        self.bInput.unwrap_or(false)
    }

    pub fn clear_bInput(&mut self) {
        self.bInput = ::std::option::Option::None;
    }

    pub fn has_bInput(&self) -> bool {
        self.bInput.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bInput(&mut self, v: bool) {
        self.bInput = ::std::option::Option::Some(v);
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string elementtagname = 4;

    pub fn elementtagname(&self) -> &str {
        match self.elementtagname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_elementtagname(&mut self) {
        self.elementtagname = ::std::option::Option::None;
    }

    pub fn has_elementtagname(&self) -> bool {
        self.elementtagname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_elementtagname(&mut self, v: ::std::string::String) {
        self.elementtagname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_elementtagname(&mut self) -> &mut ::std::string::String {
        if self.elementtagname.is_none() {
            self.elementtagname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.elementtagname.as_mut().unwrap()
    }

    // Take field
    pub fn take_elementtagname(&mut self) -> ::std::string::String {
        self.elementtagname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string searchbuttontext = 5;

    pub fn searchbuttontext(&self) -> &str {
        match self.searchbuttontext.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_searchbuttontext(&mut self) {
        self.searchbuttontext = ::std::option::Option::None;
    }

    pub fn has_searchbuttontext(&self) -> bool {
        self.searchbuttontext.is_some()
    }

    // Param is passed by value, moved
    pub fn set_searchbuttontext(&mut self, v: ::std::string::String) {
        self.searchbuttontext = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_searchbuttontext(&mut self) -> &mut ::std::string::String {
        if self.searchbuttontext.is_none() {
            self.searchbuttontext = ::std::option::Option::Some(::std::string::String::new());
        }
        self.searchbuttontext.as_mut().unwrap()
    }

    // Take field
    pub fn take_searchbuttontext(&mut self) -> ::std::string::String {
        self.searchbuttontext.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool bHasMultipleInputs = 6;

    pub fn bHasMultipleInputs(&self) -> bool {
        self.bHasMultipleInputs.unwrap_or(false)
    }

    pub fn clear_bHasMultipleInputs(&mut self) {
        self.bHasMultipleInputs = ::std::option::Option::None;
    }

    pub fn has_bHasMultipleInputs(&self) -> bool {
        self.bHasMultipleInputs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bHasMultipleInputs(&mut self, v: bool) {
        self.bHasMultipleInputs = ::std::option::Option::Some(v);
    }

    // optional string input_type = 7;

    pub fn input_type(&self) -> &str {
        match self.input_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_input_type(&mut self) {
        self.input_type = ::std::option::Option::None;
    }

    pub fn has_input_type(&self) -> bool {
        self.input_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_type(&mut self, v: ::std::string::String) {
        self.input_type = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input_type(&mut self) -> &mut ::std::string::String {
        if self.input_type.is_none() {
            self.input_type = ::std::option::Option::Some(::std::string::String::new());
        }
        self.input_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_input_type(&mut self) -> ::std::string::String {
        self.input_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgNodeHasFocus| { &m.browser_handle },
            |m: &mut CMsgNodeHasFocus| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bInput",
            |m: &CMsgNodeHasFocus| { &m.bInput },
            |m: &mut CMsgNodeHasFocus| { &mut m.bInput },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgNodeHasFocus| { &m.name },
            |m: &mut CMsgNodeHasFocus| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "elementtagname",
            |m: &CMsgNodeHasFocus| { &m.elementtagname },
            |m: &mut CMsgNodeHasFocus| { &mut m.elementtagname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "searchbuttontext",
            |m: &CMsgNodeHasFocus| { &m.searchbuttontext },
            |m: &mut CMsgNodeHasFocus| { &mut m.searchbuttontext },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bHasMultipleInputs",
            |m: &CMsgNodeHasFocus| { &m.bHasMultipleInputs },
            |m: &mut CMsgNodeHasFocus| { &mut m.bHasMultipleInputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "input_type",
            |m: &CMsgNodeHasFocus| { &m.input_type },
            |m: &mut CMsgNodeHasFocus| { &mut m.input_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgNodeHasFocus>(
            "CMsgNodeHasFocus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgNodeHasFocus {
    const NAME: &'static str = "CMsgNodeHasFocus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.bInput = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.elementtagname = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.searchbuttontext = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.bHasMultipleInputs = ::std::option::Option::Some(is.read_bool()?);
                },
                58 => {
                    self.input_type = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.bInput {
            my_size += 1 + 1;
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.elementtagname.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.searchbuttontext.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.bHasMultipleInputs {
            my_size += 1 + 1;
        }
        if let Some(v) = self.input_type.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.bInput {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.elementtagname.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.searchbuttontext.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.bHasMultipleInputs {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.input_type.as_ref() {
            os.write_string(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgNodeHasFocus {
        CMsgNodeHasFocus::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.bInput = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.elementtagname = ::std::option::Option::None;
        self.searchbuttontext = ::std::option::Option::None;
        self.bHasMultipleInputs = ::std::option::Option::None;
        self.input_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgNodeHasFocus {
        static instance: CMsgNodeHasFocus = CMsgNodeHasFocus {
            browser_handle: ::std::option::Option::None,
            bInput: ::std::option::Option::None,
            name: ::std::option::Option::None,
            elementtagname: ::std::option::Option::None,
            searchbuttontext: ::std::option::Option::None,
            bHasMultipleInputs: ::std::option::Option::None,
            input_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgNodeHasFocus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgNodeHasFocus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgNodeHasFocus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgNodeHasFocus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgZoomToFocusedElement)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgZoomToFocusedElement {
    // message fields
    // @@protoc_insertion_point(field:CMsgZoomToFocusedElement.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgZoomToFocusedElement.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgZoomToFocusedElement {
    fn default() -> &'a CMsgZoomToFocusedElement {
        <CMsgZoomToFocusedElement as ::protobuf::Message>::default_instance()
    }
}

impl CMsgZoomToFocusedElement {
    pub fn new() -> CMsgZoomToFocusedElement {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgZoomToFocusedElement| { &m.browser_handle },
            |m: &mut CMsgZoomToFocusedElement| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgZoomToFocusedElement>(
            "CMsgZoomToFocusedElement",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgZoomToFocusedElement {
    const NAME: &'static str = "CMsgZoomToFocusedElement";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgZoomToFocusedElement {
        CMsgZoomToFocusedElement::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgZoomToFocusedElement {
        static instance: CMsgZoomToFocusedElement = CMsgZoomToFocusedElement {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgZoomToFocusedElement {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgZoomToFocusedElement").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgZoomToFocusedElement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgZoomToFocusedElement {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgCloseFullScreenFlashIfOpen)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCloseFullScreenFlashIfOpen {
    // message fields
    // @@protoc_insertion_point(field:CMsgCloseFullScreenFlashIfOpen.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCloseFullScreenFlashIfOpen.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCloseFullScreenFlashIfOpen {
    fn default() -> &'a CMsgCloseFullScreenFlashIfOpen {
        <CMsgCloseFullScreenFlashIfOpen as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCloseFullScreenFlashIfOpen {
    pub fn new() -> CMsgCloseFullScreenFlashIfOpen {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgCloseFullScreenFlashIfOpen| { &m.browser_handle },
            |m: &mut CMsgCloseFullScreenFlashIfOpen| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCloseFullScreenFlashIfOpen>(
            "CMsgCloseFullScreenFlashIfOpen",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgCloseFullScreenFlashIfOpen {
    const NAME: &'static str = "CMsgCloseFullScreenFlashIfOpen";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCloseFullScreenFlashIfOpen {
        CMsgCloseFullScreenFlashIfOpen::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCloseFullScreenFlashIfOpen {
        static instance: CMsgCloseFullScreenFlashIfOpen = CMsgCloseFullScreenFlashIfOpen {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgCloseFullScreenFlashIfOpen {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCloseFullScreenFlashIfOpen").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCloseFullScreenFlashIfOpen {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCloseFullScreenFlashIfOpen {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPauseFullScreenFlashMovieIfOpen)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPauseFullScreenFlashMovieIfOpen {
    // message fields
    // @@protoc_insertion_point(field:CMsgPauseFullScreenFlashMovieIfOpen.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPauseFullScreenFlashMovieIfOpen.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPauseFullScreenFlashMovieIfOpen {
    fn default() -> &'a CMsgPauseFullScreenFlashMovieIfOpen {
        <CMsgPauseFullScreenFlashMovieIfOpen as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPauseFullScreenFlashMovieIfOpen {
    pub fn new() -> CMsgPauseFullScreenFlashMovieIfOpen {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgPauseFullScreenFlashMovieIfOpen| { &m.browser_handle },
            |m: &mut CMsgPauseFullScreenFlashMovieIfOpen| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPauseFullScreenFlashMovieIfOpen>(
            "CMsgPauseFullScreenFlashMovieIfOpen",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPauseFullScreenFlashMovieIfOpen {
    const NAME: &'static str = "CMsgPauseFullScreenFlashMovieIfOpen";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPauseFullScreenFlashMovieIfOpen {
        CMsgPauseFullScreenFlashMovieIfOpen::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPauseFullScreenFlashMovieIfOpen {
        static instance: CMsgPauseFullScreenFlashMovieIfOpen = CMsgPauseFullScreenFlashMovieIfOpen {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPauseFullScreenFlashMovieIfOpen {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPauseFullScreenFlashMovieIfOpen").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPauseFullScreenFlashMovieIfOpen {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPauseFullScreenFlashMovieIfOpen {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgFocusedNodeText)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFocusedNodeText {
    // message fields
    // @@protoc_insertion_point(field:CMsgFocusedNodeText.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFocusedNodeText.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFocusedNodeText {
    fn default() -> &'a CMsgFocusedNodeText {
        <CMsgFocusedNodeText as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFocusedNodeText {
    pub fn new() -> CMsgFocusedNodeText {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgFocusedNodeText| { &m.browser_handle },
            |m: &mut CMsgFocusedNodeText| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgFocusedNodeText>(
            "CMsgFocusedNodeText",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgFocusedNodeText {
    const NAME: &'static str = "CMsgFocusedNodeText";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFocusedNodeText {
        CMsgFocusedNodeText::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFocusedNodeText {
        static instance: CMsgFocusedNodeText = CMsgFocusedNodeText {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgFocusedNodeText {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgFocusedNodeText").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgFocusedNodeText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFocusedNodeText {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgFocusedNodeTextResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFocusedNodeTextResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgFocusedNodeTextResponse.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgFocusedNodeTextResponse.value)
    pub value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFocusedNodeTextResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFocusedNodeTextResponse {
    fn default() -> &'a CMsgFocusedNodeTextResponse {
        <CMsgFocusedNodeTextResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFocusedNodeTextResponse {
    pub fn new() -> CMsgFocusedNodeTextResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string value = 2;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgFocusedNodeTextResponse| { &m.browser_handle },
            |m: &mut CMsgFocusedNodeTextResponse| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CMsgFocusedNodeTextResponse| { &m.value },
            |m: &mut CMsgFocusedNodeTextResponse| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgFocusedNodeTextResponse>(
            "CMsgFocusedNodeTextResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgFocusedNodeTextResponse {
    const NAME: &'static str = "CMsgFocusedNodeTextResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFocusedNodeTextResponse {
        CMsgFocusedNodeTextResponse::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFocusedNodeTextResponse {
        static instance: CMsgFocusedNodeTextResponse = CMsgFocusedNodeTextResponse {
            browser_handle: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgFocusedNodeTextResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgFocusedNodeTextResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgFocusedNodeTextResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFocusedNodeTextResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgBuildID)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBuildID {
    // message fields
    // @@protoc_insertion_point(field:CMsgBuildID.build_id)
    pub build_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBuildID.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBuildID {
    fn default() -> &'a CMsgBuildID {
        <CMsgBuildID as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBuildID {
    pub fn new() -> CMsgBuildID {
        ::std::default::Default::default()
    }

    // optional uint64 build_id = 1;

    pub fn build_id(&self) -> u64 {
        self.build_id.unwrap_or(0)
    }

    pub fn clear_build_id(&mut self) {
        self.build_id = ::std::option::Option::None;
    }

    pub fn has_build_id(&self) -> bool {
        self.build_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_build_id(&mut self, v: u64) {
        self.build_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "build_id",
            |m: &CMsgBuildID| { &m.build_id },
            |m: &mut CMsgBuildID| { &mut m.build_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBuildID>(
            "CMsgBuildID",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgBuildID {
    const NAME: &'static str = "CMsgBuildID";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.build_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.build_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.build_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBuildID {
        CMsgBuildID::new()
    }

    fn clear(&mut self) {
        self.build_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBuildID {
        static instance: CMsgBuildID = CMsgBuildID {
            build_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgBuildID {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBuildID").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBuildID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBuildID {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgOpenDevTools)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgOpenDevTools {
    // message fields
    // @@protoc_insertion_point(field:CMsgOpenDevTools.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgOpenDevTools.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgOpenDevTools {
    fn default() -> &'a CMsgOpenDevTools {
        <CMsgOpenDevTools as ::protobuf::Message>::default_instance()
    }
}

impl CMsgOpenDevTools {
    pub fn new() -> CMsgOpenDevTools {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgOpenDevTools| { &m.browser_handle },
            |m: &mut CMsgOpenDevTools| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgOpenDevTools>(
            "CMsgOpenDevTools",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgOpenDevTools {
    const NAME: &'static str = "CMsgOpenDevTools";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgOpenDevTools {
        CMsgOpenDevTools::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgOpenDevTools {
        static instance: CMsgOpenDevTools = CMsgOpenDevTools {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgOpenDevTools {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgOpenDevTools").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgOpenDevTools {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgOpenDevTools {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgCloseDevTools)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCloseDevTools {
    // message fields
    // @@protoc_insertion_point(field:CMsgCloseDevTools.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCloseDevTools.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCloseDevTools {
    fn default() -> &'a CMsgCloseDevTools {
        <CMsgCloseDevTools as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCloseDevTools {
    pub fn new() -> CMsgCloseDevTools {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgCloseDevTools| { &m.browser_handle },
            |m: &mut CMsgCloseDevTools| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCloseDevTools>(
            "CMsgCloseDevTools",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgCloseDevTools {
    const NAME: &'static str = "CMsgCloseDevTools";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCloseDevTools {
        CMsgCloseDevTools::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCloseDevTools {
        static instance: CMsgCloseDevTools = CMsgCloseDevTools {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgCloseDevTools {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCloseDevTools").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCloseDevTools {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCloseDevTools {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgUnlockH264)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgUnlockH264 {
    // message fields
    // @@protoc_insertion_point(field:CMsgUnlockH264.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgUnlockH264.unlock_code)
    pub unlock_code: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgUnlockH264.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgUnlockH264 {
    fn default() -> &'a CMsgUnlockH264 {
        <CMsgUnlockH264 as ::protobuf::Message>::default_instance()
    }
}

impl CMsgUnlockH264 {
    pub fn new() -> CMsgUnlockH264 {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string unlock_code = 2;

    pub fn unlock_code(&self) -> &str {
        match self.unlock_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_unlock_code(&mut self) {
        self.unlock_code = ::std::option::Option::None;
    }

    pub fn has_unlock_code(&self) -> bool {
        self.unlock_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unlock_code(&mut self, v: ::std::string::String) {
        self.unlock_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unlock_code(&mut self) -> &mut ::std::string::String {
        if self.unlock_code.is_none() {
            self.unlock_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.unlock_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_unlock_code(&mut self) -> ::std::string::String {
        self.unlock_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgUnlockH264| { &m.browser_handle },
            |m: &mut CMsgUnlockH264| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unlock_code",
            |m: &CMsgUnlockH264| { &m.unlock_code },
            |m: &mut CMsgUnlockH264| { &mut m.unlock_code },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgUnlockH264>(
            "CMsgUnlockH264",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgUnlockH264 {
    const NAME: &'static str = "CMsgUnlockH264";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.unlock_code = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.unlock_code.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.unlock_code.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgUnlockH264 {
        CMsgUnlockH264::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unlock_code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgUnlockH264 {
        static instance: CMsgUnlockH264 = CMsgUnlockH264 {
            browser_handle: ::std::option::Option::None,
            unlock_code: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgUnlockH264 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgUnlockH264").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgUnlockH264 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgUnlockH264 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgScreenInformationChanged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgScreenInformationChanged {
    // message fields
    // @@protoc_insertion_point(field:CMsgScreenInformationChanged.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgScreenInformationChanged.override_width)
    pub override_width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgScreenInformationChanged.override_height)
    pub override_height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgScreenInformationChanged.monitor_left)
    pub monitor_left: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgScreenInformationChanged.monitor_top)
    pub monitor_top: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgScreenInformationChanged.monitor_right)
    pub monitor_right: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgScreenInformationChanged.monitor_bottom)
    pub monitor_bottom: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgScreenInformationChanged.usable_left)
    pub usable_left: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgScreenInformationChanged.usable_top)
    pub usable_top: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgScreenInformationChanged.usable_right)
    pub usable_right: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgScreenInformationChanged.usable_bottom)
    pub usable_bottom: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgScreenInformationChanged.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgScreenInformationChanged {
    fn default() -> &'a CMsgScreenInformationChanged {
        <CMsgScreenInformationChanged as ::protobuf::Message>::default_instance()
    }
}

impl CMsgScreenInformationChanged {
    pub fn new() -> CMsgScreenInformationChanged {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 override_width = 2;

    pub fn override_width(&self) -> u32 {
        self.override_width.unwrap_or(0)
    }

    pub fn clear_override_width(&mut self) {
        self.override_width = ::std::option::Option::None;
    }

    pub fn has_override_width(&self) -> bool {
        self.override_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_override_width(&mut self, v: u32) {
        self.override_width = ::std::option::Option::Some(v);
    }

    // optional uint32 override_height = 3;

    pub fn override_height(&self) -> u32 {
        self.override_height.unwrap_or(0)
    }

    pub fn clear_override_height(&mut self) {
        self.override_height = ::std::option::Option::None;
    }

    pub fn has_override_height(&self) -> bool {
        self.override_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_override_height(&mut self, v: u32) {
        self.override_height = ::std::option::Option::Some(v);
    }

    // optional uint32 monitor_left = 4;

    pub fn monitor_left(&self) -> u32 {
        self.monitor_left.unwrap_or(0)
    }

    pub fn clear_monitor_left(&mut self) {
        self.monitor_left = ::std::option::Option::None;
    }

    pub fn has_monitor_left(&self) -> bool {
        self.monitor_left.is_some()
    }

    // Param is passed by value, moved
    pub fn set_monitor_left(&mut self, v: u32) {
        self.monitor_left = ::std::option::Option::Some(v);
    }

    // optional uint32 monitor_top = 5;

    pub fn monitor_top(&self) -> u32 {
        self.monitor_top.unwrap_or(0)
    }

    pub fn clear_monitor_top(&mut self) {
        self.monitor_top = ::std::option::Option::None;
    }

    pub fn has_monitor_top(&self) -> bool {
        self.monitor_top.is_some()
    }

    // Param is passed by value, moved
    pub fn set_monitor_top(&mut self, v: u32) {
        self.monitor_top = ::std::option::Option::Some(v);
    }

    // optional uint32 monitor_right = 6;

    pub fn monitor_right(&self) -> u32 {
        self.monitor_right.unwrap_or(0)
    }

    pub fn clear_monitor_right(&mut self) {
        self.monitor_right = ::std::option::Option::None;
    }

    pub fn has_monitor_right(&self) -> bool {
        self.monitor_right.is_some()
    }

    // Param is passed by value, moved
    pub fn set_monitor_right(&mut self, v: u32) {
        self.monitor_right = ::std::option::Option::Some(v);
    }

    // optional uint32 monitor_bottom = 7;

    pub fn monitor_bottom(&self) -> u32 {
        self.monitor_bottom.unwrap_or(0)
    }

    pub fn clear_monitor_bottom(&mut self) {
        self.monitor_bottom = ::std::option::Option::None;
    }

    pub fn has_monitor_bottom(&self) -> bool {
        self.monitor_bottom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_monitor_bottom(&mut self, v: u32) {
        self.monitor_bottom = ::std::option::Option::Some(v);
    }

    // optional uint32 usable_left = 8;

    pub fn usable_left(&self) -> u32 {
        self.usable_left.unwrap_or(0)
    }

    pub fn clear_usable_left(&mut self) {
        self.usable_left = ::std::option::Option::None;
    }

    pub fn has_usable_left(&self) -> bool {
        self.usable_left.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usable_left(&mut self, v: u32) {
        self.usable_left = ::std::option::Option::Some(v);
    }

    // optional uint32 usable_top = 9;

    pub fn usable_top(&self) -> u32 {
        self.usable_top.unwrap_or(0)
    }

    pub fn clear_usable_top(&mut self) {
        self.usable_top = ::std::option::Option::None;
    }

    pub fn has_usable_top(&self) -> bool {
        self.usable_top.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usable_top(&mut self, v: u32) {
        self.usable_top = ::std::option::Option::Some(v);
    }

    // optional uint32 usable_right = 10;

    pub fn usable_right(&self) -> u32 {
        self.usable_right.unwrap_or(0)
    }

    pub fn clear_usable_right(&mut self) {
        self.usable_right = ::std::option::Option::None;
    }

    pub fn has_usable_right(&self) -> bool {
        self.usable_right.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usable_right(&mut self, v: u32) {
        self.usable_right = ::std::option::Option::Some(v);
    }

    // optional uint32 usable_bottom = 11;

    pub fn usable_bottom(&self) -> u32 {
        self.usable_bottom.unwrap_or(0)
    }

    pub fn clear_usable_bottom(&mut self) {
        self.usable_bottom = ::std::option::Option::None;
    }

    pub fn has_usable_bottom(&self) -> bool {
        self.usable_bottom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usable_bottom(&mut self, v: u32) {
        self.usable_bottom = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgScreenInformationChanged| { &m.browser_handle },
            |m: &mut CMsgScreenInformationChanged| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "override_width",
            |m: &CMsgScreenInformationChanged| { &m.override_width },
            |m: &mut CMsgScreenInformationChanged| { &mut m.override_width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "override_height",
            |m: &CMsgScreenInformationChanged| { &m.override_height },
            |m: &mut CMsgScreenInformationChanged| { &mut m.override_height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "monitor_left",
            |m: &CMsgScreenInformationChanged| { &m.monitor_left },
            |m: &mut CMsgScreenInformationChanged| { &mut m.monitor_left },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "monitor_top",
            |m: &CMsgScreenInformationChanged| { &m.monitor_top },
            |m: &mut CMsgScreenInformationChanged| { &mut m.monitor_top },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "monitor_right",
            |m: &CMsgScreenInformationChanged| { &m.monitor_right },
            |m: &mut CMsgScreenInformationChanged| { &mut m.monitor_right },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "monitor_bottom",
            |m: &CMsgScreenInformationChanged| { &m.monitor_bottom },
            |m: &mut CMsgScreenInformationChanged| { &mut m.monitor_bottom },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "usable_left",
            |m: &CMsgScreenInformationChanged| { &m.usable_left },
            |m: &mut CMsgScreenInformationChanged| { &mut m.usable_left },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "usable_top",
            |m: &CMsgScreenInformationChanged| { &m.usable_top },
            |m: &mut CMsgScreenInformationChanged| { &mut m.usable_top },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "usable_right",
            |m: &CMsgScreenInformationChanged| { &m.usable_right },
            |m: &mut CMsgScreenInformationChanged| { &mut m.usable_right },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "usable_bottom",
            |m: &CMsgScreenInformationChanged| { &m.usable_bottom },
            |m: &mut CMsgScreenInformationChanged| { &mut m.usable_bottom },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgScreenInformationChanged>(
            "CMsgScreenInformationChanged",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgScreenInformationChanged {
    const NAME: &'static str = "CMsgScreenInformationChanged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.override_width = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.override_height = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.monitor_left = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.monitor_top = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.monitor_right = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.monitor_bottom = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.usable_left = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.usable_top = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.usable_right = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.usable_bottom = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.override_width {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.override_height {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.monitor_left {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.monitor_top {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.monitor_right {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.monitor_bottom {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.usable_left {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.usable_top {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.usable_right {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.usable_bottom {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.override_width {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.override_height {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.monitor_left {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.monitor_top {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.monitor_right {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.monitor_bottom {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.usable_left {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.usable_top {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.usable_right {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.usable_bottom {
            os.write_uint32(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgScreenInformationChanged {
        CMsgScreenInformationChanged::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.override_width = ::std::option::Option::None;
        self.override_height = ::std::option::Option::None;
        self.monitor_left = ::std::option::Option::None;
        self.monitor_top = ::std::option::Option::None;
        self.monitor_right = ::std::option::Option::None;
        self.monitor_bottom = ::std::option::Option::None;
        self.usable_left = ::std::option::Option::None;
        self.usable_top = ::std::option::Option::None;
        self.usable_right = ::std::option::Option::None;
        self.usable_bottom = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgScreenInformationChanged {
        static instance: CMsgScreenInformationChanged = CMsgScreenInformationChanged {
            browser_handle: ::std::option::Option::None,
            override_width: ::std::option::Option::None,
            override_height: ::std::option::Option::None,
            monitor_left: ::std::option::Option::None,
            monitor_top: ::std::option::Option::None,
            monitor_right: ::std::option::Option::None,
            monitor_bottom: ::std::option::Option::None,
            usable_left: ::std::option::Option::None,
            usable_top: ::std::option::Option::None,
            usable_right: ::std::option::Option::None,
            usable_bottom: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgScreenInformationChanged {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgScreenInformationChanged").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgScreenInformationChanged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgScreenInformationChanged {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClearAllCookies)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClearAllCookies {
    // message fields
    // @@protoc_insertion_point(field:CMsgClearAllCookies.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClearAllCookies.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClearAllCookies {
    fn default() -> &'a CMsgClearAllCookies {
        <CMsgClearAllCookies as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClearAllCookies {
    pub fn new() -> CMsgClearAllCookies {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgClearAllCookies| { &m.browser_handle },
            |m: &mut CMsgClearAllCookies| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClearAllCookies>(
            "CMsgClearAllCookies",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClearAllCookies {
    const NAME: &'static str = "CMsgClearAllCookies";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClearAllCookies {
        CMsgClearAllCookies::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClearAllCookies {
        static instance: CMsgClearAllCookies = CMsgClearAllCookies {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClearAllCookies {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClearAllCookies").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClearAllCookies {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClearAllCookies {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgScreenDPI)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgScreenDPI {
    // message fields
    // @@protoc_insertion_point(field:CMsgScreenDPI.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgScreenDPI.dpi_scaling)
    pub dpi_scaling: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgScreenDPI.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgScreenDPI {
    fn default() -> &'a CMsgScreenDPI {
        <CMsgScreenDPI as ::protobuf::Message>::default_instance()
    }
}

impl CMsgScreenDPI {
    pub fn new() -> CMsgScreenDPI {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional float dpi_scaling = 2;

    pub fn dpi_scaling(&self) -> f32 {
        self.dpi_scaling.unwrap_or(0.)
    }

    pub fn clear_dpi_scaling(&mut self) {
        self.dpi_scaling = ::std::option::Option::None;
    }

    pub fn has_dpi_scaling(&self) -> bool {
        self.dpi_scaling.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dpi_scaling(&mut self, v: f32) {
        self.dpi_scaling = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgScreenDPI| { &m.browser_handle },
            |m: &mut CMsgScreenDPI| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dpi_scaling",
            |m: &CMsgScreenDPI| { &m.dpi_scaling },
            |m: &mut CMsgScreenDPI| { &mut m.dpi_scaling },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgScreenDPI>(
            "CMsgScreenDPI",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgScreenDPI {
    const NAME: &'static str = "CMsgScreenDPI";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.dpi_scaling = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.dpi_scaling {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.dpi_scaling {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgScreenDPI {
        CMsgScreenDPI::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.dpi_scaling = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgScreenDPI {
        static instance: CMsgScreenDPI = CMsgScreenDPI {
            browser_handle: ::std::option::Option::None,
            dpi_scaling: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgScreenDPI {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgScreenDPI").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgScreenDPI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgScreenDPI {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgAuthedSteamDomains)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAuthedSteamDomains {
    // message fields
    // @@protoc_insertion_point(field:CMsgAuthedSteamDomains.domains)
    pub domains: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAuthedSteamDomains.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAuthedSteamDomains {
    fn default() -> &'a CMsgAuthedSteamDomains {
        <CMsgAuthedSteamDomains as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAuthedSteamDomains {
    pub fn new() -> CMsgAuthedSteamDomains {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "domains",
            |m: &CMsgAuthedSteamDomains| { &m.domains },
            |m: &mut CMsgAuthedSteamDomains| { &mut m.domains },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAuthedSteamDomains>(
            "CMsgAuthedSteamDomains",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgAuthedSteamDomains {
    const NAME: &'static str = "CMsgAuthedSteamDomains";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.domains.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.domains {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.domains {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAuthedSteamDomains {
        CMsgAuthedSteamDomains::new()
    }

    fn clear(&mut self) {
        self.domains.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAuthedSteamDomains {
        static instance: CMsgAuthedSteamDomains = CMsgAuthedSteamDomains {
            domains: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgAuthedSteamDomains {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAuthedSteamDomains").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAuthedSteamDomains {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAuthedSteamDomains {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamAuthNeeded)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamAuthNeeded {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamAuthNeeded.filler)
    pub filler: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamAuthNeeded.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamAuthNeeded {
    fn default() -> &'a CMsgSteamAuthNeeded {
        <CMsgSteamAuthNeeded as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamAuthNeeded {
    pub fn new() -> CMsgSteamAuthNeeded {
        ::std::default::Default::default()
    }

    // optional bool filler = 1;

    pub fn filler(&self) -> bool {
        self.filler.unwrap_or(false)
    }

    pub fn clear_filler(&mut self) {
        self.filler = ::std::option::Option::None;
    }

    pub fn has_filler(&self) -> bool {
        self.filler.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filler(&mut self, v: bool) {
        self.filler = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "filler",
            |m: &CMsgSteamAuthNeeded| { &m.filler },
            |m: &mut CMsgSteamAuthNeeded| { &mut m.filler },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamAuthNeeded>(
            "CMsgSteamAuthNeeded",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamAuthNeeded {
    const NAME: &'static str = "CMsgSteamAuthNeeded";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.filler = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.filler {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.filler {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamAuthNeeded {
        CMsgSteamAuthNeeded::new()
    }

    fn clear(&mut self) {
        self.filler = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamAuthNeeded {
        static instance: CMsgSteamAuthNeeded = CMsgSteamAuthNeeded {
            filler: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamAuthNeeded {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamAuthNeeded").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamAuthNeeded {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamAuthNeeded {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamAuthCookiesSet)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamAuthCookiesSet {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamAuthCookiesSet.success)
    pub success: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamAuthCookiesSet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamAuthCookiesSet {
    fn default() -> &'a CMsgSteamAuthCookiesSet {
        <CMsgSteamAuthCookiesSet as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamAuthCookiesSet {
    pub fn new() -> CMsgSteamAuthCookiesSet {
        ::std::default::Default::default()
    }

    // optional bool success = 1;

    pub fn success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "success",
            |m: &CMsgSteamAuthCookiesSet| { &m.success },
            |m: &mut CMsgSteamAuthCookiesSet| { &mut m.success },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamAuthCookiesSet>(
            "CMsgSteamAuthCookiesSet",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamAuthCookiesSet {
    const NAME: &'static str = "CMsgSteamAuthCookiesSet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamAuthCookiesSet {
        CMsgSteamAuthCookiesSet::new()
    }

    fn clear(&mut self) {
        self.success = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamAuthCookiesSet {
        static instance: CMsgSteamAuthCookiesSet = CMsgSteamAuthCookiesSet {
            success: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamAuthCookiesSet {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamAuthCookiesSet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamAuthCookiesSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamAuthCookiesSet {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgJSRegisterMethod)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgJSRegisterMethod {
    // message fields
    // @@protoc_insertion_point(field:CMsgJSRegisterMethod.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJSRegisterMethod.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgJSRegisterMethod.method_type)
    pub method_type: ::std::option::Option<::protobuf::EnumOrUnknown<EJSRegisterMethodType>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgJSRegisterMethod.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgJSRegisterMethod {
    fn default() -> &'a CMsgJSRegisterMethod {
        <CMsgJSRegisterMethod as ::protobuf::Message>::default_instance()
    }
}

impl CMsgJSRegisterMethod {
    pub fn new() -> CMsgJSRegisterMethod {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .EJSRegisterMethodType method_type = 3;

    pub fn method_type(&self) -> EJSRegisterMethodType {
        match self.method_type {
            Some(e) => e.enum_value_or(EJSRegisterMethodType::k_EJSRegisterMethodType_Invalid),
            None => EJSRegisterMethodType::k_EJSRegisterMethodType_Invalid,
        }
    }

    pub fn clear_method_type(&mut self) {
        self.method_type = ::std::option::Option::None;
    }

    pub fn has_method_type(&self) -> bool {
        self.method_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_method_type(&mut self, v: EJSRegisterMethodType) {
        self.method_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgJSRegisterMethod| { &m.browser_handle },
            |m: &mut CMsgJSRegisterMethod| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgJSRegisterMethod| { &m.name },
            |m: &mut CMsgJSRegisterMethod| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "method_type",
            |m: &CMsgJSRegisterMethod| { &m.method_type },
            |m: &mut CMsgJSRegisterMethod| { &mut m.method_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgJSRegisterMethod>(
            "CMsgJSRegisterMethod",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgJSRegisterMethod {
    const NAME: &'static str = "CMsgJSRegisterMethod";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.method_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.method_type {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.method_type {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgJSRegisterMethod {
        CMsgJSRegisterMethod::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.method_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgJSRegisterMethod {
        static instance: CMsgJSRegisterMethod = CMsgJSRegisterMethod {
            browser_handle: ::std::option::Option::None,
            name: ::std::option::Option::None,
            method_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgJSRegisterMethod {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgJSRegisterMethod").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgJSRegisterMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgJSRegisterMethod {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CJSMethodArgument)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CJSMethodArgument {
    // message fields
    // @@protoc_insertion_point(field:CJSMethodArgument.json_data)
    pub json_data: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CJSMethodArgument.function_handle)
    pub function_handle: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CJSMethodArgument.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CJSMethodArgument {
    fn default() -> &'a CJSMethodArgument {
        <CJSMethodArgument as ::protobuf::Message>::default_instance()
    }
}

impl CJSMethodArgument {
    pub fn new() -> CJSMethodArgument {
        ::std::default::Default::default()
    }

    // optional string json_data = 1;

    pub fn json_data(&self) -> &str {
        match self.json_data.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_json_data(&mut self) {
        self.json_data = ::std::option::Option::None;
    }

    pub fn has_json_data(&self) -> bool {
        self.json_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_json_data(&mut self, v: ::std::string::String) {
        self.json_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_json_data(&mut self) -> &mut ::std::string::String {
        if self.json_data.is_none() {
            self.json_data = ::std::option::Option::Some(::std::string::String::new());
        }
        self.json_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_json_data(&mut self) -> ::std::string::String {
        self.json_data.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 function_handle = 2;

    pub fn function_handle(&self) -> u64 {
        self.function_handle.unwrap_or(0)
    }

    pub fn clear_function_handle(&mut self) {
        self.function_handle = ::std::option::Option::None;
    }

    pub fn has_function_handle(&self) -> bool {
        self.function_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_function_handle(&mut self, v: u64) {
        self.function_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "json_data",
            |m: &CJSMethodArgument| { &m.json_data },
            |m: &mut CJSMethodArgument| { &mut m.json_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "function_handle",
            |m: &CJSMethodArgument| { &m.function_handle },
            |m: &mut CJSMethodArgument| { &mut m.function_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CJSMethodArgument>(
            "CJSMethodArgument",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CJSMethodArgument {
    const NAME: &'static str = "CJSMethodArgument";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.json_data = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.function_handle = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.json_data.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.function_handle {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.json_data.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.function_handle {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CJSMethodArgument {
        CJSMethodArgument::new()
    }

    fn clear(&mut self) {
        self.json_data = ::std::option::Option::None;
        self.function_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CJSMethodArgument {
        static instance: CJSMethodArgument = CJSMethodArgument {
            json_data: ::std::option::Option::None,
            function_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CJSMethodArgument {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CJSMethodArgument").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CJSMethodArgument {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CJSMethodArgument {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgJSValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgJSValue {
    // message fields
    // @@protoc_insertion_point(field:CMsgJSValue.bool_value)
    pub bool_value: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgJSValue.int_value)
    pub int_value: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgJSValue.uint_value)
    pub uint_value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJSValue.double_value)
    pub double_value: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CMsgJSValue.string_value)
    pub string_value: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgJSValue.function_handle)
    pub function_handle: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgJSValue.is_array)
    pub is_array: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgJSValue.array_values)
    pub array_values: ::std::vec::Vec<CMsgJSValue>,
    // @@protoc_insertion_point(field:CMsgJSValue.is_object)
    pub is_object: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgJSValue.object_properties)
    pub object_properties: ::std::vec::Vec<cmsg_jsvalue::JSObjectProperty>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgJSValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgJSValue {
    fn default() -> &'a CMsgJSValue {
        <CMsgJSValue as ::protobuf::Message>::default_instance()
    }
}

impl CMsgJSValue {
    pub fn new() -> CMsgJSValue {
        ::std::default::Default::default()
    }

    // optional bool bool_value = 1;

    pub fn bool_value(&self) -> bool {
        self.bool_value.unwrap_or(false)
    }

    pub fn clear_bool_value(&mut self) {
        self.bool_value = ::std::option::Option::None;
    }

    pub fn has_bool_value(&self) -> bool {
        self.bool_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bool_value(&mut self, v: bool) {
        self.bool_value = ::std::option::Option::Some(v);
    }

    // optional int32 int_value = 2;

    pub fn int_value(&self) -> i32 {
        self.int_value.unwrap_or(0)
    }

    pub fn clear_int_value(&mut self) {
        self.int_value = ::std::option::Option::None;
    }

    pub fn has_int_value(&self) -> bool {
        self.int_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_int_value(&mut self, v: i32) {
        self.int_value = ::std::option::Option::Some(v);
    }

    // optional uint32 uint_value = 3;

    pub fn uint_value(&self) -> u32 {
        self.uint_value.unwrap_or(0)
    }

    pub fn clear_uint_value(&mut self) {
        self.uint_value = ::std::option::Option::None;
    }

    pub fn has_uint_value(&self) -> bool {
        self.uint_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uint_value(&mut self, v: u32) {
        self.uint_value = ::std::option::Option::Some(v);
    }

    // optional double double_value = 4;

    pub fn double_value(&self) -> f64 {
        self.double_value.unwrap_or(0.)
    }

    pub fn clear_double_value(&mut self) {
        self.double_value = ::std::option::Option::None;
    }

    pub fn has_double_value(&self) -> bool {
        self.double_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_double_value(&mut self, v: f64) {
        self.double_value = ::std::option::Option::Some(v);
    }

    // optional string string_value = 5;

    pub fn string_value(&self) -> &str {
        match self.string_value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_string_value(&mut self) {
        self.string_value = ::std::option::Option::None;
    }

    pub fn has_string_value(&self) -> bool {
        self.string_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_value(&mut self, v: ::std::string::String) {
        self.string_value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_value(&mut self) -> &mut ::std::string::String {
        if self.string_value.is_none() {
            self.string_value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.string_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_value(&mut self) -> ::std::string::String {
        self.string_value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 function_handle = 6;

    pub fn function_handle(&self) -> u64 {
        self.function_handle.unwrap_or(0)
    }

    pub fn clear_function_handle(&mut self) {
        self.function_handle = ::std::option::Option::None;
    }

    pub fn has_function_handle(&self) -> bool {
        self.function_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_function_handle(&mut self, v: u64) {
        self.function_handle = ::std::option::Option::Some(v);
    }

    // optional bool is_array = 8;

    pub fn is_array(&self) -> bool {
        self.is_array.unwrap_or(false)
    }

    pub fn clear_is_array(&mut self) {
        self.is_array = ::std::option::Option::None;
    }

    pub fn has_is_array(&self) -> bool {
        self.is_array.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_array(&mut self, v: bool) {
        self.is_array = ::std::option::Option::Some(v);
    }

    // optional bool is_object = 10;

    pub fn is_object(&self) -> bool {
        self.is_object.unwrap_or(false)
    }

    pub fn clear_is_object(&mut self) {
        self.is_object = ::std::option::Option::None;
    }

    pub fn has_is_object(&self) -> bool {
        self.is_object.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_object(&mut self, v: bool) {
        self.is_object = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bool_value",
            |m: &CMsgJSValue| { &m.bool_value },
            |m: &mut CMsgJSValue| { &mut m.bool_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "int_value",
            |m: &CMsgJSValue| { &m.int_value },
            |m: &mut CMsgJSValue| { &mut m.int_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uint_value",
            |m: &CMsgJSValue| { &m.uint_value },
            |m: &mut CMsgJSValue| { &mut m.uint_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "double_value",
            |m: &CMsgJSValue| { &m.double_value },
            |m: &mut CMsgJSValue| { &mut m.double_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "string_value",
            |m: &CMsgJSValue| { &m.string_value },
            |m: &mut CMsgJSValue| { &mut m.string_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "function_handle",
            |m: &CMsgJSValue| { &m.function_handle },
            |m: &mut CMsgJSValue| { &mut m.function_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_array",
            |m: &CMsgJSValue| { &m.is_array },
            |m: &mut CMsgJSValue| { &mut m.is_array },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "array_values",
            |m: &CMsgJSValue| { &m.array_values },
            |m: &mut CMsgJSValue| { &mut m.array_values },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_object",
            |m: &CMsgJSValue| { &m.is_object },
            |m: &mut CMsgJSValue| { &mut m.is_object },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "object_properties",
            |m: &CMsgJSValue| { &m.object_properties },
            |m: &mut CMsgJSValue| { &mut m.object_properties },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgJSValue>(
            "CMsgJSValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgJSValue {
    const NAME: &'static str = "CMsgJSValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.bool_value = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.int_value = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.uint_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                33 => {
                    self.double_value = ::std::option::Option::Some(is.read_double()?);
                },
                42 => {
                    self.string_value = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.function_handle = ::std::option::Option::Some(is.read_uint64()?);
                },
                64 => {
                    self.is_array = ::std::option::Option::Some(is.read_bool()?);
                },
                74 => {
                    self.array_values.push(is.read_message()?);
                },
                80 => {
                    self.is_object = ::std::option::Option::Some(is.read_bool()?);
                },
                90 => {
                    self.object_properties.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.bool_value {
            my_size += 1 + 1;
        }
        if let Some(v) = self.int_value {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.uint_value {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.double_value {
            my_size += 1 + 8;
        }
        if let Some(v) = self.string_value.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.function_handle {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.is_array {
            my_size += 1 + 1;
        }
        for value in &self.array_values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.is_object {
            my_size += 1 + 1;
        }
        for value in &self.object_properties {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.bool_value {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.int_value {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.uint_value {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.double_value {
            os.write_double(4, v)?;
        }
        if let Some(v) = self.string_value.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.function_handle {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.is_array {
            os.write_bool(8, v)?;
        }
        for v in &self.array_values {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        if let Some(v) = self.is_object {
            os.write_bool(10, v)?;
        }
        for v in &self.object_properties {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgJSValue {
        CMsgJSValue::new()
    }

    fn clear(&mut self) {
        self.bool_value = ::std::option::Option::None;
        self.int_value = ::std::option::Option::None;
        self.uint_value = ::std::option::Option::None;
        self.double_value = ::std::option::Option::None;
        self.string_value = ::std::option::Option::None;
        self.function_handle = ::std::option::Option::None;
        self.is_array = ::std::option::Option::None;
        self.array_values.clear();
        self.is_object = ::std::option::Option::None;
        self.object_properties.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgJSValue {
        static instance: CMsgJSValue = CMsgJSValue {
            bool_value: ::std::option::Option::None,
            int_value: ::std::option::Option::None,
            uint_value: ::std::option::Option::None,
            double_value: ::std::option::Option::None,
            string_value: ::std::option::Option::None,
            function_handle: ::std::option::Option::None,
            is_array: ::std::option::Option::None,
            array_values: ::std::vec::Vec::new(),
            is_object: ::std::option::Option::None,
            object_properties: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgJSValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgJSValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgJSValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgJSValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgJSValue`
pub mod cmsg_jsvalue {
    // @@protoc_insertion_point(message:CMsgJSValue.JSObjectProperty)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct JSObjectProperty {
        // message fields
        // @@protoc_insertion_point(field:CMsgJSValue.JSObjectProperty.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgJSValue.JSObjectProperty.value)
        pub value: ::protobuf::MessageField<super::CMsgJSValue>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgJSValue.JSObjectProperty.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a JSObjectProperty {
        fn default() -> &'a JSObjectProperty {
            <JSObjectProperty as ::protobuf::Message>::default_instance()
        }
    }

    impl JSObjectProperty {
        pub fn new() -> JSObjectProperty {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &JSObjectProperty| { &m.name },
                |m: &mut JSObjectProperty| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::CMsgJSValue>(
                "value",
                |m: &JSObjectProperty| { &m.value },
                |m: &mut JSObjectProperty| { &mut m.value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<JSObjectProperty>(
                "CMsgJSValue.JSObjectProperty",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for JSObjectProperty {
        const NAME: &'static str = "JSObjectProperty";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.value)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.value.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.value.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> JSObjectProperty {
            JSObjectProperty::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.value.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static JSObjectProperty {
            static instance: JSObjectProperty = JSObjectProperty {
                name: ::std::option::Option::None,
                value: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for JSObjectProperty {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgJSValue.JSObjectProperty").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for JSObjectProperty {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for JSObjectProperty {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgJSMethodCall)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgJSMethodCall {
    // message fields
    // @@protoc_insertion_point(field:CMsgJSMethodCall.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJSMethodCall.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgJSMethodCall.arguments)
    pub arguments: ::std::vec::Vec<CMsgJSValue>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgJSMethodCall.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgJSMethodCall {
    fn default() -> &'a CMsgJSMethodCall {
        <CMsgJSMethodCall as ::protobuf::Message>::default_instance()
    }
}

impl CMsgJSMethodCall {
    pub fn new() -> CMsgJSMethodCall {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgJSMethodCall| { &m.browser_handle },
            |m: &mut CMsgJSMethodCall| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgJSMethodCall| { &m.name },
            |m: &mut CMsgJSMethodCall| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "arguments",
            |m: &CMsgJSMethodCall| { &m.arguments },
            |m: &mut CMsgJSMethodCall| { &mut m.arguments },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgJSMethodCall>(
            "CMsgJSMethodCall",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgJSMethodCall {
    const NAME: &'static str = "CMsgJSMethodCall";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.arguments.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.arguments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.arguments {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgJSMethodCall {
        CMsgJSMethodCall::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.arguments.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgJSMethodCall {
        static instance: CMsgJSMethodCall = CMsgJSMethodCall {
            browser_handle: ::std::option::Option::None,
            name: ::std::option::Option::None,
            arguments: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgJSMethodCall {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgJSMethodCall").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgJSMethodCall {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgJSMethodCall {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgJSExecuteCallback)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgJSExecuteCallback {
    // message fields
    // @@protoc_insertion_point(field:CMsgJSExecuteCallback.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJSExecuteCallback.function_handle)
    pub function_handle: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgJSExecuteCallback.arguments)
    pub arguments: ::std::vec::Vec<CMsgJSValue>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgJSExecuteCallback.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgJSExecuteCallback {
    fn default() -> &'a CMsgJSExecuteCallback {
        <CMsgJSExecuteCallback as ::protobuf::Message>::default_instance()
    }
}

impl CMsgJSExecuteCallback {
    pub fn new() -> CMsgJSExecuteCallback {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint64 function_handle = 2;

    pub fn function_handle(&self) -> u64 {
        self.function_handle.unwrap_or(0)
    }

    pub fn clear_function_handle(&mut self) {
        self.function_handle = ::std::option::Option::None;
    }

    pub fn has_function_handle(&self) -> bool {
        self.function_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_function_handle(&mut self, v: u64) {
        self.function_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgJSExecuteCallback| { &m.browser_handle },
            |m: &mut CMsgJSExecuteCallback| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "function_handle",
            |m: &CMsgJSExecuteCallback| { &m.function_handle },
            |m: &mut CMsgJSExecuteCallback| { &mut m.function_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "arguments",
            |m: &CMsgJSExecuteCallback| { &m.arguments },
            |m: &mut CMsgJSExecuteCallback| { &mut m.arguments },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgJSExecuteCallback>(
            "CMsgJSExecuteCallback",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgJSExecuteCallback {
    const NAME: &'static str = "CMsgJSExecuteCallback";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.function_handle = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.arguments.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.function_handle {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        for value in &self.arguments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.function_handle {
            os.write_uint64(2, v)?;
        }
        for v in &self.arguments {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgJSExecuteCallback {
        CMsgJSExecuteCallback::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.function_handle = ::std::option::Option::None;
        self.arguments.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgJSExecuteCallback {
        static instance: CMsgJSExecuteCallback = CMsgJSExecuteCallback {
            browser_handle: ::std::option::Option::None,
            function_handle: ::std::option::Option::None,
            arguments: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgJSExecuteCallback {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgJSExecuteCallback").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgJSExecuteCallback {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgJSExecuteCallback {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgJSReleaseCallback)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgJSReleaseCallback {
    // message fields
    // @@protoc_insertion_point(field:CMsgJSReleaseCallback.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJSReleaseCallback.function_handle)
    pub function_handle: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgJSReleaseCallback.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgJSReleaseCallback {
    fn default() -> &'a CMsgJSReleaseCallback {
        <CMsgJSReleaseCallback as ::protobuf::Message>::default_instance()
    }
}

impl CMsgJSReleaseCallback {
    pub fn new() -> CMsgJSReleaseCallback {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint64 function_handle = 2;

    pub fn function_handle(&self) -> u64 {
        self.function_handle.unwrap_or(0)
    }

    pub fn clear_function_handle(&mut self) {
        self.function_handle = ::std::option::Option::None;
    }

    pub fn has_function_handle(&self) -> bool {
        self.function_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_function_handle(&mut self, v: u64) {
        self.function_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgJSReleaseCallback| { &m.browser_handle },
            |m: &mut CMsgJSReleaseCallback| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "function_handle",
            |m: &CMsgJSReleaseCallback| { &m.function_handle },
            |m: &mut CMsgJSReleaseCallback| { &mut m.function_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgJSReleaseCallback>(
            "CMsgJSReleaseCallback",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgJSReleaseCallback {
    const NAME: &'static str = "CMsgJSReleaseCallback";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.function_handle = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.function_handle {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.function_handle {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgJSReleaseCallback {
        CMsgJSReleaseCallback::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.function_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgJSReleaseCallback {
        static instance: CMsgJSReleaseCallback = CMsgJSReleaseCallback {
            browser_handle: ::std::option::Option::None,
            function_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgJSReleaseCallback {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgJSReleaseCallback").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgJSReleaseCallback {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgJSReleaseCallback {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgJSRaiseException)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgJSRaiseException {
    // message fields
    // @@protoc_insertion_point(field:CMsgJSRaiseException.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJSRaiseException.exception)
    pub exception: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgJSRaiseException.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgJSRaiseException {
    fn default() -> &'a CMsgJSRaiseException {
        <CMsgJSRaiseException as ::protobuf::Message>::default_instance()
    }
}

impl CMsgJSRaiseException {
    pub fn new() -> CMsgJSRaiseException {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string exception = 2;

    pub fn exception(&self) -> &str {
        match self.exception.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_exception(&mut self) {
        self.exception = ::std::option::Option::None;
    }

    pub fn has_exception(&self) -> bool {
        self.exception.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exception(&mut self, v: ::std::string::String) {
        self.exception = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exception(&mut self) -> &mut ::std::string::String {
        if self.exception.is_none() {
            self.exception = ::std::option::Option::Some(::std::string::String::new());
        }
        self.exception.as_mut().unwrap()
    }

    // Take field
    pub fn take_exception(&mut self) -> ::std::string::String {
        self.exception.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgJSRaiseException| { &m.browser_handle },
            |m: &mut CMsgJSRaiseException| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "exception",
            |m: &CMsgJSRaiseException| { &m.exception },
            |m: &mut CMsgJSRaiseException| { &mut m.exception },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgJSRaiseException>(
            "CMsgJSRaiseException",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgJSRaiseException {
    const NAME: &'static str = "CMsgJSRaiseException";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.exception = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.exception.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.exception.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgJSRaiseException {
        CMsgJSRaiseException::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.exception = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgJSRaiseException {
        static instance: CMsgJSRaiseException = CMsgJSRaiseException {
            browser_handle: ::std::option::Option::None,
            exception: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgJSRaiseException {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgJSRaiseException").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgJSRaiseException {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgJSRaiseException {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgLoadLocalization)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLoadLocalization {
    // message fields
    // @@protoc_insertion_point(field:CMsgLoadLocalization.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLoadLocalization.localization_path)
    pub localization_path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgLoadLocalization.language)
    pub language: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLoadLocalization.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLoadLocalization {
    fn default() -> &'a CMsgLoadLocalization {
        <CMsgLoadLocalization as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLoadLocalization {
    pub fn new() -> CMsgLoadLocalization {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string localization_path = 2;

    pub fn localization_path(&self) -> &str {
        match self.localization_path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_localization_path(&mut self) {
        self.localization_path = ::std::option::Option::None;
    }

    pub fn has_localization_path(&self) -> bool {
        self.localization_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localization_path(&mut self, v: ::std::string::String) {
        self.localization_path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localization_path(&mut self) -> &mut ::std::string::String {
        if self.localization_path.is_none() {
            self.localization_path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.localization_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_localization_path(&mut self) -> ::std::string::String {
        self.localization_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string language = 3;

    pub fn language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language = ::std::option::Option::Some(::std::string::String::new());
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgLoadLocalization| { &m.browser_handle },
            |m: &mut CMsgLoadLocalization| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "localization_path",
            |m: &CMsgLoadLocalization| { &m.localization_path },
            |m: &mut CMsgLoadLocalization| { &mut m.localization_path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "language",
            |m: &CMsgLoadLocalization| { &m.language },
            |m: &mut CMsgLoadLocalization| { &mut m.language },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLoadLocalization>(
            "CMsgLoadLocalization",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgLoadLocalization {
    const NAME: &'static str = "CMsgLoadLocalization";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.localization_path = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.language = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.localization_path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.localization_path.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.language.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLoadLocalization {
        CMsgLoadLocalization::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.localization_path = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLoadLocalization {
        static instance: CMsgLoadLocalization = CMsgLoadLocalization {
            browser_handle: ::std::option::Option::None,
            localization_path: ::std::option::Option::None,
            language: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgLoadLocalization {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLoadLocalization").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLoadLocalization {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLoadLocalization {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgJumpListLink)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgJumpListLink {
    // message fields
    // @@protoc_insertion_point(field:CMsgJumpListLink.display_name)
    pub display_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgJumpListLink.url_link)
    pub url_link: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgJumpListLink.icon_path)
    pub icon_path: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgJumpListLink.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgJumpListLink {
    fn default() -> &'a CMsgJumpListLink {
        <CMsgJumpListLink as ::protobuf::Message>::default_instance()
    }
}

impl CMsgJumpListLink {
    pub fn new() -> CMsgJumpListLink {
        ::std::default::Default::default()
    }

    // optional string display_name = 1;

    pub fn display_name(&self) -> &str {
        match self.display_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_display_name(&mut self) {
        self.display_name = ::std::option::Option::None;
    }

    pub fn has_display_name(&self) -> bool {
        self.display_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        if self.display_name.is_none() {
            self.display_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.display_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        self.display_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string url_link = 2;

    pub fn url_link(&self) -> &str {
        match self.url_link.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url_link(&mut self) {
        self.url_link = ::std::option::Option::None;
    }

    pub fn has_url_link(&self) -> bool {
        self.url_link.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url_link(&mut self, v: ::std::string::String) {
        self.url_link = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url_link(&mut self) -> &mut ::std::string::String {
        if self.url_link.is_none() {
            self.url_link = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url_link.as_mut().unwrap()
    }

    // Take field
    pub fn take_url_link(&mut self) -> ::std::string::String {
        self.url_link.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string icon_path = 3;

    pub fn icon_path(&self) -> &str {
        match self.icon_path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_icon_path(&mut self) {
        self.icon_path = ::std::option::Option::None;
    }

    pub fn has_icon_path(&self) -> bool {
        self.icon_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icon_path(&mut self, v: ::std::string::String) {
        self.icon_path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon_path(&mut self) -> &mut ::std::string::String {
        if self.icon_path.is_none() {
            self.icon_path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.icon_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_icon_path(&mut self) -> ::std::string::String {
        self.icon_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_name",
            |m: &CMsgJumpListLink| { &m.display_name },
            |m: &mut CMsgJumpListLink| { &mut m.display_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url_link",
            |m: &CMsgJumpListLink| { &m.url_link },
            |m: &mut CMsgJumpListLink| { &mut m.url_link },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "icon_path",
            |m: &CMsgJumpListLink| { &m.icon_path },
            |m: &mut CMsgJumpListLink| { &mut m.icon_path },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgJumpListLink>(
            "CMsgJumpListLink",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgJumpListLink {
    const NAME: &'static str = "CMsgJumpListLink";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.display_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.url_link = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.icon_path = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.display_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.url_link.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.icon_path.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.display_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.url_link.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.icon_path.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgJumpListLink {
        CMsgJumpListLink::new()
    }

    fn clear(&mut self) {
        self.display_name = ::std::option::Option::None;
        self.url_link = ::std::option::Option::None;
        self.icon_path = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgJumpListLink {
        static instance: CMsgJumpListLink = CMsgJumpListLink {
            display_name: ::std::option::Option::None,
            url_link: ::std::option::Option::None,
            icon_path: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgJumpListLink {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgJumpListLink").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgJumpListLink {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgJumpListLink {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMSgJumpListMRUApp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMSgJumpListMRUApp {
    // message fields
    // @@protoc_insertion_point(field:CMSgJumpListMRUApp.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMSgJumpListMRUApp.display_name)
    pub display_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMSgJumpListMRUApp.url_link)
    pub url_link: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMSgJumpListMRUApp.icon_path)
    pub icon_path: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMSgJumpListMRUApp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMSgJumpListMRUApp {
    fn default() -> &'a CMSgJumpListMRUApp {
        <CMSgJumpListMRUApp as ::protobuf::Message>::default_instance()
    }
}

impl CMSgJumpListMRUApp {
    pub fn new() -> CMSgJumpListMRUApp {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string display_name = 2;

    pub fn display_name(&self) -> &str {
        match self.display_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_display_name(&mut self) {
        self.display_name = ::std::option::Option::None;
    }

    pub fn has_display_name(&self) -> bool {
        self.display_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        if self.display_name.is_none() {
            self.display_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.display_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        self.display_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string url_link = 3;

    pub fn url_link(&self) -> &str {
        match self.url_link.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url_link(&mut self) {
        self.url_link = ::std::option::Option::None;
    }

    pub fn has_url_link(&self) -> bool {
        self.url_link.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url_link(&mut self, v: ::std::string::String) {
        self.url_link = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url_link(&mut self) -> &mut ::std::string::String {
        if self.url_link.is_none() {
            self.url_link = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url_link.as_mut().unwrap()
    }

    // Take field
    pub fn take_url_link(&mut self) -> ::std::string::String {
        self.url_link.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string icon_path = 4;

    pub fn icon_path(&self) -> &str {
        match self.icon_path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_icon_path(&mut self) {
        self.icon_path = ::std::option::Option::None;
    }

    pub fn has_icon_path(&self) -> bool {
        self.icon_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icon_path(&mut self, v: ::std::string::String) {
        self.icon_path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon_path(&mut self) -> &mut ::std::string::String {
        if self.icon_path.is_none() {
            self.icon_path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.icon_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_icon_path(&mut self) -> ::std::string::String {
        self.icon_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CMSgJumpListMRUApp| { &m.appid },
            |m: &mut CMSgJumpListMRUApp| { &mut m.appid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_name",
            |m: &CMSgJumpListMRUApp| { &m.display_name },
            |m: &mut CMSgJumpListMRUApp| { &mut m.display_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url_link",
            |m: &CMSgJumpListMRUApp| { &m.url_link },
            |m: &mut CMSgJumpListMRUApp| { &mut m.url_link },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "icon_path",
            |m: &CMSgJumpListMRUApp| { &m.icon_path },
            |m: &mut CMSgJumpListMRUApp| { &mut m.icon_path },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMSgJumpListMRUApp>(
            "CMSgJumpListMRUApp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMSgJumpListMRUApp {
    const NAME: &'static str = "CMSgJumpListMRUApp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.display_name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.url_link = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.icon_path = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.display_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.url_link.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.icon_path.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.display_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.url_link.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.icon_path.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMSgJumpListMRUApp {
        CMSgJumpListMRUApp::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.display_name = ::std::option::Option::None;
        self.url_link = ::std::option::Option::None;
        self.icon_path = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMSgJumpListMRUApp {
        static instance: CMSgJumpListMRUApp = CMSgJumpListMRUApp {
            appid: ::std::option::Option::None,
            display_name: ::std::option::Option::None,
            url_link: ::std::option::Option::None,
            icon_path: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMSgJumpListMRUApp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMSgJumpListMRUApp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMSgJumpListMRUApp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMSgJumpListMRUApp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSetJumpList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetJumpList {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetJumpList.steam_path)
    pub steam_path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSetJumpList.mru_title)
    pub mru_title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSetJumpList.apps)
    pub apps: ::std::vec::Vec<CMSgJumpListMRUApp>,
    // @@protoc_insertion_point(field:CMsgSetJumpList.links)
    pub links: ::std::vec::Vec<CMsgJumpListLink>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetJumpList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetJumpList {
    fn default() -> &'a CMsgSetJumpList {
        <CMsgSetJumpList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetJumpList {
    pub fn new() -> CMsgSetJumpList {
        ::std::default::Default::default()
    }

    // optional string steam_path = 1;

    pub fn steam_path(&self) -> &str {
        match self.steam_path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_steam_path(&mut self) {
        self.steam_path = ::std::option::Option::None;
    }

    pub fn has_steam_path(&self) -> bool {
        self.steam_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_path(&mut self, v: ::std::string::String) {
        self.steam_path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_steam_path(&mut self) -> &mut ::std::string::String {
        if self.steam_path.is_none() {
            self.steam_path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.steam_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_steam_path(&mut self) -> ::std::string::String {
        self.steam_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string mru_title = 2;

    pub fn mru_title(&self) -> &str {
        match self.mru_title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mru_title(&mut self) {
        self.mru_title = ::std::option::Option::None;
    }

    pub fn has_mru_title(&self) -> bool {
        self.mru_title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mru_title(&mut self, v: ::std::string::String) {
        self.mru_title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mru_title(&mut self) -> &mut ::std::string::String {
        if self.mru_title.is_none() {
            self.mru_title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mru_title.as_mut().unwrap()
    }

    // Take field
    pub fn take_mru_title(&mut self) -> ::std::string::String {
        self.mru_title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_path",
            |m: &CMsgSetJumpList| { &m.steam_path },
            |m: &mut CMsgSetJumpList| { &mut m.steam_path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mru_title",
            |m: &CMsgSetJumpList| { &m.mru_title },
            |m: &mut CMsgSetJumpList| { &mut m.mru_title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "apps",
            |m: &CMsgSetJumpList| { &m.apps },
            |m: &mut CMsgSetJumpList| { &mut m.apps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "links",
            |m: &CMsgSetJumpList| { &m.links },
            |m: &mut CMsgSetJumpList| { &mut m.links },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetJumpList>(
            "CMsgSetJumpList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSetJumpList {
    const NAME: &'static str = "CMsgSetJumpList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.steam_path = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.mru_title = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.apps.push(is.read_message()?);
                },
                34 => {
                    self.links.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.mru_title.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.links {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_path.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.mru_title.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.apps {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.links {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetJumpList {
        CMsgSetJumpList::new()
    }

    fn clear(&mut self) {
        self.steam_path = ::std::option::Option::None;
        self.mru_title = ::std::option::Option::None;
        self.apps.clear();
        self.links.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetJumpList {
        static instance: CMsgSetJumpList = CMsgSetJumpList {
            steam_path: ::std::option::Option::None,
            mru_title: ::std::option::Option::None,
            apps: ::std::vec::Vec::new(),
            links: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSetJumpList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetJumpList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetJumpList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetJumpList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSetGameOverlayTargetPIDs)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetGameOverlayTargetPIDs {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetGameOverlayTargetPIDs.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetGameOverlayTargetPIDs.target_pid)
    pub target_pid: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetGameOverlayTargetPIDs.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetGameOverlayTargetPIDs {
    fn default() -> &'a CMsgSetGameOverlayTargetPIDs {
        <CMsgSetGameOverlayTargetPIDs as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetGameOverlayTargetPIDs {
    pub fn new() -> CMsgSetGameOverlayTargetPIDs {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgSetGameOverlayTargetPIDs| { &m.browser_handle },
            |m: &mut CMsgSetGameOverlayTargetPIDs| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "target_pid",
            |m: &CMsgSetGameOverlayTargetPIDs| { &m.target_pid },
            |m: &mut CMsgSetGameOverlayTargetPIDs| { &mut m.target_pid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetGameOverlayTargetPIDs>(
            "CMsgSetGameOverlayTargetPIDs",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSetGameOverlayTargetPIDs {
    const NAME: &'static str = "CMsgSetGameOverlayTargetPIDs";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.target_pid)?;
                },
                16 => {
                    self.target_pid.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.target_pid {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        for v in &self.target_pid {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetGameOverlayTargetPIDs {
        CMsgSetGameOverlayTargetPIDs::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.target_pid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetGameOverlayTargetPIDs {
        static instance: CMsgSetGameOverlayTargetPIDs = CMsgSetGameOverlayTargetPIDs {
            browser_handle: ::std::option::Option::None,
            target_pid: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSetGameOverlayTargetPIDs {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetGameOverlayTargetPIDs").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetGameOverlayTargetPIDs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetGameOverlayTargetPIDs {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGameOverlayTargetTextureID)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameOverlayTargetTextureID {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameOverlayTargetTextureID.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameOverlayTargetTextureID.target_pid)
    pub target_pid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameOverlayTargetTextureID.texture_handle)
    pub texture_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameOverlayTargetTextureID.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameOverlayTargetTextureID {
    fn default() -> &'a CMsgGameOverlayTargetTextureID {
        <CMsgGameOverlayTargetTextureID as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameOverlayTargetTextureID {
    pub fn new() -> CMsgGameOverlayTargetTextureID {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 target_pid = 2;

    pub fn target_pid(&self) -> u32 {
        self.target_pid.unwrap_or(0)
    }

    pub fn clear_target_pid(&mut self) {
        self.target_pid = ::std::option::Option::None;
    }

    pub fn has_target_pid(&self) -> bool {
        self.target_pid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_pid(&mut self, v: u32) {
        self.target_pid = ::std::option::Option::Some(v);
    }

    // optional uint32 texture_handle = 3;

    pub fn texture_handle(&self) -> u32 {
        self.texture_handle.unwrap_or(0)
    }

    pub fn clear_texture_handle(&mut self) {
        self.texture_handle = ::std::option::Option::None;
    }

    pub fn has_texture_handle(&self) -> bool {
        self.texture_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_texture_handle(&mut self, v: u32) {
        self.texture_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgGameOverlayTargetTextureID| { &m.browser_handle },
            |m: &mut CMsgGameOverlayTargetTextureID| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_pid",
            |m: &CMsgGameOverlayTargetTextureID| { &m.target_pid },
            |m: &mut CMsgGameOverlayTargetTextureID| { &mut m.target_pid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "texture_handle",
            |m: &CMsgGameOverlayTargetTextureID| { &m.texture_handle },
            |m: &mut CMsgGameOverlayTargetTextureID| { &mut m.texture_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGameOverlayTargetTextureID>(
            "CMsgGameOverlayTargetTextureID",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGameOverlayTargetTextureID {
    const NAME: &'static str = "CMsgGameOverlayTargetTextureID";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.target_pid = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.texture_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.target_pid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.texture_handle {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.target_pid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.texture_handle {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameOverlayTargetTextureID {
        CMsgGameOverlayTargetTextureID::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.target_pid = ::std::option::Option::None;
        self.texture_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameOverlayTargetTextureID {
        static instance: CMsgGameOverlayTargetTextureID = CMsgGameOverlayTargetTextureID {
            browser_handle: ::std::option::Option::None,
            target_pid: ::std::option::Option::None,
            texture_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGameOverlayTargetTextureID {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGameOverlayTargetTextureID").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGameOverlayTargetTextureID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameOverlayTargetTextureID {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgDraggableRegionsChanged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDraggableRegionsChanged {
    // message fields
    // @@protoc_insertion_point(field:CMsgDraggableRegionsChanged.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDraggableRegionsChanged.rects)
    pub rects: ::std::vec::Vec<cmsg_draggable_regions_changed::DraggableRects>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDraggableRegionsChanged.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDraggableRegionsChanged {
    fn default() -> &'a CMsgDraggableRegionsChanged {
        <CMsgDraggableRegionsChanged as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDraggableRegionsChanged {
    pub fn new() -> CMsgDraggableRegionsChanged {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgDraggableRegionsChanged| { &m.browser_handle },
            |m: &mut CMsgDraggableRegionsChanged| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rects",
            |m: &CMsgDraggableRegionsChanged| { &m.rects },
            |m: &mut CMsgDraggableRegionsChanged| { &mut m.rects },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDraggableRegionsChanged>(
            "CMsgDraggableRegionsChanged",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDraggableRegionsChanged {
    const NAME: &'static str = "CMsgDraggableRegionsChanged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.rects.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.rects {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        for v in &self.rects {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDraggableRegionsChanged {
        CMsgDraggableRegionsChanged::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.rects.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDraggableRegionsChanged {
        static instance: CMsgDraggableRegionsChanged = CMsgDraggableRegionsChanged {
            browser_handle: ::std::option::Option::None,
            rects: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDraggableRegionsChanged {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDraggableRegionsChanged").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDraggableRegionsChanged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDraggableRegionsChanged {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgDraggableRegionsChanged`
pub mod cmsg_draggable_regions_changed {
    // @@protoc_insertion_point(message:CMsgDraggableRegionsChanged.DraggableRects)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DraggableRects {
        // message fields
        // @@protoc_insertion_point(field:CMsgDraggableRegionsChanged.DraggableRects.x)
        pub x: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDraggableRegionsChanged.DraggableRects.y)
        pub y: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDraggableRegionsChanged.DraggableRects.width)
        pub width: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDraggableRegionsChanged.DraggableRects.height)
        pub height: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDraggableRegionsChanged.DraggableRects.draggable)
        pub draggable: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDraggableRegionsChanged.DraggableRects.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DraggableRects {
        fn default() -> &'a DraggableRects {
            <DraggableRects as ::protobuf::Message>::default_instance()
        }
    }

    impl DraggableRects {
        pub fn new() -> DraggableRects {
            ::std::default::Default::default()
        }

        // optional int32 x = 1;

        pub fn x(&self) -> i32 {
            self.x.unwrap_or(0)
        }

        pub fn clear_x(&mut self) {
            self.x = ::std::option::Option::None;
        }

        pub fn has_x(&self) -> bool {
            self.x.is_some()
        }

        // Param is passed by value, moved
        pub fn set_x(&mut self, v: i32) {
            self.x = ::std::option::Option::Some(v);
        }

        // optional int32 y = 2;

        pub fn y(&self) -> i32 {
            self.y.unwrap_or(0)
        }

        pub fn clear_y(&mut self) {
            self.y = ::std::option::Option::None;
        }

        pub fn has_y(&self) -> bool {
            self.y.is_some()
        }

        // Param is passed by value, moved
        pub fn set_y(&mut self, v: i32) {
            self.y = ::std::option::Option::Some(v);
        }

        // optional int32 width = 3;

        pub fn width(&self) -> i32 {
            self.width.unwrap_or(0)
        }

        pub fn clear_width(&mut self) {
            self.width = ::std::option::Option::None;
        }

        pub fn has_width(&self) -> bool {
            self.width.is_some()
        }

        // Param is passed by value, moved
        pub fn set_width(&mut self, v: i32) {
            self.width = ::std::option::Option::Some(v);
        }

        // optional int32 height = 4;

        pub fn height(&self) -> i32 {
            self.height.unwrap_or(0)
        }

        pub fn clear_height(&mut self) {
            self.height = ::std::option::Option::None;
        }

        pub fn has_height(&self) -> bool {
            self.height.is_some()
        }

        // Param is passed by value, moved
        pub fn set_height(&mut self, v: i32) {
            self.height = ::std::option::Option::Some(v);
        }

        // optional bool draggable = 5;

        pub fn draggable(&self) -> bool {
            self.draggable.unwrap_or(false)
        }

        pub fn clear_draggable(&mut self) {
            self.draggable = ::std::option::Option::None;
        }

        pub fn has_draggable(&self) -> bool {
            self.draggable.is_some()
        }

        // Param is passed by value, moved
        pub fn set_draggable(&mut self, v: bool) {
            self.draggable = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "x",
                |m: &DraggableRects| { &m.x },
                |m: &mut DraggableRects| { &mut m.x },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "y",
                |m: &DraggableRects| { &m.y },
                |m: &mut DraggableRects| { &mut m.y },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "width",
                |m: &DraggableRects| { &m.width },
                |m: &mut DraggableRects| { &mut m.width },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "height",
                |m: &DraggableRects| { &m.height },
                |m: &mut DraggableRects| { &mut m.height },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "draggable",
                |m: &DraggableRects| { &m.draggable },
                |m: &mut DraggableRects| { &mut m.draggable },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DraggableRects>(
                "CMsgDraggableRegionsChanged.DraggableRects",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for DraggableRects {
        const NAME: &'static str = "DraggableRects";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.x = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.y = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.width = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.height = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.draggable = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.x {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.y {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.width {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.height {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.draggable {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.x {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.y {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.width {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.height {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.draggable {
                os.write_bool(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DraggableRects {
            DraggableRects::new()
        }

        fn clear(&mut self) {
            self.x = ::std::option::Option::None;
            self.y = ::std::option::Option::None;
            self.width = ::std::option::Option::None;
            self.height = ::std::option::Option::None;
            self.draggable = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DraggableRects {
            static instance: DraggableRects = DraggableRects {
                x: ::std::option::Option::None,
                y: ::std::option::Option::None,
                width: ::std::option::Option::None,
                height: ::std::option::Option::None,
                draggable: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for DraggableRects {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgDraggableRegionsChanged.DraggableRects").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DraggableRects {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for DraggableRects {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgResizeGripChanged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgResizeGripChanged {
    // message fields
    // @@protoc_insertion_point(field:CMsgResizeGripChanged.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgResizeGripChanged.width)
    pub width: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgResizeGripChanged.height)
    pub height: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgResizeGripChanged.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgResizeGripChanged {
    fn default() -> &'a CMsgResizeGripChanged {
        <CMsgResizeGripChanged as ::protobuf::Message>::default_instance()
    }
}

impl CMsgResizeGripChanged {
    pub fn new() -> CMsgResizeGripChanged {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional int32 width = 2;

    pub fn width(&self) -> i32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional int32 height = 3;

    pub fn height(&self) -> i32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgResizeGripChanged| { &m.browser_handle },
            |m: &mut CMsgResizeGripChanged| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &CMsgResizeGripChanged| { &m.width },
            |m: &mut CMsgResizeGripChanged| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &CMsgResizeGripChanged| { &m.height },
            |m: &mut CMsgResizeGripChanged| { &mut m.height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgResizeGripChanged>(
            "CMsgResizeGripChanged",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgResizeGripChanged {
    const NAME: &'static str = "CMsgResizeGripChanged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.width = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.height = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.width {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.height {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgResizeGripChanged {
        CMsgResizeGripChanged::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgResizeGripChanged {
        static instance: CMsgResizeGripChanged = CMsgResizeGripChanged {
            browser_handle: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgResizeGripChanged {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgResizeGripChanged").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgResizeGripChanged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgResizeGripChanged {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSetWindowPosition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetWindowPosition {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetWindowPosition.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetWindowPosition.x)
    pub x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSetWindowPosition.y)
    pub y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSetWindowPosition.width)
    pub width: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSetWindowPosition.height)
    pub height: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSetWindowPosition.min_width)
    pub min_width: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSetWindowPosition.min_height)
    pub min_height: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetWindowPosition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetWindowPosition {
    fn default() -> &'a CMsgSetWindowPosition {
        <CMsgSetWindowPosition as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetWindowPosition {
    pub fn new() -> CMsgSetWindowPosition {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional int32 x = 2;

    pub fn x(&self) -> i32 {
        self.x.unwrap_or(0)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: i32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional int32 y = 3;

    pub fn y(&self) -> i32 {
        self.y.unwrap_or(0)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: i32) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional int32 width = 4;

    pub fn width(&self) -> i32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional int32 height = 5;

    pub fn height(&self) -> i32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional int32 min_width = 6;

    pub fn min_width(&self) -> i32 {
        self.min_width.unwrap_or(0)
    }

    pub fn clear_min_width(&mut self) {
        self.min_width = ::std::option::Option::None;
    }

    pub fn has_min_width(&self) -> bool {
        self.min_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_width(&mut self, v: i32) {
        self.min_width = ::std::option::Option::Some(v);
    }

    // optional int32 min_height = 7;

    pub fn min_height(&self) -> i32 {
        self.min_height.unwrap_or(0)
    }

    pub fn clear_min_height(&mut self) {
        self.min_height = ::std::option::Option::None;
    }

    pub fn has_min_height(&self) -> bool {
        self.min_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_height(&mut self, v: i32) {
        self.min_height = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgSetWindowPosition| { &m.browser_handle },
            |m: &mut CMsgSetWindowPosition| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &CMsgSetWindowPosition| { &m.x },
            |m: &mut CMsgSetWindowPosition| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &CMsgSetWindowPosition| { &m.y },
            |m: &mut CMsgSetWindowPosition| { &mut m.y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &CMsgSetWindowPosition| { &m.width },
            |m: &mut CMsgSetWindowPosition| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &CMsgSetWindowPosition| { &m.height },
            |m: &mut CMsgSetWindowPosition| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "min_width",
            |m: &CMsgSetWindowPosition| { &m.min_width },
            |m: &mut CMsgSetWindowPosition| { &mut m.min_width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "min_height",
            |m: &CMsgSetWindowPosition| { &m.min_height },
            |m: &mut CMsgSetWindowPosition| { &mut m.min_height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetWindowPosition>(
            "CMsgSetWindowPosition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSetWindowPosition {
    const NAME: &'static str = "CMsgSetWindowPosition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.x = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.y = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.width = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.height = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.min_width = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.min_height = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.min_width {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.min_height {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.width {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.height {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.min_width {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.min_height {
            os.write_int32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetWindowPosition {
        CMsgSetWindowPosition::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.min_width = ::std::option::Option::None;
        self.min_height = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetWindowPosition {
        static instance: CMsgSetWindowPosition = CMsgSetWindowPosition {
            browser_handle: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            min_width: ::std::option::Option::None,
            min_height: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSetWindowPosition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetWindowPosition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetWindowPosition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetWindowPosition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgShowWindow)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgShowWindow {
    // message fields
    // @@protoc_insertion_point(field:CMsgShowWindow.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgShowWindow.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgShowWindow {
    fn default() -> &'a CMsgShowWindow {
        <CMsgShowWindow as ::protobuf::Message>::default_instance()
    }
}

impl CMsgShowWindow {
    pub fn new() -> CMsgShowWindow {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgShowWindow| { &m.browser_handle },
            |m: &mut CMsgShowWindow| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgShowWindow>(
            "CMsgShowWindow",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgShowWindow {
    const NAME: &'static str = "CMsgShowWindow";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgShowWindow {
        CMsgShowWindow::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgShowWindow {
        static instance: CMsgShowWindow = CMsgShowWindow {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgShowWindow {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgShowWindow").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgShowWindow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgShowWindow {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgHideWindow)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHideWindow {
    // message fields
    // @@protoc_insertion_point(field:CMsgHideWindow.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgHideWindow.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHideWindow {
    fn default() -> &'a CMsgHideWindow {
        <CMsgHideWindow as ::protobuf::Message>::default_instance()
    }
}

impl CMsgHideWindow {
    pub fn new() -> CMsgHideWindow {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgHideWindow| { &m.browser_handle },
            |m: &mut CMsgHideWindow| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgHideWindow>(
            "CMsgHideWindow",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgHideWindow {
    const NAME: &'static str = "CMsgHideWindow";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHideWindow {
        CMsgHideWindow::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHideWindow {
        static instance: CMsgHideWindow = CMsgHideWindow {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgHideWindow {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgHideWindow").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgHideWindow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgHideWindow {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgBringWindowToFront)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBringWindowToFront {
    // message fields
    // @@protoc_insertion_point(field:CMsgBringWindowToFront.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBringWindowToFront.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBringWindowToFront {
    fn default() -> &'a CMsgBringWindowToFront {
        <CMsgBringWindowToFront as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBringWindowToFront {
    pub fn new() -> CMsgBringWindowToFront {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgBringWindowToFront| { &m.browser_handle },
            |m: &mut CMsgBringWindowToFront| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgBringWindowToFront>(
            "CMsgBringWindowToFront",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgBringWindowToFront {
    const NAME: &'static str = "CMsgBringWindowToFront";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBringWindowToFront {
        CMsgBringWindowToFront::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBringWindowToFront {
        static instance: CMsgBringWindowToFront = CMsgBringWindowToFront {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgBringWindowToFront {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgBringWindowToFront").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgBringWindowToFront {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBringWindowToFront {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSetForegroundWindow)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetForegroundWindow {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetForegroundWindow.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetForegroundWindow.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetForegroundWindow {
    fn default() -> &'a CMsgSetForegroundWindow {
        <CMsgSetForegroundWindow as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetForegroundWindow {
    pub fn new() -> CMsgSetForegroundWindow {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgSetForegroundWindow| { &m.browser_handle },
            |m: &mut CMsgSetForegroundWindow| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetForegroundWindow>(
            "CMsgSetForegroundWindow",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSetForegroundWindow {
    const NAME: &'static str = "CMsgSetForegroundWindow";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetForegroundWindow {
        CMsgSetForegroundWindow::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetForegroundWindow {
        static instance: CMsgSetForegroundWindow = CMsgSetForegroundWindow {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSetForegroundWindow {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetForegroundWindow").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetForegroundWindow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetForegroundWindow {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgMaximizeRestoreWindow)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMaximizeRestoreWindow {
    // message fields
    // @@protoc_insertion_point(field:CMsgMaximizeRestoreWindow.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMaximizeRestoreWindow.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMaximizeRestoreWindow {
    fn default() -> &'a CMsgMaximizeRestoreWindow {
        <CMsgMaximizeRestoreWindow as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMaximizeRestoreWindow {
    pub fn new() -> CMsgMaximizeRestoreWindow {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgMaximizeRestoreWindow| { &m.browser_handle },
            |m: &mut CMsgMaximizeRestoreWindow| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgMaximizeRestoreWindow>(
            "CMsgMaximizeRestoreWindow",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgMaximizeRestoreWindow {
    const NAME: &'static str = "CMsgMaximizeRestoreWindow";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMaximizeRestoreWindow {
        CMsgMaximizeRestoreWindow::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMaximizeRestoreWindow {
        static instance: CMsgMaximizeRestoreWindow = CMsgMaximizeRestoreWindow {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgMaximizeRestoreWindow {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgMaximizeRestoreWindow").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgMaximizeRestoreWindow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMaximizeRestoreWindow {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgMinimizeWindow)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMinimizeWindow {
    // message fields
    // @@protoc_insertion_point(field:CMsgMinimizeWindow.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMinimizeWindow.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMinimizeWindow {
    fn default() -> &'a CMsgMinimizeWindow {
        <CMsgMinimizeWindow as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMinimizeWindow {
    pub fn new() -> CMsgMinimizeWindow {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgMinimizeWindow| { &m.browser_handle },
            |m: &mut CMsgMinimizeWindow| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgMinimizeWindow>(
            "CMsgMinimizeWindow",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgMinimizeWindow {
    const NAME: &'static str = "CMsgMinimizeWindow";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMinimizeWindow {
        CMsgMinimizeWindow::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMinimizeWindow {
        static instance: CMsgMinimizeWindow = CMsgMinimizeWindow {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgMinimizeWindow {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgMinimizeWindow").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgMinimizeWindow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMinimizeWindow {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgShowBrowserContextMenu)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgShowBrowserContextMenu {
    // message fields
    // @@protoc_insertion_point(field:CMsgShowBrowserContextMenu.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgShowBrowserContextMenu.custom_commands)
    pub custom_commands: ::std::vec::Vec<cmsg_show_browser_context_menu::ContextCommand>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgShowBrowserContextMenu.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgShowBrowserContextMenu {
    fn default() -> &'a CMsgShowBrowserContextMenu {
        <CMsgShowBrowserContextMenu as ::protobuf::Message>::default_instance()
    }
}

impl CMsgShowBrowserContextMenu {
    pub fn new() -> CMsgShowBrowserContextMenu {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgShowBrowserContextMenu| { &m.browser_handle },
            |m: &mut CMsgShowBrowserContextMenu| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "custom_commands",
            |m: &CMsgShowBrowserContextMenu| { &m.custom_commands },
            |m: &mut CMsgShowBrowserContextMenu| { &mut m.custom_commands },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgShowBrowserContextMenu>(
            "CMsgShowBrowserContextMenu",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgShowBrowserContextMenu {
    const NAME: &'static str = "CMsgShowBrowserContextMenu";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.custom_commands.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.custom_commands {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        for v in &self.custom_commands {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgShowBrowserContextMenu {
        CMsgShowBrowserContextMenu::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.custom_commands.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgShowBrowserContextMenu {
        static instance: CMsgShowBrowserContextMenu = CMsgShowBrowserContextMenu {
            browser_handle: ::std::option::Option::None,
            custom_commands: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgShowBrowserContextMenu {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgShowBrowserContextMenu").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgShowBrowserContextMenu {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgShowBrowserContextMenu {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgShowBrowserContextMenu`
pub mod cmsg_show_browser_context_menu {
    // @@protoc_insertion_point(message:CMsgShowBrowserContextMenu.ContextCommand)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ContextCommand {
        // message fields
        // @@protoc_insertion_point(field:CMsgShowBrowserContextMenu.ContextCommand.id)
        pub id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgShowBrowserContextMenu.ContextCommand.label)
        pub label: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgShowBrowserContextMenu.ContextCommand.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ContextCommand {
        fn default() -> &'a ContextCommand {
            <ContextCommand as ::protobuf::Message>::default_instance()
        }
    }

    impl ContextCommand {
        pub fn new() -> ContextCommand {
            ::std::default::Default::default()
        }

        // optional int32 id = 1;

        pub fn id(&self) -> i32 {
            self.id.unwrap_or(0)
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: i32) {
            self.id = ::std::option::Option::Some(v);
        }

        // optional string label = 2;

        pub fn label(&self) -> &str {
            match self.label.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_label(&mut self) {
            self.label = ::std::option::Option::None;
        }

        pub fn has_label(&self) -> bool {
            self.label.is_some()
        }

        // Param is passed by value, moved
        pub fn set_label(&mut self, v: ::std::string::String) {
            self.label = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_label(&mut self) -> &mut ::std::string::String {
            if self.label.is_none() {
                self.label = ::std::option::Option::Some(::std::string::String::new());
            }
            self.label.as_mut().unwrap()
        }

        // Take field
        pub fn take_label(&mut self) -> ::std::string::String {
            self.label.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "id",
                |m: &ContextCommand| { &m.id },
                |m: &mut ContextCommand| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "label",
                |m: &ContextCommand| { &m.label },
                |m: &mut ContextCommand| { &mut m.label },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ContextCommand>(
                "CMsgShowBrowserContextMenu.ContextCommand",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ContextCommand {
        const NAME: &'static str = "ContextCommand";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.label = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.id {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.label.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.label.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ContextCommand {
            ContextCommand::new()
        }

        fn clear(&mut self) {
            self.id = ::std::option::Option::None;
            self.label = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ContextCommand {
            static instance: ContextCommand = ContextCommand {
                id: ::std::option::Option::None,
                label: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ContextCommand {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgShowBrowserContextMenu.ContextCommand").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ContextCommand {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ContextCommand {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgHandleContextMenuCommand)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHandleContextMenuCommand {
    // message fields
    // @@protoc_insertion_point(field:CMsgHandleContextMenuCommand.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHandleContextMenuCommand.command_id)
    pub command_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgHandleContextMenuCommand.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHandleContextMenuCommand {
    fn default() -> &'a CMsgHandleContextMenuCommand {
        <CMsgHandleContextMenuCommand as ::protobuf::Message>::default_instance()
    }
}

impl CMsgHandleContextMenuCommand {
    pub fn new() -> CMsgHandleContextMenuCommand {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional int32 command_id = 2;

    pub fn command_id(&self) -> i32 {
        self.command_id.unwrap_or(0)
    }

    pub fn clear_command_id(&mut self) {
        self.command_id = ::std::option::Option::None;
    }

    pub fn has_command_id(&self) -> bool {
        self.command_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command_id(&mut self, v: i32) {
        self.command_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgHandleContextMenuCommand| { &m.browser_handle },
            |m: &mut CMsgHandleContextMenuCommand| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "command_id",
            |m: &CMsgHandleContextMenuCommand| { &m.command_id },
            |m: &mut CMsgHandleContextMenuCommand| { &mut m.command_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgHandleContextMenuCommand>(
            "CMsgHandleContextMenuCommand",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgHandleContextMenuCommand {
    const NAME: &'static str = "CMsgHandleContextMenuCommand";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.command_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.command_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.command_id {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHandleContextMenuCommand {
        CMsgHandleContextMenuCommand::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.command_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHandleContextMenuCommand {
        static instance: CMsgHandleContextMenuCommand = CMsgHandleContextMenuCommand {
            browser_handle: ::std::option::Option::None,
            command_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgHandleContextMenuCommand {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgHandleContextMenuCommand").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgHandleContextMenuCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgHandleContextMenuCommand {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgImeSetComposition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgImeSetComposition {
    // message fields
    // @@protoc_insertion_point(field:CMsgImeSetComposition.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgImeSetComposition.text)
    pub text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgImeSetComposition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgImeSetComposition {
    fn default() -> &'a CMsgImeSetComposition {
        <CMsgImeSetComposition as ::protobuf::Message>::default_instance()
    }
}

impl CMsgImeSetComposition {
    pub fn new() -> CMsgImeSetComposition {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgImeSetComposition| { &m.browser_handle },
            |m: &mut CMsgImeSetComposition| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &CMsgImeSetComposition| { &m.text },
            |m: &mut CMsgImeSetComposition| { &mut m.text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgImeSetComposition>(
            "CMsgImeSetComposition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgImeSetComposition {
    const NAME: &'static str = "CMsgImeSetComposition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgImeSetComposition {
        CMsgImeSetComposition::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgImeSetComposition {
        static instance: CMsgImeSetComposition = CMsgImeSetComposition {
            browser_handle: ::std::option::Option::None,
            text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgImeSetComposition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgImeSetComposition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgImeSetComposition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgImeSetComposition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgImeCommitText)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgImeCommitText {
    // message fields
    // @@protoc_insertion_point(field:CMsgImeCommitText.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgImeCommitText.text)
    pub text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgImeCommitText.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgImeCommitText {
    fn default() -> &'a CMsgImeCommitText {
        <CMsgImeCommitText as ::protobuf::Message>::default_instance()
    }
}

impl CMsgImeCommitText {
    pub fn new() -> CMsgImeCommitText {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgImeCommitText| { &m.browser_handle },
            |m: &mut CMsgImeCommitText| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &CMsgImeCommitText| { &m.text },
            |m: &mut CMsgImeCommitText| { &mut m.text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgImeCommitText>(
            "CMsgImeCommitText",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgImeCommitText {
    const NAME: &'static str = "CMsgImeCommitText";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgImeCommitText {
        CMsgImeCommitText::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgImeCommitText {
        static instance: CMsgImeCommitText = CMsgImeCommitText {
            browser_handle: ::std::option::Option::None,
            text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgImeCommitText {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgImeCommitText").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgImeCommitText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgImeCommitText {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgImeCancelComposition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgImeCancelComposition {
    // message fields
    // @@protoc_insertion_point(field:CMsgImeCancelComposition.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgImeCancelComposition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgImeCancelComposition {
    fn default() -> &'a CMsgImeCancelComposition {
        <CMsgImeCancelComposition as ::protobuf::Message>::default_instance()
    }
}

impl CMsgImeCancelComposition {
    pub fn new() -> CMsgImeCancelComposition {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgImeCancelComposition| { &m.browser_handle },
            |m: &mut CMsgImeCancelComposition| { &mut m.browser_handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgImeCancelComposition>(
            "CMsgImeCancelComposition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgImeCancelComposition {
    const NAME: &'static str = "CMsgImeCancelComposition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgImeCancelComposition {
        CMsgImeCancelComposition::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgImeCancelComposition {
        static instance: CMsgImeCancelComposition = CMsgImeCancelComposition {
            browser_handle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgImeCancelComposition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgImeCancelComposition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgImeCancelComposition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgImeCancelComposition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgImeCompositionRangeChanged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgImeCompositionRangeChanged {
    // message fields
    // @@protoc_insertion_point(field:CMsgImeCompositionRangeChanged.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgImeCompositionRangeChanged.x)
    pub x: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgImeCompositionRangeChanged.y)
    pub y: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgImeCompositionRangeChanged.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgImeCompositionRangeChanged {
    fn default() -> &'a CMsgImeCompositionRangeChanged {
        <CMsgImeCompositionRangeChanged as ::protobuf::Message>::default_instance()
    }
}

impl CMsgImeCompositionRangeChanged {
    pub fn new() -> CMsgImeCompositionRangeChanged {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 x = 2;

    pub fn x(&self) -> u32 {
        self.x.unwrap_or(0)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: u32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional uint32 y = 3;

    pub fn y(&self) -> u32 {
        self.y.unwrap_or(0)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: u32) {
        self.y = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgImeCompositionRangeChanged| { &m.browser_handle },
            |m: &mut CMsgImeCompositionRangeChanged| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &CMsgImeCompositionRangeChanged| { &m.x },
            |m: &mut CMsgImeCompositionRangeChanged| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &CMsgImeCompositionRangeChanged| { &m.y },
            |m: &mut CMsgImeCompositionRangeChanged| { &mut m.y },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgImeCompositionRangeChanged>(
            "CMsgImeCompositionRangeChanged",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgImeCompositionRangeChanged {
    const NAME: &'static str = "CMsgImeCompositionRangeChanged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.x = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.y = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgImeCompositionRangeChanged {
        CMsgImeCompositionRangeChanged::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgImeCompositionRangeChanged {
        static instance: CMsgImeCompositionRangeChanged = CMsgImeCompositionRangeChanged {
            browser_handle: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgImeCompositionRangeChanged {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgImeCompositionRangeChanged").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgImeCompositionRangeChanged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgImeCompositionRangeChanged {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgInspectElement)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgInspectElement {
    // message fields
    // @@protoc_insertion_point(field:CMsgInspectElement.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgInspectElement.x)
    pub x: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgInspectElement.y)
    pub y: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgInspectElement.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgInspectElement {
    fn default() -> &'a CMsgInspectElement {
        <CMsgInspectElement as ::protobuf::Message>::default_instance()
    }
}

impl CMsgInspectElement {
    pub fn new() -> CMsgInspectElement {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 x = 2;

    pub fn x(&self) -> u32 {
        self.x.unwrap_or(0)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: u32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional uint32 y = 3;

    pub fn y(&self) -> u32 {
        self.y.unwrap_or(0)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: u32) {
        self.y = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgInspectElement| { &m.browser_handle },
            |m: &mut CMsgInspectElement| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &CMsgInspectElement| { &m.x },
            |m: &mut CMsgInspectElement| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &CMsgInspectElement| { &m.y },
            |m: &mut CMsgInspectElement| { &mut m.y },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgInspectElement>(
            "CMsgInspectElement",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgInspectElement {
    const NAME: &'static str = "CMsgInspectElement";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.x = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.y = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgInspectElement {
        CMsgInspectElement::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgInspectElement {
        static instance: CMsgInspectElement = CMsgInspectElement {
            browser_handle: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgInspectElement {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgInspectElement").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgInspectElement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgInspectElement {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgDisableF5)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDisableF5 {
    // message fields
    // @@protoc_insertion_point(field:CMsgDisableF5.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDisableF5.disable)
    pub disable: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDisableF5.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDisableF5 {
    fn default() -> &'a CMsgDisableF5 {
        <CMsgDisableF5 as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDisableF5 {
    pub fn new() -> CMsgDisableF5 {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool disable = 2;

    pub fn disable(&self) -> bool {
        self.disable.unwrap_or(false)
    }

    pub fn clear_disable(&mut self) {
        self.disable = ::std::option::Option::None;
    }

    pub fn has_disable(&self) -> bool {
        self.disable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable(&mut self, v: bool) {
        self.disable = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgDisableF5| { &m.browser_handle },
            |m: &mut CMsgDisableF5| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "disable",
            |m: &CMsgDisableF5| { &m.disable },
            |m: &mut CMsgDisableF5| { &mut m.disable },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDisableF5>(
            "CMsgDisableF5",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDisableF5 {
    const NAME: &'static str = "CMsgDisableF5";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.disable = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.disable {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.disable {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDisableF5 {
        CMsgDisableF5::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.disable = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDisableF5 {
        static instance: CMsgDisableF5 = CMsgDisableF5 {
            browser_handle: ::std::option::Option::None,
            disable: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDisableF5 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDisableF5").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDisableF5 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDisableF5 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgStartDownload)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgStartDownload {
    // message fields
    // @@protoc_insertion_point(field:CMsgStartDownload.browser_handle)
    pub browser_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgStartDownload.url)
    pub url: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgStartDownload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStartDownload {
    fn default() -> &'a CMsgStartDownload {
        <CMsgStartDownload as ::protobuf::Message>::default_instance()
    }
}

impl CMsgStartDownload {
    pub fn new() -> CMsgStartDownload {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;

    pub fn browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }

    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "browser_handle",
            |m: &CMsgStartDownload| { &m.browser_handle },
            |m: &mut CMsgStartDownload| { &mut m.browser_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgStartDownload| { &m.url },
            |m: &mut CMsgStartDownload| { &mut m.url },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgStartDownload>(
            "CMsgStartDownload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgStartDownload {
    const NAME: &'static str = "CMsgStartDownload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.browser_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStartDownload {
        CMsgStartDownload::new()
    }

    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStartDownload {
        static instance: CMsgStartDownload = CMsgStartDownload {
            browser_handle: ::std::option::Option::None,
            url: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgStartDownload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgStartDownload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgStartDownload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgStartDownload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EJSRegisterMethodType)
pub enum EJSRegisterMethodType {
    // @@protoc_insertion_point(enum_value:EJSRegisterMethodType.k_EJSRegisterMethodType_Invalid)
    k_EJSRegisterMethodType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EJSRegisterMethodType.k_EJSRegisterMethodType_Function)
    k_EJSRegisterMethodType_Function = 1,
    // @@protoc_insertion_point(enum_value:EJSRegisterMethodType.k_EJSRegisterMethodType_Callback)
    k_EJSRegisterMethodType_Callback = 2,
    // @@protoc_insertion_point(enum_value:EJSRegisterMethodType.k_EJSRegisterMethodType_Promise)
    k_EJSRegisterMethodType_Promise = 3,
}

impl ::protobuf::Enum for EJSRegisterMethodType {
    const NAME: &'static str = "EJSRegisterMethodType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EJSRegisterMethodType> {
        match value {
            0 => ::std::option::Option::Some(EJSRegisterMethodType::k_EJSRegisterMethodType_Invalid),
            1 => ::std::option::Option::Some(EJSRegisterMethodType::k_EJSRegisterMethodType_Function),
            2 => ::std::option::Option::Some(EJSRegisterMethodType::k_EJSRegisterMethodType_Callback),
            3 => ::std::option::Option::Some(EJSRegisterMethodType::k_EJSRegisterMethodType_Promise),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EJSRegisterMethodType> {
        match str {
            "k_EJSRegisterMethodType_Invalid" => ::std::option::Option::Some(EJSRegisterMethodType::k_EJSRegisterMethodType_Invalid),
            "k_EJSRegisterMethodType_Function" => ::std::option::Option::Some(EJSRegisterMethodType::k_EJSRegisterMethodType_Function),
            "k_EJSRegisterMethodType_Callback" => ::std::option::Option::Some(EJSRegisterMethodType::k_EJSRegisterMethodType_Callback),
            "k_EJSRegisterMethodType_Promise" => ::std::option::Option::Some(EJSRegisterMethodType::k_EJSRegisterMethodType_Promise),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EJSRegisterMethodType] = &[
        EJSRegisterMethodType::k_EJSRegisterMethodType_Invalid,
        EJSRegisterMethodType::k_EJSRegisterMethodType_Function,
        EJSRegisterMethodType::k_EJSRegisterMethodType_Callback,
        EJSRegisterMethodType::k_EJSRegisterMethodType_Promise,
    ];
}

impl ::protobuf::EnumFull for EJSRegisterMethodType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EJSRegisterMethodType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EJSRegisterMethodType {
    fn default() -> Self {
        EJSRegisterMethodType::k_EJSRegisterMethodType_Invalid
    }
}

impl EJSRegisterMethodType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EJSRegisterMethodType>("EJSRegisterMethodType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x12htmlmessages.proto\"\x90\x01\n\tCMsgKeyUp\x12%\n\x0ebrowser_handle\
    \x18\x01\x20\x01(\rR\rbrowserHandle\x12\x18\n\x07keyCode\x18\x02\x20\x01\
    (\rR\x07keyCode\x12\x1c\n\tmodifiers\x18\x03\x20\x01(\rR\tmodifiers\x12$\
    \n\rnativeKeyCode\x18\x04\x20\x01(\rR\rnativeKeyCode\"\xb6\x01\n\x0bCMsg\
    KeyDown\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\
    \x18\n\x07keyCode\x18\x02\x20\x01(\rR\x07keyCode\x12\x1c\n\tmodifiers\
    \x18\x03\x20\x01(\rR\tmodifiers\x12\"\n\ris_system_key\x18\x04\x20\x01(\
    \x08R\x0bisSystemKey\x12$\n\rnativeKeyCode\x18\x05\x20\x01(\rR\rnativeKe\
    yCode\"\xac\x01\n\x0bCMsgKeyChar\x12%\n\x0ebrowser_handle\x18\x01\x20\
    \x01(\rR\rbrowserHandle\x12\x18\n\x07unichar\x18\x02\x20\x01(\rR\x07unic\
    har\x12\x1c\n\tmodifiers\x18\x03\x20\x01(\rR\tmodifiers\x12\x18\n\x07key\
    Code\x18\x04\x20\x01(\rR\x07keyCode\x12$\n\rnativeKeyCode\x18\x05\x20\
    \x01(\rR\rnativeKeyCode\"w\n\rCMsgMouseDown\x12%\n\x0ebrowser_handle\x18\
    \x01\x20\x01(\rR\rbrowserHandle\x12!\n\x0cmouse_button\x18\x02\x20\x01(\
    \rR\x0bmouseButton\x12\x1c\n\tmodifiers\x18\x03\x20\x01(\rR\tmodifiers\"\
    \xb3\x01\n\x0bCMsgMouseUp\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\r\
    browserHandle\x12!\n\x0cmouse_button\x18\x02\x20\x01(\rR\x0bmouseButton\
    \x12\x1c\n\tmodifiers\x18\x03\x20\x01(\rR\tmodifiers\x12\x20\n\x0cis_off\
    _panel\x18\x04\x20\x01(\x08R\nisOffPanel\x12\x0c\n\x01x\x18\x05\x20\x01(\
    \x05R\x01x\x12\x0c\n\x01y\x18\x06\x20\x01(\x05R\x01y\"{\n\x11CMsgMouseDb\
    lClick\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12!\
    \n\x0cmouse_button\x18\x02\x20\x01(\rR\x0bmouseButton\x12\x1c\n\tmodifie\
    rs\x18\x03\x20\x01(\rR\tmodifiers\"\x85\x01\n\x0eCMsgMouseWheel\x12%\n\
    \x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x16\n\x06delta\
    x\x18\x02\x20\x01(\x05R\x06deltax\x12\x16\n\x06deltay\x18\x03\x20\x01(\
    \x05R\x06deltay\x12\x1c\n\tmodifiers\x18\x04\x20\x01(\rR\tmodifiers\"p\n\
    \rCMsgMouseMove\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHan\
    dle\x12\x0c\n\x01x\x18\x02\x20\x01(\x05R\x01x\x12\x0c\n\x01y\x18\x03\x20\
    \x01(\x05R\x01y\x12\x1c\n\tmodifiers\x18\x04\x20\x01(\rR\tmodifiers\"7\n\
    \x0eCMsgMouseLeave\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowser\
    Handle\"\xa2\x05\n\x11CMsgBrowserCreate\x12\x1d\n\nrequest_id\x18\x01\
    \x20\x01(\rR\trequestId\x12\x1c\n\tuseragent\x18\x03\x20\x01(\tR\tuserag\
    ent\x12\x19\n\x08user_css\x18\x05\x20\x01(\tR\x07userCss\x12)\n\x10nativ\
    e_dropdowns\x18\x06\x20\x01(\x08R\x0fnativeDropdowns\x12\x1f\n\x0bdpi_sc\
    aling\x18\x07\x20\x01(\x02R\ndpiScaling\x12\"\n\toffscreen\x18\x08\x20\
    \x01(\x08:\x04trueR\toffscreen\x12&\n\rinitial_width\x18\t\x20\x01(\r:\
    \x010R\x0cinitialWidth\x12(\n\x0einitial_height\x18\n\x20\x01(\r:\x010R\
    \rinitialHeight\x12\x1f\n\x0bwindow_icon\x18\x0b\x20\x01(\tR\nwindowIcon\
    \x12%\n\nborderless\x18\x0c\x20\x01(\x08:\x05falseR\nborderless\x12#\n\r\
    vroverlay_key\x18\r\x20\x01(\tR\x0cvroverlayKey\x12$\n\x0cbrowser_type\
    \x18\x0e\x20\x01(\r:\x010R\x0bbrowserType\x12,\n\x0binitial_top\x18\x0f\
    \x20\x01(\x05:\x0b-2147483648R\ninitialTop\x12.\n\x0cinitial_left\x18\
    \x10\x20\x01(\x05:\x0b-2147483648R\x0binitialLeft\x12@\n\x19only_allow_t\
    rusted_popups\x18\x11\x20\x01(\x08:\x05falseR\x16onlyAllowTrustedPopups\
    \x12\x1f\n\x0binitial_url\x18\x12\x20\x01(\tR\ninitialUrl\x12\x1f\n\x0bh\
    wnd_parent\x18\x13\x20\x01(\x06R\nhwndParent\"a\n\x19CMsgBrowserCreateRe\
    sponse\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\
    \x1d\n\nrequest_id\x18\x02\x20\x01(\rR\trequestId\":\n\x11CMsgBrowserRem\
    ove\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"\xe4\
    \x02\n\x1eCMsgSetLocalFileRequestMapping\x12%\n\x0ebrowser_handle\x18\
    \x01\x20\x01(\rR\rbrowserHandle\x12\x1f\n\x0brequest_url\x18\x02\x20\x01\
    (\tR\nrequestUrl\x12,\n\x12default_local_path\x18\x03\x20\x01(\tR\x10def\
    aultLocalPath\x12G\n\x06routes\x18\x04\x20\x03(\x0b2/.CMsgSetLocalFileRe\
    questMapping.AdditionalRouteR\x06routes\x1a\x82\x01\n\x0fAdditionalRoute\
    \x12!\n\x0crelative_url\x18\x01\x20\x01(\tR\x0brelativeUrl\x12\x1d\n\nlo\
    cal_path\x18\x02\x20\x01(\tR\tlocalPath\x12-\n\x12allowed_extensions\x18\
    \x03\x20\x01(\tR\x11allowedExtensions\"\x94\x02\n\x17CMsgBrowserErrorStr\
    ings\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x14\
    \n\x05title\x18\x02\x20\x01(\tR\x05title\x12\x16\n\x06header\x18\x03\x20\
    \x01(\tR\x06header\x12\x1d\n\ncache_miss\x18\x04\x20\x01(\tR\tcacheMiss\
    \x12\x17\n\x07bad_url\x18\x05\x20\x01(\tR\x06badUrl\x12-\n\x12connection\
    _problem\x18\x06\x20\x01(\tR\x11connectionProblem\x12#\n\rproxy_problem\
    \x18\x07\x20\x01(\tR\x0cproxyProblem\x12\x18\n\x07unknown\x18\x08\x20\
    \x01(\tR\x07unknown\"f\n\x0fCMsgBrowserSize\x12%\n\x0ebrowser_handle\x18\
    \x01\x20\x01(\rR\rbrowserHandle\x12\x14\n\x05width\x18\x02\x20\x01(\rR\
    \x05width\x12\x16\n\x06height\x18\x03\x20\x01(\rR\x06height\"l\n\x15CMsg\
    BrowserSetMinSize\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserH\
    andle\x12\x14\n\x05width\x18\x02\x20\x01(\rR\x05width\x12\x16\n\x06heigh\
    t\x18\x03\x20\x01(\rR\x06height\"\x8a\x01\n\x13CMsgBrowserPosition\x12%\
    \n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x0c\n\x01x\
    \x18\x02\x20\x01(\x05R\x01x\x12\x0c\n\x01y\x18\x03\x20\x01(\x05R\x01y\
    \x12\x17\n\x07x_local\x18\x04\x20\x01(\x05R\x06xLocal\x12\x17\n\x07y_loc\
    al\x18\x05\x20\x01(\x05R\x06yLocal\"\x85\x01\n\x12CMsgBrowserResized\x12\
    %\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x0c\n\x01x\
    \x18\x02\x20\x01(\x05R\x01x\x12\x0c\n\x01y\x18\x03\x20\x01(\x05R\x01y\
    \x12\x14\n\x05width\x18\x04\x20\x01(\rR\x05width\x12\x16\n\x06height\x18\
    \x05\x20\x01(\rR\x06height\"z\n\x0bCMsgPostURL\x12%\n\x0ebrowser_handle\
    \x18\x01\x20\x01(\rR\rbrowserHandle\x12\x10\n\x03url\x18\x02\x20\x01(\tR\
    \x03url\x12\x12\n\x04post\x18\x03\x20\x01(\tR\x04post\x12\x1e\n\npageser\
    ial\x18\x04\x20\x01(\rR\npageserial\"^\n\rCMsgAddHeader\x12%\n\x0ebrowse\
    r_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x10\n\x03key\x18\x02\x20\
    \x01(\tR\x03key\x12\x14\n\x05value\x18\x03\x20\x01(\tR\x05value\"5\n\x0c\
    CMsgStopLoad\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\
    \"3\n\nCMsgReload\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserH\
    andle\"6\n\rCMsgGoForward\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\r\
    browserHandle\"3\n\nCMsgGoBack\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\
    \rR\rbrowserHandle\"N\n\rCMsgWasHidden\x12%\n\x0ebrowser_handle\x18\x01\
    \x20\x01(\rR\rbrowserHandle\x12\x16\n\x06hidden\x18\x02\x20\x01(\x08R\
    \x06hidden\"9\n\x10CMsgClearHistory\x12%\n\x0ebrowser_handle\x18\x01\x20\
    \x01(\rR\rbrowserHandle\"A\n\x18CMsgClearAllBrowsingData\x12%\n\x0ebrows\
    er_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"1\n\x08CMsgCopy\x12%\n\x0e\
    browser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"2\n\tCMsgPaste\x12%\n\
    \x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"V\n\x15CMsgExecut\
    eJavaScript\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\
    \x12\x16\n\x06script\x18\x02\x20\x01(\tR\x06script\"K\n\x0cCMsgSetFocus\
    \x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x14\n\
    \x05focus\x18\x02\x20\x01(\x08R\x05focus\"D\n\x1bCMsgHorizontalScrollBar\
    Size\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"\xce\
    \x01\n#CMsgHorizontalScrollBarSizeResponse\x12%\n\x0ebrowser_handle\x18\
    \x01\x20\x01(\rR\rbrowserHandle\x12\x1d\n\nscroll_max\x18\x06\x20\x01(\r\
    R\tscrollMax\x12\x16\n\x06scroll\x18\x07\x20\x01(\rR\x06scroll\x12\x12\n\
    \x04zoom\x18\x08\x20\x01(\x02R\x04zoom\x12\x18\n\x07visible\x18\t\x20\
    \x01(\x08R\x07visible\x12\x1b\n\tpage_size\x18\n\x20\x01(\rR\x08pageSize\
    \"B\n\x19CMsgVerticalScrollBarSize\x12%\n\x0ebrowser_handle\x18\x01\x20\
    \x01(\rR\rbrowserHandle\"\xcc\x01\n!CMsgVerticalScrollBarSizeResponse\
    \x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x1d\n\n\
    scroll_max\x18\x06\x20\x01(\rR\tscrollMax\x12\x16\n\x06scroll\x18\x07\
    \x20\x01(\rR\x06scroll\x12\x12\n\x04zoom\x18\x08\x20\x01(\x02R\x04zoom\
    \x12\x18\n\x07visible\x18\t\x20\x01(\x08R\x07visible\x12\x1b\n\tpage_siz\
    e\x18\n\x20\x01(\rR\x08pageSize\"~\n\x08CMsgFind\x12%\n\x0ebrowser_handl\
    e\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x12\n\x04find\x18\x02\x20\x01(\
    \tR\x04find\x12\x16\n\x06infind\x18\x03\x20\x01(\x08R\x06infind\x12\x1f\
    \n\x07reverse\x18\x04\x20\x01(\x08:\x05falseR\x07reverse\"5\n\x0cCMsgSto\
    pFind\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"X\n\
    \x17CMsgSetHorizontalScroll\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\
    \rbrowserHandle\x12\x16\n\x06scroll\x18\x02\x20\x01(\rR\x06scroll\"V\n\
    \x15CMsgSetVerticalScroll\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\r\
    browserHandle\x12\x16\n\x06scroll\x18\x02\x20\x01(\rR\x06scroll\"M\n\x10\
    CMsgSetZoomLevel\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHa\
    ndle\x12\x12\n\x04zoom\x18\x02\x20\x01(\x01R\x04zoom\"7\n\x0eCMsgViewSou\
    rce\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"\x82\
    \x01\n\x10CMsgBrowserReady\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\
    \rbrowserHandle\x12$\n\x0evr_overlay_key\x18\x02\x20\x01(\tR\x0cvrOverla\
    yKey\x12!\n\x0chwnd_browser\x18\x03\x20\x01(\x06R\x0bhwndBrowser\"\xcd\
    \x01\n\x0eCMsgURLChanged\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rb\
    rowserHandle\x12\x10\n\x03url\x18\x02\x20\x01(\tR\x03url\x12\x1a\n\x08po\
    stData\x18\x03\x20\x01(\tR\x08postData\x12\x20\n\x0bbIsRedirect\x18\x04\
    \x20\x01(\x08R\x0bbIsRedirect\x12\x1c\n\tpagetitle\x18\x05\x20\x01(\tR\t\
    pagetitle\x12&\n\x0ebNewNavigation\x18\x06\x20\x01(\x08R\x0ebNewNavigati\
    on\"5\n\x0bCHTMLHeader\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value\"\x8e\x02\n\x15CHTMLPageSec\
    urityInfo\x12#\n\tbIsSecure\x18\x01\x20\x01(\x08:\x05falseR\tbIsSecure\
    \x12+\n\rbHasCertError\x18\x02\x20\x01(\x08:\x05falseR\rbHasCertError\
    \x12\x1e\n\nissuerName\x18\x03\x20\x01(\tR\nissuerName\x12\x1a\n\x08cert\
    Name\x18\x04\x20\x01(\tR\x08certName\x12!\n\ncertExpiry\x18\x05\x20\x01(\
    \x05:\x010R\ncertExpiry\x12\x1f\n\tnCertBits\x18\x06\x20\x01(\x05:\x010R\
    \tnCertBits\x12#\n\tbIsEVCert\x18\x07\x20\x01(\x08:\x05falseR\tbIsEVCert\
    \"l\n\x13CMsgFinishedRequest\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\r\
    R\rbrowserHandle\x12\x10\n\x03url\x18\x02\x20\x01(\tR\x03url\x12\x1c\n\t\
    pageTitle\x18\x03\x20\x01(\tR\tpageTitle\"\x92\x01\n\x11CMsgLoadedReques\
    t\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x10\n\
    \x03url\x18\x02\x20\x01(\tR\x03url\x12\x1c\n\tpageTitle\x18\x03\x20\x01(\
    \tR\tpageTitle\x12&\n\x07headers\x18\x05\x20\x03(\x0b2\x0c.CHTMLHeaderR\
    \x07headers\"\x88\x01\n\x10CMsgPageSecurity\x12%\n\x0ebrowser_handle\x18\
    \x01\x20\x01(\rR\rbrowserHandle\x12\x10\n\x03url\x18\x02\x20\x01(\tR\x03\
    url\x12;\n\rsecurity_info\x18\x03\x20\x01(\x0b2\x16.CHTMLPageSecurityInf\
    oR\x0csecurityInfo\"\xa1\x01\n\x10CMsgStartRequest\x12%\n\x0ebrowser_han\
    dle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x10\n\x03url\x18\x02\x20\x01(\
    \tR\x03url\x12\x16\n\x06target\x18\x03\x20\x01(\tR\x06target\x12\x1a\n\
    \x08postData\x18\x04\x20\x01(\tR\x08postData\x12\x20\n\x0bbIsRedirect\
    \x18\x05\x20\x01(\x08R\x0bbIsRedirect\"Y\n\x18CMsgStartRequestResponse\
    \x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x16\n\
    \x06bAllow\x18\x02\x20\x01(\x08R\x06bAllow\"6\n\rCMsgShowPopup\x12%\n\
    \x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"6\n\rCMsgHidePopu\
    p\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"z\n\rCMsg\
    SizePopup\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\
    \x12\x0c\n\x01x\x18\x02\x20\x01(\x05R\x01x\x12\x0c\n\x01y\x18\x03\x20\
    \x01(\x05R\x01y\x12\x12\n\x04wide\x18\x04\x20\x01(\rR\x04wide\x12\x12\n\
    \x04tall\x18\x05\x20\x01(\rR\x04tall\"k\n\x0eCMsgOpenNewTab\x12%\n\x0ebr\
    owser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x10\n\x03url\x18\x02\
    \x20\x01(\tR\x03url\x12\x20\n\x0bbForeground\x18\x03\x20\x01(\x08R\x0bbF\
    oreground\"\xf6\x01\n\x13CMsgPopupHTMLWindow\x12%\n\x0ebrowser_handle\
    \x18\x01\x20\x01(\rR\rbrowserHandle\x12\x10\n\x03url\x18\x02\x20\x01(\tR\
    \x03url\x12\x19\n\x01x\x18\x03\x20\x01(\x05:\x0b-2147483648R\x01x\x12\
    \x19\n\x01y\x18\x04\x20\x01(\x05:\x0b-2147483648R\x01y\x12\x12\n\x04wide\
    \x18\x05\x20\x01(\rR\x04wide\x12\x12\n\x04tall\x18\x06\x20\x01(\rR\x04ta\
    ll\x12\x1f\n\x0bpopup_index\x18\x07\x20\x01(\rR\npopupIndex\x12'\n\x0ftr\
    usted_creator\x18\x08\x20\x01(\x08R\x0etrustedCreator\"\\\n\x1bCMsgPopup\
    HTMLWindowResponse\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowser\
    Handle\x12\x16\n\x06bAllow\x18\x02\x20\x01(\x08R\x06bAllow\"O\n\x10CMsgS\
    etHTMLTitle\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\
    \x12\x14\n\x05title\x18\x02\x20\x01(\tR\x05title\"N\n\x13CMsgLoadingReso\
    urce\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x10\
    \n\x03url\x18\x02\x20\x01(\tR\x03url\"K\n\x0eCMsgStatusText\x12%\n\x0ebr\
    owser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x12\n\x04text\x18\
    \x02\x20\x01(\tR\x04text\"\xcf\x01\n\rCMsgSetCursor\x12%\n\x0ebrowser_ha\
    ndle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x16\n\x06cursor\x18\x02\x20\
    \x01(\rR\x06cursor\x12\x1f\n\x0bcustom_data\x18\x03\x20\x01(\x0cR\ncusto\
    mData\x12\x12\n\x04wide\x18\x04\x20\x01(\rR\x04wide\x12\x12\n\x04tall\
    \x18\x05\x20\x01(\rR\x04tall\x12\x1a\n\x08xhotspot\x18\x06\x20\x01(\rR\
    \x08xhotspot\x12\x1a\n\x08yhotspot\x18\x07\x20\x01(\rR\x08yhotspot\"\xaf\
    \x01\n\x12CMsgFileLoadDialog\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\r\
    R\rbrowserHandle\x12\x14\n\x05title\x18\x02\x20\x01(\tR\x05title\x12\x20\
    \n\x0binitialFile\x18\x03\x20\x01(\tR\x0binitialFile\x12!\n\x0caccept_ty\
    pes\x18\x04\x20\x03(\tR\x0bacceptTypes\x12\x17\n\x07is_save\x18\x05\x20\
    \x01(\x08R\x06isSave\"Y\n\x1aCMsgFileLoadDialogResponse\x12%\n\x0ebrowse\
    r_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x14\n\x05files\x18\x02\
    \x20\x03(\tR\x05files\"L\n\x0fCMsgShowToolTip\x12%\n\x0ebrowser_handle\
    \x18\x01\x20\x01(\rR\rbrowserHandle\x12\x12\n\x04text\x18\x02\x20\x01(\t\
    R\x04text\"N\n\x11CMsgUpdateToolTip\x12%\n\x0ebrowser_handle\x18\x01\x20\
    \x01(\rR\rbrowserHandle\x12\x12\n\x04text\x18\x02\x20\x01(\tR\x04text\"8\
    \n\x0fCMsgHideToolTip\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrow\
    serHandle\"v\n\x11CMsgSearchResults\x12%\n\x0ebrowser_handle\x18\x01\x20\
    \x01(\rR\rbrowserHandle\x12\x20\n\x0bactiveMatch\x18\x02\x20\x01(\x05R\
    \x0bactiveMatch\x12\x18\n\x07results\x18\x03\x20\x01(\x05R\x07results\"2\
    \n\tCMsgClose\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandl\
    e\"\xc6\x01\n\x19CMsgSetSharedPaintBuffers\x12%\n\x0ebrowser_handle\x18\
    \x01\x20\x01(\rR\rbrowserHandle\x12\x12\n\x04wide\x18\x02\x20\x01(\rR\
    \x04wide\x12\x12\n\x04tall\x18\x03\x20\x01(\rR\x04tall\x12\x1d\n\nsource\
    _pid\x18\x04\x20\x01(\x04R\tsourcePid\x12#\n\rsource_handle\x18\x05\x20\
    \x01(\x04R\x0csourceHandle\x12\x16\n\x06handle\x18\x06\x20\x01(\x04R\x06\
    handle\"B\n\x19CMsgAckSharedPaintBuffers\x12%\n\x0ebrowser_handle\x18\
    \x01\x20\x01(\rR\rbrowserHandle\"\x9e\x02\n\x0eCMsgNeedsPaint\x12%\n\x0e\
    browser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x18\n\x07scrollx\
    \x18\n\x20\x01(\rR\x07scrollx\x12\x18\n\x07scrolly\x18\x0b\x20\x01(\rR\
    \x07scrolly\x12\x1c\n\tpagescale\x18\x0c\x20\x01(\x02R\tpagescale\x12\
    \x1e\n\npageserial\x18\x0f\x20\x01(\rR\npageserial\x12\x20\n\x0cavg_fram\
    e_ms\x18\x14\x20\x01(\rR\navgFrameMs\x12-\n\x13stddev_sum_frame_ms\x18\
    \x15\x20\x01(\x02R\x10stddevSumFrameMs\x12\"\n\rlong_frame_ms\x18\x16\
    \x20\x01(\rR\x0blongFrameMs\"\x86\x02\n\x13CMsgComboNeedsPaint\x12%\n\
    \x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x12\n\x04rgba\
    \x18\x02\x20\x01(\x04R\x04rgba\x12&\n\rcombobox_wide\x18\x03\x20\x01(\r:\
    \x010R\x0ccomboboxWide\x12&\n\rcombobox_tall\x18\x04\x20\x01(\r:\x010R\
    \x0ccomboboxTall\x123\n\x14shared_memory_handle\x18\x05\x20\x01(\x04:\
    \x010R\x12sharedMemoryHandle\x12/\n\x12shared_memory_size\x18\x07\x20\
    \x01(\x04:\x010R\x10sharedMemorySize\"\x87\x02\n\x1bCMsgNeedsSharedTextu\
    rePaint\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12!\
    \n\x0cshare_handle\x18\x02\x20\x01(\rR\x0bshareHandle\x12\x14\n\x05width\
    \x18\x03\x20\x01(\rR\x05width\x12\x16\n\x06height\x18\x04\x20\x01(\rR\
    \x06height\x12\x18\n\x07scrollx\x18\x05\x20\x01(\rR\x07scrollx\x12\x18\n\
    \x07scrolly\x18\x06\x20\x01(\rR\x07scrolly\x12\x1c\n\tpagescale\x18\x07\
    \x20\x01(\x02R\tpagescale\x12\x1e\n\npageserial\x18\x08\x20\x01(\rR\npag\
    eserial\"\xe4\x01\n\x1bCMsgGameOverlayTexturePaint\x12%\n\x0ebrowser_han\
    dle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x14\n\x05width\x18\x03\x20\
    \x01(\rR\x05width\x12\x16\n\x06height\x18\x04\x20\x01(\rR\x06height\x12\
    \x18\n\x07scrollx\x18\x05\x20\x01(\rR\x07scrollx\x12\x18\n\x07scrolly\
    \x18\x06\x20\x01(\rR\x07scrolly\x12\x1c\n\tpagescale\x18\x07\x20\x01(\
    \x02R\tpagescale\x12\x1e\n\npageserial\x18\x08\x20\x01(\rR\npageserial\"\
    4\n\x0bCMsgGetZoom\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowser\
    Handle\"P\n\x13CMsgGetZoomResponse\x12%\n\x0ebrowser_handle\x18\x01\x20\
    \x01(\rR\rbrowserHandle\x12\x12\n\x04zoom\x18\x02\x20\x01(\x02R\x04zoom\
    \"W\n\x12CMsgLinkAtPosition\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\
    \rbrowserHandle\x12\x0c\n\x01x\x18\x02\x20\x01(\rR\x01x\x12\x0c\n\x01y\
    \x18\x03\x20\x01(\rR\x01y\"\xa7\x01\n\x1aCMsgLinkAtPositionResponse\x12%\
    \n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x0c\n\x01x\
    \x18\x02\x20\x01(\rR\x01x\x12\x0c\n\x01y\x18\x03\x20\x01(\rR\x01y\x12\
    \x10\n\x03url\x18\x04\x20\x01(\tR\x03url\x12\x1c\n\tblivelink\x18\x05\
    \x20\x01(\x08R\tblivelink\x12\x16\n\x06binput\x18\x06\x20\x01(\x08R\x06b\
    input\"`\n\x1bCMsgZoomToElementAtPosition\x12%\n\x0ebrowser_handle\x18\
    \x01\x20\x01(\rR\rbrowserHandle\x12\x0c\n\x01x\x18\x02\x20\x01(\rR\x01x\
    \x12\x0c\n\x01y\x18\x03\x20\x01(\rR\x01y\"~\n#CMsgZoomToElementAtPositio\
    nResponse\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\
    \x12\x14\n\x05scale\x18\x02\x20\x01(\x02R\x05scale\x12\x1a\n\x08duration\
    \x18\x03\x20\x01(\x02R\x08duration\"o\n\x14CMsgScalePageToValue\x12%\n\
    \x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x14\n\x05scale\
    \x18\x02\x20\x01(\x02R\x05scale\x12\x0c\n\x01x\x18\x03\x20\x01(\x02R\x01\
    x\x12\x0c\n\x01y\x18\x04\x20\x01(\x02R\x01y\"}\n\x1bCMsgForcePopupsToDir\
    ectHWND\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x127\
    \n\x18force_direct_hwnd_popups\x18\x02\x20\x01(\x08R\x15forceDirectHwndP\
    opups\"Y\n\x1cCMsgScalePageToValueResponse\x12%\n\x0ebrowser_handle\x18\
    \x01\x20\x01(\rR\rbrowserHandle\x12\x12\n\x04zoom\x18\x02\x20\x01(\x02R\
    \x04zoom\"\x97\x01\n\x12CMsgSavePageToJPEG\x12%\n\x0ebrowser_handle\x18\
    \x01\x20\x01(\rR\rbrowserHandle\x12\x10\n\x03url\x18\x02\x20\x01(\tR\x03\
    url\x12\x1a\n\x08filename\x18\x03\x20\x01(\tR\x08filename\x12\x14\n\x05w\
    idth\x18\x04\x20\x01(\rR\x05width\x12\x16\n\x06height\x18\x05\x20\x01(\r\
    R\x06height\"q\n\x1aCMsgSavePageToJPEGResponse\x12%\n\x0ebrowser_handle\
    \x18\x01\x20\x01(\rR\rbrowserHandle\x12\x10\n\x03url\x18\x02\x20\x01(\tR\
    \x03url\x12\x1a\n\x08filename\x18\x03\x20\x01(\tR\x08filename\"N\n\x0bCM\
    sgJSAlert\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\
    \x12\x18\n\x07message\x18\x02\x20\x01(\tR\x07message\"P\n\rCMsgJSConfirm\
    \x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x18\n\
    \x07message\x18\x02\x20\x01(\tR\x07message\"U\n\x14CMsgJSDialogResponse\
    \x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x16\n\
    \x06result\x18\x02\x20\x01(\x08R\x06result\"z\n\x17CMsgCanGoBackAndForwa\
    rd\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x18\n\
    \x07bgoback\x18\x02\x20\x01(\x08R\x07bgoback\x12\x1e\n\nbgoforward\x18\
    \x03\x20\x01(\x08R\nbgoforward\"g\n\x10CMsgOpenSteamURL\x12%\n\x0ebrowse\
    r_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x10\n\x03url\x18\x02\x20\
    \x01(\tR\x03url\x12\x1a\n\x08referrer\x18\x03\x20\x01(\tR\x08referrer\"\
    \xad\x01\n\rCMsgSetCookie\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\x12\x12\n\x04path\x18\
    \x03\x20\x01(\tR\x04path\x12\x12\n\x04host\x18\x04\x20\x01(\tR\x04host\
    \x12\x18\n\x07expires\x18\x05\x20\x01(\rR\x07expires\x12\x16\n\x06secure\
    \x18\x06\x20\x01(\x08R\x06secure\x12\x1a\n\x08httponly\x18\x07\x20\x01(\
    \x08R\x08httponly\"k\n\x16CMsgSetTargetFrameRate\x12%\n\x0ebrowser_handl\
    e\x18\x01\x20\x01(\rR\rbrowserHandle\x12*\n\x10nTargetFrameRate\x18\x02\
    \x20\x01(\rR\x10nTargetFrameRate\"9\n\x10CMsgPauseRepaint\x12%\n\x0ebrow\
    ser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"8\n\x0fCMsgFullRepaint\
    \x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\">\n\x15CMs\
    gRequestFullScreen\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowser\
    Handle\";\n\x12CMsgExitFullScreen\x12%\n\x0ebrowser_handle\x18\x01\x20\
    \x01(\rR\rbrowserHandle\"C\n\x1aCMsgToggleFindInPageDialog\x12%\n\x0ebro\
    wser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"?\n\x16CMsgSetPIDShuttin\
    gDown\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"H\n\
    \x1fCMsgDisableBackgroundThrottling\x12%\n\x0ebrowser_handle\x18\x01\x20\
    \x01(\rR\rbrowserHandle\"?\n\x16CMsgAckPIDShuttingDown\x12%\n\x0ebrowser\
    _handle\x18\x01\x20\x01(\rR\rbrowserHandle\"O\n\x14CMsgGetCookiesForURL\
    \x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x10\n\
    \x03url\x18\x02\x20\x01(\tR\x03url\"_\n\x07CCookie\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\
    \x12\x16\n\x06domain\x18\x03\x20\x01(\tR\x06domain\x12\x12\n\x04path\x18\
    \x04\x20\x01(\tR\x04path\"{\n\x1cCMsgGetCookiesForURLResponse\x12%\n\x0e\
    browser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x10\n\x03url\x18\
    \x02\x20\x01(\tR\x03url\x12\"\n\x07cookies\x18\x03\x20\x03(\x0b2\x08.CCo\
    okieR\x07cookies\"\x88\x02\n\x10CMsgNodeHasFocus\x12%\n\x0ebrowser_handl\
    e\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x16\n\x06bInput\x18\x02\x20\x01\
    (\x08R\x06bInput\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12&\n\
    \x0eelementtagname\x18\x04\x20\x01(\tR\x0eelementtagname\x12*\n\x10searc\
    hbuttontext\x18\x05\x20\x01(\tR\x10searchbuttontext\x12.\n\x12bHasMultip\
    leInputs\x18\x06\x20\x01(\x08R\x12bHasMultipleInputs\x12\x1d\n\ninput_ty\
    pe\x18\x07\x20\x01(\tR\tinputType\"A\n\x18CMsgZoomToFocusedElement\x12%\
    \n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"G\n\x1eCMsgClos\
    eFullScreenFlashIfOpen\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbro\
    wserHandle\"L\n#CMsgPauseFullScreenFlashMovieIfOpen\x12%\n\x0ebrowser_ha\
    ndle\x18\x01\x20\x01(\rR\rbrowserHandle\"<\n\x13CMsgFocusedNodeText\x12%\
    \n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"Z\n\x1bCMsgFocu\
    sedNodeTextResponse\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowse\
    rHandle\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\"(\n\x0bCMsgBuil\
    dID\x12\x19\n\x08build_id\x18\x01\x20\x01(\x04R\x07buildId\"9\n\x10CMsgO\
    penDevTools\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\
    \":\n\x11CMsgCloseDevTools\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\
    \rbrowserHandle\"X\n\x0eCMsgUnlockH264\x12%\n\x0ebrowser_handle\x18\x01\
    \x20\x01(\rR\rbrowserHandle\x12\x1f\n\x0bunlock_code\x18\x02\x20\x01(\tR\
    \nunlockCode\"\xad\x03\n\x1cCMsgScreenInformationChanged\x12%\n\x0ebrows\
    er_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12%\n\x0eoverride_width\
    \x18\x02\x20\x01(\rR\roverrideWidth\x12'\n\x0foverride_height\x18\x03\
    \x20\x01(\rR\x0eoverrideHeight\x12!\n\x0cmonitor_left\x18\x04\x20\x01(\r\
    R\x0bmonitorLeft\x12\x1f\n\x0bmonitor_top\x18\x05\x20\x01(\rR\nmonitorTo\
    p\x12#\n\rmonitor_right\x18\x06\x20\x01(\rR\x0cmonitorRight\x12%\n\x0emo\
    nitor_bottom\x18\x07\x20\x01(\rR\rmonitorBottom\x12\x1f\n\x0busable_left\
    \x18\x08\x20\x01(\rR\nusableLeft\x12\x1d\n\nusable_top\x18\t\x20\x01(\rR\
    \tusableTop\x12!\n\x0cusable_right\x18\n\x20\x01(\rR\x0busableRight\x12#\
    \n\rusable_bottom\x18\x0b\x20\x01(\rR\x0cusableBottom\"<\n\x13CMsgClearA\
    llCookies\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"W\
    \n\rCMsgScreenDPI\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserH\
    andle\x12\x1f\n\x0bdpi_scaling\x18\x02\x20\x01(\x02R\ndpiScaling\"2\n\
    \x16CMsgAuthedSteamDomains\x12\x18\n\x07domains\x18\x01\x20\x03(\tR\x07d\
    omains\"-\n\x13CMsgSteamAuthNeeded\x12\x16\n\x06filler\x18\x01\x20\x01(\
    \x08R\x06filler\"3\n\x17CMsgSteamAuthCookiesSet\x12\x18\n\x07success\x18\
    \x01\x20\x01(\x08R\x07success\"\xab\x01\n\x14CMsgJSRegisterMethod\x12%\n\
    \x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x12\n\x04name\
    \x18\x02\x20\x01(\tR\x04name\x12X\n\x0bmethod_type\x18\x03\x20\x01(\x0e2\
    \x16.EJSRegisterMethodType:\x1fk_EJSRegisterMethodType_InvalidR\nmethodT\
    ype\"Y\n\x11CJSMethodArgument\x12\x1b\n\tjson_data\x18\x01\x20\x01(\tR\
    \x08jsonData\x12'\n\x0ffunction_handle\x18\x02\x20\x01(\x04R\x0efunction\
    Handle\"\xd8\x03\n\x0bCMsgJSValue\x12\x1d\n\nbool_value\x18\x01\x20\x01(\
    \x08R\tboolValue\x12\x1b\n\tint_value\x18\x02\x20\x01(\x05R\x08intValue\
    \x12\x1d\n\nuint_value\x18\x03\x20\x01(\rR\tuintValue\x12!\n\x0cdouble_v\
    alue\x18\x04\x20\x01(\x01R\x0bdoubleValue\x12!\n\x0cstring_value\x18\x05\
    \x20\x01(\tR\x0bstringValue\x12'\n\x0ffunction_handle\x18\x06\x20\x01(\
    \x04R\x0efunctionHandle\x12\x19\n\x08is_array\x18\x08\x20\x01(\x08R\x07i\
    sArray\x12/\n\x0carray_values\x18\t\x20\x03(\x0b2\x0c.CMsgJSValueR\x0bar\
    rayValues\x12\x1b\n\tis_object\x18\n\x20\x01(\x08R\x08isObject\x12J\n\
    \x11object_properties\x18\x0b\x20\x03(\x0b2\x1d.CMsgJSValue.JSObjectProp\
    ertyR\x10objectProperties\x1aJ\n\x10JSObjectProperty\x12\x12\n\x04name\
    \x18\x01\x20\x01(\tR\x04name\x12\"\n\x05value\x18\x02\x20\x01(\x0b2\x0c.\
    CMsgJSValueR\x05value\"y\n\x10CMsgJSMethodCall\x12%\n\x0ebrowser_handle\
    \x18\x01\x20\x01(\rR\rbrowserHandle\x12\x12\n\x04name\x18\x02\x20\x01(\t\
    R\x04name\x12*\n\targuments\x18\x03\x20\x03(\x0b2\x0c.CMsgJSValueR\targu\
    ments\"\x93\x01\n\x15CMsgJSExecuteCallback\x12%\n\x0ebrowser_handle\x18\
    \x01\x20\x01(\rR\rbrowserHandle\x12'\n\x0ffunction_handle\x18\x02\x20\
    \x01(\x04R\x0efunctionHandle\x12*\n\targuments\x18\x03\x20\x03(\x0b2\x0c\
    .CMsgJSValueR\targuments\"g\n\x15CMsgJSReleaseCallback\x12%\n\x0ebrowser\
    _handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12'\n\x0ffunction_handle\x18\
    \x02\x20\x01(\x04R\x0efunctionHandle\"[\n\x14CMsgJSRaiseException\x12%\n\
    \x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x1c\n\texcepti\
    on\x18\x02\x20\x01(\tR\texception\"\x86\x01\n\x14CMsgLoadLocalization\
    \x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12+\n\x11l\
    ocalization_path\x18\x02\x20\x01(\tR\x10localizationPath\x12\x1a\n\x08la\
    nguage\x18\x03\x20\x01(\tR\x08language\"m\n\x10CMsgJumpListLink\x12!\n\
    \x0cdisplay_name\x18\x01\x20\x01(\tR\x0bdisplayName\x12\x19\n\x08url_lin\
    k\x18\x02\x20\x01(\tR\x07urlLink\x12\x1b\n\ticon_path\x18\x03\x20\x01(\t\
    R\x08iconPath\"\x85\x01\n\x12CMSgJumpListMRUApp\x12\x14\n\x05appid\x18\
    \x01\x20\x01(\rR\x05appid\x12!\n\x0cdisplay_name\x18\x02\x20\x01(\tR\x0b\
    displayName\x12\x19\n\x08url_link\x18\x03\x20\x01(\tR\x07urlLink\x12\x1b\
    \n\ticon_path\x18\x04\x20\x01(\tR\x08iconPath\"\x9f\x01\n\x0fCMsgSetJump\
    List\x12\x1d\n\nsteam_path\x18\x01\x20\x01(\tR\tsteamPath\x12\x1b\n\tmru\
    _title\x18\x02\x20\x01(\tR\x08mruTitle\x12'\n\x04apps\x18\x03\x20\x03(\
    \x0b2\x13.CMSgJumpListMRUAppR\x04apps\x12'\n\x05links\x18\x04\x20\x03(\
    \x0b2\x11.CMsgJumpListLinkR\x05links\"d\n\x1cCMsgSetGameOverlayTargetPID\
    s\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x1d\n\
    \ntarget_pid\x18\x02\x20\x03(\rR\ttargetPid\"\x8d\x01\n\x1eCMsgGameOverl\
    ayTargetTextureID\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserH\
    andle\x12\x1d\n\ntarget_pid\x18\x02\x20\x01(\rR\ttargetPid\x12%\n\x0etex\
    ture_handle\x18\x03\x20\x01(\rR\rtextureHandle\"\x81\x02\n\x1bCMsgDragga\
    bleRegionsChanged\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserH\
    andle\x12A\n\x05rects\x18\x02\x20\x03(\x0b2+.CMsgDraggableRegionsChanged\
    .DraggableRectsR\x05rects\x1ax\n\x0eDraggableRects\x12\x0c\n\x01x\x18\
    \x01\x20\x01(\x05R\x01x\x12\x0c\n\x01y\x18\x02\x20\x01(\x05R\x01y\x12\
    \x14\n\x05width\x18\x03\x20\x01(\x05R\x05width\x12\x16\n\x06height\x18\
    \x04\x20\x01(\x05R\x06height\x12\x1c\n\tdraggable\x18\x05\x20\x01(\x08R\
    \tdraggable\"l\n\x15CMsgResizeGripChanged\x12%\n\x0ebrowser_handle\x18\
    \x01\x20\x01(\rR\rbrowserHandle\x12\x14\n\x05width\x18\x02\x20\x01(\x05R\
    \x05width\x12\x16\n\x06height\x18\x03\x20\x01(\x05R\x06height\"\xc4\x01\
    \n\x15CMsgSetWindowPosition\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\
    \rbrowserHandle\x12\x0c\n\x01x\x18\x02\x20\x01(\x05R\x01x\x12\x0c\n\x01y\
    \x18\x03\x20\x01(\x05R\x01y\x12\x14\n\x05width\x18\x04\x20\x01(\x05R\x05\
    width\x12\x16\n\x06height\x18\x05\x20\x01(\x05R\x06height\x12\x1b\n\tmin\
    _width\x18\x06\x20\x01(\x05R\x08minWidth\x12\x1d\n\nmin_height\x18\x07\
    \x20\x01(\x05R\tminHeight\"7\n\x0eCMsgShowWindow\x12%\n\x0ebrowser_handl\
    e\x18\x01\x20\x01(\rR\rbrowserHandle\"7\n\x0eCMsgHideWindow\x12%\n\x0ebr\
    owser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"?\n\x16CMsgBringWindowT\
    oFront\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"@\n\
    \x17CMsgSetForegroundWindow\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\
    \rbrowserHandle\"B\n\x19CMsgMaximizeRestoreWindow\x12%\n\x0ebrowser_hand\
    le\x18\x01\x20\x01(\rR\rbrowserHandle\";\n\x12CMsgMinimizeWindow\x12%\n\
    \x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"\xd0\x01\n\x1aCMs\
    gShowBrowserContextMenu\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbr\
    owserHandle\x12S\n\x0fcustom_commands\x18\x02\x20\x03(\x0b2*.CMsgShowBro\
    wserContextMenu.ContextCommandR\x0ecustomCommands\x1a6\n\x0eContextComma\
    nd\x12\x0e\n\x02id\x18\x01\x20\x01(\x05R\x02id\x12\x14\n\x05label\x18\
    \x02\x20\x01(\tR\x05label\"d\n\x1cCMsgHandleContextMenuCommand\x12%\n\
    \x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x1d\n\ncommand\
    _id\x18\x02\x20\x01(\x05R\tcommandId\"R\n\x15CMsgImeSetComposition\x12%\
    \n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x12\n\x04tex\
    t\x18\x02\x20\x01(\tR\x04text\"N\n\x11CMsgImeCommitText\x12%\n\x0ebrowse\
    r_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x12\n\x04text\x18\x02\
    \x20\x01(\tR\x04text\"A\n\x18CMsgImeCancelComposition\x12%\n\x0ebrowser_\
    handle\x18\x01\x20\x01(\rR\rbrowserHandle\"c\n\x1eCMsgImeCompositionRang\
    eChanged\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\
    \x0c\n\x01x\x18\x02\x20\x01(\rR\x01x\x12\x0c\n\x01y\x18\x03\x20\x01(\rR\
    \x01y\"W\n\x12CMsgInspectElement\x12%\n\x0ebrowser_handle\x18\x01\x20\
    \x01(\rR\rbrowserHandle\x12\x0c\n\x01x\x18\x02\x20\x01(\rR\x01x\x12\x0c\
    \n\x01y\x18\x03\x20\x01(\rR\x01y\"P\n\rCMsgDisableF5\x12%\n\x0ebrowser_h\
    andle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x18\n\x07disable\x18\x02\
    \x20\x01(\x08R\x07disable\"L\n\x11CMsgStartDownload\x12%\n\x0ebrowser_ha\
    ndle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x10\n\x03url\x18\x02\x20\x01\
    (\tR\x03url*\xad\x01\n\x15EJSRegisterMethodType\x12#\n\x1fk_EJSRegisterM\
    ethodType_Invalid\x10\0\x12$\n\x20k_EJSRegisterMethodType_Function\x10\
    \x01\x12$\n\x20k_EJSRegisterMethodType_Callback\x10\x02\x12#\n\x1fk_EJSR\
    egisterMethodType_Promise\x10\x03B\x05H\x01\x80\x01\0J\xb4\xab\x02\n\x07\
    \x12\x05\0\0\x95\x07\x01\n\x08\n\x01\x08\x12\x03\0\0\x1c\n\t\n\x02\x08\t\
    \x12\x03\0\0\x1c\n\x08\n\x01\x08\x12\x03\x01\0#\n\t\n\x02\x08\x10\x12\
    \x03\x01\0#\n\n\n\x02\x05\0\x12\x04\x03\0\x08\x01\n\n\n\x03\x05\0\x01\
    \x12\x03\x03\x05\x1a\n\x0b\n\x04\x05\0\x02\0\x12\x03\x04\x08,\n\x0c\n\
    \x05\x05\0\x02\0\x01\x12\x03\x04\x08'\n\x0c\n\x05\x05\0\x02\0\x02\x12\
    \x03\x04*+\n\x0b\n\x04\x05\0\x02\x01\x12\x03\x05\x08-\n\x0c\n\x05\x05\0\
    \x02\x01\x01\x12\x03\x05\x08(\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03\x05+\
    ,\n\x0b\n\x04\x05\0\x02\x02\x12\x03\x06\x08-\n\x0c\n\x05\x05\0\x02\x02\
    \x01\x12\x03\x06\x08(\n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03\x06+,\n\x0b\
    \n\x04\x05\0\x02\x03\x12\x03\x07\x08,\n\x0c\n\x05\x05\0\x02\x03\x01\x12\
    \x03\x07\x08'\n\x0c\n\x05\x05\0\x02\x03\x02\x12\x03\x07*+\n\n\n\x02\x04\
    \0\x12\x04\n\0\x0f\x01\n\n\n\x03\x04\0\x01\x12\x03\n\x08\x11\n\x0b\n\x04\
    \x04\0\x02\0\x12\x03\x0b\x08+\n\x0c\n\x05\x04\0\x02\0\x04\x12\x03\x0b\
    \x08\x10\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x0b\x11\x17\n\x0c\n\x05\x04\
    \0\x02\0\x01\x12\x03\x0b\x18&\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x0b)*\
    \n\x0b\n\x04\x04\0\x02\x01\x12\x03\x0c\x08$\n\x0c\n\x05\x04\0\x02\x01\
    \x04\x12\x03\x0c\x08\x10\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03\x0c\x11\
    \x17\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x0c\x18\x1f\n\x0c\n\x05\x04\0\
    \x02\x01\x03\x12\x03\x0c\"#\n\x0b\n\x04\x04\0\x02\x02\x12\x03\r\x08&\n\
    \x0c\n\x05\x04\0\x02\x02\x04\x12\x03\r\x08\x10\n\x0c\n\x05\x04\0\x02\x02\
    \x05\x12\x03\r\x11\x17\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\r\x18!\n\
    \x0c\n\x05\x04\0\x02\x02\x03\x12\x03\r$%\n\x0b\n\x04\x04\0\x02\x03\x12\
    \x03\x0e\x08*\n\x0c\n\x05\x04\0\x02\x03\x04\x12\x03\x0e\x08\x10\n\x0c\n\
    \x05\x04\0\x02\x03\x05\x12\x03\x0e\x11\x17\n\x0c\n\x05\x04\0\x02\x03\x01\
    \x12\x03\x0e\x18%\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03\x0e()\n\n\n\x02\
    \x04\x01\x12\x04\x11\0\x17\x01\n\n\n\x03\x04\x01\x01\x12\x03\x11\x08\x13\
    \n\x0b\n\x04\x04\x01\x02\0\x12\x03\x12\x08+\n\x0c\n\x05\x04\x01\x02\0\
    \x04\x12\x03\x12\x08\x10\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03\x12\x11\
    \x17\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\x12\x18&\n\x0c\n\x05\x04\x01\
    \x02\0\x03\x12\x03\x12)*\n\x0b\n\x04\x04\x01\x02\x01\x12\x03\x13\x08$\n\
    \x0c\n\x05\x04\x01\x02\x01\x04\x12\x03\x13\x08\x10\n\x0c\n\x05\x04\x01\
    \x02\x01\x05\x12\x03\x13\x11\x17\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\
    \x13\x18\x1f\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03\x13\"#\n\x0b\n\x04\
    \x04\x01\x02\x02\x12\x03\x14\x08&\n\x0c\n\x05\x04\x01\x02\x02\x04\x12\
    \x03\x14\x08\x10\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03\x14\x11\x17\n\
    \x0c\n\x05\x04\x01\x02\x02\x01\x12\x03\x14\x18!\n\x0c\n\x05\x04\x01\x02\
    \x02\x03\x12\x03\x14$%\n\x0b\n\x04\x04\x01\x02\x03\x12\x03\x15\x08(\n\
    \x0c\n\x05\x04\x01\x02\x03\x04\x12\x03\x15\x08\x10\n\x0c\n\x05\x04\x01\
    \x02\x03\x05\x12\x03\x15\x11\x15\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x03\
    \x15\x16#\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\x03\x15&'\n\x0b\n\x04\x04\
    \x01\x02\x04\x12\x03\x16\x08*\n\x0c\n\x05\x04\x01\x02\x04\x04\x12\x03\
    \x16\x08\x10\n\x0c\n\x05\x04\x01\x02\x04\x05\x12\x03\x16\x11\x17\n\x0c\n\
    \x05\x04\x01\x02\x04\x01\x12\x03\x16\x18%\n\x0c\n\x05\x04\x01\x02\x04\
    \x03\x12\x03\x16()\n\n\n\x02\x04\x02\x12\x04\x19\0\x1f\x01\n\n\n\x03\x04\
    \x02\x01\x12\x03\x19\x08\x13\n\x0b\n\x04\x04\x02\x02\0\x12\x03\x1a\x08+\
    \n\x0c\n\x05\x04\x02\x02\0\x04\x12\x03\x1a\x08\x10\n\x0c\n\x05\x04\x02\
    \x02\0\x05\x12\x03\x1a\x11\x17\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03\x1a\
    \x18&\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03\x1a)*\n\x0b\n\x04\x04\x02\
    \x02\x01\x12\x03\x1b\x08$\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03\x1b\
    \x08\x10\n\x0c\n\x05\x04\x02\x02\x01\x05\x12\x03\x1b\x11\x17\n\x0c\n\x05\
    \x04\x02\x02\x01\x01\x12\x03\x1b\x18\x1f\n\x0c\n\x05\x04\x02\x02\x01\x03\
    \x12\x03\x1b\"#\n\x0b\n\x04\x04\x02\x02\x02\x12\x03\x1c\x08&\n\x0c\n\x05\
    \x04\x02\x02\x02\x04\x12\x03\x1c\x08\x10\n\x0c\n\x05\x04\x02\x02\x02\x05\
    \x12\x03\x1c\x11\x17\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x03\x1c\x18!\n\
    \x0c\n\x05\x04\x02\x02\x02\x03\x12\x03\x1c$%\n\x0b\n\x04\x04\x02\x02\x03\
    \x12\x03\x1d\x08$\n\x0c\n\x05\x04\x02\x02\x03\x04\x12\x03\x1d\x08\x10\n\
    \x0c\n\x05\x04\x02\x02\x03\x05\x12\x03\x1d\x11\x17\n\x0c\n\x05\x04\x02\
    \x02\x03\x01\x12\x03\x1d\x18\x1f\n\x0c\n\x05\x04\x02\x02\x03\x03\x12\x03\
    \x1d\"#\n\x0b\n\x04\x04\x02\x02\x04\x12\x03\x1e\x08*\n\x0c\n\x05\x04\x02\
    \x02\x04\x04\x12\x03\x1e\x08\x10\n\x0c\n\x05\x04\x02\x02\x04\x05\x12\x03\
    \x1e\x11\x17\n\x0c\n\x05\x04\x02\x02\x04\x01\x12\x03\x1e\x18%\n\x0c\n\
    \x05\x04\x02\x02\x04\x03\x12\x03\x1e()\n\n\n\x02\x04\x03\x12\x04!\0%\x01\
    \n\n\n\x03\x04\x03\x01\x12\x03!\x08\x15\n\x0b\n\x04\x04\x03\x02\0\x12\
    \x03\"\x08+\n\x0c\n\x05\x04\x03\x02\0\x04\x12\x03\"\x08\x10\n\x0c\n\x05\
    \x04\x03\x02\0\x05\x12\x03\"\x11\x17\n\x0c\n\x05\x04\x03\x02\0\x01\x12\
    \x03\"\x18&\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03\")*\n\x0b\n\x04\x04\
    \x03\x02\x01\x12\x03#\x08)\n\x0c\n\x05\x04\x03\x02\x01\x04\x12\x03#\x08\
    \x10\n\x0c\n\x05\x04\x03\x02\x01\x05\x12\x03#\x11\x17\n\x0c\n\x05\x04\
    \x03\x02\x01\x01\x12\x03#\x18$\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03#'\
    (\n\x0b\n\x04\x04\x03\x02\x02\x12\x03$\x08&\n\x0c\n\x05\x04\x03\x02\x02\
    \x04\x12\x03$\x08\x10\n\x0c\n\x05\x04\x03\x02\x02\x05\x12\x03$\x11\x17\n\
    \x0c\n\x05\x04\x03\x02\x02\x01\x12\x03$\x18!\n\x0c\n\x05\x04\x03\x02\x02\
    \x03\x12\x03$$%\n\n\n\x02\x04\x04\x12\x04'\0.\x01\n\n\n\x03\x04\x04\x01\
    \x12\x03'\x08\x13\n\x0b\n\x04\x04\x04\x02\0\x12\x03(\x08+\n\x0c\n\x05\
    \x04\x04\x02\0\x04\x12\x03(\x08\x10\n\x0c\n\x05\x04\x04\x02\0\x05\x12\
    \x03(\x11\x17\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03(\x18&\n\x0c\n\x05\
    \x04\x04\x02\0\x03\x12\x03()*\n\x0b\n\x04\x04\x04\x02\x01\x12\x03)\x08)\
    \n\x0c\n\x05\x04\x04\x02\x01\x04\x12\x03)\x08\x10\n\x0c\n\x05\x04\x04\
    \x02\x01\x05\x12\x03)\x11\x17\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03)\
    \x18$\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03)'(\n\x0b\n\x04\x04\x04\x02\
    \x02\x12\x03*\x08&\n\x0c\n\x05\x04\x04\x02\x02\x04\x12\x03*\x08\x10\n\
    \x0c\n\x05\x04\x04\x02\x02\x05\x12\x03*\x11\x17\n\x0c\n\x05\x04\x04\x02\
    \x02\x01\x12\x03*\x18!\n\x0c\n\x05\x04\x04\x02\x02\x03\x12\x03*$%\n\x0b\
    \n\x04\x04\x04\x02\x03\x12\x03+\x08'\n\x0c\n\x05\x04\x04\x02\x03\x04\x12\
    \x03+\x08\x10\n\x0c\n\x05\x04\x04\x02\x03\x05\x12\x03+\x11\x15\n\x0c\n\
    \x05\x04\x04\x02\x03\x01\x12\x03+\x16\"\n\x0c\n\x05\x04\x04\x02\x03\x03\
    \x12\x03+%&\n\x0b\n\x04\x04\x04\x02\x04\x12\x03,\x08\x1d\n\x0c\n\x05\x04\
    \x04\x02\x04\x04\x12\x03,\x08\x10\n\x0c\n\x05\x04\x04\x02\x04\x05\x12\
    \x03,\x11\x16\n\x0c\n\x05\x04\x04\x02\x04\x01\x12\x03,\x17\x18\n\x0c\n\
    \x05\x04\x04\x02\x04\x03\x12\x03,\x1b\x1c\n\x0b\n\x04\x04\x04\x02\x05\
    \x12\x03-\x08\x1d\n\x0c\n\x05\x04\x04\x02\x05\x04\x12\x03-\x08\x10\n\x0c\
    \n\x05\x04\x04\x02\x05\x05\x12\x03-\x11\x16\n\x0c\n\x05\x04\x04\x02\x05\
    \x01\x12\x03-\x17\x18\n\x0c\n\x05\x04\x04\x02\x05\x03\x12\x03-\x1b\x1c\n\
    \n\n\x02\x04\x05\x12\x040\04\x01\n\n\n\x03\x04\x05\x01\x12\x030\x08\x19\
    \n\x0b\n\x04\x04\x05\x02\0\x12\x031\x08+\n\x0c\n\x05\x04\x05\x02\0\x04\
    \x12\x031\x08\x10\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x031\x11\x17\n\x0c\n\
    \x05\x04\x05\x02\0\x01\x12\x031\x18&\n\x0c\n\x05\x04\x05\x02\0\x03\x12\
    \x031)*\n\x0b\n\x04\x04\x05\x02\x01\x12\x032\x08)\n\x0c\n\x05\x04\x05\
    \x02\x01\x04\x12\x032\x08\x10\n\x0c\n\x05\x04\x05\x02\x01\x05\x12\x032\
    \x11\x17\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x032\x18$\n\x0c\n\x05\x04\
    \x05\x02\x01\x03\x12\x032'(\n\x0b\n\x04\x04\x05\x02\x02\x12\x033\x08&\n\
    \x0c\n\x05\x04\x05\x02\x02\x04\x12\x033\x08\x10\n\x0c\n\x05\x04\x05\x02\
    \x02\x05\x12\x033\x11\x17\n\x0c\n\x05\x04\x05\x02\x02\x01\x12\x033\x18!\
    \n\x0c\n\x05\x04\x05\x02\x02\x03\x12\x033$%\n\n\n\x02\x04\x06\x12\x046\0\
    ;\x01\n\n\n\x03\x04\x06\x01\x12\x036\x08\x16\n\x0b\n\x04\x04\x06\x02\0\
    \x12\x037\x08+\n\x0c\n\x05\x04\x06\x02\0\x04\x12\x037\x08\x10\n\x0c\n\
    \x05\x04\x06\x02\0\x05\x12\x037\x11\x17\n\x0c\n\x05\x04\x06\x02\0\x01\
    \x12\x037\x18&\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x037)*\n\x0b\n\x04\x04\
    \x06\x02\x01\x12\x038\x08\"\n\x0c\n\x05\x04\x06\x02\x01\x04\x12\x038\x08\
    \x10\n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x038\x11\x16\n\x0c\n\x05\x04\
    \x06\x02\x01\x01\x12\x038\x17\x1d\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\
    \x038\x20!\n\x0b\n\x04\x04\x06\x02\x02\x12\x039\x08\"\n\x0c\n\x05\x04\
    \x06\x02\x02\x04\x12\x039\x08\x10\n\x0c\n\x05\x04\x06\x02\x02\x05\x12\
    \x039\x11\x16\n\x0c\n\x05\x04\x06\x02\x02\x01\x12\x039\x17\x1d\n\x0c\n\
    \x05\x04\x06\x02\x02\x03\x12\x039\x20!\n\x0b\n\x04\x04\x06\x02\x03\x12\
    \x03:\x08&\n\x0c\n\x05\x04\x06\x02\x03\x04\x12\x03:\x08\x10\n\x0c\n\x05\
    \x04\x06\x02\x03\x05\x12\x03:\x11\x17\n\x0c\n\x05\x04\x06\x02\x03\x01\
    \x12\x03:\x18!\n\x0c\n\x05\x04\x06\x02\x03\x03\x12\x03:$%\n\n\n\x02\x04\
    \x07\x12\x04=\0B\x01\n\n\n\x03\x04\x07\x01\x12\x03=\x08\x15\n\x0b\n\x04\
    \x04\x07\x02\0\x12\x03>\x08+\n\x0c\n\x05\x04\x07\x02\0\x04\x12\x03>\x08\
    \x10\n\x0c\n\x05\x04\x07\x02\0\x05\x12\x03>\x11\x17\n\x0c\n\x05\x04\x07\
    \x02\0\x01\x12\x03>\x18&\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03>)*\n\x0b\
    \n\x04\x04\x07\x02\x01\x12\x03?\x08\x1d\n\x0c\n\x05\x04\x07\x02\x01\x04\
    \x12\x03?\x08\x10\n\x0c\n\x05\x04\x07\x02\x01\x05\x12\x03?\x11\x16\n\x0c\
    \n\x05\x04\x07\x02\x01\x01\x12\x03?\x17\x18\n\x0c\n\x05\x04\x07\x02\x01\
    \x03\x12\x03?\x1b\x1c\n\x0b\n\x04\x04\x07\x02\x02\x12\x03@\x08\x1d\n\x0c\
    \n\x05\x04\x07\x02\x02\x04\x12\x03@\x08\x10\n\x0c\n\x05\x04\x07\x02\x02\
    \x05\x12\x03@\x11\x16\n\x0c\n\x05\x04\x07\x02\x02\x01\x12\x03@\x17\x18\n\
    \x0c\n\x05\x04\x07\x02\x02\x03\x12\x03@\x1b\x1c\n\x0b\n\x04\x04\x07\x02\
    \x03\x12\x03A\x08&\n\x0c\n\x05\x04\x07\x02\x03\x04\x12\x03A\x08\x10\n\
    \x0c\n\x05\x04\x07\x02\x03\x05\x12\x03A\x11\x17\n\x0c\n\x05\x04\x07\x02\
    \x03\x01\x12\x03A\x18!\n\x0c\n\x05\x04\x07\x02\x03\x03\x12\x03A$%\n\n\n\
    \x02\x04\x08\x12\x04D\0F\x01\n\n\n\x03\x04\x08\x01\x12\x03D\x08\x16\n\
    \x0b\n\x04\x04\x08\x02\0\x12\x03E\x08+\n\x0c\n\x05\x04\x08\x02\0\x04\x12\
    \x03E\x08\x10\n\x0c\n\x05\x04\x08\x02\0\x05\x12\x03E\x11\x17\n\x0c\n\x05\
    \x04\x08\x02\0\x01\x12\x03E\x18&\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03E)\
    *\n\n\n\x02\x04\t\x12\x04H\0Z\x01\n\n\n\x03\x04\t\x01\x12\x03H\x08\x19\n\
    \x0b\n\x04\x04\t\x02\0\x12\x03I\x08'\n\x0c\n\x05\x04\t\x02\0\x04\x12\x03\
    I\x08\x10\n\x0c\n\x05\x04\t\x02\0\x05\x12\x03I\x11\x17\n\x0c\n\x05\x04\t\
    \x02\0\x01\x12\x03I\x18\"\n\x0c\n\x05\x04\t\x02\0\x03\x12\x03I%&\n\x0b\n\
    \x04\x04\t\x02\x01\x12\x03J\x08&\n\x0c\n\x05\x04\t\x02\x01\x04\x12\x03J\
    \x08\x10\n\x0c\n\x05\x04\t\x02\x01\x05\x12\x03J\x11\x17\n\x0c\n\x05\x04\
    \t\x02\x01\x01\x12\x03J\x18!\n\x0c\n\x05\x04\t\x02\x01\x03\x12\x03J$%\n\
    \x0b\n\x04\x04\t\x02\x02\x12\x03K\x08%\n\x0c\n\x05\x04\t\x02\x02\x04\x12\
    \x03K\x08\x10\n\x0c\n\x05\x04\t\x02\x02\x05\x12\x03K\x11\x17\n\x0c\n\x05\
    \x04\t\x02\x02\x01\x12\x03K\x18\x20\n\x0c\n\x05\x04\t\x02\x02\x03\x12\
    \x03K#$\n\x0b\n\x04\x04\t\x02\x03\x12\x03L\x08+\n\x0c\n\x05\x04\t\x02\
    \x03\x04\x12\x03L\x08\x10\n\x0c\n\x05\x04\t\x02\x03\x05\x12\x03L\x11\x15\
    \n\x0c\n\x05\x04\t\x02\x03\x01\x12\x03L\x16&\n\x0c\n\x05\x04\t\x02\x03\
    \x03\x12\x03L)*\n\x0b\n\x04\x04\t\x02\x04\x12\x03M\x08'\n\x0c\n\x05\x04\
    \t\x02\x04\x04\x12\x03M\x08\x10\n\x0c\n\x05\x04\t\x02\x04\x05\x12\x03M\
    \x11\x16\n\x0c\n\x05\x04\t\x02\x04\x01\x12\x03M\x17\"\n\x0c\n\x05\x04\t\
    \x02\x04\x03\x12\x03M%&\n\x0b\n\x04\x04\t\x02\x05\x12\x03N\x085\n\x0c\n\
    \x05\x04\t\x02\x05\x04\x12\x03N\x08\x10\n\x0c\n\x05\x04\t\x02\x05\x05\
    \x12\x03N\x11\x15\n\x0c\n\x05\x04\t\x02\x05\x01\x12\x03N\x16\x1f\n\x0c\n\
    \x05\x04\t\x02\x05\x03\x12\x03N\"#\n\x0c\n\x05\x04\t\x02\x05\x08\x12\x03\
    N$4\n\x0c\n\x05\x04\t\x02\x05\x07\x12\x03N/3\n\x0b\n\x04\x04\t\x02\x06\
    \x12\x03O\x088\n\x0c\n\x05\x04\t\x02\x06\x04\x12\x03O\x08\x10\n\x0c\n\
    \x05\x04\t\x02\x06\x05\x12\x03O\x11\x17\n\x0c\n\x05\x04\t\x02\x06\x01\
    \x12\x03O\x18%\n\x0c\n\x05\x04\t\x02\x06\x03\x12\x03O()\n\x0c\n\x05\x04\
    \t\x02\x06\x08\x12\x03O*7\n\x0c\n\x05\x04\t\x02\x06\x07\x12\x03O56\n\x0b\
    \n\x04\x04\t\x02\x07\x12\x03P\x08:\n\x0c\n\x05\x04\t\x02\x07\x04\x12\x03\
    P\x08\x10\n\x0c\n\x05\x04\t\x02\x07\x05\x12\x03P\x11\x17\n\x0c\n\x05\x04\
    \t\x02\x07\x01\x12\x03P\x18&\n\x0c\n\x05\x04\t\x02\x07\x03\x12\x03P)+\n\
    \x0c\n\x05\x04\t\x02\x07\x08\x12\x03P,9\n\x0c\n\x05\x04\t\x02\x07\x07\
    \x12\x03P78\n\x0b\n\x04\x04\t\x02\x08\x12\x03Q\x08)\n\x0c\n\x05\x04\t\
    \x02\x08\x04\x12\x03Q\x08\x10\n\x0c\n\x05\x04\t\x02\x08\x05\x12\x03Q\x11\
    \x17\n\x0c\n\x05\x04\t\x02\x08\x01\x12\x03Q\x18#\n\x0c\n\x05\x04\t\x02\
    \x08\x03\x12\x03Q&(\n\x0b\n\x04\x04\t\x02\t\x12\x03R\x088\n\x0c\n\x05\
    \x04\t\x02\t\x04\x12\x03R\x08\x10\n\x0c\n\x05\x04\t\x02\t\x05\x12\x03R\
    \x11\x15\n\x0c\n\x05\x04\t\x02\t\x01\x12\x03R\x16\x20\n\x0c\n\x05\x04\t\
    \x02\t\x03\x12\x03R#%\n\x0c\n\x05\x04\t\x02\t\x08\x12\x03R&7\n\x0c\n\x05\
    \x04\t\x02\t\x07\x12\x03R16\n\x0b\n\x04\x04\t\x02\n\x12\x03S\x08+\n\x0c\
    \n\x05\x04\t\x02\n\x04\x12\x03S\x08\x10\n\x0c\n\x05\x04\t\x02\n\x05\x12\
    \x03S\x11\x17\n\x0c\n\x05\x04\t\x02\n\x01\x12\x03S\x18%\n\x0c\n\x05\x04\
    \t\x02\n\x03\x12\x03S(*\n\x0b\n\x04\x04\t\x02\x0b\x12\x03T\x088\n\x0c\n\
    \x05\x04\t\x02\x0b\x04\x12\x03T\x08\x10\n\x0c\n\x05\x04\t\x02\x0b\x05\
    \x12\x03T\x11\x17\n\x0c\n\x05\x04\t\x02\x0b\x01\x12\x03T\x18$\n\x0c\n\
    \x05\x04\t\x02\x0b\x03\x12\x03T')\n\x0c\n\x05\x04\t\x02\x0b\x08\x12\x03T\
    *7\n\x0c\n\x05\x04\t\x02\x0b\x07\x12\x03T56\n\x0b\n\x04\x04\t\x02\x0c\
    \x12\x03U\x08@\n\x0c\n\x05\x04\t\x02\x0c\x04\x12\x03U\x08\x10\n\x0c\n\
    \x05\x04\t\x02\x0c\x05\x12\x03U\x11\x16\n\x0c\n\x05\x04\t\x02\x0c\x01\
    \x12\x03U\x17\"\n\x0c\n\x05\x04\t\x02\x0c\x03\x12\x03U%'\n\x0c\n\x05\x04\
    \t\x02\x0c\x08\x12\x03U(?\n\x0c\n\x05\x04\t\x02\x0c\x07\x12\x03U3>\n\x0b\
    \n\x04\x04\t\x02\r\x12\x03V\x08A\n\x0c\n\x05\x04\t\x02\r\x04\x12\x03V\
    \x08\x10\n\x0c\n\x05\x04\t\x02\r\x05\x12\x03V\x11\x16\n\x0c\n\x05\x04\t\
    \x02\r\x01\x12\x03V\x17#\n\x0c\n\x05\x04\t\x02\r\x03\x12\x03V&(\n\x0c\n\
    \x05\x04\t\x02\r\x08\x12\x03V)@\n\x0c\n\x05\x04\t\x02\r\x07\x12\x03V4?\n\
    \x0b\n\x04\x04\t\x02\x0e\x12\x03W\x08G\n\x0c\n\x05\x04\t\x02\x0e\x04\x12\
    \x03W\x08\x10\n\x0c\n\x05\x04\t\x02\x0e\x05\x12\x03W\x11\x15\n\x0c\n\x05\
    \x04\t\x02\x0e\x01\x12\x03W\x16/\n\x0c\n\x05\x04\t\x02\x0e\x03\x12\x03W2\
    4\n\x0c\n\x05\x04\t\x02\x0e\x08\x12\x03W5F\n\x0c\n\x05\x04\t\x02\x0e\x07\
    \x12\x03W@E\n\x0b\n\x04\x04\t\x02\x0f\x12\x03X\x08)\n\x0c\n\x05\x04\t\
    \x02\x0f\x04\x12\x03X\x08\x10\n\x0c\n\x05\x04\t\x02\x0f\x05\x12\x03X\x11\
    \x17\n\x0c\n\x05\x04\t\x02\x0f\x01\x12\x03X\x18#\n\x0c\n\x05\x04\t\x02\
    \x0f\x03\x12\x03X&(\n\x0b\n\x04\x04\t\x02\x10\x12\x03Y\x08*\n\x0c\n\x05\
    \x04\t\x02\x10\x04\x12\x03Y\x08\x10\n\x0c\n\x05\x04\t\x02\x10\x05\x12\
    \x03Y\x11\x18\n\x0c\n\x05\x04\t\x02\x10\x01\x12\x03Y\x19$\n\x0c\n\x05\
    \x04\t\x02\x10\x03\x12\x03Y')\n\n\n\x02\x04\n\x12\x04\\\0_\x01\n\n\n\x03\
    \x04\n\x01\x12\x03\\\x08!\n\x0b\n\x04\x04\n\x02\0\x12\x03]\x08+\n\x0c\n\
    \x05\x04\n\x02\0\x04\x12\x03]\x08\x10\n\x0c\n\x05\x04\n\x02\0\x05\x12\
    \x03]\x11\x17\n\x0c\n\x05\x04\n\x02\0\x01\x12\x03]\x18&\n\x0c\n\x05\x04\
    \n\x02\0\x03\x12\x03])*\n\x0b\n\x04\x04\n\x02\x01\x12\x03^\x08'\n\x0c\n\
    \x05\x04\n\x02\x01\x04\x12\x03^\x08\x10\n\x0c\n\x05\x04\n\x02\x01\x05\
    \x12\x03^\x11\x17\n\x0c\n\x05\x04\n\x02\x01\x01\x12\x03^\x18\"\n\x0c\n\
    \x05\x04\n\x02\x01\x03\x12\x03^%&\n\n\n\x02\x04\x0b\x12\x04a\0c\x01\n\n\
    \n\x03\x04\x0b\x01\x12\x03a\x08\x19\n\x0b\n\x04\x04\x0b\x02\0\x12\x03b\
    \x08+\n\x0c\n\x05\x04\x0b\x02\0\x04\x12\x03b\x08\x10\n\x0c\n\x05\x04\x0b\
    \x02\0\x05\x12\x03b\x11\x17\n\x0c\n\x05\x04\x0b\x02\0\x01\x12\x03b\x18&\
    \n\x0c\n\x05\x04\x0b\x02\0\x03\x12\x03b)*\n\n\n\x02\x04\x0c\x12\x04e\0p\
    \x01\n\n\n\x03\x04\x0c\x01\x12\x03e\x08&\n\x0c\n\x04\x04\x0c\x03\0\x12\
    \x04f\x08j\t\n\x0c\n\x05\x04\x0c\x03\0\x01\x12\x03f\x10\x1f\n\r\n\x06\
    \x04\x0c\x03\0\x02\0\x12\x03g\x101\n\x0e\n\x07\x04\x0c\x03\0\x02\0\x04\
    \x12\x03g\x10\x18\n\x0e\n\x07\x04\x0c\x03\0\x02\0\x05\x12\x03g\x19\x1f\n\
    \x0e\n\x07\x04\x0c\x03\0\x02\0\x01\x12\x03g\x20,\n\x0e\n\x07\x04\x0c\x03\
    \0\x02\0\x03\x12\x03g/0\n\r\n\x06\x04\x0c\x03\0\x02\x01\x12\x03h\x10/\n\
    \x0e\n\x07\x04\x0c\x03\0\x02\x01\x04\x12\x03h\x10\x18\n\x0e\n\x07\x04\
    \x0c\x03\0\x02\x01\x05\x12\x03h\x19\x1f\n\x0e\n\x07\x04\x0c\x03\0\x02\
    \x01\x01\x12\x03h\x20*\n\x0e\n\x07\x04\x0c\x03\0\x02\x01\x03\x12\x03h-.\
    \n\r\n\x06\x04\x0c\x03\0\x02\x02\x12\x03i\x107\n\x0e\n\x07\x04\x0c\x03\0\
    \x02\x02\x04\x12\x03i\x10\x18\n\x0e\n\x07\x04\x0c\x03\0\x02\x02\x05\x12\
    \x03i\x19\x1f\n\x0e\n\x07\x04\x0c\x03\0\x02\x02\x01\x12\x03i\x202\n\x0e\
    \n\x07\x04\x0c\x03\0\x02\x02\x03\x12\x03i56\n\x0b\n\x04\x04\x0c\x02\0\
    \x12\x03l\x08+\n\x0c\n\x05\x04\x0c\x02\0\x04\x12\x03l\x08\x10\n\x0c\n\
    \x05\x04\x0c\x02\0\x05\x12\x03l\x11\x17\n\x0c\n\x05\x04\x0c\x02\0\x01\
    \x12\x03l\x18&\n\x0c\n\x05\x04\x0c\x02\0\x03\x12\x03l)*\n\x0b\n\x04\x04\
    \x0c\x02\x01\x12\x03m\x08(\n\x0c\n\x05\x04\x0c\x02\x01\x04\x12\x03m\x08\
    \x10\n\x0c\n\x05\x04\x0c\x02\x01\x05\x12\x03m\x11\x17\n\x0c\n\x05\x04\
    \x0c\x02\x01\x01\x12\x03m\x18#\n\x0c\n\x05\x04\x0c\x02\x01\x03\x12\x03m&\
    '\n\x0b\n\x04\x04\x0c\x02\x02\x12\x03n\x08/\n\x0c\n\x05\x04\x0c\x02\x02\
    \x04\x12\x03n\x08\x10\n\x0c\n\x05\x04\x0c\x02\x02\x05\x12\x03n\x11\x17\n\
    \x0c\n\x05\x04\x0c\x02\x02\x01\x12\x03n\x18*\n\x0c\n\x05\x04\x0c\x02\x02\
    \x03\x12\x03n-.\n\x0b\n\x04\x04\x0c\x02\x03\x12\x03o\x08L\n\x0c\n\x05\
    \x04\x0c\x02\x03\x04\x12\x03o\x08\x10\n\x0c\n\x05\x04\x0c\x02\x03\x06\
    \x12\x03o\x11@\n\x0c\n\x05\x04\x0c\x02\x03\x01\x12\x03oAG\n\x0c\n\x05\
    \x04\x0c\x02\x03\x03\x12\x03oJK\n\n\n\x02\x04\r\x12\x04r\0{\x01\n\n\n\
    \x03\x04\r\x01\x12\x03r\x08\x1f\n\x0b\n\x04\x04\r\x02\0\x12\x03s\x08+\n\
    \x0c\n\x05\x04\r\x02\0\x04\x12\x03s\x08\x10\n\x0c\n\x05\x04\r\x02\0\x05\
    \x12\x03s\x11\x17\n\x0c\n\x05\x04\r\x02\0\x01\x12\x03s\x18&\n\x0c\n\x05\
    \x04\r\x02\0\x03\x12\x03s)*\n\x0b\n\x04\x04\r\x02\x01\x12\x03t\x08\"\n\
    \x0c\n\x05\x04\r\x02\x01\x04\x12\x03t\x08\x10\n\x0c\n\x05\x04\r\x02\x01\
    \x05\x12\x03t\x11\x17\n\x0c\n\x05\x04\r\x02\x01\x01\x12\x03t\x18\x1d\n\
    \x0c\n\x05\x04\r\x02\x01\x03\x12\x03t\x20!\n\x0b\n\x04\x04\r\x02\x02\x12\
    \x03u\x08#\n\x0c\n\x05\x04\r\x02\x02\x04\x12\x03u\x08\x10\n\x0c\n\x05\
    \x04\r\x02\x02\x05\x12\x03u\x11\x17\n\x0c\n\x05\x04\r\x02\x02\x01\x12\
    \x03u\x18\x1e\n\x0c\n\x05\x04\r\x02\x02\x03\x12\x03u!\"\n\x0b\n\x04\x04\
    \r\x02\x03\x12\x03v\x08'\n\x0c\n\x05\x04\r\x02\x03\x04\x12\x03v\x08\x10\
    \n\x0c\n\x05\x04\r\x02\x03\x05\x12\x03v\x11\x17\n\x0c\n\x05\x04\r\x02\
    \x03\x01\x12\x03v\x18\"\n\x0c\n\x05\x04\r\x02\x03\x03\x12\x03v%&\n\x0b\n\
    \x04\x04\r\x02\x04\x12\x03w\x08$\n\x0c\n\x05\x04\r\x02\x04\x04\x12\x03w\
    \x08\x10\n\x0c\n\x05\x04\r\x02\x04\x05\x12\x03w\x11\x17\n\x0c\n\x05\x04\
    \r\x02\x04\x01\x12\x03w\x18\x1f\n\x0c\n\x05\x04\r\x02\x04\x03\x12\x03w\"\
    #\n\x0b\n\x04\x04\r\x02\x05\x12\x03x\x08/\n\x0c\n\x05\x04\r\x02\x05\x04\
    \x12\x03x\x08\x10\n\x0c\n\x05\x04\r\x02\x05\x05\x12\x03x\x11\x17\n\x0c\n\
    \x05\x04\r\x02\x05\x01\x12\x03x\x18*\n\x0c\n\x05\x04\r\x02\x05\x03\x12\
    \x03x-.\n\x0b\n\x04\x04\r\x02\x06\x12\x03y\x08*\n\x0c\n\x05\x04\r\x02\
    \x06\x04\x12\x03y\x08\x10\n\x0c\n\x05\x04\r\x02\x06\x05\x12\x03y\x11\x17\
    \n\x0c\n\x05\x04\r\x02\x06\x01\x12\x03y\x18%\n\x0c\n\x05\x04\r\x02\x06\
    \x03\x12\x03y()\n\x0b\n\x04\x04\r\x02\x07\x12\x03z\x08$\n\x0c\n\x05\x04\
    \r\x02\x07\x04\x12\x03z\x08\x10\n\x0c\n\x05\x04\r\x02\x07\x05\x12\x03z\
    \x11\x17\n\x0c\n\x05\x04\r\x02\x07\x01\x12\x03z\x18\x1f\n\x0c\n\x05\x04\
    \r\x02\x07\x03\x12\x03z\"#\n\x0b\n\x02\x04\x0e\x12\x05}\0\x81\x01\x01\n\
    \n\n\x03\x04\x0e\x01\x12\x03}\x08\x17\n\x0b\n\x04\x04\x0e\x02\0\x12\x03~\
    \x08+\n\x0c\n\x05\x04\x0e\x02\0\x04\x12\x03~\x08\x10\n\x0c\n\x05\x04\x0e\
    \x02\0\x05\x12\x03~\x11\x17\n\x0c\n\x05\x04\x0e\x02\0\x01\x12\x03~\x18&\
    \n\x0c\n\x05\x04\x0e\x02\0\x03\x12\x03~)*\n\x0b\n\x04\x04\x0e\x02\x01\
    \x12\x03\x7f\x08\"\n\x0c\n\x05\x04\x0e\x02\x01\x04\x12\x03\x7f\x08\x10\n\
    \x0c\n\x05\x04\x0e\x02\x01\x05\x12\x03\x7f\x11\x17\n\x0c\n\x05\x04\x0e\
    \x02\x01\x01\x12\x03\x7f\x18\x1d\n\x0c\n\x05\x04\x0e\x02\x01\x03\x12\x03\
    \x7f\x20!\n\x0c\n\x04\x04\x0e\x02\x02\x12\x04\x80\x01\x08#\n\r\n\x05\x04\
    \x0e\x02\x02\x04\x12\x04\x80\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x02\x05\
    \x12\x04\x80\x01\x11\x17\n\r\n\x05\x04\x0e\x02\x02\x01\x12\x04\x80\x01\
    \x18\x1e\n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\x80\x01!\"\n\x0c\n\x02\
    \x04\x0f\x12\x06\x83\x01\0\x87\x01\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\
    \x83\x01\x08\x1d\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\x84\x01\x08+\n\r\n\
    \x05\x04\x0f\x02\0\x04\x12\x04\x84\x01\x08\x10\n\r\n\x05\x04\x0f\x02\0\
    \x05\x12\x04\x84\x01\x11\x17\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\x84\x01\
    \x18&\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\x84\x01)*\n\x0c\n\x04\x04\x0f\
    \x02\x01\x12\x04\x85\x01\x08\"\n\r\n\x05\x04\x0f\x02\x01\x04\x12\x04\x85\
    \x01\x08\x10\n\r\n\x05\x04\x0f\x02\x01\x05\x12\x04\x85\x01\x11\x17\n\r\n\
    \x05\x04\x0f\x02\x01\x01\x12\x04\x85\x01\x18\x1d\n\r\n\x05\x04\x0f\x02\
    \x01\x03\x12\x04\x85\x01\x20!\n\x0c\n\x04\x04\x0f\x02\x02\x12\x04\x86\
    \x01\x08#\n\r\n\x05\x04\x0f\x02\x02\x04\x12\x04\x86\x01\x08\x10\n\r\n\
    \x05\x04\x0f\x02\x02\x05\x12\x04\x86\x01\x11\x17\n\r\n\x05\x04\x0f\x02\
    \x02\x01\x12\x04\x86\x01\x18\x1e\n\r\n\x05\x04\x0f\x02\x02\x03\x12\x04\
    \x86\x01!\"\n\x0c\n\x02\x04\x10\x12\x06\x89\x01\0\x8f\x01\x01\n\x0b\n\
    \x03\x04\x10\x01\x12\x04\x89\x01\x08\x1b\n\x0c\n\x04\x04\x10\x02\0\x12\
    \x04\x8a\x01\x08+\n\r\n\x05\x04\x10\x02\0\x04\x12\x04\x8a\x01\x08\x10\n\
    \r\n\x05\x04\x10\x02\0\x05\x12\x04\x8a\x01\x11\x17\n\r\n\x05\x04\x10\x02\
    \0\x01\x12\x04\x8a\x01\x18&\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\x8a\x01)\
    *\n\x0c\n\x04\x04\x10\x02\x01\x12\x04\x8b\x01\x08\x1d\n\r\n\x05\x04\x10\
    \x02\x01\x04\x12\x04\x8b\x01\x08\x10\n\r\n\x05\x04\x10\x02\x01\x05\x12\
    \x04\x8b\x01\x11\x16\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\x8b\x01\x17\
    \x18\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\x8b\x01\x1b\x1c\n\x0c\n\x04\
    \x04\x10\x02\x02\x12\x04\x8c\x01\x08\x1d\n\r\n\x05\x04\x10\x02\x02\x04\
    \x12\x04\x8c\x01\x08\x10\n\r\n\x05\x04\x10\x02\x02\x05\x12\x04\x8c\x01\
    \x11\x16\n\r\n\x05\x04\x10\x02\x02\x01\x12\x04\x8c\x01\x17\x18\n\r\n\x05\
    \x04\x10\x02\x02\x03\x12\x04\x8c\x01\x1b\x1c\n\x0c\n\x04\x04\x10\x02\x03\
    \x12\x04\x8d\x01\x08#\n\r\n\x05\x04\x10\x02\x03\x04\x12\x04\x8d\x01\x08\
    \x10\n\r\n\x05\x04\x10\x02\x03\x05\x12\x04\x8d\x01\x11\x16\n\r\n\x05\x04\
    \x10\x02\x03\x01\x12\x04\x8d\x01\x17\x1e\n\r\n\x05\x04\x10\x02\x03\x03\
    \x12\x04\x8d\x01!\"\n\x0c\n\x04\x04\x10\x02\x04\x12\x04\x8e\x01\x08#\n\r\
    \n\x05\x04\x10\x02\x04\x04\x12\x04\x8e\x01\x08\x10\n\r\n\x05\x04\x10\x02\
    \x04\x05\x12\x04\x8e\x01\x11\x16\n\r\n\x05\x04\x10\x02\x04\x01\x12\x04\
    \x8e\x01\x17\x1e\n\r\n\x05\x04\x10\x02\x04\x03\x12\x04\x8e\x01!\"\n\x0c\
    \n\x02\x04\x11\x12\x06\x91\x01\0\x97\x01\x01\n\x0b\n\x03\x04\x11\x01\x12\
    \x04\x91\x01\x08\x1a\n\x0c\n\x04\x04\x11\x02\0\x12\x04\x92\x01\x08+\n\r\
    \n\x05\x04\x11\x02\0\x04\x12\x04\x92\x01\x08\x10\n\r\n\x05\x04\x11\x02\0\
    \x05\x12\x04\x92\x01\x11\x17\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\x92\x01\
    \x18&\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\x92\x01)*\n\x0c\n\x04\x04\x11\
    \x02\x01\x12\x04\x93\x01\x08\x1d\n\r\n\x05\x04\x11\x02\x01\x04\x12\x04\
    \x93\x01\x08\x10\n\r\n\x05\x04\x11\x02\x01\x05\x12\x04\x93\x01\x11\x16\n\
    \r\n\x05\x04\x11\x02\x01\x01\x12\x04\x93\x01\x17\x18\n\r\n\x05\x04\x11\
    \x02\x01\x03\x12\x04\x93\x01\x1b\x1c\n\x0c\n\x04\x04\x11\x02\x02\x12\x04\
    \x94\x01\x08\x1d\n\r\n\x05\x04\x11\x02\x02\x04\x12\x04\x94\x01\x08\x10\n\
    \r\n\x05\x04\x11\x02\x02\x05\x12\x04\x94\x01\x11\x16\n\r\n\x05\x04\x11\
    \x02\x02\x01\x12\x04\x94\x01\x17\x18\n\r\n\x05\x04\x11\x02\x02\x03\x12\
    \x04\x94\x01\x1b\x1c\n\x0c\n\x04\x04\x11\x02\x03\x12\x04\x95\x01\x08\"\n\
    \r\n\x05\x04\x11\x02\x03\x04\x12\x04\x95\x01\x08\x10\n\r\n\x05\x04\x11\
    \x02\x03\x05\x12\x04\x95\x01\x11\x17\n\r\n\x05\x04\x11\x02\x03\x01\x12\
    \x04\x95\x01\x18\x1d\n\r\n\x05\x04\x11\x02\x03\x03\x12\x04\x95\x01\x20!\
    \n\x0c\n\x04\x04\x11\x02\x04\x12\x04\x96\x01\x08#\n\r\n\x05\x04\x11\x02\
    \x04\x04\x12\x04\x96\x01\x08\x10\n\r\n\x05\x04\x11\x02\x04\x05\x12\x04\
    \x96\x01\x11\x17\n\r\n\x05\x04\x11\x02\x04\x01\x12\x04\x96\x01\x18\x1e\n\
    \r\n\x05\x04\x11\x02\x04\x03\x12\x04\x96\x01!\"\n\x0c\n\x02\x04\x12\x12\
    \x06\x99\x01\0\x9e\x01\x01\n\x0b\n\x03\x04\x12\x01\x12\x04\x99\x01\x08\
    \x13\n\x0c\n\x04\x04\x12\x02\0\x12\x04\x9a\x01\x08+\n\r\n\x05\x04\x12\
    \x02\0\x04\x12\x04\x9a\x01\x08\x10\n\r\n\x05\x04\x12\x02\0\x05\x12\x04\
    \x9a\x01\x11\x17\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\x9a\x01\x18&\n\r\n\
    \x05\x04\x12\x02\0\x03\x12\x04\x9a\x01)*\n\x0c\n\x04\x04\x12\x02\x01\x12\
    \x04\x9b\x01\x08\x20\n\r\n\x05\x04\x12\x02\x01\x04\x12\x04\x9b\x01\x08\
    \x10\n\r\n\x05\x04\x12\x02\x01\x05\x12\x04\x9b\x01\x11\x17\n\r\n\x05\x04\
    \x12\x02\x01\x01\x12\x04\x9b\x01\x18\x1b\n\r\n\x05\x04\x12\x02\x01\x03\
    \x12\x04\x9b\x01\x1e\x1f\n\x0c\n\x04\x04\x12\x02\x02\x12\x04\x9c\x01\x08\
    !\n\r\n\x05\x04\x12\x02\x02\x04\x12\x04\x9c\x01\x08\x10\n\r\n\x05\x04\
    \x12\x02\x02\x05\x12\x04\x9c\x01\x11\x17\n\r\n\x05\x04\x12\x02\x02\x01\
    \x12\x04\x9c\x01\x18\x1c\n\r\n\x05\x04\x12\x02\x02\x03\x12\x04\x9c\x01\
    \x1f\x20\n\x0c\n\x04\x04\x12\x02\x03\x12\x04\x9d\x01\x08'\n\r\n\x05\x04\
    \x12\x02\x03\x04\x12\x04\x9d\x01\x08\x10\n\r\n\x05\x04\x12\x02\x03\x05\
    \x12\x04\x9d\x01\x11\x17\n\r\n\x05\x04\x12\x02\x03\x01\x12\x04\x9d\x01\
    \x18\"\n\r\n\x05\x04\x12\x02\x03\x03\x12\x04\x9d\x01%&\n\x0c\n\x02\x04\
    \x13\x12\x06\xa0\x01\0\xa4\x01\x01\n\x0b\n\x03\x04\x13\x01\x12\x04\xa0\
    \x01\x08\x15\n\x0c\n\x04\x04\x13\x02\0\x12\x04\xa1\x01\x08+\n\r\n\x05\
    \x04\x13\x02\0\x04\x12\x04\xa1\x01\x08\x10\n\r\n\x05\x04\x13\x02\0\x05\
    \x12\x04\xa1\x01\x11\x17\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\xa1\x01\x18\
    &\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xa1\x01)*\n\x0c\n\x04\x04\x13\x02\
    \x01\x12\x04\xa2\x01\x08\x20\n\r\n\x05\x04\x13\x02\x01\x04\x12\x04\xa2\
    \x01\x08\x10\n\r\n\x05\x04\x13\x02\x01\x05\x12\x04\xa2\x01\x11\x17\n\r\n\
    \x05\x04\x13\x02\x01\x01\x12\x04\xa2\x01\x18\x1b\n\r\n\x05\x04\x13\x02\
    \x01\x03\x12\x04\xa2\x01\x1e\x1f\n\x0c\n\x04\x04\x13\x02\x02\x12\x04\xa3\
    \x01\x08\"\n\r\n\x05\x04\x13\x02\x02\x04\x12\x04\xa3\x01\x08\x10\n\r\n\
    \x05\x04\x13\x02\x02\x05\x12\x04\xa3\x01\x11\x17\n\r\n\x05\x04\x13\x02\
    \x02\x01\x12\x04\xa3\x01\x18\x1d\n\r\n\x05\x04\x13\x02\x02\x03\x12\x04\
    \xa3\x01\x20!\n\x0c\n\x02\x04\x14\x12\x06\xa6\x01\0\xa8\x01\x01\n\x0b\n\
    \x03\x04\x14\x01\x12\x04\xa6\x01\x08\x14\n\x0c\n\x04\x04\x14\x02\0\x12\
    \x04\xa7\x01\x08+\n\r\n\x05\x04\x14\x02\0\x04\x12\x04\xa7\x01\x08\x10\n\
    \r\n\x05\x04\x14\x02\0\x05\x12\x04\xa7\x01\x11\x17\n\r\n\x05\x04\x14\x02\
    \0\x01\x12\x04\xa7\x01\x18&\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xa7\x01)\
    *\n\x0c\n\x02\x04\x15\x12\x06\xaa\x01\0\xac\x01\x01\n\x0b\n\x03\x04\x15\
    \x01\x12\x04\xaa\x01\x08\x12\n\x0c\n\x04\x04\x15\x02\0\x12\x04\xab\x01\
    \x08+\n\r\n\x05\x04\x15\x02\0\x04\x12\x04\xab\x01\x08\x10\n\r\n\x05\x04\
    \x15\x02\0\x05\x12\x04\xab\x01\x11\x17\n\r\n\x05\x04\x15\x02\0\x01\x12\
    \x04\xab\x01\x18&\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\xab\x01)*\n\x0c\n\
    \x02\x04\x16\x12\x06\xae\x01\0\xb0\x01\x01\n\x0b\n\x03\x04\x16\x01\x12\
    \x04\xae\x01\x08\x15\n\x0c\n\x04\x04\x16\x02\0\x12\x04\xaf\x01\x08+\n\r\
    \n\x05\x04\x16\x02\0\x04\x12\x04\xaf\x01\x08\x10\n\r\n\x05\x04\x16\x02\0\
    \x05\x12\x04\xaf\x01\x11\x17\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\xaf\x01\
    \x18&\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\xaf\x01)*\n\x0c\n\x02\x04\x17\
    \x12\x06\xb2\x01\0\xb4\x01\x01\n\x0b\n\x03\x04\x17\x01\x12\x04\xb2\x01\
    \x08\x12\n\x0c\n\x04\x04\x17\x02\0\x12\x04\xb3\x01\x08+\n\r\n\x05\x04\
    \x17\x02\0\x04\x12\x04\xb3\x01\x08\x10\n\r\n\x05\x04\x17\x02\0\x05\x12\
    \x04\xb3\x01\x11\x17\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xb3\x01\x18&\n\
    \r\n\x05\x04\x17\x02\0\x03\x12\x04\xb3\x01)*\n\x0c\n\x02\x04\x18\x12\x06\
    \xb6\x01\0\xb9\x01\x01\n\x0b\n\x03\x04\x18\x01\x12\x04\xb6\x01\x08\x15\n\
    \x0c\n\x04\x04\x18\x02\0\x12\x04\xb7\x01\x08+\n\r\n\x05\x04\x18\x02\0\
    \x04\x12\x04\xb7\x01\x08\x10\n\r\n\x05\x04\x18\x02\0\x05\x12\x04\xb7\x01\
    \x11\x17\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\xb7\x01\x18&\n\r\n\x05\x04\
    \x18\x02\0\x03\x12\x04\xb7\x01)*\n\x0c\n\x04\x04\x18\x02\x01\x12\x04\xb8\
    \x01\x08!\n\r\n\x05\x04\x18\x02\x01\x04\x12\x04\xb8\x01\x08\x10\n\r\n\
    \x05\x04\x18\x02\x01\x05\x12\x04\xb8\x01\x11\x15\n\r\n\x05\x04\x18\x02\
    \x01\x01\x12\x04\xb8\x01\x16\x1c\n\r\n\x05\x04\x18\x02\x01\x03\x12\x04\
    \xb8\x01\x1f\x20\n\x0c\n\x02\x04\x19\x12\x06\xbb\x01\0\xbd\x01\x01\n\x0b\
    \n\x03\x04\x19\x01\x12\x04\xbb\x01\x08\x18\n\x0c\n\x04\x04\x19\x02\0\x12\
    \x04\xbc\x01\x08+\n\r\n\x05\x04\x19\x02\0\x04\x12\x04\xbc\x01\x08\x10\n\
    \r\n\x05\x04\x19\x02\0\x05\x12\x04\xbc\x01\x11\x17\n\r\n\x05\x04\x19\x02\
    \0\x01\x12\x04\xbc\x01\x18&\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\xbc\x01)\
    *\n\x0c\n\x02\x04\x1a\x12\x06\xbf\x01\0\xc1\x01\x01\n\x0b\n\x03\x04\x1a\
    \x01\x12\x04\xbf\x01\x08\x20\n\x0c\n\x04\x04\x1a\x02\0\x12\x04\xc0\x01\
    \x08+\n\r\n\x05\x04\x1a\x02\0\x04\x12\x04\xc0\x01\x08\x10\n\r\n\x05\x04\
    \x1a\x02\0\x05\x12\x04\xc0\x01\x11\x17\n\r\n\x05\x04\x1a\x02\0\x01\x12\
    \x04\xc0\x01\x18&\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\xc0\x01)*\n\x0c\n\
    \x02\x04\x1b\x12\x06\xc3\x01\0\xc5\x01\x01\n\x0b\n\x03\x04\x1b\x01\x12\
    \x04\xc3\x01\x08\x10\n\x0c\n\x04\x04\x1b\x02\0\x12\x04\xc4\x01\x08+\n\r\
    \n\x05\x04\x1b\x02\0\x04\x12\x04\xc4\x01\x08\x10\n\r\n\x05\x04\x1b\x02\0\
    \x05\x12\x04\xc4\x01\x11\x17\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\xc4\x01\
    \x18&\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\xc4\x01)*\n\x0c\n\x02\x04\x1c\
    \x12\x06\xc7\x01\0\xc9\x01\x01\n\x0b\n\x03\x04\x1c\x01\x12\x04\xc7\x01\
    \x08\x11\n\x0c\n\x04\x04\x1c\x02\0\x12\x04\xc8\x01\x08+\n\r\n\x05\x04\
    \x1c\x02\0\x04\x12\x04\xc8\x01\x08\x10\n\r\n\x05\x04\x1c\x02\0\x05\x12\
    \x04\xc8\x01\x11\x17\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\xc8\x01\x18&\n\
    \r\n\x05\x04\x1c\x02\0\x03\x12\x04\xc8\x01)*\n\x0c\n\x02\x04\x1d\x12\x06\
    \xcb\x01\0\xce\x01\x01\n\x0b\n\x03\x04\x1d\x01\x12\x04\xcb\x01\x08\x1d\n\
    \x0c\n\x04\x04\x1d\x02\0\x12\x04\xcc\x01\x08+\n\r\n\x05\x04\x1d\x02\0\
    \x04\x12\x04\xcc\x01\x08\x10\n\r\n\x05\x04\x1d\x02\0\x05\x12\x04\xcc\x01\
    \x11\x17\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\xcc\x01\x18&\n\r\n\x05\x04\
    \x1d\x02\0\x03\x12\x04\xcc\x01)*\n\x0c\n\x04\x04\x1d\x02\x01\x12\x04\xcd\
    \x01\x08#\n\r\n\x05\x04\x1d\x02\x01\x04\x12\x04\xcd\x01\x08\x10\n\r\n\
    \x05\x04\x1d\x02\x01\x05\x12\x04\xcd\x01\x11\x17\n\r\n\x05\x04\x1d\x02\
    \x01\x01\x12\x04\xcd\x01\x18\x1e\n\r\n\x05\x04\x1d\x02\x01\x03\x12\x04\
    \xcd\x01!\"\n\x0c\n\x02\x04\x1e\x12\x06\xd0\x01\0\xd3\x01\x01\n\x0b\n\
    \x03\x04\x1e\x01\x12\x04\xd0\x01\x08\x14\n\x0c\n\x04\x04\x1e\x02\0\x12\
    \x04\xd1\x01\x08+\n\r\n\x05\x04\x1e\x02\0\x04\x12\x04\xd1\x01\x08\x10\n\
    \r\n\x05\x04\x1e\x02\0\x05\x12\x04\xd1\x01\x11\x17\n\r\n\x05\x04\x1e\x02\
    \0\x01\x12\x04\xd1\x01\x18&\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\xd1\x01)\
    *\n\x0c\n\x04\x04\x1e\x02\x01\x12\x04\xd2\x01\x08\x20\n\r\n\x05\x04\x1e\
    \x02\x01\x04\x12\x04\xd2\x01\x08\x10\n\r\n\x05\x04\x1e\x02\x01\x05\x12\
    \x04\xd2\x01\x11\x15\n\r\n\x05\x04\x1e\x02\x01\x01\x12\x04\xd2\x01\x16\
    \x1b\n\r\n\x05\x04\x1e\x02\x01\x03\x12\x04\xd2\x01\x1e\x1f\n\x0c\n\x02\
    \x04\x1f\x12\x06\xd5\x01\0\xd7\x01\x01\n\x0b\n\x03\x04\x1f\x01\x12\x04\
    \xd5\x01\x08#\n\x0c\n\x04\x04\x1f\x02\0\x12\x04\xd6\x01\x08+\n\r\n\x05\
    \x04\x1f\x02\0\x04\x12\x04\xd6\x01\x08\x10\n\r\n\x05\x04\x1f\x02\0\x05\
    \x12\x04\xd6\x01\x11\x17\n\r\n\x05\x04\x1f\x02\0\x01\x12\x04\xd6\x01\x18\
    &\n\r\n\x05\x04\x1f\x02\0\x03\x12\x04\xd6\x01)*\n\x0c\n\x02\x04\x20\x12\
    \x06\xd9\x01\0\xe0\x01\x01\n\x0b\n\x03\x04\x20\x01\x12\x04\xd9\x01\x08+\
    \n\x0c\n\x04\x04\x20\x02\0\x12\x04\xda\x01\x08+\n\r\n\x05\x04\x20\x02\0\
    \x04\x12\x04\xda\x01\x08\x10\n\r\n\x05\x04\x20\x02\0\x05\x12\x04\xda\x01\
    \x11\x17\n\r\n\x05\x04\x20\x02\0\x01\x12\x04\xda\x01\x18&\n\r\n\x05\x04\
    \x20\x02\0\x03\x12\x04\xda\x01)*\n\x0c\n\x04\x04\x20\x02\x01\x12\x04\xdb\
    \x01\x08'\n\r\n\x05\x04\x20\x02\x01\x04\x12\x04\xdb\x01\x08\x10\n\r\n\
    \x05\x04\x20\x02\x01\x05\x12\x04\xdb\x01\x11\x17\n\r\n\x05\x04\x20\x02\
    \x01\x01\x12\x04\xdb\x01\x18\"\n\r\n\x05\x04\x20\x02\x01\x03\x12\x04\xdb\
    \x01%&\n\x0c\n\x04\x04\x20\x02\x02\x12\x04\xdc\x01\x08#\n\r\n\x05\x04\
    \x20\x02\x02\x04\x12\x04\xdc\x01\x08\x10\n\r\n\x05\x04\x20\x02\x02\x05\
    \x12\x04\xdc\x01\x11\x17\n\r\n\x05\x04\x20\x02\x02\x01\x12\x04\xdc\x01\
    \x18\x1e\n\r\n\x05\x04\x20\x02\x02\x03\x12\x04\xdc\x01!\"\n\x0c\n\x04\
    \x04\x20\x02\x03\x12\x04\xdd\x01\x08\x20\n\r\n\x05\x04\x20\x02\x03\x04\
    \x12\x04\xdd\x01\x08\x10\n\r\n\x05\x04\x20\x02\x03\x05\x12\x04\xdd\x01\
    \x11\x16\n\r\n\x05\x04\x20\x02\x03\x01\x12\x04\xdd\x01\x17\x1b\n\r\n\x05\
    \x04\x20\x02\x03\x03\x12\x04\xdd\x01\x1e\x1f\n\x0c\n\x04\x04\x20\x02\x04\
    \x12\x04\xde\x01\x08\"\n\r\n\x05\x04\x20\x02\x04\x04\x12\x04\xde\x01\x08\
    \x10\n\r\n\x05\x04\x20\x02\x04\x05\x12\x04\xde\x01\x11\x15\n\r\n\x05\x04\
    \x20\x02\x04\x01\x12\x04\xde\x01\x16\x1d\n\r\n\x05\x04\x20\x02\x04\x03\
    \x12\x04\xde\x01\x20!\n\x0c\n\x04\x04\x20\x02\x05\x12\x04\xdf\x01\x08'\n\
    \r\n\x05\x04\x20\x02\x05\x04\x12\x04\xdf\x01\x08\x10\n\r\n\x05\x04\x20\
    \x02\x05\x05\x12\x04\xdf\x01\x11\x17\n\r\n\x05\x04\x20\x02\x05\x01\x12\
    \x04\xdf\x01\x18!\n\r\n\x05\x04\x20\x02\x05\x03\x12\x04\xdf\x01$&\n\x0c\
    \n\x02\x04!\x12\x06\xe2\x01\0\xe4\x01\x01\n\x0b\n\x03\x04!\x01\x12\x04\
    \xe2\x01\x08!\n\x0c\n\x04\x04!\x02\0\x12\x04\xe3\x01\x08+\n\r\n\x05\x04!\
    \x02\0\x04\x12\x04\xe3\x01\x08\x10\n\r\n\x05\x04!\x02\0\x05\x12\x04\xe3\
    \x01\x11\x17\n\r\n\x05\x04!\x02\0\x01\x12\x04\xe3\x01\x18&\n\r\n\x05\x04\
    !\x02\0\x03\x12\x04\xe3\x01)*\n\x0c\n\x02\x04\"\x12\x06\xe6\x01\0\xed\
    \x01\x01\n\x0b\n\x03\x04\"\x01\x12\x04\xe6\x01\x08)\n\x0c\n\x04\x04\"\
    \x02\0\x12\x04\xe7\x01\x08+\n\r\n\x05\x04\"\x02\0\x04\x12\x04\xe7\x01\
    \x08\x10\n\r\n\x05\x04\"\x02\0\x05\x12\x04\xe7\x01\x11\x17\n\r\n\x05\x04\
    \"\x02\0\x01\x12\x04\xe7\x01\x18&\n\r\n\x05\x04\"\x02\0\x03\x12\x04\xe7\
    \x01)*\n\x0c\n\x04\x04\"\x02\x01\x12\x04\xe8\x01\x08'\n\r\n\x05\x04\"\
    \x02\x01\x04\x12\x04\xe8\x01\x08\x10\n\r\n\x05\x04\"\x02\x01\x05\x12\x04\
    \xe8\x01\x11\x17\n\r\n\x05\x04\"\x02\x01\x01\x12\x04\xe8\x01\x18\"\n\r\n\
    \x05\x04\"\x02\x01\x03\x12\x04\xe8\x01%&\n\x0c\n\x04\x04\"\x02\x02\x12\
    \x04\xe9\x01\x08#\n\r\n\x05\x04\"\x02\x02\x04\x12\x04\xe9\x01\x08\x10\n\
    \r\n\x05\x04\"\x02\x02\x05\x12\x04\xe9\x01\x11\x17\n\r\n\x05\x04\"\x02\
    \x02\x01\x12\x04\xe9\x01\x18\x1e\n\r\n\x05\x04\"\x02\x02\x03\x12\x04\xe9\
    \x01!\"\n\x0c\n\x04\x04\"\x02\x03\x12\x04\xea\x01\x08\x20\n\r\n\x05\x04\
    \"\x02\x03\x04\x12\x04\xea\x01\x08\x10\n\r\n\x05\x04\"\x02\x03\x05\x12\
    \x04\xea\x01\x11\x16\n\r\n\x05\x04\"\x02\x03\x01\x12\x04\xea\x01\x17\x1b\
    \n\r\n\x05\x04\"\x02\x03\x03\x12\x04\xea\x01\x1e\x1f\n\x0c\n\x04\x04\"\
    \x02\x04\x12\x04\xeb\x01\x08\"\n\r\n\x05\x04\"\x02\x04\x04\x12\x04\xeb\
    \x01\x08\x10\n\r\n\x05\x04\"\x02\x04\x05\x12\x04\xeb\x01\x11\x15\n\r\n\
    \x05\x04\"\x02\x04\x01\x12\x04\xeb\x01\x16\x1d\n\r\n\x05\x04\"\x02\x04\
    \x03\x12\x04\xeb\x01\x20!\n\x0c\n\x04\x04\"\x02\x05\x12\x04\xec\x01\x08'\
    \n\r\n\x05\x04\"\x02\x05\x04\x12\x04\xec\x01\x08\x10\n\r\n\x05\x04\"\x02\
    \x05\x05\x12\x04\xec\x01\x11\x17\n\r\n\x05\x04\"\x02\x05\x01\x12\x04\xec\
    \x01\x18!\n\r\n\x05\x04\"\x02\x05\x03\x12\x04\xec\x01$&\n\x0c\n\x02\x04#\
    \x12\x06\xef\x01\0\xf4\x01\x01\n\x0b\n\x03\x04#\x01\x12\x04\xef\x01\x08\
    \x10\n\x0c\n\x04\x04#\x02\0\x12\x04\xf0\x01\x08+\n\r\n\x05\x04#\x02\0\
    \x04\x12\x04\xf0\x01\x08\x10\n\r\n\x05\x04#\x02\0\x05\x12\x04\xf0\x01\
    \x11\x17\n\r\n\x05\x04#\x02\0\x01\x12\x04\xf0\x01\x18&\n\r\n\x05\x04#\
    \x02\0\x03\x12\x04\xf0\x01)*\n\x0c\n\x04\x04#\x02\x01\x12\x04\xf1\x01\
    \x08!\n\r\n\x05\x04#\x02\x01\x04\x12\x04\xf1\x01\x08\x10\n\r\n\x05\x04#\
    \x02\x01\x05\x12\x04\xf1\x01\x11\x17\n\r\n\x05\x04#\x02\x01\x01\x12\x04\
    \xf1\x01\x18\x1c\n\r\n\x05\x04#\x02\x01\x03\x12\x04\xf1\x01\x1f\x20\n\
    \x0c\n\x04\x04#\x02\x02\x12\x04\xf2\x01\x08!\n\r\n\x05\x04#\x02\x02\x04\
    \x12\x04\xf2\x01\x08\x10\n\r\n\x05\x04#\x02\x02\x05\x12\x04\xf2\x01\x11\
    \x15\n\r\n\x05\x04#\x02\x02\x01\x12\x04\xf2\x01\x16\x1c\n\r\n\x05\x04#\
    \x02\x02\x03\x12\x04\xf2\x01\x1f\x20\n\x0c\n\x04\x04#\x02\x03\x12\x04\
    \xf3\x01\x084\n\r\n\x05\x04#\x02\x03\x04\x12\x04\xf3\x01\x08\x10\n\r\n\
    \x05\x04#\x02\x03\x05\x12\x04\xf3\x01\x11\x15\n\r\n\x05\x04#\x02\x03\x01\
    \x12\x04\xf3\x01\x16\x1d\n\r\n\x05\x04#\x02\x03\x03\x12\x04\xf3\x01\x20!\
    \n\r\n\x05\x04#\x02\x03\x08\x12\x04\xf3\x01\"3\n\r\n\x05\x04#\x02\x03\
    \x07\x12\x04\xf3\x01-2\n\x0c\n\x02\x04$\x12\x06\xf6\x01\0\xf8\x01\x01\n\
    \x0b\n\x03\x04$\x01\x12\x04\xf6\x01\x08\x14\n\x0c\n\x04\x04$\x02\0\x12\
    \x04\xf7\x01\x08+\n\r\n\x05\x04$\x02\0\x04\x12\x04\xf7\x01\x08\x10\n\r\n\
    \x05\x04$\x02\0\x05\x12\x04\xf7\x01\x11\x17\n\r\n\x05\x04$\x02\0\x01\x12\
    \x04\xf7\x01\x18&\n\r\n\x05\x04$\x02\0\x03\x12\x04\xf7\x01)*\n\x0c\n\x02\
    \x04%\x12\x06\xfa\x01\0\xfd\x01\x01\n\x0b\n\x03\x04%\x01\x12\x04\xfa\x01\
    \x08\x1f\n\x0c\n\x04\x04%\x02\0\x12\x04\xfb\x01\x08+\n\r\n\x05\x04%\x02\
    \0\x04\x12\x04\xfb\x01\x08\x10\n\r\n\x05\x04%\x02\0\x05\x12\x04\xfb\x01\
    \x11\x17\n\r\n\x05\x04%\x02\0\x01\x12\x04\xfb\x01\x18&\n\r\n\x05\x04%\
    \x02\0\x03\x12\x04\xfb\x01)*\n\x0c\n\x04\x04%\x02\x01\x12\x04\xfc\x01\
    \x08#\n\r\n\x05\x04%\x02\x01\x04\x12\x04\xfc\x01\x08\x10\n\r\n\x05\x04%\
    \x02\x01\x05\x12\x04\xfc\x01\x11\x17\n\r\n\x05\x04%\x02\x01\x01\x12\x04\
    \xfc\x01\x18\x1e\n\r\n\x05\x04%\x02\x01\x03\x12\x04\xfc\x01!\"\n\x0c\n\
    \x02\x04&\x12\x06\xff\x01\0\x82\x02\x01\n\x0b\n\x03\x04&\x01\x12\x04\xff\
    \x01\x08\x1d\n\x0c\n\x04\x04&\x02\0\x12\x04\x80\x02\x08+\n\r\n\x05\x04&\
    \x02\0\x04\x12\x04\x80\x02\x08\x10\n\r\n\x05\x04&\x02\0\x05\x12\x04\x80\
    \x02\x11\x17\n\r\n\x05\x04&\x02\0\x01\x12\x04\x80\x02\x18&\n\r\n\x05\x04\
    &\x02\0\x03\x12\x04\x80\x02)*\n\x0c\n\x04\x04&\x02\x01\x12\x04\x81\x02\
    \x08#\n\r\n\x05\x04&\x02\x01\x04\x12\x04\x81\x02\x08\x10\n\r\n\x05\x04&\
    \x02\x01\x05\x12\x04\x81\x02\x11\x17\n\r\n\x05\x04&\x02\x01\x01\x12\x04\
    \x81\x02\x18\x1e\n\r\n\x05\x04&\x02\x01\x03\x12\x04\x81\x02!\"\n\x0c\n\
    \x02\x04'\x12\x06\x84\x02\0\x87\x02\x01\n\x0b\n\x03\x04'\x01\x12\x04\x84\
    \x02\x08\x18\n\x0c\n\x04\x04'\x02\0\x12\x04\x85\x02\x08+\n\r\n\x05\x04'\
    \x02\0\x04\x12\x04\x85\x02\x08\x10\n\r\n\x05\x04'\x02\0\x05\x12\x04\x85\
    \x02\x11\x17\n\r\n\x05\x04'\x02\0\x01\x12\x04\x85\x02\x18&\n\r\n\x05\x04\
    '\x02\0\x03\x12\x04\x85\x02)*\n\x0c\n\x04\x04'\x02\x01\x12\x04\x86\x02\
    \x08!\n\r\n\x05\x04'\x02\x01\x04\x12\x04\x86\x02\x08\x10\n\r\n\x05\x04'\
    \x02\x01\x05\x12\x04\x86\x02\x11\x17\n\r\n\x05\x04'\x02\x01\x01\x12\x04\
    \x86\x02\x18\x1c\n\r\n\x05\x04'\x02\x01\x03\x12\x04\x86\x02\x1f\x20\n\
    \x0c\n\x02\x04(\x12\x06\x89\x02\0\x8b\x02\x01\n\x0b\n\x03\x04(\x01\x12\
    \x04\x89\x02\x08\x16\n\x0c\n\x04\x04(\x02\0\x12\x04\x8a\x02\x08+\n\r\n\
    \x05\x04(\x02\0\x04\x12\x04\x8a\x02\x08\x10\n\r\n\x05\x04(\x02\0\x05\x12\
    \x04\x8a\x02\x11\x17\n\r\n\x05\x04(\x02\0\x01\x12\x04\x8a\x02\x18&\n\r\n\
    \x05\x04(\x02\0\x03\x12\x04\x8a\x02)*\n\x0c\n\x02\x04)\x12\x06\x8d\x02\0\
    \x91\x02\x01\n\x0b\n\x03\x04)\x01\x12\x04\x8d\x02\x08\x18\n\x0c\n\x04\
    \x04)\x02\0\x12\x04\x8e\x02\x08+\n\r\n\x05\x04)\x02\0\x04\x12\x04\x8e\
    \x02\x08\x10\n\r\n\x05\x04)\x02\0\x05\x12\x04\x8e\x02\x11\x17\n\r\n\x05\
    \x04)\x02\0\x01\x12\x04\x8e\x02\x18&\n\r\n\x05\x04)\x02\0\x03\x12\x04\
    \x8e\x02)*\n\x0c\n\x04\x04)\x02\x01\x12\x04\x8f\x02\x08+\n\r\n\x05\x04)\
    \x02\x01\x04\x12\x04\x8f\x02\x08\x10\n\r\n\x05\x04)\x02\x01\x05\x12\x04\
    \x8f\x02\x11\x17\n\r\n\x05\x04)\x02\x01\x01\x12\x04\x8f\x02\x18&\n\r\n\
    \x05\x04)\x02\x01\x03\x12\x04\x8f\x02)*\n\x0c\n\x04\x04)\x02\x02\x12\x04\
    \x90\x02\x08*\n\r\n\x05\x04)\x02\x02\x04\x12\x04\x90\x02\x08\x10\n\r\n\
    \x05\x04)\x02\x02\x05\x12\x04\x90\x02\x11\x18\n\r\n\x05\x04)\x02\x02\x01\
    \x12\x04\x90\x02\x19%\n\r\n\x05\x04)\x02\x02\x03\x12\x04\x90\x02()\n\x0c\
    \n\x02\x04*\x12\x06\x93\x02\0\x9a\x02\x01\n\x0b\n\x03\x04*\x01\x12\x04\
    \x93\x02\x08\x16\n\x0c\n\x04\x04*\x02\0\x12\x04\x94\x02\x08+\n\r\n\x05\
    \x04*\x02\0\x04\x12\x04\x94\x02\x08\x10\n\r\n\x05\x04*\x02\0\x05\x12\x04\
    \x94\x02\x11\x17\n\r\n\x05\x04*\x02\0\x01\x12\x04\x94\x02\x18&\n\r\n\x05\
    \x04*\x02\0\x03\x12\x04\x94\x02)*\n\x0c\n\x04\x04*\x02\x01\x12\x04\x95\
    \x02\x08\x20\n\r\n\x05\x04*\x02\x01\x04\x12\x04\x95\x02\x08\x10\n\r\n\
    \x05\x04*\x02\x01\x05\x12\x04\x95\x02\x11\x17\n\r\n\x05\x04*\x02\x01\x01\
    \x12\x04\x95\x02\x18\x1b\n\r\n\x05\x04*\x02\x01\x03\x12\x04\x95\x02\x1e\
    \x1f\n\x0c\n\x04\x04*\x02\x02\x12\x04\x96\x02\x08%\n\r\n\x05\x04*\x02\
    \x02\x04\x12\x04\x96\x02\x08\x10\n\r\n\x05\x04*\x02\x02\x05\x12\x04\x96\
    \x02\x11\x17\n\r\n\x05\x04*\x02\x02\x01\x12\x04\x96\x02\x18\x20\n\r\n\
    \x05\x04*\x02\x02\x03\x12\x04\x96\x02#$\n\x0c\n\x04\x04*\x02\x03\x12\x04\
    \x97\x02\x08&\n\r\n\x05\x04*\x02\x03\x04\x12\x04\x97\x02\x08\x10\n\r\n\
    \x05\x04*\x02\x03\x05\x12\x04\x97\x02\x11\x15\n\r\n\x05\x04*\x02\x03\x01\
    \x12\x04\x97\x02\x16!\n\r\n\x05\x04*\x02\x03\x03\x12\x04\x97\x02$%\n\x0c\
    \n\x04\x04*\x02\x04\x12\x04\x98\x02\x08&\n\r\n\x05\x04*\x02\x04\x04\x12\
    \x04\x98\x02\x08\x10\n\r\n\x05\x04*\x02\x04\x05\x12\x04\x98\x02\x11\x17\
    \n\r\n\x05\x04*\x02\x04\x01\x12\x04\x98\x02\x18!\n\r\n\x05\x04*\x02\x04\
    \x03\x12\x04\x98\x02$%\n\x0c\n\x04\x04*\x02\x05\x12\x04\x99\x02\x08)\n\r\
    \n\x05\x04*\x02\x05\x04\x12\x04\x99\x02\x08\x10\n\r\n\x05\x04*\x02\x05\
    \x05\x12\x04\x99\x02\x11\x15\n\r\n\x05\x04*\x02\x05\x01\x12\x04\x99\x02\
    \x16$\n\r\n\x05\x04*\x02\x05\x03\x12\x04\x99\x02'(\n\x0c\n\x02\x04+\x12\
    \x06\x9c\x02\0\x9f\x02\x01\n\x0b\n\x03\x04+\x01\x12\x04\x9c\x02\x08\x13\
    \n\x0c\n\x04\x04+\x02\0\x12\x04\x9d\x02\x08\x20\n\r\n\x05\x04+\x02\0\x04\
    \x12\x04\x9d\x02\x08\x10\n\r\n\x05\x04+\x02\0\x05\x12\x04\x9d\x02\x11\
    \x17\n\r\n\x05\x04+\x02\0\x01\x12\x04\x9d\x02\x18\x1b\n\r\n\x05\x04+\x02\
    \0\x03\x12\x04\x9d\x02\x1e\x1f\n\x0c\n\x04\x04+\x02\x01\x12\x04\x9e\x02\
    \x08\"\n\r\n\x05\x04+\x02\x01\x04\x12\x04\x9e\x02\x08\x10\n\r\n\x05\x04+\
    \x02\x01\x05\x12\x04\x9e\x02\x11\x17\n\r\n\x05\x04+\x02\x01\x01\x12\x04\
    \x9e\x02\x18\x1d\n\r\n\x05\x04+\x02\x01\x03\x12\x04\x9e\x02\x20!\n\x0c\n\
    \x02\x04,\x12\x06\xa1\x02\0\xa9\x02\x01\n\x0b\n\x03\x04,\x01\x12\x04\xa1\
    \x02\x08\x1d\n\x0c\n\x04\x04,\x02\0\x12\x04\xa2\x02\x086\n\r\n\x05\x04,\
    \x02\0\x04\x12\x04\xa2\x02\x08\x10\n\r\n\x05\x04,\x02\0\x05\x12\x04\xa2\
    \x02\x11\x15\n\r\n\x05\x04,\x02\0\x01\x12\x04\xa2\x02\x16\x1f\n\r\n\x05\
    \x04,\x02\0\x03\x12\x04\xa2\x02\"#\n\r\n\x05\x04,\x02\0\x08\x12\x04\xa2\
    \x02$5\n\r\n\x05\x04,\x02\0\x07\x12\x04\xa2\x02/4\n\x0c\n\x04\x04,\x02\
    \x01\x12\x04\xa3\x02\x08:\n\r\n\x05\x04,\x02\x01\x04\x12\x04\xa3\x02\x08\
    \x10\n\r\n\x05\x04,\x02\x01\x05\x12\x04\xa3\x02\x11\x15\n\r\n\x05\x04,\
    \x02\x01\x01\x12\x04\xa3\x02\x16#\n\r\n\x05\x04,\x02\x01\x03\x12\x04\xa3\
    \x02&'\n\r\n\x05\x04,\x02\x01\x08\x12\x04\xa3\x02(9\n\r\n\x05\x04,\x02\
    \x01\x07\x12\x04\xa3\x0238\n\x0c\n\x04\x04,\x02\x02\x12\x04\xa4\x02\x08'\
    \n\r\n\x05\x04,\x02\x02\x04\x12\x04\xa4\x02\x08\x10\n\r\n\x05\x04,\x02\
    \x02\x05\x12\x04\xa4\x02\x11\x17\n\r\n\x05\x04,\x02\x02\x01\x12\x04\xa4\
    \x02\x18\"\n\r\n\x05\x04,\x02\x02\x03\x12\x04\xa4\x02%&\n\x0c\n\x04\x04,\
    \x02\x03\x12\x04\xa5\x02\x08%\n\r\n\x05\x04,\x02\x03\x04\x12\x04\xa5\x02\
    \x08\x10\n\r\n\x05\x04,\x02\x03\x05\x12\x04\xa5\x02\x11\x17\n\r\n\x05\
    \x04,\x02\x03\x01\x12\x04\xa5\x02\x18\x20\n\r\n\x05\x04,\x02\x03\x03\x12\
    \x04\xa5\x02#$\n\x0c\n\x04\x04,\x02\x04\x12\x04\xa6\x02\x084\n\r\n\x05\
    \x04,\x02\x04\x04\x12\x04\xa6\x02\x08\x10\n\r\n\x05\x04,\x02\x04\x05\x12\
    \x04\xa6\x02\x11\x16\n\r\n\x05\x04,\x02\x04\x01\x12\x04\xa6\x02\x17!\n\r\
    \n\x05\x04,\x02\x04\x03\x12\x04\xa6\x02$%\n\r\n\x05\x04,\x02\x04\x08\x12\
    \x04\xa6\x02&3\n\r\n\x05\x04,\x02\x04\x07\x12\x04\xa6\x0212\n\x0c\n\x04\
    \x04,\x02\x05\x12\x04\xa7\x02\x083\n\r\n\x05\x04,\x02\x05\x04\x12\x04\
    \xa7\x02\x08\x10\n\r\n\x05\x04,\x02\x05\x05\x12\x04\xa7\x02\x11\x16\n\r\
    \n\x05\x04,\x02\x05\x01\x12\x04\xa7\x02\x17\x20\n\r\n\x05\x04,\x02\x05\
    \x03\x12\x04\xa7\x02#$\n\r\n\x05\x04,\x02\x05\x08\x12\x04\xa7\x02%2\n\r\
    \n\x05\x04,\x02\x05\x07\x12\x04\xa7\x0201\n\x0c\n\x04\x04,\x02\x06\x12\
    \x04\xa8\x02\x086\n\r\n\x05\x04,\x02\x06\x04\x12\x04\xa8\x02\x08\x10\n\r\
    \n\x05\x04,\x02\x06\x05\x12\x04\xa8\x02\x11\x15\n\r\n\x05\x04,\x02\x06\
    \x01\x12\x04\xa8\x02\x16\x1f\n\r\n\x05\x04,\x02\x06\x03\x12\x04\xa8\x02\
    \"#\n\r\n\x05\x04,\x02\x06\x08\x12\x04\xa8\x02$5\n\r\n\x05\x04,\x02\x06\
    \x07\x12\x04\xa8\x02/4\n\x0c\n\x02\x04-\x12\x06\xab\x02\0\xaf\x02\x01\n\
    \x0b\n\x03\x04-\x01\x12\x04\xab\x02\x08\x1b\n\x0c\n\x04\x04-\x02\0\x12\
    \x04\xac\x02\x08+\n\r\n\x05\x04-\x02\0\x04\x12\x04\xac\x02\x08\x10\n\r\n\
    \x05\x04-\x02\0\x05\x12\x04\xac\x02\x11\x17\n\r\n\x05\x04-\x02\0\x01\x12\
    \x04\xac\x02\x18&\n\r\n\x05\x04-\x02\0\x03\x12\x04\xac\x02)*\n\x0c\n\x04\
    \x04-\x02\x01\x12\x04\xad\x02\x08\x20\n\r\n\x05\x04-\x02\x01\x04\x12\x04\
    \xad\x02\x08\x10\n\r\n\x05\x04-\x02\x01\x05\x12\x04\xad\x02\x11\x17\n\r\
    \n\x05\x04-\x02\x01\x01\x12\x04\xad\x02\x18\x1b\n\r\n\x05\x04-\x02\x01\
    \x03\x12\x04\xad\x02\x1e\x1f\n\x0c\n\x04\x04-\x02\x02\x12\x04\xae\x02\
    \x08&\n\r\n\x05\x04-\x02\x02\x04\x12\x04\xae\x02\x08\x10\n\r\n\x05\x04-\
    \x02\x02\x05\x12\x04\xae\x02\x11\x17\n\r\n\x05\x04-\x02\x02\x01\x12\x04\
    \xae\x02\x18!\n\r\n\x05\x04-\x02\x02\x03\x12\x04\xae\x02$%\n\x0c\n\x02\
    \x04.\x12\x06\xb1\x02\0\xb6\x02\x01\n\x0b\n\x03\x04.\x01\x12\x04\xb1\x02\
    \x08\x19\n\x0c\n\x04\x04.\x02\0\x12\x04\xb2\x02\x08+\n\r\n\x05\x04.\x02\
    \0\x04\x12\x04\xb2\x02\x08\x10\n\r\n\x05\x04.\x02\0\x05\x12\x04\xb2\x02\
    \x11\x17\n\r\n\x05\x04.\x02\0\x01\x12\x04\xb2\x02\x18&\n\r\n\x05\x04.\
    \x02\0\x03\x12\x04\xb2\x02)*\n\x0c\n\x04\x04.\x02\x01\x12\x04\xb3\x02\
    \x08\x20\n\r\n\x05\x04.\x02\x01\x04\x12\x04\xb3\x02\x08\x10\n\r\n\x05\
    \x04.\x02\x01\x05\x12\x04\xb3\x02\x11\x17\n\r\n\x05\x04.\x02\x01\x01\x12\
    \x04\xb3\x02\x18\x1b\n\r\n\x05\x04.\x02\x01\x03\x12\x04\xb3\x02\x1e\x1f\
    \n\x0c\n\x04\x04.\x02\x02\x12\x04\xb4\x02\x08&\n\r\n\x05\x04.\x02\x02\
    \x04\x12\x04\xb4\x02\x08\x10\n\r\n\x05\x04.\x02\x02\x05\x12\x04\xb4\x02\
    \x11\x17\n\r\n\x05\x04.\x02\x02\x01\x12\x04\xb4\x02\x18!\n\r\n\x05\x04.\
    \x02\x02\x03\x12\x04\xb4\x02$%\n\x0c\n\x04\x04.\x02\x03\x12\x04\xb5\x02\
    \x08*\n\r\n\x05\x04.\x02\x03\x04\x12\x04\xb5\x02\x08\x10\n\r\n\x05\x04.\
    \x02\x03\x06\x12\x04\xb5\x02\x11\x1d\n\r\n\x05\x04.\x02\x03\x01\x12\x04\
    \xb5\x02\x1e%\n\r\n\x05\x04.\x02\x03\x03\x12\x04\xb5\x02()\n\x0c\n\x02\
    \x04/\x12\x06\xb8\x02\0\xbc\x02\x01\n\x0b\n\x03\x04/\x01\x12\x04\xb8\x02\
    \x08\x18\n\x0c\n\x04\x04/\x02\0\x12\x04\xb9\x02\x08+\n\r\n\x05\x04/\x02\
    \0\x04\x12\x04\xb9\x02\x08\x10\n\r\n\x05\x04/\x02\0\x05\x12\x04\xb9\x02\
    \x11\x17\n\r\n\x05\x04/\x02\0\x01\x12\x04\xb9\x02\x18&\n\r\n\x05\x04/\
    \x02\0\x03\x12\x04\xb9\x02)*\n\x0c\n\x04\x04/\x02\x01\x12\x04\xba\x02\
    \x08\x20\n\r\n\x05\x04/\x02\x01\x04\x12\x04\xba\x02\x08\x10\n\r\n\x05\
    \x04/\x02\x01\x05\x12\x04\xba\x02\x11\x17\n\r\n\x05\x04/\x02\x01\x01\x12\
    \x04\xba\x02\x18\x1b\n\r\n\x05\x04/\x02\x01\x03\x12\x04\xba\x02\x1e\x1f\
    \n\x0c\n\x04\x04/\x02\x02\x12\x04\xbb\x02\x08:\n\r\n\x05\x04/\x02\x02\
    \x04\x12\x04\xbb\x02\x08\x10\n\r\n\x05\x04/\x02\x02\x06\x12\x04\xbb\x02\
    \x11'\n\r\n\x05\x04/\x02\x02\x01\x12\x04\xbb\x02(5\n\r\n\x05\x04/\x02\
    \x02\x03\x12\x04\xbb\x0289\n\x0c\n\x02\x040\x12\x06\xbe\x02\0\xc4\x02\
    \x01\n\x0b\n\x03\x040\x01\x12\x04\xbe\x02\x08\x18\n\x0c\n\x04\x040\x02\0\
    \x12\x04\xbf\x02\x08+\n\r\n\x05\x040\x02\0\x04\x12\x04\xbf\x02\x08\x10\n\
    \r\n\x05\x040\x02\0\x05\x12\x04\xbf\x02\x11\x17\n\r\n\x05\x040\x02\0\x01\
    \x12\x04\xbf\x02\x18&\n\r\n\x05\x040\x02\0\x03\x12\x04\xbf\x02)*\n\x0c\n\
    \x04\x040\x02\x01\x12\x04\xc0\x02\x08\x20\n\r\n\x05\x040\x02\x01\x04\x12\
    \x04\xc0\x02\x08\x10\n\r\n\x05\x040\x02\x01\x05\x12\x04\xc0\x02\x11\x17\
    \n\r\n\x05\x040\x02\x01\x01\x12\x04\xc0\x02\x18\x1b\n\r\n\x05\x040\x02\
    \x01\x03\x12\x04\xc0\x02\x1e\x1f\n\x0c\n\x04\x040\x02\x02\x12\x04\xc1\
    \x02\x08#\n\r\n\x05\x040\x02\x02\x04\x12\x04\xc1\x02\x08\x10\n\r\n\x05\
    \x040\x02\x02\x05\x12\x04\xc1\x02\x11\x17\n\r\n\x05\x040\x02\x02\x01\x12\
    \x04\xc1\x02\x18\x1e\n\r\n\x05\x040\x02\x02\x03\x12\x04\xc1\x02!\"\n\x0c\
    \n\x04\x040\x02\x03\x12\x04\xc2\x02\x08%\n\r\n\x05\x040\x02\x03\x04\x12\
    \x04\xc2\x02\x08\x10\n\r\n\x05\x040\x02\x03\x05\x12\x04\xc2\x02\x11\x17\
    \n\r\n\x05\x040\x02\x03\x01\x12\x04\xc2\x02\x18\x20\n\r\n\x05\x040\x02\
    \x03\x03\x12\x04\xc2\x02#$\n\x0c\n\x04\x040\x02\x04\x12\x04\xc3\x02\x08&\
    \n\r\n\x05\x040\x02\x04\x04\x12\x04\xc3\x02\x08\x10\n\r\n\x05\x040\x02\
    \x04\x05\x12\x04\xc3\x02\x11\x15\n\r\n\x05\x040\x02\x04\x01\x12\x04\xc3\
    \x02\x16!\n\r\n\x05\x040\x02\x04\x03\x12\x04\xc3\x02$%\n\x0c\n\x02\x041\
    \x12\x06\xc6\x02\0\xc9\x02\x01\n\x0b\n\x03\x041\x01\x12\x04\xc6\x02\x08\
    \x20\n\x0c\n\x04\x041\x02\0\x12\x04\xc7\x02\x08+\n\r\n\x05\x041\x02\0\
    \x04\x12\x04\xc7\x02\x08\x10\n\r\n\x05\x041\x02\0\x05\x12\x04\xc7\x02\
    \x11\x17\n\r\n\x05\x041\x02\0\x01\x12\x04\xc7\x02\x18&\n\r\n\x05\x041\
    \x02\0\x03\x12\x04\xc7\x02)*\n\x0c\n\x04\x041\x02\x01\x12\x04\xc8\x02\
    \x08!\n\r\n\x05\x041\x02\x01\x04\x12\x04\xc8\x02\x08\x10\n\r\n\x05\x041\
    \x02\x01\x05\x12\x04\xc8\x02\x11\x15\n\r\n\x05\x041\x02\x01\x01\x12\x04\
    \xc8\x02\x16\x1c\n\r\n\x05\x041\x02\x01\x03\x12\x04\xc8\x02\x1f\x20\n\
    \x0c\n\x02\x042\x12\x06\xcb\x02\0\xcd\x02\x01\n\x0b\n\x03\x042\x01\x12\
    \x04\xcb\x02\x08\x15\n\x0c\n\x04\x042\x02\0\x12\x04\xcc\x02\x08+\n\r\n\
    \x05\x042\x02\0\x04\x12\x04\xcc\x02\x08\x10\n\r\n\x05\x042\x02\0\x05\x12\
    \x04\xcc\x02\x11\x17\n\r\n\x05\x042\x02\0\x01\x12\x04\xcc\x02\x18&\n\r\n\
    \x05\x042\x02\0\x03\x12\x04\xcc\x02)*\n\x0c\n\x02\x043\x12\x06\xcf\x02\0\
    \xd1\x02\x01\n\x0b\n\x03\x043\x01\x12\x04\xcf\x02\x08\x15\n\x0c\n\x04\
    \x043\x02\0\x12\x04\xd0\x02\x08+\n\r\n\x05\x043\x02\0\x04\x12\x04\xd0\
    \x02\x08\x10\n\r\n\x05\x043\x02\0\x05\x12\x04\xd0\x02\x11\x17\n\r\n\x05\
    \x043\x02\0\x01\x12\x04\xd0\x02\x18&\n\r\n\x05\x043\x02\0\x03\x12\x04\
    \xd0\x02)*\n\x0c\n\x02\x044\x12\x06\xd3\x02\0\xd9\x02\x01\n\x0b\n\x03\
    \x044\x01\x12\x04\xd3\x02\x08\x15\n\x0c\n\x04\x044\x02\0\x12\x04\xd4\x02\
    \x08+\n\r\n\x05\x044\x02\0\x04\x12\x04\xd4\x02\x08\x10\n\r\n\x05\x044\
    \x02\0\x05\x12\x04\xd4\x02\x11\x17\n\r\n\x05\x044\x02\0\x01\x12\x04\xd4\
    \x02\x18&\n\r\n\x05\x044\x02\0\x03\x12\x04\xd4\x02)*\n\x0c\n\x04\x044\
    \x02\x01\x12\x04\xd5\x02\x08\x1d\n\r\n\x05\x044\x02\x01\x04\x12\x04\xd5\
    \x02\x08\x10\n\r\n\x05\x044\x02\x01\x05\x12\x04\xd5\x02\x11\x16\n\r\n\
    \x05\x044\x02\x01\x01\x12\x04\xd5\x02\x17\x18\n\r\n\x05\x044\x02\x01\x03\
    \x12\x04\xd5\x02\x1b\x1c\n\x0c\n\x04\x044\x02\x02\x12\x04\xd6\x02\x08\
    \x1d\n\r\n\x05\x044\x02\x02\x04\x12\x04\xd6\x02\x08\x10\n\r\n\x05\x044\
    \x02\x02\x05\x12\x04\xd6\x02\x11\x16\n\r\n\x05\x044\x02\x02\x01\x12\x04\
    \xd6\x02\x17\x18\n\r\n\x05\x044\x02\x02\x03\x12\x04\xd6\x02\x1b\x1c\n\
    \x0c\n\x04\x044\x02\x03\x12\x04\xd7\x02\x08!\n\r\n\x05\x044\x02\x03\x04\
    \x12\x04\xd7\x02\x08\x10\n\r\n\x05\x044\x02\x03\x05\x12\x04\xd7\x02\x11\
    \x17\n\r\n\x05\x044\x02\x03\x01\x12\x04\xd7\x02\x18\x1c\n\r\n\x05\x044\
    \x02\x03\x03\x12\x04\xd7\x02\x1f\x20\n\x0c\n\x04\x044\x02\x04\x12\x04\
    \xd8\x02\x08!\n\r\n\x05\x044\x02\x04\x04\x12\x04\xd8\x02\x08\x10\n\r\n\
    \x05\x044\x02\x04\x05\x12\x04\xd8\x02\x11\x17\n\r\n\x05\x044\x02\x04\x01\
    \x12\x04\xd8\x02\x18\x1c\n\r\n\x05\x044\x02\x04\x03\x12\x04\xd8\x02\x1f\
    \x20\n\x0c\n\x02\x045\x12\x06\xdb\x02\0\xdf\x02\x01\n\x0b\n\x03\x045\x01\
    \x12\x04\xdb\x02\x08\x16\n\x0c\n\x04\x045\x02\0\x12\x04\xdc\x02\x08+\n\r\
    \n\x05\x045\x02\0\x04\x12\x04\xdc\x02\x08\x10\n\r\n\x05\x045\x02\0\x05\
    \x12\x04\xdc\x02\x11\x17\n\r\n\x05\x045\x02\0\x01\x12\x04\xdc\x02\x18&\n\
    \r\n\x05\x045\x02\0\x03\x12\x04\xdc\x02)*\n\x0c\n\x04\x045\x02\x01\x12\
    \x04\xdd\x02\x08\x20\n\r\n\x05\x045\x02\x01\x04\x12\x04\xdd\x02\x08\x10\
    \n\r\n\x05\x045\x02\x01\x05\x12\x04\xdd\x02\x11\x17\n\r\n\x05\x045\x02\
    \x01\x01\x12\x04\xdd\x02\x18\x1b\n\r\n\x05\x045\x02\x01\x03\x12\x04\xdd\
    \x02\x1e\x1f\n\x0c\n\x04\x045\x02\x02\x12\x04\xde\x02\x08&\n\r\n\x05\x04\
    5\x02\x02\x04\x12\x04\xde\x02\x08\x10\n\r\n\x05\x045\x02\x02\x05\x12\x04\
    \xde\x02\x11\x15\n\r\n\x05\x045\x02\x02\x01\x12\x04\xde\x02\x16!\n\r\n\
    \x05\x045\x02\x02\x03\x12\x04\xde\x02$%\n\x0c\n\x02\x046\x12\x06\xe1\x02\
    \0\xea\x02\x01\n\x0b\n\x03\x046\x01\x12\x04\xe1\x02\x08\x1b\n\x0c\n\x04\
    \x046\x02\0\x12\x04\xe2\x02\x08+\n\r\n\x05\x046\x02\0\x04\x12\x04\xe2\
    \x02\x08\x10\n\r\n\x05\x046\x02\0\x05\x12\x04\xe2\x02\x11\x17\n\r\n\x05\
    \x046\x02\0\x01\x12\x04\xe2\x02\x18&\n\r\n\x05\x046\x02\0\x03\x12\x04\
    \xe2\x02)*\n\x0c\n\x04\x046\x02\x01\x12\x04\xe3\x02\x08\x20\n\r\n\x05\
    \x046\x02\x01\x04\x12\x04\xe3\x02\x08\x10\n\r\n\x05\x046\x02\x01\x05\x12\
    \x04\xe3\x02\x11\x17\n\r\n\x05\x046\x02\x01\x01\x12\x04\xe3\x02\x18\x1b\
    \n\r\n\x05\x046\x02\x01\x03\x12\x04\xe3\x02\x1e\x1f\n\x0c\n\x04\x046\x02\
    \x02\x12\x04\xe4\x02\x085\n\r\n\x05\x046\x02\x02\x04\x12\x04\xe4\x02\x08\
    \x10\n\r\n\x05\x046\x02\x02\x05\x12\x04\xe4\x02\x11\x16\n\r\n\x05\x046\
    \x02\x02\x01\x12\x04\xe4\x02\x17\x18\n\r\n\x05\x046\x02\x02\x03\x12\x04\
    \xe4\x02\x1b\x1c\n\r\n\x05\x046\x02\x02\x08\x12\x04\xe4\x02\x1d4\n\r\n\
    \x05\x046\x02\x02\x07\x12\x04\xe4\x02(3\n\x0c\n\x04\x046\x02\x03\x12\x04\
    \xe5\x02\x085\n\r\n\x05\x046\x02\x03\x04\x12\x04\xe5\x02\x08\x10\n\r\n\
    \x05\x046\x02\x03\x05\x12\x04\xe5\x02\x11\x16\n\r\n\x05\x046\x02\x03\x01\
    \x12\x04\xe5\x02\x17\x18\n\r\n\x05\x046\x02\x03\x03\x12\x04\xe5\x02\x1b\
    \x1c\n\r\n\x05\x046\x02\x03\x08\x12\x04\xe5\x02\x1d4\n\r\n\x05\x046\x02\
    \x03\x07\x12\x04\xe5\x02(3\n\x0c\n\x04\x046\x02\x04\x12\x04\xe6\x02\x08!\
    \n\r\n\x05\x046\x02\x04\x04\x12\x04\xe6\x02\x08\x10\n\r\n\x05\x046\x02\
    \x04\x05\x12\x04\xe6\x02\x11\x17\n\r\n\x05\x046\x02\x04\x01\x12\x04\xe6\
    \x02\x18\x1c\n\r\n\x05\x046\x02\x04\x03\x12\x04\xe6\x02\x1f\x20\n\x0c\n\
    \x04\x046\x02\x05\x12\x04\xe7\x02\x08!\n\r\n\x05\x046\x02\x05\x04\x12\
    \x04\xe7\x02\x08\x10\n\r\n\x05\x046\x02\x05\x05\x12\x04\xe7\x02\x11\x17\
    \n\r\n\x05\x046\x02\x05\x01\x12\x04\xe7\x02\x18\x1c\n\r\n\x05\x046\x02\
    \x05\x03\x12\x04\xe7\x02\x1f\x20\n\x0c\n\x04\x046\x02\x06\x12\x04\xe8\
    \x02\x08(\n\r\n\x05\x046\x02\x06\x04\x12\x04\xe8\x02\x08\x10\n\r\n\x05\
    \x046\x02\x06\x05\x12\x04\xe8\x02\x11\x17\n\r\n\x05\x046\x02\x06\x01\x12\
    \x04\xe8\x02\x18#\n\r\n\x05\x046\x02\x06\x03\x12\x04\xe8\x02&'\n\x0c\n\
    \x04\x046\x02\x07\x12\x04\xe9\x02\x08*\n\r\n\x05\x046\x02\x07\x04\x12\
    \x04\xe9\x02\x08\x10\n\r\n\x05\x046\x02\x07\x05\x12\x04\xe9\x02\x11\x15\
    \n\r\n\x05\x046\x02\x07\x01\x12\x04\xe9\x02\x16%\n\r\n\x05\x046\x02\x07\
    \x03\x12\x04\xe9\x02()\n\x0c\n\x02\x047\x12\x06\xec\x02\0\xef\x02\x01\n\
    \x0b\n\x03\x047\x01\x12\x04\xec\x02\x08#\n\x0c\n\x04\x047\x02\0\x12\x04\
    \xed\x02\x08+\n\r\n\x05\x047\x02\0\x04\x12\x04\xed\x02\x08\x10\n\r\n\x05\
    \x047\x02\0\x05\x12\x04\xed\x02\x11\x17\n\r\n\x05\x047\x02\0\x01\x12\x04\
    \xed\x02\x18&\n\r\n\x05\x047\x02\0\x03\x12\x04\xed\x02)*\n\x0c\n\x04\x04\
    7\x02\x01\x12\x04\xee\x02\x08!\n\r\n\x05\x047\x02\x01\x04\x12\x04\xee\
    \x02\x08\x10\n\r\n\x05\x047\x02\x01\x05\x12\x04\xee\x02\x11\x15\n\r\n\
    \x05\x047\x02\x01\x01\x12\x04\xee\x02\x16\x1c\n\r\n\x05\x047\x02\x01\x03\
    \x12\x04\xee\x02\x1f\x20\n\x0c\n\x02\x048\x12\x06\xf1\x02\0\xf4\x02\x01\
    \n\x0b\n\x03\x048\x01\x12\x04\xf1\x02\x08\x18\n\x0c\n\x04\x048\x02\0\x12\
    \x04\xf2\x02\x08+\n\r\n\x05\x048\x02\0\x04\x12\x04\xf2\x02\x08\x10\n\r\n\
    \x05\x048\x02\0\x05\x12\x04\xf2\x02\x11\x17\n\r\n\x05\x048\x02\0\x01\x12\
    \x04\xf2\x02\x18&\n\r\n\x05\x048\x02\0\x03\x12\x04\xf2\x02)*\n\x0c\n\x04\
    \x048\x02\x01\x12\x04\xf3\x02\x08\"\n\r\n\x05\x048\x02\x01\x04\x12\x04\
    \xf3\x02\x08\x10\n\r\n\x05\x048\x02\x01\x05\x12\x04\xf3\x02\x11\x17\n\r\
    \n\x05\x048\x02\x01\x01\x12\x04\xf3\x02\x18\x1d\n\r\n\x05\x048\x02\x01\
    \x03\x12\x04\xf3\x02\x20!\n\x0c\n\x02\x049\x12\x06\xf6\x02\0\xf9\x02\x01\
    \n\x0b\n\x03\x049\x01\x12\x04\xf6\x02\x08\x1b\n\x0c\n\x04\x049\x02\0\x12\
    \x04\xf7\x02\x08+\n\r\n\x05\x049\x02\0\x04\x12\x04\xf7\x02\x08\x10\n\r\n\
    \x05\x049\x02\0\x05\x12\x04\xf7\x02\x11\x17\n\r\n\x05\x049\x02\0\x01\x12\
    \x04\xf7\x02\x18&\n\r\n\x05\x049\x02\0\x03\x12\x04\xf7\x02)*\n\x0c\n\x04\
    \x049\x02\x01\x12\x04\xf8\x02\x08\x20\n\r\n\x05\x049\x02\x01\x04\x12\x04\
    \xf8\x02\x08\x10\n\r\n\x05\x049\x02\x01\x05\x12\x04\xf8\x02\x11\x17\n\r\
    \n\x05\x049\x02\x01\x01\x12\x04\xf8\x02\x18\x1b\n\r\n\x05\x049\x02\x01\
    \x03\x12\x04\xf8\x02\x1e\x1f\n\x0c\n\x02\x04:\x12\x06\xfb\x02\0\xfe\x02\
    \x01\n\x0b\n\x03\x04:\x01\x12\x04\xfb\x02\x08\x16\n\x0c\n\x04\x04:\x02\0\
    \x12\x04\xfc\x02\x08+\n\r\n\x05\x04:\x02\0\x04\x12\x04\xfc\x02\x08\x10\n\
    \r\n\x05\x04:\x02\0\x05\x12\x04\xfc\x02\x11\x17\n\r\n\x05\x04:\x02\0\x01\
    \x12\x04\xfc\x02\x18&\n\r\n\x05\x04:\x02\0\x03\x12\x04\xfc\x02)*\n\x0c\n\
    \x04\x04:\x02\x01\x12\x04\xfd\x02\x08!\n\r\n\x05\x04:\x02\x01\x04\x12\
    \x04\xfd\x02\x08\x10\n\r\n\x05\x04:\x02\x01\x05\x12\x04\xfd\x02\x11\x17\
    \n\r\n\x05\x04:\x02\x01\x01\x12\x04\xfd\x02\x18\x1c\n\r\n\x05\x04:\x02\
    \x01\x03\x12\x04\xfd\x02\x1f\x20\n\x0c\n\x02\x04;\x12\x06\x80\x03\0\x88\
    \x03\x01\n\x0b\n\x03\x04;\x01\x12\x04\x80\x03\x08\x15\n\x0c\n\x04\x04;\
    \x02\0\x12\x04\x81\x03\x08+\n\r\n\x05\x04;\x02\0\x04\x12\x04\x81\x03\x08\
    \x10\n\r\n\x05\x04;\x02\0\x05\x12\x04\x81\x03\x11\x17\n\r\n\x05\x04;\x02\
    \0\x01\x12\x04\x81\x03\x18&\n\r\n\x05\x04;\x02\0\x03\x12\x04\x81\x03)*\n\
    \x0c\n\x04\x04;\x02\x01\x12\x04\x82\x03\x08#\n\r\n\x05\x04;\x02\x01\x04\
    \x12\x04\x82\x03\x08\x10\n\r\n\x05\x04;\x02\x01\x05\x12\x04\x82\x03\x11\
    \x17\n\r\n\x05\x04;\x02\x01\x01\x12\x04\x82\x03\x18\x1e\n\r\n\x05\x04;\
    \x02\x01\x03\x12\x04\x82\x03!\"\n\x0c\n\x04\x04;\x02\x02\x12\x04\x83\x03\
    \x08'\n\r\n\x05\x04;\x02\x02\x04\x12\x04\x83\x03\x08\x10\n\r\n\x05\x04;\
    \x02\x02\x05\x12\x04\x83\x03\x11\x16\n\r\n\x05\x04;\x02\x02\x01\x12\x04\
    \x83\x03\x17\"\n\r\n\x05\x04;\x02\x02\x03\x12\x04\x83\x03%&\n\x0c\n\x04\
    \x04;\x02\x03\x12\x04\x84\x03\x08!\n\r\n\x05\x04;\x02\x03\x04\x12\x04\
    \x84\x03\x08\x10\n\r\n\x05\x04;\x02\x03\x05\x12\x04\x84\x03\x11\x17\n\r\
    \n\x05\x04;\x02\x03\x01\x12\x04\x84\x03\x18\x1c\n\r\n\x05\x04;\x02\x03\
    \x03\x12\x04\x84\x03\x1f\x20\n\x0c\n\x04\x04;\x02\x04\x12\x04\x85\x03\
    \x08!\n\r\n\x05\x04;\x02\x04\x04\x12\x04\x85\x03\x08\x10\n\r\n\x05\x04;\
    \x02\x04\x05\x12\x04\x85\x03\x11\x17\n\r\n\x05\x04;\x02\x04\x01\x12\x04\
    \x85\x03\x18\x1c\n\r\n\x05\x04;\x02\x04\x03\x12\x04\x85\x03\x1f\x20\n\
    \x0c\n\x04\x04;\x02\x05\x12\x04\x86\x03\x08%\n\r\n\x05\x04;\x02\x05\x04\
    \x12\x04\x86\x03\x08\x10\n\r\n\x05\x04;\x02\x05\x05\x12\x04\x86\x03\x11\
    \x17\n\r\n\x05\x04;\x02\x05\x01\x12\x04\x86\x03\x18\x20\n\r\n\x05\x04;\
    \x02\x05\x03\x12\x04\x86\x03#$\n\x0c\n\x04\x04;\x02\x06\x12\x04\x87\x03\
    \x08%\n\r\n\x05\x04;\x02\x06\x04\x12\x04\x87\x03\x08\x10\n\r\n\x05\x04;\
    \x02\x06\x05\x12\x04\x87\x03\x11\x17\n\r\n\x05\x04;\x02\x06\x01\x12\x04\
    \x87\x03\x18\x20\n\r\n\x05\x04;\x02\x06\x03\x12\x04\x87\x03#$\n\x0c\n\
    \x02\x04<\x12\x06\x8a\x03\0\x90\x03\x01\n\x0b\n\x03\x04<\x01\x12\x04\x8a\
    \x03\x08\x1a\n\x0c\n\x04\x04<\x02\0\x12\x04\x8b\x03\x08+\n\r\n\x05\x04<\
    \x02\0\x04\x12\x04\x8b\x03\x08\x10\n\r\n\x05\x04<\x02\0\x05\x12\x04\x8b\
    \x03\x11\x17\n\r\n\x05\x04<\x02\0\x01\x12\x04\x8b\x03\x18&\n\r\n\x05\x04\
    <\x02\0\x03\x12\x04\x8b\x03)*\n\x0c\n\x04\x04<\x02\x01\x12\x04\x8c\x03\
    \x08\"\n\r\n\x05\x04<\x02\x01\x04\x12\x04\x8c\x03\x08\x10\n\r\n\x05\x04<\
    \x02\x01\x05\x12\x04\x8c\x03\x11\x17\n\r\n\x05\x04<\x02\x01\x01\x12\x04\
    \x8c\x03\x18\x1d\n\r\n\x05\x04<\x02\x01\x03\x12\x04\x8c\x03\x20!\n\x0c\n\
    \x04\x04<\x02\x02\x12\x04\x8d\x03\x08(\n\r\n\x05\x04<\x02\x02\x04\x12\
    \x04\x8d\x03\x08\x10\n\r\n\x05\x04<\x02\x02\x05\x12\x04\x8d\x03\x11\x17\
    \n\r\n\x05\x04<\x02\x02\x01\x12\x04\x8d\x03\x18#\n\r\n\x05\x04<\x02\x02\
    \x03\x12\x04\x8d\x03&'\n\x0c\n\x04\x04<\x02\x03\x12\x04\x8e\x03\x08)\n\r\
    \n\x05\x04<\x02\x03\x04\x12\x04\x8e\x03\x08\x10\n\r\n\x05\x04<\x02\x03\
    \x05\x12\x04\x8e\x03\x11\x17\n\r\n\x05\x04<\x02\x03\x01\x12\x04\x8e\x03\
    \x18$\n\r\n\x05\x04<\x02\x03\x03\x12\x04\x8e\x03'(\n\x0c\n\x04\x04<\x02\
    \x04\x12\x04\x8f\x03\x08\"\n\r\n\x05\x04<\x02\x04\x04\x12\x04\x8f\x03\
    \x08\x10\n\r\n\x05\x04<\x02\x04\x05\x12\x04\x8f\x03\x11\x15\n\r\n\x05\
    \x04<\x02\x04\x01\x12\x04\x8f\x03\x16\x1d\n\r\n\x05\x04<\x02\x04\x03\x12\
    \x04\x8f\x03\x20!\n\x0c\n\x02\x04=\x12\x06\x92\x03\0\x95\x03\x01\n\x0b\n\
    \x03\x04=\x01\x12\x04\x92\x03\x08\"\n\x0c\n\x04\x04=\x02\0\x12\x04\x93\
    \x03\x08+\n\r\n\x05\x04=\x02\0\x04\x12\x04\x93\x03\x08\x10\n\r\n\x05\x04\
    =\x02\0\x05\x12\x04\x93\x03\x11\x17\n\r\n\x05\x04=\x02\0\x01\x12\x04\x93\
    \x03\x18&\n\r\n\x05\x04=\x02\0\x03\x12\x04\x93\x03)*\n\x0c\n\x04\x04=\
    \x02\x01\x12\x04\x94\x03\x08\"\n\r\n\x05\x04=\x02\x01\x04\x12\x04\x94\
    \x03\x08\x10\n\r\n\x05\x04=\x02\x01\x05\x12\x04\x94\x03\x11\x17\n\r\n\
    \x05\x04=\x02\x01\x01\x12\x04\x94\x03\x18\x1d\n\r\n\x05\x04=\x02\x01\x03\
    \x12\x04\x94\x03\x20!\n\x0c\n\x02\x04>\x12\x06\x97\x03\0\x9a\x03\x01\n\
    \x0b\n\x03\x04>\x01\x12\x04\x97\x03\x08\x17\n\x0c\n\x04\x04>\x02\0\x12\
    \x04\x98\x03\x08+\n\r\n\x05\x04>\x02\0\x04\x12\x04\x98\x03\x08\x10\n\r\n\
    \x05\x04>\x02\0\x05\x12\x04\x98\x03\x11\x17\n\r\n\x05\x04>\x02\0\x01\x12\
    \x04\x98\x03\x18&\n\r\n\x05\x04>\x02\0\x03\x12\x04\x98\x03)*\n\x0c\n\x04\
    \x04>\x02\x01\x12\x04\x99\x03\x08!\n\r\n\x05\x04>\x02\x01\x04\x12\x04\
    \x99\x03\x08\x10\n\r\n\x05\x04>\x02\x01\x05\x12\x04\x99\x03\x11\x17\n\r\
    \n\x05\x04>\x02\x01\x01\x12\x04\x99\x03\x18\x1c\n\r\n\x05\x04>\x02\x01\
    \x03\x12\x04\x99\x03\x1f\x20\n\x0c\n\x02\x04?\x12\x06\x9c\x03\0\x9f\x03\
    \x01\n\x0b\n\x03\x04?\x01\x12\x04\x9c\x03\x08\x19\n\x0c\n\x04\x04?\x02\0\
    \x12\x04\x9d\x03\x08+\n\r\n\x05\x04?\x02\0\x04\x12\x04\x9d\x03\x08\x10\n\
    \r\n\x05\x04?\x02\0\x05\x12\x04\x9d\x03\x11\x17\n\r\n\x05\x04?\x02\0\x01\
    \x12\x04\x9d\x03\x18&\n\r\n\x05\x04?\x02\0\x03\x12\x04\x9d\x03)*\n\x0c\n\
    \x04\x04?\x02\x01\x12\x04\x9e\x03\x08!\n\r\n\x05\x04?\x02\x01\x04\x12\
    \x04\x9e\x03\x08\x10\n\r\n\x05\x04?\x02\x01\x05\x12\x04\x9e\x03\x11\x17\
    \n\r\n\x05\x04?\x02\x01\x01\x12\x04\x9e\x03\x18\x1c\n\r\n\x05\x04?\x02\
    \x01\x03\x12\x04\x9e\x03\x1f\x20\n\x0c\n\x02\x04@\x12\x06\xa1\x03\0\xa3\
    \x03\x01\n\x0b\n\x03\x04@\x01\x12\x04\xa1\x03\x08\x17\n\x0c\n\x04\x04@\
    \x02\0\x12\x04\xa2\x03\x08+\n\r\n\x05\x04@\x02\0\x04\x12\x04\xa2\x03\x08\
    \x10\n\r\n\x05\x04@\x02\0\x05\x12\x04\xa2\x03\x11\x17\n\r\n\x05\x04@\x02\
    \0\x01\x12\x04\xa2\x03\x18&\n\r\n\x05\x04@\x02\0\x03\x12\x04\xa2\x03)*\n\
    \x0c\n\x02\x04A\x12\x06\xa5\x03\0\xa9\x03\x01\n\x0b\n\x03\x04A\x01\x12\
    \x04\xa5\x03\x08\x19\n\x0c\n\x04\x04A\x02\0\x12\x04\xa6\x03\x08+\n\r\n\
    \x05\x04A\x02\0\x04\x12\x04\xa6\x03\x08\x10\n\r\n\x05\x04A\x02\0\x05\x12\
    \x04\xa6\x03\x11\x17\n\r\n\x05\x04A\x02\0\x01\x12\x04\xa6\x03\x18&\n\r\n\
    \x05\x04A\x02\0\x03\x12\x04\xa6\x03)*\n\x0c\n\x04\x04A\x02\x01\x12\x04\
    \xa7\x03\x08'\n\r\n\x05\x04A\x02\x01\x04\x12\x04\xa7\x03\x08\x10\n\r\n\
    \x05\x04A\x02\x01\x05\x12\x04\xa7\x03\x11\x16\n\r\n\x05\x04A\x02\x01\x01\
    \x12\x04\xa7\x03\x17\"\n\r\n\x05\x04A\x02\x01\x03\x12\x04\xa7\x03%&\n\
    \x0c\n\x04\x04A\x02\x02\x12\x04\xa8\x03\x08#\n\r\n\x05\x04A\x02\x02\x04\
    \x12\x04\xa8\x03\x08\x10\n\r\n\x05\x04A\x02\x02\x05\x12\x04\xa8\x03\x11\
    \x16\n\r\n\x05\x04A\x02\x02\x01\x12\x04\xa8\x03\x17\x1e\n\r\n\x05\x04A\
    \x02\x02\x03\x12\x04\xa8\x03!\"\n\x0c\n\x02\x04B\x12\x06\xab\x03\0\xad\
    \x03\x01\n\x0b\n\x03\x04B\x01\x12\x04\xab\x03\x08\x11\n\x0c\n\x04\x04B\
    \x02\0\x12\x04\xac\x03\x08+\n\r\n\x05\x04B\x02\0\x04\x12\x04\xac\x03\x08\
    \x10\n\r\n\x05\x04B\x02\0\x05\x12\x04\xac\x03\x11\x17\n\r\n\x05\x04B\x02\
    \0\x01\x12\x04\xac\x03\x18&\n\r\n\x05\x04B\x02\0\x03\x12\x04\xac\x03)*\n\
    \x0c\n\x02\x04C\x12\x06\xaf\x03\0\xb6\x03\x01\n\x0b\n\x03\x04C\x01\x12\
    \x04\xaf\x03\x08!\n\x0c\n\x04\x04C\x02\0\x12\x04\xb0\x03\x08+\n\r\n\x05\
    \x04C\x02\0\x04\x12\x04\xb0\x03\x08\x10\n\r\n\x05\x04C\x02\0\x05\x12\x04\
    \xb0\x03\x11\x17\n\r\n\x05\x04C\x02\0\x01\x12\x04\xb0\x03\x18&\n\r\n\x05\
    \x04C\x02\0\x03\x12\x04\xb0\x03)*\n\x0c\n\x04\x04C\x02\x01\x12\x04\xb1\
    \x03\x08!\n\r\n\x05\x04C\x02\x01\x04\x12\x04\xb1\x03\x08\x10\n\r\n\x05\
    \x04C\x02\x01\x05\x12\x04\xb1\x03\x11\x17\n\r\n\x05\x04C\x02\x01\x01\x12\
    \x04\xb1\x03\x18\x1c\n\r\n\x05\x04C\x02\x01\x03\x12\x04\xb1\x03\x1f\x20\
    \n\x0c\n\x04\x04C\x02\x02\x12\x04\xb2\x03\x08!\n\r\n\x05\x04C\x02\x02\
    \x04\x12\x04\xb2\x03\x08\x10\n\r\n\x05\x04C\x02\x02\x05\x12\x04\xb2\x03\
    \x11\x17\n\r\n\x05\x04C\x02\x02\x01\x12\x04\xb2\x03\x18\x1c\n\r\n\x05\
    \x04C\x02\x02\x03\x12\x04\xb2\x03\x1f\x20\n\x0c\n\x04\x04C\x02\x03\x12\
    \x04\xb3\x03\x08'\n\r\n\x05\x04C\x02\x03\x04\x12\x04\xb3\x03\x08\x10\n\r\
    \n\x05\x04C\x02\x03\x05\x12\x04\xb3\x03\x11\x17\n\r\n\x05\x04C\x02\x03\
    \x01\x12\x04\xb3\x03\x18\"\n\r\n\x05\x04C\x02\x03\x03\x12\x04\xb3\x03%&\
    \n\x0c\n\x04\x04C\x02\x04\x12\x04\xb4\x03\x08*\n\r\n\x05\x04C\x02\x04\
    \x04\x12\x04\xb4\x03\x08\x10\n\r\n\x05\x04C\x02\x04\x05\x12\x04\xb4\x03\
    \x11\x17\n\r\n\x05\x04C\x02\x04\x01\x12\x04\xb4\x03\x18%\n\r\n\x05\x04C\
    \x02\x04\x03\x12\x04\xb4\x03()\n\x0c\n\x04\x04C\x02\x05\x12\x04\xb5\x03\
    \x08#\n\r\n\x05\x04C\x02\x05\x04\x12\x04\xb5\x03\x08\x10\n\r\n\x05\x04C\
    \x02\x05\x05\x12\x04\xb5\x03\x11\x17\n\r\n\x05\x04C\x02\x05\x01\x12\x04\
    \xb5\x03\x18\x1e\n\r\n\x05\x04C\x02\x05\x03\x12\x04\xb5\x03!\"\n\x0c\n\
    \x02\x04D\x12\x06\xb8\x03\0\xba\x03\x01\n\x0b\n\x03\x04D\x01\x12\x04\xb8\
    \x03\x08!\n\x0c\n\x04\x04D\x02\0\x12\x04\xb9\x03\x08+\n\r\n\x05\x04D\x02\
    \0\x04\x12\x04\xb9\x03\x08\x10\n\r\n\x05\x04D\x02\0\x05\x12\x04\xb9\x03\
    \x11\x17\n\r\n\x05\x04D\x02\0\x01\x12\x04\xb9\x03\x18&\n\r\n\x05\x04D\
    \x02\0\x03\x12\x04\xb9\x03)*\n\x0c\n\x02\x04E\x12\x06\xbc\x03\0\xc5\x03\
    \x01\n\x0b\n\x03\x04E\x01\x12\x04\xbc\x03\x08\x16\n\x0c\n\x04\x04E\x02\0\
    \x12\x04\xbd\x03\x08+\n\r\n\x05\x04E\x02\0\x04\x12\x04\xbd\x03\x08\x10\n\
    \r\n\x05\x04E\x02\0\x05\x12\x04\xbd\x03\x11\x17\n\r\n\x05\x04E\x02\0\x01\
    \x12\x04\xbd\x03\x18&\n\r\n\x05\x04E\x02\0\x03\x12\x04\xbd\x03)*\n\x0c\n\
    \x04\x04E\x02\x01\x12\x04\xbe\x03\x08%\n\r\n\x05\x04E\x02\x01\x04\x12\
    \x04\xbe\x03\x08\x10\n\r\n\x05\x04E\x02\x01\x05\x12\x04\xbe\x03\x11\x17\
    \n\r\n\x05\x04E\x02\x01\x01\x12\x04\xbe\x03\x18\x1f\n\r\n\x05\x04E\x02\
    \x01\x03\x12\x04\xbe\x03\"$\n\x0c\n\x04\x04E\x02\x02\x12\x04\xbf\x03\x08\
    %\n\r\n\x05\x04E\x02\x02\x04\x12\x04\xbf\x03\x08\x10\n\r\n\x05\x04E\x02\
    \x02\x05\x12\x04\xbf\x03\x11\x17\n\r\n\x05\x04E\x02\x02\x01\x12\x04\xbf\
    \x03\x18\x1f\n\r\n\x05\x04E\x02\x02\x03\x12\x04\xbf\x03\"$\n\x0c\n\x04\
    \x04E\x02\x03\x12\x04\xc0\x03\x08&\n\r\n\x05\x04E\x02\x03\x04\x12\x04\
    \xc0\x03\x08\x10\n\r\n\x05\x04E\x02\x03\x05\x12\x04\xc0\x03\x11\x16\n\r\
    \n\x05\x04E\x02\x03\x01\x12\x04\xc0\x03\x17\x20\n\r\n\x05\x04E\x02\x03\
    \x03\x12\x04\xc0\x03#%\n\x0c\n\x04\x04E\x02\x04\x12\x04\xc1\x03\x08(\n\r\
    \n\x05\x04E\x02\x04\x04\x12\x04\xc1\x03\x08\x10\n\r\n\x05\x04E\x02\x04\
    \x05\x12\x04\xc1\x03\x11\x17\n\r\n\x05\x04E\x02\x04\x01\x12\x04\xc1\x03\
    \x18\"\n\r\n\x05\x04E\x02\x04\x03\x12\x04\xc1\x03%'\n\x0c\n\x04\x04E\x02\
    \x05\x12\x04\xc2\x03\x08*\n\r\n\x05\x04E\x02\x05\x04\x12\x04\xc2\x03\x08\
    \x10\n\r\n\x05\x04E\x02\x05\x05\x12\x04\xc2\x03\x11\x17\n\r\n\x05\x04E\
    \x02\x05\x01\x12\x04\xc2\x03\x18$\n\r\n\x05\x04E\x02\x05\x03\x12\x04\xc2\
    \x03')\n\x0c\n\x04\x04E\x02\x06\x12\x04\xc3\x03\x080\n\r\n\x05\x04E\x02\
    \x06\x04\x12\x04\xc3\x03\x08\x10\n\r\n\x05\x04E\x02\x06\x05\x12\x04\xc3\
    \x03\x11\x16\n\r\n\x05\x04E\x02\x06\x01\x12\x04\xc3\x03\x17*\n\r\n\x05\
    \x04E\x02\x06\x03\x12\x04\xc3\x03-/\n\x0c\n\x04\x04E\x02\x07\x12\x04\xc4\
    \x03\x08+\n\r\n\x05\x04E\x02\x07\x04\x12\x04\xc4\x03\x08\x10\n\r\n\x05\
    \x04E\x02\x07\x05\x12\x04\xc4\x03\x11\x17\n\r\n\x05\x04E\x02\x07\x01\x12\
    \x04\xc4\x03\x18%\n\r\n\x05\x04E\x02\x07\x03\x12\x04\xc4\x03(*\n\x0c\n\
    \x02\x04F\x12\x06\xc7\x03\0\xce\x03\x01\n\x0b\n\x03\x04F\x01\x12\x04\xc7\
    \x03\x08\x1b\n\x0c\n\x04\x04F\x02\0\x12\x04\xc8\x03\x08+\n\r\n\x05\x04F\
    \x02\0\x04\x12\x04\xc8\x03\x08\x10\n\r\n\x05\x04F\x02\0\x05\x12\x04\xc8\
    \x03\x11\x17\n\r\n\x05\x04F\x02\0\x01\x12\x04\xc8\x03\x18&\n\r\n\x05\x04\
    F\x02\0\x03\x12\x04\xc8\x03)*\n\x0c\n\x04\x04F\x02\x01\x12\x04\xc9\x03\
    \x08!\n\r\n\x05\x04F\x02\x01\x04\x12\x04\xc9\x03\x08\x10\n\r\n\x05\x04F\
    \x02\x01\x05\x12\x04\xc9\x03\x11\x17\n\r\n\x05\x04F\x02\x01\x01\x12\x04\
    \xc9\x03\x18\x1c\n\r\n\x05\x04F\x02\x01\x03\x12\x04\xc9\x03\x1f\x20\n\
    \x0c\n\x04\x04F\x02\x02\x12\x04\xca\x03\x088\n\r\n\x05\x04F\x02\x02\x04\
    \x12\x04\xca\x03\x08\x10\n\r\n\x05\x04F\x02\x02\x05\x12\x04\xca\x03\x11\
    \x17\n\r\n\x05\x04F\x02\x02\x01\x12\x04\xca\x03\x18%\n\r\n\x05\x04F\x02\
    \x02\x03\x12\x04\xca\x03()\n\r\n\x05\x04F\x02\x02\x08\x12\x04\xca\x03*7\
    \n\r\n\x05\x04F\x02\x02\x07\x12\x04\xca\x0356\n\x0c\n\x04\x04F\x02\x03\
    \x12\x04\xcb\x03\x088\n\r\n\x05\x04F\x02\x03\x04\x12\x04\xcb\x03\x08\x10\
    \n\r\n\x05\x04F\x02\x03\x05\x12\x04\xcb\x03\x11\x17\n\r\n\x05\x04F\x02\
    \x03\x01\x12\x04\xcb\x03\x18%\n\r\n\x05\x04F\x02\x03\x03\x12\x04\xcb\x03\
    ()\n\r\n\x05\x04F\x02\x03\x08\x12\x04\xcb\x03*7\n\r\n\x05\x04F\x02\x03\
    \x07\x12\x04\xcb\x0356\n\x0c\n\x04\x04F\x02\x04\x12\x04\xcc\x03\x08?\n\r\
    \n\x05\x04F\x02\x04\x04\x12\x04\xcc\x03\x08\x10\n\r\n\x05\x04F\x02\x04\
    \x05\x12\x04\xcc\x03\x11\x17\n\r\n\x05\x04F\x02\x04\x01\x12\x04\xcc\x03\
    \x18,\n\r\n\x05\x04F\x02\x04\x03\x12\x04\xcc\x03/0\n\r\n\x05\x04F\x02\
    \x04\x08\x12\x04\xcc\x031>\n\r\n\x05\x04F\x02\x04\x07\x12\x04\xcc\x03<=\
    \n\x0c\n\x04\x04F\x02\x05\x12\x04\xcd\x03\x08=\n\r\n\x05\x04F\x02\x05\
    \x04\x12\x04\xcd\x03\x08\x10\n\r\n\x05\x04F\x02\x05\x05\x12\x04\xcd\x03\
    \x11\x17\n\r\n\x05\x04F\x02\x05\x01\x12\x04\xcd\x03\x18*\n\r\n\x05\x04F\
    \x02\x05\x03\x12\x04\xcd\x03-.\n\r\n\x05\x04F\x02\x05\x08\x12\x04\xcd\
    \x03/<\n\r\n\x05\x04F\x02\x05\x07\x12\x04\xcd\x03:;\n\x0c\n\x02\x04G\x12\
    \x06\xd0\x03\0\xd9\x03\x01\n\x0b\n\x03\x04G\x01\x12\x04\xd0\x03\x08#\n\
    \x0c\n\x04\x04G\x02\0\x12\x04\xd1\x03\x08+\n\r\n\x05\x04G\x02\0\x04\x12\
    \x04\xd1\x03\x08\x10\n\r\n\x05\x04G\x02\0\x05\x12\x04\xd1\x03\x11\x17\n\
    \r\n\x05\x04G\x02\0\x01\x12\x04\xd1\x03\x18&\n\r\n\x05\x04G\x02\0\x03\
    \x12\x04\xd1\x03)*\n\x0c\n\x04\x04G\x02\x01\x12\x04\xd2\x03\x08)\n\r\n\
    \x05\x04G\x02\x01\x04\x12\x04\xd2\x03\x08\x10\n\r\n\x05\x04G\x02\x01\x05\
    \x12\x04\xd2\x03\x11\x17\n\r\n\x05\x04G\x02\x01\x01\x12\x04\xd2\x03\x18$\
    \n\r\n\x05\x04G\x02\x01\x03\x12\x04\xd2\x03'(\n\x0c\n\x04\x04G\x02\x02\
    \x12\x04\xd3\x03\x08\"\n\r\n\x05\x04G\x02\x02\x04\x12\x04\xd3\x03\x08\
    \x10\n\r\n\x05\x04G\x02\x02\x05\x12\x04\xd3\x03\x11\x17\n\r\n\x05\x04G\
    \x02\x02\x01\x12\x04\xd3\x03\x18\x1d\n\r\n\x05\x04G\x02\x02\x03\x12\x04\
    \xd3\x03\x20!\n\x0c\n\x04\x04G\x02\x03\x12\x04\xd4\x03\x08#\n\r\n\x05\
    \x04G\x02\x03\x04\x12\x04\xd4\x03\x08\x10\n\r\n\x05\x04G\x02\x03\x05\x12\
    \x04\xd4\x03\x11\x17\n\r\n\x05\x04G\x02\x03\x01\x12\x04\xd4\x03\x18\x1e\
    \n\r\n\x05\x04G\x02\x03\x03\x12\x04\xd4\x03!\"\n\x0c\n\x04\x04G\x02\x04\
    \x12\x04\xd5\x03\x08$\n\r\n\x05\x04G\x02\x04\x04\x12\x04\xd5\x03\x08\x10\
    \n\r\n\x05\x04G\x02\x04\x05\x12\x04\xd5\x03\x11\x17\n\r\n\x05\x04G\x02\
    \x04\x01\x12\x04\xd5\x03\x18\x1f\n\r\n\x05\x04G\x02\x04\x03\x12\x04\xd5\
    \x03\"#\n\x0c\n\x04\x04G\x02\x05\x12\x04\xd6\x03\x08$\n\r\n\x05\x04G\x02\
    \x05\x04\x12\x04\xd6\x03\x08\x10\n\r\n\x05\x04G\x02\x05\x05\x12\x04\xd6\
    \x03\x11\x17\n\r\n\x05\x04G\x02\x05\x01\x12\x04\xd6\x03\x18\x1f\n\r\n\
    \x05\x04G\x02\x05\x03\x12\x04\xd6\x03\"#\n\x0c\n\x04\x04G\x02\x06\x12\
    \x04\xd7\x03\x08%\n\r\n\x05\x04G\x02\x06\x04\x12\x04\xd7\x03\x08\x10\n\r\
    \n\x05\x04G\x02\x06\x05\x12\x04\xd7\x03\x11\x16\n\r\n\x05\x04G\x02\x06\
    \x01\x12\x04\xd7\x03\x17\x20\n\r\n\x05\x04G\x02\x06\x03\x12\x04\xd7\x03#\
    $\n\x0c\n\x04\x04G\x02\x07\x12\x04\xd8\x03\x08'\n\r\n\x05\x04G\x02\x07\
    \x04\x12\x04\xd8\x03\x08\x10\n\r\n\x05\x04G\x02\x07\x05\x12\x04\xd8\x03\
    \x11\x17\n\r\n\x05\x04G\x02\x07\x01\x12\x04\xd8\x03\x18\"\n\r\n\x05\x04G\
    \x02\x07\x03\x12\x04\xd8\x03%&\n\x0c\n\x02\x04H\x12\x06\xdb\x03\0\xe3\
    \x03\x01\n\x0b\n\x03\x04H\x01\x12\x04\xdb\x03\x08#\n\x0c\n\x04\x04H\x02\
    \0\x12\x04\xdc\x03\x08+\n\r\n\x05\x04H\x02\0\x04\x12\x04\xdc\x03\x08\x10\
    \n\r\n\x05\x04H\x02\0\x05\x12\x04\xdc\x03\x11\x17\n\r\n\x05\x04H\x02\0\
    \x01\x12\x04\xdc\x03\x18&\n\r\n\x05\x04H\x02\0\x03\x12\x04\xdc\x03)*\n\
    \x0c\n\x04\x04H\x02\x01\x12\x04\xdd\x03\x08\"\n\r\n\x05\x04H\x02\x01\x04\
    \x12\x04\xdd\x03\x08\x10\n\r\n\x05\x04H\x02\x01\x05\x12\x04\xdd\x03\x11\
    \x17\n\r\n\x05\x04H\x02\x01\x01\x12\x04\xdd\x03\x18\x1d\n\r\n\x05\x04H\
    \x02\x01\x03\x12\x04\xdd\x03\x20!\n\x0c\n\x04\x04H\x02\x02\x12\x04\xde\
    \x03\x08#\n\r\n\x05\x04H\x02\x02\x04\x12\x04\xde\x03\x08\x10\n\r\n\x05\
    \x04H\x02\x02\x05\x12\x04\xde\x03\x11\x17\n\r\n\x05\x04H\x02\x02\x01\x12\
    \x04\xde\x03\x18\x1e\n\r\n\x05\x04H\x02\x02\x03\x12\x04\xde\x03!\"\n\x0c\
    \n\x04\x04H\x02\x03\x12\x04\xdf\x03\x08$\n\r\n\x05\x04H\x02\x03\x04\x12\
    \x04\xdf\x03\x08\x10\n\r\n\x05\x04H\x02\x03\x05\x12\x04\xdf\x03\x11\x17\
    \n\r\n\x05\x04H\x02\x03\x01\x12\x04\xdf\x03\x18\x1f\n\r\n\x05\x04H\x02\
    \x03\x03\x12\x04\xdf\x03\"#\n\x0c\n\x04\x04H\x02\x04\x12\x04\xe0\x03\x08\
    $\n\r\n\x05\x04H\x02\x04\x04\x12\x04\xe0\x03\x08\x10\n\r\n\x05\x04H\x02\
    \x04\x05\x12\x04\xe0\x03\x11\x17\n\r\n\x05\x04H\x02\x04\x01\x12\x04\xe0\
    \x03\x18\x1f\n\r\n\x05\x04H\x02\x04\x03\x12\x04\xe0\x03\"#\n\x0c\n\x04\
    \x04H\x02\x05\x12\x04\xe1\x03\x08%\n\r\n\x05\x04H\x02\x05\x04\x12\x04\
    \xe1\x03\x08\x10\n\r\n\x05\x04H\x02\x05\x05\x12\x04\xe1\x03\x11\x16\n\r\
    \n\x05\x04H\x02\x05\x01\x12\x04\xe1\x03\x17\x20\n\r\n\x05\x04H\x02\x05\
    \x03\x12\x04\xe1\x03#$\n\x0c\n\x04\x04H\x02\x06\x12\x04\xe2\x03\x08'\n\r\
    \n\x05\x04H\x02\x06\x04\x12\x04\xe2\x03\x08\x10\n\r\n\x05\x04H\x02\x06\
    \x05\x12\x04\xe2\x03\x11\x17\n\r\n\x05\x04H\x02\x06\x01\x12\x04\xe2\x03\
    \x18\"\n\r\n\x05\x04H\x02\x06\x03\x12\x04\xe2\x03%&\n\x0c\n\x02\x04I\x12\
    \x06\xe5\x03\0\xe7\x03\x01\n\x0b\n\x03\x04I\x01\x12\x04\xe5\x03\x08\x13\
    \n\x0c\n\x04\x04I\x02\0\x12\x04\xe6\x03\x08+\n\r\n\x05\x04I\x02\0\x04\
    \x12\x04\xe6\x03\x08\x10\n\r\n\x05\x04I\x02\0\x05\x12\x04\xe6\x03\x11\
    \x17\n\r\n\x05\x04I\x02\0\x01\x12\x04\xe6\x03\x18&\n\r\n\x05\x04I\x02\0\
    \x03\x12\x04\xe6\x03)*\n\x0c\n\x02\x04J\x12\x06\xe9\x03\0\xec\x03\x01\n\
    \x0b\n\x03\x04J\x01\x12\x04\xe9\x03\x08\x1b\n\x0c\n\x04\x04J\x02\0\x12\
    \x04\xea\x03\x08+\n\r\n\x05\x04J\x02\0\x04\x12\x04\xea\x03\x08\x10\n\r\n\
    \x05\x04J\x02\0\x05\x12\x04\xea\x03\x11\x17\n\r\n\x05\x04J\x02\0\x01\x12\
    \x04\xea\x03\x18&\n\r\n\x05\x04J\x02\0\x03\x12\x04\xea\x03)*\n\x0c\n\x04\
    \x04J\x02\x01\x12\x04\xeb\x03\x08\x20\n\r\n\x05\x04J\x02\x01\x04\x12\x04\
    \xeb\x03\x08\x10\n\r\n\x05\x04J\x02\x01\x05\x12\x04\xeb\x03\x11\x16\n\r\
    \n\x05\x04J\x02\x01\x01\x12\x04\xeb\x03\x17\x1b\n\r\n\x05\x04J\x02\x01\
    \x03\x12\x04\xeb\x03\x1e\x1f\n\x0c\n\x02\x04K\x12\x06\xee\x03\0\xf2\x03\
    \x01\n\x0b\n\x03\x04K\x01\x12\x04\xee\x03\x08\x1a\n\x0c\n\x04\x04K\x02\0\
    \x12\x04\xef\x03\x08+\n\r\n\x05\x04K\x02\0\x04\x12\x04\xef\x03\x08\x10\n\
    \r\n\x05\x04K\x02\0\x05\x12\x04\xef\x03\x11\x17\n\r\n\x05\x04K\x02\0\x01\
    \x12\x04\xef\x03\x18&\n\r\n\x05\x04K\x02\0\x03\x12\x04\xef\x03)*\n\x0c\n\
    \x04\x04K\x02\x01\x12\x04\xf0\x03\x08\x1e\n\r\n\x05\x04K\x02\x01\x04\x12\
    \x04\xf0\x03\x08\x10\n\r\n\x05\x04K\x02\x01\x05\x12\x04\xf0\x03\x11\x17\
    \n\r\n\x05\x04K\x02\x01\x01\x12\x04\xf0\x03\x18\x19\n\r\n\x05\x04K\x02\
    \x01\x03\x12\x04\xf0\x03\x1c\x1d\n\x0c\n\x04\x04K\x02\x02\x12\x04\xf1\
    \x03\x08\x1e\n\r\n\x05\x04K\x02\x02\x04\x12\x04\xf1\x03\x08\x10\n\r\n\
    \x05\x04K\x02\x02\x05\x12\x04\xf1\x03\x11\x17\n\r\n\x05\x04K\x02\x02\x01\
    \x12\x04\xf1\x03\x18\x19\n\r\n\x05\x04K\x02\x02\x03\x12\x04\xf1\x03\x1c\
    \x1d\n\x0c\n\x02\x04L\x12\x06\xf4\x03\0\xfb\x03\x01\n\x0b\n\x03\x04L\x01\
    \x12\x04\xf4\x03\x08\"\n\x0c\n\x04\x04L\x02\0\x12\x04\xf5\x03\x08+\n\r\n\
    \x05\x04L\x02\0\x04\x12\x04\xf5\x03\x08\x10\n\r\n\x05\x04L\x02\0\x05\x12\
    \x04\xf5\x03\x11\x17\n\r\n\x05\x04L\x02\0\x01\x12\x04\xf5\x03\x18&\n\r\n\
    \x05\x04L\x02\0\x03\x12\x04\xf5\x03)*\n\x0c\n\x04\x04L\x02\x01\x12\x04\
    \xf6\x03\x08\x1e\n\r\n\x05\x04L\x02\x01\x04\x12\x04\xf6\x03\x08\x10\n\r\
    \n\x05\x04L\x02\x01\x05\x12\x04\xf6\x03\x11\x17\n\r\n\x05\x04L\x02\x01\
    \x01\x12\x04\xf6\x03\x18\x19\n\r\n\x05\x04L\x02\x01\x03\x12\x04\xf6\x03\
    \x1c\x1d\n\x0c\n\x04\x04L\x02\x02\x12\x04\xf7\x03\x08\x1e\n\r\n\x05\x04L\
    \x02\x02\x04\x12\x04\xf7\x03\x08\x10\n\r\n\x05\x04L\x02\x02\x05\x12\x04\
    \xf7\x03\x11\x17\n\r\n\x05\x04L\x02\x02\x01\x12\x04\xf7\x03\x18\x19\n\r\
    \n\x05\x04L\x02\x02\x03\x12\x04\xf7\x03\x1c\x1d\n\x0c\n\x04\x04L\x02\x03\
    \x12\x04\xf8\x03\x08\x20\n\r\n\x05\x04L\x02\x03\x04\x12\x04\xf8\x03\x08\
    \x10\n\r\n\x05\x04L\x02\x03\x05\x12\x04\xf8\x03\x11\x17\n\r\n\x05\x04L\
    \x02\x03\x01\x12\x04\xf8\x03\x18\x1b\n\r\n\x05\x04L\x02\x03\x03\x12\x04\
    \xf8\x03\x1e\x1f\n\x0c\n\x04\x04L\x02\x04\x12\x04\xf9\x03\x08$\n\r\n\x05\
    \x04L\x02\x04\x04\x12\x04\xf9\x03\x08\x10\n\r\n\x05\x04L\x02\x04\x05\x12\
    \x04\xf9\x03\x11\x15\n\r\n\x05\x04L\x02\x04\x01\x12\x04\xf9\x03\x16\x1f\
    \n\r\n\x05\x04L\x02\x04\x03\x12\x04\xf9\x03\"#\n\x0c\n\x04\x04L\x02\x05\
    \x12\x04\xfa\x03\x08!\n\r\n\x05\x04L\x02\x05\x04\x12\x04\xfa\x03\x08\x10\
    \n\r\n\x05\x04L\x02\x05\x05\x12\x04\xfa\x03\x11\x15\n\r\n\x05\x04L\x02\
    \x05\x01\x12\x04\xfa\x03\x16\x1c\n\r\n\x05\x04L\x02\x05\x03\x12\x04\xfa\
    \x03\x1f\x20\n\x0c\n\x02\x04M\x12\x06\xfd\x03\0\x81\x04\x01\n\x0b\n\x03\
    \x04M\x01\x12\x04\xfd\x03\x08#\n\x0c\n\x04\x04M\x02\0\x12\x04\xfe\x03\
    \x08+\n\r\n\x05\x04M\x02\0\x04\x12\x04\xfe\x03\x08\x10\n\r\n\x05\x04M\
    \x02\0\x05\x12\x04\xfe\x03\x11\x17\n\r\n\x05\x04M\x02\0\x01\x12\x04\xfe\
    \x03\x18&\n\r\n\x05\x04M\x02\0\x03\x12\x04\xfe\x03)*\n\x0c\n\x04\x04M\
    \x02\x01\x12\x04\xff\x03\x08\x1e\n\r\n\x05\x04M\x02\x01\x04\x12\x04\xff\
    \x03\x08\x10\n\r\n\x05\x04M\x02\x01\x05\x12\x04\xff\x03\x11\x17\n\r\n\
    \x05\x04M\x02\x01\x01\x12\x04\xff\x03\x18\x19\n\r\n\x05\x04M\x02\x01\x03\
    \x12\x04\xff\x03\x1c\x1d\n\x0c\n\x04\x04M\x02\x02\x12\x04\x80\x04\x08\
    \x1e\n\r\n\x05\x04M\x02\x02\x04\x12\x04\x80\x04\x08\x10\n\r\n\x05\x04M\
    \x02\x02\x05\x12\x04\x80\x04\x11\x17\n\r\n\x05\x04M\x02\x02\x01\x12\x04\
    \x80\x04\x18\x19\n\r\n\x05\x04M\x02\x02\x03\x12\x04\x80\x04\x1c\x1d\n\
    \x0c\n\x02\x04N\x12\x06\x83\x04\0\x87\x04\x01\n\x0b\n\x03\x04N\x01\x12\
    \x04\x83\x04\x08+\n\x0c\n\x04\x04N\x02\0\x12\x04\x84\x04\x08+\n\r\n\x05\
    \x04N\x02\0\x04\x12\x04\x84\x04\x08\x10\n\r\n\x05\x04N\x02\0\x05\x12\x04\
    \x84\x04\x11\x17\n\r\n\x05\x04N\x02\0\x01\x12\x04\x84\x04\x18&\n\r\n\x05\
    \x04N\x02\0\x03\x12\x04\x84\x04)*\n\x0c\n\x04\x04N\x02\x01\x12\x04\x85\
    \x04\x08!\n\r\n\x05\x04N\x02\x01\x04\x12\x04\x85\x04\x08\x10\n\r\n\x05\
    \x04N\x02\x01\x05\x12\x04\x85\x04\x11\x16\n\r\n\x05\x04N\x02\x01\x01\x12\
    \x04\x85\x04\x17\x1c\n\r\n\x05\x04N\x02\x01\x03\x12\x04\x85\x04\x1f\x20\
    \n\x0c\n\x04\x04N\x02\x02\x12\x04\x86\x04\x08$\n\r\n\x05\x04N\x02\x02\
    \x04\x12\x04\x86\x04\x08\x10\n\r\n\x05\x04N\x02\x02\x05\x12\x04\x86\x04\
    \x11\x16\n\r\n\x05\x04N\x02\x02\x01\x12\x04\x86\x04\x17\x1f\n\r\n\x05\
    \x04N\x02\x02\x03\x12\x04\x86\x04\"#\n\x0c\n\x02\x04O\x12\x06\x89\x04\0\
    \x8e\x04\x01\n\x0b\n\x03\x04O\x01\x12\x04\x89\x04\x08\x1c\n\x0c\n\x04\
    \x04O\x02\0\x12\x04\x8a\x04\x08+\n\r\n\x05\x04O\x02\0\x04\x12\x04\x8a\
    \x04\x08\x10\n\r\n\x05\x04O\x02\0\x05\x12\x04\x8a\x04\x11\x17\n\r\n\x05\
    \x04O\x02\0\x01\x12\x04\x8a\x04\x18&\n\r\n\x05\x04O\x02\0\x03\x12\x04\
    \x8a\x04)*\n\x0c\n\x04\x04O\x02\x01\x12\x04\x8b\x04\x08!\n\r\n\x05\x04O\
    \x02\x01\x04\x12\x04\x8b\x04\x08\x10\n\r\n\x05\x04O\x02\x01\x05\x12\x04\
    \x8b\x04\x11\x16\n\r\n\x05\x04O\x02\x01\x01\x12\x04\x8b\x04\x17\x1c\n\r\
    \n\x05\x04O\x02\x01\x03\x12\x04\x8b\x04\x1f\x20\n\x0c\n\x04\x04O\x02\x02\
    \x12\x04\x8c\x04\x08\x1d\n\r\n\x05\x04O\x02\x02\x04\x12\x04\x8c\x04\x08\
    \x10\n\r\n\x05\x04O\x02\x02\x05\x12\x04\x8c\x04\x11\x16\n\r\n\x05\x04O\
    \x02\x02\x01\x12\x04\x8c\x04\x17\x18\n\r\n\x05\x04O\x02\x02\x03\x12\x04\
    \x8c\x04\x1b\x1c\n\x0c\n\x04\x04O\x02\x03\x12\x04\x8d\x04\x08\x1d\n\r\n\
    \x05\x04O\x02\x03\x04\x12\x04\x8d\x04\x08\x10\n\r\n\x05\x04O\x02\x03\x05\
    \x12\x04\x8d\x04\x11\x16\n\r\n\x05\x04O\x02\x03\x01\x12\x04\x8d\x04\x17\
    \x18\n\r\n\x05\x04O\x02\x03\x03\x12\x04\x8d\x04\x1b\x1c\n\x0c\n\x02\x04P\
    \x12\x06\x90\x04\0\x93\x04\x01\n\x0b\n\x03\x04P\x01\x12\x04\x90\x04\x08#\
    \n\x0c\n\x04\x04P\x02\0\x12\x04\x91\x04\x08+\n\r\n\x05\x04P\x02\0\x04\
    \x12\x04\x91\x04\x08\x10\n\r\n\x05\x04P\x02\0\x05\x12\x04\x91\x04\x11\
    \x17\n\r\n\x05\x04P\x02\0\x01\x12\x04\x91\x04\x18&\n\r\n\x05\x04P\x02\0\
    \x03\x12\x04\x91\x04)*\n\x0c\n\x04\x04P\x02\x01\x12\x04\x92\x04\x083\n\r\
    \n\x05\x04P\x02\x01\x04\x12\x04\x92\x04\x08\x10\n\r\n\x05\x04P\x02\x01\
    \x05\x12\x04\x92\x04\x11\x15\n\r\n\x05\x04P\x02\x01\x01\x12\x04\x92\x04\
    \x16.\n\r\n\x05\x04P\x02\x01\x03\x12\x04\x92\x0412\n\x0c\n\x02\x04Q\x12\
    \x06\x95\x04\0\x98\x04\x01\n\x0b\n\x03\x04Q\x01\x12\x04\x95\x04\x08$\n\
    \x0c\n\x04\x04Q\x02\0\x12\x04\x96\x04\x08+\n\r\n\x05\x04Q\x02\0\x04\x12\
    \x04\x96\x04\x08\x10\n\r\n\x05\x04Q\x02\0\x05\x12\x04\x96\x04\x11\x17\n\
    \r\n\x05\x04Q\x02\0\x01\x12\x04\x96\x04\x18&\n\r\n\x05\x04Q\x02\0\x03\
    \x12\x04\x96\x04)*\n\x0c\n\x04\x04Q\x02\x01\x12\x04\x97\x04\x08\x20\n\r\
    \n\x05\x04Q\x02\x01\x04\x12\x04\x97\x04\x08\x10\n\r\n\x05\x04Q\x02\x01\
    \x05\x12\x04\x97\x04\x11\x16\n\r\n\x05\x04Q\x02\x01\x01\x12\x04\x97\x04\
    \x17\x1b\n\r\n\x05\x04Q\x02\x01\x03\x12\x04\x97\x04\x1e\x1f\n\x0c\n\x02\
    \x04R\x12\x06\x9a\x04\0\xa0\x04\x01\n\x0b\n\x03\x04R\x01\x12\x04\x9a\x04\
    \x08\x1a\n\x0c\n\x04\x04R\x02\0\x12\x04\x9b\x04\x08+\n\r\n\x05\x04R\x02\
    \0\x04\x12\x04\x9b\x04\x08\x10\n\r\n\x05\x04R\x02\0\x05\x12\x04\x9b\x04\
    \x11\x17\n\r\n\x05\x04R\x02\0\x01\x12\x04\x9b\x04\x18&\n\r\n\x05\x04R\
    \x02\0\x03\x12\x04\x9b\x04)*\n\x0c\n\x04\x04R\x02\x01\x12\x04\x9c\x04\
    \x08\x20\n\r\n\x05\x04R\x02\x01\x04\x12\x04\x9c\x04\x08\x10\n\r\n\x05\
    \x04R\x02\x01\x05\x12\x04\x9c\x04\x11\x17\n\r\n\x05\x04R\x02\x01\x01\x12\
    \x04\x9c\x04\x18\x1b\n\r\n\x05\x04R\x02\x01\x03\x12\x04\x9c\x04\x1e\x1f\
    \n\x0c\n\x04\x04R\x02\x02\x12\x04\x9d\x04\x08%\n\r\n\x05\x04R\x02\x02\
    \x04\x12\x04\x9d\x04\x08\x10\n\r\n\x05\x04R\x02\x02\x05\x12\x04\x9d\x04\
    \x11\x17\n\r\n\x05\x04R\x02\x02\x01\x12\x04\x9d\x04\x18\x20\n\r\n\x05\
    \x04R\x02\x02\x03\x12\x04\x9d\x04#$\n\x0c\n\x04\x04R\x02\x03\x12\x04\x9e\
    \x04\x08\"\n\r\n\x05\x04R\x02\x03\x04\x12\x04\x9e\x04\x08\x10\n\r\n\x05\
    \x04R\x02\x03\x05\x12\x04\x9e\x04\x11\x17\n\r\n\x05\x04R\x02\x03\x01\x12\
    \x04\x9e\x04\x18\x1d\n\r\n\x05\x04R\x02\x03\x03\x12\x04\x9e\x04\x20!\n\
    \x0c\n\x04\x04R\x02\x04\x12\x04\x9f\x04\x08#\n\r\n\x05\x04R\x02\x04\x04\
    \x12\x04\x9f\x04\x08\x10\n\r\n\x05\x04R\x02\x04\x05\x12\x04\x9f\x04\x11\
    \x17\n\r\n\x05\x04R\x02\x04\x01\x12\x04\x9f\x04\x18\x1e\n\r\n\x05\x04R\
    \x02\x04\x03\x12\x04\x9f\x04!\"\n\x0c\n\x02\x04S\x12\x06\xa2\x04\0\xa6\
    \x04\x01\n\x0b\n\x03\x04S\x01\x12\x04\xa2\x04\x08\"\n\x0c\n\x04\x04S\x02\
    \0\x12\x04\xa3\x04\x08+\n\r\n\x05\x04S\x02\0\x04\x12\x04\xa3\x04\x08\x10\
    \n\r\n\x05\x04S\x02\0\x05\x12\x04\xa3\x04\x11\x17\n\r\n\x05\x04S\x02\0\
    \x01\x12\x04\xa3\x04\x18&\n\r\n\x05\x04S\x02\0\x03\x12\x04\xa3\x04)*\n\
    \x0c\n\x04\x04S\x02\x01\x12\x04\xa4\x04\x08\x20\n\r\n\x05\x04S\x02\x01\
    \x04\x12\x04\xa4\x04\x08\x10\n\r\n\x05\x04S\x02\x01\x05\x12\x04\xa4\x04\
    \x11\x17\n\r\n\x05\x04S\x02\x01\x01\x12\x04\xa4\x04\x18\x1b\n\r\n\x05\
    \x04S\x02\x01\x03\x12\x04\xa4\x04\x1e\x1f\n\x0c\n\x04\x04S\x02\x02\x12\
    \x04\xa5\x04\x08%\n\r\n\x05\x04S\x02\x02\x04\x12\x04\xa5\x04\x08\x10\n\r\
    \n\x05\x04S\x02\x02\x05\x12\x04\xa5\x04\x11\x17\n\r\n\x05\x04S\x02\x02\
    \x01\x12\x04\xa5\x04\x18\x20\n\r\n\x05\x04S\x02\x02\x03\x12\x04\xa5\x04#\
    $\n\x0c\n\x02\x04T\x12\x06\xa8\x04\0\xab\x04\x01\n\x0b\n\x03\x04T\x01\
    \x12\x04\xa8\x04\x08\x13\n\x0c\n\x04\x04T\x02\0\x12\x04\xa9\x04\x08+\n\r\
    \n\x05\x04T\x02\0\x04\x12\x04\xa9\x04\x08\x10\n\r\n\x05\x04T\x02\0\x05\
    \x12\x04\xa9\x04\x11\x17\n\r\n\x05\x04T\x02\0\x01\x12\x04\xa9\x04\x18&\n\
    \r\n\x05\x04T\x02\0\x03\x12\x04\xa9\x04)*\n\x0c\n\x04\x04T\x02\x01\x12\
    \x04\xaa\x04\x08$\n\r\n\x05\x04T\x02\x01\x04\x12\x04\xaa\x04\x08\x10\n\r\
    \n\x05\x04T\x02\x01\x05\x12\x04\xaa\x04\x11\x17\n\r\n\x05\x04T\x02\x01\
    \x01\x12\x04\xaa\x04\x18\x1f\n\r\n\x05\x04T\x02\x01\x03\x12\x04\xaa\x04\
    \"#\n\x0c\n\x02\x04U\x12\x06\xad\x04\0\xb0\x04\x01\n\x0b\n\x03\x04U\x01\
    \x12\x04\xad\x04\x08\x15\n\x0c\n\x04\x04U\x02\0\x12\x04\xae\x04\x08+\n\r\
    \n\x05\x04U\x02\0\x04\x12\x04\xae\x04\x08\x10\n\r\n\x05\x04U\x02\0\x05\
    \x12\x04\xae\x04\x11\x17\n\r\n\x05\x04U\x02\0\x01\x12\x04\xae\x04\x18&\n\
    \r\n\x05\x04U\x02\0\x03\x12\x04\xae\x04)*\n\x0c\n\x04\x04U\x02\x01\x12\
    \x04\xaf\x04\x08$\n\r\n\x05\x04U\x02\x01\x04\x12\x04\xaf\x04\x08\x10\n\r\
    \n\x05\x04U\x02\x01\x05\x12\x04\xaf\x04\x11\x17\n\r\n\x05\x04U\x02\x01\
    \x01\x12\x04\xaf\x04\x18\x1f\n\r\n\x05\x04U\x02\x01\x03\x12\x04\xaf\x04\
    \"#\n\x0c\n\x02\x04V\x12\x06\xb2\x04\0\xb5\x04\x01\n\x0b\n\x03\x04V\x01\
    \x12\x04\xb2\x04\x08\x1c\n\x0c\n\x04\x04V\x02\0\x12\x04\xb3\x04\x08+\n\r\
    \n\x05\x04V\x02\0\x04\x12\x04\xb3\x04\x08\x10\n\r\n\x05\x04V\x02\0\x05\
    \x12\x04\xb3\x04\x11\x17\n\r\n\x05\x04V\x02\0\x01\x12\x04\xb3\x04\x18&\n\
    \r\n\x05\x04V\x02\0\x03\x12\x04\xb3\x04)*\n\x0c\n\x04\x04V\x02\x01\x12\
    \x04\xb4\x04\x08!\n\r\n\x05\x04V\x02\x01\x04\x12\x04\xb4\x04\x08\x10\n\r\
    \n\x05\x04V\x02\x01\x05\x12\x04\xb4\x04\x11\x15\n\r\n\x05\x04V\x02\x01\
    \x01\x12\x04\xb4\x04\x16\x1c\n\r\n\x05\x04V\x02\x01\x03\x12\x04\xb4\x04\
    \x1f\x20\n\x0c\n\x02\x04W\x12\x06\xb7\x04\0\xbb\x04\x01\n\x0b\n\x03\x04W\
    \x01\x12\x04\xb7\x04\x08\x1f\n\x0c\n\x04\x04W\x02\0\x12\x04\xb8\x04\x08+\
    \n\r\n\x05\x04W\x02\0\x04\x12\x04\xb8\x04\x08\x10\n\r\n\x05\x04W\x02\0\
    \x05\x12\x04\xb8\x04\x11\x17\n\r\n\x05\x04W\x02\0\x01\x12\x04\xb8\x04\
    \x18&\n\r\n\x05\x04W\x02\0\x03\x12\x04\xb8\x04)*\n\x0c\n\x04\x04W\x02\
    \x01\x12\x04\xb9\x04\x08\"\n\r\n\x05\x04W\x02\x01\x04\x12\x04\xb9\x04\
    \x08\x10\n\r\n\x05\x04W\x02\x01\x05\x12\x04\xb9\x04\x11\x15\n\r\n\x05\
    \x04W\x02\x01\x01\x12\x04\xb9\x04\x16\x1d\n\r\n\x05\x04W\x02\x01\x03\x12\
    \x04\xb9\x04\x20!\n\x0c\n\x04\x04W\x02\x02\x12\x04\xba\x04\x08%\n\r\n\
    \x05\x04W\x02\x02\x04\x12\x04\xba\x04\x08\x10\n\r\n\x05\x04W\x02\x02\x05\
    \x12\x04\xba\x04\x11\x15\n\r\n\x05\x04W\x02\x02\x01\x12\x04\xba\x04\x16\
    \x20\n\r\n\x05\x04W\x02\x02\x03\x12\x04\xba\x04#$\n\x0c\n\x02\x04X\x12\
    \x06\xbd\x04\0\xc1\x04\x01\n\x0b\n\x03\x04X\x01\x12\x04\xbd\x04\x08\x18\
    \n\x0c\n\x04\x04X\x02\0\x12\x04\xbe\x04\x08+\n\r\n\x05\x04X\x02\0\x04\
    \x12\x04\xbe\x04\x08\x10\n\r\n\x05\x04X\x02\0\x05\x12\x04\xbe\x04\x11\
    \x17\n\r\n\x05\x04X\x02\0\x01\x12\x04\xbe\x04\x18&\n\r\n\x05\x04X\x02\0\
    \x03\x12\x04\xbe\x04)*\n\x0c\n\x04\x04X\x02\x01\x12\x04\xbf\x04\x08\x20\
    \n\r\n\x05\x04X\x02\x01\x04\x12\x04\xbf\x04\x08\x10\n\r\n\x05\x04X\x02\
    \x01\x05\x12\x04\xbf\x04\x11\x17\n\r\n\x05\x04X\x02\x01\x01\x12\x04\xbf\
    \x04\x18\x1b\n\r\n\x05\x04X\x02\x01\x03\x12\x04\xbf\x04\x1e\x1f\n\x0c\n\
    \x04\x04X\x02\x02\x12\x04\xc0\x04\x08%\n\r\n\x05\x04X\x02\x02\x04\x12\
    \x04\xc0\x04\x08\x10\n\r\n\x05\x04X\x02\x02\x05\x12\x04\xc0\x04\x11\x17\
    \n\r\n\x05\x04X\x02\x02\x01\x12\x04\xc0\x04\x18\x20\n\r\n\x05\x04X\x02\
    \x02\x03\x12\x04\xc0\x04#$\n\x0c\n\x02\x04Y\x12\x06\xc3\x04\0\xcb\x04\
    \x01\n\x0b\n\x03\x04Y\x01\x12\x04\xc3\x04\x08\x15\n\x0c\n\x04\x04Y\x02\0\
    \x12\x04\xc4\x04\x08\x20\n\r\n\x05\x04Y\x02\0\x04\x12\x04\xc4\x04\x08\
    \x10\n\r\n\x05\x04Y\x02\0\x05\x12\x04\xc4\x04\x11\x17\n\r\n\x05\x04Y\x02\
    \0\x01\x12\x04\xc4\x04\x18\x1b\n\r\n\x05\x04Y\x02\0\x03\x12\x04\xc4\x04\
    \x1e\x1f\n\x0c\n\x04\x04Y\x02\x01\x12\x04\xc5\x04\x08\"\n\r\n\x05\x04Y\
    \x02\x01\x04\x12\x04\xc5\x04\x08\x10\n\r\n\x05\x04Y\x02\x01\x05\x12\x04\
    \xc5\x04\x11\x17\n\r\n\x05\x04Y\x02\x01\x01\x12\x04\xc5\x04\x18\x1d\n\r\
    \n\x05\x04Y\x02\x01\x03\x12\x04\xc5\x04\x20!\n\x0c\n\x04\x04Y\x02\x02\
    \x12\x04\xc6\x04\x08!\n\r\n\x05\x04Y\x02\x02\x04\x12\x04\xc6\x04\x08\x10\
    \n\r\n\x05\x04Y\x02\x02\x05\x12\x04\xc6\x04\x11\x17\n\r\n\x05\x04Y\x02\
    \x02\x01\x12\x04\xc6\x04\x18\x1c\n\r\n\x05\x04Y\x02\x02\x03\x12\x04\xc6\
    \x04\x1f\x20\n\x0c\n\x04\x04Y\x02\x03\x12\x04\xc7\x04\x08!\n\r\n\x05\x04\
    Y\x02\x03\x04\x12\x04\xc7\x04\x08\x10\n\r\n\x05\x04Y\x02\x03\x05\x12\x04\
    \xc7\x04\x11\x17\n\r\n\x05\x04Y\x02\x03\x01\x12\x04\xc7\x04\x18\x1c\n\r\
    \n\x05\x04Y\x02\x03\x03\x12\x04\xc7\x04\x1f\x20\n\x0c\n\x04\x04Y\x02\x04\
    \x12\x04\xc8\x04\x08$\n\r\n\x05\x04Y\x02\x04\x04\x12\x04\xc8\x04\x08\x10\
    \n\r\n\x05\x04Y\x02\x04\x05\x12\x04\xc8\x04\x11\x17\n\r\n\x05\x04Y\x02\
    \x04\x01\x12\x04\xc8\x04\x18\x1f\n\r\n\x05\x04Y\x02\x04\x03\x12\x04\xc8\
    \x04\"#\n\x0c\n\x04\x04Y\x02\x05\x12\x04\xc9\x04\x08!\n\r\n\x05\x04Y\x02\
    \x05\x04\x12\x04\xc9\x04\x08\x10\n\r\n\x05\x04Y\x02\x05\x05\x12\x04\xc9\
    \x04\x11\x15\n\r\n\x05\x04Y\x02\x05\x01\x12\x04\xc9\x04\x16\x1c\n\r\n\
    \x05\x04Y\x02\x05\x03\x12\x04\xc9\x04\x1f\x20\n\x0c\n\x04\x04Y\x02\x06\
    \x12\x04\xca\x04\x08#\n\r\n\x05\x04Y\x02\x06\x04\x12\x04\xca\x04\x08\x10\
    \n\r\n\x05\x04Y\x02\x06\x05\x12\x04\xca\x04\x11\x15\n\r\n\x05\x04Y\x02\
    \x06\x01\x12\x04\xca\x04\x16\x1e\n\r\n\x05\x04Y\x02\x06\x03\x12\x04\xca\
    \x04!\"\n\x0c\n\x02\x04Z\x12\x06\xcd\x04\0\xd0\x04\x01\n\x0b\n\x03\x04Z\
    \x01\x12\x04\xcd\x04\x08\x1e\n\x0c\n\x04\x04Z\x02\0\x12\x04\xce\x04\x08+\
    \n\r\n\x05\x04Z\x02\0\x04\x12\x04\xce\x04\x08\x10\n\r\n\x05\x04Z\x02\0\
    \x05\x12\x04\xce\x04\x11\x17\n\r\n\x05\x04Z\x02\0\x01\x12\x04\xce\x04\
    \x18&\n\r\n\x05\x04Z\x02\0\x03\x12\x04\xce\x04)*\n\x0c\n\x04\x04Z\x02\
    \x01\x12\x04\xcf\x04\x08-\n\r\n\x05\x04Z\x02\x01\x04\x12\x04\xcf\x04\x08\
    \x10\n\r\n\x05\x04Z\x02\x01\x05\x12\x04\xcf\x04\x11\x17\n\r\n\x05\x04Z\
    \x02\x01\x01\x12\x04\xcf\x04\x18(\n\r\n\x05\x04Z\x02\x01\x03\x12\x04\xcf\
    \x04+,\n\x0c\n\x02\x04[\x12\x06\xd2\x04\0\xd4\x04\x01\n\x0b\n\x03\x04[\
    \x01\x12\x04\xd2\x04\x08\x18\n\x0c\n\x04\x04[\x02\0\x12\x04\xd3\x04\x08+\
    \n\r\n\x05\x04[\x02\0\x04\x12\x04\xd3\x04\x08\x10\n\r\n\x05\x04[\x02\0\
    \x05\x12\x04\xd3\x04\x11\x17\n\r\n\x05\x04[\x02\0\x01\x12\x04\xd3\x04\
    \x18&\n\r\n\x05\x04[\x02\0\x03\x12\x04\xd3\x04)*\n\x0c\n\x02\x04\\\x12\
    \x06\xd6\x04\0\xd8\x04\x01\n\x0b\n\x03\x04\\\x01\x12\x04\xd6\x04\x08\x17\
    \n\x0c\n\x04\x04\\\x02\0\x12\x04\xd7\x04\x08+\n\r\n\x05\x04\\\x02\0\x04\
    \x12\x04\xd7\x04\x08\x10\n\r\n\x05\x04\\\x02\0\x05\x12\x04\xd7\x04\x11\
    \x17\n\r\n\x05\x04\\\x02\0\x01\x12\x04\xd7\x04\x18&\n\r\n\x05\x04\\\x02\
    \0\x03\x12\x04\xd7\x04)*\n\x0c\n\x02\x04]\x12\x06\xda\x04\0\xdc\x04\x01\
    \n\x0b\n\x03\x04]\x01\x12\x04\xda\x04\x08\x1d\n\x0c\n\x04\x04]\x02\0\x12\
    \x04\xdb\x04\x08+\n\r\n\x05\x04]\x02\0\x04\x12\x04\xdb\x04\x08\x10\n\r\n\
    \x05\x04]\x02\0\x05\x12\x04\xdb\x04\x11\x17\n\r\n\x05\x04]\x02\0\x01\x12\
    \x04\xdb\x04\x18&\n\r\n\x05\x04]\x02\0\x03\x12\x04\xdb\x04)*\n\x0c\n\x02\
    \x04^\x12\x06\xde\x04\0\xe0\x04\x01\n\x0b\n\x03\x04^\x01\x12\x04\xde\x04\
    \x08\x1a\n\x0c\n\x04\x04^\x02\0\x12\x04\xdf\x04\x08+\n\r\n\x05\x04^\x02\
    \0\x04\x12\x04\xdf\x04\x08\x10\n\r\n\x05\x04^\x02\0\x05\x12\x04\xdf\x04\
    \x11\x17\n\r\n\x05\x04^\x02\0\x01\x12\x04\xdf\x04\x18&\n\r\n\x05\x04^\
    \x02\0\x03\x12\x04\xdf\x04)*\n\x0c\n\x02\x04_\x12\x06\xe2\x04\0\xe4\x04\
    \x01\n\x0b\n\x03\x04_\x01\x12\x04\xe2\x04\x08\"\n\x0c\n\x04\x04_\x02\0\
    \x12\x04\xe3\x04\x08+\n\r\n\x05\x04_\x02\0\x04\x12\x04\xe3\x04\x08\x10\n\
    \r\n\x05\x04_\x02\0\x05\x12\x04\xe3\x04\x11\x17\n\r\n\x05\x04_\x02\0\x01\
    \x12\x04\xe3\x04\x18&\n\r\n\x05\x04_\x02\0\x03\x12\x04\xe3\x04)*\n\x0c\n\
    \x02\x04`\x12\x06\xe6\x04\0\xe8\x04\x01\n\x0b\n\x03\x04`\x01\x12\x04\xe6\
    \x04\x08\x1e\n\x0c\n\x04\x04`\x02\0\x12\x04\xe7\x04\x08+\n\r\n\x05\x04`\
    \x02\0\x04\x12\x04\xe7\x04\x08\x10\n\r\n\x05\x04`\x02\0\x05\x12\x04\xe7\
    \x04\x11\x17\n\r\n\x05\x04`\x02\0\x01\x12\x04\xe7\x04\x18&\n\r\n\x05\x04\
    `\x02\0\x03\x12\x04\xe7\x04)*\n\x0c\n\x02\x04a\x12\x06\xea\x04\0\xec\x04\
    \x01\n\x0b\n\x03\x04a\x01\x12\x04\xea\x04\x08'\n\x0c\n\x04\x04a\x02\0\
    \x12\x04\xeb\x04\x08+\n\r\n\x05\x04a\x02\0\x04\x12\x04\xeb\x04\x08\x10\n\
    \r\n\x05\x04a\x02\0\x05\x12\x04\xeb\x04\x11\x17\n\r\n\x05\x04a\x02\0\x01\
    \x12\x04\xeb\x04\x18&\n\r\n\x05\x04a\x02\0\x03\x12\x04\xeb\x04)*\n\x0c\n\
    \x02\x04b\x12\x06\xee\x04\0\xf0\x04\x01\n\x0b\n\x03\x04b\x01\x12\x04\xee\
    \x04\x08\x1e\n\x0c\n\x04\x04b\x02\0\x12\x04\xef\x04\x08+\n\r\n\x05\x04b\
    \x02\0\x04\x12\x04\xef\x04\x08\x10\n\r\n\x05\x04b\x02\0\x05\x12\x04\xef\
    \x04\x11\x17\n\r\n\x05\x04b\x02\0\x01\x12\x04\xef\x04\x18&\n\r\n\x05\x04\
    b\x02\0\x03\x12\x04\xef\x04)*\n\x0c\n\x02\x04c\x12\x06\xf2\x04\0\xf5\x04\
    \x01\n\x0b\n\x03\x04c\x01\x12\x04\xf2\x04\x08\x1c\n\x0c\n\x04\x04c\x02\0\
    \x12\x04\xf3\x04\x08+\n\r\n\x05\x04c\x02\0\x04\x12\x04\xf3\x04\x08\x10\n\
    \r\n\x05\x04c\x02\0\x05\x12\x04\xf3\x04\x11\x17\n\r\n\x05\x04c\x02\0\x01\
    \x12\x04\xf3\x04\x18&\n\r\n\x05\x04c\x02\0\x03\x12\x04\xf3\x04)*\n\x0c\n\
    \x04\x04c\x02\x01\x12\x04\xf4\x04\x08\x20\n\r\n\x05\x04c\x02\x01\x04\x12\
    \x04\xf4\x04\x08\x10\n\r\n\x05\x04c\x02\x01\x05\x12\x04\xf4\x04\x11\x17\
    \n\r\n\x05\x04c\x02\x01\x01\x12\x04\xf4\x04\x18\x1b\n\r\n\x05\x04c\x02\
    \x01\x03\x12\x04\xf4\x04\x1e\x1f\n\x0c\n\x02\x04d\x12\x06\xf7\x04\0\xfc\
    \x04\x01\n\x0b\n\x03\x04d\x01\x12\x04\xf7\x04\x08\x0f\n\x0c\n\x04\x04d\
    \x02\0\x12\x04\xf8\x04\x08!\n\r\n\x05\x04d\x02\0\x04\x12\x04\xf8\x04\x08\
    \x10\n\r\n\x05\x04d\x02\0\x05\x12\x04\xf8\x04\x11\x17\n\r\n\x05\x04d\x02\
    \0\x01\x12\x04\xf8\x04\x18\x1c\n\r\n\x05\x04d\x02\0\x03\x12\x04\xf8\x04\
    \x1f\x20\n\x0c\n\x04\x04d\x02\x01\x12\x04\xf9\x04\x08\"\n\r\n\x05\x04d\
    \x02\x01\x04\x12\x04\xf9\x04\x08\x10\n\r\n\x05\x04d\x02\x01\x05\x12\x04\
    \xf9\x04\x11\x17\n\r\n\x05\x04d\x02\x01\x01\x12\x04\xf9\x04\x18\x1d\n\r\
    \n\x05\x04d\x02\x01\x03\x12\x04\xf9\x04\x20!\n\x0c\n\x04\x04d\x02\x02\
    \x12\x04\xfa\x04\x08#\n\r\n\x05\x04d\x02\x02\x04\x12\x04\xfa\x04\x08\x10\
    \n\r\n\x05\x04d\x02\x02\x05\x12\x04\xfa\x04\x11\x17\n\r\n\x05\x04d\x02\
    \x02\x01\x12\x04\xfa\x04\x18\x1e\n\r\n\x05\x04d\x02\x02\x03\x12\x04\xfa\
    \x04!\"\n\x0c\n\x04\x04d\x02\x03\x12\x04\xfb\x04\x08!\n\r\n\x05\x04d\x02\
    \x03\x04\x12\x04\xfb\x04\x08\x10\n\r\n\x05\x04d\x02\x03\x05\x12\x04\xfb\
    \x04\x11\x17\n\r\n\x05\x04d\x02\x03\x01\x12\x04\xfb\x04\x18\x1c\n\r\n\
    \x05\x04d\x02\x03\x03\x12\x04\xfb\x04\x1f\x20\n\x0c\n\x02\x04e\x12\x06\
    \xfe\x04\0\x82\x05\x01\n\x0b\n\x03\x04e\x01\x12\x04\xfe\x04\x08$\n\x0c\n\
    \x04\x04e\x02\0\x12\x04\xff\x04\x08+\n\r\n\x05\x04e\x02\0\x04\x12\x04\
    \xff\x04\x08\x10\n\r\n\x05\x04e\x02\0\x05\x12\x04\xff\x04\x11\x17\n\r\n\
    \x05\x04e\x02\0\x01\x12\x04\xff\x04\x18&\n\r\n\x05\x04e\x02\0\x03\x12\
    \x04\xff\x04)*\n\x0c\n\x04\x04e\x02\x01\x12\x04\x80\x05\x08\x20\n\r\n\
    \x05\x04e\x02\x01\x04\x12\x04\x80\x05\x08\x10\n\r\n\x05\x04e\x02\x01\x05\
    \x12\x04\x80\x05\x11\x17\n\r\n\x05\x04e\x02\x01\x01\x12\x04\x80\x05\x18\
    \x1b\n\r\n\x05\x04e\x02\x01\x03\x12\x04\x80\x05\x1e\x1f\n\x0c\n\x04\x04e\
    \x02\x02\x12\x04\x81\x05\x08&\n\r\n\x05\x04e\x02\x02\x04\x12\x04\x81\x05\
    \x08\x10\n\r\n\x05\x04e\x02\x02\x06\x12\x04\x81\x05\x11\x19\n\r\n\x05\
    \x04e\x02\x02\x01\x12\x04\x81\x05\x1a!\n\r\n\x05\x04e\x02\x02\x03\x12\
    \x04\x81\x05$%\n\x0c\n\x02\x04f\x12\x06\x84\x05\0\x8c\x05\x01\n\x0b\n\
    \x03\x04f\x01\x12\x04\x84\x05\x08\x18\n\x0c\n\x04\x04f\x02\0\x12\x04\x85\
    \x05\x08+\n\r\n\x05\x04f\x02\0\x04\x12\x04\x85\x05\x08\x10\n\r\n\x05\x04\
    f\x02\0\x05\x12\x04\x85\x05\x11\x17\n\r\n\x05\x04f\x02\0\x01\x12\x04\x85\
    \x05\x18&\n\r\n\x05\x04f\x02\0\x03\x12\x04\x85\x05)*\n\x0c\n\x04\x04f\
    \x02\x01\x12\x04\x86\x05\x08!\n\r\n\x05\x04f\x02\x01\x04\x12\x04\x86\x05\
    \x08\x10\n\r\n\x05\x04f\x02\x01\x05\x12\x04\x86\x05\x11\x15\n\r\n\x05\
    \x04f\x02\x01\x01\x12\x04\x86\x05\x16\x1c\n\r\n\x05\x04f\x02\x01\x03\x12\
    \x04\x86\x05\x1f\x20\n\x0c\n\x04\x04f\x02\x02\x12\x04\x87\x05\x08!\n\r\n\
    \x05\x04f\x02\x02\x04\x12\x04\x87\x05\x08\x10\n\r\n\x05\x04f\x02\x02\x05\
    \x12\x04\x87\x05\x11\x17\n\r\n\x05\x04f\x02\x02\x01\x12\x04\x87\x05\x18\
    \x1c\n\r\n\x05\x04f\x02\x02\x03\x12\x04\x87\x05\x1f\x20\n\x0c\n\x04\x04f\
    \x02\x03\x12\x04\x88\x05\x08+\n\r\n\x05\x04f\x02\x03\x04\x12\x04\x88\x05\
    \x08\x10\n\r\n\x05\x04f\x02\x03\x05\x12\x04\x88\x05\x11\x17\n\r\n\x05\
    \x04f\x02\x03\x01\x12\x04\x88\x05\x18&\n\r\n\x05\x04f\x02\x03\x03\x12\
    \x04\x88\x05)*\n\x0c\n\x04\x04f\x02\x04\x12\x04\x89\x05\x08-\n\r\n\x05\
    \x04f\x02\x04\x04\x12\x04\x89\x05\x08\x10\n\r\n\x05\x04f\x02\x04\x05\x12\
    \x04\x89\x05\x11\x17\n\r\n\x05\x04f\x02\x04\x01\x12\x04\x89\x05\x18(\n\r\
    \n\x05\x04f\x02\x04\x03\x12\x04\x89\x05+,\n\x0c\n\x04\x04f\x02\x05\x12\
    \x04\x8a\x05\x08-\n\r\n\x05\x04f\x02\x05\x04\x12\x04\x8a\x05\x08\x10\n\r\
    \n\x05\x04f\x02\x05\x05\x12\x04\x8a\x05\x11\x15\n\r\n\x05\x04f\x02\x05\
    \x01\x12\x04\x8a\x05\x16(\n\r\n\x05\x04f\x02\x05\x03\x12\x04\x8a\x05+,\n\
    \x0c\n\x04\x04f\x02\x06\x12\x04\x8b\x05\x08'\n\r\n\x05\x04f\x02\x06\x04\
    \x12\x04\x8b\x05\x08\x10\n\r\n\x05\x04f\x02\x06\x05\x12\x04\x8b\x05\x11\
    \x17\n\r\n\x05\x04f\x02\x06\x01\x12\x04\x8b\x05\x18\"\n\r\n\x05\x04f\x02\
    \x06\x03\x12\x04\x8b\x05%&\n\x0c\n\x02\x04g\x12\x06\x8e\x05\0\x90\x05\
    \x01\n\x0b\n\x03\x04g\x01\x12\x04\x8e\x05\x08\x20\n\x0c\n\x04\x04g\x02\0\
    \x12\x04\x8f\x05\x08+\n\r\n\x05\x04g\x02\0\x04\x12\x04\x8f\x05\x08\x10\n\
    \r\n\x05\x04g\x02\0\x05\x12\x04\x8f\x05\x11\x17\n\r\n\x05\x04g\x02\0\x01\
    \x12\x04\x8f\x05\x18&\n\r\n\x05\x04g\x02\0\x03\x12\x04\x8f\x05)*\n\x0c\n\
    \x02\x04h\x12\x06\x92\x05\0\x94\x05\x01\n\x0b\n\x03\x04h\x01\x12\x04\x92\
    \x05\x08&\n\x0c\n\x04\x04h\x02\0\x12\x04\x93\x05\x08+\n\r\n\x05\x04h\x02\
    \0\x04\x12\x04\x93\x05\x08\x10\n\r\n\x05\x04h\x02\0\x05\x12\x04\x93\x05\
    \x11\x17\n\r\n\x05\x04h\x02\0\x01\x12\x04\x93\x05\x18&\n\r\n\x05\x04h\
    \x02\0\x03\x12\x04\x93\x05)*\n\x0c\n\x02\x04i\x12\x06\x96\x05\0\x98\x05\
    \x01\n\x0b\n\x03\x04i\x01\x12\x04\x96\x05\x08+\n\x0c\n\x04\x04i\x02\0\
    \x12\x04\x97\x05\x08+\n\r\n\x05\x04i\x02\0\x04\x12\x04\x97\x05\x08\x10\n\
    \r\n\x05\x04i\x02\0\x05\x12\x04\x97\x05\x11\x17\n\r\n\x05\x04i\x02\0\x01\
    \x12\x04\x97\x05\x18&\n\r\n\x05\x04i\x02\0\x03\x12\x04\x97\x05)*\n\x0c\n\
    \x02\x04j\x12\x06\x9a\x05\0\x9c\x05\x01\n\x0b\n\x03\x04j\x01\x12\x04\x9a\
    \x05\x08\x1b\n\x0c\n\x04\x04j\x02\0\x12\x04\x9b\x05\x08+\n\r\n\x05\x04j\
    \x02\0\x04\x12\x04\x9b\x05\x08\x10\n\r\n\x05\x04j\x02\0\x05\x12\x04\x9b\
    \x05\x11\x17\n\r\n\x05\x04j\x02\0\x01\x12\x04\x9b\x05\x18&\n\r\n\x05\x04\
    j\x02\0\x03\x12\x04\x9b\x05)*\n\x0c\n\x02\x04k\x12\x06\x9e\x05\0\xa1\x05\
    \x01\n\x0b\n\x03\x04k\x01\x12\x04\x9e\x05\x08#\n\x0c\n\x04\x04k\x02\0\
    \x12\x04\x9f\x05\x08+\n\r\n\x05\x04k\x02\0\x04\x12\x04\x9f\x05\x08\x10\n\
    \r\n\x05\x04k\x02\0\x05\x12\x04\x9f\x05\x11\x17\n\r\n\x05\x04k\x02\0\x01\
    \x12\x04\x9f\x05\x18&\n\r\n\x05\x04k\x02\0\x03\x12\x04\x9f\x05)*\n\x0c\n\
    \x04\x04k\x02\x01\x12\x04\xa0\x05\x08\"\n\r\n\x05\x04k\x02\x01\x04\x12\
    \x04\xa0\x05\x08\x10\n\r\n\x05\x04k\x02\x01\x05\x12\x04\xa0\x05\x11\x17\
    \n\r\n\x05\x04k\x02\x01\x01\x12\x04\xa0\x05\x18\x1d\n\r\n\x05\x04k\x02\
    \x01\x03\x12\x04\xa0\x05\x20!\n\x0c\n\x02\x04l\x12\x06\xa3\x05\0\xa5\x05\
    \x01\n\x0b\n\x03\x04l\x01\x12\x04\xa3\x05\x08\x13\n\x0c\n\x04\x04l\x02\0\
    \x12\x04\xa4\x05\x08%\n\r\n\x05\x04l\x02\0\x04\x12\x04\xa4\x05\x08\x10\n\
    \r\n\x05\x04l\x02\0\x05\x12\x04\xa4\x05\x11\x17\n\r\n\x05\x04l\x02\0\x01\
    \x12\x04\xa4\x05\x18\x20\n\r\n\x05\x04l\x02\0\x03\x12\x04\xa4\x05#$\n\
    \x0c\n\x02\x04m\x12\x06\xa7\x05\0\xa9\x05\x01\n\x0b\n\x03\x04m\x01\x12\
    \x04\xa7\x05\x08\x18\n\x0c\n\x04\x04m\x02\0\x12\x04\xa8\x05\x08+\n\r\n\
    \x05\x04m\x02\0\x04\x12\x04\xa8\x05\x08\x10\n\r\n\x05\x04m\x02\0\x05\x12\
    \x04\xa8\x05\x11\x17\n\r\n\x05\x04m\x02\0\x01\x12\x04\xa8\x05\x18&\n\r\n\
    \x05\x04m\x02\0\x03\x12\x04\xa8\x05)*\n\x0c\n\x02\x04n\x12\x06\xab\x05\0\
    \xad\x05\x01\n\x0b\n\x03\x04n\x01\x12\x04\xab\x05\x08\x19\n\x0c\n\x04\
    \x04n\x02\0\x12\x04\xac\x05\x08+\n\r\n\x05\x04n\x02\0\x04\x12\x04\xac\
    \x05\x08\x10\n\r\n\x05\x04n\x02\0\x05\x12\x04\xac\x05\x11\x17\n\r\n\x05\
    \x04n\x02\0\x01\x12\x04\xac\x05\x18&\n\r\n\x05\x04n\x02\0\x03\x12\x04\
    \xac\x05)*\n\x0c\n\x02\x04o\x12\x06\xaf\x05\0\xb2\x05\x01\n\x0b\n\x03\
    \x04o\x01\x12\x04\xaf\x05\x08\x16\n\x0c\n\x04\x04o\x02\0\x12\x04\xb0\x05\
    \x08+\n\r\n\x05\x04o\x02\0\x04\x12\x04\xb0\x05\x08\x10\n\r\n\x05\x04o\
    \x02\0\x05\x12\x04\xb0\x05\x11\x17\n\r\n\x05\x04o\x02\0\x01\x12\x04\xb0\
    \x05\x18&\n\r\n\x05\x04o\x02\0\x03\x12\x04\xb0\x05)*\n\x0c\n\x04\x04o\
    \x02\x01\x12\x04\xb1\x05\x08(\n\r\n\x05\x04o\x02\x01\x04\x12\x04\xb1\x05\
    \x08\x10\n\r\n\x05\x04o\x02\x01\x05\x12\x04\xb1\x05\x11\x17\n\r\n\x05\
    \x04o\x02\x01\x01\x12\x04\xb1\x05\x18#\n\r\n\x05\x04o\x02\x01\x03\x12\
    \x04\xb1\x05&'\n\x0c\n\x02\x04p\x12\x06\xb4\x05\0\xc0\x05\x01\n\x0b\n\
    \x03\x04p\x01\x12\x04\xb4\x05\x08$\n\x0c\n\x04\x04p\x02\0\x12\x04\xb5\
    \x05\x08+\n\r\n\x05\x04p\x02\0\x04\x12\x04\xb5\x05\x08\x10\n\r\n\x05\x04\
    p\x02\0\x05\x12\x04\xb5\x05\x11\x17\n\r\n\x05\x04p\x02\0\x01\x12\x04\xb5\
    \x05\x18&\n\r\n\x05\x04p\x02\0\x03\x12\x04\xb5\x05)*\n\x0c\n\x04\x04p\
    \x02\x01\x12\x04\xb6\x05\x08+\n\r\n\x05\x04p\x02\x01\x04\x12\x04\xb6\x05\
    \x08\x10\n\r\n\x05\x04p\x02\x01\x05\x12\x04\xb6\x05\x11\x17\n\r\n\x05\
    \x04p\x02\x01\x01\x12\x04\xb6\x05\x18&\n\r\n\x05\x04p\x02\x01\x03\x12\
    \x04\xb6\x05)*\n\x0c\n\x04\x04p\x02\x02\x12\x04\xb7\x05\x08,\n\r\n\x05\
    \x04p\x02\x02\x04\x12\x04\xb7\x05\x08\x10\n\r\n\x05\x04p\x02\x02\x05\x12\
    \x04\xb7\x05\x11\x17\n\r\n\x05\x04p\x02\x02\x01\x12\x04\xb7\x05\x18'\n\r\
    \n\x05\x04p\x02\x02\x03\x12\x04\xb7\x05*+\n\x0c\n\x04\x04p\x02\x03\x12\
    \x04\xb8\x05\x08)\n\r\n\x05\x04p\x02\x03\x04\x12\x04\xb8\x05\x08\x10\n\r\
    \n\x05\x04p\x02\x03\x05\x12\x04\xb8\x05\x11\x17\n\r\n\x05\x04p\x02\x03\
    \x01\x12\x04\xb8\x05\x18$\n\r\n\x05\x04p\x02\x03\x03\x12\x04\xb8\x05'(\n\
    \x0c\n\x04\x04p\x02\x04\x12\x04\xb9\x05\x08(\n\r\n\x05\x04p\x02\x04\x04\
    \x12\x04\xb9\x05\x08\x10\n\r\n\x05\x04p\x02\x04\x05\x12\x04\xb9\x05\x11\
    \x17\n\r\n\x05\x04p\x02\x04\x01\x12\x04\xb9\x05\x18#\n\r\n\x05\x04p\x02\
    \x04\x03\x12\x04\xb9\x05&'\n\x0c\n\x04\x04p\x02\x05\x12\x04\xba\x05\x08*\
    \n\r\n\x05\x04p\x02\x05\x04\x12\x04\xba\x05\x08\x10\n\r\n\x05\x04p\x02\
    \x05\x05\x12\x04\xba\x05\x11\x17\n\r\n\x05\x04p\x02\x05\x01\x12\x04\xba\
    \x05\x18%\n\r\n\x05\x04p\x02\x05\x03\x12\x04\xba\x05()\n\x0c\n\x04\x04p\
    \x02\x06\x12\x04\xbb\x05\x08+\n\r\n\x05\x04p\x02\x06\x04\x12\x04\xbb\x05\
    \x08\x10\n\r\n\x05\x04p\x02\x06\x05\x12\x04\xbb\x05\x11\x17\n\r\n\x05\
    \x04p\x02\x06\x01\x12\x04\xbb\x05\x18&\n\r\n\x05\x04p\x02\x06\x03\x12\
    \x04\xbb\x05)*\n\x0c\n\x04\x04p\x02\x07\x12\x04\xbc\x05\x08(\n\r\n\x05\
    \x04p\x02\x07\x04\x12\x04\xbc\x05\x08\x10\n\r\n\x05\x04p\x02\x07\x05\x12\
    \x04\xbc\x05\x11\x17\n\r\n\x05\x04p\x02\x07\x01\x12\x04\xbc\x05\x18#\n\r\
    \n\x05\x04p\x02\x07\x03\x12\x04\xbc\x05&'\n\x0c\n\x04\x04p\x02\x08\x12\
    \x04\xbd\x05\x08'\n\r\n\x05\x04p\x02\x08\x04\x12\x04\xbd\x05\x08\x10\n\r\
    \n\x05\x04p\x02\x08\x05\x12\x04\xbd\x05\x11\x17\n\r\n\x05\x04p\x02\x08\
    \x01\x12\x04\xbd\x05\x18\"\n\r\n\x05\x04p\x02\x08\x03\x12\x04\xbd\x05%&\
    \n\x0c\n\x04\x04p\x02\t\x12\x04\xbe\x05\x08*\n\r\n\x05\x04p\x02\t\x04\
    \x12\x04\xbe\x05\x08\x10\n\r\n\x05\x04p\x02\t\x05\x12\x04\xbe\x05\x11\
    \x17\n\r\n\x05\x04p\x02\t\x01\x12\x04\xbe\x05\x18$\n\r\n\x05\x04p\x02\t\
    \x03\x12\x04\xbe\x05')\n\x0c\n\x04\x04p\x02\n\x12\x04\xbf\x05\x08+\n\r\n\
    \x05\x04p\x02\n\x04\x12\x04\xbf\x05\x08\x10\n\r\n\x05\x04p\x02\n\x05\x12\
    \x04\xbf\x05\x11\x17\n\r\n\x05\x04p\x02\n\x01\x12\x04\xbf\x05\x18%\n\r\n\
    \x05\x04p\x02\n\x03\x12\x04\xbf\x05(*\n\x0c\n\x02\x04q\x12\x06\xc2\x05\0\
    \xc4\x05\x01\n\x0b\n\x03\x04q\x01\x12\x04\xc2\x05\x08\x1b\n\x0c\n\x04\
    \x04q\x02\0\x12\x04\xc3\x05\x08+\n\r\n\x05\x04q\x02\0\x04\x12\x04\xc3\
    \x05\x08\x10\n\r\n\x05\x04q\x02\0\x05\x12\x04\xc3\x05\x11\x17\n\r\n\x05\
    \x04q\x02\0\x01\x12\x04\xc3\x05\x18&\n\r\n\x05\x04q\x02\0\x03\x12\x04\
    \xc3\x05)*\n\x0c\n\x02\x04r\x12\x06\xc6\x05\0\xc9\x05\x01\n\x0b\n\x03\
    \x04r\x01\x12\x04\xc6\x05\x08\x15\n\x0c\n\x04\x04r\x02\0\x12\x04\xc7\x05\
    \x08+\n\r\n\x05\x04r\x02\0\x04\x12\x04\xc7\x05\x08\x10\n\r\n\x05\x04r\
    \x02\0\x05\x12\x04\xc7\x05\x11\x17\n\r\n\x05\x04r\x02\0\x01\x12\x04\xc7\
    \x05\x18&\n\r\n\x05\x04r\x02\0\x03\x12\x04\xc7\x05)*\n\x0c\n\x04\x04r\
    \x02\x01\x12\x04\xc8\x05\x08'\n\r\n\x05\x04r\x02\x01\x04\x12\x04\xc8\x05\
    \x08\x10\n\r\n\x05\x04r\x02\x01\x05\x12\x04\xc8\x05\x11\x16\n\r\n\x05\
    \x04r\x02\x01\x01\x12\x04\xc8\x05\x17\"\n\r\n\x05\x04r\x02\x01\x03\x12\
    \x04\xc8\x05%&\n\x0c\n\x02\x04s\x12\x06\xcb\x05\0\xcd\x05\x01\n\x0b\n\
    \x03\x04s\x01\x12\x04\xcb\x05\x08\x1e\n\x0c\n\x04\x04s\x02\0\x12\x04\xcc\
    \x05\x08$\n\r\n\x05\x04s\x02\0\x04\x12\x04\xcc\x05\x08\x10\n\r\n\x05\x04\
    s\x02\0\x05\x12\x04\xcc\x05\x11\x17\n\r\n\x05\x04s\x02\0\x01\x12\x04\xcc\
    \x05\x18\x1f\n\r\n\x05\x04s\x02\0\x03\x12\x04\xcc\x05\"#\n\x0c\n\x02\x04\
    t\x12\x06\xcf\x05\0\xd1\x05\x01\n\x0b\n\x03\x04t\x01\x12\x04\xcf\x05\x08\
    \x1b\n\x0c\n\x04\x04t\x02\0\x12\x04\xd0\x05\x08!\n\r\n\x05\x04t\x02\0\
    \x04\x12\x04\xd0\x05\x08\x10\n\r\n\x05\x04t\x02\0\x05\x12\x04\xd0\x05\
    \x11\x15\n\r\n\x05\x04t\x02\0\x01\x12\x04\xd0\x05\x16\x1c\n\r\n\x05\x04t\
    \x02\0\x03\x12\x04\xd0\x05\x1f\x20\n\x0c\n\x02\x04u\x12\x06\xd3\x05\0\
    \xd5\x05\x01\n\x0b\n\x03\x04u\x01\x12\x04\xd3\x05\x08\x1f\n\x0c\n\x04\
    \x04u\x02\0\x12\x04\xd4\x05\x08\"\n\r\n\x05\x04u\x02\0\x04\x12\x04\xd4\
    \x05\x08\x10\n\r\n\x05\x04u\x02\0\x05\x12\x04\xd4\x05\x11\x15\n\r\n\x05\
    \x04u\x02\0\x01\x12\x04\xd4\x05\x16\x1d\n\r\n\x05\x04u\x02\0\x03\x12\x04\
    \xd4\x05\x20!\n\x0c\n\x02\x04v\x12\x06\xd7\x05\0\xdb\x05\x01\n\x0b\n\x03\
    \x04v\x01\x12\x04\xd7\x05\x08\x1c\n\x0c\n\x04\x04v\x02\0\x12\x04\xd8\x05\
    \x08+\n\r\n\x05\x04v\x02\0\x04\x12\x04\xd8\x05\x08\x10\n\r\n\x05\x04v\
    \x02\0\x05\x12\x04\xd8\x05\x11\x17\n\r\n\x05\x04v\x02\0\x01\x12\x04\xd8\
    \x05\x18&\n\r\n\x05\x04v\x02\0\x03\x12\x04\xd8\x05)*\n\x0c\n\x04\x04v\
    \x02\x01\x12\x04\xd9\x05\x08!\n\r\n\x05\x04v\x02\x01\x04\x12\x04\xd9\x05\
    \x08\x10\n\r\n\x05\x04v\x02\x01\x05\x12\x04\xd9\x05\x11\x17\n\r\n\x05\
    \x04v\x02\x01\x01\x12\x04\xd9\x05\x18\x1c\n\r\n\x05\x04v\x02\x01\x03\x12\
    \x04\xd9\x05\x1f\x20\n\x0c\n\x04\x04v\x02\x02\x12\x04\xda\x05\x08d\n\r\n\
    \x05\x04v\x02\x02\x04\x12\x04\xda\x05\x08\x10\n\r\n\x05\x04v\x02\x02\x06\
    \x12\x04\xda\x05\x11'\n\r\n\x05\x04v\x02\x02\x01\x12\x04\xda\x05(3\n\r\n\
    \x05\x04v\x02\x02\x03\x12\x04\xda\x0567\n\r\n\x05\x04v\x02\x02\x08\x12\
    \x04\xda\x058c\n\r\n\x05\x04v\x02\x02\x07\x12\x04\xda\x05Cb\n\x0c\n\x02\
    \x04w\x12\x06\xdd\x05\0\xe0\x05\x01\n\x0b\n\x03\x04w\x01\x12\x04\xdd\x05\
    \x08\x19\n\x0c\n\x04\x04w\x02\0\x12\x04\xde\x05\x08&\n\r\n\x05\x04w\x02\
    \0\x04\x12\x04\xde\x05\x08\x10\n\r\n\x05\x04w\x02\0\x05\x12\x04\xde\x05\
    \x11\x17\n\r\n\x05\x04w\x02\0\x01\x12\x04\xde\x05\x18!\n\r\n\x05\x04w\
    \x02\0\x03\x12\x04\xde\x05$%\n\x0c\n\x04\x04w\x02\x01\x12\x04\xdf\x05\
    \x08,\n\r\n\x05\x04w\x02\x01\x04\x12\x04\xdf\x05\x08\x10\n\r\n\x05\x04w\
    \x02\x01\x05\x12\x04\xdf\x05\x11\x17\n\r\n\x05\x04w\x02\x01\x01\x12\x04\
    \xdf\x05\x18'\n\r\n\x05\x04w\x02\x01\x03\x12\x04\xdf\x05*+\n\x0c\n\x02\
    \x04x\x12\x06\xe2\x05\0\xf2\x05\x01\n\x0b\n\x03\x04x\x01\x12\x04\xe2\x05\
    \x08\x13\n\x0e\n\x04\x04x\x03\0\x12\x06\xe3\x05\x08\xe6\x05\t\n\r\n\x05\
    \x04x\x03\0\x01\x12\x04\xe3\x05\x10\x20\n\x0e\n\x06\x04x\x03\0\x02\0\x12\
    \x04\xe4\x05\x10)\n\x0f\n\x07\x04x\x03\0\x02\0\x04\x12\x04\xe4\x05\x10\
    \x18\n\x0f\n\x07\x04x\x03\0\x02\0\x05\x12\x04\xe4\x05\x19\x1f\n\x0f\n\
    \x07\x04x\x03\0\x02\0\x01\x12\x04\xe4\x05\x20$\n\x0f\n\x07\x04x\x03\0\
    \x02\0\x03\x12\x04\xe4\x05'(\n\x0e\n\x06\x04x\x03\0\x02\x01\x12\x04\xe5\
    \x05\x100\n\x0f\n\x07\x04x\x03\0\x02\x01\x04\x12\x04\xe5\x05\x10\x18\n\
    \x0f\n\x07\x04x\x03\0\x02\x01\x06\x12\x04\xe5\x05\x19%\n\x0f\n\x07\x04x\
    \x03\0\x02\x01\x01\x12\x04\xe5\x05&+\n\x0f\n\x07\x04x\x03\0\x02\x01\x03\
    \x12\x04\xe5\x05./\n\x0c\n\x04\x04x\x02\0\x12\x04\xe8\x05\x08%\n\r\n\x05\
    \x04x\x02\0\x04\x12\x04\xe8\x05\x08\x10\n\r\n\x05\x04x\x02\0\x05\x12\x04\
    \xe8\x05\x11\x15\n\r\n\x05\x04x\x02\0\x01\x12\x04\xe8\x05\x16\x20\n\r\n\
    \x05\x04x\x02\0\x03\x12\x04\xe8\x05#$\n\x0c\n\x04\x04x\x02\x01\x12\x04\
    \xe9\x05\x08%\n\r\n\x05\x04x\x02\x01\x04\x12\x04\xe9\x05\x08\x10\n\r\n\
    \x05\x04x\x02\x01\x05\x12\x04\xe9\x05\x11\x16\n\r\n\x05\x04x\x02\x01\x01\
    \x12\x04\xe9\x05\x17\x20\n\r\n\x05\x04x\x02\x01\x03\x12\x04\xe9\x05#$\n\
    \x0c\n\x04\x04x\x02\x02\x12\x04\xea\x05\x08'\n\r\n\x05\x04x\x02\x02\x04\
    \x12\x04\xea\x05\x08\x10\n\r\n\x05\x04x\x02\x02\x05\x12\x04\xea\x05\x11\
    \x17\n\r\n\x05\x04x\x02\x02\x01\x12\x04\xea\x05\x18\"\n\r\n\x05\x04x\x02\
    \x02\x03\x12\x04\xea\x05%&\n\x0c\n\x04\x04x\x02\x03\x12\x04\xeb\x05\x08)\
    \n\r\n\x05\x04x\x02\x03\x04\x12\x04\xeb\x05\x08\x10\n\r\n\x05\x04x\x02\
    \x03\x05\x12\x04\xeb\x05\x11\x17\n\r\n\x05\x04x\x02\x03\x01\x12\x04\xeb\
    \x05\x18$\n\r\n\x05\x04x\x02\x03\x03\x12\x04\xeb\x05'(\n\x0c\n\x04\x04x\
    \x02\x04\x12\x04\xec\x05\x08)\n\r\n\x05\x04x\x02\x04\x04\x12\x04\xec\x05\
    \x08\x10\n\r\n\x05\x04x\x02\x04\x05\x12\x04\xec\x05\x11\x17\n\r\n\x05\
    \x04x\x02\x04\x01\x12\x04\xec\x05\x18$\n\r\n\x05\x04x\x02\x04\x03\x12\
    \x04\xec\x05'(\n\x0c\n\x04\x04x\x02\x05\x12\x04\xed\x05\x08,\n\r\n\x05\
    \x04x\x02\x05\x04\x12\x04\xed\x05\x08\x10\n\r\n\x05\x04x\x02\x05\x05\x12\
    \x04\xed\x05\x11\x17\n\r\n\x05\x04x\x02\x05\x01\x12\x04\xed\x05\x18'\n\r\
    \n\x05\x04x\x02\x05\x03\x12\x04\xed\x05*+\n\x0c\n\x04\x04x\x02\x06\x12\
    \x04\xee\x05\x08#\n\r\n\x05\x04x\x02\x06\x04\x12\x04\xee\x05\x08\x10\n\r\
    \n\x05\x04x\x02\x06\x05\x12\x04\xee\x05\x11\x15\n\r\n\x05\x04x\x02\x06\
    \x01\x12\x04\xee\x05\x16\x1e\n\r\n\x05\x04x\x02\x06\x03\x12\x04\xee\x05!\
    \"\n\x0c\n\x04\x04x\x02\x07\x12\x04\xef\x05\x08/\n\r\n\x05\x04x\x02\x07\
    \x04\x12\x04\xef\x05\x08\x10\n\r\n\x05\x04x\x02\x07\x06\x12\x04\xef\x05\
    \x11\x1d\n\r\n\x05\x04x\x02\x07\x01\x12\x04\xef\x05\x1e*\n\r\n\x05\x04x\
    \x02\x07\x03\x12\x04\xef\x05-.\n\x0c\n\x04\x04x\x02\x08\x12\x04\xf0\x05\
    \x08%\n\r\n\x05\x04x\x02\x08\x04\x12\x04\xf0\x05\x08\x10\n\r\n\x05\x04x\
    \x02\x08\x05\x12\x04\xf0\x05\x11\x15\n\r\n\x05\x04x\x02\x08\x01\x12\x04\
    \xf0\x05\x16\x1f\n\r\n\x05\x04x\x02\x08\x03\x12\x04\xf0\x05\"$\n\x0c\n\
    \x04\x04x\x02\t\x12\x04\xf1\x05\x08F\n\r\n\x05\x04x\x02\t\x04\x12\x04\
    \xf1\x05\x08\x10\n\r\n\x05\x04x\x02\t\x06\x12\x04\xf1\x05\x11.\n\r\n\x05\
    \x04x\x02\t\x01\x12\x04\xf1\x05/@\n\r\n\x05\x04x\x02\t\x03\x12\x04\xf1\
    \x05CE\n\x0c\n\x02\x04y\x12\x06\xf4\x05\0\xf8\x05\x01\n\x0b\n\x03\x04y\
    \x01\x12\x04\xf4\x05\x08\x18\n\x0c\n\x04\x04y\x02\0\x12\x04\xf5\x05\x08+\
    \n\r\n\x05\x04y\x02\0\x04\x12\x04\xf5\x05\x08\x10\n\r\n\x05\x04y\x02\0\
    \x05\x12\x04\xf5\x05\x11\x17\n\r\n\x05\x04y\x02\0\x01\x12\x04\xf5\x05\
    \x18&\n\r\n\x05\x04y\x02\0\x03\x12\x04\xf5\x05)*\n\x0c\n\x04\x04y\x02\
    \x01\x12\x04\xf6\x05\x08!\n\r\n\x05\x04y\x02\x01\x04\x12\x04\xf6\x05\x08\
    \x10\n\r\n\x05\x04y\x02\x01\x05\x12\x04\xf6\x05\x11\x17\n\r\n\x05\x04y\
    \x02\x01\x01\x12\x04\xf6\x05\x18\x1c\n\r\n\x05\x04y\x02\x01\x03\x12\x04\
    \xf6\x05\x1f\x20\n\x0c\n\x04\x04y\x02\x02\x12\x04\xf7\x05\x08,\n\r\n\x05\
    \x04y\x02\x02\x04\x12\x04\xf7\x05\x08\x10\n\r\n\x05\x04y\x02\x02\x06\x12\
    \x04\xf7\x05\x11\x1d\n\r\n\x05\x04y\x02\x02\x01\x12\x04\xf7\x05\x1e'\n\r\
    \n\x05\x04y\x02\x02\x03\x12\x04\xf7\x05*+\n\x0c\n\x02\x04z\x12\x06\xfa\
    \x05\0\xfe\x05\x01\n\x0b\n\x03\x04z\x01\x12\x04\xfa\x05\x08\x1d\n\x0c\n\
    \x04\x04z\x02\0\x12\x04\xfb\x05\x08+\n\r\n\x05\x04z\x02\0\x04\x12\x04\
    \xfb\x05\x08\x10\n\r\n\x05\x04z\x02\0\x05\x12\x04\xfb\x05\x11\x17\n\r\n\
    \x05\x04z\x02\0\x01\x12\x04\xfb\x05\x18&\n\r\n\x05\x04z\x02\0\x03\x12\
    \x04\xfb\x05)*\n\x0c\n\x04\x04z\x02\x01\x12\x04\xfc\x05\x08,\n\r\n\x05\
    \x04z\x02\x01\x04\x12\x04\xfc\x05\x08\x10\n\r\n\x05\x04z\x02\x01\x05\x12\
    \x04\xfc\x05\x11\x17\n\r\n\x05\x04z\x02\x01\x01\x12\x04\xfc\x05\x18'\n\r\
    \n\x05\x04z\x02\x01\x03\x12\x04\xfc\x05*+\n\x0c\n\x04\x04z\x02\x02\x12\
    \x04\xfd\x05\x08,\n\r\n\x05\x04z\x02\x02\x04\x12\x04\xfd\x05\x08\x10\n\r\
    \n\x05\x04z\x02\x02\x06\x12\x04\xfd\x05\x11\x1d\n\r\n\x05\x04z\x02\x02\
    \x01\x12\x04\xfd\x05\x1e'\n\r\n\x05\x04z\x02\x02\x03\x12\x04\xfd\x05*+\n\
    \x0c\n\x02\x04{\x12\x06\x80\x06\0\x83\x06\x01\n\x0b\n\x03\x04{\x01\x12\
    \x04\x80\x06\x08\x1d\n\x0c\n\x04\x04{\x02\0\x12\x04\x81\x06\x08+\n\r\n\
    \x05\x04{\x02\0\x04\x12\x04\x81\x06\x08\x10\n\r\n\x05\x04{\x02\0\x05\x12\
    \x04\x81\x06\x11\x17\n\r\n\x05\x04{\x02\0\x01\x12\x04\x81\x06\x18&\n\r\n\
    \x05\x04{\x02\0\x03\x12\x04\x81\x06)*\n\x0c\n\x04\x04{\x02\x01\x12\x04\
    \x82\x06\x08,\n\r\n\x05\x04{\x02\x01\x04\x12\x04\x82\x06\x08\x10\n\r\n\
    \x05\x04{\x02\x01\x05\x12\x04\x82\x06\x11\x17\n\r\n\x05\x04{\x02\x01\x01\
    \x12\x04\x82\x06\x18'\n\r\n\x05\x04{\x02\x01\x03\x12\x04\x82\x06*+\n\x0c\
    \n\x02\x04|\x12\x06\x85\x06\0\x88\x06\x01\n\x0b\n\x03\x04|\x01\x12\x04\
    \x85\x06\x08\x1c\n\x0c\n\x04\x04|\x02\0\x12\x04\x86\x06\x08+\n\r\n\x05\
    \x04|\x02\0\x04\x12\x04\x86\x06\x08\x10\n\r\n\x05\x04|\x02\0\x05\x12\x04\
    \x86\x06\x11\x17\n\r\n\x05\x04|\x02\0\x01\x12\x04\x86\x06\x18&\n\r\n\x05\
    \x04|\x02\0\x03\x12\x04\x86\x06)*\n\x0c\n\x04\x04|\x02\x01\x12\x04\x87\
    \x06\x08&\n\r\n\x05\x04|\x02\x01\x04\x12\x04\x87\x06\x08\x10\n\r\n\x05\
    \x04|\x02\x01\x05\x12\x04\x87\x06\x11\x17\n\r\n\x05\x04|\x02\x01\x01\x12\
    \x04\x87\x06\x18!\n\r\n\x05\x04|\x02\x01\x03\x12\x04\x87\x06$%\n\x0c\n\
    \x02\x04}\x12\x06\x8a\x06\0\x8e\x06\x01\n\x0b\n\x03\x04}\x01\x12\x04\x8a\
    \x06\x08\x1c\n\x0c\n\x04\x04}\x02\0\x12\x04\x8b\x06\x08+\n\r\n\x05\x04}\
    \x02\0\x04\x12\x04\x8b\x06\x08\x10\n\r\n\x05\x04}\x02\0\x05\x12\x04\x8b\
    \x06\x11\x17\n\r\n\x05\x04}\x02\0\x01\x12\x04\x8b\x06\x18&\n\r\n\x05\x04\
    }\x02\0\x03\x12\x04\x8b\x06)*\n\x0c\n\x04\x04}\x02\x01\x12\x04\x8c\x06\
    \x08.\n\r\n\x05\x04}\x02\x01\x04\x12\x04\x8c\x06\x08\x10\n\r\n\x05\x04}\
    \x02\x01\x05\x12\x04\x8c\x06\x11\x17\n\r\n\x05\x04}\x02\x01\x01\x12\x04\
    \x8c\x06\x18)\n\r\n\x05\x04}\x02\x01\x03\x12\x04\x8c\x06,-\n\x0c\n\x04\
    \x04}\x02\x02\x12\x04\x8d\x06\x08%\n\r\n\x05\x04}\x02\x02\x04\x12\x04\
    \x8d\x06\x08\x10\n\r\n\x05\x04}\x02\x02\x05\x12\x04\x8d\x06\x11\x17\n\r\
    \n\x05\x04}\x02\x02\x01\x12\x04\x8d\x06\x18\x20\n\r\n\x05\x04}\x02\x02\
    \x03\x12\x04\x8d\x06#$\n\x0c\n\x02\x04~\x12\x06\x90\x06\0\x94\x06\x01\n\
    \x0b\n\x03\x04~\x01\x12\x04\x90\x06\x08\x18\n\x0c\n\x04\x04~\x02\0\x12\
    \x04\x91\x06\x08)\n\r\n\x05\x04~\x02\0\x04\x12\x04\x91\x06\x08\x10\n\r\n\
    \x05\x04~\x02\0\x05\x12\x04\x91\x06\x11\x17\n\r\n\x05\x04~\x02\0\x01\x12\
    \x04\x91\x06\x18$\n\r\n\x05\x04~\x02\0\x03\x12\x04\x91\x06'(\n\x0c\n\x04\
    \x04~\x02\x01\x12\x04\x92\x06\x08%\n\r\n\x05\x04~\x02\x01\x04\x12\x04\
    \x92\x06\x08\x10\n\r\n\x05\x04~\x02\x01\x05\x12\x04\x92\x06\x11\x17\n\r\
    \n\x05\x04~\x02\x01\x01\x12\x04\x92\x06\x18\x20\n\r\n\x05\x04~\x02\x01\
    \x03\x12\x04\x92\x06#$\n\x0c\n\x04\x04~\x02\x02\x12\x04\x93\x06\x08&\n\r\
    \n\x05\x04~\x02\x02\x04\x12\x04\x93\x06\x08\x10\n\r\n\x05\x04~\x02\x02\
    \x05\x12\x04\x93\x06\x11\x17\n\r\n\x05\x04~\x02\x02\x01\x12\x04\x93\x06\
    \x18!\n\r\n\x05\x04~\x02\x02\x03\x12\x04\x93\x06$%\n\x0c\n\x02\x04\x7f\
    \x12\x06\x96\x06\0\x9b\x06\x01\n\x0b\n\x03\x04\x7f\x01\x12\x04\x96\x06\
    \x08\x1a\n\x0c\n\x04\x04\x7f\x02\0\x12\x04\x97\x06\x08\"\n\r\n\x05\x04\
    \x7f\x02\0\x04\x12\x04\x97\x06\x08\x10\n\r\n\x05\x04\x7f\x02\0\x05\x12\
    \x04\x97\x06\x11\x17\n\r\n\x05\x04\x7f\x02\0\x01\x12\x04\x97\x06\x18\x1d\
    \n\r\n\x05\x04\x7f\x02\0\x03\x12\x04\x97\x06\x20!\n\x0c\n\x04\x04\x7f\
    \x02\x01\x12\x04\x98\x06\x08)\n\r\n\x05\x04\x7f\x02\x01\x04\x12\x04\x98\
    \x06\x08\x10\n\r\n\x05\x04\x7f\x02\x01\x05\x12\x04\x98\x06\x11\x17\n\r\n\
    \x05\x04\x7f\x02\x01\x01\x12\x04\x98\x06\x18$\n\r\n\x05\x04\x7f\x02\x01\
    \x03\x12\x04\x98\x06'(\n\x0c\n\x04\x04\x7f\x02\x02\x12\x04\x99\x06\x08%\
    \n\r\n\x05\x04\x7f\x02\x02\x04\x12\x04\x99\x06\x08\x10\n\r\n\x05\x04\x7f\
    \x02\x02\x05\x12\x04\x99\x06\x11\x17\n\r\n\x05\x04\x7f\x02\x02\x01\x12\
    \x04\x99\x06\x18\x20\n\r\n\x05\x04\x7f\x02\x02\x03\x12\x04\x99\x06#$\n\
    \x0c\n\x04\x04\x7f\x02\x03\x12\x04\x9a\x06\x08&\n\r\n\x05\x04\x7f\x02\
    \x03\x04\x12\x04\x9a\x06\x08\x10\n\r\n\x05\x04\x7f\x02\x03\x05\x12\x04\
    \x9a\x06\x11\x17\n\r\n\x05\x04\x7f\x02\x03\x01\x12\x04\x9a\x06\x18!\n\r\
    \n\x05\x04\x7f\x02\x03\x03\x12\x04\x9a\x06$%\n\r\n\x03\x04\x80\x01\x12\
    \x06\x9d\x06\0\xa2\x06\x01\n\x0c\n\x04\x04\x80\x01\x01\x12\x04\x9d\x06\
    \x08\x17\n\r\n\x05\x04\x80\x01\x02\0\x12\x04\x9e\x06\x08'\n\x0e\n\x06\
    \x04\x80\x01\x02\0\x04\x12\x04\x9e\x06\x08\x10\n\x0e\n\x06\x04\x80\x01\
    \x02\0\x05\x12\x04\x9e\x06\x11\x17\n\x0e\n\x06\x04\x80\x01\x02\0\x01\x12\
    \x04\x9e\x06\x18\"\n\x0e\n\x06\x04\x80\x01\x02\0\x03\x12\x04\x9e\x06%&\n\
    \r\n\x05\x04\x80\x01\x02\x01\x12\x04\x9f\x06\x08&\n\x0e\n\x06\x04\x80\
    \x01\x02\x01\x04\x12\x04\x9f\x06\x08\x10\n\x0e\n\x06\x04\x80\x01\x02\x01\
    \x05\x12\x04\x9f\x06\x11\x17\n\x0e\n\x06\x04\x80\x01\x02\x01\x01\x12\x04\
    \x9f\x06\x18!\n\x0e\n\x06\x04\x80\x01\x02\x01\x03\x12\x04\x9f\x06$%\n\r\
    \n\x05\x04\x80\x01\x02\x02\x12\x04\xa0\x06\x08.\n\x0e\n\x06\x04\x80\x01\
    \x02\x02\x04\x12\x04\xa0\x06\x08\x10\n\x0e\n\x06\x04\x80\x01\x02\x02\x06\
    \x12\x04\xa0\x06\x11$\n\x0e\n\x06\x04\x80\x01\x02\x02\x01\x12\x04\xa0\
    \x06%)\n\x0e\n\x06\x04\x80\x01\x02\x02\x03\x12\x04\xa0\x06,-\n\r\n\x05\
    \x04\x80\x01\x02\x03\x12\x04\xa1\x06\x08-\n\x0e\n\x06\x04\x80\x01\x02\
    \x03\x04\x12\x04\xa1\x06\x08\x10\n\x0e\n\x06\x04\x80\x01\x02\x03\x06\x12\
    \x04\xa1\x06\x11\"\n\x0e\n\x06\x04\x80\x01\x02\x03\x01\x12\x04\xa1\x06#(\
    \n\x0e\n\x06\x04\x80\x01\x02\x03\x03\x12\x04\xa1\x06+,\n\r\n\x03\x04\x81\
    \x01\x12\x06\xa4\x06\0\xa7\x06\x01\n\x0c\n\x04\x04\x81\x01\x01\x12\x04\
    \xa4\x06\x08$\n\r\n\x05\x04\x81\x01\x02\0\x12\x04\xa5\x06\x08+\n\x0e\n\
    \x06\x04\x81\x01\x02\0\x04\x12\x04\xa5\x06\x08\x10\n\x0e\n\x06\x04\x81\
    \x01\x02\0\x05\x12\x04\xa5\x06\x11\x17\n\x0e\n\x06\x04\x81\x01\x02\0\x01\
    \x12\x04\xa5\x06\x18&\n\x0e\n\x06\x04\x81\x01\x02\0\x03\x12\x04\xa5\x06)\
    *\n\r\n\x05\x04\x81\x01\x02\x01\x12\x04\xa6\x06\x08'\n\x0e\n\x06\x04\x81\
    \x01\x02\x01\x04\x12\x04\xa6\x06\x08\x10\n\x0e\n\x06\x04\x81\x01\x02\x01\
    \x05\x12\x04\xa6\x06\x11\x17\n\x0e\n\x06\x04\x81\x01\x02\x01\x01\x12\x04\
    \xa6\x06\x18\"\n\x0e\n\x06\x04\x81\x01\x02\x01\x03\x12\x04\xa6\x06%&\n\r\
    \n\x03\x04\x82\x01\x12\x06\xa9\x06\0\xad\x06\x01\n\x0c\n\x04\x04\x82\x01\
    \x01\x12\x04\xa9\x06\x08&\n\r\n\x05\x04\x82\x01\x02\0\x12\x04\xaa\x06\
    \x08+\n\x0e\n\x06\x04\x82\x01\x02\0\x04\x12\x04\xaa\x06\x08\x10\n\x0e\n\
    \x06\x04\x82\x01\x02\0\x05\x12\x04\xaa\x06\x11\x17\n\x0e\n\x06\x04\x82\
    \x01\x02\0\x01\x12\x04\xaa\x06\x18&\n\x0e\n\x06\x04\x82\x01\x02\0\x03\
    \x12\x04\xaa\x06)*\n\r\n\x05\x04\x82\x01\x02\x01\x12\x04\xab\x06\x08'\n\
    \x0e\n\x06\x04\x82\x01\x02\x01\x04\x12\x04\xab\x06\x08\x10\n\x0e\n\x06\
    \x04\x82\x01\x02\x01\x05\x12\x04\xab\x06\x11\x17\n\x0e\n\x06\x04\x82\x01\
    \x02\x01\x01\x12\x04\xab\x06\x18\"\n\x0e\n\x06\x04\x82\x01\x02\x01\x03\
    \x12\x04\xab\x06%&\n\r\n\x05\x04\x82\x01\x02\x02\x12\x04\xac\x06\x08+\n\
    \x0e\n\x06\x04\x82\x01\x02\x02\x04\x12\x04\xac\x06\x08\x10\n\x0e\n\x06\
    \x04\x82\x01\x02\x02\x05\x12\x04\xac\x06\x11\x17\n\x0e\n\x06\x04\x82\x01\
    \x02\x02\x01\x12\x04\xac\x06\x18&\n\x0e\n\x06\x04\x82\x01\x02\x02\x03\
    \x12\x04\xac\x06)*\n\r\n\x03\x04\x83\x01\x12\x06\xaf\x06\0\xba\x06\x01\n\
    \x0c\n\x04\x04\x83\x01\x01\x12\x04\xaf\x06\x08#\n\x0f\n\x05\x04\x83\x01\
    \x03\0\x12\x06\xb0\x06\x08\xb6\x06\t\n\x0e\n\x06\x04\x83\x01\x03\0\x01\
    \x12\x04\xb0\x06\x10\x1e\n\x0f\n\x07\x04\x83\x01\x03\0\x02\0\x12\x04\xb1\
    \x06\x10%\n\x10\n\x08\x04\x83\x01\x03\0\x02\0\x04\x12\x04\xb1\x06\x10\
    \x18\n\x10\n\x08\x04\x83\x01\x03\0\x02\0\x05\x12\x04\xb1\x06\x19\x1e\n\
    \x10\n\x08\x04\x83\x01\x03\0\x02\0\x01\x12\x04\xb1\x06\x1f\x20\n\x10\n\
    \x08\x04\x83\x01\x03\0\x02\0\x03\x12\x04\xb1\x06#$\n\x0f\n\x07\x04\x83\
    \x01\x03\0\x02\x01\x12\x04\xb2\x06\x10%\n\x10\n\x08\x04\x83\x01\x03\0\
    \x02\x01\x04\x12\x04\xb2\x06\x10\x18\n\x10\n\x08\x04\x83\x01\x03\0\x02\
    \x01\x05\x12\x04\xb2\x06\x19\x1e\n\x10\n\x08\x04\x83\x01\x03\0\x02\x01\
    \x01\x12\x04\xb2\x06\x1f\x20\n\x10\n\x08\x04\x83\x01\x03\0\x02\x01\x03\
    \x12\x04\xb2\x06#$\n\x0f\n\x07\x04\x83\x01\x03\0\x02\x02\x12\x04\xb3\x06\
    \x10)\n\x10\n\x08\x04\x83\x01\x03\0\x02\x02\x04\x12\x04\xb3\x06\x10\x18\
    \n\x10\n\x08\x04\x83\x01\x03\0\x02\x02\x05\x12\x04\xb3\x06\x19\x1e\n\x10\
    \n\x08\x04\x83\x01\x03\0\x02\x02\x01\x12\x04\xb3\x06\x1f$\n\x10\n\x08\
    \x04\x83\x01\x03\0\x02\x02\x03\x12\x04\xb3\x06'(\n\x0f\n\x07\x04\x83\x01\
    \x03\0\x02\x03\x12\x04\xb4\x06\x10*\n\x10\n\x08\x04\x83\x01\x03\0\x02\
    \x03\x04\x12\x04\xb4\x06\x10\x18\n\x10\n\x08\x04\x83\x01\x03\0\x02\x03\
    \x05\x12\x04\xb4\x06\x19\x1e\n\x10\n\x08\x04\x83\x01\x03\0\x02\x03\x01\
    \x12\x04\xb4\x06\x1f%\n\x10\n\x08\x04\x83\x01\x03\0\x02\x03\x03\x12\x04\
    \xb4\x06()\n\x0f\n\x07\x04\x83\x01\x03\0\x02\x04\x12\x04\xb5\x06\x10,\n\
    \x10\n\x08\x04\x83\x01\x03\0\x02\x04\x04\x12\x04\xb5\x06\x10\x18\n\x10\n\
    \x08\x04\x83\x01\x03\0\x02\x04\x05\x12\x04\xb5\x06\x19\x1d\n\x10\n\x08\
    \x04\x83\x01\x03\0\x02\x04\x01\x12\x04\xb5\x06\x1e'\n\x10\n\x08\x04\x83\
    \x01\x03\0\x02\x04\x03\x12\x04\xb5\x06*+\n\r\n\x05\x04\x83\x01\x02\0\x12\
    \x04\xb8\x06\x08+\n\x0e\n\x06\x04\x83\x01\x02\0\x04\x12\x04\xb8\x06\x08\
    \x10\n\x0e\n\x06\x04\x83\x01\x02\0\x05\x12\x04\xb8\x06\x11\x17\n\x0e\n\
    \x06\x04\x83\x01\x02\0\x01\x12\x04\xb8\x06\x18&\n\x0e\n\x06\x04\x83\x01\
    \x02\0\x03\x12\x04\xb8\x06)*\n\r\n\x05\x04\x83\x01\x02\x01\x12\x04\xb9\
    \x06\x08G\n\x0e\n\x06\x04\x83\x01\x02\x01\x04\x12\x04\xb9\x06\x08\x10\n\
    \x0e\n\x06\x04\x83\x01\x02\x01\x06\x12\x04\xb9\x06\x11<\n\x0e\n\x06\x04\
    \x83\x01\x02\x01\x01\x12\x04\xb9\x06=B\n\x0e\n\x06\x04\x83\x01\x02\x01\
    \x03\x12\x04\xb9\x06EF\n\r\n\x03\x04\x84\x01\x12\x06\xbc\x06\0\xc0\x06\
    \x01\n\x0c\n\x04\x04\x84\x01\x01\x12\x04\xbc\x06\x08\x1d\n\r\n\x05\x04\
    \x84\x01\x02\0\x12\x04\xbd\x06\x08+\n\x0e\n\x06\x04\x84\x01\x02\0\x04\
    \x12\x04\xbd\x06\x08\x10\n\x0e\n\x06\x04\x84\x01\x02\0\x05\x12\x04\xbd\
    \x06\x11\x17\n\x0e\n\x06\x04\x84\x01\x02\0\x01\x12\x04\xbd\x06\x18&\n\
    \x0e\n\x06\x04\x84\x01\x02\0\x03\x12\x04\xbd\x06)*\n\r\n\x05\x04\x84\x01\
    \x02\x01\x12\x04\xbe\x06\x08!\n\x0e\n\x06\x04\x84\x01\x02\x01\x04\x12\
    \x04\xbe\x06\x08\x10\n\x0e\n\x06\x04\x84\x01\x02\x01\x05\x12\x04\xbe\x06\
    \x11\x16\n\x0e\n\x06\x04\x84\x01\x02\x01\x01\x12\x04\xbe\x06\x17\x1c\n\
    \x0e\n\x06\x04\x84\x01\x02\x01\x03\x12\x04\xbe\x06\x1f\x20\n\r\n\x05\x04\
    \x84\x01\x02\x02\x12\x04\xbf\x06\x08\"\n\x0e\n\x06\x04\x84\x01\x02\x02\
    \x04\x12\x04\xbf\x06\x08\x10\n\x0e\n\x06\x04\x84\x01\x02\x02\x05\x12\x04\
    \xbf\x06\x11\x16\n\x0e\n\x06\x04\x84\x01\x02\x02\x01\x12\x04\xbf\x06\x17\
    \x1d\n\x0e\n\x06\x04\x84\x01\x02\x02\x03\x12\x04\xbf\x06\x20!\n\r\n\x03\
    \x04\x85\x01\x12\x06\xc2\x06\0\xca\x06\x01\n\x0c\n\x04\x04\x85\x01\x01\
    \x12\x04\xc2\x06\x08\x1d\n\r\n\x05\x04\x85\x01\x02\0\x12\x04\xc3\x06\x08\
    +\n\x0e\n\x06\x04\x85\x01\x02\0\x04\x12\x04\xc3\x06\x08\x10\n\x0e\n\x06\
    \x04\x85\x01\x02\0\x05\x12\x04\xc3\x06\x11\x17\n\x0e\n\x06\x04\x85\x01\
    \x02\0\x01\x12\x04\xc3\x06\x18&\n\x0e\n\x06\x04\x85\x01\x02\0\x03\x12\
    \x04\xc3\x06)*\n\r\n\x05\x04\x85\x01\x02\x01\x12\x04\xc4\x06\x08\x1d\n\
    \x0e\n\x06\x04\x85\x01\x02\x01\x04\x12\x04\xc4\x06\x08\x10\n\x0e\n\x06\
    \x04\x85\x01\x02\x01\x05\x12\x04\xc4\x06\x11\x16\n\x0e\n\x06\x04\x85\x01\
    \x02\x01\x01\x12\x04\xc4\x06\x17\x18\n\x0e\n\x06\x04\x85\x01\x02\x01\x03\
    \x12\x04\xc4\x06\x1b\x1c\n\r\n\x05\x04\x85\x01\x02\x02\x12\x04\xc5\x06\
    \x08\x1d\n\x0e\n\x06\x04\x85\x01\x02\x02\x04\x12\x04\xc5\x06\x08\x10\n\
    \x0e\n\x06\x04\x85\x01\x02\x02\x05\x12\x04\xc5\x06\x11\x16\n\x0e\n\x06\
    \x04\x85\x01\x02\x02\x01\x12\x04\xc5\x06\x17\x18\n\x0e\n\x06\x04\x85\x01\
    \x02\x02\x03\x12\x04\xc5\x06\x1b\x1c\n\r\n\x05\x04\x85\x01\x02\x03\x12\
    \x04\xc6\x06\x08!\n\x0e\n\x06\x04\x85\x01\x02\x03\x04\x12\x04\xc6\x06\
    \x08\x10\n\x0e\n\x06\x04\x85\x01\x02\x03\x05\x12\x04\xc6\x06\x11\x16\n\
    \x0e\n\x06\x04\x85\x01\x02\x03\x01\x12\x04\xc6\x06\x17\x1c\n\x0e\n\x06\
    \x04\x85\x01\x02\x03\x03\x12\x04\xc6\x06\x1f\x20\n\r\n\x05\x04\x85\x01\
    \x02\x04\x12\x04\xc7\x06\x08\"\n\x0e\n\x06\x04\x85\x01\x02\x04\x04\x12\
    \x04\xc7\x06\x08\x10\n\x0e\n\x06\x04\x85\x01\x02\x04\x05\x12\x04\xc7\x06\
    \x11\x16\n\x0e\n\x06\x04\x85\x01\x02\x04\x01\x12\x04\xc7\x06\x17\x1d\n\
    \x0e\n\x06\x04\x85\x01\x02\x04\x03\x12\x04\xc7\x06\x20!\n\r\n\x05\x04\
    \x85\x01\x02\x05\x12\x04\xc8\x06\x08%\n\x0e\n\x06\x04\x85\x01\x02\x05\
    \x04\x12\x04\xc8\x06\x08\x10\n\x0e\n\x06\x04\x85\x01\x02\x05\x05\x12\x04\
    \xc8\x06\x11\x16\n\x0e\n\x06\x04\x85\x01\x02\x05\x01\x12\x04\xc8\x06\x17\
    \x20\n\x0e\n\x06\x04\x85\x01\x02\x05\x03\x12\x04\xc8\x06#$\n\r\n\x05\x04\
    \x85\x01\x02\x06\x12\x04\xc9\x06\x08&\n\x0e\n\x06\x04\x85\x01\x02\x06\
    \x04\x12\x04\xc9\x06\x08\x10\n\x0e\n\x06\x04\x85\x01\x02\x06\x05\x12\x04\
    \xc9\x06\x11\x16\n\x0e\n\x06\x04\x85\x01\x02\x06\x01\x12\x04\xc9\x06\x17\
    !\n\x0e\n\x06\x04\x85\x01\x02\x06\x03\x12\x04\xc9\x06$%\n\r\n\x03\x04\
    \x86\x01\x12\x06\xcc\x06\0\xce\x06\x01\n\x0c\n\x04\x04\x86\x01\x01\x12\
    \x04\xcc\x06\x08\x16\n\r\n\x05\x04\x86\x01\x02\0\x12\x04\xcd\x06\x08+\n\
    \x0e\n\x06\x04\x86\x01\x02\0\x04\x12\x04\xcd\x06\x08\x10\n\x0e\n\x06\x04\
    \x86\x01\x02\0\x05\x12\x04\xcd\x06\x11\x17\n\x0e\n\x06\x04\x86\x01\x02\0\
    \x01\x12\x04\xcd\x06\x18&\n\x0e\n\x06\x04\x86\x01\x02\0\x03\x12\x04\xcd\
    \x06)*\n\r\n\x03\x04\x87\x01\x12\x06\xd0\x06\0\xd2\x06\x01\n\x0c\n\x04\
    \x04\x87\x01\x01\x12\x04\xd0\x06\x08\x16\n\r\n\x05\x04\x87\x01\x02\0\x12\
    \x04\xd1\x06\x08+\n\x0e\n\x06\x04\x87\x01\x02\0\x04\x12\x04\xd1\x06\x08\
    \x10\n\x0e\n\x06\x04\x87\x01\x02\0\x05\x12\x04\xd1\x06\x11\x17\n\x0e\n\
    \x06\x04\x87\x01\x02\0\x01\x12\x04\xd1\x06\x18&\n\x0e\n\x06\x04\x87\x01\
    \x02\0\x03\x12\x04\xd1\x06)*\n\r\n\x03\x04\x88\x01\x12\x06\xd4\x06\0\xd6\
    \x06\x01\n\x0c\n\x04\x04\x88\x01\x01\x12\x04\xd4\x06\x08\x1e\n\r\n\x05\
    \x04\x88\x01\x02\0\x12\x04\xd5\x06\x08+\n\x0e\n\x06\x04\x88\x01\x02\0\
    \x04\x12\x04\xd5\x06\x08\x10\n\x0e\n\x06\x04\x88\x01\x02\0\x05\x12\x04\
    \xd5\x06\x11\x17\n\x0e\n\x06\x04\x88\x01\x02\0\x01\x12\x04\xd5\x06\x18&\
    \n\x0e\n\x06\x04\x88\x01\x02\0\x03\x12\x04\xd5\x06)*\n\r\n\x03\x04\x89\
    \x01\x12\x06\xd8\x06\0\xda\x06\x01\n\x0c\n\x04\x04\x89\x01\x01\x12\x04\
    \xd8\x06\x08\x1f\n\r\n\x05\x04\x89\x01\x02\0\x12\x04\xd9\x06\x08+\n\x0e\
    \n\x06\x04\x89\x01\x02\0\x04\x12\x04\xd9\x06\x08\x10\n\x0e\n\x06\x04\x89\
    \x01\x02\0\x05\x12\x04\xd9\x06\x11\x17\n\x0e\n\x06\x04\x89\x01\x02\0\x01\
    \x12\x04\xd9\x06\x18&\n\x0e\n\x06\x04\x89\x01\x02\0\x03\x12\x04\xd9\x06)\
    *\n\r\n\x03\x04\x8a\x01\x12\x06\xdc\x06\0\xde\x06\x01\n\x0c\n\x04\x04\
    \x8a\x01\x01\x12\x04\xdc\x06\x08!\n\r\n\x05\x04\x8a\x01\x02\0\x12\x04\
    \xdd\x06\x08+\n\x0e\n\x06\x04\x8a\x01\x02\0\x04\x12\x04\xdd\x06\x08\x10\
    \n\x0e\n\x06\x04\x8a\x01\x02\0\x05\x12\x04\xdd\x06\x11\x17\n\x0e\n\x06\
    \x04\x8a\x01\x02\0\x01\x12\x04\xdd\x06\x18&\n\x0e\n\x06\x04\x8a\x01\x02\
    \0\x03\x12\x04\xdd\x06)*\n\r\n\x03\x04\x8b\x01\x12\x06\xe0\x06\0\xe2\x06\
    \x01\n\x0c\n\x04\x04\x8b\x01\x01\x12\x04\xe0\x06\x08\x1a\n\r\n\x05\x04\
    \x8b\x01\x02\0\x12\x04\xe1\x06\x08+\n\x0e\n\x06\x04\x8b\x01\x02\0\x04\
    \x12\x04\xe1\x06\x08\x10\n\x0e\n\x06\x04\x8b\x01\x02\0\x05\x12\x04\xe1\
    \x06\x11\x17\n\x0e\n\x06\x04\x8b\x01\x02\0\x01\x12\x04\xe1\x06\x18&\n\
    \x0e\n\x06\x04\x8b\x01\x02\0\x03\x12\x04\xe1\x06)*\n\r\n\x03\x04\x8c\x01\
    \x12\x06\xe4\x06\0\xec\x06\x01\n\x0c\n\x04\x04\x8c\x01\x01\x12\x04\xe4\
    \x06\x08\"\n\x0f\n\x05\x04\x8c\x01\x03\0\x12\x06\xe5\x06\x08\xe8\x06\t\n\
    \x0e\n\x06\x04\x8c\x01\x03\0\x01\x12\x04\xe5\x06\x10\x1e\n\x0f\n\x07\x04\
    \x8c\x01\x03\0\x02\0\x12\x04\xe6\x06\x10&\n\x10\n\x08\x04\x8c\x01\x03\0\
    \x02\0\x04\x12\x04\xe6\x06\x10\x18\n\x10\n\x08\x04\x8c\x01\x03\0\x02\0\
    \x05\x12\x04\xe6\x06\x19\x1e\n\x10\n\x08\x04\x8c\x01\x03\0\x02\0\x01\x12\
    \x04\xe6\x06\x1f!\n\x10\n\x08\x04\x8c\x01\x03\0\x02\0\x03\x12\x04\xe6\
    \x06$%\n\x0f\n\x07\x04\x8c\x01\x03\0\x02\x01\x12\x04\xe7\x06\x10*\n\x10\
    \n\x08\x04\x8c\x01\x03\0\x02\x01\x04\x12\x04\xe7\x06\x10\x18\n\x10\n\x08\
    \x04\x8c\x01\x03\0\x02\x01\x05\x12\x04\xe7\x06\x19\x1f\n\x10\n\x08\x04\
    \x8c\x01\x03\0\x02\x01\x01\x12\x04\xe7\x06\x20%\n\x10\n\x08\x04\x8c\x01\
    \x03\0\x02\x01\x03\x12\x04\xe7\x06()\n\r\n\x05\x04\x8c\x01\x02\0\x12\x04\
    \xea\x06\x08+\n\x0e\n\x06\x04\x8c\x01\x02\0\x04\x12\x04\xea\x06\x08\x10\
    \n\x0e\n\x06\x04\x8c\x01\x02\0\x05\x12\x04\xea\x06\x11\x17\n\x0e\n\x06\
    \x04\x8c\x01\x02\0\x01\x12\x04\xea\x06\x18&\n\x0e\n\x06\x04\x8c\x01\x02\
    \0\x03\x12\x04\xea\x06)*\n\r\n\x05\x04\x8c\x01\x02\x01\x12\x04\xeb\x06\
    \x08P\n\x0e\n\x06\x04\x8c\x01\x02\x01\x04\x12\x04\xeb\x06\x08\x10\n\x0e\
    \n\x06\x04\x8c\x01\x02\x01\x06\x12\x04\xeb\x06\x11;\n\x0e\n\x06\x04\x8c\
    \x01\x02\x01\x01\x12\x04\xeb\x06<K\n\x0e\n\x06\x04\x8c\x01\x02\x01\x03\
    \x12\x04\xeb\x06NO\n\r\n\x03\x04\x8d\x01\x12\x06\xee\x06\0\xf1\x06\x01\n\
    \x0c\n\x04\x04\x8d\x01\x01\x12\x04\xee\x06\x08$\n\r\n\x05\x04\x8d\x01\
    \x02\0\x12\x04\xef\x06\x08+\n\x0e\n\x06\x04\x8d\x01\x02\0\x04\x12\x04\
    \xef\x06\x08\x10\n\x0e\n\x06\x04\x8d\x01\x02\0\x05\x12\x04\xef\x06\x11\
    \x17\n\x0e\n\x06\x04\x8d\x01\x02\0\x01\x12\x04\xef\x06\x18&\n\x0e\n\x06\
    \x04\x8d\x01\x02\0\x03\x12\x04\xef\x06)*\n\r\n\x05\x04\x8d\x01\x02\x01\
    \x12\x04\xf0\x06\x08&\n\x0e\n\x06\x04\x8d\x01\x02\x01\x04\x12\x04\xf0\
    \x06\x08\x10\n\x0e\n\x06\x04\x8d\x01\x02\x01\x05\x12\x04\xf0\x06\x11\x16\
    \n\x0e\n\x06\x04\x8d\x01\x02\x01\x01\x12\x04\xf0\x06\x17!\n\x0e\n\x06\
    \x04\x8d\x01\x02\x01\x03\x12\x04\xf0\x06$%\n\r\n\x03\x04\x8e\x01\x12\x06\
    \xf3\x06\0\xf6\x06\x01\n\x0c\n\x04\x04\x8e\x01\x01\x12\x04\xf3\x06\x08\
    \x1d\n\r\n\x05\x04\x8e\x01\x02\0\x12\x04\xf4\x06\x08+\n\x0e\n\x06\x04\
    \x8e\x01\x02\0\x04\x12\x04\xf4\x06\x08\x10\n\x0e\n\x06\x04\x8e\x01\x02\0\
    \x05\x12\x04\xf4\x06\x11\x17\n\x0e\n\x06\x04\x8e\x01\x02\0\x01\x12\x04\
    \xf4\x06\x18&\n\x0e\n\x06\x04\x8e\x01\x02\0\x03\x12\x04\xf4\x06)*\n\r\n\
    \x05\x04\x8e\x01\x02\x01\x12\x04\xf5\x06\x08!\n\x0e\n\x06\x04\x8e\x01\
    \x02\x01\x04\x12\x04\xf5\x06\x08\x10\n\x0e\n\x06\x04\x8e\x01\x02\x01\x05\
    \x12\x04\xf5\x06\x11\x17\n\x0e\n\x06\x04\x8e\x01\x02\x01\x01\x12\x04\xf5\
    \x06\x18\x1c\n\x0e\n\x06\x04\x8e\x01\x02\x01\x03\x12\x04\xf5\x06\x1f\x20\
    \n\r\n\x03\x04\x8f\x01\x12\x06\xf8\x06\0\xfb\x06\x01\n\x0c\n\x04\x04\x8f\
    \x01\x01\x12\x04\xf8\x06\x08\x19\n\r\n\x05\x04\x8f\x01\x02\0\x12\x04\xf9\
    \x06\x08+\n\x0e\n\x06\x04\x8f\x01\x02\0\x04\x12\x04\xf9\x06\x08\x10\n\
    \x0e\n\x06\x04\x8f\x01\x02\0\x05\x12\x04\xf9\x06\x11\x17\n\x0e\n\x06\x04\
    \x8f\x01\x02\0\x01\x12\x04\xf9\x06\x18&\n\x0e\n\x06\x04\x8f\x01\x02\0\
    \x03\x12\x04\xf9\x06)*\n\r\n\x05\x04\x8f\x01\x02\x01\x12\x04\xfa\x06\x08\
    !\n\x0e\n\x06\x04\x8f\x01\x02\x01\x04\x12\x04\xfa\x06\x08\x10\n\x0e\n\
    \x06\x04\x8f\x01\x02\x01\x05\x12\x04\xfa\x06\x11\x17\n\x0e\n\x06\x04\x8f\
    \x01\x02\x01\x01\x12\x04\xfa\x06\x18\x1c\n\x0e\n\x06\x04\x8f\x01\x02\x01\
    \x03\x12\x04\xfa\x06\x1f\x20\n\r\n\x03\x04\x90\x01\x12\x06\xfd\x06\0\xff\
    \x06\x01\n\x0c\n\x04\x04\x90\x01\x01\x12\x04\xfd\x06\x08\x20\n\r\n\x05\
    \x04\x90\x01\x02\0\x12\x04\xfe\x06\x08+\n\x0e\n\x06\x04\x90\x01\x02\0\
    \x04\x12\x04\xfe\x06\x08\x10\n\x0e\n\x06\x04\x90\x01\x02\0\x05\x12\x04\
    \xfe\x06\x11\x17\n\x0e\n\x06\x04\x90\x01\x02\0\x01\x12\x04\xfe\x06\x18&\
    \n\x0e\n\x06\x04\x90\x01\x02\0\x03\x12\x04\xfe\x06)*\n\r\n\x03\x04\x91\
    \x01\x12\x06\x81\x07\0\x85\x07\x01\n\x0c\n\x04\x04\x91\x01\x01\x12\x04\
    \x81\x07\x08&\n\r\n\x05\x04\x91\x01\x02\0\x12\x04\x82\x07\x08+\n\x0e\n\
    \x06\x04\x91\x01\x02\0\x04\x12\x04\x82\x07\x08\x10\n\x0e\n\x06\x04\x91\
    \x01\x02\0\x05\x12\x04\x82\x07\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\0\x01\
    \x12\x04\x82\x07\x18&\n\x0e\n\x06\x04\x91\x01\x02\0\x03\x12\x04\x82\x07)\
    *\n\r\n\x05\x04\x91\x01\x02\x01\x12\x04\x83\x07\x08\x1e\n\x0e\n\x06\x04\
    \x91\x01\x02\x01\x04\x12\x04\x83\x07\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\
    \x01\x05\x12\x04\x83\x07\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x01\x01\x12\
    \x04\x83\x07\x18\x19\n\x0e\n\x06\x04\x91\x01\x02\x01\x03\x12\x04\x83\x07\
    \x1c\x1d\n\r\n\x05\x04\x91\x01\x02\x02\x12\x04\x84\x07\x08\x1e\n\x0e\n\
    \x06\x04\x91\x01\x02\x02\x04\x12\x04\x84\x07\x08\x10\n\x0e\n\x06\x04\x91\
    \x01\x02\x02\x05\x12\x04\x84\x07\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x02\
    \x01\x12\x04\x84\x07\x18\x19\n\x0e\n\x06\x04\x91\x01\x02\x02\x03\x12\x04\
    \x84\x07\x1c\x1d\n\r\n\x03\x04\x92\x01\x12\x06\x87\x07\0\x8b\x07\x01\n\
    \x0c\n\x04\x04\x92\x01\x01\x12\x04\x87\x07\x08\x1a\n\r\n\x05\x04\x92\x01\
    \x02\0\x12\x04\x88\x07\x08+\n\x0e\n\x06\x04\x92\x01\x02\0\x04\x12\x04\
    \x88\x07\x08\x10\n\x0e\n\x06\x04\x92\x01\x02\0\x05\x12\x04\x88\x07\x11\
    \x17\n\x0e\n\x06\x04\x92\x01\x02\0\x01\x12\x04\x88\x07\x18&\n\x0e\n\x06\
    \x04\x92\x01\x02\0\x03\x12\x04\x88\x07)*\n\r\n\x05\x04\x92\x01\x02\x01\
    \x12\x04\x89\x07\x08\x1e\n\x0e\n\x06\x04\x92\x01\x02\x01\x04\x12\x04\x89\
    \x07\x08\x10\n\x0e\n\x06\x04\x92\x01\x02\x01\x05\x12\x04\x89\x07\x11\x17\
    \n\x0e\n\x06\x04\x92\x01\x02\x01\x01\x12\x04\x89\x07\x18\x19\n\x0e\n\x06\
    \x04\x92\x01\x02\x01\x03\x12\x04\x89\x07\x1c\x1d\n\r\n\x05\x04\x92\x01\
    \x02\x02\x12\x04\x8a\x07\x08\x1e\n\x0e\n\x06\x04\x92\x01\x02\x02\x04\x12\
    \x04\x8a\x07\x08\x10\n\x0e\n\x06\x04\x92\x01\x02\x02\x05\x12\x04\x8a\x07\
    \x11\x17\n\x0e\n\x06\x04\x92\x01\x02\x02\x01\x12\x04\x8a\x07\x18\x19\n\
    \x0e\n\x06\x04\x92\x01\x02\x02\x03\x12\x04\x8a\x07\x1c\x1d\n\r\n\x03\x04\
    \x93\x01\x12\x06\x8d\x07\0\x90\x07\x01\n\x0c\n\x04\x04\x93\x01\x01\x12\
    \x04\x8d\x07\x08\x15\n\r\n\x05\x04\x93\x01\x02\0\x12\x04\x8e\x07\x08+\n\
    \x0e\n\x06\x04\x93\x01\x02\0\x04\x12\x04\x8e\x07\x08\x10\n\x0e\n\x06\x04\
    \x93\x01\x02\0\x05\x12\x04\x8e\x07\x11\x17\n\x0e\n\x06\x04\x93\x01\x02\0\
    \x01\x12\x04\x8e\x07\x18&\n\x0e\n\x06\x04\x93\x01\x02\0\x03\x12\x04\x8e\
    \x07)*\n\r\n\x05\x04\x93\x01\x02\x01\x12\x04\x8f\x07\x08\"\n\x0e\n\x06\
    \x04\x93\x01\x02\x01\x04\x12\x04\x8f\x07\x08\x10\n\x0e\n\x06\x04\x93\x01\
    \x02\x01\x05\x12\x04\x8f\x07\x11\x15\n\x0e\n\x06\x04\x93\x01\x02\x01\x01\
    \x12\x04\x8f\x07\x16\x1d\n\x0e\n\x06\x04\x93\x01\x02\x01\x03\x12\x04\x8f\
    \x07\x20!\n\r\n\x03\x04\x94\x01\x12\x06\x92\x07\0\x95\x07\x01\n\x0c\n\
    \x04\x04\x94\x01\x01\x12\x04\x92\x07\x08\x19\n\r\n\x05\x04\x94\x01\x02\0\
    \x12\x04\x93\x07\x08+\n\x0e\n\x06\x04\x94\x01\x02\0\x04\x12\x04\x93\x07\
    \x08\x10\n\x0e\n\x06\x04\x94\x01\x02\0\x05\x12\x04\x93\x07\x11\x17\n\x0e\
    \n\x06\x04\x94\x01\x02\0\x01\x12\x04\x93\x07\x18&\n\x0e\n\x06\x04\x94\
    \x01\x02\0\x03\x12\x04\x93\x07)*\n\r\n\x05\x04\x94\x01\x02\x01\x12\x04\
    \x94\x07\x08\x20\n\x0e\n\x06\x04\x94\x01\x02\x01\x04\x12\x04\x94\x07\x08\
    \x10\n\x0e\n\x06\x04\x94\x01\x02\x01\x05\x12\x04\x94\x07\x11\x17\n\x0e\n\
    \x06\x04\x94\x01\x02\x01\x01\x12\x04\x94\x07\x18\x1b\n\x0e\n\x06\x04\x94\
    \x01\x02\x01\x03\x12\x04\x94\x07\x1e\x1f\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(153);
            messages.push(CMsgKeyUp::generated_message_descriptor_data());
            messages.push(CMsgKeyDown::generated_message_descriptor_data());
            messages.push(CMsgKeyChar::generated_message_descriptor_data());
            messages.push(CMsgMouseDown::generated_message_descriptor_data());
            messages.push(CMsgMouseUp::generated_message_descriptor_data());
            messages.push(CMsgMouseDblClick::generated_message_descriptor_data());
            messages.push(CMsgMouseWheel::generated_message_descriptor_data());
            messages.push(CMsgMouseMove::generated_message_descriptor_data());
            messages.push(CMsgMouseLeave::generated_message_descriptor_data());
            messages.push(CMsgBrowserCreate::generated_message_descriptor_data());
            messages.push(CMsgBrowserCreateResponse::generated_message_descriptor_data());
            messages.push(CMsgBrowserRemove::generated_message_descriptor_data());
            messages.push(CMsgSetLocalFileRequestMapping::generated_message_descriptor_data());
            messages.push(CMsgBrowserErrorStrings::generated_message_descriptor_data());
            messages.push(CMsgBrowserSize::generated_message_descriptor_data());
            messages.push(CMsgBrowserSetMinSize::generated_message_descriptor_data());
            messages.push(CMsgBrowserPosition::generated_message_descriptor_data());
            messages.push(CMsgBrowserResized::generated_message_descriptor_data());
            messages.push(CMsgPostURL::generated_message_descriptor_data());
            messages.push(CMsgAddHeader::generated_message_descriptor_data());
            messages.push(CMsgStopLoad::generated_message_descriptor_data());
            messages.push(CMsgReload::generated_message_descriptor_data());
            messages.push(CMsgGoForward::generated_message_descriptor_data());
            messages.push(CMsgGoBack::generated_message_descriptor_data());
            messages.push(CMsgWasHidden::generated_message_descriptor_data());
            messages.push(CMsgClearHistory::generated_message_descriptor_data());
            messages.push(CMsgClearAllBrowsingData::generated_message_descriptor_data());
            messages.push(CMsgCopy::generated_message_descriptor_data());
            messages.push(CMsgPaste::generated_message_descriptor_data());
            messages.push(CMsgExecuteJavaScript::generated_message_descriptor_data());
            messages.push(CMsgSetFocus::generated_message_descriptor_data());
            messages.push(CMsgHorizontalScrollBarSize::generated_message_descriptor_data());
            messages.push(CMsgHorizontalScrollBarSizeResponse::generated_message_descriptor_data());
            messages.push(CMsgVerticalScrollBarSize::generated_message_descriptor_data());
            messages.push(CMsgVerticalScrollBarSizeResponse::generated_message_descriptor_data());
            messages.push(CMsgFind::generated_message_descriptor_data());
            messages.push(CMsgStopFind::generated_message_descriptor_data());
            messages.push(CMsgSetHorizontalScroll::generated_message_descriptor_data());
            messages.push(CMsgSetVerticalScroll::generated_message_descriptor_data());
            messages.push(CMsgSetZoomLevel::generated_message_descriptor_data());
            messages.push(CMsgViewSource::generated_message_descriptor_data());
            messages.push(CMsgBrowserReady::generated_message_descriptor_data());
            messages.push(CMsgURLChanged::generated_message_descriptor_data());
            messages.push(CHTMLHeader::generated_message_descriptor_data());
            messages.push(CHTMLPageSecurityInfo::generated_message_descriptor_data());
            messages.push(CMsgFinishedRequest::generated_message_descriptor_data());
            messages.push(CMsgLoadedRequest::generated_message_descriptor_data());
            messages.push(CMsgPageSecurity::generated_message_descriptor_data());
            messages.push(CMsgStartRequest::generated_message_descriptor_data());
            messages.push(CMsgStartRequestResponse::generated_message_descriptor_data());
            messages.push(CMsgShowPopup::generated_message_descriptor_data());
            messages.push(CMsgHidePopup::generated_message_descriptor_data());
            messages.push(CMsgSizePopup::generated_message_descriptor_data());
            messages.push(CMsgOpenNewTab::generated_message_descriptor_data());
            messages.push(CMsgPopupHTMLWindow::generated_message_descriptor_data());
            messages.push(CMsgPopupHTMLWindowResponse::generated_message_descriptor_data());
            messages.push(CMsgSetHTMLTitle::generated_message_descriptor_data());
            messages.push(CMsgLoadingResource::generated_message_descriptor_data());
            messages.push(CMsgStatusText::generated_message_descriptor_data());
            messages.push(CMsgSetCursor::generated_message_descriptor_data());
            messages.push(CMsgFileLoadDialog::generated_message_descriptor_data());
            messages.push(CMsgFileLoadDialogResponse::generated_message_descriptor_data());
            messages.push(CMsgShowToolTip::generated_message_descriptor_data());
            messages.push(CMsgUpdateToolTip::generated_message_descriptor_data());
            messages.push(CMsgHideToolTip::generated_message_descriptor_data());
            messages.push(CMsgSearchResults::generated_message_descriptor_data());
            messages.push(CMsgClose::generated_message_descriptor_data());
            messages.push(CMsgSetSharedPaintBuffers::generated_message_descriptor_data());
            messages.push(CMsgAckSharedPaintBuffers::generated_message_descriptor_data());
            messages.push(CMsgNeedsPaint::generated_message_descriptor_data());
            messages.push(CMsgComboNeedsPaint::generated_message_descriptor_data());
            messages.push(CMsgNeedsSharedTexturePaint::generated_message_descriptor_data());
            messages.push(CMsgGameOverlayTexturePaint::generated_message_descriptor_data());
            messages.push(CMsgGetZoom::generated_message_descriptor_data());
            messages.push(CMsgGetZoomResponse::generated_message_descriptor_data());
            messages.push(CMsgLinkAtPosition::generated_message_descriptor_data());
            messages.push(CMsgLinkAtPositionResponse::generated_message_descriptor_data());
            messages.push(CMsgZoomToElementAtPosition::generated_message_descriptor_data());
            messages.push(CMsgZoomToElementAtPositionResponse::generated_message_descriptor_data());
            messages.push(CMsgScalePageToValue::generated_message_descriptor_data());
            messages.push(CMsgForcePopupsToDirectHWND::generated_message_descriptor_data());
            messages.push(CMsgScalePageToValueResponse::generated_message_descriptor_data());
            messages.push(CMsgSavePageToJPEG::generated_message_descriptor_data());
            messages.push(CMsgSavePageToJPEGResponse::generated_message_descriptor_data());
            messages.push(CMsgJSAlert::generated_message_descriptor_data());
            messages.push(CMsgJSConfirm::generated_message_descriptor_data());
            messages.push(CMsgJSDialogResponse::generated_message_descriptor_data());
            messages.push(CMsgCanGoBackAndForward::generated_message_descriptor_data());
            messages.push(CMsgOpenSteamURL::generated_message_descriptor_data());
            messages.push(CMsgSetCookie::generated_message_descriptor_data());
            messages.push(CMsgSetTargetFrameRate::generated_message_descriptor_data());
            messages.push(CMsgPauseRepaint::generated_message_descriptor_data());
            messages.push(CMsgFullRepaint::generated_message_descriptor_data());
            messages.push(CMsgRequestFullScreen::generated_message_descriptor_data());
            messages.push(CMsgExitFullScreen::generated_message_descriptor_data());
            messages.push(CMsgToggleFindInPageDialog::generated_message_descriptor_data());
            messages.push(CMsgSetPIDShuttingDown::generated_message_descriptor_data());
            messages.push(CMsgDisableBackgroundThrottling::generated_message_descriptor_data());
            messages.push(CMsgAckPIDShuttingDown::generated_message_descriptor_data());
            messages.push(CMsgGetCookiesForURL::generated_message_descriptor_data());
            messages.push(CCookie::generated_message_descriptor_data());
            messages.push(CMsgGetCookiesForURLResponse::generated_message_descriptor_data());
            messages.push(CMsgNodeHasFocus::generated_message_descriptor_data());
            messages.push(CMsgZoomToFocusedElement::generated_message_descriptor_data());
            messages.push(CMsgCloseFullScreenFlashIfOpen::generated_message_descriptor_data());
            messages.push(CMsgPauseFullScreenFlashMovieIfOpen::generated_message_descriptor_data());
            messages.push(CMsgFocusedNodeText::generated_message_descriptor_data());
            messages.push(CMsgFocusedNodeTextResponse::generated_message_descriptor_data());
            messages.push(CMsgBuildID::generated_message_descriptor_data());
            messages.push(CMsgOpenDevTools::generated_message_descriptor_data());
            messages.push(CMsgCloseDevTools::generated_message_descriptor_data());
            messages.push(CMsgUnlockH264::generated_message_descriptor_data());
            messages.push(CMsgScreenInformationChanged::generated_message_descriptor_data());
            messages.push(CMsgClearAllCookies::generated_message_descriptor_data());
            messages.push(CMsgScreenDPI::generated_message_descriptor_data());
            messages.push(CMsgAuthedSteamDomains::generated_message_descriptor_data());
            messages.push(CMsgSteamAuthNeeded::generated_message_descriptor_data());
            messages.push(CMsgSteamAuthCookiesSet::generated_message_descriptor_data());
            messages.push(CMsgJSRegisterMethod::generated_message_descriptor_data());
            messages.push(CJSMethodArgument::generated_message_descriptor_data());
            messages.push(CMsgJSValue::generated_message_descriptor_data());
            messages.push(CMsgJSMethodCall::generated_message_descriptor_data());
            messages.push(CMsgJSExecuteCallback::generated_message_descriptor_data());
            messages.push(CMsgJSReleaseCallback::generated_message_descriptor_data());
            messages.push(CMsgJSRaiseException::generated_message_descriptor_data());
            messages.push(CMsgLoadLocalization::generated_message_descriptor_data());
            messages.push(CMsgJumpListLink::generated_message_descriptor_data());
            messages.push(CMSgJumpListMRUApp::generated_message_descriptor_data());
            messages.push(CMsgSetJumpList::generated_message_descriptor_data());
            messages.push(CMsgSetGameOverlayTargetPIDs::generated_message_descriptor_data());
            messages.push(CMsgGameOverlayTargetTextureID::generated_message_descriptor_data());
            messages.push(CMsgDraggableRegionsChanged::generated_message_descriptor_data());
            messages.push(CMsgResizeGripChanged::generated_message_descriptor_data());
            messages.push(CMsgSetWindowPosition::generated_message_descriptor_data());
            messages.push(CMsgShowWindow::generated_message_descriptor_data());
            messages.push(CMsgHideWindow::generated_message_descriptor_data());
            messages.push(CMsgBringWindowToFront::generated_message_descriptor_data());
            messages.push(CMsgSetForegroundWindow::generated_message_descriptor_data());
            messages.push(CMsgMaximizeRestoreWindow::generated_message_descriptor_data());
            messages.push(CMsgMinimizeWindow::generated_message_descriptor_data());
            messages.push(CMsgShowBrowserContextMenu::generated_message_descriptor_data());
            messages.push(CMsgHandleContextMenuCommand::generated_message_descriptor_data());
            messages.push(CMsgImeSetComposition::generated_message_descriptor_data());
            messages.push(CMsgImeCommitText::generated_message_descriptor_data());
            messages.push(CMsgImeCancelComposition::generated_message_descriptor_data());
            messages.push(CMsgImeCompositionRangeChanged::generated_message_descriptor_data());
            messages.push(CMsgInspectElement::generated_message_descriptor_data());
            messages.push(CMsgDisableF5::generated_message_descriptor_data());
            messages.push(CMsgStartDownload::generated_message_descriptor_data());
            messages.push(cmsg_set_local_file_request_mapping::AdditionalRoute::generated_message_descriptor_data());
            messages.push(cmsg_jsvalue::JSObjectProperty::generated_message_descriptor_data());
            messages.push(cmsg_draggable_regions_changed::DraggableRects::generated_message_descriptor_data());
            messages.push(cmsg_show_browser_context_menu::ContextCommand::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(EJSRegisterMethodType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
