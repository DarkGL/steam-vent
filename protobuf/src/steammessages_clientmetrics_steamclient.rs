// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_clientmetrics.steamclient.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:CClientMetrics_AppInterfaceCreation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientMetrics_AppInterfaceCreation {
    // message fields
    // @@protoc_insertion_point(field:CClientMetrics_AppInterfaceCreation.raw_version)
    pub raw_version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientMetrics_AppInterfaceCreation.requested_interface_type)
    pub requested_interface_type: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientMetrics_AppInterfaceCreation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_AppInterfaceCreation {
    fn default() -> &'a CClientMetrics_AppInterfaceCreation {
        <CClientMetrics_AppInterfaceCreation as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_AppInterfaceCreation {
    pub fn new() -> CClientMetrics_AppInterfaceCreation {
        ::std::default::Default::default()
    }

    // optional string raw_version = 1;

    pub fn raw_version(&self) -> &str {
        match self.raw_version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_raw_version(&mut self) {
        self.raw_version = ::std::option::Option::None;
    }

    pub fn has_raw_version(&self) -> bool {
        self.raw_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_version(&mut self, v: ::std::string::String) {
        self.raw_version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_raw_version(&mut self) -> &mut ::std::string::String {
        if self.raw_version.is_none() {
            self.raw_version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.raw_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_raw_version(&mut self) -> ::std::string::String {
        self.raw_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string requested_interface_type = 2;

    pub fn requested_interface_type(&self) -> &str {
        match self.requested_interface_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_requested_interface_type(&mut self) {
        self.requested_interface_type = ::std::option::Option::None;
    }

    pub fn has_requested_interface_type(&self) -> bool {
        self.requested_interface_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requested_interface_type(&mut self, v: ::std::string::String) {
        self.requested_interface_type = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_requested_interface_type(&mut self) -> &mut ::std::string::String {
        if self.requested_interface_type.is_none() {
            self.requested_interface_type = ::std::option::Option::Some(::std::string::String::new());
        }
        self.requested_interface_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_requested_interface_type(&mut self) -> ::std::string::String {
        self.requested_interface_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "raw_version",
            |m: &CClientMetrics_AppInterfaceCreation| { &m.raw_version },
            |m: &mut CClientMetrics_AppInterfaceCreation| { &mut m.raw_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "requested_interface_type",
            |m: &CClientMetrics_AppInterfaceCreation| { &m.requested_interface_type },
            |m: &mut CClientMetrics_AppInterfaceCreation| { &mut m.requested_interface_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CClientMetrics_AppInterfaceCreation>(
            "CClientMetrics_AppInterfaceCreation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CClientMetrics_AppInterfaceCreation {
    const NAME: &'static str = "CClientMetrics_AppInterfaceCreation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.raw_version = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.requested_interface_type = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.raw_version.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.requested_interface_type.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.raw_version.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.requested_interface_type.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientMetrics_AppInterfaceCreation {
        CClientMetrics_AppInterfaceCreation::new()
    }

    fn clear(&mut self) {
        self.raw_version = ::std::option::Option::None;
        self.requested_interface_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientMetrics_AppInterfaceCreation {
        static instance: CClientMetrics_AppInterfaceCreation = CClientMetrics_AppInterfaceCreation {
            raw_version: ::std::option::Option::None,
            requested_interface_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CClientMetrics_AppInterfaceCreation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientMetrics_AppInterfaceCreation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientMetrics_AppInterfaceCreation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClientMetrics_AppInterfaceCreation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientMetrics_AppInterfaceMethodCounts)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientMetrics_AppInterfaceMethodCounts {
    // message fields
    // @@protoc_insertion_point(field:CClientMetrics_AppInterfaceMethodCounts.interface_name)
    pub interface_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientMetrics_AppInterfaceMethodCounts.method_name)
    pub method_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientMetrics_AppInterfaceMethodCounts.call_count)
    pub call_count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientMetrics_AppInterfaceMethodCounts.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_AppInterfaceMethodCounts {
    fn default() -> &'a CClientMetrics_AppInterfaceMethodCounts {
        <CClientMetrics_AppInterfaceMethodCounts as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_AppInterfaceMethodCounts {
    pub fn new() -> CClientMetrics_AppInterfaceMethodCounts {
        ::std::default::Default::default()
    }

    // optional string interface_name = 1;

    pub fn interface_name(&self) -> &str {
        match self.interface_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_interface_name(&mut self) {
        self.interface_name = ::std::option::Option::None;
    }

    pub fn has_interface_name(&self) -> bool {
        self.interface_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interface_name(&mut self, v: ::std::string::String) {
        self.interface_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_interface_name(&mut self) -> &mut ::std::string::String {
        if self.interface_name.is_none() {
            self.interface_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.interface_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_interface_name(&mut self) -> ::std::string::String {
        self.interface_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string method_name = 2;

    pub fn method_name(&self) -> &str {
        match self.method_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_method_name(&mut self) {
        self.method_name = ::std::option::Option::None;
    }

    pub fn has_method_name(&self) -> bool {
        self.method_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_method_name(&mut self, v: ::std::string::String) {
        self.method_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_method_name(&mut self) -> &mut ::std::string::String {
        if self.method_name.is_none() {
            self.method_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.method_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_method_name(&mut self) -> ::std::string::String {
        self.method_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 call_count = 3;

    pub fn call_count(&self) -> u32 {
        self.call_count.unwrap_or(0)
    }

    pub fn clear_call_count(&mut self) {
        self.call_count = ::std::option::Option::None;
    }

    pub fn has_call_count(&self) -> bool {
        self.call_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_call_count(&mut self, v: u32) {
        self.call_count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "interface_name",
            |m: &CClientMetrics_AppInterfaceMethodCounts| { &m.interface_name },
            |m: &mut CClientMetrics_AppInterfaceMethodCounts| { &mut m.interface_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "method_name",
            |m: &CClientMetrics_AppInterfaceMethodCounts| { &m.method_name },
            |m: &mut CClientMetrics_AppInterfaceMethodCounts| { &mut m.method_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "call_count",
            |m: &CClientMetrics_AppInterfaceMethodCounts| { &m.call_count },
            |m: &mut CClientMetrics_AppInterfaceMethodCounts| { &mut m.call_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CClientMetrics_AppInterfaceMethodCounts>(
            "CClientMetrics_AppInterfaceMethodCounts",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CClientMetrics_AppInterfaceMethodCounts {
    const NAME: &'static str = "CClientMetrics_AppInterfaceMethodCounts";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.interface_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.method_name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.call_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.interface_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.method_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.call_count {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.interface_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.method_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.call_count {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientMetrics_AppInterfaceMethodCounts {
        CClientMetrics_AppInterfaceMethodCounts::new()
    }

    fn clear(&mut self) {
        self.interface_name = ::std::option::Option::None;
        self.method_name = ::std::option::Option::None;
        self.call_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientMetrics_AppInterfaceMethodCounts {
        static instance: CClientMetrics_AppInterfaceMethodCounts = CClientMetrics_AppInterfaceMethodCounts {
            interface_name: ::std::option::Option::None,
            method_name: ::std::option::Option::None,
            call_count: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CClientMetrics_AppInterfaceMethodCounts {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientMetrics_AppInterfaceMethodCounts").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientMetrics_AppInterfaceMethodCounts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClientMetrics_AppInterfaceMethodCounts {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientMetrics_AppInterfaceStats_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientMetrics_AppInterfaceStats_Notification {
    // message fields
    // @@protoc_insertion_point(field:CClientMetrics_AppInterfaceStats_Notification.game_id)
    pub game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_AppInterfaceStats_Notification.interfaces_created)
    pub interfaces_created: ::std::vec::Vec<CClientMetrics_AppInterfaceCreation>,
    // @@protoc_insertion_point(field:CClientMetrics_AppInterfaceStats_Notification.methods_called)
    pub methods_called: ::std::vec::Vec<CClientMetrics_AppInterfaceMethodCounts>,
    // @@protoc_insertion_point(field:CClientMetrics_AppInterfaceStats_Notification.session_length_seconds)
    pub session_length_seconds: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientMetrics_AppInterfaceStats_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_AppInterfaceStats_Notification {
    fn default() -> &'a CClientMetrics_AppInterfaceStats_Notification {
        <CClientMetrics_AppInterfaceStats_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_AppInterfaceStats_Notification {
    pub fn new() -> CClientMetrics_AppInterfaceStats_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 game_id = 1;

    pub fn game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // optional uint32 session_length_seconds = 4;

    pub fn session_length_seconds(&self) -> u32 {
        self.session_length_seconds.unwrap_or(0)
    }

    pub fn clear_session_length_seconds(&mut self) {
        self.session_length_seconds = ::std::option::Option::None;
    }

    pub fn has_session_length_seconds(&self) -> bool {
        self.session_length_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_length_seconds(&mut self, v: u32) {
        self.session_length_seconds = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_id",
            |m: &CClientMetrics_AppInterfaceStats_Notification| { &m.game_id },
            |m: &mut CClientMetrics_AppInterfaceStats_Notification| { &mut m.game_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "interfaces_created",
            |m: &CClientMetrics_AppInterfaceStats_Notification| { &m.interfaces_created },
            |m: &mut CClientMetrics_AppInterfaceStats_Notification| { &mut m.interfaces_created },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "methods_called",
            |m: &CClientMetrics_AppInterfaceStats_Notification| { &m.methods_called },
            |m: &mut CClientMetrics_AppInterfaceStats_Notification| { &mut m.methods_called },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "session_length_seconds",
            |m: &CClientMetrics_AppInterfaceStats_Notification| { &m.session_length_seconds },
            |m: &mut CClientMetrics_AppInterfaceStats_Notification| { &mut m.session_length_seconds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CClientMetrics_AppInterfaceStats_Notification>(
            "CClientMetrics_AppInterfaceStats_Notification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CClientMetrics_AppInterfaceStats_Notification {
    const NAME: &'static str = "CClientMetrics_AppInterfaceStats_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.interfaces_created.push(is.read_message()?);
                },
                26 => {
                    self.methods_called.push(is.read_message()?);
                },
                32 => {
                    self.session_length_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.interfaces_created {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.methods_called {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.session_length_seconds {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.game_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.interfaces_created {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.methods_called {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.session_length_seconds {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientMetrics_AppInterfaceStats_Notification {
        CClientMetrics_AppInterfaceStats_Notification::new()
    }

    fn clear(&mut self) {
        self.game_id = ::std::option::Option::None;
        self.interfaces_created.clear();
        self.methods_called.clear();
        self.session_length_seconds = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientMetrics_AppInterfaceStats_Notification {
        static instance: CClientMetrics_AppInterfaceStats_Notification = CClientMetrics_AppInterfaceStats_Notification {
            game_id: ::std::option::Option::None,
            interfaces_created: ::std::vec::Vec::new(),
            methods_called: ::std::vec::Vec::new(),
            session_length_seconds: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CClientMetrics_AppInterfaceStats_Notification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientMetrics_AppInterfaceStats_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientMetrics_AppInterfaceStats_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClientMetrics_AppInterfaceStats_Notification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientMetrics_IPv6Connectivity_Result)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientMetrics_IPv6Connectivity_Result {
    // message fields
    // @@protoc_insertion_point(field:CClientMetrics_IPv6Connectivity_Result.protocol_tested)
    pub protocol_tested: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientMetrics_IPv6Connectivity_Result.connectivity_state)
    pub connectivity_state: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientMetrics_IPv6Connectivity_Result.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_IPv6Connectivity_Result {
    fn default() -> &'a CClientMetrics_IPv6Connectivity_Result {
        <CClientMetrics_IPv6Connectivity_Result as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_IPv6Connectivity_Result {
    pub fn new() -> CClientMetrics_IPv6Connectivity_Result {
        ::std::default::Default::default()
    }

    // optional uint32 protocol_tested = 1;

    pub fn protocol_tested(&self) -> u32 {
        self.protocol_tested.unwrap_or(0)
    }

    pub fn clear_protocol_tested(&mut self) {
        self.protocol_tested = ::std::option::Option::None;
    }

    pub fn has_protocol_tested(&self) -> bool {
        self.protocol_tested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_tested(&mut self, v: u32) {
        self.protocol_tested = ::std::option::Option::Some(v);
    }

    // optional uint32 connectivity_state = 2;

    pub fn connectivity_state(&self) -> u32 {
        self.connectivity_state.unwrap_or(0)
    }

    pub fn clear_connectivity_state(&mut self) {
        self.connectivity_state = ::std::option::Option::None;
    }

    pub fn has_connectivity_state(&self) -> bool {
        self.connectivity_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connectivity_state(&mut self, v: u32) {
        self.connectivity_state = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "protocol_tested",
            |m: &CClientMetrics_IPv6Connectivity_Result| { &m.protocol_tested },
            |m: &mut CClientMetrics_IPv6Connectivity_Result| { &mut m.protocol_tested },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "connectivity_state",
            |m: &CClientMetrics_IPv6Connectivity_Result| { &m.connectivity_state },
            |m: &mut CClientMetrics_IPv6Connectivity_Result| { &mut m.connectivity_state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CClientMetrics_IPv6Connectivity_Result>(
            "CClientMetrics_IPv6Connectivity_Result",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CClientMetrics_IPv6Connectivity_Result {
    const NAME: &'static str = "CClientMetrics_IPv6Connectivity_Result";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.protocol_tested = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.connectivity_state = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.protocol_tested {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.connectivity_state {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.protocol_tested {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.connectivity_state {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientMetrics_IPv6Connectivity_Result {
        CClientMetrics_IPv6Connectivity_Result::new()
    }

    fn clear(&mut self) {
        self.protocol_tested = ::std::option::Option::None;
        self.connectivity_state = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientMetrics_IPv6Connectivity_Result {
        static instance: CClientMetrics_IPv6Connectivity_Result = CClientMetrics_IPv6Connectivity_Result {
            protocol_tested: ::std::option::Option::None,
            connectivity_state: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CClientMetrics_IPv6Connectivity_Result {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientMetrics_IPv6Connectivity_Result").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientMetrics_IPv6Connectivity_Result {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClientMetrics_IPv6Connectivity_Result {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientMetrics_IPv6Connectivity_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientMetrics_IPv6Connectivity_Notification {
    // message fields
    // @@protoc_insertion_point(field:CClientMetrics_IPv6Connectivity_Notification.cell_id)
    pub cell_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientMetrics_IPv6Connectivity_Notification.results)
    pub results: ::std::vec::Vec<CClientMetrics_IPv6Connectivity_Result>,
    // @@protoc_insertion_point(field:CClientMetrics_IPv6Connectivity_Notification.private_ip_is_rfc6598)
    pub private_ip_is_rfc6598: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientMetrics_IPv6Connectivity_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_IPv6Connectivity_Notification {
    fn default() -> &'a CClientMetrics_IPv6Connectivity_Notification {
        <CClientMetrics_IPv6Connectivity_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_IPv6Connectivity_Notification {
    pub fn new() -> CClientMetrics_IPv6Connectivity_Notification {
        ::std::default::Default::default()
    }

    // optional uint32 cell_id = 1;

    pub fn cell_id(&self) -> u32 {
        self.cell_id.unwrap_or(0)
    }

    pub fn clear_cell_id(&mut self) {
        self.cell_id = ::std::option::Option::None;
    }

    pub fn has_cell_id(&self) -> bool {
        self.cell_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id(&mut self, v: u32) {
        self.cell_id = ::std::option::Option::Some(v);
    }

    // optional bool private_ip_is_rfc6598 = 3;

    pub fn private_ip_is_rfc6598(&self) -> bool {
        self.private_ip_is_rfc6598.unwrap_or(false)
    }

    pub fn clear_private_ip_is_rfc6598(&mut self) {
        self.private_ip_is_rfc6598 = ::std::option::Option::None;
    }

    pub fn has_private_ip_is_rfc6598(&self) -> bool {
        self.private_ip_is_rfc6598.is_some()
    }

    // Param is passed by value, moved
    pub fn set_private_ip_is_rfc6598(&mut self, v: bool) {
        self.private_ip_is_rfc6598 = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cell_id",
            |m: &CClientMetrics_IPv6Connectivity_Notification| { &m.cell_id },
            |m: &mut CClientMetrics_IPv6Connectivity_Notification| { &mut m.cell_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "results",
            |m: &CClientMetrics_IPv6Connectivity_Notification| { &m.results },
            |m: &mut CClientMetrics_IPv6Connectivity_Notification| { &mut m.results },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "private_ip_is_rfc6598",
            |m: &CClientMetrics_IPv6Connectivity_Notification| { &m.private_ip_is_rfc6598 },
            |m: &mut CClientMetrics_IPv6Connectivity_Notification| { &mut m.private_ip_is_rfc6598 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CClientMetrics_IPv6Connectivity_Notification>(
            "CClientMetrics_IPv6Connectivity_Notification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CClientMetrics_IPv6Connectivity_Notification {
    const NAME: &'static str = "CClientMetrics_IPv6Connectivity_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cell_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.results.push(is.read_message()?);
                },
                24 => {
                    self.private_ip_is_rfc6598 = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cell_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.private_ip_is_rfc6598 {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cell_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.results {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.private_ip_is_rfc6598 {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientMetrics_IPv6Connectivity_Notification {
        CClientMetrics_IPv6Connectivity_Notification::new()
    }

    fn clear(&mut self) {
        self.cell_id = ::std::option::Option::None;
        self.results.clear();
        self.private_ip_is_rfc6598 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientMetrics_IPv6Connectivity_Notification {
        static instance: CClientMetrics_IPv6Connectivity_Notification = CClientMetrics_IPv6Connectivity_Notification {
            cell_id: ::std::option::Option::None,
            results: ::std::vec::Vec::new(),
            private_ip_is_rfc6598: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CClientMetrics_IPv6Connectivity_Notification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientMetrics_IPv6Connectivity_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientMetrics_IPv6Connectivity_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClientMetrics_IPv6Connectivity_Notification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientMetrics_SteamPipeWorkStats_Operation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientMetrics_SteamPipeWorkStats_Operation {
    // message fields
    // @@protoc_insertion_point(field:CClientMetrics_SteamPipeWorkStats_Operation.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<ESteamPipeOperationType>>,
    // @@protoc_insertion_point(field:CClientMetrics_SteamPipeWorkStats_Operation.num_ops)
    pub num_ops: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientMetrics_SteamPipeWorkStats_Operation.num_bytes)
    pub num_bytes: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_SteamPipeWorkStats_Operation.busy_time_ms)
    pub busy_time_ms: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_SteamPipeWorkStats_Operation.idle_time_ms)
    pub idle_time_ms: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_SteamPipeWorkStats_Operation.sum_run_time_ms)
    pub sum_run_time_ms: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientMetrics_SteamPipeWorkStats_Operation.sum_wait_time_ms)
    pub sum_wait_time_ms: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientMetrics_SteamPipeWorkStats_Operation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_SteamPipeWorkStats_Operation {
    fn default() -> &'a CClientMetrics_SteamPipeWorkStats_Operation {
        <CClientMetrics_SteamPipeWorkStats_Operation as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_SteamPipeWorkStats_Operation {
    pub fn new() -> CClientMetrics_SteamPipeWorkStats_Operation {
        ::std::default::Default::default()
    }

    // optional .ESteamPipeOperationType type = 1;

    pub fn type_(&self) -> ESteamPipeOperationType {
        match self.type_ {
            Some(e) => e.enum_value_or(ESteamPipeOperationType::k_ESteamPipeOperationType_Invalid),
            None => ESteamPipeOperationType::k_ESteamPipeOperationType_Invalid,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ESteamPipeOperationType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 num_ops = 2;

    pub fn num_ops(&self) -> u32 {
        self.num_ops.unwrap_or(0)
    }

    pub fn clear_num_ops(&mut self) {
        self.num_ops = ::std::option::Option::None;
    }

    pub fn has_num_ops(&self) -> bool {
        self.num_ops.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_ops(&mut self, v: u32) {
        self.num_ops = ::std::option::Option::Some(v);
    }

    // optional uint64 num_bytes = 3;

    pub fn num_bytes(&self) -> u64 {
        self.num_bytes.unwrap_or(0)
    }

    pub fn clear_num_bytes(&mut self) {
        self.num_bytes = ::std::option::Option::None;
    }

    pub fn has_num_bytes(&self) -> bool {
        self.num_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_bytes(&mut self, v: u64) {
        self.num_bytes = ::std::option::Option::Some(v);
    }

    // optional uint64 busy_time_ms = 4;

    pub fn busy_time_ms(&self) -> u64 {
        self.busy_time_ms.unwrap_or(0)
    }

    pub fn clear_busy_time_ms(&mut self) {
        self.busy_time_ms = ::std::option::Option::None;
    }

    pub fn has_busy_time_ms(&self) -> bool {
        self.busy_time_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_busy_time_ms(&mut self, v: u64) {
        self.busy_time_ms = ::std::option::Option::Some(v);
    }

    // optional uint64 idle_time_ms = 5;

    pub fn idle_time_ms(&self) -> u64 {
        self.idle_time_ms.unwrap_or(0)
    }

    pub fn clear_idle_time_ms(&mut self) {
        self.idle_time_ms = ::std::option::Option::None;
    }

    pub fn has_idle_time_ms(&self) -> bool {
        self.idle_time_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idle_time_ms(&mut self, v: u64) {
        self.idle_time_ms = ::std::option::Option::Some(v);
    }

    // optional uint64 sum_run_time_ms = 6;

    pub fn sum_run_time_ms(&self) -> u64 {
        self.sum_run_time_ms.unwrap_or(0)
    }

    pub fn clear_sum_run_time_ms(&mut self) {
        self.sum_run_time_ms = ::std::option::Option::None;
    }

    pub fn has_sum_run_time_ms(&self) -> bool {
        self.sum_run_time_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sum_run_time_ms(&mut self, v: u64) {
        self.sum_run_time_ms = ::std::option::Option::Some(v);
    }

    // optional uint64 sum_wait_time_ms = 7;

    pub fn sum_wait_time_ms(&self) -> u64 {
        self.sum_wait_time_ms.unwrap_or(0)
    }

    pub fn clear_sum_wait_time_ms(&mut self) {
        self.sum_wait_time_ms = ::std::option::Option::None;
    }

    pub fn has_sum_wait_time_ms(&self) -> bool {
        self.sum_wait_time_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sum_wait_time_ms(&mut self, v: u64) {
        self.sum_wait_time_ms = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CClientMetrics_SteamPipeWorkStats_Operation| { &m.type_ },
            |m: &mut CClientMetrics_SteamPipeWorkStats_Operation| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_ops",
            |m: &CClientMetrics_SteamPipeWorkStats_Operation| { &m.num_ops },
            |m: &mut CClientMetrics_SteamPipeWorkStats_Operation| { &mut m.num_ops },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_bytes",
            |m: &CClientMetrics_SteamPipeWorkStats_Operation| { &m.num_bytes },
            |m: &mut CClientMetrics_SteamPipeWorkStats_Operation| { &mut m.num_bytes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "busy_time_ms",
            |m: &CClientMetrics_SteamPipeWorkStats_Operation| { &m.busy_time_ms },
            |m: &mut CClientMetrics_SteamPipeWorkStats_Operation| { &mut m.busy_time_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "idle_time_ms",
            |m: &CClientMetrics_SteamPipeWorkStats_Operation| { &m.idle_time_ms },
            |m: &mut CClientMetrics_SteamPipeWorkStats_Operation| { &mut m.idle_time_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sum_run_time_ms",
            |m: &CClientMetrics_SteamPipeWorkStats_Operation| { &m.sum_run_time_ms },
            |m: &mut CClientMetrics_SteamPipeWorkStats_Operation| { &mut m.sum_run_time_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sum_wait_time_ms",
            |m: &CClientMetrics_SteamPipeWorkStats_Operation| { &m.sum_wait_time_ms },
            |m: &mut CClientMetrics_SteamPipeWorkStats_Operation| { &mut m.sum_wait_time_ms },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CClientMetrics_SteamPipeWorkStats_Operation>(
            "CClientMetrics_SteamPipeWorkStats_Operation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CClientMetrics_SteamPipeWorkStats_Operation {
    const NAME: &'static str = "CClientMetrics_SteamPipeWorkStats_Operation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.num_ops = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.num_bytes = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.busy_time_ms = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.idle_time_ms = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.sum_run_time_ms = ::std::option::Option::Some(is.read_uint64()?);
                },
                56 => {
                    self.sum_wait_time_ms = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.num_ops {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.num_bytes {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.busy_time_ms {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.idle_time_ms {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.sum_run_time_ms {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.sum_wait_time_ms {
            my_size += ::protobuf::rt::uint64_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.num_ops {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.num_bytes {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.busy_time_ms {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.idle_time_ms {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.sum_run_time_ms {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.sum_wait_time_ms {
            os.write_uint64(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientMetrics_SteamPipeWorkStats_Operation {
        CClientMetrics_SteamPipeWorkStats_Operation::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.num_ops = ::std::option::Option::None;
        self.num_bytes = ::std::option::Option::None;
        self.busy_time_ms = ::std::option::Option::None;
        self.idle_time_ms = ::std::option::Option::None;
        self.sum_run_time_ms = ::std::option::Option::None;
        self.sum_wait_time_ms = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientMetrics_SteamPipeWorkStats_Operation {
        static instance: CClientMetrics_SteamPipeWorkStats_Operation = CClientMetrics_SteamPipeWorkStats_Operation {
            type_: ::std::option::Option::None,
            num_ops: ::std::option::Option::None,
            num_bytes: ::std::option::Option::None,
            busy_time_ms: ::std::option::Option::None,
            idle_time_ms: ::std::option::Option::None,
            sum_run_time_ms: ::std::option::Option::None,
            sum_wait_time_ms: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CClientMetrics_SteamPipeWorkStats_Operation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientMetrics_SteamPipeWorkStats_Operation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientMetrics_SteamPipeWorkStats_Operation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClientMetrics_SteamPipeWorkStats_Operation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientMetrics_SteamPipeWorkStats_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientMetrics_SteamPipeWorkStats_Notification {
    // message fields
    // @@protoc_insertion_point(field:CClientMetrics_SteamPipeWorkStats_Notification.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientMetrics_SteamPipeWorkStats_Notification.depotid)
    pub depotid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientMetrics_SteamPipeWorkStats_Notification.work_type)
    pub work_type: ::std::option::Option<::protobuf::EnumOrUnknown<ESteamPipeWorkType>>,
    // @@protoc_insertion_point(field:CClientMetrics_SteamPipeWorkStats_Notification.operations)
    pub operations: ::std::vec::Vec<CClientMetrics_SteamPipeWorkStats_Operation>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientMetrics_SteamPipeWorkStats_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_SteamPipeWorkStats_Notification {
    fn default() -> &'a CClientMetrics_SteamPipeWorkStats_Notification {
        <CClientMetrics_SteamPipeWorkStats_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_SteamPipeWorkStats_Notification {
    pub fn new() -> CClientMetrics_SteamPipeWorkStats_Notification {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 depotid = 2;

    pub fn depotid(&self) -> u32 {
        self.depotid.unwrap_or(0)
    }

    pub fn clear_depotid(&mut self) {
        self.depotid = ::std::option::Option::None;
    }

    pub fn has_depotid(&self) -> bool {
        self.depotid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_depotid(&mut self, v: u32) {
        self.depotid = ::std::option::Option::Some(v);
    }

    // optional .ESteamPipeWorkType work_type = 3;

    pub fn work_type(&self) -> ESteamPipeWorkType {
        match self.work_type {
            Some(e) => e.enum_value_or(ESteamPipeWorkType::k_ESteamPipeClientWorkType_Invalid),
            None => ESteamPipeWorkType::k_ESteamPipeClientWorkType_Invalid,
        }
    }

    pub fn clear_work_type(&mut self) {
        self.work_type = ::std::option::Option::None;
    }

    pub fn has_work_type(&self) -> bool {
        self.work_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_work_type(&mut self, v: ESteamPipeWorkType) {
        self.work_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CClientMetrics_SteamPipeWorkStats_Notification| { &m.appid },
            |m: &mut CClientMetrics_SteamPipeWorkStats_Notification| { &mut m.appid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "depotid",
            |m: &CClientMetrics_SteamPipeWorkStats_Notification| { &m.depotid },
            |m: &mut CClientMetrics_SteamPipeWorkStats_Notification| { &mut m.depotid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "work_type",
            |m: &CClientMetrics_SteamPipeWorkStats_Notification| { &m.work_type },
            |m: &mut CClientMetrics_SteamPipeWorkStats_Notification| { &mut m.work_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "operations",
            |m: &CClientMetrics_SteamPipeWorkStats_Notification| { &m.operations },
            |m: &mut CClientMetrics_SteamPipeWorkStats_Notification| { &mut m.operations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CClientMetrics_SteamPipeWorkStats_Notification>(
            "CClientMetrics_SteamPipeWorkStats_Notification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CClientMetrics_SteamPipeWorkStats_Notification {
    const NAME: &'static str = "CClientMetrics_SteamPipeWorkStats_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.depotid = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.work_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                34 => {
                    self.operations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.depotid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.work_type {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        for value in &self.operations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.depotid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.work_type {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.operations {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientMetrics_SteamPipeWorkStats_Notification {
        CClientMetrics_SteamPipeWorkStats_Notification::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.depotid = ::std::option::Option::None;
        self.work_type = ::std::option::Option::None;
        self.operations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientMetrics_SteamPipeWorkStats_Notification {
        static instance: CClientMetrics_SteamPipeWorkStats_Notification = CClientMetrics_SteamPipeWorkStats_Notification {
            appid: ::std::option::Option::None,
            depotid: ::std::option::Option::None,
            work_type: ::std::option::Option::None,
            operations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CClientMetrics_SteamPipeWorkStats_Notification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientMetrics_SteamPipeWorkStats_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientMetrics_SteamPipeWorkStats_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClientMetrics_SteamPipeWorkStats_Notification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientMetrics_ReportClientError_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientMetrics_ReportClientError_Notification {
    // message fields
    // @@protoc_insertion_point(field:CClientMetrics_ReportClientError_Notification.product)
    pub product: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientMetrics_ReportClientError_Notification.version)
    pub version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientMetrics_ReportClientError_Notification.errors)
    pub errors: ::std::vec::Vec<cclient_metrics_report_client_error_notification::Error>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientMetrics_ReportClientError_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_ReportClientError_Notification {
    fn default() -> &'a CClientMetrics_ReportClientError_Notification {
        <CClientMetrics_ReportClientError_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_ReportClientError_Notification {
    pub fn new() -> CClientMetrics_ReportClientError_Notification {
        ::std::default::Default::default()
    }

    // optional string product = 1;

    pub fn product(&self) -> &str {
        match self.product.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_product(&mut self) {
        self.product = ::std::option::Option::None;
    }

    pub fn has_product(&self) -> bool {
        self.product.is_some()
    }

    // Param is passed by value, moved
    pub fn set_product(&mut self, v: ::std::string::String) {
        self.product = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_product(&mut self) -> &mut ::std::string::String {
        if self.product.is_none() {
            self.product = ::std::option::Option::Some(::std::string::String::new());
        }
        self.product.as_mut().unwrap()
    }

    // Take field
    pub fn take_product(&mut self) -> ::std::string::String {
        self.product.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string version = 2;

    pub fn version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "product",
            |m: &CClientMetrics_ReportClientError_Notification| { &m.product },
            |m: &mut CClientMetrics_ReportClientError_Notification| { &mut m.product },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CClientMetrics_ReportClientError_Notification| { &m.version },
            |m: &mut CClientMetrics_ReportClientError_Notification| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "errors",
            |m: &CClientMetrics_ReportClientError_Notification| { &m.errors },
            |m: &mut CClientMetrics_ReportClientError_Notification| { &mut m.errors },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CClientMetrics_ReportClientError_Notification>(
            "CClientMetrics_ReportClientError_Notification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CClientMetrics_ReportClientError_Notification {
    const NAME: &'static str = "CClientMetrics_ReportClientError_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.product = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.version = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.errors.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.product.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.errors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.product.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.version.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.errors {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientMetrics_ReportClientError_Notification {
        CClientMetrics_ReportClientError_Notification::new()
    }

    fn clear(&mut self) {
        self.product = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.errors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientMetrics_ReportClientError_Notification {
        static instance: CClientMetrics_ReportClientError_Notification = CClientMetrics_ReportClientError_Notification {
            product: ::std::option::Option::None,
            version: ::std::option::Option::None,
            errors: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CClientMetrics_ReportClientError_Notification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientMetrics_ReportClientError_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientMetrics_ReportClientError_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClientMetrics_ReportClientError_Notification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CClientMetrics_ReportClientError_Notification`
pub mod cclient_metrics_report_client_error_notification {
    // @@protoc_insertion_point(message:CClientMetrics_ReportClientError_Notification.Error)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Error {
        // message fields
        // @@protoc_insertion_point(field:CClientMetrics_ReportClientError_Notification.Error.identifier)
        pub identifier: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CClientMetrics_ReportClientError_Notification.Error.message)
        pub message: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CClientMetrics_ReportClientError_Notification.Error.count)
        pub count: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CClientMetrics_ReportClientError_Notification.Error.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Error {
        fn default() -> &'a Error {
            <Error as ::protobuf::Message>::default_instance()
        }
    }

    impl Error {
        pub fn new() -> Error {
            ::std::default::Default::default()
        }

        // optional string identifier = 1;

        pub fn identifier(&self) -> &str {
            match self.identifier.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_identifier(&mut self) {
            self.identifier = ::std::option::Option::None;
        }

        pub fn has_identifier(&self) -> bool {
            self.identifier.is_some()
        }

        // Param is passed by value, moved
        pub fn set_identifier(&mut self, v: ::std::string::String) {
            self.identifier = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_identifier(&mut self) -> &mut ::std::string::String {
            if self.identifier.is_none() {
                self.identifier = ::std::option::Option::Some(::std::string::String::new());
            }
            self.identifier.as_mut().unwrap()
        }

        // Take field
        pub fn take_identifier(&mut self) -> ::std::string::String {
            self.identifier.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string message = 2;

        pub fn message(&self) -> &str {
            match self.message.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_message(&mut self) {
            self.message = ::std::option::Option::None;
        }

        pub fn has_message(&self) -> bool {
            self.message.is_some()
        }

        // Param is passed by value, moved
        pub fn set_message(&mut self, v: ::std::string::String) {
            self.message = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_message(&mut self) -> &mut ::std::string::String {
            if self.message.is_none() {
                self.message = ::std::option::Option::Some(::std::string::String::new());
            }
            self.message.as_mut().unwrap()
        }

        // Take field
        pub fn take_message(&mut self) -> ::std::string::String {
            self.message.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 count = 3;

        pub fn count(&self) -> u32 {
            self.count.unwrap_or(0)
        }

        pub fn clear_count(&mut self) {
            self.count = ::std::option::Option::None;
        }

        pub fn has_count(&self) -> bool {
            self.count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_count(&mut self, v: u32) {
            self.count = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "identifier",
                |m: &Error| { &m.identifier },
                |m: &mut Error| { &mut m.identifier },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "message",
                |m: &Error| { &m.message },
                |m: &mut Error| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "count",
                |m: &Error| { &m.count },
                |m: &mut Error| { &mut m.count },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Error>(
                "CClientMetrics_ReportClientError_Notification.Error",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Error {
        const NAME: &'static str = "Error";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.identifier = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.message = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.identifier.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.message.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.count {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.identifier.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.message.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.count {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Error {
            Error::new()
        }

        fn clear(&mut self) {
            self.identifier = ::std::option::Option::None;
            self.message = ::std::option::Option::None;
            self.count = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Error {
            static instance: Error = Error {
                identifier: ::std::option::Option::None,
                message: ::std::option::Option::None,
                count: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Error {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CClientMetrics_ReportClientError_Notification.Error").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Error {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Error {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CClientMetrics_ClientBootstrap_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientMetrics_ClientBootstrap_Notification {
    // message fields
    // @@protoc_insertion_point(field:CClientMetrics_ClientBootstrap_Notification.summary)
    pub summary: ::protobuf::MessageField<super::clientmetrics::CClientMetrics_ClientBootstrap_Summary>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientMetrics_ClientBootstrap_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_ClientBootstrap_Notification {
    fn default() -> &'a CClientMetrics_ClientBootstrap_Notification {
        <CClientMetrics_ClientBootstrap_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_ClientBootstrap_Notification {
    pub fn new() -> CClientMetrics_ClientBootstrap_Notification {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::clientmetrics::CClientMetrics_ClientBootstrap_Summary>(
            "summary",
            |m: &CClientMetrics_ClientBootstrap_Notification| { &m.summary },
            |m: &mut CClientMetrics_ClientBootstrap_Notification| { &mut m.summary },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CClientMetrics_ClientBootstrap_Notification>(
            "CClientMetrics_ClientBootstrap_Notification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CClientMetrics_ClientBootstrap_Notification {
    const NAME: &'static str = "CClientMetrics_ClientBootstrap_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.summary)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.summary.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientMetrics_ClientBootstrap_Notification {
        CClientMetrics_ClientBootstrap_Notification::new()
    }

    fn clear(&mut self) {
        self.summary.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientMetrics_ClientBootstrap_Notification {
        static instance: CClientMetrics_ClientBootstrap_Notification = CClientMetrics_ClientBootstrap_Notification {
            summary: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CClientMetrics_ClientBootstrap_Notification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientMetrics_ClientBootstrap_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientMetrics_ClientBootstrap_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClientMetrics_ClientBootstrap_Notification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESteamPipeWorkType)
pub enum ESteamPipeWorkType {
    // @@protoc_insertion_point(enum_value:ESteamPipeWorkType.k_ESteamPipeClientWorkType_Invalid)
    k_ESteamPipeClientWorkType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ESteamPipeWorkType.k_ESteamPipeClientWorkType_StageFromChunkStores)
    k_ESteamPipeClientWorkType_StageFromChunkStores = 1,
}

impl ::protobuf::Enum for ESteamPipeWorkType {
    const NAME: &'static str = "ESteamPipeWorkType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESteamPipeWorkType> {
        match value {
            0 => ::std::option::Option::Some(ESteamPipeWorkType::k_ESteamPipeClientWorkType_Invalid),
            1 => ::std::option::Option::Some(ESteamPipeWorkType::k_ESteamPipeClientWorkType_StageFromChunkStores),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESteamPipeWorkType> {
        match str {
            "k_ESteamPipeClientWorkType_Invalid" => ::std::option::Option::Some(ESteamPipeWorkType::k_ESteamPipeClientWorkType_Invalid),
            "k_ESteamPipeClientWorkType_StageFromChunkStores" => ::std::option::Option::Some(ESteamPipeWorkType::k_ESteamPipeClientWorkType_StageFromChunkStores),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESteamPipeWorkType] = &[
        ESteamPipeWorkType::k_ESteamPipeClientWorkType_Invalid,
        ESteamPipeWorkType::k_ESteamPipeClientWorkType_StageFromChunkStores,
    ];
}

impl ::protobuf::EnumFull for ESteamPipeWorkType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESteamPipeWorkType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESteamPipeWorkType {
    fn default() -> Self {
        ESteamPipeWorkType::k_ESteamPipeClientWorkType_Invalid
    }
}

impl ESteamPipeWorkType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ESteamPipeWorkType>("ESteamPipeWorkType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESteamPipeOperationType)
pub enum ESteamPipeOperationType {
    // @@protoc_insertion_point(enum_value:ESteamPipeOperationType.k_ESteamPipeOperationType_Invalid)
    k_ESteamPipeOperationType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ESteamPipeOperationType.k_ESteamPipeOperationType_DecryptCPU)
    k_ESteamPipeOperationType_DecryptCPU = 1,
    // @@protoc_insertion_point(enum_value:ESteamPipeOperationType.k_ESteamPipeOperationType_DiskRead)
    k_ESteamPipeOperationType_DiskRead = 2,
    // @@protoc_insertion_point(enum_value:ESteamPipeOperationType.k_ESteamPipeOperationType_DiskWrite)
    k_ESteamPipeOperationType_DiskWrite = 3,
}

impl ::protobuf::Enum for ESteamPipeOperationType {
    const NAME: &'static str = "ESteamPipeOperationType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESteamPipeOperationType> {
        match value {
            0 => ::std::option::Option::Some(ESteamPipeOperationType::k_ESteamPipeOperationType_Invalid),
            1 => ::std::option::Option::Some(ESteamPipeOperationType::k_ESteamPipeOperationType_DecryptCPU),
            2 => ::std::option::Option::Some(ESteamPipeOperationType::k_ESteamPipeOperationType_DiskRead),
            3 => ::std::option::Option::Some(ESteamPipeOperationType::k_ESteamPipeOperationType_DiskWrite),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESteamPipeOperationType> {
        match str {
            "k_ESteamPipeOperationType_Invalid" => ::std::option::Option::Some(ESteamPipeOperationType::k_ESteamPipeOperationType_Invalid),
            "k_ESteamPipeOperationType_DecryptCPU" => ::std::option::Option::Some(ESteamPipeOperationType::k_ESteamPipeOperationType_DecryptCPU),
            "k_ESteamPipeOperationType_DiskRead" => ::std::option::Option::Some(ESteamPipeOperationType::k_ESteamPipeOperationType_DiskRead),
            "k_ESteamPipeOperationType_DiskWrite" => ::std::option::Option::Some(ESteamPipeOperationType::k_ESteamPipeOperationType_DiskWrite),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESteamPipeOperationType] = &[
        ESteamPipeOperationType::k_ESteamPipeOperationType_Invalid,
        ESteamPipeOperationType::k_ESteamPipeOperationType_DecryptCPU,
        ESteamPipeOperationType::k_ESteamPipeOperationType_DiskRead,
        ESteamPipeOperationType::k_ESteamPipeOperationType_DiskWrite,
    ];
}

impl ::protobuf::EnumFull for ESteamPipeOperationType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESteamPipeOperationType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESteamPipeOperationType {
    fn default() -> Self {
        ESteamPipeOperationType::k_ESteamPipeOperationType_Invalid
    }
}

impl ESteamPipeOperationType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ESteamPipeOperationType>("ESteamPipeOperationType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n-steammessages_clientmetrics.steamclient.proto\x1a,steammessages_unifi\
    ed_base.steamclient.proto\x1a\x13clientmetrics.proto\"\x80\x01\n#CClient\
    Metrics_AppInterfaceCreation\x12\x1f\n\x0braw_version\x18\x01\x20\x01(\t\
    R\nrawVersion\x128\n\x18requested_interface_type\x18\x02\x20\x01(\tR\x16\
    requestedInterfaceType\"\x90\x01\n'CClientMetrics_AppInterfaceMethodCoun\
    ts\x12%\n\x0einterface_name\x18\x01\x20\x01(\tR\rinterfaceName\x12\x1f\n\
    \x0bmethod_name\x18\x02\x20\x01(\tR\nmethodName\x12\x1d\n\ncall_count\
    \x18\x03\x20\x01(\rR\tcallCount\"\xa4\x02\n-CClientMetrics_AppInterfaceS\
    tats_Notification\x12\x17\n\x07game_id\x18\x01\x20\x01(\x04R\x06gameId\
    \x12S\n\x12interfaces_created\x18\x02\x20\x03(\x0b2$.CClientMetrics_AppI\
    nterfaceCreationR\x11interfacesCreated\x12O\n\x0emethods_called\x18\x03\
    \x20\x03(\x0b2(.CClientMetrics_AppInterfaceMethodCountsR\rmethodsCalled\
    \x124\n\x16session_length_seconds\x18\x04\x20\x01(\rR\x14sessionLengthSe\
    conds\"\x80\x01\n&CClientMetrics_IPv6Connectivity_Result\x12'\n\x0fproto\
    col_tested\x18\x01\x20\x01(\rR\x0eprotocolTested\x12-\n\x12connectivity_\
    state\x18\x02\x20\x01(\rR\x11connectivityState\"\xbd\x01\n,CClientMetric\
    s_IPv6Connectivity_Notification\x12\x17\n\x07cell_id\x18\x01\x20\x01(\rR\
    \x06cellId\x12A\n\x07results\x18\x02\x20\x03(\x0b2'.CClientMetrics_IPv6C\
    onnectivity_ResultR\x07results\x121\n\x15private_ip_is_rfc6598\x18\x03\
    \x20\x01(\x08R\x12privateIpIsRfc6598\"\xc8\x02\n+CClientMetrics_SteamPip\
    eWorkStats_Operation\x12O\n\x04type\x18\x01\x20\x01(\x0e2\x18.ESteamPipe\
    OperationType:!k_ESteamPipeOperationType_InvalidR\x04type\x12\x17\n\x07n\
    um_ops\x18\x02\x20\x01(\rR\x06numOps\x12\x1b\n\tnum_bytes\x18\x03\x20\
    \x01(\x04R\x08numBytes\x12\x20\n\x0cbusy_time_ms\x18\x04\x20\x01(\x04R\n\
    busyTimeMs\x12\x20\n\x0cidle_time_ms\x18\x05\x20\x01(\x04R\nidleTimeMs\
    \x12%\n\x0fsum_run_time_ms\x18\x06\x20\x01(\x04R\x0csumRunTimeMs\x12'\n\
    \x10sum_wait_time_ms\x18\x07\x20\x01(\x04R\rsumWaitTimeMs\"\x84\x02\n.CC\
    lientMetrics_SteamPipeWorkStats_Notification\x12\x14\n\x05appid\x18\x01\
    \x20\x01(\rR\x05appid\x12\x18\n\x07depotid\x18\x02\x20\x01(\rR\x07depoti\
    d\x12T\n\twork_type\x18\x03\x20\x01(\x0e2\x13.ESteamPipeWorkType:\"k_ESt\
    eamPipeClientWorkType_InvalidR\x08workType\x12L\n\noperations\x18\x04\
    \x20\x03(\x0b2,.CClientMetrics_SteamPipeWorkStats_OperationR\noperations\
    \"\x8a\x02\n-CClientMetrics_ReportClientError_Notification\x12\x18\n\x07\
    product\x18\x01\x20\x01(\tR\x07product\x12\x18\n\x07version\x18\x02\x20\
    \x01(\tR\x07version\x12L\n\x06errors\x18\x03\x20\x03(\x0b24.CClientMetri\
    cs_ReportClientError_Notification.ErrorR\x06errors\x1aW\n\x05Error\x12\
    \x1e\n\nidentifier\x18\x01\x20\x01(\tR\nidentifier\x12\x18\n\x07message\
    \x18\x02\x20\x01(\tR\x07message\x12\x14\n\x05count\x18\x03\x20\x01(\rR\
    \x05count\"p\n+CClientMetrics_ClientBootstrap_Notification\x12A\n\x07sum\
    mary\x18\x01\x20\x01(\x0b2'.CClientMetrics_ClientBootstrap_SummaryR\x07s\
    ummary*q\n\x12ESteamPipeWorkType\x12&\n\"k_ESteamPipeClientWorkType_Inva\
    lid\x10\0\x123\n/k_ESteamPipeClientWorkType_StageFromChunkStores\x10\x01\
    *\xbb\x01\n\x17ESteamPipeOperationType\x12%\n!k_ESteamPipeOperationType_\
    Invalid\x10\0\x12(\n$k_ESteamPipeOperationType_DecryptCPU\x10\x01\x12&\n\
    \"k_ESteamPipeOperationType_DiskRead\x10\x02\x12'\n#k_ESteamPipeOperatio\
    nType_DiskWrite\x10\x032\xf4\x03\n\rClientMetrics\x12\\\n\x1dClientAppIn\
    terfaceStatsReport\x12..CClientMetrics_AppInterfaceStats_Notification\
    \x1a\x0b.NoResponse\x12Z\n\x1cClientIPv6ConnectivityReport\x12-.CClientM\
    etrics_IPv6Connectivity_Notification\x1a\x0b.NoResponse\x12X\n\x18SteamP\
    ipeWorkStatsReport\x12/.CClientMetrics_SteamPipeWorkStats_Notification\
    \x1a\x0b.NoResponse\x12P\n\x11ReportClientError\x12..CClientMetrics_Repo\
    rtClientError_Notification\x1a\x0b.NoResponse\x12R\n\x15ClientBootstrapR\
    eport\x12,.CClientMetrics_ClientBootstrap_Notification\x1a\x0b.NoRespons\
    e\x1a)\x82\xb5\x18%A\x20service\x20for\x20client-reported\x20metricsB\
    \x03\x80\x01\x01J\x89\x19\n\x06\x12\x04\0\0W\x01\n\t\n\x02\x03\0\x12\x03\
    \0\06\n\t\n\x02\x03\x01\x12\x03\x01\0\x1d\n\x08\n\x01\x08\x12\x03\x03\0\
    \"\n\t\n\x02\x08\x10\x12\x03\x03\0\"\n\n\n\x02\x05\0\x12\x04\x05\0\x08\
    \x01\n\n\n\x03\x05\0\x01\x12\x03\x05\x05\x17\n\x0b\n\x04\x05\0\x02\0\x12\
    \x03\x06\x08/\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\x06\x08*\n\x0c\n\x05\
    \x05\0\x02\0\x02\x12\x03\x06-.\n\x0b\n\x04\x05\0\x02\x01\x12\x03\x07\x08\
    <\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03\x07\x087\n\x0c\n\x05\x05\0\x02\
    \x01\x02\x12\x03\x07:;\n\n\n\x02\x05\x01\x12\x04\n\0\x0f\x01\n\n\n\x03\
    \x05\x01\x01\x12\x03\n\x05\x1c\n\x0b\n\x04\x05\x01\x02\0\x12\x03\x0b\x08\
    .\n\x0c\n\x05\x05\x01\x02\0\x01\x12\x03\x0b\x08)\n\x0c\n\x05\x05\x01\x02\
    \0\x02\x12\x03\x0b,-\n\x0b\n\x04\x05\x01\x02\x01\x12\x03\x0c\x081\n\x0c\
    \n\x05\x05\x01\x02\x01\x01\x12\x03\x0c\x08,\n\x0c\n\x05\x05\x01\x02\x01\
    \x02\x12\x03\x0c/0\n\x0b\n\x04\x05\x01\x02\x02\x12\x03\r\x08/\n\x0c\n\
    \x05\x05\x01\x02\x02\x01\x12\x03\r\x08*\n\x0c\n\x05\x05\x01\x02\x02\x02\
    \x12\x03\r-.\n\x0b\n\x04\x05\x01\x02\x03\x12\x03\x0e\x080\n\x0c\n\x05\
    \x05\x01\x02\x03\x01\x12\x03\x0e\x08+\n\x0c\n\x05\x05\x01\x02\x03\x02\
    \x12\x03\x0e./\n\n\n\x02\x04\0\x12\x04\x11\0\x14\x01\n\n\n\x03\x04\0\x01\
    \x12\x03\x11\x08+\n\x0b\n\x04\x04\0\x02\0\x12\x03\x12\x08(\n\x0c\n\x05\
    \x04\0\x02\0\x04\x12\x03\x12\x08\x10\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\
    \x12\x11\x17\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x12\x18#\n\x0c\n\x05\
    \x04\0\x02\0\x03\x12\x03\x12&'\n\x0b\n\x04\x04\0\x02\x01\x12\x03\x13\x08\
    5\n\x0c\n\x05\x04\0\x02\x01\x04\x12\x03\x13\x08\x10\n\x0c\n\x05\x04\0\
    \x02\x01\x05\x12\x03\x13\x11\x17\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\
    \x13\x180\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x1334\n\n\n\x02\x04\x01\
    \x12\x04\x16\0\x1a\x01\n\n\n\x03\x04\x01\x01\x12\x03\x16\x08/\n\x0b\n\
    \x04\x04\x01\x02\0\x12\x03\x17\x08+\n\x0c\n\x05\x04\x01\x02\0\x04\x12\
    \x03\x17\x08\x10\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03\x17\x11\x17\n\x0c\
    \n\x05\x04\x01\x02\0\x01\x12\x03\x17\x18&\n\x0c\n\x05\x04\x01\x02\0\x03\
    \x12\x03\x17)*\n\x0b\n\x04\x04\x01\x02\x01\x12\x03\x18\x08(\n\x0c\n\x05\
    \x04\x01\x02\x01\x04\x12\x03\x18\x08\x10\n\x0c\n\x05\x04\x01\x02\x01\x05\
    \x12\x03\x18\x11\x17\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\x18\x18#\n\
    \x0c\n\x05\x04\x01\x02\x01\x03\x12\x03\x18&'\n\x0b\n\x04\x04\x01\x02\x02\
    \x12\x03\x19\x08'\n\x0c\n\x05\x04\x01\x02\x02\x04\x12\x03\x19\x08\x10\n\
    \x0c\n\x05\x04\x01\x02\x02\x05\x12\x03\x19\x11\x17\n\x0c\n\x05\x04\x01\
    \x02\x02\x01\x12\x03\x19\x18\"\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03\
    \x19%&\n\n\n\x02\x04\x02\x12\x04\x1c\0!\x01\n\n\n\x03\x04\x02\x01\x12\
    \x03\x1c\x085\n\x0b\n\x04\x04\x02\x02\0\x12\x03\x1d\x08$\n\x0c\n\x05\x04\
    \x02\x02\0\x04\x12\x03\x1d\x08\x10\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03\
    \x1d\x11\x17\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03\x1d\x18\x1f\n\x0c\n\
    \x05\x04\x02\x02\0\x03\x12\x03\x1d\"#\n\x0b\n\x04\x04\x02\x02\x01\x12\
    \x03\x1e\x08M\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03\x1e\x08\x10\n\x0c\
    \n\x05\x04\x02\x02\x01\x06\x12\x03\x1e\x115\n\x0c\n\x05\x04\x02\x02\x01\
    \x01\x12\x03\x1e6H\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03\x1eKL\n\x0b\n\
    \x04\x04\x02\x02\x02\x12\x03\x1f\x08M\n\x0c\n\x05\x04\x02\x02\x02\x04\
    \x12\x03\x1f\x08\x10\n\x0c\n\x05\x04\x02\x02\x02\x06\x12\x03\x1f\x119\n\
    \x0c\n\x05\x04\x02\x02\x02\x01\x12\x03\x1f:H\n\x0c\n\x05\x04\x02\x02\x02\
    \x03\x12\x03\x1fKL\n\x0b\n\x04\x04\x02\x02\x03\x12\x03\x20\x083\n\x0c\n\
    \x05\x04\x02\x02\x03\x04\x12\x03\x20\x08\x10\n\x0c\n\x05\x04\x02\x02\x03\
    \x05\x12\x03\x20\x11\x17\n\x0c\n\x05\x04\x02\x02\x03\x01\x12\x03\x20\x18\
    .\n\x0c\n\x05\x04\x02\x02\x03\x03\x12\x03\x2012\n\n\n\x02\x04\x03\x12\
    \x04#\0&\x01\n\n\n\x03\x04\x03\x01\x12\x03#\x08.\n\x0b\n\x04\x04\x03\x02\
    \0\x12\x03$\x08,\n\x0c\n\x05\x04\x03\x02\0\x04\x12\x03$\x08\x10\n\x0c\n\
    \x05\x04\x03\x02\0\x05\x12\x03$\x11\x17\n\x0c\n\x05\x04\x03\x02\0\x01\
    \x12\x03$\x18'\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03$*+\n\x0b\n\x04\x04\
    \x03\x02\x01\x12\x03%\x08/\n\x0c\n\x05\x04\x03\x02\x01\x04\x12\x03%\x08\
    \x10\n\x0c\n\x05\x04\x03\x02\x01\x05\x12\x03%\x11\x17\n\x0c\n\x05\x04\
    \x03\x02\x01\x01\x12\x03%\x18*\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03%-\
    .\n\n\n\x02\x04\x04\x12\x04(\0,\x01\n\n\n\x03\x04\x04\x01\x12\x03(\x084\
    \n\x0b\n\x04\x04\x04\x02\0\x12\x03)\x08$\n\x0c\n\x05\x04\x04\x02\0\x04\
    \x12\x03)\x08\x10\n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03)\x11\x17\n\x0c\n\
    \x05\x04\x04\x02\0\x01\x12\x03)\x18\x1f\n\x0c\n\x05\x04\x04\x02\0\x03\
    \x12\x03)\"#\n\x0b\n\x04\x04\x04\x02\x01\x12\x03*\x08E\n\x0c\n\x05\x04\
    \x04\x02\x01\x04\x12\x03*\x08\x10\n\x0c\n\x05\x04\x04\x02\x01\x06\x12\
    \x03*\x118\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03*9@\n\x0c\n\x05\x04\
    \x04\x02\x01\x03\x12\x03*CD\n\x0b\n\x04\x04\x04\x02\x02\x12\x03+\x080\n\
    \x0c\n\x05\x04\x04\x02\x02\x04\x12\x03+\x08\x10\n\x0c\n\x05\x04\x04\x02\
    \x02\x05\x12\x03+\x11\x15\n\x0c\n\x05\x04\x04\x02\x02\x01\x12\x03+\x16+\
    \n\x0c\n\x05\x04\x04\x02\x02\x03\x12\x03+./\n\n\n\x02\x04\x05\x12\x04.\0\
    6\x01\n\n\n\x03\x04\x05\x01\x12\x03.\x083\n\x0b\n\x04\x04\x05\x02\0\x12\
    \x03/\x08a\n\x0c\n\x05\x04\x05\x02\0\x04\x12\x03/\x08\x10\n\x0c\n\x05\
    \x04\x05\x02\0\x06\x12\x03/\x11)\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03/*\
    .\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03/12\n\x0c\n\x05\x04\x05\x02\0\x08\
    \x12\x03/3`\n\x0c\n\x05\x04\x05\x02\0\x07\x12\x03/>_\n\x0b\n\x04\x04\x05\
    \x02\x01\x12\x030\x08$\n\x0c\n\x05\x04\x05\x02\x01\x04\x12\x030\x08\x10\
    \n\x0c\n\x05\x04\x05\x02\x01\x05\x12\x030\x11\x17\n\x0c\n\x05\x04\x05\
    \x02\x01\x01\x12\x030\x18\x1f\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x030\"\
    #\n\x0b\n\x04\x04\x05\x02\x02\x12\x031\x08&\n\x0c\n\x05\x04\x05\x02\x02\
    \x04\x12\x031\x08\x10\n\x0c\n\x05\x04\x05\x02\x02\x05\x12\x031\x11\x17\n\
    \x0c\n\x05\x04\x05\x02\x02\x01\x12\x031\x18!\n\x0c\n\x05\x04\x05\x02\x02\
    \x03\x12\x031$%\n\x0b\n\x04\x04\x05\x02\x03\x12\x032\x08)\n\x0c\n\x05\
    \x04\x05\x02\x03\x04\x12\x032\x08\x10\n\x0c\n\x05\x04\x05\x02\x03\x05\
    \x12\x032\x11\x17\n\x0c\n\x05\x04\x05\x02\x03\x01\x12\x032\x18$\n\x0c\n\
    \x05\x04\x05\x02\x03\x03\x12\x032'(\n\x0b\n\x04\x04\x05\x02\x04\x12\x033\
    \x08)\n\x0c\n\x05\x04\x05\x02\x04\x04\x12\x033\x08\x10\n\x0c\n\x05\x04\
    \x05\x02\x04\x05\x12\x033\x11\x17\n\x0c\n\x05\x04\x05\x02\x04\x01\x12\
    \x033\x18$\n\x0c\n\x05\x04\x05\x02\x04\x03\x12\x033'(\n\x0b\n\x04\x04\
    \x05\x02\x05\x12\x034\x08,\n\x0c\n\x05\x04\x05\x02\x05\x04\x12\x034\x08\
    \x10\n\x0c\n\x05\x04\x05\x02\x05\x05\x12\x034\x11\x17\n\x0c\n\x05\x04\
    \x05\x02\x05\x01\x12\x034\x18'\n\x0c\n\x05\x04\x05\x02\x05\x03\x12\x034*\
    +\n\x0b\n\x04\x04\x05\x02\x06\x12\x035\x08-\n\x0c\n\x05\x04\x05\x02\x06\
    \x04\x12\x035\x08\x10\n\x0c\n\x05\x04\x05\x02\x06\x05\x12\x035\x11\x17\n\
    \x0c\n\x05\x04\x05\x02\x06\x01\x12\x035\x18(\n\x0c\n\x05\x04\x05\x02\x06\
    \x03\x12\x035+,\n\n\n\x02\x04\x06\x12\x048\0=\x01\n\n\n\x03\x04\x06\x01\
    \x12\x038\x086\n\x0b\n\x04\x04\x06\x02\0\x12\x039\x08\"\n\x0c\n\x05\x04\
    \x06\x02\0\x04\x12\x039\x08\x10\n\x0c\n\x05\x04\x06\x02\0\x05\x12\x039\
    \x11\x17\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x039\x18\x1d\n\x0c\n\x05\x04\
    \x06\x02\0\x03\x12\x039\x20!\n\x0b\n\x04\x04\x06\x02\x01\x12\x03:\x08$\n\
    \x0c\n\x05\x04\x06\x02\x01\x04\x12\x03:\x08\x10\n\x0c\n\x05\x04\x06\x02\
    \x01\x05\x12\x03:\x11\x17\n\x0c\n\x05\x04\x06\x02\x01\x01\x12\x03:\x18\
    \x1f\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03:\"#\n\x0b\n\x04\x04\x06\x02\
    \x02\x12\x03;\x08b\n\x0c\n\x05\x04\x06\x02\x02\x04\x12\x03;\x08\x10\n\
    \x0c\n\x05\x04\x06\x02\x02\x06\x12\x03;\x11$\n\x0c\n\x05\x04\x06\x02\x02\
    \x01\x12\x03;%.\n\x0c\n\x05\x04\x06\x02\x02\x03\x12\x03;12\n\x0c\n\x05\
    \x04\x06\x02\x02\x08\x12\x03;3a\n\x0c\n\x05\x04\x06\x02\x02\x07\x12\x03;\
    >`\n\x0b\n\x04\x04\x06\x02\x03\x12\x03<\x08M\n\x0c\n\x05\x04\x06\x02\x03\
    \x04\x12\x03<\x08\x10\n\x0c\n\x05\x04\x06\x02\x03\x06\x12\x03<\x11=\n\
    \x0c\n\x05\x04\x06\x02\x03\x01\x12\x03<>H\n\x0c\n\x05\x04\x06\x02\x03\
    \x03\x12\x03<KL\n\n\n\x02\x04\x07\x12\x04?\0I\x01\n\n\n\x03\x04\x07\x01\
    \x12\x03?\x085\n\x0c\n\x04\x04\x07\x03\0\x12\x04@\x08D\t\n\x0c\n\x05\x04\
    \x07\x03\0\x01\x12\x03@\x10\x15\n\r\n\x06\x04\x07\x03\0\x02\0\x12\x03A\
    \x10/\n\x0e\n\x07\x04\x07\x03\0\x02\0\x04\x12\x03A\x10\x18\n\x0e\n\x07\
    \x04\x07\x03\0\x02\0\x05\x12\x03A\x19\x1f\n\x0e\n\x07\x04\x07\x03\0\x02\
    \0\x01\x12\x03A\x20*\n\x0e\n\x07\x04\x07\x03\0\x02\0\x03\x12\x03A-.\n\r\
    \n\x06\x04\x07\x03\0\x02\x01\x12\x03B\x10,\n\x0e\n\x07\x04\x07\x03\0\x02\
    \x01\x04\x12\x03B\x10\x18\n\x0e\n\x07\x04\x07\x03\0\x02\x01\x05\x12\x03B\
    \x19\x1f\n\x0e\n\x07\x04\x07\x03\0\x02\x01\x01\x12\x03B\x20'\n\x0e\n\x07\
    \x04\x07\x03\0\x02\x01\x03\x12\x03B*+\n\r\n\x06\x04\x07\x03\0\x02\x02\
    \x12\x03C\x10*\n\x0e\n\x07\x04\x07\x03\0\x02\x02\x04\x12\x03C\x10\x18\n\
    \x0e\n\x07\x04\x07\x03\0\x02\x02\x05\x12\x03C\x19\x1f\n\x0e\n\x07\x04\
    \x07\x03\0\x02\x02\x01\x12\x03C\x20%\n\x0e\n\x07\x04\x07\x03\0\x02\x02\
    \x03\x12\x03C()\n\x0b\n\x04\x04\x07\x02\0\x12\x03F\x08$\n\x0c\n\x05\x04\
    \x07\x02\0\x04\x12\x03F\x08\x10\n\x0c\n\x05\x04\x07\x02\0\x05\x12\x03F\
    \x11\x17\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03F\x18\x1f\n\x0c\n\x05\x04\
    \x07\x02\0\x03\x12\x03F\"#\n\x0b\n\x04\x04\x07\x02\x01\x12\x03G\x08$\n\
    \x0c\n\x05\x04\x07\x02\x01\x04\x12\x03G\x08\x10\n\x0c\n\x05\x04\x07\x02\
    \x01\x05\x12\x03G\x11\x17\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\x03G\x18\
    \x1f\n\x0c\n\x05\x04\x07\x02\x01\x03\x12\x03G\"#\n\x0b\n\x04\x04\x07\x02\
    \x02\x12\x03H\x08Q\n\x0c\n\x05\x04\x07\x02\x02\x04\x12\x03H\x08\x10\n\
    \x0c\n\x05\x04\x07\x02\x02\x06\x12\x03H\x11E\n\x0c\n\x05\x04\x07\x02\x02\
    \x01\x12\x03HFL\n\x0c\n\x05\x04\x07\x02\x02\x03\x12\x03HOP\n\n\n\x02\x04\
    \x08\x12\x04K\0M\x01\n\n\n\x03\x04\x08\x01\x12\x03K\x083\n\x0b\n\x04\x04\
    \x08\x02\0\x12\x03L\x08E\n\x0c\n\x05\x04\x08\x02\0\x04\x12\x03L\x08\x10\
    \n\x0c\n\x05\x04\x08\x02\0\x06\x12\x03L\x118\n\x0c\n\x05\x04\x08\x02\0\
    \x01\x12\x03L9@\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03LCD\n\n\n\x02\x06\0\
    \x12\x04O\0W\x01\n\n\n\x03\x06\0\x01\x12\x03O\x08\x15\n\n\n\x03\x06\0\
    \x03\x12\x03P\x08O\n\r\n\x06\x06\0\x03\xd0\x86\x03\x12\x03P\x08O\n\x0b\n\
    \x04\x06\0\x02\0\x12\x03R\x08q\n\x0c\n\x05\x06\0\x02\0\x01\x12\x03R\x0c)\
    \n\x0c\n\x05\x06\0\x02\0\x02\x12\x03R+Y\n\x0c\n\x05\x06\0\x02\0\x03\x12\
    \x03Rdo\n\x0b\n\x04\x06\0\x02\x01\x12\x03S\x08o\n\x0c\n\x05\x06\0\x02\
    \x01\x01\x12\x03S\x0c(\n\x0c\n\x05\x06\0\x02\x01\x02\x12\x03S*W\n\x0c\n\
    \x05\x06\0\x02\x01\x03\x12\x03Sbm\n\x0b\n\x04\x06\0\x02\x02\x12\x03T\x08\
    m\n\x0c\n\x05\x06\0\x02\x02\x01\x12\x03T\x0c$\n\x0c\n\x05\x06\0\x02\x02\
    \x02\x12\x03T&U\n\x0c\n\x05\x06\0\x02\x02\x03\x12\x03T`k\n\x0b\n\x04\x06\
    \0\x02\x03\x12\x03U\x08e\n\x0c\n\x05\x06\0\x02\x03\x01\x12\x03U\x0c\x1d\
    \n\x0c\n\x05\x06\0\x02\x03\x02\x12\x03U\x1fM\n\x0c\n\x05\x06\0\x02\x03\
    \x03\x12\x03UXc\n\x0b\n\x04\x06\0\x02\x04\x12\x03V\x08g\n\x0c\n\x05\x06\
    \0\x02\x04\x01\x12\x03V\x0c!\n\x0c\n\x05\x06\0\x02\x04\x02\x12\x03V#O\n\
    \x0c\n\x05\x06\0\x02\x04\x03\x12\x03VZe\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(super::steammessages_unified_base_steamclient::file_descriptor().clone());
            deps.push(super::clientmetrics::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(10);
            messages.push(CClientMetrics_AppInterfaceCreation::generated_message_descriptor_data());
            messages.push(CClientMetrics_AppInterfaceMethodCounts::generated_message_descriptor_data());
            messages.push(CClientMetrics_AppInterfaceStats_Notification::generated_message_descriptor_data());
            messages.push(CClientMetrics_IPv6Connectivity_Result::generated_message_descriptor_data());
            messages.push(CClientMetrics_IPv6Connectivity_Notification::generated_message_descriptor_data());
            messages.push(CClientMetrics_SteamPipeWorkStats_Operation::generated_message_descriptor_data());
            messages.push(CClientMetrics_SteamPipeWorkStats_Notification::generated_message_descriptor_data());
            messages.push(CClientMetrics_ReportClientError_Notification::generated_message_descriptor_data());
            messages.push(CClientMetrics_ClientBootstrap_Notification::generated_message_descriptor_data());
            messages.push(cclient_metrics_report_client_error_notification::Error::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(ESteamPipeWorkType::generated_enum_descriptor_data());
            enums.push(ESteamPipeOperationType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
