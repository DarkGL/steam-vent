// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_chat.steamclient.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:CChat_RequestFriendPersonaStates_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChat_RequestFriendPersonaStates_Request {
    // special fields
    // @@protoc_insertion_point(special_field:CChat_RequestFriendPersonaStates_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChat_RequestFriendPersonaStates_Request {
    fn default() -> &'a CChat_RequestFriendPersonaStates_Request {
        <CChat_RequestFriendPersonaStates_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChat_RequestFriendPersonaStates_Request {
    pub fn new() -> CChat_RequestFriendPersonaStates_Request {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChat_RequestFriendPersonaStates_Request>(
            "CChat_RequestFriendPersonaStates_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChat_RequestFriendPersonaStates_Request {
    const NAME: &'static str = "CChat_RequestFriendPersonaStates_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChat_RequestFriendPersonaStates_Request {
        CChat_RequestFriendPersonaStates_Request::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChat_RequestFriendPersonaStates_Request {
        static instance: CChat_RequestFriendPersonaStates_Request = CChat_RequestFriendPersonaStates_Request {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChat_RequestFriendPersonaStates_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChat_RequestFriendPersonaStates_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChat_RequestFriendPersonaStates_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChat_RequestFriendPersonaStates_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChat_RequestFriendPersonaStates_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChat_RequestFriendPersonaStates_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChat_RequestFriendPersonaStates_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChat_RequestFriendPersonaStates_Response {
    fn default() -> &'a CChat_RequestFriendPersonaStates_Response {
        <CChat_RequestFriendPersonaStates_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChat_RequestFriendPersonaStates_Response {
    pub fn new() -> CChat_RequestFriendPersonaStates_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChat_RequestFriendPersonaStates_Response>(
            "CChat_RequestFriendPersonaStates_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChat_RequestFriendPersonaStates_Response {
    const NAME: &'static str = "CChat_RequestFriendPersonaStates_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChat_RequestFriendPersonaStates_Response {
        CChat_RequestFriendPersonaStates_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChat_RequestFriendPersonaStates_Response {
        static instance: CChat_RequestFriendPersonaStates_Response = CChat_RequestFriendPersonaStates_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChat_RequestFriendPersonaStates_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChat_RequestFriendPersonaStates_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChat_RequestFriendPersonaStates_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChat_RequestFriendPersonaStates_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_CreateChatRoomGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_CreateChatRoomGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_CreateChatRoomGroup_Request.steamid_partner)
    pub steamid_partner: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_CreateChatRoomGroup_Request.steamid_invited)
    pub steamid_invited: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_CreateChatRoomGroup_Request.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_CreateChatRoomGroup_Request.steamid_invitees)
    pub steamid_invitees: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CChatRoom_CreateChatRoomGroup_Request.watching_broadcast_accountid)
    pub watching_broadcast_accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_CreateChatRoomGroup_Request.watching_broadcast_channel_id)
    pub watching_broadcast_channel_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_CreateChatRoomGroup_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_CreateChatRoomGroup_Request {
    fn default() -> &'a CChatRoom_CreateChatRoomGroup_Request {
        <CChatRoom_CreateChatRoomGroup_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_CreateChatRoomGroup_Request {
    pub fn new() -> CChatRoom_CreateChatRoomGroup_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_partner = 1;

    pub fn steamid_partner(&self) -> u64 {
        self.steamid_partner.unwrap_or(0)
    }

    pub fn clear_steamid_partner(&mut self) {
        self.steamid_partner = ::std::option::Option::None;
    }

    pub fn has_steamid_partner(&self) -> bool {
        self.steamid_partner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_partner(&mut self, v: u64) {
        self.steamid_partner = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid_invited = 2;

    pub fn steamid_invited(&self) -> u64 {
        self.steamid_invited.unwrap_or(0)
    }

    pub fn clear_steamid_invited(&mut self) {
        self.steamid_invited = ::std::option::Option::None;
    }

    pub fn has_steamid_invited(&self) -> bool {
        self.steamid_invited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_invited(&mut self, v: u64) {
        self.steamid_invited = ::std::option::Option::Some(v);
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 watching_broadcast_accountid = 6;

    pub fn watching_broadcast_accountid(&self) -> u32 {
        self.watching_broadcast_accountid.unwrap_or(0)
    }

    pub fn clear_watching_broadcast_accountid(&mut self) {
        self.watching_broadcast_accountid = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_accountid(&self) -> bool {
        self.watching_broadcast_accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_accountid(&mut self, v: u32) {
        self.watching_broadcast_accountid = ::std::option::Option::Some(v);
    }

    // optional uint64 watching_broadcast_channel_id = 7;

    pub fn watching_broadcast_channel_id(&self) -> u64 {
        self.watching_broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_watching_broadcast_channel_id(&mut self) {
        self.watching_broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_channel_id(&self) -> bool {
        self.watching_broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_channel_id(&mut self, v: u64) {
        self.watching_broadcast_channel_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid_partner",
            |m: &CChatRoom_CreateChatRoomGroup_Request| { &m.steamid_partner },
            |m: &mut CChatRoom_CreateChatRoomGroup_Request| { &mut m.steamid_partner },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid_invited",
            |m: &CChatRoom_CreateChatRoomGroup_Request| { &m.steamid_invited },
            |m: &mut CChatRoom_CreateChatRoomGroup_Request| { &mut m.steamid_invited },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CChatRoom_CreateChatRoomGroup_Request| { &m.name },
            |m: &mut CChatRoom_CreateChatRoomGroup_Request| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "steamid_invitees",
            |m: &CChatRoom_CreateChatRoomGroup_Request| { &m.steamid_invitees },
            |m: &mut CChatRoom_CreateChatRoomGroup_Request| { &mut m.steamid_invitees },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "watching_broadcast_accountid",
            |m: &CChatRoom_CreateChatRoomGroup_Request| { &m.watching_broadcast_accountid },
            |m: &mut CChatRoom_CreateChatRoomGroup_Request| { &mut m.watching_broadcast_accountid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "watching_broadcast_channel_id",
            |m: &CChatRoom_CreateChatRoomGroup_Request| { &m.watching_broadcast_channel_id },
            |m: &mut CChatRoom_CreateChatRoomGroup_Request| { &mut m.watching_broadcast_channel_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_CreateChatRoomGroup_Request>(
            "CChatRoom_CreateChatRoomGroup_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_CreateChatRoomGroup_Request {
    const NAME: &'static str = "CChatRoom_CreateChatRoomGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid_partner = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.steamid_invited = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    is.read_repeated_packed_fixed64_into(&mut self.steamid_invitees)?;
                },
                33 => {
                    self.steamid_invitees.push(is.read_fixed64()?);
                },
                48 => {
                    self.watching_broadcast_accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.watching_broadcast_channel_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_partner {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steamid_invited {
            my_size += 1 + 8;
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += 9 * self.steamid_invitees.len() as u64;
        if let Some(v) = self.watching_broadcast_accountid {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.watching_broadcast_channel_id {
            my_size += ::protobuf::rt::uint64_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid_partner {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.steamid_invited {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.steamid_invitees {
            os.write_fixed64(4, *v)?;
        };
        if let Some(v) = self.watching_broadcast_accountid {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.watching_broadcast_channel_id {
            os.write_uint64(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_CreateChatRoomGroup_Request {
        CChatRoom_CreateChatRoomGroup_Request::new()
    }

    fn clear(&mut self) {
        self.steamid_partner = ::std::option::Option::None;
        self.steamid_invited = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.steamid_invitees.clear();
        self.watching_broadcast_accountid = ::std::option::Option::None;
        self.watching_broadcast_channel_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_CreateChatRoomGroup_Request {
        static instance: CChatRoom_CreateChatRoomGroup_Request = CChatRoom_CreateChatRoomGroup_Request {
            steamid_partner: ::std::option::Option::None,
            steamid_invited: ::std::option::Option::None,
            name: ::std::option::Option::None,
            steamid_invitees: ::std::vec::Vec::new(),
            watching_broadcast_accountid: ::std::option::Option::None,
            watching_broadcast_channel_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_CreateChatRoomGroup_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_CreateChatRoomGroup_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_CreateChatRoomGroup_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_CreateChatRoomGroup_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRole)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRole {
    // message fields
    // @@protoc_insertion_point(field:CChatRole.role_id)
    pub role_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRole.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRole.ordinal)
    pub ordinal: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRole.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRole {
    fn default() -> &'a CChatRole {
        <CChatRole as ::protobuf::Message>::default_instance()
    }
}

impl CChatRole {
    pub fn new() -> CChatRole {
        ::std::default::Default::default()
    }

    // optional uint64 role_id = 1;

    pub fn role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }

    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 ordinal = 3;

    pub fn ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }

    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "role_id",
            |m: &CChatRole| { &m.role_id },
            |m: &mut CChatRole| { &mut m.role_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CChatRole| { &m.name },
            |m: &mut CChatRole| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ordinal",
            |m: &CChatRole| { &m.ordinal },
            |m: &mut CChatRole| { &mut m.ordinal },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRole>(
            "CChatRole",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRole {
    const NAME: &'static str = "CChatRole";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.role_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.ordinal = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.role_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.ordinal {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.role_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRole {
        CChatRole::new()
    }

    fn clear(&mut self) {
        self.role_id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.ordinal = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRole {
        static instance: CChatRole = CChatRole {
            role_id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            ordinal: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRole {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRole").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRole {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoleActions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoleActions {
    // message fields
    // @@protoc_insertion_point(field:CChatRoleActions.role_id)
    pub role_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoleActions.can_create_rename_delete_channel)
    pub can_create_rename_delete_channel: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatRoleActions.can_kick)
    pub can_kick: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatRoleActions.can_ban)
    pub can_ban: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatRoleActions.can_invite)
    pub can_invite: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatRoleActions.can_change_tagline_avatar_name)
    pub can_change_tagline_avatar_name: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatRoleActions.can_chat)
    pub can_chat: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatRoleActions.can_view_history)
    pub can_view_history: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatRoleActions.can_change_group_roles)
    pub can_change_group_roles: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatRoleActions.can_change_user_roles)
    pub can_change_user_roles: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatRoleActions.can_mention_all)
    pub can_mention_all: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatRoleActions.can_set_watching_broadcast)
    pub can_set_watching_broadcast: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoleActions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoleActions {
    fn default() -> &'a CChatRoleActions {
        <CChatRoleActions as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoleActions {
    pub fn new() -> CChatRoleActions {
        ::std::default::Default::default()
    }

    // optional uint64 role_id = 1;

    pub fn role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }

    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }

    // optional bool can_create_rename_delete_channel = 2;

    pub fn can_create_rename_delete_channel(&self) -> bool {
        self.can_create_rename_delete_channel.unwrap_or(false)
    }

    pub fn clear_can_create_rename_delete_channel(&mut self) {
        self.can_create_rename_delete_channel = ::std::option::Option::None;
    }

    pub fn has_can_create_rename_delete_channel(&self) -> bool {
        self.can_create_rename_delete_channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_create_rename_delete_channel(&mut self, v: bool) {
        self.can_create_rename_delete_channel = ::std::option::Option::Some(v);
    }

    // optional bool can_kick = 3;

    pub fn can_kick(&self) -> bool {
        self.can_kick.unwrap_or(false)
    }

    pub fn clear_can_kick(&mut self) {
        self.can_kick = ::std::option::Option::None;
    }

    pub fn has_can_kick(&self) -> bool {
        self.can_kick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_kick(&mut self, v: bool) {
        self.can_kick = ::std::option::Option::Some(v);
    }

    // optional bool can_ban = 4;

    pub fn can_ban(&self) -> bool {
        self.can_ban.unwrap_or(false)
    }

    pub fn clear_can_ban(&mut self) {
        self.can_ban = ::std::option::Option::None;
    }

    pub fn has_can_ban(&self) -> bool {
        self.can_ban.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_ban(&mut self, v: bool) {
        self.can_ban = ::std::option::Option::Some(v);
    }

    // optional bool can_invite = 5;

    pub fn can_invite(&self) -> bool {
        self.can_invite.unwrap_or(false)
    }

    pub fn clear_can_invite(&mut self) {
        self.can_invite = ::std::option::Option::None;
    }

    pub fn has_can_invite(&self) -> bool {
        self.can_invite.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_invite(&mut self, v: bool) {
        self.can_invite = ::std::option::Option::Some(v);
    }

    // optional bool can_change_tagline_avatar_name = 6;

    pub fn can_change_tagline_avatar_name(&self) -> bool {
        self.can_change_tagline_avatar_name.unwrap_or(false)
    }

    pub fn clear_can_change_tagline_avatar_name(&mut self) {
        self.can_change_tagline_avatar_name = ::std::option::Option::None;
    }

    pub fn has_can_change_tagline_avatar_name(&self) -> bool {
        self.can_change_tagline_avatar_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_change_tagline_avatar_name(&mut self, v: bool) {
        self.can_change_tagline_avatar_name = ::std::option::Option::Some(v);
    }

    // optional bool can_chat = 7;

    pub fn can_chat(&self) -> bool {
        self.can_chat.unwrap_or(false)
    }

    pub fn clear_can_chat(&mut self) {
        self.can_chat = ::std::option::Option::None;
    }

    pub fn has_can_chat(&self) -> bool {
        self.can_chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_chat(&mut self, v: bool) {
        self.can_chat = ::std::option::Option::Some(v);
    }

    // optional bool can_view_history = 8;

    pub fn can_view_history(&self) -> bool {
        self.can_view_history.unwrap_or(false)
    }

    pub fn clear_can_view_history(&mut self) {
        self.can_view_history = ::std::option::Option::None;
    }

    pub fn has_can_view_history(&self) -> bool {
        self.can_view_history.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_view_history(&mut self, v: bool) {
        self.can_view_history = ::std::option::Option::Some(v);
    }

    // optional bool can_change_group_roles = 9;

    pub fn can_change_group_roles(&self) -> bool {
        self.can_change_group_roles.unwrap_or(false)
    }

    pub fn clear_can_change_group_roles(&mut self) {
        self.can_change_group_roles = ::std::option::Option::None;
    }

    pub fn has_can_change_group_roles(&self) -> bool {
        self.can_change_group_roles.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_change_group_roles(&mut self, v: bool) {
        self.can_change_group_roles = ::std::option::Option::Some(v);
    }

    // optional bool can_change_user_roles = 10;

    pub fn can_change_user_roles(&self) -> bool {
        self.can_change_user_roles.unwrap_or(false)
    }

    pub fn clear_can_change_user_roles(&mut self) {
        self.can_change_user_roles = ::std::option::Option::None;
    }

    pub fn has_can_change_user_roles(&self) -> bool {
        self.can_change_user_roles.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_change_user_roles(&mut self, v: bool) {
        self.can_change_user_roles = ::std::option::Option::Some(v);
    }

    // optional bool can_mention_all = 11;

    pub fn can_mention_all(&self) -> bool {
        self.can_mention_all.unwrap_or(false)
    }

    pub fn clear_can_mention_all(&mut self) {
        self.can_mention_all = ::std::option::Option::None;
    }

    pub fn has_can_mention_all(&self) -> bool {
        self.can_mention_all.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_mention_all(&mut self, v: bool) {
        self.can_mention_all = ::std::option::Option::Some(v);
    }

    // optional bool can_set_watching_broadcast = 12;

    pub fn can_set_watching_broadcast(&self) -> bool {
        self.can_set_watching_broadcast.unwrap_or(false)
    }

    pub fn clear_can_set_watching_broadcast(&mut self) {
        self.can_set_watching_broadcast = ::std::option::Option::None;
    }

    pub fn has_can_set_watching_broadcast(&self) -> bool {
        self.can_set_watching_broadcast.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_set_watching_broadcast(&mut self, v: bool) {
        self.can_set_watching_broadcast = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "role_id",
            |m: &CChatRoleActions| { &m.role_id },
            |m: &mut CChatRoleActions| { &mut m.role_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "can_create_rename_delete_channel",
            |m: &CChatRoleActions| { &m.can_create_rename_delete_channel },
            |m: &mut CChatRoleActions| { &mut m.can_create_rename_delete_channel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "can_kick",
            |m: &CChatRoleActions| { &m.can_kick },
            |m: &mut CChatRoleActions| { &mut m.can_kick },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "can_ban",
            |m: &CChatRoleActions| { &m.can_ban },
            |m: &mut CChatRoleActions| { &mut m.can_ban },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "can_invite",
            |m: &CChatRoleActions| { &m.can_invite },
            |m: &mut CChatRoleActions| { &mut m.can_invite },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "can_change_tagline_avatar_name",
            |m: &CChatRoleActions| { &m.can_change_tagline_avatar_name },
            |m: &mut CChatRoleActions| { &mut m.can_change_tagline_avatar_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "can_chat",
            |m: &CChatRoleActions| { &m.can_chat },
            |m: &mut CChatRoleActions| { &mut m.can_chat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "can_view_history",
            |m: &CChatRoleActions| { &m.can_view_history },
            |m: &mut CChatRoleActions| { &mut m.can_view_history },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "can_change_group_roles",
            |m: &CChatRoleActions| { &m.can_change_group_roles },
            |m: &mut CChatRoleActions| { &mut m.can_change_group_roles },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "can_change_user_roles",
            |m: &CChatRoleActions| { &m.can_change_user_roles },
            |m: &mut CChatRoleActions| { &mut m.can_change_user_roles },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "can_mention_all",
            |m: &CChatRoleActions| { &m.can_mention_all },
            |m: &mut CChatRoleActions| { &mut m.can_mention_all },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "can_set_watching_broadcast",
            |m: &CChatRoleActions| { &m.can_set_watching_broadcast },
            |m: &mut CChatRoleActions| { &mut m.can_set_watching_broadcast },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoleActions>(
            "CChatRoleActions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoleActions {
    const NAME: &'static str = "CChatRoleActions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.role_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.can_create_rename_delete_channel = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.can_kick = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.can_ban = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.can_invite = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.can_change_tagline_avatar_name = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.can_chat = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.can_view_history = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.can_change_group_roles = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.can_change_user_roles = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.can_mention_all = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.can_set_watching_broadcast = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.role_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.can_create_rename_delete_channel {
            my_size += 1 + 1;
        }
        if let Some(v) = self.can_kick {
            my_size += 1 + 1;
        }
        if let Some(v) = self.can_ban {
            my_size += 1 + 1;
        }
        if let Some(v) = self.can_invite {
            my_size += 1 + 1;
        }
        if let Some(v) = self.can_change_tagline_avatar_name {
            my_size += 1 + 1;
        }
        if let Some(v) = self.can_chat {
            my_size += 1 + 1;
        }
        if let Some(v) = self.can_view_history {
            my_size += 1 + 1;
        }
        if let Some(v) = self.can_change_group_roles {
            my_size += 1 + 1;
        }
        if let Some(v) = self.can_change_user_roles {
            my_size += 1 + 1;
        }
        if let Some(v) = self.can_mention_all {
            my_size += 1 + 1;
        }
        if let Some(v) = self.can_set_watching_broadcast {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.role_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.can_create_rename_delete_channel {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.can_kick {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.can_ban {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.can_invite {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.can_change_tagline_avatar_name {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.can_chat {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.can_view_history {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.can_change_group_roles {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.can_change_user_roles {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.can_mention_all {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.can_set_watching_broadcast {
            os.write_bool(12, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoleActions {
        CChatRoleActions::new()
    }

    fn clear(&mut self) {
        self.role_id = ::std::option::Option::None;
        self.can_create_rename_delete_channel = ::std::option::Option::None;
        self.can_kick = ::std::option::Option::None;
        self.can_ban = ::std::option::Option::None;
        self.can_invite = ::std::option::Option::None;
        self.can_change_tagline_avatar_name = ::std::option::Option::None;
        self.can_chat = ::std::option::Option::None;
        self.can_view_history = ::std::option::Option::None;
        self.can_change_group_roles = ::std::option::Option::None;
        self.can_change_user_roles = ::std::option::Option::None;
        self.can_mention_all = ::std::option::Option::None;
        self.can_set_watching_broadcast = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoleActions {
        static instance: CChatRoleActions = CChatRoleActions {
            role_id: ::std::option::Option::None,
            can_create_rename_delete_channel: ::std::option::Option::None,
            can_kick: ::std::option::Option::None,
            can_ban: ::std::option::Option::None,
            can_invite: ::std::option::Option::None,
            can_change_tagline_avatar_name: ::std::option::Option::None,
            can_chat: ::std::option::Option::None,
            can_view_history: ::std::option::Option::None,
            can_change_group_roles: ::std::option::Option::None,
            can_change_user_roles: ::std::option::Option::None,
            can_mention_all: ::std::option::Option::None,
            can_set_watching_broadcast: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoleActions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoleActions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoleActions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoleActions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatPartyBeacon)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatPartyBeacon {
    // message fields
    // @@protoc_insertion_point(field:CChatPartyBeacon.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatPartyBeacon.steamid_owner)
    pub steamid_owner: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatPartyBeacon.beacon_id)
    pub beacon_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatPartyBeacon.game_metadata)
    pub game_metadata: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatPartyBeacon.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatPartyBeacon {
    fn default() -> &'a CChatPartyBeacon {
        <CChatPartyBeacon as ::protobuf::Message>::default_instance()
    }
}

impl CChatPartyBeacon {
    pub fn new() -> CChatPartyBeacon {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid_owner = 2;

    pub fn steamid_owner(&self) -> u64 {
        self.steamid_owner.unwrap_or(0)
    }

    pub fn clear_steamid_owner(&mut self) {
        self.steamid_owner = ::std::option::Option::None;
    }

    pub fn has_steamid_owner(&self) -> bool {
        self.steamid_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_owner(&mut self, v: u64) {
        self.steamid_owner = ::std::option::Option::Some(v);
    }

    // optional fixed64 beacon_id = 3;

    pub fn beacon_id(&self) -> u64 {
        self.beacon_id.unwrap_or(0)
    }

    pub fn clear_beacon_id(&mut self) {
        self.beacon_id = ::std::option::Option::None;
    }

    pub fn has_beacon_id(&self) -> bool {
        self.beacon_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_beacon_id(&mut self, v: u64) {
        self.beacon_id = ::std::option::Option::Some(v);
    }

    // optional string game_metadata = 4;

    pub fn game_metadata(&self) -> &str {
        match self.game_metadata.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_metadata(&mut self) {
        self.game_metadata = ::std::option::Option::None;
    }

    pub fn has_game_metadata(&self) -> bool {
        self.game_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_metadata(&mut self, v: ::std::string::String) {
        self.game_metadata = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_metadata(&mut self) -> &mut ::std::string::String {
        if self.game_metadata.is_none() {
            self.game_metadata = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_metadata(&mut self) -> ::std::string::String {
        self.game_metadata.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CChatPartyBeacon| { &m.app_id },
            |m: &mut CChatPartyBeacon| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid_owner",
            |m: &CChatPartyBeacon| { &m.steamid_owner },
            |m: &mut CChatPartyBeacon| { &mut m.steamid_owner },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "beacon_id",
            |m: &CChatPartyBeacon| { &m.beacon_id },
            |m: &mut CChatPartyBeacon| { &mut m.beacon_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_metadata",
            |m: &CChatPartyBeacon| { &m.game_metadata },
            |m: &mut CChatPartyBeacon| { &mut m.game_metadata },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatPartyBeacon>(
            "CChatPartyBeacon",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatPartyBeacon {
    const NAME: &'static str = "CChatPartyBeacon";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steamid_owner = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.beacon_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                34 => {
                    self.game_metadata = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steamid_owner {
            my_size += 1 + 8;
        }
        if let Some(v) = self.beacon_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.game_metadata.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steamid_owner {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.beacon_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.game_metadata.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatPartyBeacon {
        CChatPartyBeacon::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steamid_owner = ::std::option::Option::None;
        self.beacon_id = ::std::option::Option::None;
        self.game_metadata = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatPartyBeacon {
        static instance: CChatPartyBeacon = CChatPartyBeacon {
            app_id: ::std::option::Option::None,
            steamid_owner: ::std::option::Option::None,
            beacon_id: ::std::option::Option::None,
            game_metadata: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatPartyBeacon {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatPartyBeacon").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatPartyBeacon {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatPartyBeacon {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoomGroupHeaderState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoomGroupHeaderState {
    // message fields
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.chat_name)
    pub chat_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.clanid)
    pub clanid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.accountid_owner)
    pub accountid_owner: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.tagline)
    pub tagline: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.avatar_sha)
    pub avatar_sha: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.default_role_id)
    pub default_role_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.roles)
    pub roles: ::std::vec::Vec<CChatRole>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.role_actions)
    pub role_actions: ::std::vec::Vec<CChatRoleActions>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.watching_broadcast_accountid)
    pub watching_broadcast_accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.party_beacons)
    pub party_beacons: ::std::vec::Vec<CChatPartyBeacon>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.watching_broadcast_channel_id)
    pub watching_broadcast_channel_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.active_minigame_id)
    pub active_minigame_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.avatar_ugc_url)
    pub avatar_ugc_url: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoomGroupHeaderState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoomGroupHeaderState {
    fn default() -> &'a CChatRoomGroupHeaderState {
        <CChatRoomGroupHeaderState as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoomGroupHeaderState {
    pub fn new() -> CChatRoomGroupHeaderState {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string chat_name = 2;

    pub fn chat_name(&self) -> &str {
        match self.chat_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_chat_name(&mut self) {
        self.chat_name = ::std::option::Option::None;
    }

    pub fn has_chat_name(&self) -> bool {
        self.chat_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_name(&mut self, v: ::std::string::String) {
        self.chat_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_name(&mut self) -> &mut ::std::string::String {
        if self.chat_name.is_none() {
            self.chat_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.chat_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_name(&mut self) -> ::std::string::String {
        self.chat_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 clanid = 13;

    pub fn clanid(&self) -> u32 {
        self.clanid.unwrap_or(0)
    }

    pub fn clear_clanid(&mut self) {
        self.clanid = ::std::option::Option::None;
    }

    pub fn has_clanid(&self) -> bool {
        self.clanid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clanid(&mut self, v: u32) {
        self.clanid = ::std::option::Option::Some(v);
    }

    // optional uint32 accountid_owner = 14;

    pub fn accountid_owner(&self) -> u32 {
        self.accountid_owner.unwrap_or(0)
    }

    pub fn clear_accountid_owner(&mut self) {
        self.accountid_owner = ::std::option::Option::None;
    }

    pub fn has_accountid_owner(&self) -> bool {
        self.accountid_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid_owner(&mut self, v: u32) {
        self.accountid_owner = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 21;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string tagline = 15;

    pub fn tagline(&self) -> &str {
        match self.tagline.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_tagline(&mut self) {
        self.tagline = ::std::option::Option::None;
    }

    pub fn has_tagline(&self) -> bool {
        self.tagline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tagline(&mut self, v: ::std::string::String) {
        self.tagline = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tagline(&mut self) -> &mut ::std::string::String {
        if self.tagline.is_none() {
            self.tagline = ::std::option::Option::Some(::std::string::String::new());
        }
        self.tagline.as_mut().unwrap()
    }

    // Take field
    pub fn take_tagline(&mut self) -> ::std::string::String {
        self.tagline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes avatar_sha = 16;

    pub fn avatar_sha(&self) -> &[u8] {
        match self.avatar_sha.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_avatar_sha(&mut self) {
        self.avatar_sha = ::std::option::Option::None;
    }

    pub fn has_avatar_sha(&self) -> bool {
        self.avatar_sha.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar_sha(&mut self, v: ::std::vec::Vec<u8>) {
        self.avatar_sha = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar_sha(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.avatar_sha.is_none() {
            self.avatar_sha = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.avatar_sha.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar_sha(&mut self) -> ::std::vec::Vec<u8> {
        self.avatar_sha.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 default_role_id = 17;

    pub fn default_role_id(&self) -> u64 {
        self.default_role_id.unwrap_or(0)
    }

    pub fn clear_default_role_id(&mut self) {
        self.default_role_id = ::std::option::Option::None;
    }

    pub fn has_default_role_id(&self) -> bool {
        self.default_role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_role_id(&mut self, v: u64) {
        self.default_role_id = ::std::option::Option::Some(v);
    }

    // optional uint32 watching_broadcast_accountid = 20;

    pub fn watching_broadcast_accountid(&self) -> u32 {
        self.watching_broadcast_accountid.unwrap_or(0)
    }

    pub fn clear_watching_broadcast_accountid(&mut self) {
        self.watching_broadcast_accountid = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_accountid(&self) -> bool {
        self.watching_broadcast_accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_accountid(&mut self, v: u32) {
        self.watching_broadcast_accountid = ::std::option::Option::Some(v);
    }

    // optional uint64 watching_broadcast_channel_id = 23;

    pub fn watching_broadcast_channel_id(&self) -> u64 {
        self.watching_broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_watching_broadcast_channel_id(&mut self) {
        self.watching_broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_channel_id(&self) -> bool {
        self.watching_broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_channel_id(&mut self, v: u64) {
        self.watching_broadcast_channel_id = ::std::option::Option::Some(v);
    }

    // optional uint64 active_minigame_id = 24;

    pub fn active_minigame_id(&self) -> u64 {
        self.active_minigame_id.unwrap_or(0)
    }

    pub fn clear_active_minigame_id(&mut self) {
        self.active_minigame_id = ::std::option::Option::None;
    }

    pub fn has_active_minigame_id(&self) -> bool {
        self.active_minigame_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_minigame_id(&mut self, v: u64) {
        self.active_minigame_id = ::std::option::Option::Some(v);
    }

    // optional string avatar_ugc_url = 25;

    pub fn avatar_ugc_url(&self) -> &str {
        match self.avatar_ugc_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_avatar_ugc_url(&mut self) {
        self.avatar_ugc_url = ::std::option::Option::None;
    }

    pub fn has_avatar_ugc_url(&self) -> bool {
        self.avatar_ugc_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar_ugc_url(&mut self, v: ::std::string::String) {
        self.avatar_ugc_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar_ugc_url(&mut self) -> &mut ::std::string::String {
        if self.avatar_ugc_url.is_none() {
            self.avatar_ugc_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.avatar_ugc_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar_ugc_url(&mut self) -> ::std::string::String {
        self.avatar_ugc_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(15);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoomGroupHeaderState| { &m.chat_group_id },
            |m: &mut CChatRoomGroupHeaderState| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_name",
            |m: &CChatRoomGroupHeaderState| { &m.chat_name },
            |m: &mut CChatRoomGroupHeaderState| { &mut m.chat_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "clanid",
            |m: &CChatRoomGroupHeaderState| { &m.clanid },
            |m: &mut CChatRoomGroupHeaderState| { &mut m.clanid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid_owner",
            |m: &CChatRoomGroupHeaderState| { &m.accountid_owner },
            |m: &mut CChatRoomGroupHeaderState| { &mut m.accountid_owner },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CChatRoomGroupHeaderState| { &m.appid },
            |m: &mut CChatRoomGroupHeaderState| { &mut m.appid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tagline",
            |m: &CChatRoomGroupHeaderState| { &m.tagline },
            |m: &mut CChatRoomGroupHeaderState| { &mut m.tagline },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "avatar_sha",
            |m: &CChatRoomGroupHeaderState| { &m.avatar_sha },
            |m: &mut CChatRoomGroupHeaderState| { &mut m.avatar_sha },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "default_role_id",
            |m: &CChatRoomGroupHeaderState| { &m.default_role_id },
            |m: &mut CChatRoomGroupHeaderState| { &mut m.default_role_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "roles",
            |m: &CChatRoomGroupHeaderState| { &m.roles },
            |m: &mut CChatRoomGroupHeaderState| { &mut m.roles },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "role_actions",
            |m: &CChatRoomGroupHeaderState| { &m.role_actions },
            |m: &mut CChatRoomGroupHeaderState| { &mut m.role_actions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "watching_broadcast_accountid",
            |m: &CChatRoomGroupHeaderState| { &m.watching_broadcast_accountid },
            |m: &mut CChatRoomGroupHeaderState| { &mut m.watching_broadcast_accountid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "party_beacons",
            |m: &CChatRoomGroupHeaderState| { &m.party_beacons },
            |m: &mut CChatRoomGroupHeaderState| { &mut m.party_beacons },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "watching_broadcast_channel_id",
            |m: &CChatRoomGroupHeaderState| { &m.watching_broadcast_channel_id },
            |m: &mut CChatRoomGroupHeaderState| { &mut m.watching_broadcast_channel_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "active_minigame_id",
            |m: &CChatRoomGroupHeaderState| { &m.active_minigame_id },
            |m: &mut CChatRoomGroupHeaderState| { &mut m.active_minigame_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "avatar_ugc_url",
            |m: &CChatRoomGroupHeaderState| { &m.avatar_ugc_url },
            |m: &mut CChatRoomGroupHeaderState| { &mut m.avatar_ugc_url },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoomGroupHeaderState>(
            "CChatRoomGroupHeaderState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoomGroupHeaderState {
    const NAME: &'static str = "CChatRoomGroupHeaderState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.chat_name = ::std::option::Option::Some(is.read_string()?);
                },
                104 => {
                    self.clanid = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.accountid_owner = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                122 => {
                    self.tagline = ::std::option::Option::Some(is.read_string()?);
                },
                130 => {
                    self.avatar_sha = ::std::option::Option::Some(is.read_bytes()?);
                },
                136 => {
                    self.default_role_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                146 => {
                    self.roles.push(is.read_message()?);
                },
                154 => {
                    self.role_actions.push(is.read_message()?);
                },
                160 => {
                    self.watching_broadcast_accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                178 => {
                    self.party_beacons.push(is.read_message()?);
                },
                184 => {
                    self.watching_broadcast_channel_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                192 => {
                    self.active_minigame_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                202 => {
                    self.avatar_ugc_url = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.clanid {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.accountid_owner {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.tagline.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.avatar_sha.as_ref() {
            my_size += ::protobuf::rt::bytes_size(16, &v);
        }
        if let Some(v) = self.default_role_id {
            my_size += ::protobuf::rt::uint64_size(17, v);
        }
        for value in &self.roles {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.role_actions {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.watching_broadcast_accountid {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        for value in &self.party_beacons {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.watching_broadcast_channel_id {
            my_size += ::protobuf::rt::uint64_size(23, v);
        }
        if let Some(v) = self.active_minigame_id {
            my_size += ::protobuf::rt::uint64_size(24, v);
        }
        if let Some(v) = self.avatar_ugc_url.as_ref() {
            my_size += ::protobuf::rt::string_size(25, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.clanid {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.accountid_owner {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.tagline.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.avatar_sha.as_ref() {
            os.write_bytes(16, v)?;
        }
        if let Some(v) = self.default_role_id {
            os.write_uint64(17, v)?;
        }
        for v in &self.roles {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        };
        for v in &self.role_actions {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        };
        if let Some(v) = self.watching_broadcast_accountid {
            os.write_uint32(20, v)?;
        }
        for v in &self.party_beacons {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        };
        if let Some(v) = self.watching_broadcast_channel_id {
            os.write_uint64(23, v)?;
        }
        if let Some(v) = self.active_minigame_id {
            os.write_uint64(24, v)?;
        }
        if let Some(v) = self.avatar_ugc_url.as_ref() {
            os.write_string(25, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoomGroupHeaderState {
        CChatRoomGroupHeaderState::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_name = ::std::option::Option::None;
        self.clanid = ::std::option::Option::None;
        self.accountid_owner = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.tagline = ::std::option::Option::None;
        self.avatar_sha = ::std::option::Option::None;
        self.default_role_id = ::std::option::Option::None;
        self.roles.clear();
        self.role_actions.clear();
        self.watching_broadcast_accountid = ::std::option::Option::None;
        self.party_beacons.clear();
        self.watching_broadcast_channel_id = ::std::option::Option::None;
        self.active_minigame_id = ::std::option::Option::None;
        self.avatar_ugc_url = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoomGroupHeaderState {
        static instance: CChatRoomGroupHeaderState = CChatRoomGroupHeaderState {
            chat_group_id: ::std::option::Option::None,
            chat_name: ::std::option::Option::None,
            clanid: ::std::option::Option::None,
            accountid_owner: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            tagline: ::std::option::Option::None,
            avatar_sha: ::std::option::Option::None,
            default_role_id: ::std::option::Option::None,
            roles: ::std::vec::Vec::new(),
            role_actions: ::std::vec::Vec::new(),
            watching_broadcast_accountid: ::std::option::Option::None,
            party_beacons: ::std::vec::Vec::new(),
            watching_broadcast_channel_id: ::std::option::Option::None,
            active_minigame_id: ::std::option::Option::None,
            avatar_ugc_url: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoomGroupHeaderState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoomGroupHeaderState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoomGroupHeaderState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoomGroupHeaderState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoomMember)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoomMember {
    // message fields
    // @@protoc_insertion_point(field:CChatRoomMember.accountid)
    pub accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoomMember.state)
    pub state: ::std::option::Option<::protobuf::EnumOrUnknown<EChatRoomJoinState>>,
    // @@protoc_insertion_point(field:CChatRoomMember.rank)
    pub rank: ::std::option::Option<::protobuf::EnumOrUnknown<EChatRoomGroupRank>>,
    // @@protoc_insertion_point(field:CChatRoomMember.time_kick_expire)
    pub time_kick_expire: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoomMember.role_ids)
    pub role_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoomMember.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoomMember {
    fn default() -> &'a CChatRoomMember {
        <CChatRoomMember as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoomMember {
    pub fn new() -> CChatRoomMember {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;

    pub fn accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional .EChatRoomJoinState state = 3;

    pub fn state(&self) -> EChatRoomJoinState {
        match self.state {
            Some(e) => e.enum_value_or(EChatRoomJoinState::k_EChatRoomJoinState_Default),
            None => EChatRoomJoinState::k_EChatRoomJoinState_Default,
        }
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: EChatRoomJoinState) {
        self.state = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .EChatRoomGroupRank rank = 4;

    pub fn rank(&self) -> EChatRoomGroupRank {
        match self.rank {
            Some(e) => e.enum_value_or(EChatRoomGroupRank::k_EChatRoomGroupRank_Default),
            None => EChatRoomGroupRank::k_EChatRoomGroupRank_Default,
        }
    }

    pub fn clear_rank(&mut self) {
        self.rank = ::std::option::Option::None;
    }

    pub fn has_rank(&self) -> bool {
        self.rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank(&mut self, v: EChatRoomGroupRank) {
        self.rank = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 time_kick_expire = 6;

    pub fn time_kick_expire(&self) -> u32 {
        self.time_kick_expire.unwrap_or(0)
    }

    pub fn clear_time_kick_expire(&mut self) {
        self.time_kick_expire = ::std::option::Option::None;
    }

    pub fn has_time_kick_expire(&self) -> bool {
        self.time_kick_expire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_kick_expire(&mut self, v: u32) {
        self.time_kick_expire = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid",
            |m: &CChatRoomMember| { &m.accountid },
            |m: &mut CChatRoomMember| { &mut m.accountid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "state",
            |m: &CChatRoomMember| { &m.state },
            |m: &mut CChatRoomMember| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rank",
            |m: &CChatRoomMember| { &m.rank },
            |m: &mut CChatRoomMember| { &mut m.rank },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_kick_expire",
            |m: &CChatRoomMember| { &m.time_kick_expire },
            |m: &mut CChatRoomMember| { &mut m.time_kick_expire },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "role_ids",
            |m: &CChatRoomMember| { &m.role_ids },
            |m: &mut CChatRoomMember| { &mut m.role_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoomMember>(
            "CChatRoomMember",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoomMember {
    const NAME: &'static str = "CChatRoomMember";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.rank = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                48 => {
                    self.time_kick_expire = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    is.read_repeated_packed_uint64_into(&mut self.role_ids)?;
                },
                56 => {
                    self.role_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.rank {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.time_kick_expire {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        for value in &self.role_ids {
            my_size += ::protobuf::rt::uint64_size(7, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.state {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.rank {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.time_kick_expire {
            os.write_uint32(6, v)?;
        }
        for v in &self.role_ids {
            os.write_uint64(7, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoomMember {
        CChatRoomMember::new()
    }

    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.state = ::std::option::Option::None;
        self.rank = ::std::option::Option::None;
        self.time_kick_expire = ::std::option::Option::None;
        self.role_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoomMember {
        static instance: CChatRoomMember = CChatRoomMember {
            accountid: ::std::option::Option::None,
            state: ::std::option::Option::None,
            rank: ::std::option::Option::None,
            time_kick_expire: ::std::option::Option::None,
            role_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoomMember {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoomMember").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoomMember {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoomMember {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoomState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoomState {
    // message fields
    // @@protoc_insertion_point(field:CChatRoomState.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoomState.chat_name)
    pub chat_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoomState.voice_allowed)
    pub voice_allowed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatRoomState.members_in_voice)
    pub members_in_voice: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CChatRoomState.time_last_message)
    pub time_last_message: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoomState.sort_order)
    pub sort_order: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoomState.last_message)
    pub last_message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoomState.accountid_last_message)
    pub accountid_last_message: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoomState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoomState {
    fn default() -> &'a CChatRoomState {
        <CChatRoomState as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoomState {
    pub fn new() -> CChatRoomState {
        ::std::default::Default::default()
    }

    // optional uint64 chat_id = 1;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional string chat_name = 2;

    pub fn chat_name(&self) -> &str {
        match self.chat_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_chat_name(&mut self) {
        self.chat_name = ::std::option::Option::None;
    }

    pub fn has_chat_name(&self) -> bool {
        self.chat_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_name(&mut self, v: ::std::string::String) {
        self.chat_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_name(&mut self) -> &mut ::std::string::String {
        if self.chat_name.is_none() {
            self.chat_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.chat_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_name(&mut self) -> ::std::string::String {
        self.chat_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool voice_allowed = 3;

    pub fn voice_allowed(&self) -> bool {
        self.voice_allowed.unwrap_or(false)
    }

    pub fn clear_voice_allowed(&mut self) {
        self.voice_allowed = ::std::option::Option::None;
    }

    pub fn has_voice_allowed(&self) -> bool {
        self.voice_allowed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_allowed(&mut self, v: bool) {
        self.voice_allowed = ::std::option::Option::Some(v);
    }

    // optional uint32 time_last_message = 5;

    pub fn time_last_message(&self) -> u32 {
        self.time_last_message.unwrap_or(0)
    }

    pub fn clear_time_last_message(&mut self) {
        self.time_last_message = ::std::option::Option::None;
    }

    pub fn has_time_last_message(&self) -> bool {
        self.time_last_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_last_message(&mut self, v: u32) {
        self.time_last_message = ::std::option::Option::Some(v);
    }

    // optional uint32 sort_order = 6;

    pub fn sort_order(&self) -> u32 {
        self.sort_order.unwrap_or(0)
    }

    pub fn clear_sort_order(&mut self) {
        self.sort_order = ::std::option::Option::None;
    }

    pub fn has_sort_order(&self) -> bool {
        self.sort_order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sort_order(&mut self, v: u32) {
        self.sort_order = ::std::option::Option::Some(v);
    }

    // optional string last_message = 7;

    pub fn last_message(&self) -> &str {
        match self.last_message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_last_message(&mut self) {
        self.last_message = ::std::option::Option::None;
    }

    pub fn has_last_message(&self) -> bool {
        self.last_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_message(&mut self, v: ::std::string::String) {
        self.last_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_message(&mut self) -> &mut ::std::string::String {
        if self.last_message.is_none() {
            self.last_message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.last_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_message(&mut self) -> ::std::string::String {
        self.last_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 accountid_last_message = 8;

    pub fn accountid_last_message(&self) -> u32 {
        self.accountid_last_message.unwrap_or(0)
    }

    pub fn clear_accountid_last_message(&mut self) {
        self.accountid_last_message = ::std::option::Option::None;
    }

    pub fn has_accountid_last_message(&self) -> bool {
        self.accountid_last_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid_last_message(&mut self, v: u32) {
        self.accountid_last_message = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoomState| { &m.chat_id },
            |m: &mut CChatRoomState| { &mut m.chat_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_name",
            |m: &CChatRoomState| { &m.chat_name },
            |m: &mut CChatRoomState| { &mut m.chat_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "voice_allowed",
            |m: &CChatRoomState| { &m.voice_allowed },
            |m: &mut CChatRoomState| { &mut m.voice_allowed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "members_in_voice",
            |m: &CChatRoomState| { &m.members_in_voice },
            |m: &mut CChatRoomState| { &mut m.members_in_voice },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_last_message",
            |m: &CChatRoomState| { &m.time_last_message },
            |m: &mut CChatRoomState| { &mut m.time_last_message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sort_order",
            |m: &CChatRoomState| { &m.sort_order },
            |m: &mut CChatRoomState| { &mut m.sort_order },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_message",
            |m: &CChatRoomState| { &m.last_message },
            |m: &mut CChatRoomState| { &mut m.last_message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid_last_message",
            |m: &CChatRoomState| { &m.accountid_last_message },
            |m: &mut CChatRoomState| { &mut m.accountid_last_message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoomState>(
            "CChatRoomState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoomState {
    const NAME: &'static str = "CChatRoomState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.chat_name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.voice_allowed = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    is.read_repeated_packed_uint32_into(&mut self.members_in_voice)?;
                },
                32 => {
                    self.members_in_voice.push(is.read_uint32()?);
                },
                40 => {
                    self.time_last_message = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.sort_order = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.last_message = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.accountid_last_message = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.voice_allowed {
            my_size += 1 + 1;
        }
        for value in &self.members_in_voice {
            my_size += ::protobuf::rt::uint32_size(4, *value);
        };
        if let Some(v) = self.time_last_message {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.sort_order {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.last_message.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.accountid_last_message {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.voice_allowed {
            os.write_bool(3, v)?;
        }
        for v in &self.members_in_voice {
            os.write_uint32(4, *v)?;
        };
        if let Some(v) = self.time_last_message {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.sort_order {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.last_message.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.accountid_last_message {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoomState {
        CChatRoomState::new()
    }

    fn clear(&mut self) {
        self.chat_id = ::std::option::Option::None;
        self.chat_name = ::std::option::Option::None;
        self.voice_allowed = ::std::option::Option::None;
        self.members_in_voice.clear();
        self.time_last_message = ::std::option::Option::None;
        self.sort_order = ::std::option::Option::None;
        self.last_message = ::std::option::Option::None;
        self.accountid_last_message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoomState {
        static instance: CChatRoomState = CChatRoomState {
            chat_id: ::std::option::Option::None,
            chat_name: ::std::option::Option::None,
            voice_allowed: ::std::option::Option::None,
            members_in_voice: ::std::vec::Vec::new(),
            time_last_message: ::std::option::Option::None,
            sort_order: ::std::option::Option::None,
            last_message: ::std::option::Option::None,
            accountid_last_message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoomState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoomState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoomState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoomState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoomGroupState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoomGroupState {
    // message fields
    // @@protoc_insertion_point(field:CChatRoomGroupState.header_state)
    pub header_state: ::protobuf::MessageField<CChatRoomGroupHeaderState>,
    // @@protoc_insertion_point(field:CChatRoomGroupState.members)
    pub members: ::std::vec::Vec<CChatRoomMember>,
    // @@protoc_insertion_point(field:CChatRoomGroupState.default_chat_id)
    pub default_chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoomGroupState.chat_rooms)
    pub chat_rooms: ::std::vec::Vec<CChatRoomState>,
    // @@protoc_insertion_point(field:CChatRoomGroupState.kicked)
    pub kicked: ::std::vec::Vec<CChatRoomMember>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoomGroupState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoomGroupState {
    fn default() -> &'a CChatRoomGroupState {
        <CChatRoomGroupState as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoomGroupState {
    pub fn new() -> CChatRoomGroupState {
        ::std::default::Default::default()
    }

    // optional uint64 default_chat_id = 4;

    pub fn default_chat_id(&self) -> u64 {
        self.default_chat_id.unwrap_or(0)
    }

    pub fn clear_default_chat_id(&mut self) {
        self.default_chat_id = ::std::option::Option::None;
    }

    pub fn has_default_chat_id(&self) -> bool {
        self.default_chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_chat_id(&mut self, v: u64) {
        self.default_chat_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CChatRoomGroupHeaderState>(
            "header_state",
            |m: &CChatRoomGroupState| { &m.header_state },
            |m: &mut CChatRoomGroupState| { &mut m.header_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "members",
            |m: &CChatRoomGroupState| { &m.members },
            |m: &mut CChatRoomGroupState| { &mut m.members },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "default_chat_id",
            |m: &CChatRoomGroupState| { &m.default_chat_id },
            |m: &mut CChatRoomGroupState| { &mut m.default_chat_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "chat_rooms",
            |m: &CChatRoomGroupState| { &m.chat_rooms },
            |m: &mut CChatRoomGroupState| { &mut m.chat_rooms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "kicked",
            |m: &CChatRoomGroupState| { &m.kicked },
            |m: &mut CChatRoomGroupState| { &mut m.kicked },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoomGroupState>(
            "CChatRoomGroupState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoomGroupState {
    const NAME: &'static str = "CChatRoomGroupState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header_state)?;
                },
                18 => {
                    self.members.push(is.read_message()?);
                },
                32 => {
                    self.default_chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                42 => {
                    self.chat_rooms.push(is.read_message()?);
                },
                58 => {
                    self.kicked.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.default_chat_id {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        for value in &self.chat_rooms {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.kicked {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.members {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.default_chat_id {
            os.write_uint64(4, v)?;
        }
        for v in &self.chat_rooms {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.kicked {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoomGroupState {
        CChatRoomGroupState::new()
    }

    fn clear(&mut self) {
        self.header_state.clear();
        self.members.clear();
        self.default_chat_id = ::std::option::Option::None;
        self.chat_rooms.clear();
        self.kicked.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoomGroupState {
        static instance: CChatRoomGroupState = CChatRoomGroupState {
            header_state: ::protobuf::MessageField::none(),
            members: ::std::vec::Vec::new(),
            default_chat_id: ::std::option::Option::None,
            chat_rooms: ::std::vec::Vec::new(),
            kicked: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoomGroupState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoomGroupState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoomGroupState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoomGroupState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserChatRoomState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserChatRoomState {
    // message fields
    // @@protoc_insertion_point(field:CUserChatRoomState.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CUserChatRoomState.time_joined)
    pub time_joined: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserChatRoomState.time_last_ack)
    pub time_last_ack: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserChatRoomState.desktop_notification_level)
    pub desktop_notification_level: ::std::option::Option<::protobuf::EnumOrUnknown<EChatRoomNotificationLevel>>,
    // @@protoc_insertion_point(field:CUserChatRoomState.mobile_notification_level)
    pub mobile_notification_level: ::std::option::Option<::protobuf::EnumOrUnknown<EChatRoomNotificationLevel>>,
    // @@protoc_insertion_point(field:CUserChatRoomState.time_last_mention)
    pub time_last_mention: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserChatRoomState.unread_indicator_muted)
    pub unread_indicator_muted: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CUserChatRoomState.time_first_unread)
    pub time_first_unread: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserChatRoomState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserChatRoomState {
    fn default() -> &'a CUserChatRoomState {
        <CUserChatRoomState as ::protobuf::Message>::default_instance()
    }
}

impl CUserChatRoomState {
    pub fn new() -> CUserChatRoomState {
        ::std::default::Default::default()
    }

    // optional uint64 chat_id = 1;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 time_joined = 2;

    pub fn time_joined(&self) -> u32 {
        self.time_joined.unwrap_or(0)
    }

    pub fn clear_time_joined(&mut self) {
        self.time_joined = ::std::option::Option::None;
    }

    pub fn has_time_joined(&self) -> bool {
        self.time_joined.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_joined(&mut self, v: u32) {
        self.time_joined = ::std::option::Option::Some(v);
    }

    // optional uint32 time_last_ack = 3;

    pub fn time_last_ack(&self) -> u32 {
        self.time_last_ack.unwrap_or(0)
    }

    pub fn clear_time_last_ack(&mut self) {
        self.time_last_ack = ::std::option::Option::None;
    }

    pub fn has_time_last_ack(&self) -> bool {
        self.time_last_ack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_last_ack(&mut self, v: u32) {
        self.time_last_ack = ::std::option::Option::Some(v);
    }

    // optional .EChatRoomNotificationLevel desktop_notification_level = 4;

    pub fn desktop_notification_level(&self) -> EChatRoomNotificationLevel {
        match self.desktop_notification_level {
            Some(e) => e.enum_value_or(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid),
            None => EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid,
        }
    }

    pub fn clear_desktop_notification_level(&mut self) {
        self.desktop_notification_level = ::std::option::Option::None;
    }

    pub fn has_desktop_notification_level(&self) -> bool {
        self.desktop_notification_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desktop_notification_level(&mut self, v: EChatRoomNotificationLevel) {
        self.desktop_notification_level = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .EChatRoomNotificationLevel mobile_notification_level = 5;

    pub fn mobile_notification_level(&self) -> EChatRoomNotificationLevel {
        match self.mobile_notification_level {
            Some(e) => e.enum_value_or(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid),
            None => EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid,
        }
    }

    pub fn clear_mobile_notification_level(&mut self) {
        self.mobile_notification_level = ::std::option::Option::None;
    }

    pub fn has_mobile_notification_level(&self) -> bool {
        self.mobile_notification_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mobile_notification_level(&mut self, v: EChatRoomNotificationLevel) {
        self.mobile_notification_level = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 time_last_mention = 6;

    pub fn time_last_mention(&self) -> u32 {
        self.time_last_mention.unwrap_or(0)
    }

    pub fn clear_time_last_mention(&mut self) {
        self.time_last_mention = ::std::option::Option::None;
    }

    pub fn has_time_last_mention(&self) -> bool {
        self.time_last_mention.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_last_mention(&mut self, v: u32) {
        self.time_last_mention = ::std::option::Option::Some(v);
    }

    // optional bool unread_indicator_muted = 7;

    pub fn unread_indicator_muted(&self) -> bool {
        self.unread_indicator_muted.unwrap_or(false)
    }

    pub fn clear_unread_indicator_muted(&mut self) {
        self.unread_indicator_muted = ::std::option::Option::None;
    }

    pub fn has_unread_indicator_muted(&self) -> bool {
        self.unread_indicator_muted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unread_indicator_muted(&mut self, v: bool) {
        self.unread_indicator_muted = ::std::option::Option::Some(v);
    }

    // optional uint32 time_first_unread = 8;

    pub fn time_first_unread(&self) -> u32 {
        self.time_first_unread.unwrap_or(0)
    }

    pub fn clear_time_first_unread(&mut self) {
        self.time_first_unread = ::std::option::Option::None;
    }

    pub fn has_time_first_unread(&self) -> bool {
        self.time_first_unread.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_first_unread(&mut self, v: u32) {
        self.time_first_unread = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CUserChatRoomState| { &m.chat_id },
            |m: &mut CUserChatRoomState| { &mut m.chat_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_joined",
            |m: &CUserChatRoomState| { &m.time_joined },
            |m: &mut CUserChatRoomState| { &mut m.time_joined },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_last_ack",
            |m: &CUserChatRoomState| { &m.time_last_ack },
            |m: &mut CUserChatRoomState| { &mut m.time_last_ack },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "desktop_notification_level",
            |m: &CUserChatRoomState| { &m.desktop_notification_level },
            |m: &mut CUserChatRoomState| { &mut m.desktop_notification_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mobile_notification_level",
            |m: &CUserChatRoomState| { &m.mobile_notification_level },
            |m: &mut CUserChatRoomState| { &mut m.mobile_notification_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_last_mention",
            |m: &CUserChatRoomState| { &m.time_last_mention },
            |m: &mut CUserChatRoomState| { &mut m.time_last_mention },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unread_indicator_muted",
            |m: &CUserChatRoomState| { &m.unread_indicator_muted },
            |m: &mut CUserChatRoomState| { &mut m.unread_indicator_muted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_first_unread",
            |m: &CUserChatRoomState| { &m.time_first_unread },
            |m: &mut CUserChatRoomState| { &mut m.time_first_unread },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserChatRoomState>(
            "CUserChatRoomState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserChatRoomState {
    const NAME: &'static str = "CUserChatRoomState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.time_joined = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.time_last_ack = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.desktop_notification_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.mobile_notification_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                48 => {
                    self.time_last_mention = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.unread_indicator_muted = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.time_first_unread = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.time_joined {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.time_last_ack {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.desktop_notification_level {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.mobile_notification_level {
            my_size += ::protobuf::rt::int32_size(5, v.value());
        }
        if let Some(v) = self.time_last_mention {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.unread_indicator_muted {
            my_size += 1 + 1;
        }
        if let Some(v) = self.time_first_unread {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.time_joined {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.time_last_ack {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.desktop_notification_level {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.mobile_notification_level {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.time_last_mention {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.unread_indicator_muted {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.time_first_unread {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserChatRoomState {
        CUserChatRoomState::new()
    }

    fn clear(&mut self) {
        self.chat_id = ::std::option::Option::None;
        self.time_joined = ::std::option::Option::None;
        self.time_last_ack = ::std::option::Option::None;
        self.desktop_notification_level = ::std::option::Option::None;
        self.mobile_notification_level = ::std::option::Option::None;
        self.time_last_mention = ::std::option::Option::None;
        self.unread_indicator_muted = ::std::option::Option::None;
        self.time_first_unread = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserChatRoomState {
        static instance: CUserChatRoomState = CUserChatRoomState {
            chat_id: ::std::option::Option::None,
            time_joined: ::std::option::Option::None,
            time_last_ack: ::std::option::Option::None,
            desktop_notification_level: ::std::option::Option::None,
            mobile_notification_level: ::std::option::Option::None,
            time_last_mention: ::std::option::Option::None,
            unread_indicator_muted: ::std::option::Option::None,
            time_first_unread: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserChatRoomState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserChatRoomState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserChatRoomState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserChatRoomState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserChatRoomGroupState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserChatRoomGroupState {
    // message fields
    // @@protoc_insertion_point(field:CUserChatRoomGroupState.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CUserChatRoomGroupState.time_joined)
    pub time_joined: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserChatRoomGroupState.user_chat_room_state)
    pub user_chat_room_state: ::std::vec::Vec<CUserChatRoomState>,
    // @@protoc_insertion_point(field:CUserChatRoomGroupState.desktop_notification_level)
    pub desktop_notification_level: ::std::option::Option<::protobuf::EnumOrUnknown<EChatRoomNotificationLevel>>,
    // @@protoc_insertion_point(field:CUserChatRoomGroupState.mobile_notification_level)
    pub mobile_notification_level: ::std::option::Option<::protobuf::EnumOrUnknown<EChatRoomNotificationLevel>>,
    // @@protoc_insertion_point(field:CUserChatRoomGroupState.time_last_group_ack)
    pub time_last_group_ack: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserChatRoomGroupState.unread_indicator_muted)
    pub unread_indicator_muted: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserChatRoomGroupState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserChatRoomGroupState {
    fn default() -> &'a CUserChatRoomGroupState {
        <CUserChatRoomGroupState as ::protobuf::Message>::default_instance()
    }
}

impl CUserChatRoomGroupState {
    pub fn new() -> CUserChatRoomGroupState {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 time_joined = 2;

    pub fn time_joined(&self) -> u32 {
        self.time_joined.unwrap_or(0)
    }

    pub fn clear_time_joined(&mut self) {
        self.time_joined = ::std::option::Option::None;
    }

    pub fn has_time_joined(&self) -> bool {
        self.time_joined.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_joined(&mut self, v: u32) {
        self.time_joined = ::std::option::Option::Some(v);
    }

    // optional .EChatRoomNotificationLevel desktop_notification_level = 4;

    pub fn desktop_notification_level(&self) -> EChatRoomNotificationLevel {
        match self.desktop_notification_level {
            Some(e) => e.enum_value_or(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid),
            None => EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid,
        }
    }

    pub fn clear_desktop_notification_level(&mut self) {
        self.desktop_notification_level = ::std::option::Option::None;
    }

    pub fn has_desktop_notification_level(&self) -> bool {
        self.desktop_notification_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desktop_notification_level(&mut self, v: EChatRoomNotificationLevel) {
        self.desktop_notification_level = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .EChatRoomNotificationLevel mobile_notification_level = 5;

    pub fn mobile_notification_level(&self) -> EChatRoomNotificationLevel {
        match self.mobile_notification_level {
            Some(e) => e.enum_value_or(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid),
            None => EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid,
        }
    }

    pub fn clear_mobile_notification_level(&mut self) {
        self.mobile_notification_level = ::std::option::Option::None;
    }

    pub fn has_mobile_notification_level(&self) -> bool {
        self.mobile_notification_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mobile_notification_level(&mut self, v: EChatRoomNotificationLevel) {
        self.mobile_notification_level = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 time_last_group_ack = 6;

    pub fn time_last_group_ack(&self) -> u32 {
        self.time_last_group_ack.unwrap_or(0)
    }

    pub fn clear_time_last_group_ack(&mut self) {
        self.time_last_group_ack = ::std::option::Option::None;
    }

    pub fn has_time_last_group_ack(&self) -> bool {
        self.time_last_group_ack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_last_group_ack(&mut self, v: u32) {
        self.time_last_group_ack = ::std::option::Option::Some(v);
    }

    // optional bool unread_indicator_muted = 7;

    pub fn unread_indicator_muted(&self) -> bool {
        self.unread_indicator_muted.unwrap_or(false)
    }

    pub fn clear_unread_indicator_muted(&mut self) {
        self.unread_indicator_muted = ::std::option::Option::None;
    }

    pub fn has_unread_indicator_muted(&self) -> bool {
        self.unread_indicator_muted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unread_indicator_muted(&mut self, v: bool) {
        self.unread_indicator_muted = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CUserChatRoomGroupState| { &m.chat_group_id },
            |m: &mut CUserChatRoomGroupState| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_joined",
            |m: &CUserChatRoomGroupState| { &m.time_joined },
            |m: &mut CUserChatRoomGroupState| { &mut m.time_joined },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "user_chat_room_state",
            |m: &CUserChatRoomGroupState| { &m.user_chat_room_state },
            |m: &mut CUserChatRoomGroupState| { &mut m.user_chat_room_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "desktop_notification_level",
            |m: &CUserChatRoomGroupState| { &m.desktop_notification_level },
            |m: &mut CUserChatRoomGroupState| { &mut m.desktop_notification_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mobile_notification_level",
            |m: &CUserChatRoomGroupState| { &m.mobile_notification_level },
            |m: &mut CUserChatRoomGroupState| { &mut m.mobile_notification_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_last_group_ack",
            |m: &CUserChatRoomGroupState| { &m.time_last_group_ack },
            |m: &mut CUserChatRoomGroupState| { &mut m.time_last_group_ack },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unread_indicator_muted",
            |m: &CUserChatRoomGroupState| { &m.unread_indicator_muted },
            |m: &mut CUserChatRoomGroupState| { &mut m.unread_indicator_muted },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserChatRoomGroupState>(
            "CUserChatRoomGroupState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserChatRoomGroupState {
    const NAME: &'static str = "CUserChatRoomGroupState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.time_joined = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.user_chat_room_state.push(is.read_message()?);
                },
                32 => {
                    self.desktop_notification_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.mobile_notification_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                48 => {
                    self.time_last_group_ack = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.unread_indicator_muted = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.time_joined {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.user_chat_room_state {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.desktop_notification_level {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.mobile_notification_level {
            my_size += ::protobuf::rt::int32_size(5, v.value());
        }
        if let Some(v) = self.time_last_group_ack {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.unread_indicator_muted {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.time_joined {
            os.write_uint32(2, v)?;
        }
        for v in &self.user_chat_room_state {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.desktop_notification_level {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.mobile_notification_level {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.time_last_group_ack {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.unread_indicator_muted {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserChatRoomGroupState {
        CUserChatRoomGroupState::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.time_joined = ::std::option::Option::None;
        self.user_chat_room_state.clear();
        self.desktop_notification_level = ::std::option::Option::None;
        self.mobile_notification_level = ::std::option::Option::None;
        self.time_last_group_ack = ::std::option::Option::None;
        self.unread_indicator_muted = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserChatRoomGroupState {
        static instance: CUserChatRoomGroupState = CUserChatRoomGroupState {
            chat_group_id: ::std::option::Option::None,
            time_joined: ::std::option::Option::None,
            user_chat_room_state: ::std::vec::Vec::new(),
            desktop_notification_level: ::std::option::Option::None,
            mobile_notification_level: ::std::option::Option::None,
            time_last_group_ack: ::std::option::Option::None,
            unread_indicator_muted: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserChatRoomGroupState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserChatRoomGroupState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserChatRoomGroupState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserChatRoomGroupState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_CreateChatRoomGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_CreateChatRoomGroup_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_CreateChatRoomGroup_Response.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_CreateChatRoomGroup_Response.state)
    pub state: ::protobuf::MessageField<CChatRoomGroupState>,
    // @@protoc_insertion_point(field:CChatRoom_CreateChatRoomGroup_Response.user_chat_state)
    pub user_chat_state: ::protobuf::MessageField<CUserChatRoomGroupState>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_CreateChatRoomGroup_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_CreateChatRoomGroup_Response {
    fn default() -> &'a CChatRoom_CreateChatRoomGroup_Response {
        <CChatRoom_CreateChatRoomGroup_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_CreateChatRoomGroup_Response {
    pub fn new() -> CChatRoom_CreateChatRoomGroup_Response {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_CreateChatRoomGroup_Response| { &m.chat_group_id },
            |m: &mut CChatRoom_CreateChatRoomGroup_Response| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CChatRoomGroupState>(
            "state",
            |m: &CChatRoom_CreateChatRoomGroup_Response| { &m.state },
            |m: &mut CChatRoom_CreateChatRoomGroup_Response| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CUserChatRoomGroupState>(
            "user_chat_state",
            |m: &CChatRoom_CreateChatRoomGroup_Response| { &m.user_chat_state },
            |m: &mut CChatRoom_CreateChatRoomGroup_Response| { &mut m.user_chat_state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_CreateChatRoomGroup_Response>(
            "CChatRoom_CreateChatRoomGroup_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_CreateChatRoomGroup_Response {
    const NAME: &'static str = "CChatRoom_CreateChatRoomGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.state)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_chat_state)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.user_chat_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.user_chat_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_CreateChatRoomGroup_Response {
        CChatRoom_CreateChatRoomGroup_Response::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.state.clear();
        self.user_chat_state.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_CreateChatRoomGroup_Response {
        static instance: CChatRoom_CreateChatRoomGroup_Response = CChatRoom_CreateChatRoomGroup_Response {
            chat_group_id: ::std::option::Option::None,
            state: ::protobuf::MessageField::none(),
            user_chat_state: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_CreateChatRoomGroup_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_CreateChatRoomGroup_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_CreateChatRoomGroup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_CreateChatRoomGroup_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_SaveChatRoomGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SaveChatRoomGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SaveChatRoomGroup_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SaveChatRoomGroup_Request.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SaveChatRoomGroup_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SaveChatRoomGroup_Request {
    fn default() -> &'a CChatRoom_SaveChatRoomGroup_Request {
        <CChatRoom_SaveChatRoomGroup_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SaveChatRoomGroup_Request {
    pub fn new() -> CChatRoom_SaveChatRoomGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_SaveChatRoomGroup_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_SaveChatRoomGroup_Request| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CChatRoom_SaveChatRoomGroup_Request| { &m.name },
            |m: &mut CChatRoom_SaveChatRoomGroup_Request| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SaveChatRoomGroup_Request>(
            "CChatRoom_SaveChatRoomGroup_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_SaveChatRoomGroup_Request {
    const NAME: &'static str = "CChatRoom_SaveChatRoomGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SaveChatRoomGroup_Request {
        CChatRoom_SaveChatRoomGroup_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SaveChatRoomGroup_Request {
        static instance: CChatRoom_SaveChatRoomGroup_Request = CChatRoom_SaveChatRoomGroup_Request {
            chat_group_id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_SaveChatRoomGroup_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SaveChatRoomGroup_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SaveChatRoomGroup_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SaveChatRoomGroup_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_SaveChatRoomGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SaveChatRoomGroup_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SaveChatRoomGroup_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SaveChatRoomGroup_Response {
    fn default() -> &'a CChatRoom_SaveChatRoomGroup_Response {
        <CChatRoom_SaveChatRoomGroup_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SaveChatRoomGroup_Response {
    pub fn new() -> CChatRoom_SaveChatRoomGroup_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SaveChatRoomGroup_Response>(
            "CChatRoom_SaveChatRoomGroup_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_SaveChatRoomGroup_Response {
    const NAME: &'static str = "CChatRoom_SaveChatRoomGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SaveChatRoomGroup_Response {
        CChatRoom_SaveChatRoomGroup_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SaveChatRoomGroup_Response {
        static instance: CChatRoom_SaveChatRoomGroup_Response = CChatRoom_SaveChatRoomGroup_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_SaveChatRoomGroup_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SaveChatRoomGroup_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SaveChatRoomGroup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SaveChatRoomGroup_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_RenameChatRoomGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_RenameChatRoomGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_RenameChatRoomGroup_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_RenameChatRoomGroup_Request.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_RenameChatRoomGroup_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_RenameChatRoomGroup_Request {
    fn default() -> &'a CChatRoom_RenameChatRoomGroup_Request {
        <CChatRoom_RenameChatRoomGroup_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_RenameChatRoomGroup_Request {
    pub fn new() -> CChatRoom_RenameChatRoomGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_RenameChatRoomGroup_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_RenameChatRoomGroup_Request| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CChatRoom_RenameChatRoomGroup_Request| { &m.name },
            |m: &mut CChatRoom_RenameChatRoomGroup_Request| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_RenameChatRoomGroup_Request>(
            "CChatRoom_RenameChatRoomGroup_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_RenameChatRoomGroup_Request {
    const NAME: &'static str = "CChatRoom_RenameChatRoomGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_RenameChatRoomGroup_Request {
        CChatRoom_RenameChatRoomGroup_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_RenameChatRoomGroup_Request {
        static instance: CChatRoom_RenameChatRoomGroup_Request = CChatRoom_RenameChatRoomGroup_Request {
            chat_group_id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_RenameChatRoomGroup_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_RenameChatRoomGroup_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_RenameChatRoomGroup_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_RenameChatRoomGroup_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_RenameChatRoomGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_RenameChatRoomGroup_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_RenameChatRoomGroup_Response.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_RenameChatRoomGroup_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_RenameChatRoomGroup_Response {
    fn default() -> &'a CChatRoom_RenameChatRoomGroup_Response {
        <CChatRoom_RenameChatRoomGroup_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_RenameChatRoomGroup_Response {
    pub fn new() -> CChatRoom_RenameChatRoomGroup_Response {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CChatRoom_RenameChatRoomGroup_Response| { &m.name },
            |m: &mut CChatRoom_RenameChatRoomGroup_Response| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_RenameChatRoomGroup_Response>(
            "CChatRoom_RenameChatRoomGroup_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_RenameChatRoomGroup_Response {
    const NAME: &'static str = "CChatRoom_RenameChatRoomGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_RenameChatRoomGroup_Response {
        CChatRoom_RenameChatRoomGroup_Response::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_RenameChatRoomGroup_Response {
        static instance: CChatRoom_RenameChatRoomGroup_Response = CChatRoom_RenameChatRoomGroup_Response {
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_RenameChatRoomGroup_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_RenameChatRoomGroup_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_RenameChatRoomGroup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_RenameChatRoomGroup_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_SetChatRoomGroupTagline_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetChatRoomGroupTagline_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SetChatRoomGroupTagline_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SetChatRoomGroupTagline_Request.tagline)
    pub tagline: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetChatRoomGroupTagline_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetChatRoomGroupTagline_Request {
    fn default() -> &'a CChatRoom_SetChatRoomGroupTagline_Request {
        <CChatRoom_SetChatRoomGroupTagline_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetChatRoomGroupTagline_Request {
    pub fn new() -> CChatRoom_SetChatRoomGroupTagline_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string tagline = 2;

    pub fn tagline(&self) -> &str {
        match self.tagline.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_tagline(&mut self) {
        self.tagline = ::std::option::Option::None;
    }

    pub fn has_tagline(&self) -> bool {
        self.tagline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tagline(&mut self, v: ::std::string::String) {
        self.tagline = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tagline(&mut self) -> &mut ::std::string::String {
        if self.tagline.is_none() {
            self.tagline = ::std::option::Option::Some(::std::string::String::new());
        }
        self.tagline.as_mut().unwrap()
    }

    // Take field
    pub fn take_tagline(&mut self) -> ::std::string::String {
        self.tagline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_SetChatRoomGroupTagline_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_SetChatRoomGroupTagline_Request| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tagline",
            |m: &CChatRoom_SetChatRoomGroupTagline_Request| { &m.tagline },
            |m: &mut CChatRoom_SetChatRoomGroupTagline_Request| { &mut m.tagline },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SetChatRoomGroupTagline_Request>(
            "CChatRoom_SetChatRoomGroupTagline_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_SetChatRoomGroupTagline_Request {
    const NAME: &'static str = "CChatRoom_SetChatRoomGroupTagline_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.tagline = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.tagline.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.tagline.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetChatRoomGroupTagline_Request {
        CChatRoom_SetChatRoomGroupTagline_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.tagline = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetChatRoomGroupTagline_Request {
        static instance: CChatRoom_SetChatRoomGroupTagline_Request = CChatRoom_SetChatRoomGroupTagline_Request {
            chat_group_id: ::std::option::Option::None,
            tagline: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_SetChatRoomGroupTagline_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SetChatRoomGroupTagline_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SetChatRoomGroupTagline_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetChatRoomGroupTagline_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_SetChatRoomGroupTagline_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetChatRoomGroupTagline_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetChatRoomGroupTagline_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetChatRoomGroupTagline_Response {
    fn default() -> &'a CChatRoom_SetChatRoomGroupTagline_Response {
        <CChatRoom_SetChatRoomGroupTagline_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetChatRoomGroupTagline_Response {
    pub fn new() -> CChatRoom_SetChatRoomGroupTagline_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SetChatRoomGroupTagline_Response>(
            "CChatRoom_SetChatRoomGroupTagline_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_SetChatRoomGroupTagline_Response {
    const NAME: &'static str = "CChatRoom_SetChatRoomGroupTagline_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetChatRoomGroupTagline_Response {
        CChatRoom_SetChatRoomGroupTagline_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetChatRoomGroupTagline_Response {
        static instance: CChatRoom_SetChatRoomGroupTagline_Response = CChatRoom_SetChatRoomGroupTagline_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_SetChatRoomGroupTagline_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SetChatRoomGroupTagline_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SetChatRoomGroupTagline_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetChatRoomGroupTagline_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_SetChatRoomGroupAvatar_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetChatRoomGroupAvatar_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SetChatRoomGroupAvatar_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SetChatRoomGroupAvatar_Request.avatar_sha)
    pub avatar_sha: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetChatRoomGroupAvatar_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetChatRoomGroupAvatar_Request {
    fn default() -> &'a CChatRoom_SetChatRoomGroupAvatar_Request {
        <CChatRoom_SetChatRoomGroupAvatar_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetChatRoomGroupAvatar_Request {
    pub fn new() -> CChatRoom_SetChatRoomGroupAvatar_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional bytes avatar_sha = 2;

    pub fn avatar_sha(&self) -> &[u8] {
        match self.avatar_sha.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_avatar_sha(&mut self) {
        self.avatar_sha = ::std::option::Option::None;
    }

    pub fn has_avatar_sha(&self) -> bool {
        self.avatar_sha.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar_sha(&mut self, v: ::std::vec::Vec<u8>) {
        self.avatar_sha = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar_sha(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.avatar_sha.is_none() {
            self.avatar_sha = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.avatar_sha.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar_sha(&mut self) -> ::std::vec::Vec<u8> {
        self.avatar_sha.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_SetChatRoomGroupAvatar_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_SetChatRoomGroupAvatar_Request| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "avatar_sha",
            |m: &CChatRoom_SetChatRoomGroupAvatar_Request| { &m.avatar_sha },
            |m: &mut CChatRoom_SetChatRoomGroupAvatar_Request| { &mut m.avatar_sha },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SetChatRoomGroupAvatar_Request>(
            "CChatRoom_SetChatRoomGroupAvatar_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_SetChatRoomGroupAvatar_Request {
    const NAME: &'static str = "CChatRoom_SetChatRoomGroupAvatar_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.avatar_sha = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.avatar_sha.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.avatar_sha.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetChatRoomGroupAvatar_Request {
        CChatRoom_SetChatRoomGroupAvatar_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.avatar_sha = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetChatRoomGroupAvatar_Request {
        static instance: CChatRoom_SetChatRoomGroupAvatar_Request = CChatRoom_SetChatRoomGroupAvatar_Request {
            chat_group_id: ::std::option::Option::None,
            avatar_sha: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_SetChatRoomGroupAvatar_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SetChatRoomGroupAvatar_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SetChatRoomGroupAvatar_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetChatRoomGroupAvatar_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_SetChatRoomGroupAvatar_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetChatRoomGroupAvatar_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetChatRoomGroupAvatar_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetChatRoomGroupAvatar_Response {
    fn default() -> &'a CChatRoom_SetChatRoomGroupAvatar_Response {
        <CChatRoom_SetChatRoomGroupAvatar_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetChatRoomGroupAvatar_Response {
    pub fn new() -> CChatRoom_SetChatRoomGroupAvatar_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SetChatRoomGroupAvatar_Response>(
            "CChatRoom_SetChatRoomGroupAvatar_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_SetChatRoomGroupAvatar_Response {
    const NAME: &'static str = "CChatRoom_SetChatRoomGroupAvatar_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetChatRoomGroupAvatar_Response {
        CChatRoom_SetChatRoomGroupAvatar_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetChatRoomGroupAvatar_Response {
        static instance: CChatRoom_SetChatRoomGroupAvatar_Response = CChatRoom_SetChatRoomGroupAvatar_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_SetChatRoomGroupAvatar_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SetChatRoomGroupAvatar_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SetChatRoomGroupAvatar_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetChatRoomGroupAvatar_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_SetChatRoomGroupWatchingBroadcast_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SetChatRoomGroupWatchingBroadcast_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SetChatRoomGroupWatchingBroadcast_Request.watching_broadcast_accountid)
    pub watching_broadcast_accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_SetChatRoomGroupWatchingBroadcast_Request.watching_broadcast_channel_id)
    pub watching_broadcast_channel_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetChatRoomGroupWatchingBroadcast_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
    fn default() -> &'a CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
        <CChatRoom_SetChatRoomGroupWatchingBroadcast_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
    pub fn new() -> CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 watching_broadcast_accountid = 2;

    pub fn watching_broadcast_accountid(&self) -> u32 {
        self.watching_broadcast_accountid.unwrap_or(0)
    }

    pub fn clear_watching_broadcast_accountid(&mut self) {
        self.watching_broadcast_accountid = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_accountid(&self) -> bool {
        self.watching_broadcast_accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_accountid(&mut self, v: u32) {
        self.watching_broadcast_accountid = ::std::option::Option::Some(v);
    }

    // optional uint64 watching_broadcast_channel_id = 3;

    pub fn watching_broadcast_channel_id(&self) -> u64 {
        self.watching_broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_watching_broadcast_channel_id(&mut self) {
        self.watching_broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_channel_id(&self) -> bool {
        self.watching_broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_channel_id(&mut self, v: u64) {
        self.watching_broadcast_channel_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_SetChatRoomGroupWatchingBroadcast_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_SetChatRoomGroupWatchingBroadcast_Request| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "watching_broadcast_accountid",
            |m: &CChatRoom_SetChatRoomGroupWatchingBroadcast_Request| { &m.watching_broadcast_accountid },
            |m: &mut CChatRoom_SetChatRoomGroupWatchingBroadcast_Request| { &mut m.watching_broadcast_accountid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "watching_broadcast_channel_id",
            |m: &CChatRoom_SetChatRoomGroupWatchingBroadcast_Request| { &m.watching_broadcast_channel_id },
            |m: &mut CChatRoom_SetChatRoomGroupWatchingBroadcast_Request| { &mut m.watching_broadcast_channel_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SetChatRoomGroupWatchingBroadcast_Request>(
            "CChatRoom_SetChatRoomGroupWatchingBroadcast_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
    const NAME: &'static str = "CChatRoom_SetChatRoomGroupWatchingBroadcast_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.watching_broadcast_accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.watching_broadcast_channel_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.watching_broadcast_accountid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.watching_broadcast_channel_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.watching_broadcast_accountid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.watching_broadcast_channel_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
        CChatRoom_SetChatRoomGroupWatchingBroadcast_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.watching_broadcast_accountid = ::std::option::Option::None;
        self.watching_broadcast_channel_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
        static instance: CChatRoom_SetChatRoomGroupWatchingBroadcast_Request = CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
            chat_group_id: ::std::option::Option::None,
            watching_broadcast_accountid: ::std::option::Option::None,
            watching_broadcast_channel_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SetChatRoomGroupWatchingBroadcast_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_SetChatRoomGroupWatchingBroadcast_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetChatRoomGroupWatchingBroadcast_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
    fn default() -> &'a CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
        <CChatRoom_SetChatRoomGroupWatchingBroadcast_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
    pub fn new() -> CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SetChatRoomGroupWatchingBroadcast_Response>(
            "CChatRoom_SetChatRoomGroupWatchingBroadcast_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
    const NAME: &'static str = "CChatRoom_SetChatRoomGroupWatchingBroadcast_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
        CChatRoom_SetChatRoomGroupWatchingBroadcast_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
        static instance: CChatRoom_SetChatRoomGroupWatchingBroadcast_Response = CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SetChatRoomGroupWatchingBroadcast_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_JoinMiniGameForChatRoomGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_JoinMiniGameForChatRoomGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_JoinMiniGameForChatRoomGroup_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_JoinMiniGameForChatRoomGroup_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_JoinMiniGameForChatRoomGroup_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_JoinMiniGameForChatRoomGroup_Request {
    fn default() -> &'a CChatRoom_JoinMiniGameForChatRoomGroup_Request {
        <CChatRoom_JoinMiniGameForChatRoomGroup_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_JoinMiniGameForChatRoomGroup_Request {
    pub fn new() -> CChatRoom_JoinMiniGameForChatRoomGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_JoinMiniGameForChatRoomGroup_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_JoinMiniGameForChatRoomGroup_Request| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_JoinMiniGameForChatRoomGroup_Request| { &m.chat_id },
            |m: &mut CChatRoom_JoinMiniGameForChatRoomGroup_Request| { &mut m.chat_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_JoinMiniGameForChatRoomGroup_Request>(
            "CChatRoom_JoinMiniGameForChatRoomGroup_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_JoinMiniGameForChatRoomGroup_Request {
    const NAME: &'static str = "CChatRoom_JoinMiniGameForChatRoomGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_JoinMiniGameForChatRoomGroup_Request {
        CChatRoom_JoinMiniGameForChatRoomGroup_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_JoinMiniGameForChatRoomGroup_Request {
        static instance: CChatRoom_JoinMiniGameForChatRoomGroup_Request = CChatRoom_JoinMiniGameForChatRoomGroup_Request {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_JoinMiniGameForChatRoomGroup_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_JoinMiniGameForChatRoomGroup_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_JoinMiniGameForChatRoomGroup_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_JoinMiniGameForChatRoomGroup_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_JoinMiniGameForChatRoomGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_JoinMiniGameForChatRoomGroup_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_JoinMiniGameForChatRoomGroup_Response.minigame_id)
    pub minigame_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_JoinMiniGameForChatRoomGroup_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_JoinMiniGameForChatRoomGroup_Response {
    fn default() -> &'a CChatRoom_JoinMiniGameForChatRoomGroup_Response {
        <CChatRoom_JoinMiniGameForChatRoomGroup_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_JoinMiniGameForChatRoomGroup_Response {
    pub fn new() -> CChatRoom_JoinMiniGameForChatRoomGroup_Response {
        ::std::default::Default::default()
    }

    // optional uint64 minigame_id = 1;

    pub fn minigame_id(&self) -> u64 {
        self.minigame_id.unwrap_or(0)
    }

    pub fn clear_minigame_id(&mut self) {
        self.minigame_id = ::std::option::Option::None;
    }

    pub fn has_minigame_id(&self) -> bool {
        self.minigame_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minigame_id(&mut self, v: u64) {
        self.minigame_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minigame_id",
            |m: &CChatRoom_JoinMiniGameForChatRoomGroup_Response| { &m.minigame_id },
            |m: &mut CChatRoom_JoinMiniGameForChatRoomGroup_Response| { &mut m.minigame_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_JoinMiniGameForChatRoomGroup_Response>(
            "CChatRoom_JoinMiniGameForChatRoomGroup_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_JoinMiniGameForChatRoomGroup_Response {
    const NAME: &'static str = "CChatRoom_JoinMiniGameForChatRoomGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.minigame_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.minigame_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.minigame_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_JoinMiniGameForChatRoomGroup_Response {
        CChatRoom_JoinMiniGameForChatRoomGroup_Response::new()
    }

    fn clear(&mut self) {
        self.minigame_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_JoinMiniGameForChatRoomGroup_Response {
        static instance: CChatRoom_JoinMiniGameForChatRoomGroup_Response = CChatRoom_JoinMiniGameForChatRoomGroup_Response {
            minigame_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_JoinMiniGameForChatRoomGroup_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_JoinMiniGameForChatRoomGroup_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_JoinMiniGameForChatRoomGroup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_JoinMiniGameForChatRoomGroup_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_EndMiniGameForChatRoomGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_EndMiniGameForChatRoomGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_EndMiniGameForChatRoomGroup_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_EndMiniGameForChatRoomGroup_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_EndMiniGameForChatRoomGroup_Request.minigame_id)
    pub minigame_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_EndMiniGameForChatRoomGroup_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_EndMiniGameForChatRoomGroup_Request {
    fn default() -> &'a CChatRoom_EndMiniGameForChatRoomGroup_Request {
        <CChatRoom_EndMiniGameForChatRoomGroup_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_EndMiniGameForChatRoomGroup_Request {
    pub fn new() -> CChatRoom_EndMiniGameForChatRoomGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint64 minigame_id = 3;

    pub fn minigame_id(&self) -> u64 {
        self.minigame_id.unwrap_or(0)
    }

    pub fn clear_minigame_id(&mut self) {
        self.minigame_id = ::std::option::Option::None;
    }

    pub fn has_minigame_id(&self) -> bool {
        self.minigame_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minigame_id(&mut self, v: u64) {
        self.minigame_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_EndMiniGameForChatRoomGroup_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_EndMiniGameForChatRoomGroup_Request| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_EndMiniGameForChatRoomGroup_Request| { &m.chat_id },
            |m: &mut CChatRoom_EndMiniGameForChatRoomGroup_Request| { &mut m.chat_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minigame_id",
            |m: &CChatRoom_EndMiniGameForChatRoomGroup_Request| { &m.minigame_id },
            |m: &mut CChatRoom_EndMiniGameForChatRoomGroup_Request| { &mut m.minigame_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_EndMiniGameForChatRoomGroup_Request>(
            "CChatRoom_EndMiniGameForChatRoomGroup_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_EndMiniGameForChatRoomGroup_Request {
    const NAME: &'static str = "CChatRoom_EndMiniGameForChatRoomGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.minigame_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.minigame_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.minigame_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_EndMiniGameForChatRoomGroup_Request {
        CChatRoom_EndMiniGameForChatRoomGroup_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.minigame_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_EndMiniGameForChatRoomGroup_Request {
        static instance: CChatRoom_EndMiniGameForChatRoomGroup_Request = CChatRoom_EndMiniGameForChatRoomGroup_Request {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            minigame_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_EndMiniGameForChatRoomGroup_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_EndMiniGameForChatRoomGroup_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_EndMiniGameForChatRoomGroup_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_EndMiniGameForChatRoomGroup_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_EndMiniGameForChatRoomGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_EndMiniGameForChatRoomGroup_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_EndMiniGameForChatRoomGroup_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_EndMiniGameForChatRoomGroup_Response {
    fn default() -> &'a CChatRoom_EndMiniGameForChatRoomGroup_Response {
        <CChatRoom_EndMiniGameForChatRoomGroup_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_EndMiniGameForChatRoomGroup_Response {
    pub fn new() -> CChatRoom_EndMiniGameForChatRoomGroup_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_EndMiniGameForChatRoomGroup_Response>(
            "CChatRoom_EndMiniGameForChatRoomGroup_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_EndMiniGameForChatRoomGroup_Response {
    const NAME: &'static str = "CChatRoom_EndMiniGameForChatRoomGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_EndMiniGameForChatRoomGroup_Response {
        CChatRoom_EndMiniGameForChatRoomGroup_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_EndMiniGameForChatRoomGroup_Response {
        static instance: CChatRoom_EndMiniGameForChatRoomGroup_Response = CChatRoom_EndMiniGameForChatRoomGroup_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_EndMiniGameForChatRoomGroup_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_EndMiniGameForChatRoomGroup_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_EndMiniGameForChatRoomGroup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_EndMiniGameForChatRoomGroup_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_MuteUser_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_MuteUser_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_MuteUser_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_MuteUser_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_MuteUser_Request.expiration)
    pub expiration: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_MuteUser_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_MuteUser_Request {
    fn default() -> &'a CChatRoom_MuteUser_Request {
        <CChatRoom_MuteUser_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_MuteUser_Request {
    pub fn new() -> CChatRoom_MuteUser_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 2;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional int32 expiration = 3;

    pub fn expiration(&self) -> i32 {
        self.expiration.unwrap_or(0)
    }

    pub fn clear_expiration(&mut self) {
        self.expiration = ::std::option::Option::None;
    }

    pub fn has_expiration(&self) -> bool {
        self.expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration(&mut self, v: i32) {
        self.expiration = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_MuteUser_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_MuteUser_Request| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CChatRoom_MuteUser_Request| { &m.steamid },
            |m: &mut CChatRoom_MuteUser_Request| { &mut m.steamid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expiration",
            |m: &CChatRoom_MuteUser_Request| { &m.expiration },
            |m: &mut CChatRoom_MuteUser_Request| { &mut m.expiration },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_MuteUser_Request>(
            "CChatRoom_MuteUser_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_MuteUser_Request {
    const NAME: &'static str = "CChatRoom_MuteUser_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.expiration = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.expiration {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.expiration {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_MuteUser_Request {
        CChatRoom_MuteUser_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.expiration = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_MuteUser_Request {
        static instance: CChatRoom_MuteUser_Request = CChatRoom_MuteUser_Request {
            chat_group_id: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            expiration: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_MuteUser_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_MuteUser_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_MuteUser_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_MuteUser_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_MuteUser_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_MuteUser_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_MuteUser_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_MuteUser_Response {
    fn default() -> &'a CChatRoom_MuteUser_Response {
        <CChatRoom_MuteUser_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_MuteUser_Response {
    pub fn new() -> CChatRoom_MuteUser_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_MuteUser_Response>(
            "CChatRoom_MuteUser_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_MuteUser_Response {
    const NAME: &'static str = "CChatRoom_MuteUser_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_MuteUser_Response {
        CChatRoom_MuteUser_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_MuteUser_Response {
        static instance: CChatRoom_MuteUser_Response = CChatRoom_MuteUser_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_MuteUser_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_MuteUser_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_MuteUser_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_MuteUser_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_KickUser_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_KickUser_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_KickUser_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_KickUser_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_KickUser_Request.expiration)
    pub expiration: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_KickUser_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_KickUser_Request {
    fn default() -> &'a CChatRoom_KickUser_Request {
        <CChatRoom_KickUser_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_KickUser_Request {
    pub fn new() -> CChatRoom_KickUser_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 2;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional int32 expiration = 3;

    pub fn expiration(&self) -> i32 {
        self.expiration.unwrap_or(0)
    }

    pub fn clear_expiration(&mut self) {
        self.expiration = ::std::option::Option::None;
    }

    pub fn has_expiration(&self) -> bool {
        self.expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration(&mut self, v: i32) {
        self.expiration = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_KickUser_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_KickUser_Request| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CChatRoom_KickUser_Request| { &m.steamid },
            |m: &mut CChatRoom_KickUser_Request| { &mut m.steamid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expiration",
            |m: &CChatRoom_KickUser_Request| { &m.expiration },
            |m: &mut CChatRoom_KickUser_Request| { &mut m.expiration },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_KickUser_Request>(
            "CChatRoom_KickUser_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_KickUser_Request {
    const NAME: &'static str = "CChatRoom_KickUser_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.expiration = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.expiration {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.expiration {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_KickUser_Request {
        CChatRoom_KickUser_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.expiration = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_KickUser_Request {
        static instance: CChatRoom_KickUser_Request = CChatRoom_KickUser_Request {
            chat_group_id: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            expiration: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_KickUser_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_KickUser_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_KickUser_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_KickUser_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_KickUser_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_KickUser_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_KickUser_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_KickUser_Response {
    fn default() -> &'a CChatRoom_KickUser_Response {
        <CChatRoom_KickUser_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_KickUser_Response {
    pub fn new() -> CChatRoom_KickUser_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_KickUser_Response>(
            "CChatRoom_KickUser_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_KickUser_Response {
    const NAME: &'static str = "CChatRoom_KickUser_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_KickUser_Response {
        CChatRoom_KickUser_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_KickUser_Response {
        static instance: CChatRoom_KickUser_Response = CChatRoom_KickUser_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_KickUser_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_KickUser_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_KickUser_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_KickUser_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_SetUserBanState_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetUserBanState_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SetUserBanState_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SetUserBanState_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SetUserBanState_Request.ban_state)
    pub ban_state: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetUserBanState_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetUserBanState_Request {
    fn default() -> &'a CChatRoom_SetUserBanState_Request {
        <CChatRoom_SetUserBanState_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetUserBanState_Request {
    pub fn new() -> CChatRoom_SetUserBanState_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 2;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional bool ban_state = 3;

    pub fn ban_state(&self) -> bool {
        self.ban_state.unwrap_or(false)
    }

    pub fn clear_ban_state(&mut self) {
        self.ban_state = ::std::option::Option::None;
    }

    pub fn has_ban_state(&self) -> bool {
        self.ban_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ban_state(&mut self, v: bool) {
        self.ban_state = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_SetUserBanState_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_SetUserBanState_Request| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CChatRoom_SetUserBanState_Request| { &m.steamid },
            |m: &mut CChatRoom_SetUserBanState_Request| { &mut m.steamid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ban_state",
            |m: &CChatRoom_SetUserBanState_Request| { &m.ban_state },
            |m: &mut CChatRoom_SetUserBanState_Request| { &mut m.ban_state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SetUserBanState_Request>(
            "CChatRoom_SetUserBanState_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_SetUserBanState_Request {
    const NAME: &'static str = "CChatRoom_SetUserBanState_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.ban_state = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.ban_state {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.ban_state {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetUserBanState_Request {
        CChatRoom_SetUserBanState_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.ban_state = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetUserBanState_Request {
        static instance: CChatRoom_SetUserBanState_Request = CChatRoom_SetUserBanState_Request {
            chat_group_id: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            ban_state: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_SetUserBanState_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SetUserBanState_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SetUserBanState_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetUserBanState_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_SetUserBanState_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetUserBanState_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetUserBanState_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetUserBanState_Response {
    fn default() -> &'a CChatRoom_SetUserBanState_Response {
        <CChatRoom_SetUserBanState_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetUserBanState_Response {
    pub fn new() -> CChatRoom_SetUserBanState_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SetUserBanState_Response>(
            "CChatRoom_SetUserBanState_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_SetUserBanState_Response {
    const NAME: &'static str = "CChatRoom_SetUserBanState_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetUserBanState_Response {
        CChatRoom_SetUserBanState_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetUserBanState_Response {
        static instance: CChatRoom_SetUserBanState_Response = CChatRoom_SetUserBanState_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_SetUserBanState_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SetUserBanState_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SetUserBanState_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetUserBanState_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_RevokeInvite_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_RevokeInvite_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_RevokeInvite_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_RevokeInvite_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_RevokeInvite_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_RevokeInvite_Request {
    fn default() -> &'a CChatRoom_RevokeInvite_Request {
        <CChatRoom_RevokeInvite_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_RevokeInvite_Request {
    pub fn new() -> CChatRoom_RevokeInvite_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 2;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_RevokeInvite_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_RevokeInvite_Request| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CChatRoom_RevokeInvite_Request| { &m.steamid },
            |m: &mut CChatRoom_RevokeInvite_Request| { &mut m.steamid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_RevokeInvite_Request>(
            "CChatRoom_RevokeInvite_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_RevokeInvite_Request {
    const NAME: &'static str = "CChatRoom_RevokeInvite_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_RevokeInvite_Request {
        CChatRoom_RevokeInvite_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_RevokeInvite_Request {
        static instance: CChatRoom_RevokeInvite_Request = CChatRoom_RevokeInvite_Request {
            chat_group_id: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_RevokeInvite_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_RevokeInvite_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_RevokeInvite_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_RevokeInvite_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_RevokeInvite_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_RevokeInvite_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_RevokeInvite_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_RevokeInvite_Response {
    fn default() -> &'a CChatRoom_RevokeInvite_Response {
        <CChatRoom_RevokeInvite_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_RevokeInvite_Response {
    pub fn new() -> CChatRoom_RevokeInvite_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_RevokeInvite_Response>(
            "CChatRoom_RevokeInvite_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_RevokeInvite_Response {
    const NAME: &'static str = "CChatRoom_RevokeInvite_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_RevokeInvite_Response {
        CChatRoom_RevokeInvite_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_RevokeInvite_Response {
        static instance: CChatRoom_RevokeInvite_Response = CChatRoom_RevokeInvite_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_RevokeInvite_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_RevokeInvite_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_RevokeInvite_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_RevokeInvite_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_CreateRole_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_CreateRole_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_CreateRole_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_CreateRole_Request.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_CreateRole_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_CreateRole_Request {
    fn default() -> &'a CChatRoom_CreateRole_Request {
        <CChatRoom_CreateRole_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_CreateRole_Request {
    pub fn new() -> CChatRoom_CreateRole_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_CreateRole_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_CreateRole_Request| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CChatRoom_CreateRole_Request| { &m.name },
            |m: &mut CChatRoom_CreateRole_Request| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_CreateRole_Request>(
            "CChatRoom_CreateRole_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_CreateRole_Request {
    const NAME: &'static str = "CChatRoom_CreateRole_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_CreateRole_Request {
        CChatRoom_CreateRole_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_CreateRole_Request {
        static instance: CChatRoom_CreateRole_Request = CChatRoom_CreateRole_Request {
            chat_group_id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_CreateRole_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_CreateRole_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_CreateRole_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_CreateRole_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_CreateRole_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_CreateRole_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_CreateRole_Response.actions)
    pub actions: ::protobuf::MessageField<CChatRoleActions>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_CreateRole_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_CreateRole_Response {
    fn default() -> &'a CChatRoom_CreateRole_Response {
        <CChatRoom_CreateRole_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_CreateRole_Response {
    pub fn new() -> CChatRoom_CreateRole_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CChatRoleActions>(
            "actions",
            |m: &CChatRoom_CreateRole_Response| { &m.actions },
            |m: &mut CChatRoom_CreateRole_Response| { &mut m.actions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_CreateRole_Response>(
            "CChatRoom_CreateRole_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_CreateRole_Response {
    const NAME: &'static str = "CChatRoom_CreateRole_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.actions)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.actions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.actions.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_CreateRole_Response {
        CChatRoom_CreateRole_Response::new()
    }

    fn clear(&mut self) {
        self.actions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_CreateRole_Response {
        static instance: CChatRoom_CreateRole_Response = CChatRoom_CreateRole_Response {
            actions: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_CreateRole_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_CreateRole_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_CreateRole_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_CreateRole_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetRoles_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetRoles_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetRoles_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetRoles_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetRoles_Request {
    fn default() -> &'a CChatRoom_GetRoles_Request {
        <CChatRoom_GetRoles_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetRoles_Request {
    pub fn new() -> CChatRoom_GetRoles_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_GetRoles_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_GetRoles_Request| { &mut m.chat_group_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetRoles_Request>(
            "CChatRoom_GetRoles_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_GetRoles_Request {
    const NAME: &'static str = "CChatRoom_GetRoles_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetRoles_Request {
        CChatRoom_GetRoles_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetRoles_Request {
        static instance: CChatRoom_GetRoles_Request = CChatRoom_GetRoles_Request {
            chat_group_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_GetRoles_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetRoles_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetRoles_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetRoles_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetRoles_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetRoles_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetRoles_Response.roles)
    pub roles: ::std::vec::Vec<CChatRole>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetRoles_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetRoles_Response {
    fn default() -> &'a CChatRoom_GetRoles_Response {
        <CChatRoom_GetRoles_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetRoles_Response {
    pub fn new() -> CChatRoom_GetRoles_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "roles",
            |m: &CChatRoom_GetRoles_Response| { &m.roles },
            |m: &mut CChatRoom_GetRoles_Response| { &mut m.roles },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetRoles_Response>(
            "CChatRoom_GetRoles_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_GetRoles_Response {
    const NAME: &'static str = "CChatRoom_GetRoles_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.roles.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.roles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.roles {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetRoles_Response {
        CChatRoom_GetRoles_Response::new()
    }

    fn clear(&mut self) {
        self.roles.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetRoles_Response {
        static instance: CChatRoom_GetRoles_Response = CChatRoom_GetRoles_Response {
            roles: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_GetRoles_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetRoles_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetRoles_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetRoles_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_RenameRole_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_RenameRole_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_RenameRole_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_RenameRole_Request.role_id)
    pub role_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_RenameRole_Request.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_RenameRole_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_RenameRole_Request {
    fn default() -> &'a CChatRoom_RenameRole_Request {
        <CChatRoom_RenameRole_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_RenameRole_Request {
    pub fn new() -> CChatRoom_RenameRole_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 role_id = 2;

    pub fn role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }

    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_RenameRole_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_RenameRole_Request| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "role_id",
            |m: &CChatRoom_RenameRole_Request| { &m.role_id },
            |m: &mut CChatRoom_RenameRole_Request| { &mut m.role_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CChatRoom_RenameRole_Request| { &m.name },
            |m: &mut CChatRoom_RenameRole_Request| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_RenameRole_Request>(
            "CChatRoom_RenameRole_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_RenameRole_Request {
    const NAME: &'static str = "CChatRoom_RenameRole_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.role_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.role_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.role_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_RenameRole_Request {
        CChatRoom_RenameRole_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_RenameRole_Request {
        static instance: CChatRoom_RenameRole_Request = CChatRoom_RenameRole_Request {
            chat_group_id: ::std::option::Option::None,
            role_id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_RenameRole_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_RenameRole_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_RenameRole_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_RenameRole_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_RenameRole_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_RenameRole_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_RenameRole_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_RenameRole_Response {
    fn default() -> &'a CChatRoom_RenameRole_Response {
        <CChatRoom_RenameRole_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_RenameRole_Response {
    pub fn new() -> CChatRoom_RenameRole_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_RenameRole_Response>(
            "CChatRoom_RenameRole_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_RenameRole_Response {
    const NAME: &'static str = "CChatRoom_RenameRole_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_RenameRole_Response {
        CChatRoom_RenameRole_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_RenameRole_Response {
        static instance: CChatRoom_RenameRole_Response = CChatRoom_RenameRole_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_RenameRole_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_RenameRole_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_RenameRole_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_RenameRole_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_ReorderRole_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_ReorderRole_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_ReorderRole_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_ReorderRole_Request.role_id)
    pub role_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_ReorderRole_Request.ordinal)
    pub ordinal: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_ReorderRole_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ReorderRole_Request {
    fn default() -> &'a CChatRoom_ReorderRole_Request {
        <CChatRoom_ReorderRole_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_ReorderRole_Request {
    pub fn new() -> CChatRoom_ReorderRole_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 role_id = 2;

    pub fn role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }

    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }

    // optional uint32 ordinal = 3;

    pub fn ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }

    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_ReorderRole_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_ReorderRole_Request| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "role_id",
            |m: &CChatRoom_ReorderRole_Request| { &m.role_id },
            |m: &mut CChatRoom_ReorderRole_Request| { &mut m.role_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ordinal",
            |m: &CChatRoom_ReorderRole_Request| { &m.ordinal },
            |m: &mut CChatRoom_ReorderRole_Request| { &mut m.ordinal },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_ReorderRole_Request>(
            "CChatRoom_ReorderRole_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_ReorderRole_Request {
    const NAME: &'static str = "CChatRoom_ReorderRole_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.role_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.ordinal = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.role_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.ordinal {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.role_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_ReorderRole_Request {
        CChatRoom_ReorderRole_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.ordinal = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_ReorderRole_Request {
        static instance: CChatRoom_ReorderRole_Request = CChatRoom_ReorderRole_Request {
            chat_group_id: ::std::option::Option::None,
            role_id: ::std::option::Option::None,
            ordinal: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_ReorderRole_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_ReorderRole_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_ReorderRole_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_ReorderRole_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_ReorderRole_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_ReorderRole_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_ReorderRole_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ReorderRole_Response {
    fn default() -> &'a CChatRoom_ReorderRole_Response {
        <CChatRoom_ReorderRole_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_ReorderRole_Response {
    pub fn new() -> CChatRoom_ReorderRole_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_ReorderRole_Response>(
            "CChatRoom_ReorderRole_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_ReorderRole_Response {
    const NAME: &'static str = "CChatRoom_ReorderRole_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_ReorderRole_Response {
        CChatRoom_ReorderRole_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_ReorderRole_Response {
        static instance: CChatRoom_ReorderRole_Response = CChatRoom_ReorderRole_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_ReorderRole_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_ReorderRole_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_ReorderRole_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_ReorderRole_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_DeleteRole_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_DeleteRole_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_DeleteRole_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_DeleteRole_Request.role_id)
    pub role_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_DeleteRole_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteRole_Request {
    fn default() -> &'a CChatRoom_DeleteRole_Request {
        <CChatRoom_DeleteRole_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteRole_Request {
    pub fn new() -> CChatRoom_DeleteRole_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 role_id = 2;

    pub fn role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }

    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_DeleteRole_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_DeleteRole_Request| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "role_id",
            |m: &CChatRoom_DeleteRole_Request| { &m.role_id },
            |m: &mut CChatRoom_DeleteRole_Request| { &mut m.role_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_DeleteRole_Request>(
            "CChatRoom_DeleteRole_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_DeleteRole_Request {
    const NAME: &'static str = "CChatRoom_DeleteRole_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.role_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.role_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.role_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_DeleteRole_Request {
        CChatRoom_DeleteRole_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_DeleteRole_Request {
        static instance: CChatRoom_DeleteRole_Request = CChatRoom_DeleteRole_Request {
            chat_group_id: ::std::option::Option::None,
            role_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_DeleteRole_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_DeleteRole_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_DeleteRole_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_DeleteRole_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_DeleteRole_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_DeleteRole_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_DeleteRole_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteRole_Response {
    fn default() -> &'a CChatRoom_DeleteRole_Response {
        <CChatRoom_DeleteRole_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteRole_Response {
    pub fn new() -> CChatRoom_DeleteRole_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_DeleteRole_Response>(
            "CChatRoom_DeleteRole_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_DeleteRole_Response {
    const NAME: &'static str = "CChatRoom_DeleteRole_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_DeleteRole_Response {
        CChatRoom_DeleteRole_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_DeleteRole_Response {
        static instance: CChatRoom_DeleteRole_Response = CChatRoom_DeleteRole_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_DeleteRole_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_DeleteRole_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_DeleteRole_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_DeleteRole_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetRoleActions_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetRoleActions_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetRoleActions_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetRoleActions_Request.role_id)
    pub role_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetRoleActions_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetRoleActions_Request {
    fn default() -> &'a CChatRoom_GetRoleActions_Request {
        <CChatRoom_GetRoleActions_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetRoleActions_Request {
    pub fn new() -> CChatRoom_GetRoleActions_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 role_id = 2;

    pub fn role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }

    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_GetRoleActions_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_GetRoleActions_Request| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "role_id",
            |m: &CChatRoom_GetRoleActions_Request| { &m.role_id },
            |m: &mut CChatRoom_GetRoleActions_Request| { &mut m.role_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetRoleActions_Request>(
            "CChatRoom_GetRoleActions_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_GetRoleActions_Request {
    const NAME: &'static str = "CChatRoom_GetRoleActions_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.role_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.role_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.role_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetRoleActions_Request {
        CChatRoom_GetRoleActions_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetRoleActions_Request {
        static instance: CChatRoom_GetRoleActions_Request = CChatRoom_GetRoleActions_Request {
            chat_group_id: ::std::option::Option::None,
            role_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_GetRoleActions_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetRoleActions_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetRoleActions_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetRoleActions_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetRoleActions_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetRoleActions_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetRoleActions_Response.actions)
    pub actions: ::std::vec::Vec<CChatRoleActions>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetRoleActions_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetRoleActions_Response {
    fn default() -> &'a CChatRoom_GetRoleActions_Response {
        <CChatRoom_GetRoleActions_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetRoleActions_Response {
    pub fn new() -> CChatRoom_GetRoleActions_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "actions",
            |m: &CChatRoom_GetRoleActions_Response| { &m.actions },
            |m: &mut CChatRoom_GetRoleActions_Response| { &mut m.actions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetRoleActions_Response>(
            "CChatRoom_GetRoleActions_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_GetRoleActions_Response {
    const NAME: &'static str = "CChatRoom_GetRoleActions_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.actions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.actions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.actions {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetRoleActions_Response {
        CChatRoom_GetRoleActions_Response::new()
    }

    fn clear(&mut self) {
        self.actions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetRoleActions_Response {
        static instance: CChatRoom_GetRoleActions_Response = CChatRoom_GetRoleActions_Response {
            actions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_GetRoleActions_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetRoleActions_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetRoleActions_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetRoleActions_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_ReplaceRoleActions_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_ReplaceRoleActions_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_ReplaceRoleActions_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_ReplaceRoleActions_Request.role_id)
    pub role_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_ReplaceRoleActions_Request.actions)
    pub actions: ::protobuf::MessageField<CChatRoleActions>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_ReplaceRoleActions_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ReplaceRoleActions_Request {
    fn default() -> &'a CChatRoom_ReplaceRoleActions_Request {
        <CChatRoom_ReplaceRoleActions_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_ReplaceRoleActions_Request {
    pub fn new() -> CChatRoom_ReplaceRoleActions_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 role_id = 2;

    pub fn role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }

    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_ReplaceRoleActions_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_ReplaceRoleActions_Request| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "role_id",
            |m: &CChatRoom_ReplaceRoleActions_Request| { &m.role_id },
            |m: &mut CChatRoom_ReplaceRoleActions_Request| { &mut m.role_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CChatRoleActions>(
            "actions",
            |m: &CChatRoom_ReplaceRoleActions_Request| { &m.actions },
            |m: &mut CChatRoom_ReplaceRoleActions_Request| { &mut m.actions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_ReplaceRoleActions_Request>(
            "CChatRoom_ReplaceRoleActions_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_ReplaceRoleActions_Request {
    const NAME: &'static str = "CChatRoom_ReplaceRoleActions_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.role_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.actions)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.role_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.actions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.role_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.actions.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_ReplaceRoleActions_Request {
        CChatRoom_ReplaceRoleActions_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.actions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_ReplaceRoleActions_Request {
        static instance: CChatRoom_ReplaceRoleActions_Request = CChatRoom_ReplaceRoleActions_Request {
            chat_group_id: ::std::option::Option::None,
            role_id: ::std::option::Option::None,
            actions: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_ReplaceRoleActions_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_ReplaceRoleActions_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_ReplaceRoleActions_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_ReplaceRoleActions_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_ReplaceRoleActions_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_ReplaceRoleActions_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_ReplaceRoleActions_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ReplaceRoleActions_Response {
    fn default() -> &'a CChatRoom_ReplaceRoleActions_Response {
        <CChatRoom_ReplaceRoleActions_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_ReplaceRoleActions_Response {
    pub fn new() -> CChatRoom_ReplaceRoleActions_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_ReplaceRoleActions_Response>(
            "CChatRoom_ReplaceRoleActions_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_ReplaceRoleActions_Response {
    const NAME: &'static str = "CChatRoom_ReplaceRoleActions_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_ReplaceRoleActions_Response {
        CChatRoom_ReplaceRoleActions_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_ReplaceRoleActions_Response {
        static instance: CChatRoom_ReplaceRoleActions_Response = CChatRoom_ReplaceRoleActions_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_ReplaceRoleActions_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_ReplaceRoleActions_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_ReplaceRoleActions_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_ReplaceRoleActions_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_AddRoleToUser_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_AddRoleToUser_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_AddRoleToUser_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_AddRoleToUser_Request.role_id)
    pub role_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_AddRoleToUser_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_AddRoleToUser_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_AddRoleToUser_Request {
    fn default() -> &'a CChatRoom_AddRoleToUser_Request {
        <CChatRoom_AddRoleToUser_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_AddRoleToUser_Request {
    pub fn new() -> CChatRoom_AddRoleToUser_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 role_id = 3;

    pub fn role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }

    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 4;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_AddRoleToUser_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_AddRoleToUser_Request| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "role_id",
            |m: &CChatRoom_AddRoleToUser_Request| { &m.role_id },
            |m: &mut CChatRoom_AddRoleToUser_Request| { &mut m.role_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CChatRoom_AddRoleToUser_Request| { &m.steamid },
            |m: &mut CChatRoom_AddRoleToUser_Request| { &mut m.steamid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_AddRoleToUser_Request>(
            "CChatRoom_AddRoleToUser_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_AddRoleToUser_Request {
    const NAME: &'static str = "CChatRoom_AddRoleToUser_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.role_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                33 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.role_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.role_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_AddRoleToUser_Request {
        CChatRoom_AddRoleToUser_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_AddRoleToUser_Request {
        static instance: CChatRoom_AddRoleToUser_Request = CChatRoom_AddRoleToUser_Request {
            chat_group_id: ::std::option::Option::None,
            role_id: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_AddRoleToUser_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_AddRoleToUser_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_AddRoleToUser_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_AddRoleToUser_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_AddRoleToUser_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_AddRoleToUser_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_AddRoleToUser_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_AddRoleToUser_Response {
    fn default() -> &'a CChatRoom_AddRoleToUser_Response {
        <CChatRoom_AddRoleToUser_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_AddRoleToUser_Response {
    pub fn new() -> CChatRoom_AddRoleToUser_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_AddRoleToUser_Response>(
            "CChatRoom_AddRoleToUser_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_AddRoleToUser_Response {
    const NAME: &'static str = "CChatRoom_AddRoleToUser_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_AddRoleToUser_Response {
        CChatRoom_AddRoleToUser_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_AddRoleToUser_Response {
        static instance: CChatRoom_AddRoleToUser_Response = CChatRoom_AddRoleToUser_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_AddRoleToUser_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_AddRoleToUser_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_AddRoleToUser_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_AddRoleToUser_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetRolesForUser_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetRolesForUser_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetRolesForUser_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetRolesForUser_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetRolesForUser_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetRolesForUser_Request {
    fn default() -> &'a CChatRoom_GetRolesForUser_Request {
        <CChatRoom_GetRolesForUser_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetRolesForUser_Request {
    pub fn new() -> CChatRoom_GetRolesForUser_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 3;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_GetRolesForUser_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_GetRolesForUser_Request| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CChatRoom_GetRolesForUser_Request| { &m.steamid },
            |m: &mut CChatRoom_GetRolesForUser_Request| { &mut m.steamid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetRolesForUser_Request>(
            "CChatRoom_GetRolesForUser_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_GetRolesForUser_Request {
    const NAME: &'static str = "CChatRoom_GetRolesForUser_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                25 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetRolesForUser_Request {
        CChatRoom_GetRolesForUser_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetRolesForUser_Request {
        static instance: CChatRoom_GetRolesForUser_Request = CChatRoom_GetRolesForUser_Request {
            chat_group_id: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_GetRolesForUser_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetRolesForUser_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetRolesForUser_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetRolesForUser_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetRolesForUser_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetRolesForUser_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetRolesForUser_Response.role_ids)
    pub role_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetRolesForUser_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetRolesForUser_Response {
    fn default() -> &'a CChatRoom_GetRolesForUser_Response {
        <CChatRoom_GetRolesForUser_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetRolesForUser_Response {
    pub fn new() -> CChatRoom_GetRolesForUser_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "role_ids",
            |m: &CChatRoom_GetRolesForUser_Response| { &m.role_ids },
            |m: &mut CChatRoom_GetRolesForUser_Response| { &mut m.role_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetRolesForUser_Response>(
            "CChatRoom_GetRolesForUser_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_GetRolesForUser_Response {
    const NAME: &'static str = "CChatRoom_GetRolesForUser_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.role_ids)?;
                },
                8 => {
                    self.role_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.role_ids {
            my_size += ::protobuf::rt::uint64_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.role_ids {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetRolesForUser_Response {
        CChatRoom_GetRolesForUser_Response::new()
    }

    fn clear(&mut self) {
        self.role_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetRolesForUser_Response {
        static instance: CChatRoom_GetRolesForUser_Response = CChatRoom_GetRolesForUser_Response {
            role_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_GetRolesForUser_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetRolesForUser_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetRolesForUser_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetRolesForUser_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_DeleteRoleFromUser_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_DeleteRoleFromUser_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_DeleteRoleFromUser_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_DeleteRoleFromUser_Request.role_id)
    pub role_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_DeleteRoleFromUser_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_DeleteRoleFromUser_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteRoleFromUser_Request {
    fn default() -> &'a CChatRoom_DeleteRoleFromUser_Request {
        <CChatRoom_DeleteRoleFromUser_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteRoleFromUser_Request {
    pub fn new() -> CChatRoom_DeleteRoleFromUser_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 role_id = 3;

    pub fn role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }

    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 4;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_DeleteRoleFromUser_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_DeleteRoleFromUser_Request| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "role_id",
            |m: &CChatRoom_DeleteRoleFromUser_Request| { &m.role_id },
            |m: &mut CChatRoom_DeleteRoleFromUser_Request| { &mut m.role_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CChatRoom_DeleteRoleFromUser_Request| { &m.steamid },
            |m: &mut CChatRoom_DeleteRoleFromUser_Request| { &mut m.steamid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_DeleteRoleFromUser_Request>(
            "CChatRoom_DeleteRoleFromUser_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_DeleteRoleFromUser_Request {
    const NAME: &'static str = "CChatRoom_DeleteRoleFromUser_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.role_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                33 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.role_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.role_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_DeleteRoleFromUser_Request {
        CChatRoom_DeleteRoleFromUser_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_DeleteRoleFromUser_Request {
        static instance: CChatRoom_DeleteRoleFromUser_Request = CChatRoom_DeleteRoleFromUser_Request {
            chat_group_id: ::std::option::Option::None,
            role_id: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_DeleteRoleFromUser_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_DeleteRoleFromUser_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_DeleteRoleFromUser_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_DeleteRoleFromUser_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_DeleteRoleFromUser_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_DeleteRoleFromUser_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_DeleteRoleFromUser_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteRoleFromUser_Response {
    fn default() -> &'a CChatRoom_DeleteRoleFromUser_Response {
        <CChatRoom_DeleteRoleFromUser_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteRoleFromUser_Response {
    pub fn new() -> CChatRoom_DeleteRoleFromUser_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_DeleteRoleFromUser_Response>(
            "CChatRoom_DeleteRoleFromUser_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_DeleteRoleFromUser_Response {
    const NAME: &'static str = "CChatRoom_DeleteRoleFromUser_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_DeleteRoleFromUser_Response {
        CChatRoom_DeleteRoleFromUser_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_DeleteRoleFromUser_Response {
        static instance: CChatRoom_DeleteRoleFromUser_Response = CChatRoom_DeleteRoleFromUser_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_DeleteRoleFromUser_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_DeleteRoleFromUser_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_DeleteRoleFromUser_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_DeleteRoleFromUser_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_JoinChatRoomGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_JoinChatRoomGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_JoinChatRoomGroup_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_JoinChatRoomGroup_Request.invite_code)
    pub invite_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_JoinChatRoomGroup_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_JoinChatRoomGroup_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_JoinChatRoomGroup_Request {
    fn default() -> &'a CChatRoom_JoinChatRoomGroup_Request {
        <CChatRoom_JoinChatRoomGroup_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_JoinChatRoomGroup_Request {
    pub fn new() -> CChatRoom_JoinChatRoomGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string invite_code = 2;

    pub fn invite_code(&self) -> &str {
        match self.invite_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_invite_code(&mut self) {
        self.invite_code = ::std::option::Option::None;
    }

    pub fn has_invite_code(&self) -> bool {
        self.invite_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invite_code(&mut self, v: ::std::string::String) {
        self.invite_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_invite_code(&mut self) -> &mut ::std::string::String {
        if self.invite_code.is_none() {
            self.invite_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.invite_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_invite_code(&mut self) -> ::std::string::String {
        self.invite_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 chat_id = 3;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_JoinChatRoomGroup_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_JoinChatRoomGroup_Request| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "invite_code",
            |m: &CChatRoom_JoinChatRoomGroup_Request| { &m.invite_code },
            |m: &mut CChatRoom_JoinChatRoomGroup_Request| { &mut m.invite_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_JoinChatRoomGroup_Request| { &m.chat_id },
            |m: &mut CChatRoom_JoinChatRoomGroup_Request| { &mut m.chat_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_JoinChatRoomGroup_Request>(
            "CChatRoom_JoinChatRoomGroup_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_JoinChatRoomGroup_Request {
    const NAME: &'static str = "CChatRoom_JoinChatRoomGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.invite_code = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.invite_code.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.invite_code.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_JoinChatRoomGroup_Request {
        CChatRoom_JoinChatRoomGroup_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.invite_code = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_JoinChatRoomGroup_Request {
        static instance: CChatRoom_JoinChatRoomGroup_Request = CChatRoom_JoinChatRoomGroup_Request {
            chat_group_id: ::std::option::Option::None,
            invite_code: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_JoinChatRoomGroup_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_JoinChatRoomGroup_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_JoinChatRoomGroup_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_JoinChatRoomGroup_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_JoinChatRoomGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_JoinChatRoomGroup_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_JoinChatRoomGroup_Response.state)
    pub state: ::protobuf::MessageField<CChatRoomGroupState>,
    // @@protoc_insertion_point(field:CChatRoom_JoinChatRoomGroup_Response.user_chat_state)
    pub user_chat_state: ::protobuf::MessageField<CUserChatRoomGroupState>,
    // @@protoc_insertion_point(field:CChatRoom_JoinChatRoomGroup_Response.join_chat_id)
    pub join_chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_JoinChatRoomGroup_Response.time_expire)
    pub time_expire: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_JoinChatRoomGroup_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_JoinChatRoomGroup_Response {
    fn default() -> &'a CChatRoom_JoinChatRoomGroup_Response {
        <CChatRoom_JoinChatRoomGroup_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_JoinChatRoomGroup_Response {
    pub fn new() -> CChatRoom_JoinChatRoomGroup_Response {
        ::std::default::Default::default()
    }

    // optional uint64 join_chat_id = 4;

    pub fn join_chat_id(&self) -> u64 {
        self.join_chat_id.unwrap_or(0)
    }

    pub fn clear_join_chat_id(&mut self) {
        self.join_chat_id = ::std::option::Option::None;
    }

    pub fn has_join_chat_id(&self) -> bool {
        self.join_chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_join_chat_id(&mut self, v: u64) {
        self.join_chat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 time_expire = 5;

    pub fn time_expire(&self) -> u32 {
        self.time_expire.unwrap_or(0)
    }

    pub fn clear_time_expire(&mut self) {
        self.time_expire = ::std::option::Option::None;
    }

    pub fn has_time_expire(&self) -> bool {
        self.time_expire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_expire(&mut self, v: u32) {
        self.time_expire = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CChatRoomGroupState>(
            "state",
            |m: &CChatRoom_JoinChatRoomGroup_Response| { &m.state },
            |m: &mut CChatRoom_JoinChatRoomGroup_Response| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CUserChatRoomGroupState>(
            "user_chat_state",
            |m: &CChatRoom_JoinChatRoomGroup_Response| { &m.user_chat_state },
            |m: &mut CChatRoom_JoinChatRoomGroup_Response| { &mut m.user_chat_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "join_chat_id",
            |m: &CChatRoom_JoinChatRoomGroup_Response| { &m.join_chat_id },
            |m: &mut CChatRoom_JoinChatRoomGroup_Response| { &mut m.join_chat_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_expire",
            |m: &CChatRoom_JoinChatRoomGroup_Response| { &m.time_expire },
            |m: &mut CChatRoom_JoinChatRoomGroup_Response| { &mut m.time_expire },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_JoinChatRoomGroup_Response>(
            "CChatRoom_JoinChatRoomGroup_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_JoinChatRoomGroup_Response {
    const NAME: &'static str = "CChatRoom_JoinChatRoomGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.state)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_chat_state)?;
                },
                32 => {
                    self.join_chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.time_expire = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.user_chat_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.join_chat_id {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.time_expire {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.user_chat_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.join_chat_id {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.time_expire {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_JoinChatRoomGroup_Response {
        CChatRoom_JoinChatRoomGroup_Response::new()
    }

    fn clear(&mut self) {
        self.state.clear();
        self.user_chat_state.clear();
        self.join_chat_id = ::std::option::Option::None;
        self.time_expire = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_JoinChatRoomGroup_Response {
        static instance: CChatRoom_JoinChatRoomGroup_Response = CChatRoom_JoinChatRoomGroup_Response {
            state: ::protobuf::MessageField::none(),
            user_chat_state: ::protobuf::MessageField::none(),
            join_chat_id: ::std::option::Option::None,
            time_expire: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_JoinChatRoomGroup_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_JoinChatRoomGroup_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_JoinChatRoomGroup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_JoinChatRoomGroup_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_InviteFriendToChatRoomGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_InviteFriendToChatRoomGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_InviteFriendToChatRoomGroup_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_InviteFriendToChatRoomGroup_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_InviteFriendToChatRoomGroup_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_InviteFriendToChatRoomGroup_Request.skip_friendsui_check)
    pub skip_friendsui_check: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_InviteFriendToChatRoomGroup_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_InviteFriendToChatRoomGroup_Request {
    fn default() -> &'a CChatRoom_InviteFriendToChatRoomGroup_Request {
        <CChatRoom_InviteFriendToChatRoomGroup_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_InviteFriendToChatRoomGroup_Request {
    pub fn new() -> CChatRoom_InviteFriendToChatRoomGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 2;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 3;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional bool skip_friendsui_check = 4;

    pub fn skip_friendsui_check(&self) -> bool {
        self.skip_friendsui_check.unwrap_or(false)
    }

    pub fn clear_skip_friendsui_check(&mut self) {
        self.skip_friendsui_check = ::std::option::Option::None;
    }

    pub fn has_skip_friendsui_check(&self) -> bool {
        self.skip_friendsui_check.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skip_friendsui_check(&mut self, v: bool) {
        self.skip_friendsui_check = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_InviteFriendToChatRoomGroup_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_InviteFriendToChatRoomGroup_Request| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CChatRoom_InviteFriendToChatRoomGroup_Request| { &m.steamid },
            |m: &mut CChatRoom_InviteFriendToChatRoomGroup_Request| { &mut m.steamid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_InviteFriendToChatRoomGroup_Request| { &m.chat_id },
            |m: &mut CChatRoom_InviteFriendToChatRoomGroup_Request| { &mut m.chat_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "skip_friendsui_check",
            |m: &CChatRoom_InviteFriendToChatRoomGroup_Request| { &m.skip_friendsui_check },
            |m: &mut CChatRoom_InviteFriendToChatRoomGroup_Request| { &mut m.skip_friendsui_check },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_InviteFriendToChatRoomGroup_Request>(
            "CChatRoom_InviteFriendToChatRoomGroup_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_InviteFriendToChatRoomGroup_Request {
    const NAME: &'static str = "CChatRoom_InviteFriendToChatRoomGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.skip_friendsui_check = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.skip_friendsui_check {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.skip_friendsui_check {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_InviteFriendToChatRoomGroup_Request {
        CChatRoom_InviteFriendToChatRoomGroup_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.skip_friendsui_check = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_InviteFriendToChatRoomGroup_Request {
        static instance: CChatRoom_InviteFriendToChatRoomGroup_Request = CChatRoom_InviteFriendToChatRoomGroup_Request {
            chat_group_id: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            skip_friendsui_check: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_InviteFriendToChatRoomGroup_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_InviteFriendToChatRoomGroup_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_InviteFriendToChatRoomGroup_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_InviteFriendToChatRoomGroup_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_InviteFriendToChatRoomGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_InviteFriendToChatRoomGroup_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_InviteFriendToChatRoomGroup_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_InviteFriendToChatRoomGroup_Response {
    fn default() -> &'a CChatRoom_InviteFriendToChatRoomGroup_Response {
        <CChatRoom_InviteFriendToChatRoomGroup_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_InviteFriendToChatRoomGroup_Response {
    pub fn new() -> CChatRoom_InviteFriendToChatRoomGroup_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_InviteFriendToChatRoomGroup_Response>(
            "CChatRoom_InviteFriendToChatRoomGroup_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_InviteFriendToChatRoomGroup_Response {
    const NAME: &'static str = "CChatRoom_InviteFriendToChatRoomGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_InviteFriendToChatRoomGroup_Response {
        CChatRoom_InviteFriendToChatRoomGroup_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_InviteFriendToChatRoomGroup_Response {
        static instance: CChatRoom_InviteFriendToChatRoomGroup_Response = CChatRoom_InviteFriendToChatRoomGroup_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_InviteFriendToChatRoomGroup_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_InviteFriendToChatRoomGroup_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_InviteFriendToChatRoomGroup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_InviteFriendToChatRoomGroup_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_LeaveChatRoomGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_LeaveChatRoomGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_LeaveChatRoomGroup_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_LeaveChatRoomGroup_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_LeaveChatRoomGroup_Request {
    fn default() -> &'a CChatRoom_LeaveChatRoomGroup_Request {
        <CChatRoom_LeaveChatRoomGroup_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_LeaveChatRoomGroup_Request {
    pub fn new() -> CChatRoom_LeaveChatRoomGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_LeaveChatRoomGroup_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_LeaveChatRoomGroup_Request| { &mut m.chat_group_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_LeaveChatRoomGroup_Request>(
            "CChatRoom_LeaveChatRoomGroup_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_LeaveChatRoomGroup_Request {
    const NAME: &'static str = "CChatRoom_LeaveChatRoomGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_LeaveChatRoomGroup_Request {
        CChatRoom_LeaveChatRoomGroup_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_LeaveChatRoomGroup_Request {
        static instance: CChatRoom_LeaveChatRoomGroup_Request = CChatRoom_LeaveChatRoomGroup_Request {
            chat_group_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_LeaveChatRoomGroup_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_LeaveChatRoomGroup_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_LeaveChatRoomGroup_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_LeaveChatRoomGroup_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_LeaveChatRoomGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_LeaveChatRoomGroup_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_LeaveChatRoomGroup_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_LeaveChatRoomGroup_Response {
    fn default() -> &'a CChatRoom_LeaveChatRoomGroup_Response {
        <CChatRoom_LeaveChatRoomGroup_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_LeaveChatRoomGroup_Response {
    pub fn new() -> CChatRoom_LeaveChatRoomGroup_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_LeaveChatRoomGroup_Response>(
            "CChatRoom_LeaveChatRoomGroup_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_LeaveChatRoomGroup_Response {
    const NAME: &'static str = "CChatRoom_LeaveChatRoomGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_LeaveChatRoomGroup_Response {
        CChatRoom_LeaveChatRoomGroup_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_LeaveChatRoomGroup_Response {
        static instance: CChatRoom_LeaveChatRoomGroup_Response = CChatRoom_LeaveChatRoomGroup_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_LeaveChatRoomGroup_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_LeaveChatRoomGroup_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_LeaveChatRoomGroup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_LeaveChatRoomGroup_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_CreateChatRoom_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_CreateChatRoom_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_CreateChatRoom_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_CreateChatRoom_Request.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_CreateChatRoom_Request.allow_voice)
    pub allow_voice: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_CreateChatRoom_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_CreateChatRoom_Request {
    fn default() -> &'a CChatRoom_CreateChatRoom_Request {
        <CChatRoom_CreateChatRoom_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_CreateChatRoom_Request {
    pub fn new() -> CChatRoom_CreateChatRoom_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool allow_voice = 3;

    pub fn allow_voice(&self) -> bool {
        self.allow_voice.unwrap_or(false)
    }

    pub fn clear_allow_voice(&mut self) {
        self.allow_voice = ::std::option::Option::None;
    }

    pub fn has_allow_voice(&self) -> bool {
        self.allow_voice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_voice(&mut self, v: bool) {
        self.allow_voice = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_CreateChatRoom_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_CreateChatRoom_Request| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CChatRoom_CreateChatRoom_Request| { &m.name },
            |m: &mut CChatRoom_CreateChatRoom_Request| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "allow_voice",
            |m: &CChatRoom_CreateChatRoom_Request| { &m.allow_voice },
            |m: &mut CChatRoom_CreateChatRoom_Request| { &mut m.allow_voice },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_CreateChatRoom_Request>(
            "CChatRoom_CreateChatRoom_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_CreateChatRoom_Request {
    const NAME: &'static str = "CChatRoom_CreateChatRoom_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.allow_voice = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.allow_voice {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.allow_voice {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_CreateChatRoom_Request {
        CChatRoom_CreateChatRoom_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.allow_voice = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_CreateChatRoom_Request {
        static instance: CChatRoom_CreateChatRoom_Request = CChatRoom_CreateChatRoom_Request {
            chat_group_id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            allow_voice: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_CreateChatRoom_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_CreateChatRoom_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_CreateChatRoom_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_CreateChatRoom_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_CreateChatRoom_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_CreateChatRoom_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_CreateChatRoom_Response.chat_room)
    pub chat_room: ::protobuf::MessageField<CChatRoomState>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_CreateChatRoom_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_CreateChatRoom_Response {
    fn default() -> &'a CChatRoom_CreateChatRoom_Response {
        <CChatRoom_CreateChatRoom_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_CreateChatRoom_Response {
    pub fn new() -> CChatRoom_CreateChatRoom_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CChatRoomState>(
            "chat_room",
            |m: &CChatRoom_CreateChatRoom_Response| { &m.chat_room },
            |m: &mut CChatRoom_CreateChatRoom_Response| { &mut m.chat_room },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_CreateChatRoom_Response>(
            "CChatRoom_CreateChatRoom_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_CreateChatRoom_Response {
    const NAME: &'static str = "CChatRoom_CreateChatRoom_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.chat_room)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_room.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_room.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_CreateChatRoom_Response {
        CChatRoom_CreateChatRoom_Response::new()
    }

    fn clear(&mut self) {
        self.chat_room.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_CreateChatRoom_Response {
        static instance: CChatRoom_CreateChatRoom_Response = CChatRoom_CreateChatRoom_Response {
            chat_room: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_CreateChatRoom_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_CreateChatRoom_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_CreateChatRoom_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_CreateChatRoom_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_DeleteChatRoom_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_DeleteChatRoom_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_DeleteChatRoom_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_DeleteChatRoom_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_DeleteChatRoom_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteChatRoom_Request {
    fn default() -> &'a CChatRoom_DeleteChatRoom_Request {
        <CChatRoom_DeleteChatRoom_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteChatRoom_Request {
    pub fn new() -> CChatRoom_DeleteChatRoom_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_DeleteChatRoom_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_DeleteChatRoom_Request| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_DeleteChatRoom_Request| { &m.chat_id },
            |m: &mut CChatRoom_DeleteChatRoom_Request| { &mut m.chat_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_DeleteChatRoom_Request>(
            "CChatRoom_DeleteChatRoom_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_DeleteChatRoom_Request {
    const NAME: &'static str = "CChatRoom_DeleteChatRoom_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_DeleteChatRoom_Request {
        CChatRoom_DeleteChatRoom_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_DeleteChatRoom_Request {
        static instance: CChatRoom_DeleteChatRoom_Request = CChatRoom_DeleteChatRoom_Request {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_DeleteChatRoom_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_DeleteChatRoom_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_DeleteChatRoom_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_DeleteChatRoom_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_DeleteChatRoom_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_DeleteChatRoom_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_DeleteChatRoom_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteChatRoom_Response {
    fn default() -> &'a CChatRoom_DeleteChatRoom_Response {
        <CChatRoom_DeleteChatRoom_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteChatRoom_Response {
    pub fn new() -> CChatRoom_DeleteChatRoom_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_DeleteChatRoom_Response>(
            "CChatRoom_DeleteChatRoom_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_DeleteChatRoom_Response {
    const NAME: &'static str = "CChatRoom_DeleteChatRoom_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_DeleteChatRoom_Response {
        CChatRoom_DeleteChatRoom_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_DeleteChatRoom_Response {
        static instance: CChatRoom_DeleteChatRoom_Response = CChatRoom_DeleteChatRoom_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_DeleteChatRoom_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_DeleteChatRoom_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_DeleteChatRoom_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_DeleteChatRoom_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_RenameChatRoom_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_RenameChatRoom_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_RenameChatRoom_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_RenameChatRoom_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_RenameChatRoom_Request.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_RenameChatRoom_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_RenameChatRoom_Request {
    fn default() -> &'a CChatRoom_RenameChatRoom_Request {
        <CChatRoom_RenameChatRoom_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_RenameChatRoom_Request {
    pub fn new() -> CChatRoom_RenameChatRoom_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_RenameChatRoom_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_RenameChatRoom_Request| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_RenameChatRoom_Request| { &m.chat_id },
            |m: &mut CChatRoom_RenameChatRoom_Request| { &mut m.chat_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CChatRoom_RenameChatRoom_Request| { &m.name },
            |m: &mut CChatRoom_RenameChatRoom_Request| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_RenameChatRoom_Request>(
            "CChatRoom_RenameChatRoom_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_RenameChatRoom_Request {
    const NAME: &'static str = "CChatRoom_RenameChatRoom_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_RenameChatRoom_Request {
        CChatRoom_RenameChatRoom_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_RenameChatRoom_Request {
        static instance: CChatRoom_RenameChatRoom_Request = CChatRoom_RenameChatRoom_Request {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_RenameChatRoom_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_RenameChatRoom_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_RenameChatRoom_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_RenameChatRoom_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_RenameChatRoom_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_RenameChatRoom_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_RenameChatRoom_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_RenameChatRoom_Response {
    fn default() -> &'a CChatRoom_RenameChatRoom_Response {
        <CChatRoom_RenameChatRoom_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_RenameChatRoom_Response {
    pub fn new() -> CChatRoom_RenameChatRoom_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_RenameChatRoom_Response>(
            "CChatRoom_RenameChatRoom_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_RenameChatRoom_Response {
    const NAME: &'static str = "CChatRoom_RenameChatRoom_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_RenameChatRoom_Response {
        CChatRoom_RenameChatRoom_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_RenameChatRoom_Response {
        static instance: CChatRoom_RenameChatRoom_Response = CChatRoom_RenameChatRoom_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_RenameChatRoom_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_RenameChatRoom_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_RenameChatRoom_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_RenameChatRoom_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_ReorderChatRoom_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_ReorderChatRoom_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_ReorderChatRoom_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_ReorderChatRoom_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_ReorderChatRoom_Request.move_after_chat_id)
    pub move_after_chat_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_ReorderChatRoom_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ReorderChatRoom_Request {
    fn default() -> &'a CChatRoom_ReorderChatRoom_Request {
        <CChatRoom_ReorderChatRoom_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_ReorderChatRoom_Request {
    pub fn new() -> CChatRoom_ReorderChatRoom_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint64 move_after_chat_id = 3;

    pub fn move_after_chat_id(&self) -> u64 {
        self.move_after_chat_id.unwrap_or(0)
    }

    pub fn clear_move_after_chat_id(&mut self) {
        self.move_after_chat_id = ::std::option::Option::None;
    }

    pub fn has_move_after_chat_id(&self) -> bool {
        self.move_after_chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_move_after_chat_id(&mut self, v: u64) {
        self.move_after_chat_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_ReorderChatRoom_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_ReorderChatRoom_Request| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_ReorderChatRoom_Request| { &m.chat_id },
            |m: &mut CChatRoom_ReorderChatRoom_Request| { &mut m.chat_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "move_after_chat_id",
            |m: &CChatRoom_ReorderChatRoom_Request| { &m.move_after_chat_id },
            |m: &mut CChatRoom_ReorderChatRoom_Request| { &mut m.move_after_chat_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_ReorderChatRoom_Request>(
            "CChatRoom_ReorderChatRoom_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_ReorderChatRoom_Request {
    const NAME: &'static str = "CChatRoom_ReorderChatRoom_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.move_after_chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.move_after_chat_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.move_after_chat_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_ReorderChatRoom_Request {
        CChatRoom_ReorderChatRoom_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.move_after_chat_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_ReorderChatRoom_Request {
        static instance: CChatRoom_ReorderChatRoom_Request = CChatRoom_ReorderChatRoom_Request {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            move_after_chat_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_ReorderChatRoom_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_ReorderChatRoom_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_ReorderChatRoom_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_ReorderChatRoom_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_ReorderChatRoom_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_ReorderChatRoom_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_ReorderChatRoom_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ReorderChatRoom_Response {
    fn default() -> &'a CChatRoom_ReorderChatRoom_Response {
        <CChatRoom_ReorderChatRoom_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_ReorderChatRoom_Response {
    pub fn new() -> CChatRoom_ReorderChatRoom_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_ReorderChatRoom_Response>(
            "CChatRoom_ReorderChatRoom_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_ReorderChatRoom_Response {
    const NAME: &'static str = "CChatRoom_ReorderChatRoom_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_ReorderChatRoom_Response {
        CChatRoom_ReorderChatRoom_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_ReorderChatRoom_Response {
        static instance: CChatRoom_ReorderChatRoom_Response = CChatRoom_ReorderChatRoom_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_ReorderChatRoom_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_ReorderChatRoom_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_ReorderChatRoom_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_ReorderChatRoom_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_SendChatMessage_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SendChatMessage_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SendChatMessage_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SendChatMessage_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SendChatMessage_Request.message)
    pub message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_SendChatMessage_Request.echo_to_sender)
    pub echo_to_sender: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SendChatMessage_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SendChatMessage_Request {
    fn default() -> &'a CChatRoom_SendChatMessage_Request {
        <CChatRoom_SendChatMessage_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SendChatMessage_Request {
    pub fn new() -> CChatRoom_SendChatMessage_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional string message = 3;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool echo_to_sender = 4;

    pub fn echo_to_sender(&self) -> bool {
        self.echo_to_sender.unwrap_or(false)
    }

    pub fn clear_echo_to_sender(&mut self) {
        self.echo_to_sender = ::std::option::Option::None;
    }

    pub fn has_echo_to_sender(&self) -> bool {
        self.echo_to_sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_echo_to_sender(&mut self, v: bool) {
        self.echo_to_sender = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_SendChatMessage_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_SendChatMessage_Request| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_SendChatMessage_Request| { &m.chat_id },
            |m: &mut CChatRoom_SendChatMessage_Request| { &mut m.chat_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &CChatRoom_SendChatMessage_Request| { &m.message },
            |m: &mut CChatRoom_SendChatMessage_Request| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "echo_to_sender",
            |m: &CChatRoom_SendChatMessage_Request| { &m.echo_to_sender },
            |m: &mut CChatRoom_SendChatMessage_Request| { &mut m.echo_to_sender },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SendChatMessage_Request>(
            "CChatRoom_SendChatMessage_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_SendChatMessage_Request {
    const NAME: &'static str = "CChatRoom_SendChatMessage_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.echo_to_sender = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.echo_to_sender {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.echo_to_sender {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SendChatMessage_Request {
        CChatRoom_SendChatMessage_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.echo_to_sender = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SendChatMessage_Request {
        static instance: CChatRoom_SendChatMessage_Request = CChatRoom_SendChatMessage_Request {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            message: ::std::option::Option::None,
            echo_to_sender: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_SendChatMessage_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SendChatMessage_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SendChatMessage_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SendChatMessage_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_SendChatMessage_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SendChatMessage_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SendChatMessage_Response.modified_message)
    pub modified_message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_SendChatMessage_Response.server_timestamp)
    pub server_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_SendChatMessage_Response.ordinal)
    pub ordinal: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_SendChatMessage_Response.message_without_bb_code)
    pub message_without_bb_code: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SendChatMessage_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SendChatMessage_Response {
    fn default() -> &'a CChatRoom_SendChatMessage_Response {
        <CChatRoom_SendChatMessage_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SendChatMessage_Response {
    pub fn new() -> CChatRoom_SendChatMessage_Response {
        ::std::default::Default::default()
    }

    // optional string modified_message = 1;

    pub fn modified_message(&self) -> &str {
        match self.modified_message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_modified_message(&mut self) {
        self.modified_message = ::std::option::Option::None;
    }

    pub fn has_modified_message(&self) -> bool {
        self.modified_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modified_message(&mut self, v: ::std::string::String) {
        self.modified_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_modified_message(&mut self) -> &mut ::std::string::String {
        if self.modified_message.is_none() {
            self.modified_message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.modified_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_modified_message(&mut self) -> ::std::string::String {
        self.modified_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 server_timestamp = 2;

    pub fn server_timestamp(&self) -> u32 {
        self.server_timestamp.unwrap_or(0)
    }

    pub fn clear_server_timestamp(&mut self) {
        self.server_timestamp = ::std::option::Option::None;
    }

    pub fn has_server_timestamp(&self) -> bool {
        self.server_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_timestamp(&mut self, v: u32) {
        self.server_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 ordinal = 3;

    pub fn ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }

    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }

    // optional string message_without_bb_code = 4;

    pub fn message_without_bb_code(&self) -> &str {
        match self.message_without_bb_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message_without_bb_code(&mut self) {
        self.message_without_bb_code = ::std::option::Option::None;
    }

    pub fn has_message_without_bb_code(&self) -> bool {
        self.message_without_bb_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_without_bb_code(&mut self, v: ::std::string::String) {
        self.message_without_bb_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_without_bb_code(&mut self) -> &mut ::std::string::String {
        if self.message_without_bb_code.is_none() {
            self.message_without_bb_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message_without_bb_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_without_bb_code(&mut self) -> ::std::string::String {
        self.message_without_bb_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "modified_message",
            |m: &CChatRoom_SendChatMessage_Response| { &m.modified_message },
            |m: &mut CChatRoom_SendChatMessage_Response| { &mut m.modified_message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_timestamp",
            |m: &CChatRoom_SendChatMessage_Response| { &m.server_timestamp },
            |m: &mut CChatRoom_SendChatMessage_Response| { &mut m.server_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ordinal",
            |m: &CChatRoom_SendChatMessage_Response| { &m.ordinal },
            |m: &mut CChatRoom_SendChatMessage_Response| { &mut m.ordinal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message_without_bb_code",
            |m: &CChatRoom_SendChatMessage_Response| { &m.message_without_bb_code },
            |m: &mut CChatRoom_SendChatMessage_Response| { &mut m.message_without_bb_code },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SendChatMessage_Response>(
            "CChatRoom_SendChatMessage_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_SendChatMessage_Response {
    const NAME: &'static str = "CChatRoom_SendChatMessage_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.modified_message = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.server_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.ordinal = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.message_without_bb_code = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.modified_message.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.server_timestamp {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.ordinal {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.message_without_bb_code.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.modified_message.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.server_timestamp {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.message_without_bb_code.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SendChatMessage_Response {
        CChatRoom_SendChatMessage_Response::new()
    }

    fn clear(&mut self) {
        self.modified_message = ::std::option::Option::None;
        self.server_timestamp = ::std::option::Option::None;
        self.ordinal = ::std::option::Option::None;
        self.message_without_bb_code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SendChatMessage_Response {
        static instance: CChatRoom_SendChatMessage_Response = CChatRoom_SendChatMessage_Response {
            modified_message: ::std::option::Option::None,
            server_timestamp: ::std::option::Option::None,
            ordinal: ::std::option::Option::None,
            message_without_bb_code: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_SendChatMessage_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SendChatMessage_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SendChatMessage_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SendChatMessage_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_JoinVoiceChat_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_JoinVoiceChat_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_JoinVoiceChat_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_JoinVoiceChat_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_JoinVoiceChat_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_JoinVoiceChat_Request {
    fn default() -> &'a CChatRoom_JoinVoiceChat_Request {
        <CChatRoom_JoinVoiceChat_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_JoinVoiceChat_Request {
    pub fn new() -> CChatRoom_JoinVoiceChat_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_JoinVoiceChat_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_JoinVoiceChat_Request| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_JoinVoiceChat_Request| { &m.chat_id },
            |m: &mut CChatRoom_JoinVoiceChat_Request| { &mut m.chat_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_JoinVoiceChat_Request>(
            "CChatRoom_JoinVoiceChat_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_JoinVoiceChat_Request {
    const NAME: &'static str = "CChatRoom_JoinVoiceChat_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_JoinVoiceChat_Request {
        CChatRoom_JoinVoiceChat_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_JoinVoiceChat_Request {
        static instance: CChatRoom_JoinVoiceChat_Request = CChatRoom_JoinVoiceChat_Request {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_JoinVoiceChat_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_JoinVoiceChat_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_JoinVoiceChat_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_JoinVoiceChat_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_JoinVoiceChat_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_JoinVoiceChat_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_JoinVoiceChat_Response.voice_chatid)
    pub voice_chatid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_JoinVoiceChat_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_JoinVoiceChat_Response {
    fn default() -> &'a CChatRoom_JoinVoiceChat_Response {
        <CChatRoom_JoinVoiceChat_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_JoinVoiceChat_Response {
    pub fn new() -> CChatRoom_JoinVoiceChat_Response {
        ::std::default::Default::default()
    }

    // optional uint64 voice_chatid = 1;

    pub fn voice_chatid(&self) -> u64 {
        self.voice_chatid.unwrap_or(0)
    }

    pub fn clear_voice_chatid(&mut self) {
        self.voice_chatid = ::std::option::Option::None;
    }

    pub fn has_voice_chatid(&self) -> bool {
        self.voice_chatid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_chatid(&mut self, v: u64) {
        self.voice_chatid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "voice_chatid",
            |m: &CChatRoom_JoinVoiceChat_Response| { &m.voice_chatid },
            |m: &mut CChatRoom_JoinVoiceChat_Response| { &mut m.voice_chatid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_JoinVoiceChat_Response>(
            "CChatRoom_JoinVoiceChat_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_JoinVoiceChat_Response {
    const NAME: &'static str = "CChatRoom_JoinVoiceChat_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.voice_chatid = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.voice_chatid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.voice_chatid {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_JoinVoiceChat_Response {
        CChatRoom_JoinVoiceChat_Response::new()
    }

    fn clear(&mut self) {
        self.voice_chatid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_JoinVoiceChat_Response {
        static instance: CChatRoom_JoinVoiceChat_Response = CChatRoom_JoinVoiceChat_Response {
            voice_chatid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_JoinVoiceChat_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_JoinVoiceChat_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_JoinVoiceChat_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_JoinVoiceChat_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_LeaveVoiceChat_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_LeaveVoiceChat_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_LeaveVoiceChat_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_LeaveVoiceChat_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_LeaveVoiceChat_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_LeaveVoiceChat_Request {
    fn default() -> &'a CChatRoom_LeaveVoiceChat_Request {
        <CChatRoom_LeaveVoiceChat_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_LeaveVoiceChat_Request {
    pub fn new() -> CChatRoom_LeaveVoiceChat_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_LeaveVoiceChat_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_LeaveVoiceChat_Request| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_LeaveVoiceChat_Request| { &m.chat_id },
            |m: &mut CChatRoom_LeaveVoiceChat_Request| { &mut m.chat_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_LeaveVoiceChat_Request>(
            "CChatRoom_LeaveVoiceChat_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_LeaveVoiceChat_Request {
    const NAME: &'static str = "CChatRoom_LeaveVoiceChat_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_LeaveVoiceChat_Request {
        CChatRoom_LeaveVoiceChat_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_LeaveVoiceChat_Request {
        static instance: CChatRoom_LeaveVoiceChat_Request = CChatRoom_LeaveVoiceChat_Request {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_LeaveVoiceChat_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_LeaveVoiceChat_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_LeaveVoiceChat_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_LeaveVoiceChat_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_LeaveVoiceChat_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_LeaveVoiceChat_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_LeaveVoiceChat_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_LeaveVoiceChat_Response {
    fn default() -> &'a CChatRoom_LeaveVoiceChat_Response {
        <CChatRoom_LeaveVoiceChat_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_LeaveVoiceChat_Response {
    pub fn new() -> CChatRoom_LeaveVoiceChat_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_LeaveVoiceChat_Response>(
            "CChatRoom_LeaveVoiceChat_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_LeaveVoiceChat_Response {
    const NAME: &'static str = "CChatRoom_LeaveVoiceChat_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_LeaveVoiceChat_Response {
        CChatRoom_LeaveVoiceChat_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_LeaveVoiceChat_Response {
        static instance: CChatRoom_LeaveVoiceChat_Response = CChatRoom_LeaveVoiceChat_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_LeaveVoiceChat_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_LeaveVoiceChat_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_LeaveVoiceChat_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_LeaveVoiceChat_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetMessageHistory_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetMessageHistory_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Request.last_time)
    pub last_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Request.last_ordinal)
    pub last_ordinal: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Request.start_time)
    pub start_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Request.start_ordinal)
    pub start_ordinal: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Request.max_count)
    pub max_count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetMessageHistory_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetMessageHistory_Request {
    fn default() -> &'a CChatRoom_GetMessageHistory_Request {
        <CChatRoom_GetMessageHistory_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetMessageHistory_Request {
    pub fn new() -> CChatRoom_GetMessageHistory_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 last_time = 3;

    pub fn last_time(&self) -> u32 {
        self.last_time.unwrap_or(0)
    }

    pub fn clear_last_time(&mut self) {
        self.last_time = ::std::option::Option::None;
    }

    pub fn has_last_time(&self) -> bool {
        self.last_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_time(&mut self, v: u32) {
        self.last_time = ::std::option::Option::Some(v);
    }

    // optional uint32 last_ordinal = 4;

    pub fn last_ordinal(&self) -> u32 {
        self.last_ordinal.unwrap_or(0)
    }

    pub fn clear_last_ordinal(&mut self) {
        self.last_ordinal = ::std::option::Option::None;
    }

    pub fn has_last_ordinal(&self) -> bool {
        self.last_ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_ordinal(&mut self, v: u32) {
        self.last_ordinal = ::std::option::Option::Some(v);
    }

    // optional uint32 start_time = 5;

    pub fn start_time(&self) -> u32 {
        self.start_time.unwrap_or(0)
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional uint32 start_ordinal = 6;

    pub fn start_ordinal(&self) -> u32 {
        self.start_ordinal.unwrap_or(0)
    }

    pub fn clear_start_ordinal(&mut self) {
        self.start_ordinal = ::std::option::Option::None;
    }

    pub fn has_start_ordinal(&self) -> bool {
        self.start_ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_ordinal(&mut self, v: u32) {
        self.start_ordinal = ::std::option::Option::Some(v);
    }

    // optional uint32 max_count = 7;

    pub fn max_count(&self) -> u32 {
        self.max_count.unwrap_or(0)
    }

    pub fn clear_max_count(&mut self) {
        self.max_count = ::std::option::Option::None;
    }

    pub fn has_max_count(&self) -> bool {
        self.max_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_count(&mut self, v: u32) {
        self.max_count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_GetMessageHistory_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_GetMessageHistory_Request| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_GetMessageHistory_Request| { &m.chat_id },
            |m: &mut CChatRoom_GetMessageHistory_Request| { &mut m.chat_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_time",
            |m: &CChatRoom_GetMessageHistory_Request| { &m.last_time },
            |m: &mut CChatRoom_GetMessageHistory_Request| { &mut m.last_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_ordinal",
            |m: &CChatRoom_GetMessageHistory_Request| { &m.last_ordinal },
            |m: &mut CChatRoom_GetMessageHistory_Request| { &mut m.last_ordinal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_time",
            |m: &CChatRoom_GetMessageHistory_Request| { &m.start_time },
            |m: &mut CChatRoom_GetMessageHistory_Request| { &mut m.start_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_ordinal",
            |m: &CChatRoom_GetMessageHistory_Request| { &m.start_ordinal },
            |m: &mut CChatRoom_GetMessageHistory_Request| { &mut m.start_ordinal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_count",
            |m: &CChatRoom_GetMessageHistory_Request| { &m.max_count },
            |m: &mut CChatRoom_GetMessageHistory_Request| { &mut m.max_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetMessageHistory_Request>(
            "CChatRoom_GetMessageHistory_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_GetMessageHistory_Request {
    const NAME: &'static str = "CChatRoom_GetMessageHistory_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.last_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.last_ordinal = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.start_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.start_ordinal = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.max_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.last_time {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.last_ordinal {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.start_time {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.start_ordinal {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.max_count {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.last_time {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.last_ordinal {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.start_ordinal {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.max_count {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetMessageHistory_Request {
        CChatRoom_GetMessageHistory_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.last_time = ::std::option::Option::None;
        self.last_ordinal = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.start_ordinal = ::std::option::Option::None;
        self.max_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetMessageHistory_Request {
        static instance: CChatRoom_GetMessageHistory_Request = CChatRoom_GetMessageHistory_Request {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            last_time: ::std::option::Option::None,
            last_ordinal: ::std::option::Option::None,
            start_time: ::std::option::Option::None,
            start_ordinal: ::std::option::Option::None,
            max_count: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_GetMessageHistory_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetMessageHistory_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetMessageHistory_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetMessageHistory_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ServerMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServerMessage {
    // message fields
    // @@protoc_insertion_point(field:ServerMessage.message)
    pub message: ::std::option::Option<::protobuf::EnumOrUnknown<EChatRoomServerMessage>>,
    // @@protoc_insertion_point(field:ServerMessage.string_param)
    pub string_param: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ServerMessage.accountid_param)
    pub accountid_param: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:ServerMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServerMessage {
    fn default() -> &'a ServerMessage {
        <ServerMessage as ::protobuf::Message>::default_instance()
    }
}

impl ServerMessage {
    pub fn new() -> ServerMessage {
        ::std::default::Default::default()
    }

    // optional .EChatRoomServerMessage message = 1;

    pub fn message(&self) -> EChatRoomServerMessage {
        match self.message {
            Some(e) => e.enum_value_or(EChatRoomServerMessage::k_EChatRoomServerMsg_Invalid),
            None => EChatRoomServerMessage::k_EChatRoomServerMsg_Invalid,
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: EChatRoomServerMessage) {
        self.message = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string string_param = 2;

    pub fn string_param(&self) -> &str {
        match self.string_param.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_string_param(&mut self) {
        self.string_param = ::std::option::Option::None;
    }

    pub fn has_string_param(&self) -> bool {
        self.string_param.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_param(&mut self, v: ::std::string::String) {
        self.string_param = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_param(&mut self) -> &mut ::std::string::String {
        if self.string_param.is_none() {
            self.string_param = ::std::option::Option::Some(::std::string::String::new());
        }
        self.string_param.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_param(&mut self) -> ::std::string::String {
        self.string_param.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 accountid_param = 3;

    pub fn accountid_param(&self) -> u32 {
        self.accountid_param.unwrap_or(0)
    }

    pub fn clear_accountid_param(&mut self) {
        self.accountid_param = ::std::option::Option::None;
    }

    pub fn has_accountid_param(&self) -> bool {
        self.accountid_param.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid_param(&mut self, v: u32) {
        self.accountid_param = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &ServerMessage| { &m.message },
            |m: &mut ServerMessage| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "string_param",
            |m: &ServerMessage| { &m.string_param },
            |m: &mut ServerMessage| { &mut m.string_param },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid_param",
            |m: &ServerMessage| { &m.accountid_param },
            |m: &mut ServerMessage| { &mut m.accountid_param },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServerMessage>(
            "ServerMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServerMessage {
    const NAME: &'static str = "ServerMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.message = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.string_param = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.accountid_param = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.string_param.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.accountid_param {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.message {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.string_param.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.accountid_param {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServerMessage {
        ServerMessage::new()
    }

    fn clear(&mut self) {
        self.message = ::std::option::Option::None;
        self.string_param = ::std::option::Option::None;
        self.accountid_param = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServerMessage {
        static instance: ServerMessage = ServerMessage {
            message: ::std::option::Option::None,
            string_param: ::std::option::Option::None,
            accountid_param: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServerMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServerMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServerMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetMessageHistory_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetMessageHistory_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Response.messages)
    pub messages: ::std::vec::Vec<cchat_room_get_message_history_response::ChatMessage>,
    // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Response.more_available)
    pub more_available: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetMessageHistory_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetMessageHistory_Response {
    fn default() -> &'a CChatRoom_GetMessageHistory_Response {
        <CChatRoom_GetMessageHistory_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetMessageHistory_Response {
    pub fn new() -> CChatRoom_GetMessageHistory_Response {
        ::std::default::Default::default()
    }

    // optional bool more_available = 4;

    pub fn more_available(&self) -> bool {
        self.more_available.unwrap_or(false)
    }

    pub fn clear_more_available(&mut self) {
        self.more_available = ::std::option::Option::None;
    }

    pub fn has_more_available(&self) -> bool {
        self.more_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_more_available(&mut self, v: bool) {
        self.more_available = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "messages",
            |m: &CChatRoom_GetMessageHistory_Response| { &m.messages },
            |m: &mut CChatRoom_GetMessageHistory_Response| { &mut m.messages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "more_available",
            |m: &CChatRoom_GetMessageHistory_Response| { &m.more_available },
            |m: &mut CChatRoom_GetMessageHistory_Response| { &mut m.more_available },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetMessageHistory_Response>(
            "CChatRoom_GetMessageHistory_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_GetMessageHistory_Response {
    const NAME: &'static str = "CChatRoom_GetMessageHistory_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.messages.push(is.read_message()?);
                },
                32 => {
                    self.more_available = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.more_available {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.messages {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.more_available {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetMessageHistory_Response {
        CChatRoom_GetMessageHistory_Response::new()
    }

    fn clear(&mut self) {
        self.messages.clear();
        self.more_available = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetMessageHistory_Response {
        static instance: CChatRoom_GetMessageHistory_Response = CChatRoom_GetMessageHistory_Response {
            messages: ::std::vec::Vec::new(),
            more_available: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_GetMessageHistory_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetMessageHistory_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetMessageHistory_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetMessageHistory_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CChatRoom_GetMessageHistory_Response`
pub mod cchat_room_get_message_history_response {
    // @@protoc_insertion_point(message:CChatRoom_GetMessageHistory_Response.ChatMessage)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ChatMessage {
        // message fields
        // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Response.ChatMessage.sender)
        pub sender: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Response.ChatMessage.server_timestamp)
        pub server_timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Response.ChatMessage.message)
        pub message: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Response.ChatMessage.ordinal)
        pub ordinal: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Response.ChatMessage.server_message)
        pub server_message: ::protobuf::MessageField<super::ServerMessage>,
        // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Response.ChatMessage.deleted)
        pub deleted: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Response.ChatMessage.reactions)
        pub reactions: ::std::vec::Vec<chat_message::MessageReaction>,
        // special fields
        // @@protoc_insertion_point(special_field:CChatRoom_GetMessageHistory_Response.ChatMessage.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ChatMessage {
        fn default() -> &'a ChatMessage {
            <ChatMessage as ::protobuf::Message>::default_instance()
        }
    }

    impl ChatMessage {
        pub fn new() -> ChatMessage {
            ::std::default::Default::default()
        }

        // optional uint32 sender = 1;

        pub fn sender(&self) -> u32 {
            self.sender.unwrap_or(0)
        }

        pub fn clear_sender(&mut self) {
            self.sender = ::std::option::Option::None;
        }

        pub fn has_sender(&self) -> bool {
            self.sender.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sender(&mut self, v: u32) {
            self.sender = ::std::option::Option::Some(v);
        }

        // optional uint32 server_timestamp = 2;

        pub fn server_timestamp(&self) -> u32 {
            self.server_timestamp.unwrap_or(0)
        }

        pub fn clear_server_timestamp(&mut self) {
            self.server_timestamp = ::std::option::Option::None;
        }

        pub fn has_server_timestamp(&self) -> bool {
            self.server_timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_server_timestamp(&mut self, v: u32) {
            self.server_timestamp = ::std::option::Option::Some(v);
        }

        // optional string message = 3;

        pub fn message(&self) -> &str {
            match self.message.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_message(&mut self) {
            self.message = ::std::option::Option::None;
        }

        pub fn has_message(&self) -> bool {
            self.message.is_some()
        }

        // Param is passed by value, moved
        pub fn set_message(&mut self, v: ::std::string::String) {
            self.message = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_message(&mut self) -> &mut ::std::string::String {
            if self.message.is_none() {
                self.message = ::std::option::Option::Some(::std::string::String::new());
            }
            self.message.as_mut().unwrap()
        }

        // Take field
        pub fn take_message(&mut self) -> ::std::string::String {
            self.message.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 ordinal = 4;

        pub fn ordinal(&self) -> u32 {
            self.ordinal.unwrap_or(0)
        }

        pub fn clear_ordinal(&mut self) {
            self.ordinal = ::std::option::Option::None;
        }

        pub fn has_ordinal(&self) -> bool {
            self.ordinal.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ordinal(&mut self, v: u32) {
            self.ordinal = ::std::option::Option::Some(v);
        }

        // optional bool deleted = 6;

        pub fn deleted(&self) -> bool {
            self.deleted.unwrap_or(false)
        }

        pub fn clear_deleted(&mut self) {
            self.deleted = ::std::option::Option::None;
        }

        pub fn has_deleted(&self) -> bool {
            self.deleted.is_some()
        }

        // Param is passed by value, moved
        pub fn set_deleted(&mut self, v: bool) {
            self.deleted = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(7);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sender",
                |m: &ChatMessage| { &m.sender },
                |m: &mut ChatMessage| { &mut m.sender },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "server_timestamp",
                |m: &ChatMessage| { &m.server_timestamp },
                |m: &mut ChatMessage| { &mut m.server_timestamp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "message",
                |m: &ChatMessage| { &m.message },
                |m: &mut ChatMessage| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ordinal",
                |m: &ChatMessage| { &m.ordinal },
                |m: &mut ChatMessage| { &mut m.ordinal },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::ServerMessage>(
                "server_message",
                |m: &ChatMessage| { &m.server_message },
                |m: &mut ChatMessage| { &mut m.server_message },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "deleted",
                |m: &ChatMessage| { &m.deleted },
                |m: &mut ChatMessage| { &mut m.deleted },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "reactions",
                |m: &ChatMessage| { &m.reactions },
                |m: &mut ChatMessage| { &mut m.reactions },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChatMessage>(
                "CChatRoom_GetMessageHistory_Response.ChatMessage",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ChatMessage {
        const NAME: &'static str = "ChatMessage";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.sender = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.server_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.message = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.ordinal = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    42 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.server_message)?;
                    },
                    48 => {
                        self.deleted = ::std::option::Option::Some(is.read_bool()?);
                    },
                    58 => {
                        self.reactions.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.sender {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.server_timestamp {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.message.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.ordinal {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.server_message.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.deleted {
                my_size += 1 + 1;
            }
            for value in &self.reactions {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.sender {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.server_timestamp {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.message.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.ordinal {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.server_message.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            }
            if let Some(v) = self.deleted {
                os.write_bool(6, v)?;
            }
            for v in &self.reactions {
                ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ChatMessage {
            ChatMessage::new()
        }

        fn clear(&mut self) {
            self.sender = ::std::option::Option::None;
            self.server_timestamp = ::std::option::Option::None;
            self.message = ::std::option::Option::None;
            self.ordinal = ::std::option::Option::None;
            self.server_message.clear();
            self.deleted = ::std::option::Option::None;
            self.reactions.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ChatMessage {
            static instance: ChatMessage = ChatMessage {
                sender: ::std::option::Option::None,
                server_timestamp: ::std::option::Option::None,
                message: ::std::option::Option::None,
                ordinal: ::std::option::Option::None,
                server_message: ::protobuf::MessageField::none(),
                deleted: ::std::option::Option::None,
                reactions: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ChatMessage {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CChatRoom_GetMessageHistory_Response.ChatMessage").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ChatMessage {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ChatMessage {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `ChatMessage`
    pub mod chat_message {
        // @@protoc_insertion_point(message:CChatRoom_GetMessageHistory_Response.ChatMessage.MessageReaction)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct MessageReaction {
            // message fields
            // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Response.ChatMessage.MessageReaction.reaction_type)
            pub reaction_type: ::std::option::Option<::protobuf::EnumOrUnknown<super::super::EChatRoomMessageReactionType>>,
            // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Response.ChatMessage.MessageReaction.reaction)
            pub reaction: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Response.ChatMessage.MessageReaction.num_reactors)
            pub num_reactors: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Response.ChatMessage.MessageReaction.has_user_reacted)
            pub has_user_reacted: ::std::option::Option<bool>,
            // special fields
            // @@protoc_insertion_point(special_field:CChatRoom_GetMessageHistory_Response.ChatMessage.MessageReaction.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a MessageReaction {
            fn default() -> &'a MessageReaction {
                <MessageReaction as ::protobuf::Message>::default_instance()
            }
        }

        impl MessageReaction {
            pub fn new() -> MessageReaction {
                ::std::default::Default::default()
            }

            // optional .EChatRoomMessageReactionType reaction_type = 1;

            pub fn reaction_type(&self) -> super::super::EChatRoomMessageReactionType {
                match self.reaction_type {
                    Some(e) => e.enum_value_or(super::super::EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid),
                    None => super::super::EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid,
                }
            }

            pub fn clear_reaction_type(&mut self) {
                self.reaction_type = ::std::option::Option::None;
            }

            pub fn has_reaction_type(&self) -> bool {
                self.reaction_type.is_some()
            }

            // Param is passed by value, moved
            pub fn set_reaction_type(&mut self, v: super::super::EChatRoomMessageReactionType) {
                self.reaction_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
            }

            // optional string reaction = 2;

            pub fn reaction(&self) -> &str {
                match self.reaction.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_reaction(&mut self) {
                self.reaction = ::std::option::Option::None;
            }

            pub fn has_reaction(&self) -> bool {
                self.reaction.is_some()
            }

            // Param is passed by value, moved
            pub fn set_reaction(&mut self, v: ::std::string::String) {
                self.reaction = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_reaction(&mut self) -> &mut ::std::string::String {
                if self.reaction.is_none() {
                    self.reaction = ::std::option::Option::Some(::std::string::String::new());
                }
                self.reaction.as_mut().unwrap()
            }

            // Take field
            pub fn take_reaction(&mut self) -> ::std::string::String {
                self.reaction.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional uint32 num_reactors = 3;

            pub fn num_reactors(&self) -> u32 {
                self.num_reactors.unwrap_or(0)
            }

            pub fn clear_num_reactors(&mut self) {
                self.num_reactors = ::std::option::Option::None;
            }

            pub fn has_num_reactors(&self) -> bool {
                self.num_reactors.is_some()
            }

            // Param is passed by value, moved
            pub fn set_num_reactors(&mut self, v: u32) {
                self.num_reactors = ::std::option::Option::Some(v);
            }

            // optional bool has_user_reacted = 4;

            pub fn has_user_reacted(&self) -> bool {
                self.has_user_reacted.unwrap_or(false)
            }

            pub fn clear_has_user_reacted(&mut self) {
                self.has_user_reacted = ::std::option::Option::None;
            }

            pub fn has_has_user_reacted(&self) -> bool {
                self.has_user_reacted.is_some()
            }

            // Param is passed by value, moved
            pub fn set_has_user_reacted(&mut self, v: bool) {
                self.has_user_reacted = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "reaction_type",
                    |m: &MessageReaction| { &m.reaction_type },
                    |m: &mut MessageReaction| { &mut m.reaction_type },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "reaction",
                    |m: &MessageReaction| { &m.reaction },
                    |m: &mut MessageReaction| { &mut m.reaction },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "num_reactors",
                    |m: &MessageReaction| { &m.num_reactors },
                    |m: &mut MessageReaction| { &mut m.num_reactors },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "has_user_reacted",
                    |m: &MessageReaction| { &m.has_user_reacted },
                    |m: &mut MessageReaction| { &mut m.has_user_reacted },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MessageReaction>(
                    "CChatRoom_GetMessageHistory_Response.ChatMessage.MessageReaction",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for MessageReaction {
            const NAME: &'static str = "MessageReaction";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.reaction_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                        },
                        18 => {
                            self.reaction = ::std::option::Option::Some(is.read_string()?);
                        },
                        24 => {
                            self.num_reactors = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        32 => {
                            self.has_user_reacted = ::std::option::Option::Some(is.read_bool()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.reaction_type {
                    my_size += ::protobuf::rt::int32_size(1, v.value());
                }
                if let Some(v) = self.reaction.as_ref() {
                    my_size += ::protobuf::rt::string_size(2, &v);
                }
                if let Some(v) = self.num_reactors {
                    my_size += ::protobuf::rt::uint32_size(3, v);
                }
                if let Some(v) = self.has_user_reacted {
                    my_size += 1 + 1;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.reaction_type {
                    os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
                }
                if let Some(v) = self.reaction.as_ref() {
                    os.write_string(2, v)?;
                }
                if let Some(v) = self.num_reactors {
                    os.write_uint32(3, v)?;
                }
                if let Some(v) = self.has_user_reacted {
                    os.write_bool(4, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> MessageReaction {
                MessageReaction::new()
            }

            fn clear(&mut self) {
                self.reaction_type = ::std::option::Option::None;
                self.reaction = ::std::option::Option::None;
                self.num_reactors = ::std::option::Option::None;
                self.has_user_reacted = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static MessageReaction {
                static instance: MessageReaction = MessageReaction {
                    reaction_type: ::std::option::Option::None,
                    reaction: ::std::option::Option::None,
                    num_reactors: ::std::option::Option::None,
                    has_user_reacted: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for MessageReaction {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CChatRoom_GetMessageHistory_Response.ChatMessage.MessageReaction").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for MessageReaction {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for MessageReaction {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:CChatRoom_GetMyChatRoomGroups_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetMyChatRoomGroups_Request {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetMyChatRoomGroups_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetMyChatRoomGroups_Request {
    fn default() -> &'a CChatRoom_GetMyChatRoomGroups_Request {
        <CChatRoom_GetMyChatRoomGroups_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetMyChatRoomGroups_Request {
    pub fn new() -> CChatRoom_GetMyChatRoomGroups_Request {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetMyChatRoomGroups_Request>(
            "CChatRoom_GetMyChatRoomGroups_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_GetMyChatRoomGroups_Request {
    const NAME: &'static str = "CChatRoom_GetMyChatRoomGroups_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetMyChatRoomGroups_Request {
        CChatRoom_GetMyChatRoomGroups_Request::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetMyChatRoomGroups_Request {
        static instance: CChatRoom_GetMyChatRoomGroups_Request = CChatRoom_GetMyChatRoomGroups_Request {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_GetMyChatRoomGroups_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetMyChatRoomGroups_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetMyChatRoomGroups_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetMyChatRoomGroups_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetChatRoomGroupSummary_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetChatRoomGroupSummary_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.chat_group_name)
    pub chat_group_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.active_member_count)
    pub active_member_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.active_voice_member_count)
    pub active_voice_member_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.default_chat_id)
    pub default_chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.chat_rooms)
    pub chat_rooms: ::std::vec::Vec<CChatRoomState>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.clanid)
    pub clanid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.chat_group_tagline)
    pub chat_group_tagline: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.accountid_owner)
    pub accountid_owner: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.top_members)
    pub top_members: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.chat_group_avatar_sha)
    pub chat_group_avatar_sha: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.rank)
    pub rank: ::std::option::Option<::protobuf::EnumOrUnknown<EChatRoomGroupRank>>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.default_role_id)
    pub default_role_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.role_ids)
    pub role_ids: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.role_actions)
    pub role_actions: ::std::vec::Vec<CChatRoleActions>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.watching_broadcast_accountid)
    pub watching_broadcast_accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.party_beacons)
    pub party_beacons: ::std::vec::Vec<CChatPartyBeacon>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.watching_broadcast_channel_id)
    pub watching_broadcast_channel_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.active_minigame_id)
    pub active_minigame_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.avatar_ugc_url)
    pub avatar_ugc_url: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetChatRoomGroupSummary_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetChatRoomGroupSummary_Response {
    fn default() -> &'a CChatRoom_GetChatRoomGroupSummary_Response {
        <CChatRoom_GetChatRoomGroupSummary_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetChatRoomGroupSummary_Response {
    pub fn new() -> CChatRoom_GetChatRoomGroupSummary_Response {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string chat_group_name = 2;

    pub fn chat_group_name(&self) -> &str {
        match self.chat_group_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_chat_group_name(&mut self) {
        self.chat_group_name = ::std::option::Option::None;
    }

    pub fn has_chat_group_name(&self) -> bool {
        self.chat_group_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_name(&mut self, v: ::std::string::String) {
        self.chat_group_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_group_name(&mut self) -> &mut ::std::string::String {
        if self.chat_group_name.is_none() {
            self.chat_group_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.chat_group_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_group_name(&mut self) -> ::std::string::String {
        self.chat_group_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 active_member_count = 3;

    pub fn active_member_count(&self) -> u32 {
        self.active_member_count.unwrap_or(0)
    }

    pub fn clear_active_member_count(&mut self) {
        self.active_member_count = ::std::option::Option::None;
    }

    pub fn has_active_member_count(&self) -> bool {
        self.active_member_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_member_count(&mut self, v: u32) {
        self.active_member_count = ::std::option::Option::Some(v);
    }

    // optional uint32 active_voice_member_count = 4;

    pub fn active_voice_member_count(&self) -> u32 {
        self.active_voice_member_count.unwrap_or(0)
    }

    pub fn clear_active_voice_member_count(&mut self) {
        self.active_voice_member_count = ::std::option::Option::None;
    }

    pub fn has_active_voice_member_count(&self) -> bool {
        self.active_voice_member_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_voice_member_count(&mut self, v: u32) {
        self.active_voice_member_count = ::std::option::Option::Some(v);
    }

    // optional uint64 default_chat_id = 5;

    pub fn default_chat_id(&self) -> u64 {
        self.default_chat_id.unwrap_or(0)
    }

    pub fn clear_default_chat_id(&mut self) {
        self.default_chat_id = ::std::option::Option::None;
    }

    pub fn has_default_chat_id(&self) -> bool {
        self.default_chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_chat_id(&mut self, v: u64) {
        self.default_chat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 clanid = 7;

    pub fn clanid(&self) -> u32 {
        self.clanid.unwrap_or(0)
    }

    pub fn clear_clanid(&mut self) {
        self.clanid = ::std::option::Option::None;
    }

    pub fn has_clanid(&self) -> bool {
        self.clanid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clanid(&mut self, v: u32) {
        self.clanid = ::std::option::Option::Some(v);
    }

    // optional string chat_group_tagline = 8;

    pub fn chat_group_tagline(&self) -> &str {
        match self.chat_group_tagline.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_chat_group_tagline(&mut self) {
        self.chat_group_tagline = ::std::option::Option::None;
    }

    pub fn has_chat_group_tagline(&self) -> bool {
        self.chat_group_tagline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_tagline(&mut self, v: ::std::string::String) {
        self.chat_group_tagline = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_group_tagline(&mut self) -> &mut ::std::string::String {
        if self.chat_group_tagline.is_none() {
            self.chat_group_tagline = ::std::option::Option::Some(::std::string::String::new());
        }
        self.chat_group_tagline.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_group_tagline(&mut self) -> ::std::string::String {
        self.chat_group_tagline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 accountid_owner = 9;

    pub fn accountid_owner(&self) -> u32 {
        self.accountid_owner.unwrap_or(0)
    }

    pub fn clear_accountid_owner(&mut self) {
        self.accountid_owner = ::std::option::Option::None;
    }

    pub fn has_accountid_owner(&self) -> bool {
        self.accountid_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid_owner(&mut self, v: u32) {
        self.accountid_owner = ::std::option::Option::Some(v);
    }

    // optional bytes chat_group_avatar_sha = 11;

    pub fn chat_group_avatar_sha(&self) -> &[u8] {
        match self.chat_group_avatar_sha.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_chat_group_avatar_sha(&mut self) {
        self.chat_group_avatar_sha = ::std::option::Option::None;
    }

    pub fn has_chat_group_avatar_sha(&self) -> bool {
        self.chat_group_avatar_sha.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_avatar_sha(&mut self, v: ::std::vec::Vec<u8>) {
        self.chat_group_avatar_sha = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_group_avatar_sha(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.chat_group_avatar_sha.is_none() {
            self.chat_group_avatar_sha = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.chat_group_avatar_sha.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_group_avatar_sha(&mut self) -> ::std::vec::Vec<u8> {
        self.chat_group_avatar_sha.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .EChatRoomGroupRank rank = 12;

    pub fn rank(&self) -> EChatRoomGroupRank {
        match self.rank {
            Some(e) => e.enum_value_or(EChatRoomGroupRank::k_EChatRoomGroupRank_Default),
            None => EChatRoomGroupRank::k_EChatRoomGroupRank_Default,
        }
    }

    pub fn clear_rank(&mut self) {
        self.rank = ::std::option::Option::None;
    }

    pub fn has_rank(&self) -> bool {
        self.rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank(&mut self, v: EChatRoomGroupRank) {
        self.rank = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 default_role_id = 13;

    pub fn default_role_id(&self) -> u64 {
        self.default_role_id.unwrap_or(0)
    }

    pub fn clear_default_role_id(&mut self) {
        self.default_role_id = ::std::option::Option::None;
    }

    pub fn has_default_role_id(&self) -> bool {
        self.default_role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_role_id(&mut self, v: u64) {
        self.default_role_id = ::std::option::Option::Some(v);
    }

    // optional uint32 watching_broadcast_accountid = 16;

    pub fn watching_broadcast_accountid(&self) -> u32 {
        self.watching_broadcast_accountid.unwrap_or(0)
    }

    pub fn clear_watching_broadcast_accountid(&mut self) {
        self.watching_broadcast_accountid = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_accountid(&self) -> bool {
        self.watching_broadcast_accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_accountid(&mut self, v: u32) {
        self.watching_broadcast_accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 17;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint64 watching_broadcast_channel_id = 19;

    pub fn watching_broadcast_channel_id(&self) -> u64 {
        self.watching_broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_watching_broadcast_channel_id(&mut self) {
        self.watching_broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_channel_id(&self) -> bool {
        self.watching_broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_channel_id(&mut self, v: u64) {
        self.watching_broadcast_channel_id = ::std::option::Option::Some(v);
    }

    // optional uint64 active_minigame_id = 20;

    pub fn active_minigame_id(&self) -> u64 {
        self.active_minigame_id.unwrap_or(0)
    }

    pub fn clear_active_minigame_id(&mut self) {
        self.active_minigame_id = ::std::option::Option::None;
    }

    pub fn has_active_minigame_id(&self) -> bool {
        self.active_minigame_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_minigame_id(&mut self, v: u64) {
        self.active_minigame_id = ::std::option::Option::Some(v);
    }

    // optional string avatar_ugc_url = 21;

    pub fn avatar_ugc_url(&self) -> &str {
        match self.avatar_ugc_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_avatar_ugc_url(&mut self) {
        self.avatar_ugc_url = ::std::option::Option::None;
    }

    pub fn has_avatar_ugc_url(&self) -> bool {
        self.avatar_ugc_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar_ugc_url(&mut self, v: ::std::string::String) {
        self.avatar_ugc_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar_ugc_url(&mut self) -> &mut ::std::string::String {
        if self.avatar_ugc_url.is_none() {
            self.avatar_ugc_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.avatar_ugc_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar_ugc_url(&mut self) -> ::std::string::String {
        self.avatar_ugc_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(21);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.chat_group_id },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_name",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.chat_group_name },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.chat_group_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "active_member_count",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.active_member_count },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.active_member_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "active_voice_member_count",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.active_voice_member_count },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.active_voice_member_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "default_chat_id",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.default_chat_id },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.default_chat_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "chat_rooms",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.chat_rooms },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.chat_rooms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "clanid",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.clanid },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.clanid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_tagline",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.chat_group_tagline },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.chat_group_tagline },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid_owner",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.accountid_owner },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.accountid_owner },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "top_members",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.top_members },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.top_members },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_avatar_sha",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.chat_group_avatar_sha },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.chat_group_avatar_sha },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rank",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.rank },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.rank },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "default_role_id",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.default_role_id },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.default_role_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "role_ids",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.role_ids },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.role_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "role_actions",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.role_actions },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.role_actions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "watching_broadcast_accountid",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.watching_broadcast_accountid },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.watching_broadcast_accountid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.appid },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.appid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "party_beacons",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.party_beacons },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.party_beacons },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "watching_broadcast_channel_id",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.watching_broadcast_channel_id },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.watching_broadcast_channel_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "active_minigame_id",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.active_minigame_id },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.active_minigame_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "avatar_ugc_url",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.avatar_ugc_url },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.avatar_ugc_url },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetChatRoomGroupSummary_Response>(
            "CChatRoom_GetChatRoomGroupSummary_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_GetChatRoomGroupSummary_Response {
    const NAME: &'static str = "CChatRoom_GetChatRoomGroupSummary_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.chat_group_name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.active_member_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.active_voice_member_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.default_chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                50 => {
                    self.chat_rooms.push(is.read_message()?);
                },
                56 => {
                    self.clanid = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.chat_group_tagline = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.accountid_owner = ::std::option::Option::Some(is.read_uint32()?);
                },
                82 => {
                    is.read_repeated_packed_uint32_into(&mut self.top_members)?;
                },
                80 => {
                    self.top_members.push(is.read_uint32()?);
                },
                90 => {
                    self.chat_group_avatar_sha = ::std::option::Option::Some(is.read_bytes()?);
                },
                96 => {
                    self.rank = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                104 => {
                    self.default_role_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                114 => {
                    is.read_repeated_packed_uint64_into(&mut self.role_ids)?;
                },
                112 => {
                    self.role_ids.push(is.read_uint64()?);
                },
                122 => {
                    self.role_actions.push(is.read_message()?);
                },
                128 => {
                    self.watching_broadcast_accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                146 => {
                    self.party_beacons.push(is.read_message()?);
                },
                152 => {
                    self.watching_broadcast_channel_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                160 => {
                    self.active_minigame_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                170 => {
                    self.avatar_ugc_url = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_group_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.active_member_count {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.active_voice_member_count {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.default_chat_id {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        for value in &self.chat_rooms {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.clanid {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.chat_group_tagline.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.accountid_owner {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        for value in &self.top_members {
            my_size += ::protobuf::rt::uint32_size(10, *value);
        };
        if let Some(v) = self.chat_group_avatar_sha.as_ref() {
            my_size += ::protobuf::rt::bytes_size(11, &v);
        }
        if let Some(v) = self.rank {
            my_size += ::protobuf::rt::int32_size(12, v.value());
        }
        if let Some(v) = self.default_role_id {
            my_size += ::protobuf::rt::uint64_size(13, v);
        }
        for value in &self.role_ids {
            my_size += ::protobuf::rt::uint64_size(14, *value);
        };
        for value in &self.role_actions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.watching_broadcast_accountid {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        for value in &self.party_beacons {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.watching_broadcast_channel_id {
            my_size += ::protobuf::rt::uint64_size(19, v);
        }
        if let Some(v) = self.active_minigame_id {
            my_size += ::protobuf::rt::uint64_size(20, v);
        }
        if let Some(v) = self.avatar_ugc_url.as_ref() {
            my_size += ::protobuf::rt::string_size(21, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_group_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.active_member_count {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.active_voice_member_count {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.default_chat_id {
            os.write_uint64(5, v)?;
        }
        for v in &self.chat_rooms {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if let Some(v) = self.clanid {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.chat_group_tagline.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.accountid_owner {
            os.write_uint32(9, v)?;
        }
        for v in &self.top_members {
            os.write_uint32(10, *v)?;
        };
        if let Some(v) = self.chat_group_avatar_sha.as_ref() {
            os.write_bytes(11, v)?;
        }
        if let Some(v) = self.rank {
            os.write_enum(12, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.default_role_id {
            os.write_uint64(13, v)?;
        }
        for v in &self.role_ids {
            os.write_uint64(14, *v)?;
        };
        for v in &self.role_actions {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        };
        if let Some(v) = self.watching_broadcast_accountid {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(17, v)?;
        }
        for v in &self.party_beacons {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        };
        if let Some(v) = self.watching_broadcast_channel_id {
            os.write_uint64(19, v)?;
        }
        if let Some(v) = self.active_minigame_id {
            os.write_uint64(20, v)?;
        }
        if let Some(v) = self.avatar_ugc_url.as_ref() {
            os.write_string(21, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetChatRoomGroupSummary_Response {
        CChatRoom_GetChatRoomGroupSummary_Response::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_group_name = ::std::option::Option::None;
        self.active_member_count = ::std::option::Option::None;
        self.active_voice_member_count = ::std::option::Option::None;
        self.default_chat_id = ::std::option::Option::None;
        self.chat_rooms.clear();
        self.clanid = ::std::option::Option::None;
        self.chat_group_tagline = ::std::option::Option::None;
        self.accountid_owner = ::std::option::Option::None;
        self.top_members.clear();
        self.chat_group_avatar_sha = ::std::option::Option::None;
        self.rank = ::std::option::Option::None;
        self.default_role_id = ::std::option::Option::None;
        self.role_ids.clear();
        self.role_actions.clear();
        self.watching_broadcast_accountid = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.party_beacons.clear();
        self.watching_broadcast_channel_id = ::std::option::Option::None;
        self.active_minigame_id = ::std::option::Option::None;
        self.avatar_ugc_url = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetChatRoomGroupSummary_Response {
        static instance: CChatRoom_GetChatRoomGroupSummary_Response = CChatRoom_GetChatRoomGroupSummary_Response {
            chat_group_id: ::std::option::Option::None,
            chat_group_name: ::std::option::Option::None,
            active_member_count: ::std::option::Option::None,
            active_voice_member_count: ::std::option::Option::None,
            default_chat_id: ::std::option::Option::None,
            chat_rooms: ::std::vec::Vec::new(),
            clanid: ::std::option::Option::None,
            chat_group_tagline: ::std::option::Option::None,
            accountid_owner: ::std::option::Option::None,
            top_members: ::std::vec::Vec::new(),
            chat_group_avatar_sha: ::std::option::Option::None,
            rank: ::std::option::Option::None,
            default_role_id: ::std::option::Option::None,
            role_ids: ::std::vec::Vec::new(),
            role_actions: ::std::vec::Vec::new(),
            watching_broadcast_accountid: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            party_beacons: ::std::vec::Vec::new(),
            watching_broadcast_channel_id: ::std::option::Option::None,
            active_minigame_id: ::std::option::Option::None,
            avatar_ugc_url: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_GetChatRoomGroupSummary_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetChatRoomGroupSummary_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetChatRoomGroupSummary_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetChatRoomGroupSummary_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoomSummaryPair)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoomSummaryPair {
    // message fields
    // @@protoc_insertion_point(field:CChatRoomSummaryPair.user_chat_group_state)
    pub user_chat_group_state: ::protobuf::MessageField<CUserChatRoomGroupState>,
    // @@protoc_insertion_point(field:CChatRoomSummaryPair.group_summary)
    pub group_summary: ::protobuf::MessageField<CChatRoom_GetChatRoomGroupSummary_Response>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoomSummaryPair.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoomSummaryPair {
    fn default() -> &'a CChatRoomSummaryPair {
        <CChatRoomSummaryPair as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoomSummaryPair {
    pub fn new() -> CChatRoomSummaryPair {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CUserChatRoomGroupState>(
            "user_chat_group_state",
            |m: &CChatRoomSummaryPair| { &m.user_chat_group_state },
            |m: &mut CChatRoomSummaryPair| { &mut m.user_chat_group_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CChatRoom_GetChatRoomGroupSummary_Response>(
            "group_summary",
            |m: &CChatRoomSummaryPair| { &m.group_summary },
            |m: &mut CChatRoomSummaryPair| { &mut m.group_summary },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoomSummaryPair>(
            "CChatRoomSummaryPair",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoomSummaryPair {
    const NAME: &'static str = "CChatRoomSummaryPair";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_chat_group_state)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.group_summary)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_chat_group_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.group_summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_chat_group_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.group_summary.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoomSummaryPair {
        CChatRoomSummaryPair::new()
    }

    fn clear(&mut self) {
        self.user_chat_group_state.clear();
        self.group_summary.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoomSummaryPair {
        static instance: CChatRoomSummaryPair = CChatRoomSummaryPair {
            user_chat_group_state: ::protobuf::MessageField::none(),
            group_summary: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoomSummaryPair {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoomSummaryPair").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoomSummaryPair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoomSummaryPair {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetMyChatRoomGroups_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetMyChatRoomGroups_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetMyChatRoomGroups_Response.chat_room_groups)
    pub chat_room_groups: ::std::vec::Vec<CChatRoomSummaryPair>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetMyChatRoomGroups_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetMyChatRoomGroups_Response {
    fn default() -> &'a CChatRoom_GetMyChatRoomGroups_Response {
        <CChatRoom_GetMyChatRoomGroups_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetMyChatRoomGroups_Response {
    pub fn new() -> CChatRoom_GetMyChatRoomGroups_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "chat_room_groups",
            |m: &CChatRoom_GetMyChatRoomGroups_Response| { &m.chat_room_groups },
            |m: &mut CChatRoom_GetMyChatRoomGroups_Response| { &mut m.chat_room_groups },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetMyChatRoomGroups_Response>(
            "CChatRoom_GetMyChatRoomGroups_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_GetMyChatRoomGroups_Response {
    const NAME: &'static str = "CChatRoom_GetMyChatRoomGroups_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.chat_room_groups.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.chat_room_groups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.chat_room_groups {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetMyChatRoomGroups_Response {
        CChatRoom_GetMyChatRoomGroups_Response::new()
    }

    fn clear(&mut self) {
        self.chat_room_groups.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetMyChatRoomGroups_Response {
        static instance: CChatRoom_GetMyChatRoomGroups_Response = CChatRoom_GetMyChatRoomGroups_Response {
            chat_room_groups: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_GetMyChatRoomGroups_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetMyChatRoomGroups_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetMyChatRoomGroups_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetMyChatRoomGroups_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetChatRoomGroupState_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetChatRoomGroupState_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupState_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetChatRoomGroupState_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetChatRoomGroupState_Request {
    fn default() -> &'a CChatRoom_GetChatRoomGroupState_Request {
        <CChatRoom_GetChatRoomGroupState_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetChatRoomGroupState_Request {
    pub fn new() -> CChatRoom_GetChatRoomGroupState_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_GetChatRoomGroupState_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_GetChatRoomGroupState_Request| { &mut m.chat_group_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetChatRoomGroupState_Request>(
            "CChatRoom_GetChatRoomGroupState_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_GetChatRoomGroupState_Request {
    const NAME: &'static str = "CChatRoom_GetChatRoomGroupState_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetChatRoomGroupState_Request {
        CChatRoom_GetChatRoomGroupState_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetChatRoomGroupState_Request {
        static instance: CChatRoom_GetChatRoomGroupState_Request = CChatRoom_GetChatRoomGroupState_Request {
            chat_group_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_GetChatRoomGroupState_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetChatRoomGroupState_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetChatRoomGroupState_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetChatRoomGroupState_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetChatRoomGroupState_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetChatRoomGroupState_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupState_Response.state)
    pub state: ::protobuf::MessageField<CChatRoomGroupState>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetChatRoomGroupState_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetChatRoomGroupState_Response {
    fn default() -> &'a CChatRoom_GetChatRoomGroupState_Response {
        <CChatRoom_GetChatRoomGroupState_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetChatRoomGroupState_Response {
    pub fn new() -> CChatRoom_GetChatRoomGroupState_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CChatRoomGroupState>(
            "state",
            |m: &CChatRoom_GetChatRoomGroupState_Response| { &m.state },
            |m: &mut CChatRoom_GetChatRoomGroupState_Response| { &mut m.state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetChatRoomGroupState_Response>(
            "CChatRoom_GetChatRoomGroupState_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_GetChatRoomGroupState_Response {
    const NAME: &'static str = "CChatRoom_GetChatRoomGroupState_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.state)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetChatRoomGroupState_Response {
        CChatRoom_GetChatRoomGroupState_Response::new()
    }

    fn clear(&mut self) {
        self.state.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetChatRoomGroupState_Response {
        static instance: CChatRoom_GetChatRoomGroupState_Response = CChatRoom_GetChatRoomGroupState_Response {
            state: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_GetChatRoomGroupState_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetChatRoomGroupState_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetChatRoomGroupState_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetChatRoomGroupState_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetChatRoomGroupSummary_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetChatRoomGroupSummary_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetChatRoomGroupSummary_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetChatRoomGroupSummary_Request {
    fn default() -> &'a CChatRoom_GetChatRoomGroupSummary_Request {
        <CChatRoom_GetChatRoomGroupSummary_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetChatRoomGroupSummary_Request {
    pub fn new() -> CChatRoom_GetChatRoomGroupSummary_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_GetChatRoomGroupSummary_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Request| { &mut m.chat_group_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetChatRoomGroupSummary_Request>(
            "CChatRoom_GetChatRoomGroupSummary_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_GetChatRoomGroupSummary_Request {
    const NAME: &'static str = "CChatRoom_GetChatRoomGroupSummary_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetChatRoomGroupSummary_Request {
        CChatRoom_GetChatRoomGroupSummary_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetChatRoomGroupSummary_Request {
        static instance: CChatRoom_GetChatRoomGroupSummary_Request = CChatRoom_GetChatRoomGroupSummary_Request {
            chat_group_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_GetChatRoomGroupSummary_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetChatRoomGroupSummary_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetChatRoomGroupSummary_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetChatRoomGroupSummary_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_SetAppChatRoomGroupForceActive_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetAppChatRoomGroupForceActive_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SetAppChatRoomGroupForceActive_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SetAppChatRoomGroupForceActive_Request.requesting_app_id)
    pub requesting_app_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetAppChatRoomGroupForceActive_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetAppChatRoomGroupForceActive_Request {
    fn default() -> &'a CChatRoom_SetAppChatRoomGroupForceActive_Request {
        <CChatRoom_SetAppChatRoomGroupForceActive_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetAppChatRoomGroupForceActive_Request {
    pub fn new() -> CChatRoom_SetAppChatRoomGroupForceActive_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 requesting_app_id = 2;

    pub fn requesting_app_id(&self) -> u32 {
        self.requesting_app_id.unwrap_or(0)
    }

    pub fn clear_requesting_app_id(&mut self) {
        self.requesting_app_id = ::std::option::Option::None;
    }

    pub fn has_requesting_app_id(&self) -> bool {
        self.requesting_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requesting_app_id(&mut self, v: u32) {
        self.requesting_app_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_SetAppChatRoomGroupForceActive_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_SetAppChatRoomGroupForceActive_Request| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "requesting_app_id",
            |m: &CChatRoom_SetAppChatRoomGroupForceActive_Request| { &m.requesting_app_id },
            |m: &mut CChatRoom_SetAppChatRoomGroupForceActive_Request| { &mut m.requesting_app_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SetAppChatRoomGroupForceActive_Request>(
            "CChatRoom_SetAppChatRoomGroupForceActive_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_SetAppChatRoomGroupForceActive_Request {
    const NAME: &'static str = "CChatRoom_SetAppChatRoomGroupForceActive_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.requesting_app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.requesting_app_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.requesting_app_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetAppChatRoomGroupForceActive_Request {
        CChatRoom_SetAppChatRoomGroupForceActive_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.requesting_app_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetAppChatRoomGroupForceActive_Request {
        static instance: CChatRoom_SetAppChatRoomGroupForceActive_Request = CChatRoom_SetAppChatRoomGroupForceActive_Request {
            chat_group_id: ::std::option::Option::None,
            requesting_app_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_SetAppChatRoomGroupForceActive_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SetAppChatRoomGroupForceActive_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SetAppChatRoomGroupForceActive_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetAppChatRoomGroupForceActive_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_SetAppChatRoomGroupForceActive_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetAppChatRoomGroupForceActive_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SetAppChatRoomGroupForceActive_Response.result)
    pub result: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_SetAppChatRoomGroupForceActive_Response.accounts_in_channel)
    pub accounts_in_channel: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetAppChatRoomGroupForceActive_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetAppChatRoomGroupForceActive_Response {
    fn default() -> &'a CChatRoom_SetAppChatRoomGroupForceActive_Response {
        <CChatRoom_SetAppChatRoomGroupForceActive_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetAppChatRoomGroupForceActive_Response {
    pub fn new() -> CChatRoom_SetAppChatRoomGroupForceActive_Response {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CChatRoom_SetAppChatRoomGroupForceActive_Response| { &m.result },
            |m: &mut CChatRoom_SetAppChatRoomGroupForceActive_Response| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "accounts_in_channel",
            |m: &CChatRoom_SetAppChatRoomGroupForceActive_Response| { &m.accounts_in_channel },
            |m: &mut CChatRoom_SetAppChatRoomGroupForceActive_Response| { &mut m.accounts_in_channel },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SetAppChatRoomGroupForceActive_Response>(
            "CChatRoom_SetAppChatRoomGroupForceActive_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_SetAppChatRoomGroupForceActive_Response {
    const NAME: &'static str = "CChatRoom_SetAppChatRoomGroupForceActive_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.accounts_in_channel)?;
                },
                16 => {
                    self.accounts_in_channel.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.accounts_in_channel {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        for v in &self.accounts_in_channel {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetAppChatRoomGroupForceActive_Response {
        CChatRoom_SetAppChatRoomGroupForceActive_Response::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.accounts_in_channel.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetAppChatRoomGroupForceActive_Response {
        static instance: CChatRoom_SetAppChatRoomGroupForceActive_Response = CChatRoom_SetAppChatRoomGroupForceActive_Response {
            result: ::std::option::Option::None,
            accounts_in_channel: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_SetAppChatRoomGroupForceActive_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SetAppChatRoomGroupForceActive_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SetAppChatRoomGroupForceActive_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetAppChatRoomGroupForceActive_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_SetAppChatRoomGroupStopForceActive_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SetAppChatRoomGroupStopForceActive_Notification.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SetAppChatRoomGroupStopForceActive_Notification.requesting_app_id)
    pub requesting_app_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetAppChatRoomGroupStopForceActive_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
    fn default() -> &'a CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
        <CChatRoom_SetAppChatRoomGroupStopForceActive_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
    pub fn new() -> CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 requesting_app_id = 2;

    pub fn requesting_app_id(&self) -> u32 {
        self.requesting_app_id.unwrap_or(0)
    }

    pub fn clear_requesting_app_id(&mut self) {
        self.requesting_app_id = ::std::option::Option::None;
    }

    pub fn has_requesting_app_id(&self) -> bool {
        self.requesting_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requesting_app_id(&mut self, v: u32) {
        self.requesting_app_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_SetAppChatRoomGroupStopForceActive_Notification| { &m.chat_group_id },
            |m: &mut CChatRoom_SetAppChatRoomGroupStopForceActive_Notification| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "requesting_app_id",
            |m: &CChatRoom_SetAppChatRoomGroupStopForceActive_Notification| { &m.requesting_app_id },
            |m: &mut CChatRoom_SetAppChatRoomGroupStopForceActive_Notification| { &mut m.requesting_app_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SetAppChatRoomGroupStopForceActive_Notification>(
            "CChatRoom_SetAppChatRoomGroupStopForceActive_Notification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
    const NAME: &'static str = "CChatRoom_SetAppChatRoomGroupStopForceActive_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.requesting_app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.requesting_app_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.requesting_app_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
        CChatRoom_SetAppChatRoomGroupStopForceActive_Notification::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.requesting_app_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
        static instance: CChatRoom_SetAppChatRoomGroupStopForceActive_Notification = CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
            chat_group_id: ::std::option::Option::None,
            requesting_app_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SetAppChatRoomGroupStopForceActive_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_AckChatMessage_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_AckChatMessage_Notification {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_AckChatMessage_Notification.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_AckChatMessage_Notification.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_AckChatMessage_Notification.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_AckChatMessage_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_AckChatMessage_Notification {
    fn default() -> &'a CChatRoom_AckChatMessage_Notification {
        <CChatRoom_AckChatMessage_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_AckChatMessage_Notification {
    pub fn new() -> CChatRoom_AckChatMessage_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 3;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_AckChatMessage_Notification| { &m.chat_group_id },
            |m: &mut CChatRoom_AckChatMessage_Notification| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_AckChatMessage_Notification| { &m.chat_id },
            |m: &mut CChatRoom_AckChatMessage_Notification| { &mut m.chat_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &CChatRoom_AckChatMessage_Notification| { &m.timestamp },
            |m: &mut CChatRoom_AckChatMessage_Notification| { &mut m.timestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_AckChatMessage_Notification>(
            "CChatRoom_AckChatMessage_Notification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_AckChatMessage_Notification {
    const NAME: &'static str = "CChatRoom_AckChatMessage_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_AckChatMessage_Notification {
        CChatRoom_AckChatMessage_Notification::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_AckChatMessage_Notification {
        static instance: CChatRoom_AckChatMessage_Notification = CChatRoom_AckChatMessage_Notification {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_AckChatMessage_Notification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_AckChatMessage_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_AckChatMessage_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_AckChatMessage_Notification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_CreateInviteLink_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_CreateInviteLink_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_CreateInviteLink_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_CreateInviteLink_Request.seconds_valid)
    pub seconds_valid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_CreateInviteLink_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_CreateInviteLink_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_CreateInviteLink_Request {
    fn default() -> &'a CChatRoom_CreateInviteLink_Request {
        <CChatRoom_CreateInviteLink_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_CreateInviteLink_Request {
    pub fn new() -> CChatRoom_CreateInviteLink_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_valid = 2;

    pub fn seconds_valid(&self) -> u32 {
        self.seconds_valid.unwrap_or(0)
    }

    pub fn clear_seconds_valid(&mut self) {
        self.seconds_valid = ::std::option::Option::None;
    }

    pub fn has_seconds_valid(&self) -> bool {
        self.seconds_valid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_valid(&mut self, v: u32) {
        self.seconds_valid = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 3;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_CreateInviteLink_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_CreateInviteLink_Request| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seconds_valid",
            |m: &CChatRoom_CreateInviteLink_Request| { &m.seconds_valid },
            |m: &mut CChatRoom_CreateInviteLink_Request| { &mut m.seconds_valid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_CreateInviteLink_Request| { &m.chat_id },
            |m: &mut CChatRoom_CreateInviteLink_Request| { &mut m.chat_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_CreateInviteLink_Request>(
            "CChatRoom_CreateInviteLink_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_CreateInviteLink_Request {
    const NAME: &'static str = "CChatRoom_CreateInviteLink_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.seconds_valid = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.seconds_valid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.seconds_valid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_CreateInviteLink_Request {
        CChatRoom_CreateInviteLink_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.seconds_valid = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_CreateInviteLink_Request {
        static instance: CChatRoom_CreateInviteLink_Request = CChatRoom_CreateInviteLink_Request {
            chat_group_id: ::std::option::Option::None,
            seconds_valid: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_CreateInviteLink_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_CreateInviteLink_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_CreateInviteLink_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_CreateInviteLink_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_CreateInviteLink_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_CreateInviteLink_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_CreateInviteLink_Response.invite_code)
    pub invite_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_CreateInviteLink_Response.seconds_valid)
    pub seconds_valid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_CreateInviteLink_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_CreateInviteLink_Response {
    fn default() -> &'a CChatRoom_CreateInviteLink_Response {
        <CChatRoom_CreateInviteLink_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_CreateInviteLink_Response {
    pub fn new() -> CChatRoom_CreateInviteLink_Response {
        ::std::default::Default::default()
    }

    // optional string invite_code = 1;

    pub fn invite_code(&self) -> &str {
        match self.invite_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_invite_code(&mut self) {
        self.invite_code = ::std::option::Option::None;
    }

    pub fn has_invite_code(&self) -> bool {
        self.invite_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invite_code(&mut self, v: ::std::string::String) {
        self.invite_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_invite_code(&mut self) -> &mut ::std::string::String {
        if self.invite_code.is_none() {
            self.invite_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.invite_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_invite_code(&mut self) -> ::std::string::String {
        self.invite_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 seconds_valid = 2;

    pub fn seconds_valid(&self) -> u32 {
        self.seconds_valid.unwrap_or(0)
    }

    pub fn clear_seconds_valid(&mut self) {
        self.seconds_valid = ::std::option::Option::None;
    }

    pub fn has_seconds_valid(&self) -> bool {
        self.seconds_valid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_valid(&mut self, v: u32) {
        self.seconds_valid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "invite_code",
            |m: &CChatRoom_CreateInviteLink_Response| { &m.invite_code },
            |m: &mut CChatRoom_CreateInviteLink_Response| { &mut m.invite_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seconds_valid",
            |m: &CChatRoom_CreateInviteLink_Response| { &m.seconds_valid },
            |m: &mut CChatRoom_CreateInviteLink_Response| { &mut m.seconds_valid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_CreateInviteLink_Response>(
            "CChatRoom_CreateInviteLink_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_CreateInviteLink_Response {
    const NAME: &'static str = "CChatRoom_CreateInviteLink_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.invite_code = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.seconds_valid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.invite_code.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.seconds_valid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.invite_code.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.seconds_valid {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_CreateInviteLink_Response {
        CChatRoom_CreateInviteLink_Response::new()
    }

    fn clear(&mut self) {
        self.invite_code = ::std::option::Option::None;
        self.seconds_valid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_CreateInviteLink_Response {
        static instance: CChatRoom_CreateInviteLink_Response = CChatRoom_CreateInviteLink_Response {
            invite_code: ::std::option::Option::None,
            seconds_valid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_CreateInviteLink_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_CreateInviteLink_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_CreateInviteLink_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_CreateInviteLink_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetInviteLinkInfo_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetInviteLinkInfo_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetInviteLinkInfo_Request.invite_code)
    pub invite_code: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetInviteLinkInfo_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteLinkInfo_Request {
    fn default() -> &'a CChatRoom_GetInviteLinkInfo_Request {
        <CChatRoom_GetInviteLinkInfo_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteLinkInfo_Request {
    pub fn new() -> CChatRoom_GetInviteLinkInfo_Request {
        ::std::default::Default::default()
    }

    // optional string invite_code = 1;

    pub fn invite_code(&self) -> &str {
        match self.invite_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_invite_code(&mut self) {
        self.invite_code = ::std::option::Option::None;
    }

    pub fn has_invite_code(&self) -> bool {
        self.invite_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invite_code(&mut self, v: ::std::string::String) {
        self.invite_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_invite_code(&mut self) -> &mut ::std::string::String {
        if self.invite_code.is_none() {
            self.invite_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.invite_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_invite_code(&mut self) -> ::std::string::String {
        self.invite_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "invite_code",
            |m: &CChatRoom_GetInviteLinkInfo_Request| { &m.invite_code },
            |m: &mut CChatRoom_GetInviteLinkInfo_Request| { &mut m.invite_code },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetInviteLinkInfo_Request>(
            "CChatRoom_GetInviteLinkInfo_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_GetInviteLinkInfo_Request {
    const NAME: &'static str = "CChatRoom_GetInviteLinkInfo_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.invite_code = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.invite_code.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.invite_code.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetInviteLinkInfo_Request {
        CChatRoom_GetInviteLinkInfo_Request::new()
    }

    fn clear(&mut self) {
        self.invite_code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetInviteLinkInfo_Request {
        static instance: CChatRoom_GetInviteLinkInfo_Request = CChatRoom_GetInviteLinkInfo_Request {
            invite_code: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_GetInviteLinkInfo_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetInviteLinkInfo_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetInviteLinkInfo_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetInviteLinkInfo_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetInviteLinkInfo_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetInviteLinkInfo_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetInviteLinkInfo_Response.steamid_sender)
    pub steamid_sender: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetInviteLinkInfo_Response.time_expires)
    pub time_expires: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetInviteLinkInfo_Response.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetInviteLinkInfo_Response.group_summary)
    pub group_summary: ::protobuf::MessageField<CChatRoom_GetChatRoomGroupSummary_Response>,
    // @@protoc_insertion_point(field:CChatRoom_GetInviteLinkInfo_Response.user_chat_group_state)
    pub user_chat_group_state: ::protobuf::MessageField<CUserChatRoomGroupState>,
    // @@protoc_insertion_point(field:CChatRoom_GetInviteLinkInfo_Response.time_kick_expire)
    pub time_kick_expire: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetInviteLinkInfo_Response.banned)
    pub banned: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetInviteLinkInfo_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteLinkInfo_Response {
    fn default() -> &'a CChatRoom_GetInviteLinkInfo_Response {
        <CChatRoom_GetInviteLinkInfo_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteLinkInfo_Response {
    pub fn new() -> CChatRoom_GetInviteLinkInfo_Response {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_sender = 3;

    pub fn steamid_sender(&self) -> u64 {
        self.steamid_sender.unwrap_or(0)
    }

    pub fn clear_steamid_sender(&mut self) {
        self.steamid_sender = ::std::option::Option::None;
    }

    pub fn has_steamid_sender(&self) -> bool {
        self.steamid_sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_sender(&mut self, v: u64) {
        self.steamid_sender = ::std::option::Option::Some(v);
    }

    // optional uint32 time_expires = 4;

    pub fn time_expires(&self) -> u32 {
        self.time_expires.unwrap_or(0)
    }

    pub fn clear_time_expires(&mut self) {
        self.time_expires = ::std::option::Option::None;
    }

    pub fn has_time_expires(&self) -> bool {
        self.time_expires.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_expires(&mut self, v: u32) {
        self.time_expires = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 6;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 time_kick_expire = 10;

    pub fn time_kick_expire(&self) -> u32 {
        self.time_kick_expire.unwrap_or(0)
    }

    pub fn clear_time_kick_expire(&mut self) {
        self.time_kick_expire = ::std::option::Option::None;
    }

    pub fn has_time_kick_expire(&self) -> bool {
        self.time_kick_expire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_kick_expire(&mut self, v: u32) {
        self.time_kick_expire = ::std::option::Option::Some(v);
    }

    // optional bool banned = 11;

    pub fn banned(&self) -> bool {
        self.banned.unwrap_or(false)
    }

    pub fn clear_banned(&mut self) {
        self.banned = ::std::option::Option::None;
    }

    pub fn has_banned(&self) -> bool {
        self.banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_banned(&mut self, v: bool) {
        self.banned = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid_sender",
            |m: &CChatRoom_GetInviteLinkInfo_Response| { &m.steamid_sender },
            |m: &mut CChatRoom_GetInviteLinkInfo_Response| { &mut m.steamid_sender },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_expires",
            |m: &CChatRoom_GetInviteLinkInfo_Response| { &m.time_expires },
            |m: &mut CChatRoom_GetInviteLinkInfo_Response| { &mut m.time_expires },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_GetInviteLinkInfo_Response| { &m.chat_id },
            |m: &mut CChatRoom_GetInviteLinkInfo_Response| { &mut m.chat_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CChatRoom_GetChatRoomGroupSummary_Response>(
            "group_summary",
            |m: &CChatRoom_GetInviteLinkInfo_Response| { &m.group_summary },
            |m: &mut CChatRoom_GetInviteLinkInfo_Response| { &mut m.group_summary },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CUserChatRoomGroupState>(
            "user_chat_group_state",
            |m: &CChatRoom_GetInviteLinkInfo_Response| { &m.user_chat_group_state },
            |m: &mut CChatRoom_GetInviteLinkInfo_Response| { &mut m.user_chat_group_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_kick_expire",
            |m: &CChatRoom_GetInviteLinkInfo_Response| { &m.time_kick_expire },
            |m: &mut CChatRoom_GetInviteLinkInfo_Response| { &mut m.time_kick_expire },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "banned",
            |m: &CChatRoom_GetInviteLinkInfo_Response| { &m.banned },
            |m: &mut CChatRoom_GetInviteLinkInfo_Response| { &mut m.banned },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetInviteLinkInfo_Response>(
            "CChatRoom_GetInviteLinkInfo_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_GetInviteLinkInfo_Response {
    const NAME: &'static str = "CChatRoom_GetInviteLinkInfo_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                25 => {
                    self.steamid_sender = ::std::option::Option::Some(is.read_fixed64()?);
                },
                32 => {
                    self.time_expires = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.group_summary)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_chat_group_state)?;
                },
                80 => {
                    self.time_kick_expire = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.banned = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_sender {
            my_size += 1 + 8;
        }
        if let Some(v) = self.time_expires {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.group_summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.user_chat_group_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.time_kick_expire {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.banned {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid_sender {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.time_expires {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.group_summary.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.user_chat_group_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.time_kick_expire {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.banned {
            os.write_bool(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetInviteLinkInfo_Response {
        CChatRoom_GetInviteLinkInfo_Response::new()
    }

    fn clear(&mut self) {
        self.steamid_sender = ::std::option::Option::None;
        self.time_expires = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.group_summary.clear();
        self.user_chat_group_state.clear();
        self.time_kick_expire = ::std::option::Option::None;
        self.banned = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetInviteLinkInfo_Response {
        static instance: CChatRoom_GetInviteLinkInfo_Response = CChatRoom_GetInviteLinkInfo_Response {
            steamid_sender: ::std::option::Option::None,
            time_expires: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            group_summary: ::protobuf::MessageField::none(),
            user_chat_group_state: ::protobuf::MessageField::none(),
            time_kick_expire: ::std::option::Option::None,
            banned: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_GetInviteLinkInfo_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetInviteLinkInfo_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetInviteLinkInfo_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetInviteLinkInfo_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetInviteInfo_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetInviteInfo_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetInviteInfo_Request.steamid_invitee)
    pub steamid_invitee: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetInviteInfo_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetInviteInfo_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetInviteInfo_Request.invite_code)
    pub invite_code: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetInviteInfo_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteInfo_Request {
    fn default() -> &'a CChatRoom_GetInviteInfo_Request {
        <CChatRoom_GetInviteInfo_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteInfo_Request {
    pub fn new() -> CChatRoom_GetInviteInfo_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_invitee = 1;

    pub fn steamid_invitee(&self) -> u64 {
        self.steamid_invitee.unwrap_or(0)
    }

    pub fn clear_steamid_invitee(&mut self) {
        self.steamid_invitee = ::std::option::Option::None;
    }

    pub fn has_steamid_invitee(&self) -> bool {
        self.steamid_invitee.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_invitee(&mut self, v: u64) {
        self.steamid_invitee = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_group_id = 2;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 3;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional string invite_code = 4;

    pub fn invite_code(&self) -> &str {
        match self.invite_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_invite_code(&mut self) {
        self.invite_code = ::std::option::Option::None;
    }

    pub fn has_invite_code(&self) -> bool {
        self.invite_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invite_code(&mut self, v: ::std::string::String) {
        self.invite_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_invite_code(&mut self) -> &mut ::std::string::String {
        if self.invite_code.is_none() {
            self.invite_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.invite_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_invite_code(&mut self) -> ::std::string::String {
        self.invite_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid_invitee",
            |m: &CChatRoom_GetInviteInfo_Request| { &m.steamid_invitee },
            |m: &mut CChatRoom_GetInviteInfo_Request| { &mut m.steamid_invitee },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_GetInviteInfo_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_GetInviteInfo_Request| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_GetInviteInfo_Request| { &m.chat_id },
            |m: &mut CChatRoom_GetInviteInfo_Request| { &mut m.chat_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "invite_code",
            |m: &CChatRoom_GetInviteInfo_Request| { &m.invite_code },
            |m: &mut CChatRoom_GetInviteInfo_Request| { &mut m.invite_code },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetInviteInfo_Request>(
            "CChatRoom_GetInviteInfo_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_GetInviteInfo_Request {
    const NAME: &'static str = "CChatRoom_GetInviteInfo_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid_invitee = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                34 => {
                    self.invite_code = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_invitee {
            my_size += 1 + 8;
        }
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.invite_code.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid_invitee {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.chat_group_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.invite_code.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetInviteInfo_Request {
        CChatRoom_GetInviteInfo_Request::new()
    }

    fn clear(&mut self) {
        self.steamid_invitee = ::std::option::Option::None;
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.invite_code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetInviteInfo_Request {
        static instance: CChatRoom_GetInviteInfo_Request = CChatRoom_GetInviteInfo_Request {
            steamid_invitee: ::std::option::Option::None,
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            invite_code: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_GetInviteInfo_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetInviteInfo_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetInviteInfo_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetInviteInfo_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetInviteInfo_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetInviteInfo_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetInviteInfo_Response.group_summary)
    pub group_summary: ::protobuf::MessageField<CChatRoom_GetChatRoomGroupSummary_Response>,
    // @@protoc_insertion_point(field:CChatRoom_GetInviteInfo_Response.time_kick_expire)
    pub time_kick_expire: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetInviteInfo_Response.banned)
    pub banned: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetInviteInfo_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteInfo_Response {
    fn default() -> &'a CChatRoom_GetInviteInfo_Response {
        <CChatRoom_GetInviteInfo_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteInfo_Response {
    pub fn new() -> CChatRoom_GetInviteInfo_Response {
        ::std::default::Default::default()
    }

    // optional uint32 time_kick_expire = 2;

    pub fn time_kick_expire(&self) -> u32 {
        self.time_kick_expire.unwrap_or(0)
    }

    pub fn clear_time_kick_expire(&mut self) {
        self.time_kick_expire = ::std::option::Option::None;
    }

    pub fn has_time_kick_expire(&self) -> bool {
        self.time_kick_expire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_kick_expire(&mut self, v: u32) {
        self.time_kick_expire = ::std::option::Option::Some(v);
    }

    // optional bool banned = 3;

    pub fn banned(&self) -> bool {
        self.banned.unwrap_or(false)
    }

    pub fn clear_banned(&mut self) {
        self.banned = ::std::option::Option::None;
    }

    pub fn has_banned(&self) -> bool {
        self.banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_banned(&mut self, v: bool) {
        self.banned = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CChatRoom_GetChatRoomGroupSummary_Response>(
            "group_summary",
            |m: &CChatRoom_GetInviteInfo_Response| { &m.group_summary },
            |m: &mut CChatRoom_GetInviteInfo_Response| { &mut m.group_summary },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_kick_expire",
            |m: &CChatRoom_GetInviteInfo_Response| { &m.time_kick_expire },
            |m: &mut CChatRoom_GetInviteInfo_Response| { &mut m.time_kick_expire },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "banned",
            |m: &CChatRoom_GetInviteInfo_Response| { &m.banned },
            |m: &mut CChatRoom_GetInviteInfo_Response| { &mut m.banned },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetInviteInfo_Response>(
            "CChatRoom_GetInviteInfo_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_GetInviteInfo_Response {
    const NAME: &'static str = "CChatRoom_GetInviteInfo_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.group_summary)?;
                },
                16 => {
                    self.time_kick_expire = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.banned = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.group_summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.time_kick_expire {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.banned {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.group_summary.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.time_kick_expire {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.banned {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetInviteInfo_Response {
        CChatRoom_GetInviteInfo_Response::new()
    }

    fn clear(&mut self) {
        self.group_summary.clear();
        self.time_kick_expire = ::std::option::Option::None;
        self.banned = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetInviteInfo_Response {
        static instance: CChatRoom_GetInviteInfo_Response = CChatRoom_GetInviteInfo_Response {
            group_summary: ::protobuf::MessageField::none(),
            time_kick_expire: ::std::option::Option::None,
            banned: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_GetInviteInfo_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetInviteInfo_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetInviteInfo_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetInviteInfo_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetInviteLinksForGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetInviteLinksForGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetInviteLinksForGroup_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetInviteLinksForGroup_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteLinksForGroup_Request {
    fn default() -> &'a CChatRoom_GetInviteLinksForGroup_Request {
        <CChatRoom_GetInviteLinksForGroup_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteLinksForGroup_Request {
    pub fn new() -> CChatRoom_GetInviteLinksForGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_GetInviteLinksForGroup_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_GetInviteLinksForGroup_Request| { &mut m.chat_group_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetInviteLinksForGroup_Request>(
            "CChatRoom_GetInviteLinksForGroup_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_GetInviteLinksForGroup_Request {
    const NAME: &'static str = "CChatRoom_GetInviteLinksForGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetInviteLinksForGroup_Request {
        CChatRoom_GetInviteLinksForGroup_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetInviteLinksForGroup_Request {
        static instance: CChatRoom_GetInviteLinksForGroup_Request = CChatRoom_GetInviteLinksForGroup_Request {
            chat_group_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_GetInviteLinksForGroup_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetInviteLinksForGroup_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetInviteLinksForGroup_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetInviteLinksForGroup_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetInviteLinksForGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetInviteLinksForGroup_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetInviteLinksForGroup_Response.invite_links)
    pub invite_links: ::std::vec::Vec<cchat_room_get_invite_links_for_group_response::LinkInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetInviteLinksForGroup_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteLinksForGroup_Response {
    fn default() -> &'a CChatRoom_GetInviteLinksForGroup_Response {
        <CChatRoom_GetInviteLinksForGroup_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteLinksForGroup_Response {
    pub fn new() -> CChatRoom_GetInviteLinksForGroup_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "invite_links",
            |m: &CChatRoom_GetInviteLinksForGroup_Response| { &m.invite_links },
            |m: &mut CChatRoom_GetInviteLinksForGroup_Response| { &mut m.invite_links },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetInviteLinksForGroup_Response>(
            "CChatRoom_GetInviteLinksForGroup_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_GetInviteLinksForGroup_Response {
    const NAME: &'static str = "CChatRoom_GetInviteLinksForGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.invite_links.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.invite_links {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.invite_links {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetInviteLinksForGroup_Response {
        CChatRoom_GetInviteLinksForGroup_Response::new()
    }

    fn clear(&mut self) {
        self.invite_links.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetInviteLinksForGroup_Response {
        static instance: CChatRoom_GetInviteLinksForGroup_Response = CChatRoom_GetInviteLinksForGroup_Response {
            invite_links: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_GetInviteLinksForGroup_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetInviteLinksForGroup_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetInviteLinksForGroup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetInviteLinksForGroup_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CChatRoom_GetInviteLinksForGroup_Response`
pub mod cchat_room_get_invite_links_for_group_response {
    // @@protoc_insertion_point(message:CChatRoom_GetInviteLinksForGroup_Response.LinkInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LinkInfo {
        // message fields
        // @@protoc_insertion_point(field:CChatRoom_GetInviteLinksForGroup_Response.LinkInfo.invite_code)
        pub invite_code: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CChatRoom_GetInviteLinksForGroup_Response.LinkInfo.steamid_creator)
        pub steamid_creator: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CChatRoom_GetInviteLinksForGroup_Response.LinkInfo.time_expires)
        pub time_expires: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CChatRoom_GetInviteLinksForGroup_Response.LinkInfo.chat_id)
        pub chat_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CChatRoom_GetInviteLinksForGroup_Response.LinkInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LinkInfo {
        fn default() -> &'a LinkInfo {
            <LinkInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl LinkInfo {
        pub fn new() -> LinkInfo {
            ::std::default::Default::default()
        }

        // optional string invite_code = 1;

        pub fn invite_code(&self) -> &str {
            match self.invite_code.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_invite_code(&mut self) {
            self.invite_code = ::std::option::Option::None;
        }

        pub fn has_invite_code(&self) -> bool {
            self.invite_code.is_some()
        }

        // Param is passed by value, moved
        pub fn set_invite_code(&mut self, v: ::std::string::String) {
            self.invite_code = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_invite_code(&mut self) -> &mut ::std::string::String {
            if self.invite_code.is_none() {
                self.invite_code = ::std::option::Option::Some(::std::string::String::new());
            }
            self.invite_code.as_mut().unwrap()
        }

        // Take field
        pub fn take_invite_code(&mut self) -> ::std::string::String {
            self.invite_code.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional fixed64 steamid_creator = 2;

        pub fn steamid_creator(&self) -> u64 {
            self.steamid_creator.unwrap_or(0)
        }

        pub fn clear_steamid_creator(&mut self) {
            self.steamid_creator = ::std::option::Option::None;
        }

        pub fn has_steamid_creator(&self) -> bool {
            self.steamid_creator.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid_creator(&mut self, v: u64) {
            self.steamid_creator = ::std::option::Option::Some(v);
        }

        // optional uint32 time_expires = 3;

        pub fn time_expires(&self) -> u32 {
            self.time_expires.unwrap_or(0)
        }

        pub fn clear_time_expires(&mut self) {
            self.time_expires = ::std::option::Option::None;
        }

        pub fn has_time_expires(&self) -> bool {
            self.time_expires.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_expires(&mut self, v: u32) {
            self.time_expires = ::std::option::Option::Some(v);
        }

        // optional uint64 chat_id = 4;

        pub fn chat_id(&self) -> u64 {
            self.chat_id.unwrap_or(0)
        }

        pub fn clear_chat_id(&mut self) {
            self.chat_id = ::std::option::Option::None;
        }

        pub fn has_chat_id(&self) -> bool {
            self.chat_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_chat_id(&mut self, v: u64) {
            self.chat_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "invite_code",
                |m: &LinkInfo| { &m.invite_code },
                |m: &mut LinkInfo| { &mut m.invite_code },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "steamid_creator",
                |m: &LinkInfo| { &m.steamid_creator },
                |m: &mut LinkInfo| { &mut m.steamid_creator },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "time_expires",
                |m: &LinkInfo| { &m.time_expires },
                |m: &mut LinkInfo| { &mut m.time_expires },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "chat_id",
                |m: &LinkInfo| { &m.chat_id },
                |m: &mut LinkInfo| { &mut m.chat_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinkInfo>(
                "CChatRoom_GetInviteLinksForGroup_Response.LinkInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for LinkInfo {
        const NAME: &'static str = "LinkInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.invite_code = ::std::option::Option::Some(is.read_string()?);
                    },
                    17 => {
                        self.steamid_creator = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    24 => {
                        self.time_expires = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.invite_code.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.steamid_creator {
                my_size += 1 + 8;
            }
            if let Some(v) = self.time_expires {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.chat_id {
                my_size += ::protobuf::rt::uint64_size(4, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.invite_code.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.steamid_creator {
                os.write_fixed64(2, v)?;
            }
            if let Some(v) = self.time_expires {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.chat_id {
                os.write_uint64(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LinkInfo {
            LinkInfo::new()
        }

        fn clear(&mut self) {
            self.invite_code = ::std::option::Option::None;
            self.steamid_creator = ::std::option::Option::None;
            self.time_expires = ::std::option::Option::None;
            self.chat_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LinkInfo {
            static instance: LinkInfo = LinkInfo {
                invite_code: ::std::option::Option::None,
                steamid_creator: ::std::option::Option::None,
                time_expires: ::std::option::Option::None,
                chat_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for LinkInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CChatRoom_GetInviteLinksForGroup_Response.LinkInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for LinkInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for LinkInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CChatRoom_GetBanList_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetBanList_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetBanList_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetBanList_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetBanList_Request {
    fn default() -> &'a CChatRoom_GetBanList_Request {
        <CChatRoom_GetBanList_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetBanList_Request {
    pub fn new() -> CChatRoom_GetBanList_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_GetBanList_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_GetBanList_Request| { &mut m.chat_group_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetBanList_Request>(
            "CChatRoom_GetBanList_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_GetBanList_Request {
    const NAME: &'static str = "CChatRoom_GetBanList_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetBanList_Request {
        CChatRoom_GetBanList_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetBanList_Request {
        static instance: CChatRoom_GetBanList_Request = CChatRoom_GetBanList_Request {
            chat_group_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_GetBanList_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetBanList_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetBanList_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetBanList_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetBanList_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetBanList_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetBanList_Response.bans)
    pub bans: ::std::vec::Vec<cchat_room_get_ban_list_response::BanInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetBanList_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetBanList_Response {
    fn default() -> &'a CChatRoom_GetBanList_Response {
        <CChatRoom_GetBanList_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetBanList_Response {
    pub fn new() -> CChatRoom_GetBanList_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "bans",
            |m: &CChatRoom_GetBanList_Response| { &m.bans },
            |m: &mut CChatRoom_GetBanList_Response| { &mut m.bans },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetBanList_Response>(
            "CChatRoom_GetBanList_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_GetBanList_Response {
    const NAME: &'static str = "CChatRoom_GetBanList_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.bans.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.bans {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.bans {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetBanList_Response {
        CChatRoom_GetBanList_Response::new()
    }

    fn clear(&mut self) {
        self.bans.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetBanList_Response {
        static instance: CChatRoom_GetBanList_Response = CChatRoom_GetBanList_Response {
            bans: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_GetBanList_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetBanList_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetBanList_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetBanList_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CChatRoom_GetBanList_Response`
pub mod cchat_room_get_ban_list_response {
    // @@protoc_insertion_point(message:CChatRoom_GetBanList_Response.BanInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BanInfo {
        // message fields
        // @@protoc_insertion_point(field:CChatRoom_GetBanList_Response.BanInfo.accountid)
        pub accountid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CChatRoom_GetBanList_Response.BanInfo.accountid_actor)
        pub accountid_actor: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CChatRoom_GetBanList_Response.BanInfo.time_banned)
        pub time_banned: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CChatRoom_GetBanList_Response.BanInfo.ban_reason)
        pub ban_reason: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CChatRoom_GetBanList_Response.BanInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BanInfo {
        fn default() -> &'a BanInfo {
            <BanInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl BanInfo {
        pub fn new() -> BanInfo {
            ::std::default::Default::default()
        }

        // optional uint32 accountid = 1;

        pub fn accountid(&self) -> u32 {
            self.accountid.unwrap_or(0)
        }

        pub fn clear_accountid(&mut self) {
            self.accountid = ::std::option::Option::None;
        }

        pub fn has_accountid(&self) -> bool {
            self.accountid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_accountid(&mut self, v: u32) {
            self.accountid = ::std::option::Option::Some(v);
        }

        // optional uint32 accountid_actor = 2;

        pub fn accountid_actor(&self) -> u32 {
            self.accountid_actor.unwrap_or(0)
        }

        pub fn clear_accountid_actor(&mut self) {
            self.accountid_actor = ::std::option::Option::None;
        }

        pub fn has_accountid_actor(&self) -> bool {
            self.accountid_actor.is_some()
        }

        // Param is passed by value, moved
        pub fn set_accountid_actor(&mut self, v: u32) {
            self.accountid_actor = ::std::option::Option::Some(v);
        }

        // optional uint32 time_banned = 3;

        pub fn time_banned(&self) -> u32 {
            self.time_banned.unwrap_or(0)
        }

        pub fn clear_time_banned(&mut self) {
            self.time_banned = ::std::option::Option::None;
        }

        pub fn has_time_banned(&self) -> bool {
            self.time_banned.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_banned(&mut self, v: u32) {
            self.time_banned = ::std::option::Option::Some(v);
        }

        // optional string ban_reason = 4;

        pub fn ban_reason(&self) -> &str {
            match self.ban_reason.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_ban_reason(&mut self) {
            self.ban_reason = ::std::option::Option::None;
        }

        pub fn has_ban_reason(&self) -> bool {
            self.ban_reason.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ban_reason(&mut self, v: ::std::string::String) {
            self.ban_reason = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_ban_reason(&mut self) -> &mut ::std::string::String {
            if self.ban_reason.is_none() {
                self.ban_reason = ::std::option::Option::Some(::std::string::String::new());
            }
            self.ban_reason.as_mut().unwrap()
        }

        // Take field
        pub fn take_ban_reason(&mut self) -> ::std::string::String {
            self.ban_reason.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "accountid",
                |m: &BanInfo| { &m.accountid },
                |m: &mut BanInfo| { &mut m.accountid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "accountid_actor",
                |m: &BanInfo| { &m.accountid_actor },
                |m: &mut BanInfo| { &mut m.accountid_actor },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "time_banned",
                |m: &BanInfo| { &m.time_banned },
                |m: &mut BanInfo| { &mut m.time_banned },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ban_reason",
                |m: &BanInfo| { &m.ban_reason },
                |m: &mut BanInfo| { &mut m.ban_reason },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BanInfo>(
                "CChatRoom_GetBanList_Response.BanInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for BanInfo {
        const NAME: &'static str = "BanInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.accountid_actor = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.time_banned = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    34 => {
                        self.ban_reason = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.accountid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.accountid_actor {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.time_banned {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.ban_reason.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.accountid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.accountid_actor {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.time_banned {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.ban_reason.as_ref() {
                os.write_string(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BanInfo {
            BanInfo::new()
        }

        fn clear(&mut self) {
            self.accountid = ::std::option::Option::None;
            self.accountid_actor = ::std::option::Option::None;
            self.time_banned = ::std::option::Option::None;
            self.ban_reason = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BanInfo {
            static instance: BanInfo = BanInfo {
                accountid: ::std::option::Option::None,
                accountid_actor: ::std::option::Option::None,
                time_banned: ::std::option::Option::None,
                ban_reason: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for BanInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CChatRoom_GetBanList_Response.BanInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for BanInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for BanInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CChatRoom_GetInviteList_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetInviteList_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetInviteList_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetInviteList_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteList_Request {
    fn default() -> &'a CChatRoom_GetInviteList_Request {
        <CChatRoom_GetInviteList_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteList_Request {
    pub fn new() -> CChatRoom_GetInviteList_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_GetInviteList_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_GetInviteList_Request| { &mut m.chat_group_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetInviteList_Request>(
            "CChatRoom_GetInviteList_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_GetInviteList_Request {
    const NAME: &'static str = "CChatRoom_GetInviteList_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetInviteList_Request {
        CChatRoom_GetInviteList_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetInviteList_Request {
        static instance: CChatRoom_GetInviteList_Request = CChatRoom_GetInviteList_Request {
            chat_group_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_GetInviteList_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetInviteList_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetInviteList_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetInviteList_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoomGroupInvite)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoomGroupInvite {
    // message fields
    // @@protoc_insertion_point(field:CChatRoomGroupInvite.accountid)
    pub accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoomGroupInvite.accountid_actor)
    pub accountid_actor: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoomGroupInvite.time_invited)
    pub time_invited: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoomGroupInvite.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoomGroupInvite {
    fn default() -> &'a CChatRoomGroupInvite {
        <CChatRoomGroupInvite as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoomGroupInvite {
    pub fn new() -> CChatRoomGroupInvite {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;

    pub fn accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 accountid_actor = 2;

    pub fn accountid_actor(&self) -> u32 {
        self.accountid_actor.unwrap_or(0)
    }

    pub fn clear_accountid_actor(&mut self) {
        self.accountid_actor = ::std::option::Option::None;
    }

    pub fn has_accountid_actor(&self) -> bool {
        self.accountid_actor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid_actor(&mut self, v: u32) {
        self.accountid_actor = ::std::option::Option::Some(v);
    }

    // optional uint32 time_invited = 3;

    pub fn time_invited(&self) -> u32 {
        self.time_invited.unwrap_or(0)
    }

    pub fn clear_time_invited(&mut self) {
        self.time_invited = ::std::option::Option::None;
    }

    pub fn has_time_invited(&self) -> bool {
        self.time_invited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_invited(&mut self, v: u32) {
        self.time_invited = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid",
            |m: &CChatRoomGroupInvite| { &m.accountid },
            |m: &mut CChatRoomGroupInvite| { &mut m.accountid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid_actor",
            |m: &CChatRoomGroupInvite| { &m.accountid_actor },
            |m: &mut CChatRoomGroupInvite| { &mut m.accountid_actor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_invited",
            |m: &CChatRoomGroupInvite| { &m.time_invited },
            |m: &mut CChatRoomGroupInvite| { &mut m.time_invited },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoomGroupInvite>(
            "CChatRoomGroupInvite",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoomGroupInvite {
    const NAME: &'static str = "CChatRoomGroupInvite";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.accountid_actor = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.time_invited = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.accountid_actor {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.time_invited {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.accountid_actor {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.time_invited {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoomGroupInvite {
        CChatRoomGroupInvite::new()
    }

    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.accountid_actor = ::std::option::Option::None;
        self.time_invited = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoomGroupInvite {
        static instance: CChatRoomGroupInvite = CChatRoomGroupInvite {
            accountid: ::std::option::Option::None,
            accountid_actor: ::std::option::Option::None,
            time_invited: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoomGroupInvite {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoomGroupInvite").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoomGroupInvite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoomGroupInvite {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetInviteList_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetInviteList_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetInviteList_Response.invites)
    pub invites: ::std::vec::Vec<CChatRoomGroupInvite>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetInviteList_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteList_Response {
    fn default() -> &'a CChatRoom_GetInviteList_Response {
        <CChatRoom_GetInviteList_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteList_Response {
    pub fn new() -> CChatRoom_GetInviteList_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "invites",
            |m: &CChatRoom_GetInviteList_Response| { &m.invites },
            |m: &mut CChatRoom_GetInviteList_Response| { &mut m.invites },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetInviteList_Response>(
            "CChatRoom_GetInviteList_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_GetInviteList_Response {
    const NAME: &'static str = "CChatRoom_GetInviteList_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.invites.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.invites {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.invites {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetInviteList_Response {
        CChatRoom_GetInviteList_Response::new()
    }

    fn clear(&mut self) {
        self.invites.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetInviteList_Response {
        static instance: CChatRoom_GetInviteList_Response = CChatRoom_GetInviteList_Response {
            invites: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_GetInviteList_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetInviteList_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetInviteList_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetInviteList_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_DeleteInviteLink_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_DeleteInviteLink_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_DeleteInviteLink_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_DeleteInviteLink_Request.invite_code)
    pub invite_code: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_DeleteInviteLink_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteInviteLink_Request {
    fn default() -> &'a CChatRoom_DeleteInviteLink_Request {
        <CChatRoom_DeleteInviteLink_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteInviteLink_Request {
    pub fn new() -> CChatRoom_DeleteInviteLink_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string invite_code = 2;

    pub fn invite_code(&self) -> &str {
        match self.invite_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_invite_code(&mut self) {
        self.invite_code = ::std::option::Option::None;
    }

    pub fn has_invite_code(&self) -> bool {
        self.invite_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invite_code(&mut self, v: ::std::string::String) {
        self.invite_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_invite_code(&mut self) -> &mut ::std::string::String {
        if self.invite_code.is_none() {
            self.invite_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.invite_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_invite_code(&mut self) -> ::std::string::String {
        self.invite_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_DeleteInviteLink_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_DeleteInviteLink_Request| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "invite_code",
            |m: &CChatRoom_DeleteInviteLink_Request| { &m.invite_code },
            |m: &mut CChatRoom_DeleteInviteLink_Request| { &mut m.invite_code },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_DeleteInviteLink_Request>(
            "CChatRoom_DeleteInviteLink_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_DeleteInviteLink_Request {
    const NAME: &'static str = "CChatRoom_DeleteInviteLink_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.invite_code = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.invite_code.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.invite_code.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_DeleteInviteLink_Request {
        CChatRoom_DeleteInviteLink_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.invite_code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_DeleteInviteLink_Request {
        static instance: CChatRoom_DeleteInviteLink_Request = CChatRoom_DeleteInviteLink_Request {
            chat_group_id: ::std::option::Option::None,
            invite_code: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_DeleteInviteLink_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_DeleteInviteLink_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_DeleteInviteLink_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_DeleteInviteLink_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_DeleteInviteLink_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_DeleteInviteLink_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_DeleteInviteLink_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteInviteLink_Response {
    fn default() -> &'a CChatRoom_DeleteInviteLink_Response {
        <CChatRoom_DeleteInviteLink_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteInviteLink_Response {
    pub fn new() -> CChatRoom_DeleteInviteLink_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_DeleteInviteLink_Response>(
            "CChatRoom_DeleteInviteLink_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_DeleteInviteLink_Response {
    const NAME: &'static str = "CChatRoom_DeleteInviteLink_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_DeleteInviteLink_Response {
        CChatRoom_DeleteInviteLink_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_DeleteInviteLink_Response {
        static instance: CChatRoom_DeleteInviteLink_Response = CChatRoom_DeleteInviteLink_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_DeleteInviteLink_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_DeleteInviteLink_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_DeleteInviteLink_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_DeleteInviteLink_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_SetSessionActiveChatRoomGroups_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetSessionActiveChatRoomGroups_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SetSessionActiveChatRoomGroups_Request.chat_group_ids)
    pub chat_group_ids: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SetSessionActiveChatRoomGroups_Request.chat_groups_data_requested)
    pub chat_groups_data_requested: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SetSessionActiveChatRoomGroups_Request.virtualize_members_threshold)
    pub virtualize_members_threshold: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetSessionActiveChatRoomGroups_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetSessionActiveChatRoomGroups_Request {
    fn default() -> &'a CChatRoom_SetSessionActiveChatRoomGroups_Request {
        <CChatRoom_SetSessionActiveChatRoomGroups_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetSessionActiveChatRoomGroups_Request {
    pub fn new() -> CChatRoom_SetSessionActiveChatRoomGroups_Request {
        ::std::default::Default::default()
    }

    // optional int32 virtualize_members_threshold = 3;

    pub fn virtualize_members_threshold(&self) -> i32 {
        self.virtualize_members_threshold.unwrap_or(0)
    }

    pub fn clear_virtualize_members_threshold(&mut self) {
        self.virtualize_members_threshold = ::std::option::Option::None;
    }

    pub fn has_virtualize_members_threshold(&self) -> bool {
        self.virtualize_members_threshold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_virtualize_members_threshold(&mut self, v: i32) {
        self.virtualize_members_threshold = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "chat_group_ids",
            |m: &CChatRoom_SetSessionActiveChatRoomGroups_Request| { &m.chat_group_ids },
            |m: &mut CChatRoom_SetSessionActiveChatRoomGroups_Request| { &mut m.chat_group_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "chat_groups_data_requested",
            |m: &CChatRoom_SetSessionActiveChatRoomGroups_Request| { &m.chat_groups_data_requested },
            |m: &mut CChatRoom_SetSessionActiveChatRoomGroups_Request| { &mut m.chat_groups_data_requested },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "virtualize_members_threshold",
            |m: &CChatRoom_SetSessionActiveChatRoomGroups_Request| { &m.virtualize_members_threshold },
            |m: &mut CChatRoom_SetSessionActiveChatRoomGroups_Request| { &mut m.virtualize_members_threshold },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SetSessionActiveChatRoomGroups_Request>(
            "CChatRoom_SetSessionActiveChatRoomGroups_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_SetSessionActiveChatRoomGroups_Request {
    const NAME: &'static str = "CChatRoom_SetSessionActiveChatRoomGroups_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.chat_group_ids)?;
                },
                8 => {
                    self.chat_group_ids.push(is.read_uint64()?);
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.chat_groups_data_requested)?;
                },
                16 => {
                    self.chat_groups_data_requested.push(is.read_uint64()?);
                },
                24 => {
                    self.virtualize_members_threshold = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.chat_group_ids {
            my_size += ::protobuf::rt::uint64_size(1, *value);
        };
        for value in &self.chat_groups_data_requested {
            my_size += ::protobuf::rt::uint64_size(2, *value);
        };
        if let Some(v) = self.virtualize_members_threshold {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.chat_group_ids {
            os.write_uint64(1, *v)?;
        };
        for v in &self.chat_groups_data_requested {
            os.write_uint64(2, *v)?;
        };
        if let Some(v) = self.virtualize_members_threshold {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetSessionActiveChatRoomGroups_Request {
        CChatRoom_SetSessionActiveChatRoomGroups_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_ids.clear();
        self.chat_groups_data_requested.clear();
        self.virtualize_members_threshold = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetSessionActiveChatRoomGroups_Request {
        static instance: CChatRoom_SetSessionActiveChatRoomGroups_Request = CChatRoom_SetSessionActiveChatRoomGroups_Request {
            chat_group_ids: ::std::vec::Vec::new(),
            chat_groups_data_requested: ::std::vec::Vec::new(),
            virtualize_members_threshold: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_SetSessionActiveChatRoomGroups_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SetSessionActiveChatRoomGroups_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SetSessionActiveChatRoomGroups_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetSessionActiveChatRoomGroups_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_SetSessionActiveChatRoomGroups_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetSessionActiveChatRoomGroups_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SetSessionActiveChatRoomGroups_Response.chat_states)
    pub chat_states: ::std::vec::Vec<CChatRoomGroupState>,
    // @@protoc_insertion_point(field:CChatRoom_SetSessionActiveChatRoomGroups_Response.virtualize_members_chat_group_ids)
    pub virtualize_members_chat_group_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetSessionActiveChatRoomGroups_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetSessionActiveChatRoomGroups_Response {
    fn default() -> &'a CChatRoom_SetSessionActiveChatRoomGroups_Response {
        <CChatRoom_SetSessionActiveChatRoomGroups_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetSessionActiveChatRoomGroups_Response {
    pub fn new() -> CChatRoom_SetSessionActiveChatRoomGroups_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "chat_states",
            |m: &CChatRoom_SetSessionActiveChatRoomGroups_Response| { &m.chat_states },
            |m: &mut CChatRoom_SetSessionActiveChatRoomGroups_Response| { &mut m.chat_states },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "virtualize_members_chat_group_ids",
            |m: &CChatRoom_SetSessionActiveChatRoomGroups_Response| { &m.virtualize_members_chat_group_ids },
            |m: &mut CChatRoom_SetSessionActiveChatRoomGroups_Response| { &mut m.virtualize_members_chat_group_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SetSessionActiveChatRoomGroups_Response>(
            "CChatRoom_SetSessionActiveChatRoomGroups_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_SetSessionActiveChatRoomGroups_Response {
    const NAME: &'static str = "CChatRoom_SetSessionActiveChatRoomGroups_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.chat_states.push(is.read_message()?);
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.virtualize_members_chat_group_ids)?;
                },
                16 => {
                    self.virtualize_members_chat_group_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.chat_states {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.virtualize_members_chat_group_ids {
            my_size += ::protobuf::rt::uint64_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.chat_states {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.virtualize_members_chat_group_ids {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetSessionActiveChatRoomGroups_Response {
        CChatRoom_SetSessionActiveChatRoomGroups_Response::new()
    }

    fn clear(&mut self) {
        self.chat_states.clear();
        self.virtualize_members_chat_group_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetSessionActiveChatRoomGroups_Response {
        static instance: CChatRoom_SetSessionActiveChatRoomGroups_Response = CChatRoom_SetSessionActiveChatRoomGroups_Response {
            chat_states: ::std::vec::Vec::new(),
            virtualize_members_chat_group_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_SetSessionActiveChatRoomGroups_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SetSessionActiveChatRoomGroups_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SetSessionActiveChatRoomGroups_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetSessionActiveChatRoomGroups_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_SetUserChatGroupPreferences_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetUserChatGroupPreferences_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SetUserChatGroupPreferences_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SetUserChatGroupPreferences_Request.chat_group_preferences)
    pub chat_group_preferences: ::protobuf::MessageField<cchat_room_set_user_chat_group_preferences_request::ChatGroupPreferences>,
    // @@protoc_insertion_point(field:CChatRoom_SetUserChatGroupPreferences_Request.chat_room_preferences)
    pub chat_room_preferences: ::std::vec::Vec<cchat_room_set_user_chat_group_preferences_request::ChatRoomPreferences>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetUserChatGroupPreferences_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetUserChatGroupPreferences_Request {
    fn default() -> &'a CChatRoom_SetUserChatGroupPreferences_Request {
        <CChatRoom_SetUserChatGroupPreferences_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetUserChatGroupPreferences_Request {
    pub fn new() -> CChatRoom_SetUserChatGroupPreferences_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_SetUserChatGroupPreferences_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_SetUserChatGroupPreferences_Request| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cchat_room_set_user_chat_group_preferences_request::ChatGroupPreferences>(
            "chat_group_preferences",
            |m: &CChatRoom_SetUserChatGroupPreferences_Request| { &m.chat_group_preferences },
            |m: &mut CChatRoom_SetUserChatGroupPreferences_Request| { &mut m.chat_group_preferences },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "chat_room_preferences",
            |m: &CChatRoom_SetUserChatGroupPreferences_Request| { &m.chat_room_preferences },
            |m: &mut CChatRoom_SetUserChatGroupPreferences_Request| { &mut m.chat_room_preferences },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SetUserChatGroupPreferences_Request>(
            "CChatRoom_SetUserChatGroupPreferences_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_SetUserChatGroupPreferences_Request {
    const NAME: &'static str = "CChatRoom_SetUserChatGroupPreferences_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.chat_group_preferences)?;
                },
                26 => {
                    self.chat_room_preferences.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_group_preferences.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.chat_room_preferences {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_group_preferences.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.chat_room_preferences {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetUserChatGroupPreferences_Request {
        CChatRoom_SetUserChatGroupPreferences_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_group_preferences.clear();
        self.chat_room_preferences.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetUserChatGroupPreferences_Request {
        static instance: CChatRoom_SetUserChatGroupPreferences_Request = CChatRoom_SetUserChatGroupPreferences_Request {
            chat_group_id: ::std::option::Option::None,
            chat_group_preferences: ::protobuf::MessageField::none(),
            chat_room_preferences: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_SetUserChatGroupPreferences_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SetUserChatGroupPreferences_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SetUserChatGroupPreferences_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetUserChatGroupPreferences_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CChatRoom_SetUserChatGroupPreferences_Request`
pub mod cchat_room_set_user_chat_group_preferences_request {
    // @@protoc_insertion_point(message:CChatRoom_SetUserChatGroupPreferences_Request.ChatGroupPreferences)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ChatGroupPreferences {
        // message fields
        // @@protoc_insertion_point(field:CChatRoom_SetUserChatGroupPreferences_Request.ChatGroupPreferences.desktop_notification_level)
        pub desktop_notification_level: ::std::option::Option<::protobuf::EnumOrUnknown<super::EChatRoomNotificationLevel>>,
        // @@protoc_insertion_point(field:CChatRoom_SetUserChatGroupPreferences_Request.ChatGroupPreferences.mobile_notification_level)
        pub mobile_notification_level: ::std::option::Option<::protobuf::EnumOrUnknown<super::EChatRoomNotificationLevel>>,
        // @@protoc_insertion_point(field:CChatRoom_SetUserChatGroupPreferences_Request.ChatGroupPreferences.unread_indicator_muted)
        pub unread_indicator_muted: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CChatRoom_SetUserChatGroupPreferences_Request.ChatGroupPreferences.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ChatGroupPreferences {
        fn default() -> &'a ChatGroupPreferences {
            <ChatGroupPreferences as ::protobuf::Message>::default_instance()
        }
    }

    impl ChatGroupPreferences {
        pub fn new() -> ChatGroupPreferences {
            ::std::default::Default::default()
        }

        // optional .EChatRoomNotificationLevel desktop_notification_level = 1;

        pub fn desktop_notification_level(&self) -> super::EChatRoomNotificationLevel {
            match self.desktop_notification_level {
                Some(e) => e.enum_value_or(super::EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid),
                None => super::EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid,
            }
        }

        pub fn clear_desktop_notification_level(&mut self) {
            self.desktop_notification_level = ::std::option::Option::None;
        }

        pub fn has_desktop_notification_level(&self) -> bool {
            self.desktop_notification_level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_desktop_notification_level(&mut self, v: super::EChatRoomNotificationLevel) {
            self.desktop_notification_level = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional .EChatRoomNotificationLevel mobile_notification_level = 2;

        pub fn mobile_notification_level(&self) -> super::EChatRoomNotificationLevel {
            match self.mobile_notification_level {
                Some(e) => e.enum_value_or(super::EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid),
                None => super::EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid,
            }
        }

        pub fn clear_mobile_notification_level(&mut self) {
            self.mobile_notification_level = ::std::option::Option::None;
        }

        pub fn has_mobile_notification_level(&self) -> bool {
            self.mobile_notification_level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mobile_notification_level(&mut self, v: super::EChatRoomNotificationLevel) {
            self.mobile_notification_level = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional bool unread_indicator_muted = 3;

        pub fn unread_indicator_muted(&self) -> bool {
            self.unread_indicator_muted.unwrap_or(false)
        }

        pub fn clear_unread_indicator_muted(&mut self) {
            self.unread_indicator_muted = ::std::option::Option::None;
        }

        pub fn has_unread_indicator_muted(&self) -> bool {
            self.unread_indicator_muted.is_some()
        }

        // Param is passed by value, moved
        pub fn set_unread_indicator_muted(&mut self, v: bool) {
            self.unread_indicator_muted = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "desktop_notification_level",
                |m: &ChatGroupPreferences| { &m.desktop_notification_level },
                |m: &mut ChatGroupPreferences| { &mut m.desktop_notification_level },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "mobile_notification_level",
                |m: &ChatGroupPreferences| { &m.mobile_notification_level },
                |m: &mut ChatGroupPreferences| { &mut m.mobile_notification_level },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "unread_indicator_muted",
                |m: &ChatGroupPreferences| { &m.unread_indicator_muted },
                |m: &mut ChatGroupPreferences| { &mut m.unread_indicator_muted },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChatGroupPreferences>(
                "CChatRoom_SetUserChatGroupPreferences_Request.ChatGroupPreferences",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ChatGroupPreferences {
        const NAME: &'static str = "ChatGroupPreferences";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.desktop_notification_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    16 => {
                        self.mobile_notification_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    24 => {
                        self.unread_indicator_muted = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.desktop_notification_level {
                my_size += ::protobuf::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.mobile_notification_level {
                my_size += ::protobuf::rt::int32_size(2, v.value());
            }
            if let Some(v) = self.unread_indicator_muted {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.desktop_notification_level {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.mobile_notification_level {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.unread_indicator_muted {
                os.write_bool(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ChatGroupPreferences {
            ChatGroupPreferences::new()
        }

        fn clear(&mut self) {
            self.desktop_notification_level = ::std::option::Option::None;
            self.mobile_notification_level = ::std::option::Option::None;
            self.unread_indicator_muted = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ChatGroupPreferences {
            static instance: ChatGroupPreferences = ChatGroupPreferences {
                desktop_notification_level: ::std::option::Option::None,
                mobile_notification_level: ::std::option::Option::None,
                unread_indicator_muted: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ChatGroupPreferences {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CChatRoom_SetUserChatGroupPreferences_Request.ChatGroupPreferences").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ChatGroupPreferences {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ChatGroupPreferences {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CChatRoom_SetUserChatGroupPreferences_Request.ChatRoomPreferences)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ChatRoomPreferences {
        // message fields
        // @@protoc_insertion_point(field:CChatRoom_SetUserChatGroupPreferences_Request.ChatRoomPreferences.chat_id)
        pub chat_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CChatRoom_SetUserChatGroupPreferences_Request.ChatRoomPreferences.desktop_notification_level)
        pub desktop_notification_level: ::std::option::Option<::protobuf::EnumOrUnknown<super::EChatRoomNotificationLevel>>,
        // @@protoc_insertion_point(field:CChatRoom_SetUserChatGroupPreferences_Request.ChatRoomPreferences.mobile_notification_level)
        pub mobile_notification_level: ::std::option::Option<::protobuf::EnumOrUnknown<super::EChatRoomNotificationLevel>>,
        // @@protoc_insertion_point(field:CChatRoom_SetUserChatGroupPreferences_Request.ChatRoomPreferences.unread_indicator_muted)
        pub unread_indicator_muted: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CChatRoom_SetUserChatGroupPreferences_Request.ChatRoomPreferences.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ChatRoomPreferences {
        fn default() -> &'a ChatRoomPreferences {
            <ChatRoomPreferences as ::protobuf::Message>::default_instance()
        }
    }

    impl ChatRoomPreferences {
        pub fn new() -> ChatRoomPreferences {
            ::std::default::Default::default()
        }

        // optional uint64 chat_id = 1;

        pub fn chat_id(&self) -> u64 {
            self.chat_id.unwrap_or(0)
        }

        pub fn clear_chat_id(&mut self) {
            self.chat_id = ::std::option::Option::None;
        }

        pub fn has_chat_id(&self) -> bool {
            self.chat_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_chat_id(&mut self, v: u64) {
            self.chat_id = ::std::option::Option::Some(v);
        }

        // optional .EChatRoomNotificationLevel desktop_notification_level = 2;

        pub fn desktop_notification_level(&self) -> super::EChatRoomNotificationLevel {
            match self.desktop_notification_level {
                Some(e) => e.enum_value_or(super::EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid),
                None => super::EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid,
            }
        }

        pub fn clear_desktop_notification_level(&mut self) {
            self.desktop_notification_level = ::std::option::Option::None;
        }

        pub fn has_desktop_notification_level(&self) -> bool {
            self.desktop_notification_level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_desktop_notification_level(&mut self, v: super::EChatRoomNotificationLevel) {
            self.desktop_notification_level = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional .EChatRoomNotificationLevel mobile_notification_level = 3;

        pub fn mobile_notification_level(&self) -> super::EChatRoomNotificationLevel {
            match self.mobile_notification_level {
                Some(e) => e.enum_value_or(super::EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid),
                None => super::EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid,
            }
        }

        pub fn clear_mobile_notification_level(&mut self) {
            self.mobile_notification_level = ::std::option::Option::None;
        }

        pub fn has_mobile_notification_level(&self) -> bool {
            self.mobile_notification_level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mobile_notification_level(&mut self, v: super::EChatRoomNotificationLevel) {
            self.mobile_notification_level = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional bool unread_indicator_muted = 4;

        pub fn unread_indicator_muted(&self) -> bool {
            self.unread_indicator_muted.unwrap_or(false)
        }

        pub fn clear_unread_indicator_muted(&mut self) {
            self.unread_indicator_muted = ::std::option::Option::None;
        }

        pub fn has_unread_indicator_muted(&self) -> bool {
            self.unread_indicator_muted.is_some()
        }

        // Param is passed by value, moved
        pub fn set_unread_indicator_muted(&mut self, v: bool) {
            self.unread_indicator_muted = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "chat_id",
                |m: &ChatRoomPreferences| { &m.chat_id },
                |m: &mut ChatRoomPreferences| { &mut m.chat_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "desktop_notification_level",
                |m: &ChatRoomPreferences| { &m.desktop_notification_level },
                |m: &mut ChatRoomPreferences| { &mut m.desktop_notification_level },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "mobile_notification_level",
                |m: &ChatRoomPreferences| { &m.mobile_notification_level },
                |m: &mut ChatRoomPreferences| { &mut m.mobile_notification_level },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "unread_indicator_muted",
                |m: &ChatRoomPreferences| { &m.unread_indicator_muted },
                |m: &mut ChatRoomPreferences| { &mut m.unread_indicator_muted },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChatRoomPreferences>(
                "CChatRoom_SetUserChatGroupPreferences_Request.ChatRoomPreferences",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ChatRoomPreferences {
        const NAME: &'static str = "ChatRoomPreferences";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.desktop_notification_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    24 => {
                        self.mobile_notification_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    32 => {
                        self.unread_indicator_muted = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.chat_id {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.desktop_notification_level {
                my_size += ::protobuf::rt::int32_size(2, v.value());
            }
            if let Some(v) = self.mobile_notification_level {
                my_size += ::protobuf::rt::int32_size(3, v.value());
            }
            if let Some(v) = self.unread_indicator_muted {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.chat_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.desktop_notification_level {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.mobile_notification_level {
                os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.unread_indicator_muted {
                os.write_bool(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ChatRoomPreferences {
            ChatRoomPreferences::new()
        }

        fn clear(&mut self) {
            self.chat_id = ::std::option::Option::None;
            self.desktop_notification_level = ::std::option::Option::None;
            self.mobile_notification_level = ::std::option::Option::None;
            self.unread_indicator_muted = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ChatRoomPreferences {
            static instance: ChatRoomPreferences = ChatRoomPreferences {
                chat_id: ::std::option::Option::None,
                desktop_notification_level: ::std::option::Option::None,
                mobile_notification_level: ::std::option::Option::None,
                unread_indicator_muted: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ChatRoomPreferences {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CChatRoom_SetUserChatGroupPreferences_Request.ChatRoomPreferences").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ChatRoomPreferences {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ChatRoomPreferences {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CChatRoom_SetUserChatGroupPreferences_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetUserChatGroupPreferences_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetUserChatGroupPreferences_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetUserChatGroupPreferences_Response {
    fn default() -> &'a CChatRoom_SetUserChatGroupPreferences_Response {
        <CChatRoom_SetUserChatGroupPreferences_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetUserChatGroupPreferences_Response {
    pub fn new() -> CChatRoom_SetUserChatGroupPreferences_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SetUserChatGroupPreferences_Response>(
            "CChatRoom_SetUserChatGroupPreferences_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_SetUserChatGroupPreferences_Response {
    const NAME: &'static str = "CChatRoom_SetUserChatGroupPreferences_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetUserChatGroupPreferences_Response {
        CChatRoom_SetUserChatGroupPreferences_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetUserChatGroupPreferences_Response {
        static instance: CChatRoom_SetUserChatGroupPreferences_Response = CChatRoom_SetUserChatGroupPreferences_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_SetUserChatGroupPreferences_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SetUserChatGroupPreferences_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SetUserChatGroupPreferences_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetUserChatGroupPreferences_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_DeleteChatMessages_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_DeleteChatMessages_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_DeleteChatMessages_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_DeleteChatMessages_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_DeleteChatMessages_Request.messages)
    pub messages: ::std::vec::Vec<cchat_room_delete_chat_messages_request::Message>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_DeleteChatMessages_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteChatMessages_Request {
    fn default() -> &'a CChatRoom_DeleteChatMessages_Request {
        <CChatRoom_DeleteChatMessages_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteChatMessages_Request {
    pub fn new() -> CChatRoom_DeleteChatMessages_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_DeleteChatMessages_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_DeleteChatMessages_Request| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_DeleteChatMessages_Request| { &m.chat_id },
            |m: &mut CChatRoom_DeleteChatMessages_Request| { &mut m.chat_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "messages",
            |m: &CChatRoom_DeleteChatMessages_Request| { &m.messages },
            |m: &mut CChatRoom_DeleteChatMessages_Request| { &mut m.messages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_DeleteChatMessages_Request>(
            "CChatRoom_DeleteChatMessages_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_DeleteChatMessages_Request {
    const NAME: &'static str = "CChatRoom_DeleteChatMessages_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.messages.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        for v in &self.messages {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_DeleteChatMessages_Request {
        CChatRoom_DeleteChatMessages_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.messages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_DeleteChatMessages_Request {
        static instance: CChatRoom_DeleteChatMessages_Request = CChatRoom_DeleteChatMessages_Request {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            messages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_DeleteChatMessages_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_DeleteChatMessages_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_DeleteChatMessages_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_DeleteChatMessages_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CChatRoom_DeleteChatMessages_Request`
pub mod cchat_room_delete_chat_messages_request {
    // @@protoc_insertion_point(message:CChatRoom_DeleteChatMessages_Request.Message)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Message {
        // message fields
        // @@protoc_insertion_point(field:CChatRoom_DeleteChatMessages_Request.Message.server_timestamp)
        pub server_timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CChatRoom_DeleteChatMessages_Request.Message.ordinal)
        pub ordinal: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CChatRoom_DeleteChatMessages_Request.Message.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Message {
        fn default() -> &'a Message {
            <Message as ::protobuf::Message>::default_instance()
        }
    }

    impl Message {
        pub fn new() -> Message {
            ::std::default::Default::default()
        }

        // optional uint32 server_timestamp = 1;

        pub fn server_timestamp(&self) -> u32 {
            self.server_timestamp.unwrap_or(0)
        }

        pub fn clear_server_timestamp(&mut self) {
            self.server_timestamp = ::std::option::Option::None;
        }

        pub fn has_server_timestamp(&self) -> bool {
            self.server_timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_server_timestamp(&mut self, v: u32) {
            self.server_timestamp = ::std::option::Option::Some(v);
        }

        // optional uint32 ordinal = 2;

        pub fn ordinal(&self) -> u32 {
            self.ordinal.unwrap_or(0)
        }

        pub fn clear_ordinal(&mut self) {
            self.ordinal = ::std::option::Option::None;
        }

        pub fn has_ordinal(&self) -> bool {
            self.ordinal.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ordinal(&mut self, v: u32) {
            self.ordinal = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "server_timestamp",
                |m: &Message| { &m.server_timestamp },
                |m: &mut Message| { &mut m.server_timestamp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ordinal",
                |m: &Message| { &m.ordinal },
                |m: &mut Message| { &mut m.ordinal },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Message>(
                "CChatRoom_DeleteChatMessages_Request.Message",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Message {
        const NAME: &'static str = "Message";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.server_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.ordinal = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.server_timestamp {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.ordinal {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.server_timestamp {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.ordinal {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Message {
            Message::new()
        }

        fn clear(&mut self) {
            self.server_timestamp = ::std::option::Option::None;
            self.ordinal = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Message {
            static instance: Message = Message {
                server_timestamp: ::std::option::Option::None,
                ordinal: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Message {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CChatRoom_DeleteChatMessages_Request.Message").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Message {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Message {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CChatRoom_DeleteChatMessages_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_DeleteChatMessages_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_DeleteChatMessages_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteChatMessages_Response {
    fn default() -> &'a CChatRoom_DeleteChatMessages_Response {
        <CChatRoom_DeleteChatMessages_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteChatMessages_Response {
    pub fn new() -> CChatRoom_DeleteChatMessages_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_DeleteChatMessages_Response>(
            "CChatRoom_DeleteChatMessages_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_DeleteChatMessages_Response {
    const NAME: &'static str = "CChatRoom_DeleteChatMessages_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_DeleteChatMessages_Response {
        CChatRoom_DeleteChatMessages_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_DeleteChatMessages_Response {
        static instance: CChatRoom_DeleteChatMessages_Response = CChatRoom_DeleteChatMessages_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_DeleteChatMessages_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_DeleteChatMessages_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_DeleteChatMessages_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_DeleteChatMessages_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_UpdateMemberListView_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_UpdateMemberListView_Notification {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_UpdateMemberListView_Notification.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_UpdateMemberListView_Notification.view_id)
    pub view_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_UpdateMemberListView_Notification.start)
    pub start: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CChatRoom_UpdateMemberListView_Notification.end)
    pub end: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CChatRoom_UpdateMemberListView_Notification.client_changenumber)
    pub client_changenumber: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CChatRoom_UpdateMemberListView_Notification.delete_view)
    pub delete_view: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatRoom_UpdateMemberListView_Notification.persona_subscribe_accountids)
    pub persona_subscribe_accountids: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CChatRoom_UpdateMemberListView_Notification.persona_unsubscribe_accountids)
    pub persona_unsubscribe_accountids: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_UpdateMemberListView_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_UpdateMemberListView_Notification {
    fn default() -> &'a CChatRoom_UpdateMemberListView_Notification {
        <CChatRoom_UpdateMemberListView_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_UpdateMemberListView_Notification {
    pub fn new() -> CChatRoom_UpdateMemberListView_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 view_id = 2;

    pub fn view_id(&self) -> u64 {
        self.view_id.unwrap_or(0)
    }

    pub fn clear_view_id(&mut self) {
        self.view_id = ::std::option::Option::None;
    }

    pub fn has_view_id(&self) -> bool {
        self.view_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_id(&mut self, v: u64) {
        self.view_id = ::std::option::Option::Some(v);
    }

    // optional int32 start = 3;

    pub fn start(&self) -> i32 {
        self.start.unwrap_or(0)
    }

    pub fn clear_start(&mut self) {
        self.start = ::std::option::Option::None;
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: i32) {
        self.start = ::std::option::Option::Some(v);
    }

    // optional int32 end = 4;

    pub fn end(&self) -> i32 {
        self.end.unwrap_or(0)
    }

    pub fn clear_end(&mut self) {
        self.end = ::std::option::Option::None;
    }

    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: i32) {
        self.end = ::std::option::Option::Some(v);
    }

    // optional int32 client_changenumber = 5;

    pub fn client_changenumber(&self) -> i32 {
        self.client_changenumber.unwrap_or(0)
    }

    pub fn clear_client_changenumber(&mut self) {
        self.client_changenumber = ::std::option::Option::None;
    }

    pub fn has_client_changenumber(&self) -> bool {
        self.client_changenumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_changenumber(&mut self, v: i32) {
        self.client_changenumber = ::std::option::Option::Some(v);
    }

    // optional bool delete_view = 6;

    pub fn delete_view(&self) -> bool {
        self.delete_view.unwrap_or(false)
    }

    pub fn clear_delete_view(&mut self) {
        self.delete_view = ::std::option::Option::None;
    }

    pub fn has_delete_view(&self) -> bool {
        self.delete_view.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delete_view(&mut self, v: bool) {
        self.delete_view = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_UpdateMemberListView_Notification| { &m.chat_group_id },
            |m: &mut CChatRoom_UpdateMemberListView_Notification| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "view_id",
            |m: &CChatRoom_UpdateMemberListView_Notification| { &m.view_id },
            |m: &mut CChatRoom_UpdateMemberListView_Notification| { &mut m.view_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start",
            |m: &CChatRoom_UpdateMemberListView_Notification| { &m.start },
            |m: &mut CChatRoom_UpdateMemberListView_Notification| { &mut m.start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "end",
            |m: &CChatRoom_UpdateMemberListView_Notification| { &m.end },
            |m: &mut CChatRoom_UpdateMemberListView_Notification| { &mut m.end },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_changenumber",
            |m: &CChatRoom_UpdateMemberListView_Notification| { &m.client_changenumber },
            |m: &mut CChatRoom_UpdateMemberListView_Notification| { &mut m.client_changenumber },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "delete_view",
            |m: &CChatRoom_UpdateMemberListView_Notification| { &m.delete_view },
            |m: &mut CChatRoom_UpdateMemberListView_Notification| { &mut m.delete_view },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "persona_subscribe_accountids",
            |m: &CChatRoom_UpdateMemberListView_Notification| { &m.persona_subscribe_accountids },
            |m: &mut CChatRoom_UpdateMemberListView_Notification| { &mut m.persona_subscribe_accountids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "persona_unsubscribe_accountids",
            |m: &CChatRoom_UpdateMemberListView_Notification| { &m.persona_unsubscribe_accountids },
            |m: &mut CChatRoom_UpdateMemberListView_Notification| { &mut m.persona_unsubscribe_accountids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_UpdateMemberListView_Notification>(
            "CChatRoom_UpdateMemberListView_Notification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_UpdateMemberListView_Notification {
    const NAME: &'static str = "CChatRoom_UpdateMemberListView_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.view_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.start = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.end = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.client_changenumber = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.delete_view = ::std::option::Option::Some(is.read_bool()?);
                },
                58 => {
                    is.read_repeated_packed_int32_into(&mut self.persona_subscribe_accountids)?;
                },
                56 => {
                    self.persona_subscribe_accountids.push(is.read_int32()?);
                },
                66 => {
                    is.read_repeated_packed_int32_into(&mut self.persona_unsubscribe_accountids)?;
                },
                64 => {
                    self.persona_unsubscribe_accountids.push(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.view_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.start {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.end {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.client_changenumber {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.delete_view {
            my_size += 1 + 1;
        }
        for value in &self.persona_subscribe_accountids {
            my_size += ::protobuf::rt::int32_size(7, *value);
        };
        for value in &self.persona_unsubscribe_accountids {
            my_size += ::protobuf::rt::int32_size(8, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.view_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.start {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.end {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.client_changenumber {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.delete_view {
            os.write_bool(6, v)?;
        }
        for v in &self.persona_subscribe_accountids {
            os.write_int32(7, *v)?;
        };
        for v in &self.persona_unsubscribe_accountids {
            os.write_int32(8, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_UpdateMemberListView_Notification {
        CChatRoom_UpdateMemberListView_Notification::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.view_id = ::std::option::Option::None;
        self.start = ::std::option::Option::None;
        self.end = ::std::option::Option::None;
        self.client_changenumber = ::std::option::Option::None;
        self.delete_view = ::std::option::Option::None;
        self.persona_subscribe_accountids.clear();
        self.persona_unsubscribe_accountids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_UpdateMemberListView_Notification {
        static instance: CChatRoom_UpdateMemberListView_Notification = CChatRoom_UpdateMemberListView_Notification {
            chat_group_id: ::std::option::Option::None,
            view_id: ::std::option::Option::None,
            start: ::std::option::Option::None,
            end: ::std::option::Option::None,
            client_changenumber: ::std::option::Option::None,
            delete_view: ::std::option::Option::None,
            persona_subscribe_accountids: ::std::vec::Vec::new(),
            persona_unsubscribe_accountids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_UpdateMemberListView_Notification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_UpdateMemberListView_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_UpdateMemberListView_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_UpdateMemberListView_Notification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_SearchMembers_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SearchMembers_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SearchMembers_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SearchMembers_Request.search_id)
    pub search_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SearchMembers_Request.search_text)
    pub search_text: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_SearchMembers_Request.max_results)
    pub max_results: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SearchMembers_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SearchMembers_Request {
    fn default() -> &'a CChatRoom_SearchMembers_Request {
        <CChatRoom_SearchMembers_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SearchMembers_Request {
    pub fn new() -> CChatRoom_SearchMembers_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 search_id = 2;

    pub fn search_id(&self) -> u64 {
        self.search_id.unwrap_or(0)
    }

    pub fn clear_search_id(&mut self) {
        self.search_id = ::std::option::Option::None;
    }

    pub fn has_search_id(&self) -> bool {
        self.search_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_search_id(&mut self, v: u64) {
        self.search_id = ::std::option::Option::Some(v);
    }

    // optional string search_text = 3;

    pub fn search_text(&self) -> &str {
        match self.search_text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_search_text(&mut self) {
        self.search_text = ::std::option::Option::None;
    }

    pub fn has_search_text(&self) -> bool {
        self.search_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_search_text(&mut self, v: ::std::string::String) {
        self.search_text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_search_text(&mut self) -> &mut ::std::string::String {
        if self.search_text.is_none() {
            self.search_text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.search_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_search_text(&mut self) -> ::std::string::String {
        self.search_text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 max_results = 4;

    pub fn max_results(&self) -> i32 {
        self.max_results.unwrap_or(0)
    }

    pub fn clear_max_results(&mut self) {
        self.max_results = ::std::option::Option::None;
    }

    pub fn has_max_results(&self) -> bool {
        self.max_results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_results(&mut self, v: i32) {
        self.max_results = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_SearchMembers_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_SearchMembers_Request| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "search_id",
            |m: &CChatRoom_SearchMembers_Request| { &m.search_id },
            |m: &mut CChatRoom_SearchMembers_Request| { &mut m.search_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "search_text",
            |m: &CChatRoom_SearchMembers_Request| { &m.search_text },
            |m: &mut CChatRoom_SearchMembers_Request| { &mut m.search_text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_results",
            |m: &CChatRoom_SearchMembers_Request| { &m.max_results },
            |m: &mut CChatRoom_SearchMembers_Request| { &mut m.max_results },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SearchMembers_Request>(
            "CChatRoom_SearchMembers_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_SearchMembers_Request {
    const NAME: &'static str = "CChatRoom_SearchMembers_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.search_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.search_text = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.max_results = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.search_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.search_text.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.max_results {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.search_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.search_text.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.max_results {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SearchMembers_Request {
        CChatRoom_SearchMembers_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.search_id = ::std::option::Option::None;
        self.search_text = ::std::option::Option::None;
        self.max_results = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SearchMembers_Request {
        static instance: CChatRoom_SearchMembers_Request = CChatRoom_SearchMembers_Request {
            chat_group_id: ::std::option::Option::None,
            search_id: ::std::option::Option::None,
            search_text: ::std::option::Option::None,
            max_results: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_SearchMembers_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SearchMembers_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SearchMembers_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SearchMembers_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_SearchMembers_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SearchMembers_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SearchMembers_Response.matching_members)
    pub matching_members: ::std::vec::Vec<cchat_room_search_members_response::MemberMatch>,
    // @@protoc_insertion_point(field:CChatRoom_SearchMembers_Response.status_flags)
    pub status_flags: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SearchMembers_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SearchMembers_Response {
    fn default() -> &'a CChatRoom_SearchMembers_Response {
        <CChatRoom_SearchMembers_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SearchMembers_Response {
    pub fn new() -> CChatRoom_SearchMembers_Response {
        ::std::default::Default::default()
    }

    // optional uint32 status_flags = 2;

    pub fn status_flags(&self) -> u32 {
        self.status_flags.unwrap_or(0)
    }

    pub fn clear_status_flags(&mut self) {
        self.status_flags = ::std::option::Option::None;
    }

    pub fn has_status_flags(&self) -> bool {
        self.status_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_flags(&mut self, v: u32) {
        self.status_flags = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "matching_members",
            |m: &CChatRoom_SearchMembers_Response| { &m.matching_members },
            |m: &mut CChatRoom_SearchMembers_Response| { &mut m.matching_members },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status_flags",
            |m: &CChatRoom_SearchMembers_Response| { &m.status_flags },
            |m: &mut CChatRoom_SearchMembers_Response| { &mut m.status_flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SearchMembers_Response>(
            "CChatRoom_SearchMembers_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_SearchMembers_Response {
    const NAME: &'static str = "CChatRoom_SearchMembers_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.matching_members.push(is.read_message()?);
                },
                16 => {
                    self.status_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.matching_members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.status_flags {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.matching_members {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.status_flags {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SearchMembers_Response {
        CChatRoom_SearchMembers_Response::new()
    }

    fn clear(&mut self) {
        self.matching_members.clear();
        self.status_flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SearchMembers_Response {
        static instance: CChatRoom_SearchMembers_Response = CChatRoom_SearchMembers_Response {
            matching_members: ::std::vec::Vec::new(),
            status_flags: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_SearchMembers_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SearchMembers_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SearchMembers_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SearchMembers_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CChatRoom_SearchMembers_Response`
pub mod cchat_room_search_members_response {
    // @@protoc_insertion_point(message:CChatRoom_SearchMembers_Response.MemberMatch)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct MemberMatch {
        // message fields
        // @@protoc_insertion_point(field:CChatRoom_SearchMembers_Response.MemberMatch.accountid)
        pub accountid: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatRoom_SearchMembers_Response.MemberMatch.persona)
        pub persona: ::protobuf::MessageField<super::super::steammessages_clientserver_friends::cmsg_client_persona_state::Friend>,
        // special fields
        // @@protoc_insertion_point(special_field:CChatRoom_SearchMembers_Response.MemberMatch.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MemberMatch {
        fn default() -> &'a MemberMatch {
            <MemberMatch as ::protobuf::Message>::default_instance()
        }
    }

    impl MemberMatch {
        pub fn new() -> MemberMatch {
            ::std::default::Default::default()
        }

        // optional int32 accountid = 1;

        pub fn accountid(&self) -> i32 {
            self.accountid.unwrap_or(0)
        }

        pub fn clear_accountid(&mut self) {
            self.accountid = ::std::option::Option::None;
        }

        pub fn has_accountid(&self) -> bool {
            self.accountid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_accountid(&mut self, v: i32) {
            self.accountid = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "accountid",
                |m: &MemberMatch| { &m.accountid },
                |m: &mut MemberMatch| { &mut m.accountid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::steammessages_clientserver_friends::cmsg_client_persona_state::Friend>(
                "persona",
                |m: &MemberMatch| { &m.persona },
                |m: &mut MemberMatch| { &mut m.persona },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MemberMatch>(
                "CChatRoom_SearchMembers_Response.MemberMatch",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MemberMatch {
        const NAME: &'static str = "MemberMatch";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.accountid = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.persona)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.accountid {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.persona.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.accountid {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.persona.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MemberMatch {
            MemberMatch::new()
        }

        fn clear(&mut self) {
            self.accountid = ::std::option::Option::None;
            self.persona.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MemberMatch {
            static instance: MemberMatch = MemberMatch {
                accountid: ::std::option::Option::None,
                persona: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MemberMatch {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CChatRoom_SearchMembers_Response.MemberMatch").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MemberMatch {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MemberMatch {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CChatRoom_UpdateMessageReaction_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_UpdateMessageReaction_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_UpdateMessageReaction_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_UpdateMessageReaction_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_UpdateMessageReaction_Request.server_timestamp)
    pub server_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_UpdateMessageReaction_Request.ordinal)
    pub ordinal: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_UpdateMessageReaction_Request.reaction_type)
    pub reaction_type: ::std::option::Option<::protobuf::EnumOrUnknown<EChatRoomMessageReactionType>>,
    // @@protoc_insertion_point(field:CChatRoom_UpdateMessageReaction_Request.reaction)
    pub reaction: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_UpdateMessageReaction_Request.is_add)
    pub is_add: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_UpdateMessageReaction_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_UpdateMessageReaction_Request {
    fn default() -> &'a CChatRoom_UpdateMessageReaction_Request {
        <CChatRoom_UpdateMessageReaction_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_UpdateMessageReaction_Request {
    pub fn new() -> CChatRoom_UpdateMessageReaction_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 server_timestamp = 3;

    pub fn server_timestamp(&self) -> u32 {
        self.server_timestamp.unwrap_or(0)
    }

    pub fn clear_server_timestamp(&mut self) {
        self.server_timestamp = ::std::option::Option::None;
    }

    pub fn has_server_timestamp(&self) -> bool {
        self.server_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_timestamp(&mut self, v: u32) {
        self.server_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 ordinal = 4;

    pub fn ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }

    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }

    // optional .EChatRoomMessageReactionType reaction_type = 5;

    pub fn reaction_type(&self) -> EChatRoomMessageReactionType {
        match self.reaction_type {
            Some(e) => e.enum_value_or(EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid),
            None => EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid,
        }
    }

    pub fn clear_reaction_type(&mut self) {
        self.reaction_type = ::std::option::Option::None;
    }

    pub fn has_reaction_type(&self) -> bool {
        self.reaction_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reaction_type(&mut self, v: EChatRoomMessageReactionType) {
        self.reaction_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string reaction = 6;

    pub fn reaction(&self) -> &str {
        match self.reaction.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reaction(&mut self) {
        self.reaction = ::std::option::Option::None;
    }

    pub fn has_reaction(&self) -> bool {
        self.reaction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reaction(&mut self, v: ::std::string::String) {
        self.reaction = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reaction(&mut self) -> &mut ::std::string::String {
        if self.reaction.is_none() {
            self.reaction = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reaction.as_mut().unwrap()
    }

    // Take field
    pub fn take_reaction(&mut self) -> ::std::string::String {
        self.reaction.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_add = 7;

    pub fn is_add(&self) -> bool {
        self.is_add.unwrap_or(false)
    }

    pub fn clear_is_add(&mut self) {
        self.is_add = ::std::option::Option::None;
    }

    pub fn has_is_add(&self) -> bool {
        self.is_add.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_add(&mut self, v: bool) {
        self.is_add = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_UpdateMessageReaction_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_UpdateMessageReaction_Request| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_UpdateMessageReaction_Request| { &m.chat_id },
            |m: &mut CChatRoom_UpdateMessageReaction_Request| { &mut m.chat_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_timestamp",
            |m: &CChatRoom_UpdateMessageReaction_Request| { &m.server_timestamp },
            |m: &mut CChatRoom_UpdateMessageReaction_Request| { &mut m.server_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ordinal",
            |m: &CChatRoom_UpdateMessageReaction_Request| { &m.ordinal },
            |m: &mut CChatRoom_UpdateMessageReaction_Request| { &mut m.ordinal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reaction_type",
            |m: &CChatRoom_UpdateMessageReaction_Request| { &m.reaction_type },
            |m: &mut CChatRoom_UpdateMessageReaction_Request| { &mut m.reaction_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reaction",
            |m: &CChatRoom_UpdateMessageReaction_Request| { &m.reaction },
            |m: &mut CChatRoom_UpdateMessageReaction_Request| { &mut m.reaction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_add",
            |m: &CChatRoom_UpdateMessageReaction_Request| { &m.is_add },
            |m: &mut CChatRoom_UpdateMessageReaction_Request| { &mut m.is_add },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_UpdateMessageReaction_Request>(
            "CChatRoom_UpdateMessageReaction_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_UpdateMessageReaction_Request {
    const NAME: &'static str = "CChatRoom_UpdateMessageReaction_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.server_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.ordinal = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.reaction_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                50 => {
                    self.reaction = ::std::option::Option::Some(is.read_string()?);
                },
                56 => {
                    self.is_add = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.server_timestamp {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.ordinal {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.reaction_type {
            my_size += ::protobuf::rt::int32_size(5, v.value());
        }
        if let Some(v) = self.reaction.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.is_add {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.server_timestamp {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.reaction_type {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.reaction.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.is_add {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_UpdateMessageReaction_Request {
        CChatRoom_UpdateMessageReaction_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.server_timestamp = ::std::option::Option::None;
        self.ordinal = ::std::option::Option::None;
        self.reaction_type = ::std::option::Option::None;
        self.reaction = ::std::option::Option::None;
        self.is_add = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_UpdateMessageReaction_Request {
        static instance: CChatRoom_UpdateMessageReaction_Request = CChatRoom_UpdateMessageReaction_Request {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            server_timestamp: ::std::option::Option::None,
            ordinal: ::std::option::Option::None,
            reaction_type: ::std::option::Option::None,
            reaction: ::std::option::Option::None,
            is_add: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_UpdateMessageReaction_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_UpdateMessageReaction_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_UpdateMessageReaction_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_UpdateMessageReaction_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_UpdateMessageReaction_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_UpdateMessageReaction_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_UpdateMessageReaction_Response.num_reactors)
    pub num_reactors: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_UpdateMessageReaction_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_UpdateMessageReaction_Response {
    fn default() -> &'a CChatRoom_UpdateMessageReaction_Response {
        <CChatRoom_UpdateMessageReaction_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_UpdateMessageReaction_Response {
    pub fn new() -> CChatRoom_UpdateMessageReaction_Response {
        ::std::default::Default::default()
    }

    // optional uint32 num_reactors = 1;

    pub fn num_reactors(&self) -> u32 {
        self.num_reactors.unwrap_or(0)
    }

    pub fn clear_num_reactors(&mut self) {
        self.num_reactors = ::std::option::Option::None;
    }

    pub fn has_num_reactors(&self) -> bool {
        self.num_reactors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_reactors(&mut self, v: u32) {
        self.num_reactors = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_reactors",
            |m: &CChatRoom_UpdateMessageReaction_Response| { &m.num_reactors },
            |m: &mut CChatRoom_UpdateMessageReaction_Response| { &mut m.num_reactors },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_UpdateMessageReaction_Response>(
            "CChatRoom_UpdateMessageReaction_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_UpdateMessageReaction_Response {
    const NAME: &'static str = "CChatRoom_UpdateMessageReaction_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.num_reactors = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.num_reactors {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.num_reactors {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_UpdateMessageReaction_Response {
        CChatRoom_UpdateMessageReaction_Response::new()
    }

    fn clear(&mut self) {
        self.num_reactors = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_UpdateMessageReaction_Response {
        static instance: CChatRoom_UpdateMessageReaction_Response = CChatRoom_UpdateMessageReaction_Response {
            num_reactors: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_UpdateMessageReaction_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_UpdateMessageReaction_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_UpdateMessageReaction_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_UpdateMessageReaction_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetMessageReactionReactors_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetMessageReactionReactors_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetMessageReactionReactors_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetMessageReactionReactors_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetMessageReactionReactors_Request.server_timestamp)
    pub server_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetMessageReactionReactors_Request.ordinal)
    pub ordinal: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetMessageReactionReactors_Request.reaction_type)
    pub reaction_type: ::std::option::Option<::protobuf::EnumOrUnknown<EChatRoomMessageReactionType>>,
    // @@protoc_insertion_point(field:CChatRoom_GetMessageReactionReactors_Request.reaction)
    pub reaction: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_GetMessageReactionReactors_Request.limit)
    pub limit: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetMessageReactionReactors_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetMessageReactionReactors_Request {
    fn default() -> &'a CChatRoom_GetMessageReactionReactors_Request {
        <CChatRoom_GetMessageReactionReactors_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetMessageReactionReactors_Request {
    pub fn new() -> CChatRoom_GetMessageReactionReactors_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 server_timestamp = 3;

    pub fn server_timestamp(&self) -> u32 {
        self.server_timestamp.unwrap_or(0)
    }

    pub fn clear_server_timestamp(&mut self) {
        self.server_timestamp = ::std::option::Option::None;
    }

    pub fn has_server_timestamp(&self) -> bool {
        self.server_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_timestamp(&mut self, v: u32) {
        self.server_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 ordinal = 4;

    pub fn ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }

    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }

    // optional .EChatRoomMessageReactionType reaction_type = 5;

    pub fn reaction_type(&self) -> EChatRoomMessageReactionType {
        match self.reaction_type {
            Some(e) => e.enum_value_or(EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid),
            None => EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid,
        }
    }

    pub fn clear_reaction_type(&mut self) {
        self.reaction_type = ::std::option::Option::None;
    }

    pub fn has_reaction_type(&self) -> bool {
        self.reaction_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reaction_type(&mut self, v: EChatRoomMessageReactionType) {
        self.reaction_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string reaction = 6;

    pub fn reaction(&self) -> &str {
        match self.reaction.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reaction(&mut self) {
        self.reaction = ::std::option::Option::None;
    }

    pub fn has_reaction(&self) -> bool {
        self.reaction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reaction(&mut self, v: ::std::string::String) {
        self.reaction = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reaction(&mut self) -> &mut ::std::string::String {
        if self.reaction.is_none() {
            self.reaction = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reaction.as_mut().unwrap()
    }

    // Take field
    pub fn take_reaction(&mut self) -> ::std::string::String {
        self.reaction.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 limit = 7;

    pub fn limit(&self) -> u32 {
        self.limit.unwrap_or(0)
    }

    pub fn clear_limit(&mut self) {
        self.limit = ::std::option::Option::None;
    }

    pub fn has_limit(&self) -> bool {
        self.limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: u32) {
        self.limit = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_GetMessageReactionReactors_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_GetMessageReactionReactors_Request| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_GetMessageReactionReactors_Request| { &m.chat_id },
            |m: &mut CChatRoom_GetMessageReactionReactors_Request| { &mut m.chat_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_timestamp",
            |m: &CChatRoom_GetMessageReactionReactors_Request| { &m.server_timestamp },
            |m: &mut CChatRoom_GetMessageReactionReactors_Request| { &mut m.server_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ordinal",
            |m: &CChatRoom_GetMessageReactionReactors_Request| { &m.ordinal },
            |m: &mut CChatRoom_GetMessageReactionReactors_Request| { &mut m.ordinal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reaction_type",
            |m: &CChatRoom_GetMessageReactionReactors_Request| { &m.reaction_type },
            |m: &mut CChatRoom_GetMessageReactionReactors_Request| { &mut m.reaction_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reaction",
            |m: &CChatRoom_GetMessageReactionReactors_Request| { &m.reaction },
            |m: &mut CChatRoom_GetMessageReactionReactors_Request| { &mut m.reaction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "limit",
            |m: &CChatRoom_GetMessageReactionReactors_Request| { &m.limit },
            |m: &mut CChatRoom_GetMessageReactionReactors_Request| { &mut m.limit },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetMessageReactionReactors_Request>(
            "CChatRoom_GetMessageReactionReactors_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_GetMessageReactionReactors_Request {
    const NAME: &'static str = "CChatRoom_GetMessageReactionReactors_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.server_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.ordinal = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.reaction_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                50 => {
                    self.reaction = ::std::option::Option::Some(is.read_string()?);
                },
                56 => {
                    self.limit = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.server_timestamp {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.ordinal {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.reaction_type {
            my_size += ::protobuf::rt::int32_size(5, v.value());
        }
        if let Some(v) = self.reaction.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.limit {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.server_timestamp {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.reaction_type {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.reaction.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.limit {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetMessageReactionReactors_Request {
        CChatRoom_GetMessageReactionReactors_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.server_timestamp = ::std::option::Option::None;
        self.ordinal = ::std::option::Option::None;
        self.reaction_type = ::std::option::Option::None;
        self.reaction = ::std::option::Option::None;
        self.limit = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetMessageReactionReactors_Request {
        static instance: CChatRoom_GetMessageReactionReactors_Request = CChatRoom_GetMessageReactionReactors_Request {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            server_timestamp: ::std::option::Option::None,
            ordinal: ::std::option::Option::None,
            reaction_type: ::std::option::Option::None,
            reaction: ::std::option::Option::None,
            limit: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_GetMessageReactionReactors_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetMessageReactionReactors_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetMessageReactionReactors_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetMessageReactionReactors_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetMessageReactionReactors_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetMessageReactionReactors_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetMessageReactionReactors_Response.reactors)
    pub reactors: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetMessageReactionReactors_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetMessageReactionReactors_Response {
    fn default() -> &'a CChatRoom_GetMessageReactionReactors_Response {
        <CChatRoom_GetMessageReactionReactors_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetMessageReactionReactors_Response {
    pub fn new() -> CChatRoom_GetMessageReactionReactors_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "reactors",
            |m: &CChatRoom_GetMessageReactionReactors_Response| { &m.reactors },
            |m: &mut CChatRoom_GetMessageReactionReactors_Response| { &mut m.reactors },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetMessageReactionReactors_Response>(
            "CChatRoom_GetMessageReactionReactors_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_GetMessageReactionReactors_Response {
    const NAME: &'static str = "CChatRoom_GetMessageReactionReactors_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.reactors)?;
                },
                8 => {
                    self.reactors.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.reactors {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.reactors {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetMessageReactionReactors_Response {
        CChatRoom_GetMessageReactionReactors_Response::new()
    }

    fn clear(&mut self) {
        self.reactors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetMessageReactionReactors_Response {
        static instance: CChatRoom_GetMessageReactionReactors_Response = CChatRoom_GetMessageReactionReactors_Response {
            reactors: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_GetMessageReactionReactors_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetMessageReactionReactors_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetMessageReactionReactors_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetMessageReactionReactors_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClanChatRooms_GetClanChatRoomInfo_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClanChatRooms_GetClanChatRoomInfo_Request {
    // message fields
    // @@protoc_insertion_point(field:CClanChatRooms_GetClanChatRoomInfo_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClanChatRooms_GetClanChatRoomInfo_Request.autocreate)
    pub autocreate: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CClanChatRooms_GetClanChatRoomInfo_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClanChatRooms_GetClanChatRoomInfo_Request {
    fn default() -> &'a CClanChatRooms_GetClanChatRoomInfo_Request {
        <CClanChatRooms_GetClanChatRoomInfo_Request as ::protobuf::Message>::default_instance()
    }
}

impl CClanChatRooms_GetClanChatRoomInfo_Request {
    pub fn new() -> CClanChatRooms_GetClanChatRoomInfo_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional bool autocreate = 2;

    pub fn autocreate(&self) -> bool {
        self.autocreate.unwrap_or(true)
    }

    pub fn clear_autocreate(&mut self) {
        self.autocreate = ::std::option::Option::None;
    }

    pub fn has_autocreate(&self) -> bool {
        self.autocreate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_autocreate(&mut self, v: bool) {
        self.autocreate = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CClanChatRooms_GetClanChatRoomInfo_Request| { &m.steamid },
            |m: &mut CClanChatRooms_GetClanChatRoomInfo_Request| { &mut m.steamid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "autocreate",
            |m: &CClanChatRooms_GetClanChatRoomInfo_Request| { &m.autocreate },
            |m: &mut CClanChatRooms_GetClanChatRoomInfo_Request| { &mut m.autocreate },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CClanChatRooms_GetClanChatRoomInfo_Request>(
            "CClanChatRooms_GetClanChatRoomInfo_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CClanChatRooms_GetClanChatRoomInfo_Request {
    const NAME: &'static str = "CClanChatRooms_GetClanChatRoomInfo_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.autocreate = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.autocreate {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.autocreate {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClanChatRooms_GetClanChatRoomInfo_Request {
        CClanChatRooms_GetClanChatRoomInfo_Request::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.autocreate = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClanChatRooms_GetClanChatRoomInfo_Request {
        static instance: CClanChatRooms_GetClanChatRoomInfo_Request = CClanChatRooms_GetClanChatRoomInfo_Request {
            steamid: ::std::option::Option::None,
            autocreate: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CClanChatRooms_GetClanChatRoomInfo_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClanChatRooms_GetClanChatRoomInfo_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClanChatRooms_GetClanChatRoomInfo_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClanChatRooms_GetClanChatRoomInfo_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClanChatRooms_GetClanChatRoomInfo_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClanChatRooms_GetClanChatRoomInfo_Response {
    // message fields
    // @@protoc_insertion_point(field:CClanChatRooms_GetClanChatRoomInfo_Response.chat_group_summary)
    pub chat_group_summary: ::protobuf::MessageField<CChatRoom_GetChatRoomGroupSummary_Response>,
    // special fields
    // @@protoc_insertion_point(special_field:CClanChatRooms_GetClanChatRoomInfo_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClanChatRooms_GetClanChatRoomInfo_Response {
    fn default() -> &'a CClanChatRooms_GetClanChatRoomInfo_Response {
        <CClanChatRooms_GetClanChatRoomInfo_Response as ::protobuf::Message>::default_instance()
    }
}

impl CClanChatRooms_GetClanChatRoomInfo_Response {
    pub fn new() -> CClanChatRooms_GetClanChatRoomInfo_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CChatRoom_GetChatRoomGroupSummary_Response>(
            "chat_group_summary",
            |m: &CClanChatRooms_GetClanChatRoomInfo_Response| { &m.chat_group_summary },
            |m: &mut CClanChatRooms_GetClanChatRoomInfo_Response| { &mut m.chat_group_summary },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CClanChatRooms_GetClanChatRoomInfo_Response>(
            "CClanChatRooms_GetClanChatRoomInfo_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CClanChatRooms_GetClanChatRoomInfo_Response {
    const NAME: &'static str = "CClanChatRooms_GetClanChatRoomInfo_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.chat_group_summary)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_summary.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClanChatRooms_GetClanChatRoomInfo_Response {
        CClanChatRooms_GetClanChatRoomInfo_Response::new()
    }

    fn clear(&mut self) {
        self.chat_group_summary.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClanChatRooms_GetClanChatRoomInfo_Response {
        static instance: CClanChatRooms_GetClanChatRoomInfo_Response = CClanChatRooms_GetClanChatRoomInfo_Response {
            chat_group_summary: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CClanChatRooms_GetClanChatRoomInfo_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClanChatRooms_GetClanChatRoomInfo_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClanChatRooms_GetClanChatRoomInfo_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClanChatRooms_GetClanChatRoomInfo_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClanChatRooms_SetClanChatRoomPrivate_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClanChatRooms_SetClanChatRoomPrivate_Request {
    // message fields
    // @@protoc_insertion_point(field:CClanChatRooms_SetClanChatRoomPrivate_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClanChatRooms_SetClanChatRoomPrivate_Request.chat_room_private)
    pub chat_room_private: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CClanChatRooms_SetClanChatRoomPrivate_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClanChatRooms_SetClanChatRoomPrivate_Request {
    fn default() -> &'a CClanChatRooms_SetClanChatRoomPrivate_Request {
        <CClanChatRooms_SetClanChatRoomPrivate_Request as ::protobuf::Message>::default_instance()
    }
}

impl CClanChatRooms_SetClanChatRoomPrivate_Request {
    pub fn new() -> CClanChatRooms_SetClanChatRoomPrivate_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional bool chat_room_private = 2;

    pub fn chat_room_private(&self) -> bool {
        self.chat_room_private.unwrap_or(false)
    }

    pub fn clear_chat_room_private(&mut self) {
        self.chat_room_private = ::std::option::Option::None;
    }

    pub fn has_chat_room_private(&self) -> bool {
        self.chat_room_private.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_room_private(&mut self, v: bool) {
        self.chat_room_private = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CClanChatRooms_SetClanChatRoomPrivate_Request| { &m.steamid },
            |m: &mut CClanChatRooms_SetClanChatRoomPrivate_Request| { &mut m.steamid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_room_private",
            |m: &CClanChatRooms_SetClanChatRoomPrivate_Request| { &m.chat_room_private },
            |m: &mut CClanChatRooms_SetClanChatRoomPrivate_Request| { &mut m.chat_room_private },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CClanChatRooms_SetClanChatRoomPrivate_Request>(
            "CClanChatRooms_SetClanChatRoomPrivate_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CClanChatRooms_SetClanChatRoomPrivate_Request {
    const NAME: &'static str = "CClanChatRooms_SetClanChatRoomPrivate_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.chat_room_private = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.chat_room_private {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.chat_room_private {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClanChatRooms_SetClanChatRoomPrivate_Request {
        CClanChatRooms_SetClanChatRoomPrivate_Request::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.chat_room_private = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClanChatRooms_SetClanChatRoomPrivate_Request {
        static instance: CClanChatRooms_SetClanChatRoomPrivate_Request = CClanChatRooms_SetClanChatRoomPrivate_Request {
            steamid: ::std::option::Option::None,
            chat_room_private: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CClanChatRooms_SetClanChatRoomPrivate_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClanChatRooms_SetClanChatRoomPrivate_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClanChatRooms_SetClanChatRoomPrivate_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClanChatRooms_SetClanChatRoomPrivate_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClanChatRooms_SetClanChatRoomPrivate_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClanChatRooms_SetClanChatRoomPrivate_Response {
    // message fields
    // @@protoc_insertion_point(field:CClanChatRooms_SetClanChatRoomPrivate_Response.chat_room_private)
    pub chat_room_private: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CClanChatRooms_SetClanChatRoomPrivate_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClanChatRooms_SetClanChatRoomPrivate_Response {
    fn default() -> &'a CClanChatRooms_SetClanChatRoomPrivate_Response {
        <CClanChatRooms_SetClanChatRoomPrivate_Response as ::protobuf::Message>::default_instance()
    }
}

impl CClanChatRooms_SetClanChatRoomPrivate_Response {
    pub fn new() -> CClanChatRooms_SetClanChatRoomPrivate_Response {
        ::std::default::Default::default()
    }

    // optional bool chat_room_private = 1;

    pub fn chat_room_private(&self) -> bool {
        self.chat_room_private.unwrap_or(false)
    }

    pub fn clear_chat_room_private(&mut self) {
        self.chat_room_private = ::std::option::Option::None;
    }

    pub fn has_chat_room_private(&self) -> bool {
        self.chat_room_private.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_room_private(&mut self, v: bool) {
        self.chat_room_private = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_room_private",
            |m: &CClanChatRooms_SetClanChatRoomPrivate_Response| { &m.chat_room_private },
            |m: &mut CClanChatRooms_SetClanChatRoomPrivate_Response| { &mut m.chat_room_private },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CClanChatRooms_SetClanChatRoomPrivate_Response>(
            "CClanChatRooms_SetClanChatRoomPrivate_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CClanChatRooms_SetClanChatRoomPrivate_Response {
    const NAME: &'static str = "CClanChatRooms_SetClanChatRoomPrivate_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_room_private = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_room_private {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_room_private {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClanChatRooms_SetClanChatRoomPrivate_Response {
        CClanChatRooms_SetClanChatRoomPrivate_Response::new()
    }

    fn clear(&mut self) {
        self.chat_room_private = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClanChatRooms_SetClanChatRoomPrivate_Response {
        static instance: CClanChatRooms_SetClanChatRoomPrivate_Response = CClanChatRooms_SetClanChatRoomPrivate_Response {
            chat_room_private: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CClanChatRooms_SetClanChatRoomPrivate_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClanChatRooms_SetClanChatRoomPrivate_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClanChatRooms_SetClanChatRoomPrivate_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClanChatRooms_SetClanChatRoomPrivate_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatMentions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatMentions {
    // message fields
    // @@protoc_insertion_point(field:CChatMentions.mention_all)
    pub mention_all: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatMentions.mention_here)
    pub mention_here: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatMentions.mention_accountids)
    pub mention_accountids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatMentions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatMentions {
    fn default() -> &'a CChatMentions {
        <CChatMentions as ::protobuf::Message>::default_instance()
    }
}

impl CChatMentions {
    pub fn new() -> CChatMentions {
        ::std::default::Default::default()
    }

    // optional bool mention_all = 1;

    pub fn mention_all(&self) -> bool {
        self.mention_all.unwrap_or(false)
    }

    pub fn clear_mention_all(&mut self) {
        self.mention_all = ::std::option::Option::None;
    }

    pub fn has_mention_all(&self) -> bool {
        self.mention_all.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mention_all(&mut self, v: bool) {
        self.mention_all = ::std::option::Option::Some(v);
    }

    // optional bool mention_here = 2;

    pub fn mention_here(&self) -> bool {
        self.mention_here.unwrap_or(false)
    }

    pub fn clear_mention_here(&mut self) {
        self.mention_here = ::std::option::Option::None;
    }

    pub fn has_mention_here(&self) -> bool {
        self.mention_here.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mention_here(&mut self, v: bool) {
        self.mention_here = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mention_all",
            |m: &CChatMentions| { &m.mention_all },
            |m: &mut CChatMentions| { &mut m.mention_all },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mention_here",
            |m: &CChatMentions| { &m.mention_here },
            |m: &mut CChatMentions| { &mut m.mention_here },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "mention_accountids",
            |m: &CChatMentions| { &m.mention_accountids },
            |m: &mut CChatMentions| { &mut m.mention_accountids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatMentions>(
            "CChatMentions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatMentions {
    const NAME: &'static str = "CChatMentions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mention_all = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.mention_here = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.mention_accountids)?;
                },
                24 => {
                    self.mention_accountids.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mention_all {
            my_size += 1 + 1;
        }
        if let Some(v) = self.mention_here {
            my_size += 1 + 1;
        }
        for value in &self.mention_accountids {
            my_size += ::protobuf::rt::uint32_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.mention_all {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.mention_here {
            os.write_bool(2, v)?;
        }
        for v in &self.mention_accountids {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatMentions {
        CChatMentions::new()
    }

    fn clear(&mut self) {
        self.mention_all = ::std::option::Option::None;
        self.mention_here = ::std::option::Option::None;
        self.mention_accountids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatMentions {
        static instance: CChatMentions = CChatMentions {
            mention_all: ::std::option::Option::None,
            mention_here: ::std::option::Option::None,
            mention_accountids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatMentions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatMentions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatMentions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatMentions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_IncomingChatMessage_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_IncomingChatMessage_Notification {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_IncomingChatMessage_Notification.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_IncomingChatMessage_Notification.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_IncomingChatMessage_Notification.steamid_sender)
    pub steamid_sender: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_IncomingChatMessage_Notification.message)
    pub message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_IncomingChatMessage_Notification.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_IncomingChatMessage_Notification.mentions)
    pub mentions: ::protobuf::MessageField<CChatMentions>,
    // @@protoc_insertion_point(field:CChatRoom_IncomingChatMessage_Notification.ordinal)
    pub ordinal: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_IncomingChatMessage_Notification.server_message)
    pub server_message: ::protobuf::MessageField<ServerMessage>,
    // @@protoc_insertion_point(field:CChatRoom_IncomingChatMessage_Notification.message_no_bbcode)
    pub message_no_bbcode: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_IncomingChatMessage_Notification.chat_name)
    pub chat_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_IncomingChatMessage_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_IncomingChatMessage_Notification {
    fn default() -> &'a CChatRoom_IncomingChatMessage_Notification {
        <CChatRoom_IncomingChatMessage_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_IncomingChatMessage_Notification {
    pub fn new() -> CChatRoom_IncomingChatMessage_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid_sender = 3;

    pub fn steamid_sender(&self) -> u64 {
        self.steamid_sender.unwrap_or(0)
    }

    pub fn clear_steamid_sender(&mut self) {
        self.steamid_sender = ::std::option::Option::None;
    }

    pub fn has_steamid_sender(&self) -> bool {
        self.steamid_sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_sender(&mut self, v: u64) {
        self.steamid_sender = ::std::option::Option::Some(v);
    }

    // optional string message = 4;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 timestamp = 5;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 ordinal = 7;

    pub fn ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }

    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }

    // optional string message_no_bbcode = 9;

    pub fn message_no_bbcode(&self) -> &str {
        match self.message_no_bbcode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message_no_bbcode(&mut self) {
        self.message_no_bbcode = ::std::option::Option::None;
    }

    pub fn has_message_no_bbcode(&self) -> bool {
        self.message_no_bbcode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_no_bbcode(&mut self, v: ::std::string::String) {
        self.message_no_bbcode = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_no_bbcode(&mut self) -> &mut ::std::string::String {
        if self.message_no_bbcode.is_none() {
            self.message_no_bbcode = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message_no_bbcode.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_no_bbcode(&mut self) -> ::std::string::String {
        self.message_no_bbcode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string chat_name = 10;

    pub fn chat_name(&self) -> &str {
        match self.chat_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_chat_name(&mut self) {
        self.chat_name = ::std::option::Option::None;
    }

    pub fn has_chat_name(&self) -> bool {
        self.chat_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_name(&mut self, v: ::std::string::String) {
        self.chat_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_name(&mut self) -> &mut ::std::string::String {
        if self.chat_name.is_none() {
            self.chat_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.chat_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_name(&mut self) -> ::std::string::String {
        self.chat_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_IncomingChatMessage_Notification| { &m.chat_group_id },
            |m: &mut CChatRoom_IncomingChatMessage_Notification| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_IncomingChatMessage_Notification| { &m.chat_id },
            |m: &mut CChatRoom_IncomingChatMessage_Notification| { &mut m.chat_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid_sender",
            |m: &CChatRoom_IncomingChatMessage_Notification| { &m.steamid_sender },
            |m: &mut CChatRoom_IncomingChatMessage_Notification| { &mut m.steamid_sender },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &CChatRoom_IncomingChatMessage_Notification| { &m.message },
            |m: &mut CChatRoom_IncomingChatMessage_Notification| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &CChatRoom_IncomingChatMessage_Notification| { &m.timestamp },
            |m: &mut CChatRoom_IncomingChatMessage_Notification| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CChatMentions>(
            "mentions",
            |m: &CChatRoom_IncomingChatMessage_Notification| { &m.mentions },
            |m: &mut CChatRoom_IncomingChatMessage_Notification| { &mut m.mentions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ordinal",
            |m: &CChatRoom_IncomingChatMessage_Notification| { &m.ordinal },
            |m: &mut CChatRoom_IncomingChatMessage_Notification| { &mut m.ordinal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ServerMessage>(
            "server_message",
            |m: &CChatRoom_IncomingChatMessage_Notification| { &m.server_message },
            |m: &mut CChatRoom_IncomingChatMessage_Notification| { &mut m.server_message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message_no_bbcode",
            |m: &CChatRoom_IncomingChatMessage_Notification| { &m.message_no_bbcode },
            |m: &mut CChatRoom_IncomingChatMessage_Notification| { &mut m.message_no_bbcode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_name",
            |m: &CChatRoom_IncomingChatMessage_Notification| { &m.chat_name },
            |m: &mut CChatRoom_IncomingChatMessage_Notification| { &mut m.chat_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_IncomingChatMessage_Notification>(
            "CChatRoom_IncomingChatMessage_Notification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_IncomingChatMessage_Notification {
    const NAME: &'static str = "CChatRoom_IncomingChatMessage_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                25 => {
                    self.steamid_sender = ::std::option::Option::Some(is.read_fixed64()?);
                },
                34 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.mentions)?;
                },
                56 => {
                    self.ordinal = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.server_message)?;
                },
                74 => {
                    self.message_no_bbcode = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.chat_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.steamid_sender {
            my_size += 1 + 8;
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.mentions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ordinal {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.server_message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.message_no_bbcode.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.chat_name.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.steamid_sender {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.mentions.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.server_message.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.message_no_bbcode.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.chat_name.as_ref() {
            os.write_string(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_IncomingChatMessage_Notification {
        CChatRoom_IncomingChatMessage_Notification::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.steamid_sender = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.mentions.clear();
        self.ordinal = ::std::option::Option::None;
        self.server_message.clear();
        self.message_no_bbcode = ::std::option::Option::None;
        self.chat_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_IncomingChatMessage_Notification {
        static instance: CChatRoom_IncomingChatMessage_Notification = CChatRoom_IncomingChatMessage_Notification {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            steamid_sender: ::std::option::Option::None,
            message: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            mentions: ::protobuf::MessageField::none(),
            ordinal: ::std::option::Option::None,
            server_message: ::protobuf::MessageField::none(),
            message_no_bbcode: ::std::option::Option::None,
            chat_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_IncomingChatMessage_Notification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_IncomingChatMessage_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_IncomingChatMessage_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_IncomingChatMessage_Notification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_ChatMessageModified_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_ChatMessageModified_Notification {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_ChatMessageModified_Notification.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_ChatMessageModified_Notification.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_ChatMessageModified_Notification.messages)
    pub messages: ::std::vec::Vec<cchat_room_chat_message_modified_notification::ChatMessage>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_ChatMessageModified_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ChatMessageModified_Notification {
    fn default() -> &'a CChatRoom_ChatMessageModified_Notification {
        <CChatRoom_ChatMessageModified_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_ChatMessageModified_Notification {
    pub fn new() -> CChatRoom_ChatMessageModified_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_ChatMessageModified_Notification| { &m.chat_group_id },
            |m: &mut CChatRoom_ChatMessageModified_Notification| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_ChatMessageModified_Notification| { &m.chat_id },
            |m: &mut CChatRoom_ChatMessageModified_Notification| { &mut m.chat_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "messages",
            |m: &CChatRoom_ChatMessageModified_Notification| { &m.messages },
            |m: &mut CChatRoom_ChatMessageModified_Notification| { &mut m.messages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_ChatMessageModified_Notification>(
            "CChatRoom_ChatMessageModified_Notification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_ChatMessageModified_Notification {
    const NAME: &'static str = "CChatRoom_ChatMessageModified_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.messages.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        for v in &self.messages {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_ChatMessageModified_Notification {
        CChatRoom_ChatMessageModified_Notification::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.messages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_ChatMessageModified_Notification {
        static instance: CChatRoom_ChatMessageModified_Notification = CChatRoom_ChatMessageModified_Notification {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            messages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_ChatMessageModified_Notification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_ChatMessageModified_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_ChatMessageModified_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_ChatMessageModified_Notification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CChatRoom_ChatMessageModified_Notification`
pub mod cchat_room_chat_message_modified_notification {
    // @@protoc_insertion_point(message:CChatRoom_ChatMessageModified_Notification.ChatMessage)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ChatMessage {
        // message fields
        // @@protoc_insertion_point(field:CChatRoom_ChatMessageModified_Notification.ChatMessage.server_timestamp)
        pub server_timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CChatRoom_ChatMessageModified_Notification.ChatMessage.ordinal)
        pub ordinal: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CChatRoom_ChatMessageModified_Notification.ChatMessage.deleted)
        pub deleted: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CChatRoom_ChatMessageModified_Notification.ChatMessage.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ChatMessage {
        fn default() -> &'a ChatMessage {
            <ChatMessage as ::protobuf::Message>::default_instance()
        }
    }

    impl ChatMessage {
        pub fn new() -> ChatMessage {
            ::std::default::Default::default()
        }

        // optional uint32 server_timestamp = 1;

        pub fn server_timestamp(&self) -> u32 {
            self.server_timestamp.unwrap_or(0)
        }

        pub fn clear_server_timestamp(&mut self) {
            self.server_timestamp = ::std::option::Option::None;
        }

        pub fn has_server_timestamp(&self) -> bool {
            self.server_timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_server_timestamp(&mut self, v: u32) {
            self.server_timestamp = ::std::option::Option::Some(v);
        }

        // optional uint32 ordinal = 2;

        pub fn ordinal(&self) -> u32 {
            self.ordinal.unwrap_or(0)
        }

        pub fn clear_ordinal(&mut self) {
            self.ordinal = ::std::option::Option::None;
        }

        pub fn has_ordinal(&self) -> bool {
            self.ordinal.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ordinal(&mut self, v: u32) {
            self.ordinal = ::std::option::Option::Some(v);
        }

        // optional bool deleted = 3;

        pub fn deleted(&self) -> bool {
            self.deleted.unwrap_or(false)
        }

        pub fn clear_deleted(&mut self) {
            self.deleted = ::std::option::Option::None;
        }

        pub fn has_deleted(&self) -> bool {
            self.deleted.is_some()
        }

        // Param is passed by value, moved
        pub fn set_deleted(&mut self, v: bool) {
            self.deleted = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "server_timestamp",
                |m: &ChatMessage| { &m.server_timestamp },
                |m: &mut ChatMessage| { &mut m.server_timestamp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ordinal",
                |m: &ChatMessage| { &m.ordinal },
                |m: &mut ChatMessage| { &mut m.ordinal },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "deleted",
                |m: &ChatMessage| { &m.deleted },
                |m: &mut ChatMessage| { &mut m.deleted },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChatMessage>(
                "CChatRoom_ChatMessageModified_Notification.ChatMessage",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ChatMessage {
        const NAME: &'static str = "ChatMessage";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.server_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.ordinal = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.deleted = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.server_timestamp {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.ordinal {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.deleted {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.server_timestamp {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.ordinal {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.deleted {
                os.write_bool(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ChatMessage {
            ChatMessage::new()
        }

        fn clear(&mut self) {
            self.server_timestamp = ::std::option::Option::None;
            self.ordinal = ::std::option::Option::None;
            self.deleted = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ChatMessage {
            static instance: ChatMessage = ChatMessage {
                server_timestamp: ::std::option::Option::None,
                ordinal: ::std::option::Option::None,
                deleted: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ChatMessage {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CChatRoom_ChatMessageModified_Notification.ChatMessage").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ChatMessage {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ChatMessage {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CChatRoom_MemberStateChange_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_MemberStateChange_Notification {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_MemberStateChange_Notification.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_MemberStateChange_Notification.member)
    pub member: ::protobuf::MessageField<CChatRoomMember>,
    // @@protoc_insertion_point(field:CChatRoom_MemberStateChange_Notification.change)
    pub change: ::std::option::Option<::protobuf::EnumOrUnknown<EChatRoomMemberStateChange>>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_MemberStateChange_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_MemberStateChange_Notification {
    fn default() -> &'a CChatRoom_MemberStateChange_Notification {
        <CChatRoom_MemberStateChange_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_MemberStateChange_Notification {
    pub fn new() -> CChatRoom_MemberStateChange_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional .EChatRoomMemberStateChange change = 3;

    pub fn change(&self) -> EChatRoomMemberStateChange {
        match self.change {
            Some(e) => e.enum_value_or(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invalid),
            None => EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invalid,
        }
    }

    pub fn clear_change(&mut self) {
        self.change = ::std::option::Option::None;
    }

    pub fn has_change(&self) -> bool {
        self.change.is_some()
    }

    // Param is passed by value, moved
    pub fn set_change(&mut self, v: EChatRoomMemberStateChange) {
        self.change = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_MemberStateChange_Notification| { &m.chat_group_id },
            |m: &mut CChatRoom_MemberStateChange_Notification| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CChatRoomMember>(
            "member",
            |m: &CChatRoom_MemberStateChange_Notification| { &m.member },
            |m: &mut CChatRoom_MemberStateChange_Notification| { &mut m.member },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "change",
            |m: &CChatRoom_MemberStateChange_Notification| { &m.change },
            |m: &mut CChatRoom_MemberStateChange_Notification| { &mut m.change },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_MemberStateChange_Notification>(
            "CChatRoom_MemberStateChange_Notification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_MemberStateChange_Notification {
    const NAME: &'static str = "CChatRoom_MemberStateChange_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.member)?;
                },
                24 => {
                    self.change = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.member.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.change {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.member.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.change {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_MemberStateChange_Notification {
        CChatRoom_MemberStateChange_Notification::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.member.clear();
        self.change = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_MemberStateChange_Notification {
        static instance: CChatRoom_MemberStateChange_Notification = CChatRoom_MemberStateChange_Notification {
            chat_group_id: ::std::option::Option::None,
            member: ::protobuf::MessageField::none(),
            change: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_MemberStateChange_Notification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_MemberStateChange_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_MemberStateChange_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_MemberStateChange_Notification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_ChatRoomHeaderState_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_ChatRoomHeaderState_Notification {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_ChatRoomHeaderState_Notification.header_state)
    pub header_state: ::protobuf::MessageField<CChatRoomGroupHeaderState>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_ChatRoomHeaderState_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ChatRoomHeaderState_Notification {
    fn default() -> &'a CChatRoom_ChatRoomHeaderState_Notification {
        <CChatRoom_ChatRoomHeaderState_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_ChatRoomHeaderState_Notification {
    pub fn new() -> CChatRoom_ChatRoomHeaderState_Notification {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CChatRoomGroupHeaderState>(
            "header_state",
            |m: &CChatRoom_ChatRoomHeaderState_Notification| { &m.header_state },
            |m: &mut CChatRoom_ChatRoomHeaderState_Notification| { &mut m.header_state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_ChatRoomHeaderState_Notification>(
            "CChatRoom_ChatRoomHeaderState_Notification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_ChatRoomHeaderState_Notification {
    const NAME: &'static str = "CChatRoom_ChatRoomHeaderState_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header_state)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_ChatRoomHeaderState_Notification {
        CChatRoom_ChatRoomHeaderState_Notification::new()
    }

    fn clear(&mut self) {
        self.header_state.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_ChatRoomHeaderState_Notification {
        static instance: CChatRoom_ChatRoomHeaderState_Notification = CChatRoom_ChatRoomHeaderState_Notification {
            header_state: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_ChatRoomHeaderState_Notification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_ChatRoomHeaderState_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_ChatRoomHeaderState_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_ChatRoomHeaderState_Notification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_ChatRoomGroupRoomsChange_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_ChatRoomGroupRoomsChange_Notification {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_ChatRoomGroupRoomsChange_Notification.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_ChatRoomGroupRoomsChange_Notification.default_chat_id)
    pub default_chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_ChatRoomGroupRoomsChange_Notification.chat_rooms)
    pub chat_rooms: ::std::vec::Vec<CChatRoomState>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_ChatRoomGroupRoomsChange_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ChatRoomGroupRoomsChange_Notification {
    fn default() -> &'a CChatRoom_ChatRoomGroupRoomsChange_Notification {
        <CChatRoom_ChatRoomGroupRoomsChange_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_ChatRoomGroupRoomsChange_Notification {
    pub fn new() -> CChatRoom_ChatRoomGroupRoomsChange_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 default_chat_id = 2;

    pub fn default_chat_id(&self) -> u64 {
        self.default_chat_id.unwrap_or(0)
    }

    pub fn clear_default_chat_id(&mut self) {
        self.default_chat_id = ::std::option::Option::None;
    }

    pub fn has_default_chat_id(&self) -> bool {
        self.default_chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_chat_id(&mut self, v: u64) {
        self.default_chat_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_ChatRoomGroupRoomsChange_Notification| { &m.chat_group_id },
            |m: &mut CChatRoom_ChatRoomGroupRoomsChange_Notification| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "default_chat_id",
            |m: &CChatRoom_ChatRoomGroupRoomsChange_Notification| { &m.default_chat_id },
            |m: &mut CChatRoom_ChatRoomGroupRoomsChange_Notification| { &mut m.default_chat_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "chat_rooms",
            |m: &CChatRoom_ChatRoomGroupRoomsChange_Notification| { &m.chat_rooms },
            |m: &mut CChatRoom_ChatRoomGroupRoomsChange_Notification| { &mut m.chat_rooms },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_ChatRoomGroupRoomsChange_Notification>(
            "CChatRoom_ChatRoomGroupRoomsChange_Notification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_ChatRoomGroupRoomsChange_Notification {
    const NAME: &'static str = "CChatRoom_ChatRoomGroupRoomsChange_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.default_chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.chat_rooms.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.default_chat_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        for value in &self.chat_rooms {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.default_chat_id {
            os.write_uint64(2, v)?;
        }
        for v in &self.chat_rooms {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_ChatRoomGroupRoomsChange_Notification {
        CChatRoom_ChatRoomGroupRoomsChange_Notification::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.default_chat_id = ::std::option::Option::None;
        self.chat_rooms.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_ChatRoomGroupRoomsChange_Notification {
        static instance: CChatRoom_ChatRoomGroupRoomsChange_Notification = CChatRoom_ChatRoomGroupRoomsChange_Notification {
            chat_group_id: ::std::option::Option::None,
            default_chat_id: ::std::option::Option::None,
            chat_rooms: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_ChatRoomGroupRoomsChange_Notification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_ChatRoomGroupRoomsChange_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_ChatRoomGroupRoomsChange_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_ChatRoomGroupRoomsChange_Notification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
    fn default() -> &'a CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
        <CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
    pub fn new() -> CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_id = 1;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_group_id = 2;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification| { &m.chat_id },
            |m: &mut CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification| { &mut m.chat_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification| { &m.chat_group_id },
            |m: &mut CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification| { &mut m.chat_group_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification>(
            "CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
    const NAME: &'static str = "CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_group_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
        CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification::new()
    }

    fn clear(&mut self) {
        self.chat_id = ::std::option::Option::None;
        self.chat_group_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
        static instance: CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification = CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
            chat_id: ::std::option::Option::None,
            chat_group_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ChatRoomClient_NotifyChatGroupUserStateChanged_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
    // message fields
    // @@protoc_insertion_point(field:ChatRoomClient_NotifyChatGroupUserStateChanged_Notification.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:ChatRoomClient_NotifyChatGroupUserStateChanged_Notification.user_chat_group_state)
    pub user_chat_group_state: ::protobuf::MessageField<CUserChatRoomGroupState>,
    // @@protoc_insertion_point(field:ChatRoomClient_NotifyChatGroupUserStateChanged_Notification.group_summary)
    pub group_summary: ::protobuf::MessageField<CChatRoom_GetChatRoomGroupSummary_Response>,
    // @@protoc_insertion_point(field:ChatRoomClient_NotifyChatGroupUserStateChanged_Notification.user_action)
    pub user_action: ::std::option::Option<::protobuf::EnumOrUnknown<EChatRoomMemberStateChange>>,
    // special fields
    // @@protoc_insertion_point(special_field:ChatRoomClient_NotifyChatGroupUserStateChanged_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
    fn default() -> &'a ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
        <ChatRoomClient_NotifyChatGroupUserStateChanged_Notification as ::protobuf::Message>::default_instance()
    }
}

impl ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
    pub fn new() -> ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional .EChatRoomMemberStateChange user_action = 4;

    pub fn user_action(&self) -> EChatRoomMemberStateChange {
        match self.user_action {
            Some(e) => e.enum_value_or(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invalid),
            None => EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invalid,
        }
    }

    pub fn clear_user_action(&mut self) {
        self.user_action = ::std::option::Option::None;
    }

    pub fn has_user_action(&self) -> bool {
        self.user_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_action(&mut self, v: EChatRoomMemberStateChange) {
        self.user_action = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &ChatRoomClient_NotifyChatGroupUserStateChanged_Notification| { &m.chat_group_id },
            |m: &mut ChatRoomClient_NotifyChatGroupUserStateChanged_Notification| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CUserChatRoomGroupState>(
            "user_chat_group_state",
            |m: &ChatRoomClient_NotifyChatGroupUserStateChanged_Notification| { &m.user_chat_group_state },
            |m: &mut ChatRoomClient_NotifyChatGroupUserStateChanged_Notification| { &mut m.user_chat_group_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CChatRoom_GetChatRoomGroupSummary_Response>(
            "group_summary",
            |m: &ChatRoomClient_NotifyChatGroupUserStateChanged_Notification| { &m.group_summary },
            |m: &mut ChatRoomClient_NotifyChatGroupUserStateChanged_Notification| { &mut m.group_summary },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user_action",
            |m: &ChatRoomClient_NotifyChatGroupUserStateChanged_Notification| { &m.user_action },
            |m: &mut ChatRoomClient_NotifyChatGroupUserStateChanged_Notification| { &mut m.user_action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChatRoomClient_NotifyChatGroupUserStateChanged_Notification>(
            "ChatRoomClient_NotifyChatGroupUserStateChanged_Notification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
    const NAME: &'static str = "ChatRoomClient_NotifyChatGroupUserStateChanged_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_chat_group_state)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.group_summary)?;
                },
                32 => {
                    self.user_action = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.user_chat_group_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.group_summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.user_action {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.user_chat_group_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.group_summary.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.user_action {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
        ChatRoomClient_NotifyChatGroupUserStateChanged_Notification::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.user_chat_group_state.clear();
        self.group_summary.clear();
        self.user_action = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
        static instance: ChatRoomClient_NotifyChatGroupUserStateChanged_Notification = ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
            chat_group_id: ::std::option::Option::None,
            user_chat_group_state: ::protobuf::MessageField::none(),
            group_summary: ::protobuf::MessageField::none(),
            user_action: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChatRoomClient_NotifyChatGroupUserStateChanged_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ChatRoomClient_NotifyChatRoomDisconnect_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ChatRoomClient_NotifyChatRoomDisconnect_Notification {
    // message fields
    // @@protoc_insertion_point(field:ChatRoomClient_NotifyChatRoomDisconnect_Notification.chat_group_ids)
    pub chat_group_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:ChatRoomClient_NotifyChatRoomDisconnect_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChatRoomClient_NotifyChatRoomDisconnect_Notification {
    fn default() -> &'a ChatRoomClient_NotifyChatRoomDisconnect_Notification {
        <ChatRoomClient_NotifyChatRoomDisconnect_Notification as ::protobuf::Message>::default_instance()
    }
}

impl ChatRoomClient_NotifyChatRoomDisconnect_Notification {
    pub fn new() -> ChatRoomClient_NotifyChatRoomDisconnect_Notification {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "chat_group_ids",
            |m: &ChatRoomClient_NotifyChatRoomDisconnect_Notification| { &m.chat_group_ids },
            |m: &mut ChatRoomClient_NotifyChatRoomDisconnect_Notification| { &mut m.chat_group_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChatRoomClient_NotifyChatRoomDisconnect_Notification>(
            "ChatRoomClient_NotifyChatRoomDisconnect_Notification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ChatRoomClient_NotifyChatRoomDisconnect_Notification {
    const NAME: &'static str = "ChatRoomClient_NotifyChatRoomDisconnect_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.chat_group_ids)?;
                },
                8 => {
                    self.chat_group_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.chat_group_ids {
            my_size += ::protobuf::rt::uint64_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.chat_group_ids {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChatRoomClient_NotifyChatRoomDisconnect_Notification {
        ChatRoomClient_NotifyChatRoomDisconnect_Notification::new()
    }

    fn clear(&mut self) {
        self.chat_group_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChatRoomClient_NotifyChatRoomDisconnect_Notification {
        static instance: ChatRoomClient_NotifyChatRoomDisconnect_Notification = ChatRoomClient_NotifyChatRoomDisconnect_Notification {
            chat_group_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ChatRoomClient_NotifyChatRoomDisconnect_Notification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChatRoomClient_NotifyChatRoomDisconnect_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChatRoomClient_NotifyChatRoomDisconnect_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChatRoomClient_NotifyChatRoomDisconnect_Notification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoomMemberListView)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoomMemberListView {
    // message fields
    // @@protoc_insertion_point(field:CChatRoomMemberListView.start)
    pub start: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CChatRoomMemberListView.end)
    pub end: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CChatRoomMemberListView.total_count)
    pub total_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CChatRoomMemberListView.client_changenumber)
    pub client_changenumber: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CChatRoomMemberListView.server_changenumber)
    pub server_changenumber: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoomMemberListView.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoomMemberListView {
    fn default() -> &'a CChatRoomMemberListView {
        <CChatRoomMemberListView as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoomMemberListView {
    pub fn new() -> CChatRoomMemberListView {
        ::std::default::Default::default()
    }

    // optional int32 start = 3;

    pub fn start(&self) -> i32 {
        self.start.unwrap_or(0)
    }

    pub fn clear_start(&mut self) {
        self.start = ::std::option::Option::None;
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: i32) {
        self.start = ::std::option::Option::Some(v);
    }

    // optional int32 end = 4;

    pub fn end(&self) -> i32 {
        self.end.unwrap_or(0)
    }

    pub fn clear_end(&mut self) {
        self.end = ::std::option::Option::None;
    }

    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: i32) {
        self.end = ::std::option::Option::Some(v);
    }

    // optional int32 total_count = 5;

    pub fn total_count(&self) -> i32 {
        self.total_count.unwrap_or(0)
    }

    pub fn clear_total_count(&mut self) {
        self.total_count = ::std::option::Option::None;
    }

    pub fn has_total_count(&self) -> bool {
        self.total_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_count(&mut self, v: i32) {
        self.total_count = ::std::option::Option::Some(v);
    }

    // optional int32 client_changenumber = 6;

    pub fn client_changenumber(&self) -> i32 {
        self.client_changenumber.unwrap_or(0)
    }

    pub fn clear_client_changenumber(&mut self) {
        self.client_changenumber = ::std::option::Option::None;
    }

    pub fn has_client_changenumber(&self) -> bool {
        self.client_changenumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_changenumber(&mut self, v: i32) {
        self.client_changenumber = ::std::option::Option::Some(v);
    }

    // optional int32 server_changenumber = 7;

    pub fn server_changenumber(&self) -> i32 {
        self.server_changenumber.unwrap_or(0)
    }

    pub fn clear_server_changenumber(&mut self) {
        self.server_changenumber = ::std::option::Option::None;
    }

    pub fn has_server_changenumber(&self) -> bool {
        self.server_changenumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_changenumber(&mut self, v: i32) {
        self.server_changenumber = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start",
            |m: &CChatRoomMemberListView| { &m.start },
            |m: &mut CChatRoomMemberListView| { &mut m.start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "end",
            |m: &CChatRoomMemberListView| { &m.end },
            |m: &mut CChatRoomMemberListView| { &mut m.end },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_count",
            |m: &CChatRoomMemberListView| { &m.total_count },
            |m: &mut CChatRoomMemberListView| { &mut m.total_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_changenumber",
            |m: &CChatRoomMemberListView| { &m.client_changenumber },
            |m: &mut CChatRoomMemberListView| { &mut m.client_changenumber },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_changenumber",
            |m: &CChatRoomMemberListView| { &m.server_changenumber },
            |m: &mut CChatRoomMemberListView| { &mut m.server_changenumber },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoomMemberListView>(
            "CChatRoomMemberListView",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoomMemberListView {
    const NAME: &'static str = "CChatRoomMemberListView";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                24 => {
                    self.start = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.end = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.total_count = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.client_changenumber = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.server_changenumber = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.start {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.end {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.total_count {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.client_changenumber {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.server_changenumber {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.start {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.end {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.total_count {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.client_changenumber {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.server_changenumber {
            os.write_int32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoomMemberListView {
        CChatRoomMemberListView::new()
    }

    fn clear(&mut self) {
        self.start = ::std::option::Option::None;
        self.end = ::std::option::Option::None;
        self.total_count = ::std::option::Option::None;
        self.client_changenumber = ::std::option::Option::None;
        self.server_changenumber = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoomMemberListView {
        static instance: CChatRoomMemberListView = CChatRoomMemberListView {
            start: ::std::option::Option::None,
            end: ::std::option::Option::None,
            total_count: ::std::option::Option::None,
            client_changenumber: ::std::option::Option::None,
            server_changenumber: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoomMemberListView {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoomMemberListView").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoomMemberListView {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoomMemberListView {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoomMemberSummaryCounts)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoomMemberSummaryCounts {
    // message fields
    // @@protoc_insertion_point(field:CChatRoomMemberSummaryCounts.ingame)
    pub ingame: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CChatRoomMemberSummaryCounts.online)
    pub online: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CChatRoomMemberSummaryCounts.offline)
    pub offline: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoomMemberSummaryCounts.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoomMemberSummaryCounts {
    fn default() -> &'a CChatRoomMemberSummaryCounts {
        <CChatRoomMemberSummaryCounts as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoomMemberSummaryCounts {
    pub fn new() -> CChatRoomMemberSummaryCounts {
        ::std::default::Default::default()
    }

    // optional int32 ingame = 1;

    pub fn ingame(&self) -> i32 {
        self.ingame.unwrap_or(0)
    }

    pub fn clear_ingame(&mut self) {
        self.ingame = ::std::option::Option::None;
    }

    pub fn has_ingame(&self) -> bool {
        self.ingame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ingame(&mut self, v: i32) {
        self.ingame = ::std::option::Option::Some(v);
    }

    // optional int32 online = 2;

    pub fn online(&self) -> i32 {
        self.online.unwrap_or(0)
    }

    pub fn clear_online(&mut self) {
        self.online = ::std::option::Option::None;
    }

    pub fn has_online(&self) -> bool {
        self.online.is_some()
    }

    // Param is passed by value, moved
    pub fn set_online(&mut self, v: i32) {
        self.online = ::std::option::Option::Some(v);
    }

    // optional int32 offline = 3;

    pub fn offline(&self) -> i32 {
        self.offline.unwrap_or(0)
    }

    pub fn clear_offline(&mut self) {
        self.offline = ::std::option::Option::None;
    }

    pub fn has_offline(&self) -> bool {
        self.offline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offline(&mut self, v: i32) {
        self.offline = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ingame",
            |m: &CChatRoomMemberSummaryCounts| { &m.ingame },
            |m: &mut CChatRoomMemberSummaryCounts| { &mut m.ingame },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "online",
            |m: &CChatRoomMemberSummaryCounts| { &m.online },
            |m: &mut CChatRoomMemberSummaryCounts| { &mut m.online },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "offline",
            |m: &CChatRoomMemberSummaryCounts| { &m.offline },
            |m: &mut CChatRoomMemberSummaryCounts| { &mut m.offline },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoomMemberSummaryCounts>(
            "CChatRoomMemberSummaryCounts",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoomMemberSummaryCounts {
    const NAME: &'static str = "CChatRoomMemberSummaryCounts";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ingame = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.online = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.offline = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ingame {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.online {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.offline {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ingame {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.online {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.offline {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoomMemberSummaryCounts {
        CChatRoomMemberSummaryCounts::new()
    }

    fn clear(&mut self) {
        self.ingame = ::std::option::Option::None;
        self.online = ::std::option::Option::None;
        self.offline = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoomMemberSummaryCounts {
        static instance: CChatRoomMemberSummaryCounts = CChatRoomMemberSummaryCounts {
            ingame: ::std::option::Option::None,
            online: ::std::option::Option::None,
            offline: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoomMemberSummaryCounts {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoomMemberSummaryCounts").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoomMemberSummaryCounts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoomMemberSummaryCounts {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoomClient_MemberListViewUpdated_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoomClient_MemberListViewUpdated_Notification {
    // message fields
    // @@protoc_insertion_point(field:CChatRoomClient_MemberListViewUpdated_Notification.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoomClient_MemberListViewUpdated_Notification.view_id)
    pub view_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoomClient_MemberListViewUpdated_Notification.view)
    pub view: ::protobuf::MessageField<CChatRoomMemberListView>,
    // @@protoc_insertion_point(field:CChatRoomClient_MemberListViewUpdated_Notification.members)
    pub members: ::std::vec::Vec<cchat_room_client_member_list_view_updated_notification::MemberListViewEntry>,
    // @@protoc_insertion_point(field:CChatRoomClient_MemberListViewUpdated_Notification.status_flags)
    pub status_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoomClient_MemberListViewUpdated_Notification.member_summary)
    pub member_summary: ::protobuf::MessageField<CChatRoomMemberSummaryCounts>,
    // @@protoc_insertion_point(field:CChatRoomClient_MemberListViewUpdated_Notification.subscribed_personas)
    pub subscribed_personas: ::std::vec::Vec<super::steammessages_clientserver_friends::cmsg_client_persona_state::Friend>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoomClient_MemberListViewUpdated_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoomClient_MemberListViewUpdated_Notification {
    fn default() -> &'a CChatRoomClient_MemberListViewUpdated_Notification {
        <CChatRoomClient_MemberListViewUpdated_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoomClient_MemberListViewUpdated_Notification {
    pub fn new() -> CChatRoomClient_MemberListViewUpdated_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 view_id = 2;

    pub fn view_id(&self) -> u64 {
        self.view_id.unwrap_or(0)
    }

    pub fn clear_view_id(&mut self) {
        self.view_id = ::std::option::Option::None;
    }

    pub fn has_view_id(&self) -> bool {
        self.view_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_id(&mut self, v: u64) {
        self.view_id = ::std::option::Option::Some(v);
    }

    // optional uint32 status_flags = 5;

    pub fn status_flags(&self) -> u32 {
        self.status_flags.unwrap_or(0)
    }

    pub fn clear_status_flags(&mut self) {
        self.status_flags = ::std::option::Option::None;
    }

    pub fn has_status_flags(&self) -> bool {
        self.status_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_flags(&mut self, v: u32) {
        self.status_flags = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoomClient_MemberListViewUpdated_Notification| { &m.chat_group_id },
            |m: &mut CChatRoomClient_MemberListViewUpdated_Notification| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "view_id",
            |m: &CChatRoomClient_MemberListViewUpdated_Notification| { &m.view_id },
            |m: &mut CChatRoomClient_MemberListViewUpdated_Notification| { &mut m.view_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CChatRoomMemberListView>(
            "view",
            |m: &CChatRoomClient_MemberListViewUpdated_Notification| { &m.view },
            |m: &mut CChatRoomClient_MemberListViewUpdated_Notification| { &mut m.view },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "members",
            |m: &CChatRoomClient_MemberListViewUpdated_Notification| { &m.members },
            |m: &mut CChatRoomClient_MemberListViewUpdated_Notification| { &mut m.members },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status_flags",
            |m: &CChatRoomClient_MemberListViewUpdated_Notification| { &m.status_flags },
            |m: &mut CChatRoomClient_MemberListViewUpdated_Notification| { &mut m.status_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CChatRoomMemberSummaryCounts>(
            "member_summary",
            |m: &CChatRoomClient_MemberListViewUpdated_Notification| { &m.member_summary },
            |m: &mut CChatRoomClient_MemberListViewUpdated_Notification| { &mut m.member_summary },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "subscribed_personas",
            |m: &CChatRoomClient_MemberListViewUpdated_Notification| { &m.subscribed_personas },
            |m: &mut CChatRoomClient_MemberListViewUpdated_Notification| { &mut m.subscribed_personas },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoomClient_MemberListViewUpdated_Notification>(
            "CChatRoomClient_MemberListViewUpdated_Notification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoomClient_MemberListViewUpdated_Notification {
    const NAME: &'static str = "CChatRoomClient_MemberListViewUpdated_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.view_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.view)?;
                },
                34 => {
                    self.members.push(is.read_message()?);
                },
                40 => {
                    self.status_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.member_summary)?;
                },
                58 => {
                    self.subscribed_personas.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.view_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.view.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.status_flags {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.member_summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.subscribed_personas {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.view_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.view.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.members {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.status_flags {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.member_summary.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        for v in &self.subscribed_personas {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoomClient_MemberListViewUpdated_Notification {
        CChatRoomClient_MemberListViewUpdated_Notification::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.view_id = ::std::option::Option::None;
        self.view.clear();
        self.members.clear();
        self.status_flags = ::std::option::Option::None;
        self.member_summary.clear();
        self.subscribed_personas.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoomClient_MemberListViewUpdated_Notification {
        static instance: CChatRoomClient_MemberListViewUpdated_Notification = CChatRoomClient_MemberListViewUpdated_Notification {
            chat_group_id: ::std::option::Option::None,
            view_id: ::std::option::Option::None,
            view: ::protobuf::MessageField::none(),
            members: ::std::vec::Vec::new(),
            status_flags: ::std::option::Option::None,
            member_summary: ::protobuf::MessageField::none(),
            subscribed_personas: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoomClient_MemberListViewUpdated_Notification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoomClient_MemberListViewUpdated_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoomClient_MemberListViewUpdated_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoomClient_MemberListViewUpdated_Notification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CChatRoomClient_MemberListViewUpdated_Notification`
pub mod cchat_room_client_member_list_view_updated_notification {
    // @@protoc_insertion_point(message:CChatRoomClient_MemberListViewUpdated_Notification.MemberListViewEntry)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct MemberListViewEntry {
        // message fields
        // @@protoc_insertion_point(field:CChatRoomClient_MemberListViewUpdated_Notification.MemberListViewEntry.rank)
        pub rank: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatRoomClient_MemberListViewUpdated_Notification.MemberListViewEntry.accountid)
        pub accountid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CChatRoomClient_MemberListViewUpdated_Notification.MemberListViewEntry.persona)
        pub persona: ::protobuf::MessageField<super::super::steammessages_clientserver_friends::cmsg_client_persona_state::Friend>,
        // special fields
        // @@protoc_insertion_point(special_field:CChatRoomClient_MemberListViewUpdated_Notification.MemberListViewEntry.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MemberListViewEntry {
        fn default() -> &'a MemberListViewEntry {
            <MemberListViewEntry as ::protobuf::Message>::default_instance()
        }
    }

    impl MemberListViewEntry {
        pub fn new() -> MemberListViewEntry {
            ::std::default::Default::default()
        }

        // optional int32 rank = 1;

        pub fn rank(&self) -> i32 {
            self.rank.unwrap_or(0)
        }

        pub fn clear_rank(&mut self) {
            self.rank = ::std::option::Option::None;
        }

        pub fn has_rank(&self) -> bool {
            self.rank.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rank(&mut self, v: i32) {
            self.rank = ::std::option::Option::Some(v);
        }

        // optional uint32 accountid = 2;

        pub fn accountid(&self) -> u32 {
            self.accountid.unwrap_or(0)
        }

        pub fn clear_accountid(&mut self) {
            self.accountid = ::std::option::Option::None;
        }

        pub fn has_accountid(&self) -> bool {
            self.accountid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_accountid(&mut self, v: u32) {
            self.accountid = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rank",
                |m: &MemberListViewEntry| { &m.rank },
                |m: &mut MemberListViewEntry| { &mut m.rank },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "accountid",
                |m: &MemberListViewEntry| { &m.accountid },
                |m: &mut MemberListViewEntry| { &mut m.accountid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::steammessages_clientserver_friends::cmsg_client_persona_state::Friend>(
                "persona",
                |m: &MemberListViewEntry| { &m.persona },
                |m: &mut MemberListViewEntry| { &mut m.persona },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MemberListViewEntry>(
                "CChatRoomClient_MemberListViewUpdated_Notification.MemberListViewEntry",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MemberListViewEntry {
        const NAME: &'static str = "MemberListViewEntry";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.rank = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.persona)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.rank {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.accountid {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.persona.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.rank {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.accountid {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.persona.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MemberListViewEntry {
            MemberListViewEntry::new()
        }

        fn clear(&mut self) {
            self.rank = ::std::option::Option::None;
            self.accountid = ::std::option::Option::None;
            self.persona.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MemberListViewEntry {
            static instance: MemberListViewEntry = MemberListViewEntry {
                rank: ::std::option::Option::None,
                accountid: ::std::option::Option::None,
                persona: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MemberListViewEntry {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CChatRoomClient_MemberListViewUpdated_Notification.MemberListViewEntry").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MemberListViewEntry {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MemberListViewEntry {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CChatRoom_MessageReaction_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_MessageReaction_Notification {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_MessageReaction_Notification.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_MessageReaction_Notification.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_MessageReaction_Notification.server_timestamp)
    pub server_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_MessageReaction_Notification.ordinal)
    pub ordinal: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_MessageReaction_Notification.reactor)
    pub reactor: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_MessageReaction_Notification.reaction_type)
    pub reaction_type: ::std::option::Option<::protobuf::EnumOrUnknown<EChatRoomMessageReactionType>>,
    // @@protoc_insertion_point(field:CChatRoom_MessageReaction_Notification.reaction)
    pub reaction: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_MessageReaction_Notification.is_add)
    pub is_add: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_MessageReaction_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_MessageReaction_Notification {
    fn default() -> &'a CChatRoom_MessageReaction_Notification {
        <CChatRoom_MessageReaction_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_MessageReaction_Notification {
    pub fn new() -> CChatRoom_MessageReaction_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 server_timestamp = 3;

    pub fn server_timestamp(&self) -> u32 {
        self.server_timestamp.unwrap_or(0)
    }

    pub fn clear_server_timestamp(&mut self) {
        self.server_timestamp = ::std::option::Option::None;
    }

    pub fn has_server_timestamp(&self) -> bool {
        self.server_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_timestamp(&mut self, v: u32) {
        self.server_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 ordinal = 4;

    pub fn ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }

    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }

    // optional fixed64 reactor = 5;

    pub fn reactor(&self) -> u64 {
        self.reactor.unwrap_or(0)
    }

    pub fn clear_reactor(&mut self) {
        self.reactor = ::std::option::Option::None;
    }

    pub fn has_reactor(&self) -> bool {
        self.reactor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reactor(&mut self, v: u64) {
        self.reactor = ::std::option::Option::Some(v);
    }

    // optional .EChatRoomMessageReactionType reaction_type = 6;

    pub fn reaction_type(&self) -> EChatRoomMessageReactionType {
        match self.reaction_type {
            Some(e) => e.enum_value_or(EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid),
            None => EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid,
        }
    }

    pub fn clear_reaction_type(&mut self) {
        self.reaction_type = ::std::option::Option::None;
    }

    pub fn has_reaction_type(&self) -> bool {
        self.reaction_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reaction_type(&mut self, v: EChatRoomMessageReactionType) {
        self.reaction_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string reaction = 7;

    pub fn reaction(&self) -> &str {
        match self.reaction.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reaction(&mut self) {
        self.reaction = ::std::option::Option::None;
    }

    pub fn has_reaction(&self) -> bool {
        self.reaction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reaction(&mut self, v: ::std::string::String) {
        self.reaction = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reaction(&mut self) -> &mut ::std::string::String {
        if self.reaction.is_none() {
            self.reaction = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reaction.as_mut().unwrap()
    }

    // Take field
    pub fn take_reaction(&mut self) -> ::std::string::String {
        self.reaction.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_add = 8;

    pub fn is_add(&self) -> bool {
        self.is_add.unwrap_or(false)
    }

    pub fn clear_is_add(&mut self) {
        self.is_add = ::std::option::Option::None;
    }

    pub fn has_is_add(&self) -> bool {
        self.is_add.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_add(&mut self, v: bool) {
        self.is_add = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_MessageReaction_Notification| { &m.chat_group_id },
            |m: &mut CChatRoom_MessageReaction_Notification| { &mut m.chat_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_MessageReaction_Notification| { &m.chat_id },
            |m: &mut CChatRoom_MessageReaction_Notification| { &mut m.chat_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_timestamp",
            |m: &CChatRoom_MessageReaction_Notification| { &m.server_timestamp },
            |m: &mut CChatRoom_MessageReaction_Notification| { &mut m.server_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ordinal",
            |m: &CChatRoom_MessageReaction_Notification| { &m.ordinal },
            |m: &mut CChatRoom_MessageReaction_Notification| { &mut m.ordinal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reactor",
            |m: &CChatRoom_MessageReaction_Notification| { &m.reactor },
            |m: &mut CChatRoom_MessageReaction_Notification| { &mut m.reactor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reaction_type",
            |m: &CChatRoom_MessageReaction_Notification| { &m.reaction_type },
            |m: &mut CChatRoom_MessageReaction_Notification| { &mut m.reaction_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reaction",
            |m: &CChatRoom_MessageReaction_Notification| { &m.reaction },
            |m: &mut CChatRoom_MessageReaction_Notification| { &mut m.reaction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_add",
            |m: &CChatRoom_MessageReaction_Notification| { &m.is_add },
            |m: &mut CChatRoom_MessageReaction_Notification| { &mut m.is_add },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_MessageReaction_Notification>(
            "CChatRoom_MessageReaction_Notification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatRoom_MessageReaction_Notification {
    const NAME: &'static str = "CChatRoom_MessageReaction_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.server_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.ordinal = ::std::option::Option::Some(is.read_uint32()?);
                },
                41 => {
                    self.reactor = ::std::option::Option::Some(is.read_fixed64()?);
                },
                48 => {
                    self.reaction_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                58 => {
                    self.reaction = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.is_add = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.server_timestamp {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.ordinal {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.reactor {
            my_size += 1 + 8;
        }
        if let Some(v) = self.reaction_type {
            my_size += ::protobuf::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.reaction.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.is_add {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.server_timestamp {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.reactor {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.reaction_type {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.reaction.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.is_add {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_MessageReaction_Notification {
        CChatRoom_MessageReaction_Notification::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.server_timestamp = ::std::option::Option::None;
        self.ordinal = ::std::option::Option::None;
        self.reactor = ::std::option::Option::None;
        self.reaction_type = ::std::option::Option::None;
        self.reaction = ::std::option::Option::None;
        self.is_add = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_MessageReaction_Notification {
        static instance: CChatRoom_MessageReaction_Notification = CChatRoom_MessageReaction_Notification {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            server_timestamp: ::std::option::Option::None,
            ordinal: ::std::option::Option::None,
            reactor: ::std::option::Option::None,
            reaction_type: ::std::option::Option::None,
            reaction: ::std::option::Option::None,
            is_add: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatRoom_MessageReaction_Notification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_MessageReaction_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_MessageReaction_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_MessageReaction_Notification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatUsability_ClientUsabilityMetrics_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatUsability_ClientUsabilityMetrics_Notification {
    // message fields
    // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.metrics_run_id)
    pub metrics_run_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.client_build)
    pub client_build: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.metrics_version)
    pub metrics_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.in_web)
    pub in_web: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.settings)
    pub settings: ::protobuf::MessageField<cchat_usability_client_usability_metrics_notification::Settings>,
    // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.voice_settings)
    pub voice_settings: ::protobuf::MessageField<cchat_usability_client_usability_metrics_notification::VoiceSettings>,
    // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.ui_state)
    pub ui_state: ::protobuf::MessageField<cchat_usability_client_usability_metrics_notification::UIState>,
    // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.metrics)
    pub metrics: ::protobuf::MessageField<cchat_usability_client_usability_metrics_notification::Metrics>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatUsability_ClientUsabilityMetrics_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatUsability_ClientUsabilityMetrics_Notification {
    fn default() -> &'a CChatUsability_ClientUsabilityMetrics_Notification {
        <CChatUsability_ClientUsabilityMetrics_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatUsability_ClientUsabilityMetrics_Notification {
    pub fn new() -> CChatUsability_ClientUsabilityMetrics_Notification {
        ::std::default::Default::default()
    }

    // optional uint32 metrics_run_id = 1;

    pub fn metrics_run_id(&self) -> u32 {
        self.metrics_run_id.unwrap_or(0)
    }

    pub fn clear_metrics_run_id(&mut self) {
        self.metrics_run_id = ::std::option::Option::None;
    }

    pub fn has_metrics_run_id(&self) -> bool {
        self.metrics_run_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metrics_run_id(&mut self, v: u32) {
        self.metrics_run_id = ::std::option::Option::Some(v);
    }

    // optional uint32 client_build = 2;

    pub fn client_build(&self) -> u32 {
        self.client_build.unwrap_or(0)
    }

    pub fn clear_client_build(&mut self) {
        self.client_build = ::std::option::Option::None;
    }

    pub fn has_client_build(&self) -> bool {
        self.client_build.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_build(&mut self, v: u32) {
        self.client_build = ::std::option::Option::Some(v);
    }

    // optional uint32 metrics_version = 3;

    pub fn metrics_version(&self) -> u32 {
        self.metrics_version.unwrap_or(0)
    }

    pub fn clear_metrics_version(&mut self) {
        self.metrics_version = ::std::option::Option::None;
    }

    pub fn has_metrics_version(&self) -> bool {
        self.metrics_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metrics_version(&mut self, v: u32) {
        self.metrics_version = ::std::option::Option::Some(v);
    }

    // optional bool in_web = 4;

    pub fn in_web(&self) -> bool {
        self.in_web.unwrap_or(false)
    }

    pub fn clear_in_web(&mut self) {
        self.in_web = ::std::option::Option::None;
    }

    pub fn has_in_web(&self) -> bool {
        self.in_web.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_web(&mut self, v: bool) {
        self.in_web = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "metrics_run_id",
            |m: &CChatUsability_ClientUsabilityMetrics_Notification| { &m.metrics_run_id },
            |m: &mut CChatUsability_ClientUsabilityMetrics_Notification| { &mut m.metrics_run_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_build",
            |m: &CChatUsability_ClientUsabilityMetrics_Notification| { &m.client_build },
            |m: &mut CChatUsability_ClientUsabilityMetrics_Notification| { &mut m.client_build },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "metrics_version",
            |m: &CChatUsability_ClientUsabilityMetrics_Notification| { &m.metrics_version },
            |m: &mut CChatUsability_ClientUsabilityMetrics_Notification| { &mut m.metrics_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "in_web",
            |m: &CChatUsability_ClientUsabilityMetrics_Notification| { &m.in_web },
            |m: &mut CChatUsability_ClientUsabilityMetrics_Notification| { &mut m.in_web },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cchat_usability_client_usability_metrics_notification::Settings>(
            "settings",
            |m: &CChatUsability_ClientUsabilityMetrics_Notification| { &m.settings },
            |m: &mut CChatUsability_ClientUsabilityMetrics_Notification| { &mut m.settings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cchat_usability_client_usability_metrics_notification::VoiceSettings>(
            "voice_settings",
            |m: &CChatUsability_ClientUsabilityMetrics_Notification| { &m.voice_settings },
            |m: &mut CChatUsability_ClientUsabilityMetrics_Notification| { &mut m.voice_settings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cchat_usability_client_usability_metrics_notification::UIState>(
            "ui_state",
            |m: &CChatUsability_ClientUsabilityMetrics_Notification| { &m.ui_state },
            |m: &mut CChatUsability_ClientUsabilityMetrics_Notification| { &mut m.ui_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cchat_usability_client_usability_metrics_notification::Metrics>(
            "metrics",
            |m: &CChatUsability_ClientUsabilityMetrics_Notification| { &m.metrics },
            |m: &mut CChatUsability_ClientUsabilityMetrics_Notification| { &mut m.metrics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatUsability_ClientUsabilityMetrics_Notification>(
            "CChatUsability_ClientUsabilityMetrics_Notification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatUsability_ClientUsabilityMetrics_Notification {
    const NAME: &'static str = "CChatUsability_ClientUsabilityMetrics_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.metrics_run_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.client_build = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.metrics_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.in_web = ::std::option::Option::Some(is.read_bool()?);
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.settings)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.voice_settings)?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ui_state)?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metrics)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metrics_run_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.client_build {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.metrics_version {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.in_web {
            my_size += 1 + 1;
        }
        if let Some(v) = self.settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.voice_settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ui_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.metrics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metrics_run_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.client_build {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.metrics_version {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.in_web {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.settings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.voice_settings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.ui_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.metrics.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatUsability_ClientUsabilityMetrics_Notification {
        CChatUsability_ClientUsabilityMetrics_Notification::new()
    }

    fn clear(&mut self) {
        self.metrics_run_id = ::std::option::Option::None;
        self.client_build = ::std::option::Option::None;
        self.metrics_version = ::std::option::Option::None;
        self.in_web = ::std::option::Option::None;
        self.settings.clear();
        self.voice_settings.clear();
        self.ui_state.clear();
        self.metrics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatUsability_ClientUsabilityMetrics_Notification {
        static instance: CChatUsability_ClientUsabilityMetrics_Notification = CChatUsability_ClientUsabilityMetrics_Notification {
            metrics_run_id: ::std::option::Option::None,
            client_build: ::std::option::Option::None,
            metrics_version: ::std::option::Option::None,
            in_web: ::std::option::Option::None,
            settings: ::protobuf::MessageField::none(),
            voice_settings: ::protobuf::MessageField::none(),
            ui_state: ::protobuf::MessageField::none(),
            metrics: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatUsability_ClientUsabilityMetrics_Notification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatUsability_ClientUsabilityMetrics_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatUsability_ClientUsabilityMetrics_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatUsability_ClientUsabilityMetrics_Notification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CChatUsability_ClientUsabilityMetrics_Notification`
pub mod cchat_usability_client_usability_metrics_notification {
    // @@protoc_insertion_point(message:CChatUsability_ClientUsabilityMetrics_Notification.Settings)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Settings {
        // message fields
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.notifications_show_ingame)
        pub notifications_show_ingame: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.notifications_show_online)
        pub notifications_show_online: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.notifications_show_message)
        pub notifications_show_message: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.notifications_events_and_announcements)
        pub notifications_events_and_announcements: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.sounds_play_ingame)
        pub sounds_play_ingame: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.sounds_play_online)
        pub sounds_play_online: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.sounds_play_message)
        pub sounds_play_message: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.sounds_events_and_announcements)
        pub sounds_events_and_announcements: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.always_new_chat_window)
        pub always_new_chat_window: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.force_alphabetic_friend_sorting)
        pub force_alphabetic_friend_sorting: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.chat_flash_mode)
        pub chat_flash_mode: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.remember_open_chats)
        pub remember_open_chats: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.compact_quick_access)
        pub compact_quick_access: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.compact_friends_list)
        pub compact_friends_list: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.notifications_show_chat_room_notification)
        pub notifications_show_chat_room_notification: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.sounds_play_chat_room_notification)
        pub sounds_play_chat_room_notification: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.hide_offline_friends_in_tag_groups)
        pub hide_offline_friends_in_tag_groups: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.hide_categorized_friends)
        pub hide_categorized_friends: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.categorize_in_game_friends_by_game)
        pub categorize_in_game_friends_by_game: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.chat_font_size)
        pub chat_font_size: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.use24hour_clock)
        pub use24hour_clock: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.do_not_disturb_mode)
        pub do_not_disturb_mode: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.disable_embed_inlining)
        pub disable_embed_inlining: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.sign_into_friends)
        pub sign_into_friends: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.animated_avatars)
        pub animated_avatars: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Settings {
        fn default() -> &'a Settings {
            <Settings as ::protobuf::Message>::default_instance()
        }
    }

    impl Settings {
        pub fn new() -> Settings {
            ::std::default::Default::default()
        }

        // optional bool notifications_show_ingame = 1;

        pub fn notifications_show_ingame(&self) -> bool {
            self.notifications_show_ingame.unwrap_or(false)
        }

        pub fn clear_notifications_show_ingame(&mut self) {
            self.notifications_show_ingame = ::std::option::Option::None;
        }

        pub fn has_notifications_show_ingame(&self) -> bool {
            self.notifications_show_ingame.is_some()
        }

        // Param is passed by value, moved
        pub fn set_notifications_show_ingame(&mut self, v: bool) {
            self.notifications_show_ingame = ::std::option::Option::Some(v);
        }

        // optional bool notifications_show_online = 2;

        pub fn notifications_show_online(&self) -> bool {
            self.notifications_show_online.unwrap_or(false)
        }

        pub fn clear_notifications_show_online(&mut self) {
            self.notifications_show_online = ::std::option::Option::None;
        }

        pub fn has_notifications_show_online(&self) -> bool {
            self.notifications_show_online.is_some()
        }

        // Param is passed by value, moved
        pub fn set_notifications_show_online(&mut self, v: bool) {
            self.notifications_show_online = ::std::option::Option::Some(v);
        }

        // optional bool notifications_show_message = 3;

        pub fn notifications_show_message(&self) -> bool {
            self.notifications_show_message.unwrap_or(false)
        }

        pub fn clear_notifications_show_message(&mut self) {
            self.notifications_show_message = ::std::option::Option::None;
        }

        pub fn has_notifications_show_message(&self) -> bool {
            self.notifications_show_message.is_some()
        }

        // Param is passed by value, moved
        pub fn set_notifications_show_message(&mut self, v: bool) {
            self.notifications_show_message = ::std::option::Option::Some(v);
        }

        // optional bool notifications_events_and_announcements = 4;

        pub fn notifications_events_and_announcements(&self) -> bool {
            self.notifications_events_and_announcements.unwrap_or(false)
        }

        pub fn clear_notifications_events_and_announcements(&mut self) {
            self.notifications_events_and_announcements = ::std::option::Option::None;
        }

        pub fn has_notifications_events_and_announcements(&self) -> bool {
            self.notifications_events_and_announcements.is_some()
        }

        // Param is passed by value, moved
        pub fn set_notifications_events_and_announcements(&mut self, v: bool) {
            self.notifications_events_and_announcements = ::std::option::Option::Some(v);
        }

        // optional bool sounds_play_ingame = 5;

        pub fn sounds_play_ingame(&self) -> bool {
            self.sounds_play_ingame.unwrap_or(false)
        }

        pub fn clear_sounds_play_ingame(&mut self) {
            self.sounds_play_ingame = ::std::option::Option::None;
        }

        pub fn has_sounds_play_ingame(&self) -> bool {
            self.sounds_play_ingame.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sounds_play_ingame(&mut self, v: bool) {
            self.sounds_play_ingame = ::std::option::Option::Some(v);
        }

        // optional bool sounds_play_online = 6;

        pub fn sounds_play_online(&self) -> bool {
            self.sounds_play_online.unwrap_or(false)
        }

        pub fn clear_sounds_play_online(&mut self) {
            self.sounds_play_online = ::std::option::Option::None;
        }

        pub fn has_sounds_play_online(&self) -> bool {
            self.sounds_play_online.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sounds_play_online(&mut self, v: bool) {
            self.sounds_play_online = ::std::option::Option::Some(v);
        }

        // optional bool sounds_play_message = 7;

        pub fn sounds_play_message(&self) -> bool {
            self.sounds_play_message.unwrap_or(false)
        }

        pub fn clear_sounds_play_message(&mut self) {
            self.sounds_play_message = ::std::option::Option::None;
        }

        pub fn has_sounds_play_message(&self) -> bool {
            self.sounds_play_message.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sounds_play_message(&mut self, v: bool) {
            self.sounds_play_message = ::std::option::Option::Some(v);
        }

        // optional bool sounds_events_and_announcements = 8;

        pub fn sounds_events_and_announcements(&self) -> bool {
            self.sounds_events_and_announcements.unwrap_or(false)
        }

        pub fn clear_sounds_events_and_announcements(&mut self) {
            self.sounds_events_and_announcements = ::std::option::Option::None;
        }

        pub fn has_sounds_events_and_announcements(&self) -> bool {
            self.sounds_events_and_announcements.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sounds_events_and_announcements(&mut self, v: bool) {
            self.sounds_events_and_announcements = ::std::option::Option::Some(v);
        }

        // optional bool always_new_chat_window = 9;

        pub fn always_new_chat_window(&self) -> bool {
            self.always_new_chat_window.unwrap_or(false)
        }

        pub fn clear_always_new_chat_window(&mut self) {
            self.always_new_chat_window = ::std::option::Option::None;
        }

        pub fn has_always_new_chat_window(&self) -> bool {
            self.always_new_chat_window.is_some()
        }

        // Param is passed by value, moved
        pub fn set_always_new_chat_window(&mut self, v: bool) {
            self.always_new_chat_window = ::std::option::Option::Some(v);
        }

        // optional bool force_alphabetic_friend_sorting = 10;

        pub fn force_alphabetic_friend_sorting(&self) -> bool {
            self.force_alphabetic_friend_sorting.unwrap_or(false)
        }

        pub fn clear_force_alphabetic_friend_sorting(&mut self) {
            self.force_alphabetic_friend_sorting = ::std::option::Option::None;
        }

        pub fn has_force_alphabetic_friend_sorting(&self) -> bool {
            self.force_alphabetic_friend_sorting.is_some()
        }

        // Param is passed by value, moved
        pub fn set_force_alphabetic_friend_sorting(&mut self, v: bool) {
            self.force_alphabetic_friend_sorting = ::std::option::Option::Some(v);
        }

        // optional int32 chat_flash_mode = 11;

        pub fn chat_flash_mode(&self) -> i32 {
            self.chat_flash_mode.unwrap_or(0)
        }

        pub fn clear_chat_flash_mode(&mut self) {
            self.chat_flash_mode = ::std::option::Option::None;
        }

        pub fn has_chat_flash_mode(&self) -> bool {
            self.chat_flash_mode.is_some()
        }

        // Param is passed by value, moved
        pub fn set_chat_flash_mode(&mut self, v: i32) {
            self.chat_flash_mode = ::std::option::Option::Some(v);
        }

        // optional bool remember_open_chats = 12;

        pub fn remember_open_chats(&self) -> bool {
            self.remember_open_chats.unwrap_or(false)
        }

        pub fn clear_remember_open_chats(&mut self) {
            self.remember_open_chats = ::std::option::Option::None;
        }

        pub fn has_remember_open_chats(&self) -> bool {
            self.remember_open_chats.is_some()
        }

        // Param is passed by value, moved
        pub fn set_remember_open_chats(&mut self, v: bool) {
            self.remember_open_chats = ::std::option::Option::Some(v);
        }

        // optional bool compact_quick_access = 13;

        pub fn compact_quick_access(&self) -> bool {
            self.compact_quick_access.unwrap_or(false)
        }

        pub fn clear_compact_quick_access(&mut self) {
            self.compact_quick_access = ::std::option::Option::None;
        }

        pub fn has_compact_quick_access(&self) -> bool {
            self.compact_quick_access.is_some()
        }

        // Param is passed by value, moved
        pub fn set_compact_quick_access(&mut self, v: bool) {
            self.compact_quick_access = ::std::option::Option::Some(v);
        }

        // optional bool compact_friends_list = 14;

        pub fn compact_friends_list(&self) -> bool {
            self.compact_friends_list.unwrap_or(false)
        }

        pub fn clear_compact_friends_list(&mut self) {
            self.compact_friends_list = ::std::option::Option::None;
        }

        pub fn has_compact_friends_list(&self) -> bool {
            self.compact_friends_list.is_some()
        }

        // Param is passed by value, moved
        pub fn set_compact_friends_list(&mut self, v: bool) {
            self.compact_friends_list = ::std::option::Option::Some(v);
        }

        // optional bool notifications_show_chat_room_notification = 15;

        pub fn notifications_show_chat_room_notification(&self) -> bool {
            self.notifications_show_chat_room_notification.unwrap_or(false)
        }

        pub fn clear_notifications_show_chat_room_notification(&mut self) {
            self.notifications_show_chat_room_notification = ::std::option::Option::None;
        }

        pub fn has_notifications_show_chat_room_notification(&self) -> bool {
            self.notifications_show_chat_room_notification.is_some()
        }

        // Param is passed by value, moved
        pub fn set_notifications_show_chat_room_notification(&mut self, v: bool) {
            self.notifications_show_chat_room_notification = ::std::option::Option::Some(v);
        }

        // optional bool sounds_play_chat_room_notification = 16;

        pub fn sounds_play_chat_room_notification(&self) -> bool {
            self.sounds_play_chat_room_notification.unwrap_or(false)
        }

        pub fn clear_sounds_play_chat_room_notification(&mut self) {
            self.sounds_play_chat_room_notification = ::std::option::Option::None;
        }

        pub fn has_sounds_play_chat_room_notification(&self) -> bool {
            self.sounds_play_chat_room_notification.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sounds_play_chat_room_notification(&mut self, v: bool) {
            self.sounds_play_chat_room_notification = ::std::option::Option::Some(v);
        }

        // optional bool hide_offline_friends_in_tag_groups = 17;

        pub fn hide_offline_friends_in_tag_groups(&self) -> bool {
            self.hide_offline_friends_in_tag_groups.unwrap_or(false)
        }

        pub fn clear_hide_offline_friends_in_tag_groups(&mut self) {
            self.hide_offline_friends_in_tag_groups = ::std::option::Option::None;
        }

        pub fn has_hide_offline_friends_in_tag_groups(&self) -> bool {
            self.hide_offline_friends_in_tag_groups.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hide_offline_friends_in_tag_groups(&mut self, v: bool) {
            self.hide_offline_friends_in_tag_groups = ::std::option::Option::Some(v);
        }

        // optional bool hide_categorized_friends = 18;

        pub fn hide_categorized_friends(&self) -> bool {
            self.hide_categorized_friends.unwrap_or(false)
        }

        pub fn clear_hide_categorized_friends(&mut self) {
            self.hide_categorized_friends = ::std::option::Option::None;
        }

        pub fn has_hide_categorized_friends(&self) -> bool {
            self.hide_categorized_friends.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hide_categorized_friends(&mut self, v: bool) {
            self.hide_categorized_friends = ::std::option::Option::Some(v);
        }

        // optional bool categorize_in_game_friends_by_game = 19;

        pub fn categorize_in_game_friends_by_game(&self) -> bool {
            self.categorize_in_game_friends_by_game.unwrap_or(false)
        }

        pub fn clear_categorize_in_game_friends_by_game(&mut self) {
            self.categorize_in_game_friends_by_game = ::std::option::Option::None;
        }

        pub fn has_categorize_in_game_friends_by_game(&self) -> bool {
            self.categorize_in_game_friends_by_game.is_some()
        }

        // Param is passed by value, moved
        pub fn set_categorize_in_game_friends_by_game(&mut self, v: bool) {
            self.categorize_in_game_friends_by_game = ::std::option::Option::Some(v);
        }

        // optional int32 chat_font_size = 20;

        pub fn chat_font_size(&self) -> i32 {
            self.chat_font_size.unwrap_or(0)
        }

        pub fn clear_chat_font_size(&mut self) {
            self.chat_font_size = ::std::option::Option::None;
        }

        pub fn has_chat_font_size(&self) -> bool {
            self.chat_font_size.is_some()
        }

        // Param is passed by value, moved
        pub fn set_chat_font_size(&mut self, v: i32) {
            self.chat_font_size = ::std::option::Option::Some(v);
        }

        // optional bool use24hour_clock = 21;

        pub fn use24hour_clock(&self) -> bool {
            self.use24hour_clock.unwrap_or(false)
        }

        pub fn clear_use24hour_clock(&mut self) {
            self.use24hour_clock = ::std::option::Option::None;
        }

        pub fn has_use24hour_clock(&self) -> bool {
            self.use24hour_clock.is_some()
        }

        // Param is passed by value, moved
        pub fn set_use24hour_clock(&mut self, v: bool) {
            self.use24hour_clock = ::std::option::Option::Some(v);
        }

        // optional bool do_not_disturb_mode = 22;

        pub fn do_not_disturb_mode(&self) -> bool {
            self.do_not_disturb_mode.unwrap_or(false)
        }

        pub fn clear_do_not_disturb_mode(&mut self) {
            self.do_not_disturb_mode = ::std::option::Option::None;
        }

        pub fn has_do_not_disturb_mode(&self) -> bool {
            self.do_not_disturb_mode.is_some()
        }

        // Param is passed by value, moved
        pub fn set_do_not_disturb_mode(&mut self, v: bool) {
            self.do_not_disturb_mode = ::std::option::Option::Some(v);
        }

        // optional bool disable_embed_inlining = 23;

        pub fn disable_embed_inlining(&self) -> bool {
            self.disable_embed_inlining.unwrap_or(false)
        }

        pub fn clear_disable_embed_inlining(&mut self) {
            self.disable_embed_inlining = ::std::option::Option::None;
        }

        pub fn has_disable_embed_inlining(&self) -> bool {
            self.disable_embed_inlining.is_some()
        }

        // Param is passed by value, moved
        pub fn set_disable_embed_inlining(&mut self, v: bool) {
            self.disable_embed_inlining = ::std::option::Option::Some(v);
        }

        // optional bool sign_into_friends = 24;

        pub fn sign_into_friends(&self) -> bool {
            self.sign_into_friends.unwrap_or(false)
        }

        pub fn clear_sign_into_friends(&mut self) {
            self.sign_into_friends = ::std::option::Option::None;
        }

        pub fn has_sign_into_friends(&self) -> bool {
            self.sign_into_friends.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sign_into_friends(&mut self, v: bool) {
            self.sign_into_friends = ::std::option::Option::Some(v);
        }

        // optional bool animated_avatars = 25;

        pub fn animated_avatars(&self) -> bool {
            self.animated_avatars.unwrap_or(false)
        }

        pub fn clear_animated_avatars(&mut self) {
            self.animated_avatars = ::std::option::Option::None;
        }

        pub fn has_animated_avatars(&self) -> bool {
            self.animated_avatars.is_some()
        }

        // Param is passed by value, moved
        pub fn set_animated_avatars(&mut self, v: bool) {
            self.animated_avatars = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(25);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "notifications_show_ingame",
                |m: &Settings| { &m.notifications_show_ingame },
                |m: &mut Settings| { &mut m.notifications_show_ingame },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "notifications_show_online",
                |m: &Settings| { &m.notifications_show_online },
                |m: &mut Settings| { &mut m.notifications_show_online },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "notifications_show_message",
                |m: &Settings| { &m.notifications_show_message },
                |m: &mut Settings| { &mut m.notifications_show_message },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "notifications_events_and_announcements",
                |m: &Settings| { &m.notifications_events_and_announcements },
                |m: &mut Settings| { &mut m.notifications_events_and_announcements },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sounds_play_ingame",
                |m: &Settings| { &m.sounds_play_ingame },
                |m: &mut Settings| { &mut m.sounds_play_ingame },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sounds_play_online",
                |m: &Settings| { &m.sounds_play_online },
                |m: &mut Settings| { &mut m.sounds_play_online },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sounds_play_message",
                |m: &Settings| { &m.sounds_play_message },
                |m: &mut Settings| { &mut m.sounds_play_message },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sounds_events_and_announcements",
                |m: &Settings| { &m.sounds_events_and_announcements },
                |m: &mut Settings| { &mut m.sounds_events_and_announcements },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "always_new_chat_window",
                |m: &Settings| { &m.always_new_chat_window },
                |m: &mut Settings| { &mut m.always_new_chat_window },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "force_alphabetic_friend_sorting",
                |m: &Settings| { &m.force_alphabetic_friend_sorting },
                |m: &mut Settings| { &mut m.force_alphabetic_friend_sorting },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "chat_flash_mode",
                |m: &Settings| { &m.chat_flash_mode },
                |m: &mut Settings| { &mut m.chat_flash_mode },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "remember_open_chats",
                |m: &Settings| { &m.remember_open_chats },
                |m: &mut Settings| { &mut m.remember_open_chats },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "compact_quick_access",
                |m: &Settings| { &m.compact_quick_access },
                |m: &mut Settings| { &mut m.compact_quick_access },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "compact_friends_list",
                |m: &Settings| { &m.compact_friends_list },
                |m: &mut Settings| { &mut m.compact_friends_list },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "notifications_show_chat_room_notification",
                |m: &Settings| { &m.notifications_show_chat_room_notification },
                |m: &mut Settings| { &mut m.notifications_show_chat_room_notification },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sounds_play_chat_room_notification",
                |m: &Settings| { &m.sounds_play_chat_room_notification },
                |m: &mut Settings| { &mut m.sounds_play_chat_room_notification },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hide_offline_friends_in_tag_groups",
                |m: &Settings| { &m.hide_offline_friends_in_tag_groups },
                |m: &mut Settings| { &mut m.hide_offline_friends_in_tag_groups },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hide_categorized_friends",
                |m: &Settings| { &m.hide_categorized_friends },
                |m: &mut Settings| { &mut m.hide_categorized_friends },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "categorize_in_game_friends_by_game",
                |m: &Settings| { &m.categorize_in_game_friends_by_game },
                |m: &mut Settings| { &mut m.categorize_in_game_friends_by_game },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "chat_font_size",
                |m: &Settings| { &m.chat_font_size },
                |m: &mut Settings| { &mut m.chat_font_size },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "use24hour_clock",
                |m: &Settings| { &m.use24hour_clock },
                |m: &mut Settings| { &mut m.use24hour_clock },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "do_not_disturb_mode",
                |m: &Settings| { &m.do_not_disturb_mode },
                |m: &mut Settings| { &mut m.do_not_disturb_mode },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "disable_embed_inlining",
                |m: &Settings| { &m.disable_embed_inlining },
                |m: &mut Settings| { &mut m.disable_embed_inlining },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sign_into_friends",
                |m: &Settings| { &m.sign_into_friends },
                |m: &mut Settings| { &mut m.sign_into_friends },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "animated_avatars",
                |m: &Settings| { &m.animated_avatars },
                |m: &mut Settings| { &mut m.animated_avatars },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Settings>(
                "CChatUsability_ClientUsabilityMetrics_Notification.Settings",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Settings {
        const NAME: &'static str = "Settings";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.notifications_show_ingame = ::std::option::Option::Some(is.read_bool()?);
                    },
                    16 => {
                        self.notifications_show_online = ::std::option::Option::Some(is.read_bool()?);
                    },
                    24 => {
                        self.notifications_show_message = ::std::option::Option::Some(is.read_bool()?);
                    },
                    32 => {
                        self.notifications_events_and_announcements = ::std::option::Option::Some(is.read_bool()?);
                    },
                    40 => {
                        self.sounds_play_ingame = ::std::option::Option::Some(is.read_bool()?);
                    },
                    48 => {
                        self.sounds_play_online = ::std::option::Option::Some(is.read_bool()?);
                    },
                    56 => {
                        self.sounds_play_message = ::std::option::Option::Some(is.read_bool()?);
                    },
                    64 => {
                        self.sounds_events_and_announcements = ::std::option::Option::Some(is.read_bool()?);
                    },
                    72 => {
                        self.always_new_chat_window = ::std::option::Option::Some(is.read_bool()?);
                    },
                    80 => {
                        self.force_alphabetic_friend_sorting = ::std::option::Option::Some(is.read_bool()?);
                    },
                    88 => {
                        self.chat_flash_mode = ::std::option::Option::Some(is.read_int32()?);
                    },
                    96 => {
                        self.remember_open_chats = ::std::option::Option::Some(is.read_bool()?);
                    },
                    104 => {
                        self.compact_quick_access = ::std::option::Option::Some(is.read_bool()?);
                    },
                    112 => {
                        self.compact_friends_list = ::std::option::Option::Some(is.read_bool()?);
                    },
                    120 => {
                        self.notifications_show_chat_room_notification = ::std::option::Option::Some(is.read_bool()?);
                    },
                    128 => {
                        self.sounds_play_chat_room_notification = ::std::option::Option::Some(is.read_bool()?);
                    },
                    136 => {
                        self.hide_offline_friends_in_tag_groups = ::std::option::Option::Some(is.read_bool()?);
                    },
                    144 => {
                        self.hide_categorized_friends = ::std::option::Option::Some(is.read_bool()?);
                    },
                    152 => {
                        self.categorize_in_game_friends_by_game = ::std::option::Option::Some(is.read_bool()?);
                    },
                    160 => {
                        self.chat_font_size = ::std::option::Option::Some(is.read_int32()?);
                    },
                    168 => {
                        self.use24hour_clock = ::std::option::Option::Some(is.read_bool()?);
                    },
                    176 => {
                        self.do_not_disturb_mode = ::std::option::Option::Some(is.read_bool()?);
                    },
                    184 => {
                        self.disable_embed_inlining = ::std::option::Option::Some(is.read_bool()?);
                    },
                    192 => {
                        self.sign_into_friends = ::std::option::Option::Some(is.read_bool()?);
                    },
                    200 => {
                        self.animated_avatars = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.notifications_show_ingame {
                my_size += 1 + 1;
            }
            if let Some(v) = self.notifications_show_online {
                my_size += 1 + 1;
            }
            if let Some(v) = self.notifications_show_message {
                my_size += 1 + 1;
            }
            if let Some(v) = self.notifications_events_and_announcements {
                my_size += 1 + 1;
            }
            if let Some(v) = self.sounds_play_ingame {
                my_size += 1 + 1;
            }
            if let Some(v) = self.sounds_play_online {
                my_size += 1 + 1;
            }
            if let Some(v) = self.sounds_play_message {
                my_size += 1 + 1;
            }
            if let Some(v) = self.sounds_events_and_announcements {
                my_size += 1 + 1;
            }
            if let Some(v) = self.always_new_chat_window {
                my_size += 1 + 1;
            }
            if let Some(v) = self.force_alphabetic_friend_sorting {
                my_size += 1 + 1;
            }
            if let Some(v) = self.chat_flash_mode {
                my_size += ::protobuf::rt::int32_size(11, v);
            }
            if let Some(v) = self.remember_open_chats {
                my_size += 1 + 1;
            }
            if let Some(v) = self.compact_quick_access {
                my_size += 1 + 1;
            }
            if let Some(v) = self.compact_friends_list {
                my_size += 1 + 1;
            }
            if let Some(v) = self.notifications_show_chat_room_notification {
                my_size += 1 + 1;
            }
            if let Some(v) = self.sounds_play_chat_room_notification {
                my_size += 2 + 1;
            }
            if let Some(v) = self.hide_offline_friends_in_tag_groups {
                my_size += 2 + 1;
            }
            if let Some(v) = self.hide_categorized_friends {
                my_size += 2 + 1;
            }
            if let Some(v) = self.categorize_in_game_friends_by_game {
                my_size += 2 + 1;
            }
            if let Some(v) = self.chat_font_size {
                my_size += ::protobuf::rt::int32_size(20, v);
            }
            if let Some(v) = self.use24hour_clock {
                my_size += 2 + 1;
            }
            if let Some(v) = self.do_not_disturb_mode {
                my_size += 2 + 1;
            }
            if let Some(v) = self.disable_embed_inlining {
                my_size += 2 + 1;
            }
            if let Some(v) = self.sign_into_friends {
                my_size += 2 + 1;
            }
            if let Some(v) = self.animated_avatars {
                my_size += 2 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.notifications_show_ingame {
                os.write_bool(1, v)?;
            }
            if let Some(v) = self.notifications_show_online {
                os.write_bool(2, v)?;
            }
            if let Some(v) = self.notifications_show_message {
                os.write_bool(3, v)?;
            }
            if let Some(v) = self.notifications_events_and_announcements {
                os.write_bool(4, v)?;
            }
            if let Some(v) = self.sounds_play_ingame {
                os.write_bool(5, v)?;
            }
            if let Some(v) = self.sounds_play_online {
                os.write_bool(6, v)?;
            }
            if let Some(v) = self.sounds_play_message {
                os.write_bool(7, v)?;
            }
            if let Some(v) = self.sounds_events_and_announcements {
                os.write_bool(8, v)?;
            }
            if let Some(v) = self.always_new_chat_window {
                os.write_bool(9, v)?;
            }
            if let Some(v) = self.force_alphabetic_friend_sorting {
                os.write_bool(10, v)?;
            }
            if let Some(v) = self.chat_flash_mode {
                os.write_int32(11, v)?;
            }
            if let Some(v) = self.remember_open_chats {
                os.write_bool(12, v)?;
            }
            if let Some(v) = self.compact_quick_access {
                os.write_bool(13, v)?;
            }
            if let Some(v) = self.compact_friends_list {
                os.write_bool(14, v)?;
            }
            if let Some(v) = self.notifications_show_chat_room_notification {
                os.write_bool(15, v)?;
            }
            if let Some(v) = self.sounds_play_chat_room_notification {
                os.write_bool(16, v)?;
            }
            if let Some(v) = self.hide_offline_friends_in_tag_groups {
                os.write_bool(17, v)?;
            }
            if let Some(v) = self.hide_categorized_friends {
                os.write_bool(18, v)?;
            }
            if let Some(v) = self.categorize_in_game_friends_by_game {
                os.write_bool(19, v)?;
            }
            if let Some(v) = self.chat_font_size {
                os.write_int32(20, v)?;
            }
            if let Some(v) = self.use24hour_clock {
                os.write_bool(21, v)?;
            }
            if let Some(v) = self.do_not_disturb_mode {
                os.write_bool(22, v)?;
            }
            if let Some(v) = self.disable_embed_inlining {
                os.write_bool(23, v)?;
            }
            if let Some(v) = self.sign_into_friends {
                os.write_bool(24, v)?;
            }
            if let Some(v) = self.animated_avatars {
                os.write_bool(25, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Settings {
            Settings::new()
        }

        fn clear(&mut self) {
            self.notifications_show_ingame = ::std::option::Option::None;
            self.notifications_show_online = ::std::option::Option::None;
            self.notifications_show_message = ::std::option::Option::None;
            self.notifications_events_and_announcements = ::std::option::Option::None;
            self.sounds_play_ingame = ::std::option::Option::None;
            self.sounds_play_online = ::std::option::Option::None;
            self.sounds_play_message = ::std::option::Option::None;
            self.sounds_events_and_announcements = ::std::option::Option::None;
            self.always_new_chat_window = ::std::option::Option::None;
            self.force_alphabetic_friend_sorting = ::std::option::Option::None;
            self.chat_flash_mode = ::std::option::Option::None;
            self.remember_open_chats = ::std::option::Option::None;
            self.compact_quick_access = ::std::option::Option::None;
            self.compact_friends_list = ::std::option::Option::None;
            self.notifications_show_chat_room_notification = ::std::option::Option::None;
            self.sounds_play_chat_room_notification = ::std::option::Option::None;
            self.hide_offline_friends_in_tag_groups = ::std::option::Option::None;
            self.hide_categorized_friends = ::std::option::Option::None;
            self.categorize_in_game_friends_by_game = ::std::option::Option::None;
            self.chat_font_size = ::std::option::Option::None;
            self.use24hour_clock = ::std::option::Option::None;
            self.do_not_disturb_mode = ::std::option::Option::None;
            self.disable_embed_inlining = ::std::option::Option::None;
            self.sign_into_friends = ::std::option::Option::None;
            self.animated_avatars = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Settings {
            static instance: Settings = Settings {
                notifications_show_ingame: ::std::option::Option::None,
                notifications_show_online: ::std::option::Option::None,
                notifications_show_message: ::std::option::Option::None,
                notifications_events_and_announcements: ::std::option::Option::None,
                sounds_play_ingame: ::std::option::Option::None,
                sounds_play_online: ::std::option::Option::None,
                sounds_play_message: ::std::option::Option::None,
                sounds_events_and_announcements: ::std::option::Option::None,
                always_new_chat_window: ::std::option::Option::None,
                force_alphabetic_friend_sorting: ::std::option::Option::None,
                chat_flash_mode: ::std::option::Option::None,
                remember_open_chats: ::std::option::Option::None,
                compact_quick_access: ::std::option::Option::None,
                compact_friends_list: ::std::option::Option::None,
                notifications_show_chat_room_notification: ::std::option::Option::None,
                sounds_play_chat_room_notification: ::std::option::Option::None,
                hide_offline_friends_in_tag_groups: ::std::option::Option::None,
                hide_categorized_friends: ::std::option::Option::None,
                categorize_in_game_friends_by_game: ::std::option::Option::None,
                chat_font_size: ::std::option::Option::None,
                use24hour_clock: ::std::option::Option::None,
                do_not_disturb_mode: ::std::option::Option::None,
                disable_embed_inlining: ::std::option::Option::None,
                sign_into_friends: ::std::option::Option::None,
                animated_avatars: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Settings {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CChatUsability_ClientUsabilityMetrics_Notification.Settings").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Settings {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Settings {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct VoiceSettings {
        // message fields
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings.voice_input_gain)
        pub voice_input_gain: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings.voice_output_gain)
        pub voice_output_gain: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings.noise_gate_level)
        pub noise_gate_level: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings.voice_use_echo_cancellation)
        pub voice_use_echo_cancellation: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings.voice_use_noise_cancellation)
        pub voice_use_noise_cancellation: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings.voice_use_auto_gain_control)
        pub voice_use_auto_gain_control: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings.selected_non_default_mic)
        pub selected_non_default_mic: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings.selected_non_default_output)
        pub selected_non_default_output: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings.push_to_talk_enabled)
        pub push_to_talk_enabled: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings.push_to_mute_enabled)
        pub push_to_mute_enabled: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings.play_ptt_sounds)
        pub play_ptt_sounds: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a VoiceSettings {
        fn default() -> &'a VoiceSettings {
            <VoiceSettings as ::protobuf::Message>::default_instance()
        }
    }

    impl VoiceSettings {
        pub fn new() -> VoiceSettings {
            ::std::default::Default::default()
        }

        // optional float voice_input_gain = 1;

        pub fn voice_input_gain(&self) -> f32 {
            self.voice_input_gain.unwrap_or(0.)
        }

        pub fn clear_voice_input_gain(&mut self) {
            self.voice_input_gain = ::std::option::Option::None;
        }

        pub fn has_voice_input_gain(&self) -> bool {
            self.voice_input_gain.is_some()
        }

        // Param is passed by value, moved
        pub fn set_voice_input_gain(&mut self, v: f32) {
            self.voice_input_gain = ::std::option::Option::Some(v);
        }

        // optional float voice_output_gain = 2;

        pub fn voice_output_gain(&self) -> f32 {
            self.voice_output_gain.unwrap_or(0.)
        }

        pub fn clear_voice_output_gain(&mut self) {
            self.voice_output_gain = ::std::option::Option::None;
        }

        pub fn has_voice_output_gain(&self) -> bool {
            self.voice_output_gain.is_some()
        }

        // Param is passed by value, moved
        pub fn set_voice_output_gain(&mut self, v: f32) {
            self.voice_output_gain = ::std::option::Option::Some(v);
        }

        // optional int32 noise_gate_level = 3;

        pub fn noise_gate_level(&self) -> i32 {
            self.noise_gate_level.unwrap_or(0)
        }

        pub fn clear_noise_gate_level(&mut self) {
            self.noise_gate_level = ::std::option::Option::None;
        }

        pub fn has_noise_gate_level(&self) -> bool {
            self.noise_gate_level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_noise_gate_level(&mut self, v: i32) {
            self.noise_gate_level = ::std::option::Option::Some(v);
        }

        // optional bool voice_use_echo_cancellation = 4;

        pub fn voice_use_echo_cancellation(&self) -> bool {
            self.voice_use_echo_cancellation.unwrap_or(false)
        }

        pub fn clear_voice_use_echo_cancellation(&mut self) {
            self.voice_use_echo_cancellation = ::std::option::Option::None;
        }

        pub fn has_voice_use_echo_cancellation(&self) -> bool {
            self.voice_use_echo_cancellation.is_some()
        }

        // Param is passed by value, moved
        pub fn set_voice_use_echo_cancellation(&mut self, v: bool) {
            self.voice_use_echo_cancellation = ::std::option::Option::Some(v);
        }

        // optional bool voice_use_noise_cancellation = 5;

        pub fn voice_use_noise_cancellation(&self) -> bool {
            self.voice_use_noise_cancellation.unwrap_or(false)
        }

        pub fn clear_voice_use_noise_cancellation(&mut self) {
            self.voice_use_noise_cancellation = ::std::option::Option::None;
        }

        pub fn has_voice_use_noise_cancellation(&self) -> bool {
            self.voice_use_noise_cancellation.is_some()
        }

        // Param is passed by value, moved
        pub fn set_voice_use_noise_cancellation(&mut self, v: bool) {
            self.voice_use_noise_cancellation = ::std::option::Option::Some(v);
        }

        // optional bool voice_use_auto_gain_control = 6;

        pub fn voice_use_auto_gain_control(&self) -> bool {
            self.voice_use_auto_gain_control.unwrap_or(false)
        }

        pub fn clear_voice_use_auto_gain_control(&mut self) {
            self.voice_use_auto_gain_control = ::std::option::Option::None;
        }

        pub fn has_voice_use_auto_gain_control(&self) -> bool {
            self.voice_use_auto_gain_control.is_some()
        }

        // Param is passed by value, moved
        pub fn set_voice_use_auto_gain_control(&mut self, v: bool) {
            self.voice_use_auto_gain_control = ::std::option::Option::Some(v);
        }

        // optional bool selected_non_default_mic = 7;

        pub fn selected_non_default_mic(&self) -> bool {
            self.selected_non_default_mic.unwrap_or(false)
        }

        pub fn clear_selected_non_default_mic(&mut self) {
            self.selected_non_default_mic = ::std::option::Option::None;
        }

        pub fn has_selected_non_default_mic(&self) -> bool {
            self.selected_non_default_mic.is_some()
        }

        // Param is passed by value, moved
        pub fn set_selected_non_default_mic(&mut self, v: bool) {
            self.selected_non_default_mic = ::std::option::Option::Some(v);
        }

        // optional bool selected_non_default_output = 8;

        pub fn selected_non_default_output(&self) -> bool {
            self.selected_non_default_output.unwrap_or(false)
        }

        pub fn clear_selected_non_default_output(&mut self) {
            self.selected_non_default_output = ::std::option::Option::None;
        }

        pub fn has_selected_non_default_output(&self) -> bool {
            self.selected_non_default_output.is_some()
        }

        // Param is passed by value, moved
        pub fn set_selected_non_default_output(&mut self, v: bool) {
            self.selected_non_default_output = ::std::option::Option::Some(v);
        }

        // optional bool push_to_talk_enabled = 9;

        pub fn push_to_talk_enabled(&self) -> bool {
            self.push_to_talk_enabled.unwrap_or(false)
        }

        pub fn clear_push_to_talk_enabled(&mut self) {
            self.push_to_talk_enabled = ::std::option::Option::None;
        }

        pub fn has_push_to_talk_enabled(&self) -> bool {
            self.push_to_talk_enabled.is_some()
        }

        // Param is passed by value, moved
        pub fn set_push_to_talk_enabled(&mut self, v: bool) {
            self.push_to_talk_enabled = ::std::option::Option::Some(v);
        }

        // optional bool push_to_mute_enabled = 10;

        pub fn push_to_mute_enabled(&self) -> bool {
            self.push_to_mute_enabled.unwrap_or(false)
        }

        pub fn clear_push_to_mute_enabled(&mut self) {
            self.push_to_mute_enabled = ::std::option::Option::None;
        }

        pub fn has_push_to_mute_enabled(&self) -> bool {
            self.push_to_mute_enabled.is_some()
        }

        // Param is passed by value, moved
        pub fn set_push_to_mute_enabled(&mut self, v: bool) {
            self.push_to_mute_enabled = ::std::option::Option::Some(v);
        }

        // optional bool play_ptt_sounds = 11;

        pub fn play_ptt_sounds(&self) -> bool {
            self.play_ptt_sounds.unwrap_or(false)
        }

        pub fn clear_play_ptt_sounds(&mut self) {
            self.play_ptt_sounds = ::std::option::Option::None;
        }

        pub fn has_play_ptt_sounds(&self) -> bool {
            self.play_ptt_sounds.is_some()
        }

        // Param is passed by value, moved
        pub fn set_play_ptt_sounds(&mut self, v: bool) {
            self.play_ptt_sounds = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(11);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "voice_input_gain",
                |m: &VoiceSettings| { &m.voice_input_gain },
                |m: &mut VoiceSettings| { &mut m.voice_input_gain },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "voice_output_gain",
                |m: &VoiceSettings| { &m.voice_output_gain },
                |m: &mut VoiceSettings| { &mut m.voice_output_gain },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "noise_gate_level",
                |m: &VoiceSettings| { &m.noise_gate_level },
                |m: &mut VoiceSettings| { &mut m.noise_gate_level },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "voice_use_echo_cancellation",
                |m: &VoiceSettings| { &m.voice_use_echo_cancellation },
                |m: &mut VoiceSettings| { &mut m.voice_use_echo_cancellation },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "voice_use_noise_cancellation",
                |m: &VoiceSettings| { &m.voice_use_noise_cancellation },
                |m: &mut VoiceSettings| { &mut m.voice_use_noise_cancellation },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "voice_use_auto_gain_control",
                |m: &VoiceSettings| { &m.voice_use_auto_gain_control },
                |m: &mut VoiceSettings| { &mut m.voice_use_auto_gain_control },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "selected_non_default_mic",
                |m: &VoiceSettings| { &m.selected_non_default_mic },
                |m: &mut VoiceSettings| { &mut m.selected_non_default_mic },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "selected_non_default_output",
                |m: &VoiceSettings| { &m.selected_non_default_output },
                |m: &mut VoiceSettings| { &mut m.selected_non_default_output },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "push_to_talk_enabled",
                |m: &VoiceSettings| { &m.push_to_talk_enabled },
                |m: &mut VoiceSettings| { &mut m.push_to_talk_enabled },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "push_to_mute_enabled",
                |m: &VoiceSettings| { &m.push_to_mute_enabled },
                |m: &mut VoiceSettings| { &mut m.push_to_mute_enabled },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "play_ptt_sounds",
                |m: &VoiceSettings| { &m.play_ptt_sounds },
                |m: &mut VoiceSettings| { &mut m.play_ptt_sounds },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VoiceSettings>(
                "CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for VoiceSettings {
        const NAME: &'static str = "VoiceSettings";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.voice_input_gain = ::std::option::Option::Some(is.read_float()?);
                    },
                    21 => {
                        self.voice_output_gain = ::std::option::Option::Some(is.read_float()?);
                    },
                    24 => {
                        self.noise_gate_level = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.voice_use_echo_cancellation = ::std::option::Option::Some(is.read_bool()?);
                    },
                    40 => {
                        self.voice_use_noise_cancellation = ::std::option::Option::Some(is.read_bool()?);
                    },
                    48 => {
                        self.voice_use_auto_gain_control = ::std::option::Option::Some(is.read_bool()?);
                    },
                    56 => {
                        self.selected_non_default_mic = ::std::option::Option::Some(is.read_bool()?);
                    },
                    64 => {
                        self.selected_non_default_output = ::std::option::Option::Some(is.read_bool()?);
                    },
                    72 => {
                        self.push_to_talk_enabled = ::std::option::Option::Some(is.read_bool()?);
                    },
                    80 => {
                        self.push_to_mute_enabled = ::std::option::Option::Some(is.read_bool()?);
                    },
                    88 => {
                        self.play_ptt_sounds = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.voice_input_gain {
                my_size += 1 + 4;
            }
            if let Some(v) = self.voice_output_gain {
                my_size += 1 + 4;
            }
            if let Some(v) = self.noise_gate_level {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.voice_use_echo_cancellation {
                my_size += 1 + 1;
            }
            if let Some(v) = self.voice_use_noise_cancellation {
                my_size += 1 + 1;
            }
            if let Some(v) = self.voice_use_auto_gain_control {
                my_size += 1 + 1;
            }
            if let Some(v) = self.selected_non_default_mic {
                my_size += 1 + 1;
            }
            if let Some(v) = self.selected_non_default_output {
                my_size += 1 + 1;
            }
            if let Some(v) = self.push_to_talk_enabled {
                my_size += 1 + 1;
            }
            if let Some(v) = self.push_to_mute_enabled {
                my_size += 1 + 1;
            }
            if let Some(v) = self.play_ptt_sounds {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.voice_input_gain {
                os.write_float(1, v)?;
            }
            if let Some(v) = self.voice_output_gain {
                os.write_float(2, v)?;
            }
            if let Some(v) = self.noise_gate_level {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.voice_use_echo_cancellation {
                os.write_bool(4, v)?;
            }
            if let Some(v) = self.voice_use_noise_cancellation {
                os.write_bool(5, v)?;
            }
            if let Some(v) = self.voice_use_auto_gain_control {
                os.write_bool(6, v)?;
            }
            if let Some(v) = self.selected_non_default_mic {
                os.write_bool(7, v)?;
            }
            if let Some(v) = self.selected_non_default_output {
                os.write_bool(8, v)?;
            }
            if let Some(v) = self.push_to_talk_enabled {
                os.write_bool(9, v)?;
            }
            if let Some(v) = self.push_to_mute_enabled {
                os.write_bool(10, v)?;
            }
            if let Some(v) = self.play_ptt_sounds {
                os.write_bool(11, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> VoiceSettings {
            VoiceSettings::new()
        }

        fn clear(&mut self) {
            self.voice_input_gain = ::std::option::Option::None;
            self.voice_output_gain = ::std::option::Option::None;
            self.noise_gate_level = ::std::option::Option::None;
            self.voice_use_echo_cancellation = ::std::option::Option::None;
            self.voice_use_noise_cancellation = ::std::option::Option::None;
            self.voice_use_auto_gain_control = ::std::option::Option::None;
            self.selected_non_default_mic = ::std::option::Option::None;
            self.selected_non_default_output = ::std::option::Option::None;
            self.push_to_talk_enabled = ::std::option::Option::None;
            self.push_to_mute_enabled = ::std::option::Option::None;
            self.play_ptt_sounds = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static VoiceSettings {
            static instance: VoiceSettings = VoiceSettings {
                voice_input_gain: ::std::option::Option::None,
                voice_output_gain: ::std::option::Option::None,
                noise_gate_level: ::std::option::Option::None,
                voice_use_echo_cancellation: ::std::option::Option::None,
                voice_use_noise_cancellation: ::std::option::Option::None,
                voice_use_auto_gain_control: ::std::option::Option::None,
                selected_non_default_mic: ::std::option::Option::None,
                selected_non_default_output: ::std::option::Option::None,
                push_to_talk_enabled: ::std::option::Option::None,
                push_to_mute_enabled: ::std::option::Option::None,
                play_ptt_sounds: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for VoiceSettings {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for VoiceSettings {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for VoiceSettings {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CChatUsability_ClientUsabilityMetrics_Notification.UIState)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UIState {
        // message fields
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.friends_list_height)
        pub friends_list_height: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.friends_list_width)
        pub friends_list_width: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.friends_list_docked)
        pub friends_list_docked: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.friends_list_collapsed)
        pub friends_list_collapsed: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.friends_list_group_chats_height)
        pub friends_list_group_chats_height: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.friends_list_visible)
        pub friends_list_visible: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.chat_popups_opened)
        pub chat_popups_opened: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.group_chat_tabs_opened)
        pub group_chat_tabs_opened: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.friend_chat_tabs_opened)
        pub friend_chat_tabs_opened: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.chat_window_width)
        pub chat_window_width: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.chat_window_height)
        pub chat_window_height: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.category_collapse)
        pub category_collapse: ::protobuf::MessageField<uistate::CategoryCollapseState>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.group_chat_left_col_collapsed)
        pub group_chat_left_col_collapsed: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.group_chat_right_col_collapsed)
        pub group_chat_right_col_collapsed: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.in_one_on_one_voice_chat)
        pub in_one_on_one_voice_chat: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.in_group_voice_chat)
        pub in_group_voice_chat: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UIState {
        fn default() -> &'a UIState {
            <UIState as ::protobuf::Message>::default_instance()
        }
    }

    impl UIState {
        pub fn new() -> UIState {
            ::std::default::Default::default()
        }

        // optional int32 friends_list_height = 1;

        pub fn friends_list_height(&self) -> i32 {
            self.friends_list_height.unwrap_or(0)
        }

        pub fn clear_friends_list_height(&mut self) {
            self.friends_list_height = ::std::option::Option::None;
        }

        pub fn has_friends_list_height(&self) -> bool {
            self.friends_list_height.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friends_list_height(&mut self, v: i32) {
            self.friends_list_height = ::std::option::Option::Some(v);
        }

        // optional int32 friends_list_width = 2;

        pub fn friends_list_width(&self) -> i32 {
            self.friends_list_width.unwrap_or(0)
        }

        pub fn clear_friends_list_width(&mut self) {
            self.friends_list_width = ::std::option::Option::None;
        }

        pub fn has_friends_list_width(&self) -> bool {
            self.friends_list_width.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friends_list_width(&mut self, v: i32) {
            self.friends_list_width = ::std::option::Option::Some(v);
        }

        // optional bool friends_list_docked = 3;

        pub fn friends_list_docked(&self) -> bool {
            self.friends_list_docked.unwrap_or(false)
        }

        pub fn clear_friends_list_docked(&mut self) {
            self.friends_list_docked = ::std::option::Option::None;
        }

        pub fn has_friends_list_docked(&self) -> bool {
            self.friends_list_docked.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friends_list_docked(&mut self, v: bool) {
            self.friends_list_docked = ::std::option::Option::Some(v);
        }

        // optional bool friends_list_collapsed = 4;

        pub fn friends_list_collapsed(&self) -> bool {
            self.friends_list_collapsed.unwrap_or(false)
        }

        pub fn clear_friends_list_collapsed(&mut self) {
            self.friends_list_collapsed = ::std::option::Option::None;
        }

        pub fn has_friends_list_collapsed(&self) -> bool {
            self.friends_list_collapsed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friends_list_collapsed(&mut self, v: bool) {
            self.friends_list_collapsed = ::std::option::Option::Some(v);
        }

        // optional int32 friends_list_group_chats_height = 5;

        pub fn friends_list_group_chats_height(&self) -> i32 {
            self.friends_list_group_chats_height.unwrap_or(0)
        }

        pub fn clear_friends_list_group_chats_height(&mut self) {
            self.friends_list_group_chats_height = ::std::option::Option::None;
        }

        pub fn has_friends_list_group_chats_height(&self) -> bool {
            self.friends_list_group_chats_height.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friends_list_group_chats_height(&mut self, v: i32) {
            self.friends_list_group_chats_height = ::std::option::Option::Some(v);
        }

        // optional bool friends_list_visible = 6;

        pub fn friends_list_visible(&self) -> bool {
            self.friends_list_visible.unwrap_or(false)
        }

        pub fn clear_friends_list_visible(&mut self) {
            self.friends_list_visible = ::std::option::Option::None;
        }

        pub fn has_friends_list_visible(&self) -> bool {
            self.friends_list_visible.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friends_list_visible(&mut self, v: bool) {
            self.friends_list_visible = ::std::option::Option::Some(v);
        }

        // optional int32 chat_popups_opened = 7;

        pub fn chat_popups_opened(&self) -> i32 {
            self.chat_popups_opened.unwrap_or(0)
        }

        pub fn clear_chat_popups_opened(&mut self) {
            self.chat_popups_opened = ::std::option::Option::None;
        }

        pub fn has_chat_popups_opened(&self) -> bool {
            self.chat_popups_opened.is_some()
        }

        // Param is passed by value, moved
        pub fn set_chat_popups_opened(&mut self, v: i32) {
            self.chat_popups_opened = ::std::option::Option::Some(v);
        }

        // optional int32 group_chat_tabs_opened = 8;

        pub fn group_chat_tabs_opened(&self) -> i32 {
            self.group_chat_tabs_opened.unwrap_or(0)
        }

        pub fn clear_group_chat_tabs_opened(&mut self) {
            self.group_chat_tabs_opened = ::std::option::Option::None;
        }

        pub fn has_group_chat_tabs_opened(&self) -> bool {
            self.group_chat_tabs_opened.is_some()
        }

        // Param is passed by value, moved
        pub fn set_group_chat_tabs_opened(&mut self, v: i32) {
            self.group_chat_tabs_opened = ::std::option::Option::Some(v);
        }

        // optional int32 friend_chat_tabs_opened = 9;

        pub fn friend_chat_tabs_opened(&self) -> i32 {
            self.friend_chat_tabs_opened.unwrap_or(0)
        }

        pub fn clear_friend_chat_tabs_opened(&mut self) {
            self.friend_chat_tabs_opened = ::std::option::Option::None;
        }

        pub fn has_friend_chat_tabs_opened(&self) -> bool {
            self.friend_chat_tabs_opened.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friend_chat_tabs_opened(&mut self, v: i32) {
            self.friend_chat_tabs_opened = ::std::option::Option::Some(v);
        }

        // optional int32 chat_window_width = 10;

        pub fn chat_window_width(&self) -> i32 {
            self.chat_window_width.unwrap_or(0)
        }

        pub fn clear_chat_window_width(&mut self) {
            self.chat_window_width = ::std::option::Option::None;
        }

        pub fn has_chat_window_width(&self) -> bool {
            self.chat_window_width.is_some()
        }

        // Param is passed by value, moved
        pub fn set_chat_window_width(&mut self, v: i32) {
            self.chat_window_width = ::std::option::Option::Some(v);
        }

        // optional int32 chat_window_height = 11;

        pub fn chat_window_height(&self) -> i32 {
            self.chat_window_height.unwrap_or(0)
        }

        pub fn clear_chat_window_height(&mut self) {
            self.chat_window_height = ::std::option::Option::None;
        }

        pub fn has_chat_window_height(&self) -> bool {
            self.chat_window_height.is_some()
        }

        // Param is passed by value, moved
        pub fn set_chat_window_height(&mut self, v: i32) {
            self.chat_window_height = ::std::option::Option::Some(v);
        }

        // optional int32 group_chat_left_col_collapsed = 13;

        pub fn group_chat_left_col_collapsed(&self) -> i32 {
            self.group_chat_left_col_collapsed.unwrap_or(0)
        }

        pub fn clear_group_chat_left_col_collapsed(&mut self) {
            self.group_chat_left_col_collapsed = ::std::option::Option::None;
        }

        pub fn has_group_chat_left_col_collapsed(&self) -> bool {
            self.group_chat_left_col_collapsed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_group_chat_left_col_collapsed(&mut self, v: i32) {
            self.group_chat_left_col_collapsed = ::std::option::Option::Some(v);
        }

        // optional int32 group_chat_right_col_collapsed = 14;

        pub fn group_chat_right_col_collapsed(&self) -> i32 {
            self.group_chat_right_col_collapsed.unwrap_or(0)
        }

        pub fn clear_group_chat_right_col_collapsed(&mut self) {
            self.group_chat_right_col_collapsed = ::std::option::Option::None;
        }

        pub fn has_group_chat_right_col_collapsed(&self) -> bool {
            self.group_chat_right_col_collapsed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_group_chat_right_col_collapsed(&mut self, v: i32) {
            self.group_chat_right_col_collapsed = ::std::option::Option::Some(v);
        }

        // optional bool in_one_on_one_voice_chat = 15;

        pub fn in_one_on_one_voice_chat(&self) -> bool {
            self.in_one_on_one_voice_chat.unwrap_or(false)
        }

        pub fn clear_in_one_on_one_voice_chat(&mut self) {
            self.in_one_on_one_voice_chat = ::std::option::Option::None;
        }

        pub fn has_in_one_on_one_voice_chat(&self) -> bool {
            self.in_one_on_one_voice_chat.is_some()
        }

        // Param is passed by value, moved
        pub fn set_in_one_on_one_voice_chat(&mut self, v: bool) {
            self.in_one_on_one_voice_chat = ::std::option::Option::Some(v);
        }

        // optional bool in_group_voice_chat = 16;

        pub fn in_group_voice_chat(&self) -> bool {
            self.in_group_voice_chat.unwrap_or(false)
        }

        pub fn clear_in_group_voice_chat(&mut self) {
            self.in_group_voice_chat = ::std::option::Option::None;
        }

        pub fn has_in_group_voice_chat(&self) -> bool {
            self.in_group_voice_chat.is_some()
        }

        // Param is passed by value, moved
        pub fn set_in_group_voice_chat(&mut self, v: bool) {
            self.in_group_voice_chat = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(16);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "friends_list_height",
                |m: &UIState| { &m.friends_list_height },
                |m: &mut UIState| { &mut m.friends_list_height },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "friends_list_width",
                |m: &UIState| { &m.friends_list_width },
                |m: &mut UIState| { &mut m.friends_list_width },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "friends_list_docked",
                |m: &UIState| { &m.friends_list_docked },
                |m: &mut UIState| { &mut m.friends_list_docked },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "friends_list_collapsed",
                |m: &UIState| { &m.friends_list_collapsed },
                |m: &mut UIState| { &mut m.friends_list_collapsed },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "friends_list_group_chats_height",
                |m: &UIState| { &m.friends_list_group_chats_height },
                |m: &mut UIState| { &mut m.friends_list_group_chats_height },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "friends_list_visible",
                |m: &UIState| { &m.friends_list_visible },
                |m: &mut UIState| { &mut m.friends_list_visible },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "chat_popups_opened",
                |m: &UIState| { &m.chat_popups_opened },
                |m: &mut UIState| { &mut m.chat_popups_opened },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "group_chat_tabs_opened",
                |m: &UIState| { &m.group_chat_tabs_opened },
                |m: &mut UIState| { &mut m.group_chat_tabs_opened },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "friend_chat_tabs_opened",
                |m: &UIState| { &m.friend_chat_tabs_opened },
                |m: &mut UIState| { &mut m.friend_chat_tabs_opened },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "chat_window_width",
                |m: &UIState| { &m.chat_window_width },
                |m: &mut UIState| { &mut m.chat_window_width },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "chat_window_height",
                |m: &UIState| { &m.chat_window_height },
                |m: &mut UIState| { &mut m.chat_window_height },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, uistate::CategoryCollapseState>(
                "category_collapse",
                |m: &UIState| { &m.category_collapse },
                |m: &mut UIState| { &mut m.category_collapse },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "group_chat_left_col_collapsed",
                |m: &UIState| { &m.group_chat_left_col_collapsed },
                |m: &mut UIState| { &mut m.group_chat_left_col_collapsed },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "group_chat_right_col_collapsed",
                |m: &UIState| { &m.group_chat_right_col_collapsed },
                |m: &mut UIState| { &mut m.group_chat_right_col_collapsed },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "in_one_on_one_voice_chat",
                |m: &UIState| { &m.in_one_on_one_voice_chat },
                |m: &mut UIState| { &mut m.in_one_on_one_voice_chat },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "in_group_voice_chat",
                |m: &UIState| { &m.in_group_voice_chat },
                |m: &mut UIState| { &mut m.in_group_voice_chat },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UIState>(
                "CChatUsability_ClientUsabilityMetrics_Notification.UIState",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for UIState {
        const NAME: &'static str = "UIState";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.friends_list_height = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.friends_list_width = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.friends_list_docked = ::std::option::Option::Some(is.read_bool()?);
                    },
                    32 => {
                        self.friends_list_collapsed = ::std::option::Option::Some(is.read_bool()?);
                    },
                    40 => {
                        self.friends_list_group_chats_height = ::std::option::Option::Some(is.read_int32()?);
                    },
                    48 => {
                        self.friends_list_visible = ::std::option::Option::Some(is.read_bool()?);
                    },
                    56 => {
                        self.chat_popups_opened = ::std::option::Option::Some(is.read_int32()?);
                    },
                    64 => {
                        self.group_chat_tabs_opened = ::std::option::Option::Some(is.read_int32()?);
                    },
                    72 => {
                        self.friend_chat_tabs_opened = ::std::option::Option::Some(is.read_int32()?);
                    },
                    80 => {
                        self.chat_window_width = ::std::option::Option::Some(is.read_int32()?);
                    },
                    88 => {
                        self.chat_window_height = ::std::option::Option::Some(is.read_int32()?);
                    },
                    98 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.category_collapse)?;
                    },
                    104 => {
                        self.group_chat_left_col_collapsed = ::std::option::Option::Some(is.read_int32()?);
                    },
                    112 => {
                        self.group_chat_right_col_collapsed = ::std::option::Option::Some(is.read_int32()?);
                    },
                    120 => {
                        self.in_one_on_one_voice_chat = ::std::option::Option::Some(is.read_bool()?);
                    },
                    128 => {
                        self.in_group_voice_chat = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.friends_list_height {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.friends_list_width {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.friends_list_docked {
                my_size += 1 + 1;
            }
            if let Some(v) = self.friends_list_collapsed {
                my_size += 1 + 1;
            }
            if let Some(v) = self.friends_list_group_chats_height {
                my_size += ::protobuf::rt::int32_size(5, v);
            }
            if let Some(v) = self.friends_list_visible {
                my_size += 1 + 1;
            }
            if let Some(v) = self.chat_popups_opened {
                my_size += ::protobuf::rt::int32_size(7, v);
            }
            if let Some(v) = self.group_chat_tabs_opened {
                my_size += ::protobuf::rt::int32_size(8, v);
            }
            if let Some(v) = self.friend_chat_tabs_opened {
                my_size += ::protobuf::rt::int32_size(9, v);
            }
            if let Some(v) = self.chat_window_width {
                my_size += ::protobuf::rt::int32_size(10, v);
            }
            if let Some(v) = self.chat_window_height {
                my_size += ::protobuf::rt::int32_size(11, v);
            }
            if let Some(v) = self.category_collapse.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.group_chat_left_col_collapsed {
                my_size += ::protobuf::rt::int32_size(13, v);
            }
            if let Some(v) = self.group_chat_right_col_collapsed {
                my_size += ::protobuf::rt::int32_size(14, v);
            }
            if let Some(v) = self.in_one_on_one_voice_chat {
                my_size += 1 + 1;
            }
            if let Some(v) = self.in_group_voice_chat {
                my_size += 2 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.friends_list_height {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.friends_list_width {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.friends_list_docked {
                os.write_bool(3, v)?;
            }
            if let Some(v) = self.friends_list_collapsed {
                os.write_bool(4, v)?;
            }
            if let Some(v) = self.friends_list_group_chats_height {
                os.write_int32(5, v)?;
            }
            if let Some(v) = self.friends_list_visible {
                os.write_bool(6, v)?;
            }
            if let Some(v) = self.chat_popups_opened {
                os.write_int32(7, v)?;
            }
            if let Some(v) = self.group_chat_tabs_opened {
                os.write_int32(8, v)?;
            }
            if let Some(v) = self.friend_chat_tabs_opened {
                os.write_int32(9, v)?;
            }
            if let Some(v) = self.chat_window_width {
                os.write_int32(10, v)?;
            }
            if let Some(v) = self.chat_window_height {
                os.write_int32(11, v)?;
            }
            if let Some(v) = self.category_collapse.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
            }
            if let Some(v) = self.group_chat_left_col_collapsed {
                os.write_int32(13, v)?;
            }
            if let Some(v) = self.group_chat_right_col_collapsed {
                os.write_int32(14, v)?;
            }
            if let Some(v) = self.in_one_on_one_voice_chat {
                os.write_bool(15, v)?;
            }
            if let Some(v) = self.in_group_voice_chat {
                os.write_bool(16, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UIState {
            UIState::new()
        }

        fn clear(&mut self) {
            self.friends_list_height = ::std::option::Option::None;
            self.friends_list_width = ::std::option::Option::None;
            self.friends_list_docked = ::std::option::Option::None;
            self.friends_list_collapsed = ::std::option::Option::None;
            self.friends_list_group_chats_height = ::std::option::Option::None;
            self.friends_list_visible = ::std::option::Option::None;
            self.chat_popups_opened = ::std::option::Option::None;
            self.group_chat_tabs_opened = ::std::option::Option::None;
            self.friend_chat_tabs_opened = ::std::option::Option::None;
            self.chat_window_width = ::std::option::Option::None;
            self.chat_window_height = ::std::option::Option::None;
            self.category_collapse.clear();
            self.group_chat_left_col_collapsed = ::std::option::Option::None;
            self.group_chat_right_col_collapsed = ::std::option::Option::None;
            self.in_one_on_one_voice_chat = ::std::option::Option::None;
            self.in_group_voice_chat = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UIState {
            static instance: UIState = UIState {
                friends_list_height: ::std::option::Option::None,
                friends_list_width: ::std::option::Option::None,
                friends_list_docked: ::std::option::Option::None,
                friends_list_collapsed: ::std::option::Option::None,
                friends_list_group_chats_height: ::std::option::Option::None,
                friends_list_visible: ::std::option::Option::None,
                chat_popups_opened: ::std::option::Option::None,
                group_chat_tabs_opened: ::std::option::Option::None,
                friend_chat_tabs_opened: ::std::option::Option::None,
                chat_window_width: ::std::option::Option::None,
                chat_window_height: ::std::option::Option::None,
                category_collapse: ::protobuf::MessageField::none(),
                group_chat_left_col_collapsed: ::std::option::Option::None,
                group_chat_right_col_collapsed: ::std::option::Option::None,
                in_one_on_one_voice_chat: ::std::option::Option::None,
                in_group_voice_chat: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for UIState {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CChatUsability_ClientUsabilityMetrics_Notification.UIState").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for UIState {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for UIState {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `UIState`
    pub mod uistate {
        // @@protoc_insertion_point(message:CChatUsability_ClientUsabilityMetrics_Notification.UIState.CategoryCollapseState)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct CategoryCollapseState {
            // message fields
            // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.CategoryCollapseState.in_game_collapsed)
            pub in_game_collapsed: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.CategoryCollapseState.online_collapsed)
            pub online_collapsed: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.CategoryCollapseState.offline_collapsed)
            pub offline_collapsed: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.CategoryCollapseState.game_groups_collapsed)
            pub game_groups_collapsed: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.CategoryCollapseState.categories_collapsed)
            pub categories_collapsed: ::std::option::Option<i32>,
            // special fields
            // @@protoc_insertion_point(special_field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.CategoryCollapseState.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a CategoryCollapseState {
            fn default() -> &'a CategoryCollapseState {
                <CategoryCollapseState as ::protobuf::Message>::default_instance()
            }
        }

        impl CategoryCollapseState {
            pub fn new() -> CategoryCollapseState {
                ::std::default::Default::default()
            }

            // optional bool in_game_collapsed = 1;

            pub fn in_game_collapsed(&self) -> bool {
                self.in_game_collapsed.unwrap_or(false)
            }

            pub fn clear_in_game_collapsed(&mut self) {
                self.in_game_collapsed = ::std::option::Option::None;
            }

            pub fn has_in_game_collapsed(&self) -> bool {
                self.in_game_collapsed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_in_game_collapsed(&mut self, v: bool) {
                self.in_game_collapsed = ::std::option::Option::Some(v);
            }

            // optional bool online_collapsed = 2;

            pub fn online_collapsed(&self) -> bool {
                self.online_collapsed.unwrap_or(false)
            }

            pub fn clear_online_collapsed(&mut self) {
                self.online_collapsed = ::std::option::Option::None;
            }

            pub fn has_online_collapsed(&self) -> bool {
                self.online_collapsed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_online_collapsed(&mut self, v: bool) {
                self.online_collapsed = ::std::option::Option::Some(v);
            }

            // optional bool offline_collapsed = 3;

            pub fn offline_collapsed(&self) -> bool {
                self.offline_collapsed.unwrap_or(false)
            }

            pub fn clear_offline_collapsed(&mut self) {
                self.offline_collapsed = ::std::option::Option::None;
            }

            pub fn has_offline_collapsed(&self) -> bool {
                self.offline_collapsed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_offline_collapsed(&mut self, v: bool) {
                self.offline_collapsed = ::std::option::Option::Some(v);
            }

            // optional int32 game_groups_collapsed = 4;

            pub fn game_groups_collapsed(&self) -> i32 {
                self.game_groups_collapsed.unwrap_or(0)
            }

            pub fn clear_game_groups_collapsed(&mut self) {
                self.game_groups_collapsed = ::std::option::Option::None;
            }

            pub fn has_game_groups_collapsed(&self) -> bool {
                self.game_groups_collapsed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_game_groups_collapsed(&mut self, v: i32) {
                self.game_groups_collapsed = ::std::option::Option::Some(v);
            }

            // optional int32 categories_collapsed = 5;

            pub fn categories_collapsed(&self) -> i32 {
                self.categories_collapsed.unwrap_or(0)
            }

            pub fn clear_categories_collapsed(&mut self) {
                self.categories_collapsed = ::std::option::Option::None;
            }

            pub fn has_categories_collapsed(&self) -> bool {
                self.categories_collapsed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_categories_collapsed(&mut self, v: i32) {
                self.categories_collapsed = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "in_game_collapsed",
                    |m: &CategoryCollapseState| { &m.in_game_collapsed },
                    |m: &mut CategoryCollapseState| { &mut m.in_game_collapsed },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "online_collapsed",
                    |m: &CategoryCollapseState| { &m.online_collapsed },
                    |m: &mut CategoryCollapseState| { &mut m.online_collapsed },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "offline_collapsed",
                    |m: &CategoryCollapseState| { &m.offline_collapsed },
                    |m: &mut CategoryCollapseState| { &mut m.offline_collapsed },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "game_groups_collapsed",
                    |m: &CategoryCollapseState| { &m.game_groups_collapsed },
                    |m: &mut CategoryCollapseState| { &mut m.game_groups_collapsed },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "categories_collapsed",
                    |m: &CategoryCollapseState| { &m.categories_collapsed },
                    |m: &mut CategoryCollapseState| { &mut m.categories_collapsed },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CategoryCollapseState>(
                    "CChatUsability_ClientUsabilityMetrics_Notification.UIState.CategoryCollapseState",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for CategoryCollapseState {
            const NAME: &'static str = "CategoryCollapseState";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.in_game_collapsed = ::std::option::Option::Some(is.read_bool()?);
                        },
                        16 => {
                            self.online_collapsed = ::std::option::Option::Some(is.read_bool()?);
                        },
                        24 => {
                            self.offline_collapsed = ::std::option::Option::Some(is.read_bool()?);
                        },
                        32 => {
                            self.game_groups_collapsed = ::std::option::Option::Some(is.read_int32()?);
                        },
                        40 => {
                            self.categories_collapsed = ::std::option::Option::Some(is.read_int32()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.in_game_collapsed {
                    my_size += 1 + 1;
                }
                if let Some(v) = self.online_collapsed {
                    my_size += 1 + 1;
                }
                if let Some(v) = self.offline_collapsed {
                    my_size += 1 + 1;
                }
                if let Some(v) = self.game_groups_collapsed {
                    my_size += ::protobuf::rt::int32_size(4, v);
                }
                if let Some(v) = self.categories_collapsed {
                    my_size += ::protobuf::rt::int32_size(5, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.in_game_collapsed {
                    os.write_bool(1, v)?;
                }
                if let Some(v) = self.online_collapsed {
                    os.write_bool(2, v)?;
                }
                if let Some(v) = self.offline_collapsed {
                    os.write_bool(3, v)?;
                }
                if let Some(v) = self.game_groups_collapsed {
                    os.write_int32(4, v)?;
                }
                if let Some(v) = self.categories_collapsed {
                    os.write_int32(5, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> CategoryCollapseState {
                CategoryCollapseState::new()
            }

            fn clear(&mut self) {
                self.in_game_collapsed = ::std::option::Option::None;
                self.online_collapsed = ::std::option::Option::None;
                self.offline_collapsed = ::std::option::Option::None;
                self.game_groups_collapsed = ::std::option::Option::None;
                self.categories_collapsed = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static CategoryCollapseState {
                static instance: CategoryCollapseState = CategoryCollapseState {
                    in_game_collapsed: ::std::option::Option::None,
                    online_collapsed: ::std::option::Option::None,
                    offline_collapsed: ::std::option::Option::None,
                    game_groups_collapsed: ::std::option::Option::None,
                    categories_collapsed: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for CategoryCollapseState {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CChatUsability_ClientUsabilityMetrics_Notification.UIState.CategoryCollapseState").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for CategoryCollapseState {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for CategoryCollapseState {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:CChatUsability_ClientUsabilityMetrics_Notification.Metrics)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Metrics {
        // message fields
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Metrics.friends_count)
        pub friends_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Metrics.friends_category_count)
        pub friends_category_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Metrics.friends_categorized_count)
        pub friends_categorized_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Metrics.friends_online_count)
        pub friends_online_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Metrics.friends_in_game_count)
        pub friends_in_game_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Metrics.friends_in_game_singleton_count)
        pub friends_in_game_singleton_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Metrics.game_group_count)
        pub game_group_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Metrics.friends_favorite_count)
        pub friends_favorite_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Metrics.group_chat_count)
        pub group_chat_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Metrics.group_chat_favorite_count)
        pub group_chat_favorite_count: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CChatUsability_ClientUsabilityMetrics_Notification.Metrics.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Metrics {
        fn default() -> &'a Metrics {
            <Metrics as ::protobuf::Message>::default_instance()
        }
    }

    impl Metrics {
        pub fn new() -> Metrics {
            ::std::default::Default::default()
        }

        // optional int32 friends_count = 1;

        pub fn friends_count(&self) -> i32 {
            self.friends_count.unwrap_or(0)
        }

        pub fn clear_friends_count(&mut self) {
            self.friends_count = ::std::option::Option::None;
        }

        pub fn has_friends_count(&self) -> bool {
            self.friends_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friends_count(&mut self, v: i32) {
            self.friends_count = ::std::option::Option::Some(v);
        }

        // optional int32 friends_category_count = 2;

        pub fn friends_category_count(&self) -> i32 {
            self.friends_category_count.unwrap_or(0)
        }

        pub fn clear_friends_category_count(&mut self) {
            self.friends_category_count = ::std::option::Option::None;
        }

        pub fn has_friends_category_count(&self) -> bool {
            self.friends_category_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friends_category_count(&mut self, v: i32) {
            self.friends_category_count = ::std::option::Option::Some(v);
        }

        // optional int32 friends_categorized_count = 3;

        pub fn friends_categorized_count(&self) -> i32 {
            self.friends_categorized_count.unwrap_or(0)
        }

        pub fn clear_friends_categorized_count(&mut self) {
            self.friends_categorized_count = ::std::option::Option::None;
        }

        pub fn has_friends_categorized_count(&self) -> bool {
            self.friends_categorized_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friends_categorized_count(&mut self, v: i32) {
            self.friends_categorized_count = ::std::option::Option::Some(v);
        }

        // optional int32 friends_online_count = 4;

        pub fn friends_online_count(&self) -> i32 {
            self.friends_online_count.unwrap_or(0)
        }

        pub fn clear_friends_online_count(&mut self) {
            self.friends_online_count = ::std::option::Option::None;
        }

        pub fn has_friends_online_count(&self) -> bool {
            self.friends_online_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friends_online_count(&mut self, v: i32) {
            self.friends_online_count = ::std::option::Option::Some(v);
        }

        // optional int32 friends_in_game_count = 5;

        pub fn friends_in_game_count(&self) -> i32 {
            self.friends_in_game_count.unwrap_or(0)
        }

        pub fn clear_friends_in_game_count(&mut self) {
            self.friends_in_game_count = ::std::option::Option::None;
        }

        pub fn has_friends_in_game_count(&self) -> bool {
            self.friends_in_game_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friends_in_game_count(&mut self, v: i32) {
            self.friends_in_game_count = ::std::option::Option::Some(v);
        }

        // optional int32 friends_in_game_singleton_count = 6;

        pub fn friends_in_game_singleton_count(&self) -> i32 {
            self.friends_in_game_singleton_count.unwrap_or(0)
        }

        pub fn clear_friends_in_game_singleton_count(&mut self) {
            self.friends_in_game_singleton_count = ::std::option::Option::None;
        }

        pub fn has_friends_in_game_singleton_count(&self) -> bool {
            self.friends_in_game_singleton_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friends_in_game_singleton_count(&mut self, v: i32) {
            self.friends_in_game_singleton_count = ::std::option::Option::Some(v);
        }

        // optional int32 game_group_count = 7;

        pub fn game_group_count(&self) -> i32 {
            self.game_group_count.unwrap_or(0)
        }

        pub fn clear_game_group_count(&mut self) {
            self.game_group_count = ::std::option::Option::None;
        }

        pub fn has_game_group_count(&self) -> bool {
            self.game_group_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_group_count(&mut self, v: i32) {
            self.game_group_count = ::std::option::Option::Some(v);
        }

        // optional int32 friends_favorite_count = 8;

        pub fn friends_favorite_count(&self) -> i32 {
            self.friends_favorite_count.unwrap_or(0)
        }

        pub fn clear_friends_favorite_count(&mut self) {
            self.friends_favorite_count = ::std::option::Option::None;
        }

        pub fn has_friends_favorite_count(&self) -> bool {
            self.friends_favorite_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friends_favorite_count(&mut self, v: i32) {
            self.friends_favorite_count = ::std::option::Option::Some(v);
        }

        // optional int32 group_chat_count = 9;

        pub fn group_chat_count(&self) -> i32 {
            self.group_chat_count.unwrap_or(0)
        }

        pub fn clear_group_chat_count(&mut self) {
            self.group_chat_count = ::std::option::Option::None;
        }

        pub fn has_group_chat_count(&self) -> bool {
            self.group_chat_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_group_chat_count(&mut self, v: i32) {
            self.group_chat_count = ::std::option::Option::Some(v);
        }

        // optional int32 group_chat_favorite_count = 10;

        pub fn group_chat_favorite_count(&self) -> i32 {
            self.group_chat_favorite_count.unwrap_or(0)
        }

        pub fn clear_group_chat_favorite_count(&mut self) {
            self.group_chat_favorite_count = ::std::option::Option::None;
        }

        pub fn has_group_chat_favorite_count(&self) -> bool {
            self.group_chat_favorite_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_group_chat_favorite_count(&mut self, v: i32) {
            self.group_chat_favorite_count = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(10);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "friends_count",
                |m: &Metrics| { &m.friends_count },
                |m: &mut Metrics| { &mut m.friends_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "friends_category_count",
                |m: &Metrics| { &m.friends_category_count },
                |m: &mut Metrics| { &mut m.friends_category_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "friends_categorized_count",
                |m: &Metrics| { &m.friends_categorized_count },
                |m: &mut Metrics| { &mut m.friends_categorized_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "friends_online_count",
                |m: &Metrics| { &m.friends_online_count },
                |m: &mut Metrics| { &mut m.friends_online_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "friends_in_game_count",
                |m: &Metrics| { &m.friends_in_game_count },
                |m: &mut Metrics| { &mut m.friends_in_game_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "friends_in_game_singleton_count",
                |m: &Metrics| { &m.friends_in_game_singleton_count },
                |m: &mut Metrics| { &mut m.friends_in_game_singleton_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_group_count",
                |m: &Metrics| { &m.game_group_count },
                |m: &mut Metrics| { &mut m.game_group_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "friends_favorite_count",
                |m: &Metrics| { &m.friends_favorite_count },
                |m: &mut Metrics| { &mut m.friends_favorite_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "group_chat_count",
                |m: &Metrics| { &m.group_chat_count },
                |m: &mut Metrics| { &mut m.group_chat_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "group_chat_favorite_count",
                |m: &Metrics| { &m.group_chat_favorite_count },
                |m: &mut Metrics| { &mut m.group_chat_favorite_count },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Metrics>(
                "CChatUsability_ClientUsabilityMetrics_Notification.Metrics",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Metrics {
        const NAME: &'static str = "Metrics";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.friends_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.friends_category_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.friends_categorized_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.friends_online_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.friends_in_game_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    48 => {
                        self.friends_in_game_singleton_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    56 => {
                        self.game_group_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    64 => {
                        self.friends_favorite_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    72 => {
                        self.group_chat_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    80 => {
                        self.group_chat_favorite_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.friends_count {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.friends_category_count {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.friends_categorized_count {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.friends_online_count {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.friends_in_game_count {
                my_size += ::protobuf::rt::int32_size(5, v);
            }
            if let Some(v) = self.friends_in_game_singleton_count {
                my_size += ::protobuf::rt::int32_size(6, v);
            }
            if let Some(v) = self.game_group_count {
                my_size += ::protobuf::rt::int32_size(7, v);
            }
            if let Some(v) = self.friends_favorite_count {
                my_size += ::protobuf::rt::int32_size(8, v);
            }
            if let Some(v) = self.group_chat_count {
                my_size += ::protobuf::rt::int32_size(9, v);
            }
            if let Some(v) = self.group_chat_favorite_count {
                my_size += ::protobuf::rt::int32_size(10, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.friends_count {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.friends_category_count {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.friends_categorized_count {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.friends_online_count {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.friends_in_game_count {
                os.write_int32(5, v)?;
            }
            if let Some(v) = self.friends_in_game_singleton_count {
                os.write_int32(6, v)?;
            }
            if let Some(v) = self.game_group_count {
                os.write_int32(7, v)?;
            }
            if let Some(v) = self.friends_favorite_count {
                os.write_int32(8, v)?;
            }
            if let Some(v) = self.group_chat_count {
                os.write_int32(9, v)?;
            }
            if let Some(v) = self.group_chat_favorite_count {
                os.write_int32(10, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Metrics {
            Metrics::new()
        }

        fn clear(&mut self) {
            self.friends_count = ::std::option::Option::None;
            self.friends_category_count = ::std::option::Option::None;
            self.friends_categorized_count = ::std::option::Option::None;
            self.friends_online_count = ::std::option::Option::None;
            self.friends_in_game_count = ::std::option::Option::None;
            self.friends_in_game_singleton_count = ::std::option::Option::None;
            self.game_group_count = ::std::option::Option::None;
            self.friends_favorite_count = ::std::option::Option::None;
            self.group_chat_count = ::std::option::Option::None;
            self.group_chat_favorite_count = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Metrics {
            static instance: Metrics = Metrics {
                friends_count: ::std::option::Option::None,
                friends_category_count: ::std::option::Option::None,
                friends_categorized_count: ::std::option::Option::None,
                friends_online_count: ::std::option::Option::None,
                friends_in_game_count: ::std::option::Option::None,
                friends_in_game_singleton_count: ::std::option::Option::None,
                game_group_count: ::std::option::Option::None,
                friends_favorite_count: ::std::option::Option::None,
                group_chat_count: ::std::option::Option::None,
                group_chat_favorite_count: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Metrics {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CChatUsability_ClientUsabilityMetrics_Notification.Metrics").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Metrics {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Metrics {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CChatUsability_RequestClientUsabilityMetrics_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatUsability_RequestClientUsabilityMetrics_Notification {
    // message fields
    // @@protoc_insertion_point(field:CChatUsability_RequestClientUsabilityMetrics_Notification.metrics_run_id)
    pub metrics_run_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatUsability_RequestClientUsabilityMetrics_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatUsability_RequestClientUsabilityMetrics_Notification {
    fn default() -> &'a CChatUsability_RequestClientUsabilityMetrics_Notification {
        <CChatUsability_RequestClientUsabilityMetrics_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatUsability_RequestClientUsabilityMetrics_Notification {
    pub fn new() -> CChatUsability_RequestClientUsabilityMetrics_Notification {
        ::std::default::Default::default()
    }

    // optional uint32 metrics_run_id = 1;

    pub fn metrics_run_id(&self) -> u32 {
        self.metrics_run_id.unwrap_or(0)
    }

    pub fn clear_metrics_run_id(&mut self) {
        self.metrics_run_id = ::std::option::Option::None;
    }

    pub fn has_metrics_run_id(&self) -> bool {
        self.metrics_run_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metrics_run_id(&mut self, v: u32) {
        self.metrics_run_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "metrics_run_id",
            |m: &CChatUsability_RequestClientUsabilityMetrics_Notification| { &m.metrics_run_id },
            |m: &mut CChatUsability_RequestClientUsabilityMetrics_Notification| { &mut m.metrics_run_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CChatUsability_RequestClientUsabilityMetrics_Notification>(
            "CChatUsability_RequestClientUsabilityMetrics_Notification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CChatUsability_RequestClientUsabilityMetrics_Notification {
    const NAME: &'static str = "CChatUsability_RequestClientUsabilityMetrics_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.metrics_run_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metrics_run_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metrics_run_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatUsability_RequestClientUsabilityMetrics_Notification {
        CChatUsability_RequestClientUsabilityMetrics_Notification::new()
    }

    fn clear(&mut self) {
        self.metrics_run_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatUsability_RequestClientUsabilityMetrics_Notification {
        static instance: CChatUsability_RequestClientUsabilityMetrics_Notification = CChatUsability_RequestClientUsabilityMetrics_Notification {
            metrics_run_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CChatUsability_RequestClientUsabilityMetrics_Notification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatUsability_RequestClientUsabilityMetrics_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatUsability_RequestClientUsabilityMetrics_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatUsability_RequestClientUsabilityMetrics_Notification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EChatRoomJoinState)
pub enum EChatRoomJoinState {
    // @@protoc_insertion_point(enum_value:EChatRoomJoinState.k_EChatRoomJoinState_Default)
    k_EChatRoomJoinState_Default = 0,
    // @@protoc_insertion_point(enum_value:EChatRoomJoinState.k_EChatRoomJoinState_None)
    k_EChatRoomJoinState_None = 1,
    // @@protoc_insertion_point(enum_value:EChatRoomJoinState.k_EChatRoomJoinState_Joined)
    k_EChatRoomJoinState_Joined = 2,
    // @@protoc_insertion_point(enum_value:EChatRoomJoinState.k_EChatRoomJoinState_TestInvalid)
    k_EChatRoomJoinState_TestInvalid = 99,
}

impl ::protobuf::Enum for EChatRoomJoinState {
    const NAME: &'static str = "EChatRoomJoinState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EChatRoomJoinState> {
        match value {
            0 => ::std::option::Option::Some(EChatRoomJoinState::k_EChatRoomJoinState_Default),
            1 => ::std::option::Option::Some(EChatRoomJoinState::k_EChatRoomJoinState_None),
            2 => ::std::option::Option::Some(EChatRoomJoinState::k_EChatRoomJoinState_Joined),
            99 => ::std::option::Option::Some(EChatRoomJoinState::k_EChatRoomJoinState_TestInvalid),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EChatRoomJoinState> {
        match str {
            "k_EChatRoomJoinState_Default" => ::std::option::Option::Some(EChatRoomJoinState::k_EChatRoomJoinState_Default),
            "k_EChatRoomJoinState_None" => ::std::option::Option::Some(EChatRoomJoinState::k_EChatRoomJoinState_None),
            "k_EChatRoomJoinState_Joined" => ::std::option::Option::Some(EChatRoomJoinState::k_EChatRoomJoinState_Joined),
            "k_EChatRoomJoinState_TestInvalid" => ::std::option::Option::Some(EChatRoomJoinState::k_EChatRoomJoinState_TestInvalid),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EChatRoomJoinState] = &[
        EChatRoomJoinState::k_EChatRoomJoinState_Default,
        EChatRoomJoinState::k_EChatRoomJoinState_None,
        EChatRoomJoinState::k_EChatRoomJoinState_Joined,
        EChatRoomJoinState::k_EChatRoomJoinState_TestInvalid,
    ];
}

impl ::protobuf::EnumFull for EChatRoomJoinState {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EChatRoomJoinState").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EChatRoomJoinState::k_EChatRoomJoinState_Default => 0,
            EChatRoomJoinState::k_EChatRoomJoinState_None => 1,
            EChatRoomJoinState::k_EChatRoomJoinState_Joined => 2,
            EChatRoomJoinState::k_EChatRoomJoinState_TestInvalid => 3,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EChatRoomJoinState {
    fn default() -> Self {
        EChatRoomJoinState::k_EChatRoomJoinState_Default
    }
}

impl EChatRoomJoinState {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EChatRoomJoinState>("EChatRoomJoinState")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EChatRoomGroupRank)
pub enum EChatRoomGroupRank {
    // @@protoc_insertion_point(enum_value:EChatRoomGroupRank.k_EChatRoomGroupRank_Default)
    k_EChatRoomGroupRank_Default = 0,
    // @@protoc_insertion_point(enum_value:EChatRoomGroupRank.k_EChatRoomGroupRank_Viewer)
    k_EChatRoomGroupRank_Viewer = 10,
    // @@protoc_insertion_point(enum_value:EChatRoomGroupRank.k_EChatRoomGroupRank_Guest)
    k_EChatRoomGroupRank_Guest = 15,
    // @@protoc_insertion_point(enum_value:EChatRoomGroupRank.k_EChatRoomGroupRank_Member)
    k_EChatRoomGroupRank_Member = 20,
    // @@protoc_insertion_point(enum_value:EChatRoomGroupRank.k_EChatRoomGroupRank_Moderator)
    k_EChatRoomGroupRank_Moderator = 30,
    // @@protoc_insertion_point(enum_value:EChatRoomGroupRank.k_EChatRoomGroupRank_Officer)
    k_EChatRoomGroupRank_Officer = 40,
    // @@protoc_insertion_point(enum_value:EChatRoomGroupRank.k_EChatRoomGroupRank_Owner)
    k_EChatRoomGroupRank_Owner = 50,
    // @@protoc_insertion_point(enum_value:EChatRoomGroupRank.k_EChatRoomGroupRank_TestInvalid)
    k_EChatRoomGroupRank_TestInvalid = 99,
}

impl ::protobuf::Enum for EChatRoomGroupRank {
    const NAME: &'static str = "EChatRoomGroupRank";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EChatRoomGroupRank> {
        match value {
            0 => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Default),
            10 => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Viewer),
            15 => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Guest),
            20 => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Member),
            30 => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Moderator),
            40 => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Officer),
            50 => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Owner),
            99 => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_TestInvalid),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EChatRoomGroupRank> {
        match str {
            "k_EChatRoomGroupRank_Default" => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Default),
            "k_EChatRoomGroupRank_Viewer" => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Viewer),
            "k_EChatRoomGroupRank_Guest" => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Guest),
            "k_EChatRoomGroupRank_Member" => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Member),
            "k_EChatRoomGroupRank_Moderator" => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Moderator),
            "k_EChatRoomGroupRank_Officer" => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Officer),
            "k_EChatRoomGroupRank_Owner" => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Owner),
            "k_EChatRoomGroupRank_TestInvalid" => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_TestInvalid),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EChatRoomGroupRank] = &[
        EChatRoomGroupRank::k_EChatRoomGroupRank_Default,
        EChatRoomGroupRank::k_EChatRoomGroupRank_Viewer,
        EChatRoomGroupRank::k_EChatRoomGroupRank_Guest,
        EChatRoomGroupRank::k_EChatRoomGroupRank_Member,
        EChatRoomGroupRank::k_EChatRoomGroupRank_Moderator,
        EChatRoomGroupRank::k_EChatRoomGroupRank_Officer,
        EChatRoomGroupRank::k_EChatRoomGroupRank_Owner,
        EChatRoomGroupRank::k_EChatRoomGroupRank_TestInvalid,
    ];
}

impl ::protobuf::EnumFull for EChatRoomGroupRank {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EChatRoomGroupRank").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EChatRoomGroupRank::k_EChatRoomGroupRank_Default => 0,
            EChatRoomGroupRank::k_EChatRoomGroupRank_Viewer => 1,
            EChatRoomGroupRank::k_EChatRoomGroupRank_Guest => 2,
            EChatRoomGroupRank::k_EChatRoomGroupRank_Member => 3,
            EChatRoomGroupRank::k_EChatRoomGroupRank_Moderator => 4,
            EChatRoomGroupRank::k_EChatRoomGroupRank_Officer => 5,
            EChatRoomGroupRank::k_EChatRoomGroupRank_Owner => 6,
            EChatRoomGroupRank::k_EChatRoomGroupRank_TestInvalid => 7,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EChatRoomGroupRank {
    fn default() -> Self {
        EChatRoomGroupRank::k_EChatRoomGroupRank_Default
    }
}

impl EChatRoomGroupRank {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EChatRoomGroupRank>("EChatRoomGroupRank")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EChatRoomNotificationLevel)
pub enum EChatRoomNotificationLevel {
    // @@protoc_insertion_point(enum_value:EChatRoomNotificationLevel.k_EChatroomNotificationLevel_Invalid)
    k_EChatroomNotificationLevel_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EChatRoomNotificationLevel.k_EChatroomNotificationLevel_None)
    k_EChatroomNotificationLevel_None = 1,
    // @@protoc_insertion_point(enum_value:EChatRoomNotificationLevel.k_EChatroomNotificationLevel_MentionMe)
    k_EChatroomNotificationLevel_MentionMe = 2,
    // @@protoc_insertion_point(enum_value:EChatRoomNotificationLevel.k_EChatroomNotificationLevel_MentionAll)
    k_EChatroomNotificationLevel_MentionAll = 3,
    // @@protoc_insertion_point(enum_value:EChatRoomNotificationLevel.k_EChatroomNotificationLevel_AllMessages)
    k_EChatroomNotificationLevel_AllMessages = 4,
}

impl ::protobuf::Enum for EChatRoomNotificationLevel {
    const NAME: &'static str = "EChatRoomNotificationLevel";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EChatRoomNotificationLevel> {
        match value {
            0 => ::std::option::Option::Some(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid),
            1 => ::std::option::Option::Some(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_None),
            2 => ::std::option::Option::Some(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_MentionMe),
            3 => ::std::option::Option::Some(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_MentionAll),
            4 => ::std::option::Option::Some(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_AllMessages),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EChatRoomNotificationLevel> {
        match str {
            "k_EChatroomNotificationLevel_Invalid" => ::std::option::Option::Some(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid),
            "k_EChatroomNotificationLevel_None" => ::std::option::Option::Some(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_None),
            "k_EChatroomNotificationLevel_MentionMe" => ::std::option::Option::Some(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_MentionMe),
            "k_EChatroomNotificationLevel_MentionAll" => ::std::option::Option::Some(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_MentionAll),
            "k_EChatroomNotificationLevel_AllMessages" => ::std::option::Option::Some(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_AllMessages),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EChatRoomNotificationLevel] = &[
        EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid,
        EChatRoomNotificationLevel::k_EChatroomNotificationLevel_None,
        EChatRoomNotificationLevel::k_EChatroomNotificationLevel_MentionMe,
        EChatRoomNotificationLevel::k_EChatroomNotificationLevel_MentionAll,
        EChatRoomNotificationLevel::k_EChatroomNotificationLevel_AllMessages,
    ];
}

impl ::protobuf::EnumFull for EChatRoomNotificationLevel {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EChatRoomNotificationLevel").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EChatRoomNotificationLevel {
    fn default() -> Self {
        EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid
    }
}

impl EChatRoomNotificationLevel {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EChatRoomNotificationLevel>("EChatRoomNotificationLevel")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EChatRoomServerMessage)
pub enum EChatRoomServerMessage {
    // @@protoc_insertion_point(enum_value:EChatRoomServerMessage.k_EChatRoomServerMsg_Invalid)
    k_EChatRoomServerMsg_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EChatRoomServerMessage.k_EChatRoomServerMsg_RenameChatRoom)
    k_EChatRoomServerMsg_RenameChatRoom = 1,
    // @@protoc_insertion_point(enum_value:EChatRoomServerMessage.k_EChatRoomServerMsg_Joined)
    k_EChatRoomServerMsg_Joined = 2,
    // @@protoc_insertion_point(enum_value:EChatRoomServerMessage.k_EChatRoomServerMsg_Parted)
    k_EChatRoomServerMsg_Parted = 3,
    // @@protoc_insertion_point(enum_value:EChatRoomServerMessage.k_EChatRoomServerMsg_Kicked)
    k_EChatRoomServerMsg_Kicked = 4,
    // @@protoc_insertion_point(enum_value:EChatRoomServerMessage.k_EChatRoomServerMsg_Invited)
    k_EChatRoomServerMsg_Invited = 5,
    // @@protoc_insertion_point(enum_value:EChatRoomServerMessage.k_EChatRoomServerMsg_InviteDismissed)
    k_EChatRoomServerMsg_InviteDismissed = 8,
    // @@protoc_insertion_point(enum_value:EChatRoomServerMessage.k_EChatRoomServerMsg_ChatRoomTaglineChanged)
    k_EChatRoomServerMsg_ChatRoomTaglineChanged = 9,
    // @@protoc_insertion_point(enum_value:EChatRoomServerMessage.k_EChatRoomServerMsg_ChatRoomAvatarChanged)
    k_EChatRoomServerMsg_ChatRoomAvatarChanged = 10,
    // @@protoc_insertion_point(enum_value:EChatRoomServerMessage.k_EChatRoomServerMsg_AppCustom)
    k_EChatRoomServerMsg_AppCustom = 11,
}

impl ::protobuf::Enum for EChatRoomServerMessage {
    const NAME: &'static str = "EChatRoomServerMessage";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EChatRoomServerMessage> {
        match value {
            0 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_Invalid),
            1 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_RenameChatRoom),
            2 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_Joined),
            3 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_Parted),
            4 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_Kicked),
            5 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_Invited),
            8 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_InviteDismissed),
            9 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_ChatRoomTaglineChanged),
            10 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_ChatRoomAvatarChanged),
            11 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_AppCustom),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EChatRoomServerMessage> {
        match str {
            "k_EChatRoomServerMsg_Invalid" => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_Invalid),
            "k_EChatRoomServerMsg_RenameChatRoom" => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_RenameChatRoom),
            "k_EChatRoomServerMsg_Joined" => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_Joined),
            "k_EChatRoomServerMsg_Parted" => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_Parted),
            "k_EChatRoomServerMsg_Kicked" => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_Kicked),
            "k_EChatRoomServerMsg_Invited" => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_Invited),
            "k_EChatRoomServerMsg_InviteDismissed" => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_InviteDismissed),
            "k_EChatRoomServerMsg_ChatRoomTaglineChanged" => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_ChatRoomTaglineChanged),
            "k_EChatRoomServerMsg_ChatRoomAvatarChanged" => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_ChatRoomAvatarChanged),
            "k_EChatRoomServerMsg_AppCustom" => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_AppCustom),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EChatRoomServerMessage] = &[
        EChatRoomServerMessage::k_EChatRoomServerMsg_Invalid,
        EChatRoomServerMessage::k_EChatRoomServerMsg_RenameChatRoom,
        EChatRoomServerMessage::k_EChatRoomServerMsg_Joined,
        EChatRoomServerMessage::k_EChatRoomServerMsg_Parted,
        EChatRoomServerMessage::k_EChatRoomServerMsg_Kicked,
        EChatRoomServerMessage::k_EChatRoomServerMsg_Invited,
        EChatRoomServerMessage::k_EChatRoomServerMsg_InviteDismissed,
        EChatRoomServerMessage::k_EChatRoomServerMsg_ChatRoomTaglineChanged,
        EChatRoomServerMessage::k_EChatRoomServerMsg_ChatRoomAvatarChanged,
        EChatRoomServerMessage::k_EChatRoomServerMsg_AppCustom,
    ];
}

impl ::protobuf::EnumFull for EChatRoomServerMessage {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EChatRoomServerMessage").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EChatRoomServerMessage::k_EChatRoomServerMsg_Invalid => 0,
            EChatRoomServerMessage::k_EChatRoomServerMsg_RenameChatRoom => 1,
            EChatRoomServerMessage::k_EChatRoomServerMsg_Joined => 2,
            EChatRoomServerMessage::k_EChatRoomServerMsg_Parted => 3,
            EChatRoomServerMessage::k_EChatRoomServerMsg_Kicked => 4,
            EChatRoomServerMessage::k_EChatRoomServerMsg_Invited => 5,
            EChatRoomServerMessage::k_EChatRoomServerMsg_InviteDismissed => 6,
            EChatRoomServerMessage::k_EChatRoomServerMsg_ChatRoomTaglineChanged => 7,
            EChatRoomServerMessage::k_EChatRoomServerMsg_ChatRoomAvatarChanged => 8,
            EChatRoomServerMessage::k_EChatRoomServerMsg_AppCustom => 9,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EChatRoomServerMessage {
    fn default() -> Self {
        EChatRoomServerMessage::k_EChatRoomServerMsg_Invalid
    }
}

impl EChatRoomServerMessage {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EChatRoomServerMessage>("EChatRoomServerMessage")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EChatRoomMessageReactionType)
pub enum EChatRoomMessageReactionType {
    // @@protoc_insertion_point(enum_value:EChatRoomMessageReactionType.k_EChatRoomMessageReactionType_Invalid)
    k_EChatRoomMessageReactionType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EChatRoomMessageReactionType.k_EChatRoomMessageReactionType_Emoticon)
    k_EChatRoomMessageReactionType_Emoticon = 1,
}

impl ::protobuf::Enum for EChatRoomMessageReactionType {
    const NAME: &'static str = "EChatRoomMessageReactionType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EChatRoomMessageReactionType> {
        match value {
            0 => ::std::option::Option::Some(EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid),
            1 => ::std::option::Option::Some(EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Emoticon),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EChatRoomMessageReactionType> {
        match str {
            "k_EChatRoomMessageReactionType_Invalid" => ::std::option::Option::Some(EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid),
            "k_EChatRoomMessageReactionType_Emoticon" => ::std::option::Option::Some(EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Emoticon),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EChatRoomMessageReactionType] = &[
        EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid,
        EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Emoticon,
    ];
}

impl ::protobuf::EnumFull for EChatRoomMessageReactionType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EChatRoomMessageReactionType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EChatRoomMessageReactionType {
    fn default() -> Self {
        EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid
    }
}

impl EChatRoomMessageReactionType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EChatRoomMessageReactionType>("EChatRoomMessageReactionType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EChatRoomMemberStateChange)
pub enum EChatRoomMemberStateChange {
    // @@protoc_insertion_point(enum_value:EChatRoomMemberStateChange.k_EChatRoomMemberStateChange_Invalid)
    k_EChatRoomMemberStateChange_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EChatRoomMemberStateChange.k_EChatRoomMemberStateChange_Joined)
    k_EChatRoomMemberStateChange_Joined = 1,
    // @@protoc_insertion_point(enum_value:EChatRoomMemberStateChange.k_EChatRoomMemberStateChange_Parted)
    k_EChatRoomMemberStateChange_Parted = 2,
    // @@protoc_insertion_point(enum_value:EChatRoomMemberStateChange.k_EChatRoomMemberStateChange_Kicked)
    k_EChatRoomMemberStateChange_Kicked = 3,
    // @@protoc_insertion_point(enum_value:EChatRoomMemberStateChange.k_EChatRoomMemberStateChange_Invited)
    k_EChatRoomMemberStateChange_Invited = 4,
    // @@protoc_insertion_point(enum_value:EChatRoomMemberStateChange.k_EChatRoomMemberStateChange_RankChanged)
    k_EChatRoomMemberStateChange_RankChanged = 7,
    // @@protoc_insertion_point(enum_value:EChatRoomMemberStateChange.k_EChatRoomMemberStateChange_InviteDismissed)
    k_EChatRoomMemberStateChange_InviteDismissed = 8,
    // @@protoc_insertion_point(enum_value:EChatRoomMemberStateChange.k_EChatRoomMemberStateChange_Muted)
    k_EChatRoomMemberStateChange_Muted = 9,
    // @@protoc_insertion_point(enum_value:EChatRoomMemberStateChange.k_EChatRoomMemberStateChange_Banned)
    k_EChatRoomMemberStateChange_Banned = 10,
    // @@protoc_insertion_point(enum_value:EChatRoomMemberStateChange.k_EChatRoomMemberStateChange_RolesChanged)
    k_EChatRoomMemberStateChange_RolesChanged = 12,
}

impl ::protobuf::Enum for EChatRoomMemberStateChange {
    const NAME: &'static str = "EChatRoomMemberStateChange";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EChatRoomMemberStateChange> {
        match value {
            0 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invalid),
            1 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Joined),
            2 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Parted),
            3 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Kicked),
            4 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invited),
            7 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_RankChanged),
            8 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_InviteDismissed),
            9 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Muted),
            10 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Banned),
            12 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_RolesChanged),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EChatRoomMemberStateChange> {
        match str {
            "k_EChatRoomMemberStateChange_Invalid" => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invalid),
            "k_EChatRoomMemberStateChange_Joined" => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Joined),
            "k_EChatRoomMemberStateChange_Parted" => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Parted),
            "k_EChatRoomMemberStateChange_Kicked" => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Kicked),
            "k_EChatRoomMemberStateChange_Invited" => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invited),
            "k_EChatRoomMemberStateChange_RankChanged" => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_RankChanged),
            "k_EChatRoomMemberStateChange_InviteDismissed" => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_InviteDismissed),
            "k_EChatRoomMemberStateChange_Muted" => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Muted),
            "k_EChatRoomMemberStateChange_Banned" => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Banned),
            "k_EChatRoomMemberStateChange_RolesChanged" => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_RolesChanged),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EChatRoomMemberStateChange] = &[
        EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invalid,
        EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Joined,
        EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Parted,
        EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Kicked,
        EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invited,
        EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_RankChanged,
        EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_InviteDismissed,
        EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Muted,
        EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Banned,
        EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_RolesChanged,
    ];
}

impl ::protobuf::EnumFull for EChatRoomMemberStateChange {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EChatRoomMemberStateChange").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invalid => 0,
            EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Joined => 1,
            EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Parted => 2,
            EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Kicked => 3,
            EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invited => 4,
            EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_RankChanged => 5,
            EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_InviteDismissed => 6,
            EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Muted => 7,
            EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Banned => 8,
            EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_RolesChanged => 9,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EChatRoomMemberStateChange {
    fn default() -> Self {
        EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invalid
    }
}

impl EChatRoomMemberStateChange {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EChatRoomMemberStateChange>("EChatRoomMemberStateChange")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n$steammessages_chat.steamclient.proto\x1a,steammessages_unified_base.s\
    teamclient.proto\x1a(steammessages_clientserver_friends.proto\"*\n(CChat\
    _RequestFriendPersonaStates_Request\"+\n)CChat_RequestFriendPersonaState\
    s_Response\"\xbd\x02\n%CChatRoom_CreateChatRoomGroup_Request\x12'\n\x0fs\
    teamid_partner\x18\x01\x20\x01(\x06R\x0esteamidPartner\x12'\n\x0fsteamid\
    _invited\x18\x02\x20\x01(\x06R\x0esteamidInvited\x12\x12\n\x04name\x18\
    \x03\x20\x01(\tR\x04name\x12)\n\x10steamid_invitees\x18\x04\x20\x03(\x06\
    R\x0fsteamidInvitees\x12@\n\x1cwatching_broadcast_accountid\x18\x06\x20\
    \x01(\rR\x1awatchingBroadcastAccountid\x12A\n\x1dwatching_broadcast_chan\
    nel_id\x18\x07\x20\x01(\x04R\x1awatchingBroadcastChannelId\"R\n\tCChatRo\
    le\x12\x17\n\x07role_id\x18\x01\x20\x01(\x04R\x06roleId\x12\x12\n\x04nam\
    e\x18\x02\x20\x01(\tR\x04name\x12\x18\n\x07ordinal\x18\x03\x20\x01(\rR\
    \x07ordinal\"\x9c\x04\n\x10CChatRoleActions\x12\x17\n\x07role_id\x18\x01\
    \x20\x01(\x04R\x06roleId\x12F\n\x20can_create_rename_delete_channel\x18\
    \x02\x20\x01(\x08R\x1ccanCreateRenameDeleteChannel\x12\x19\n\x08can_kick\
    \x18\x03\x20\x01(\x08R\x07canKick\x12\x17\n\x07can_ban\x18\x04\x20\x01(\
    \x08R\x06canBan\x12\x1d\n\ncan_invite\x18\x05\x20\x01(\x08R\tcanInvite\
    \x12B\n\x1ecan_change_tagline_avatar_name\x18\x06\x20\x01(\x08R\x1acanCh\
    angeTaglineAvatarName\x12\x19\n\x08can_chat\x18\x07\x20\x01(\x08R\x07can\
    Chat\x12(\n\x10can_view_history\x18\x08\x20\x01(\x08R\x0ecanViewHistory\
    \x123\n\x16can_change_group_roles\x18\t\x20\x01(\x08R\x13canChangeGroupR\
    oles\x121\n\x15can_change_user_roles\x18\n\x20\x01(\x08R\x12canChangeUse\
    rRoles\x12&\n\x0fcan_mention_all\x18\x0b\x20\x01(\x08R\rcanMentionAll\
    \x12;\n\x1acan_set_watching_broadcast\x18\x0c\x20\x01(\x08R\x17canSetWat\
    chingBroadcast\"\x90\x01\n\x10CChatPartyBeacon\x12\x15\n\x06app_id\x18\
    \x01\x20\x01(\rR\x05appId\x12#\n\rsteamid_owner\x18\x02\x20\x01(\x06R\
    \x0csteamidOwner\x12\x1b\n\tbeacon_id\x18\x03\x20\x01(\x06R\x08beaconId\
    \x12#\n\rgame_metadata\x18\x04\x20\x01(\tR\x0cgameMetadata\"\xfd\x04\n\
    \x19CChatRoomGroupHeaderState\x12\"\n\rchat_group_id\x18\x01\x20\x01(\
    \x04R\x0bchatGroupId\x12\x1b\n\tchat_name\x18\x02\x20\x01(\tR\x08chatNam\
    e\x12\x16\n\x06clanid\x18\r\x20\x01(\rR\x06clanid\x12'\n\x0faccountid_ow\
    ner\x18\x0e\x20\x01(\rR\x0eaccountidOwner\x12\x14\n\x05appid\x18\x15\x20\
    \x01(\rR\x05appid\x12\x18\n\x07tagline\x18\x0f\x20\x01(\tR\x07tagline\
    \x12\x1d\n\navatar_sha\x18\x10\x20\x01(\x0cR\tavatarSha\x12&\n\x0fdefaul\
    t_role_id\x18\x11\x20\x01(\x04R\rdefaultRoleId\x12\x20\n\x05roles\x18\
    \x12\x20\x03(\x0b2\n.CChatRoleR\x05roles\x124\n\x0crole_actions\x18\x13\
    \x20\x03(\x0b2\x11.CChatRoleActionsR\x0broleActions\x12@\n\x1cwatching_b\
    roadcast_accountid\x18\x14\x20\x01(\rR\x1awatchingBroadcastAccountid\x12\
    6\n\rparty_beacons\x18\x16\x20\x03(\x0b2\x11.CChatPartyBeaconR\x0cpartyB\
    eacons\x12A\n\x1dwatching_broadcast_channel_id\x18\x17\x20\x01(\x04R\x1a\
    watchingBroadcastChannelId\x12,\n\x12active_minigame_id\x18\x18\x20\x01(\
    \x04R\x10activeMinigameId\x12$\n\x0eavatar_ugc_url\x18\x19\x20\x01(\tR\
    \x0cavatarUgcUrl\"\x84\x02\n\x0fCChatRoomMember\x12\x1c\n\taccountid\x18\
    \x01\x20\x01(\rR\taccountid\x12G\n\x05state\x18\x03\x20\x01(\x0e2\x13.EC\
    hatRoomJoinState:\x1ck_EChatRoomJoinState_DefaultR\x05state\x12E\n\x04ra\
    nk\x18\x04\x20\x01(\x0e2\x13.EChatRoomGroupRank:\x1ck_EChatRoomGroupRank\
    _DefaultR\x04rank\x12(\n\x10time_kick_expire\x18\x06\x20\x01(\rR\x0etime\
    KickExpire\x12\x19\n\x08role_ids\x18\x07\x20\x03(\x04R\x07roleIds\"\xb9\
    \x02\n\x0eCChatRoomState\x12\x17\n\x07chat_id\x18\x01\x20\x01(\x04R\x06c\
    hatId\x12\x1b\n\tchat_name\x18\x02\x20\x01(\tR\x08chatName\x12#\n\rvoice\
    _allowed\x18\x03\x20\x01(\x08R\x0cvoiceAllowed\x12(\n\x10members_in_voic\
    e\x18\x04\x20\x03(\rR\x0emembersInVoice\x12*\n\x11time_last_message\x18\
    \x05\x20\x01(\rR\x0ftimeLastMessage\x12\x1d\n\nsort_order\x18\x06\x20\
    \x01(\rR\tsortOrder\x12!\n\x0clast_message\x18\x07\x20\x01(\tR\x0blastMe\
    ssage\x124\n\x16accountid_last_message\x18\x08\x20\x01(\rR\x14accountidL\
    astMessage\"\x82\x02\n\x13CChatRoomGroupState\x12=\n\x0cheader_state\x18\
    \x01\x20\x01(\x0b2\x1a.CChatRoomGroupHeaderStateR\x0bheaderState\x12*\n\
    \x07members\x18\x02\x20\x03(\x0b2\x10.CChatRoomMemberR\x07members\x12&\n\
    \x0fdefault_chat_id\x18\x04\x20\x01(\x04R\rdefaultChatId\x12.\n\nchat_ro\
    oms\x18\x05\x20\x03(\x0b2\x0f.CChatRoomStateR\tchatRooms\x12(\n\x06kicke\
    d\x18\x07\x20\x03(\x0b2\x10.CChatRoomMemberR\x06kicked\"\x87\x04\n\x12CU\
    serChatRoomState\x12\x17\n\x07chat_id\x18\x01\x20\x01(\x04R\x06chatId\
    \x12\x1f\n\x0btime_joined\x18\x02\x20\x01(\rR\ntimeJoined\x12\"\n\rtime_\
    last_ack\x18\x03\x20\x01(\rR\x0btimeLastAck\x12\x7f\n\x1adesktop_notific\
    ation_level\x18\x04\x20\x01(\x0e2\x1b.EChatRoomNotificationLevel:$k_ECha\
    troomNotificationLevel_InvalidR\x18desktopNotificationLevel\x12}\n\x19mo\
    bile_notification_level\x18\x05\x20\x01(\x0e2\x1b.EChatRoomNotificationL\
    evel:$k_EChatroomNotificationLevel_InvalidR\x17mobileNotificationLevel\
    \x12*\n\x11time_last_mention\x18\x06\x20\x01(\rR\x0ftimeLastMention\x12;\
    \n\x16unread_indicator_muted\x18\x07\x20\x01(\x08:\x05falseR\x14unreadIn\
    dicatorMuted\x12*\n\x11time_first_unread\x18\x08\x20\x01(\rR\x0ftimeFirs\
    tUnread\"\x90\x04\n\x17CUserChatRoomGroupState\x12\"\n\rchat_group_id\
    \x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x1f\n\x0btime_joined\x18\x02\
    \x20\x01(\rR\ntimeJoined\x12D\n\x14user_chat_room_state\x18\x03\x20\x03(\
    \x0b2\x13.CUserChatRoomStateR\x11userChatRoomState\x12\x7f\n\x1adesktop_\
    notification_level\x18\x04\x20\x01(\x0e2\x1b.EChatRoomNotificationLevel:\
    $k_EChatroomNotificationLevel_InvalidR\x18desktopNotificationLevel\x12}\
    \n\x19mobile_notification_level\x18\x05\x20\x01(\x0e2\x1b.EChatRoomNotif\
    icationLevel:$k_EChatroomNotificationLevel_InvalidR\x17mobileNotificatio\
    nLevel\x12-\n\x13time_last_group_ack\x18\x06\x20\x01(\rR\x10timeLastGrou\
    pAck\x12;\n\x16unread_indicator_muted\x18\x07\x20\x01(\x08:\x05falseR\
    \x14unreadIndicatorMuted\"\xba\x01\n&CChatRoom_CreateChatRoomGroup_Respo\
    nse\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12*\n\
    \x05state\x18\x02\x20\x01(\x0b2\x14.CChatRoomGroupStateR\x05state\x12@\n\
    \x0fuser_chat_state\x18\x03\x20\x01(\x0b2\x18.CUserChatRoomGroupStateR\r\
    userChatState\"]\n#CChatRoom_SaveChatRoomGroup_Request\x12\"\n\rchat_gro\
    up_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x12\n\x04name\x18\x02\x20\
    \x01(\tR\x04name\"&\n$CChatRoom_SaveChatRoomGroup_Response\"_\n%CChatRoo\
    m_RenameChatRoomGroup_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\
    \x04R\x0bchatGroupId\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\"<\n&\
    CChatRoom_RenameChatRoomGroup_Response\x12\x12\n\x04name\x18\x01\x20\x01\
    (\tR\x04name\"i\n)CChatRoom_SetChatRoomGroupTagline_Request\x12\"\n\rcha\
    t_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x18\n\x07tagline\x18\
    \x02\x20\x01(\tR\x07tagline\",\n*CChatRoom_SetChatRoomGroupTagline_Respo\
    nse\"m\n(CChatRoom_SetChatRoomGroupAvatar_Request\x12\"\n\rchat_group_id\
    \x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x1d\n\navatar_sha\x18\x02\x20\
    \x01(\x0cR\tavatarSha\"+\n)CChatRoom_SetChatRoomGroupAvatar_Response\"\
    \xde\x01\n3CChatRoom_SetChatRoomGroupWatchingBroadcast_Request\x12\"\n\r\
    chat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12@\n\x1cwatching_br\
    oadcast_accountid\x18\x02\x20\x01(\rR\x1awatchingBroadcastAccountid\x12A\
    \n\x1dwatching_broadcast_channel_id\x18\x03\x20\x01(\x04R\x1awatchingBro\
    adcastChannelId\"6\n4CChatRoom_SetChatRoomGroupWatchingBroadcast_Respons\
    e\"m\n.CChatRoom_JoinMiniGameForChatRoomGroup_Request\x12\"\n\rchat_grou\
    p_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07chat_id\x18\x02\
    \x20\x01(\x04R\x06chatId\"R\n/CChatRoom_JoinMiniGameForChatRoomGroup_Res\
    ponse\x12\x1f\n\x0bminigame_id\x18\x01\x20\x01(\x04R\nminigameId\"\x8d\
    \x01\n-CChatRoom_EndMiniGameForChatRoomGroup_Request\x12\"\n\rchat_group\
    _id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07chat_id\x18\x02\
    \x20\x01(\x04R\x06chatId\x12\x1f\n\x0bminigame_id\x18\x03\x20\x01(\x04R\
    \nminigameId\"0\n.CChatRoom_EndMiniGameForChatRoomGroup_Response\"z\n\
    \x1aCChatRoom_MuteUser_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\
    \x04R\x0bchatGroupId\x12\x18\n\x07steamid\x18\x02\x20\x01(\x06R\x07steam\
    id\x12\x1e\n\nexpiration\x18\x03\x20\x01(\x05R\nexpiration\"\x1d\n\x1bCC\
    hatRoom_MuteUser_Response\"z\n\x1aCChatRoom_KickUser_Request\x12\"\n\rch\
    at_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x18\n\x07steamid\
    \x18\x02\x20\x01(\x06R\x07steamid\x12\x1e\n\nexpiration\x18\x03\x20\x01(\
    \x05R\nexpiration\"\x1d\n\x1bCChatRoom_KickUser_Response\"~\n!CChatRoom_\
    SetUserBanState_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0b\
    chatGroupId\x12\x18\n\x07steamid\x18\x02\x20\x01(\x06R\x07steamid\x12\
    \x1b\n\tban_state\x18\x03\x20\x01(\x08R\x08banState\"$\n\"CChatRoom_SetU\
    serBanState_Response\"^\n\x1eCChatRoom_RevokeInvite_Request\x12\"\n\rcha\
    t_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x18\n\x07steamid\x18\
    \x02\x20\x01(\x06R\x07steamid\"!\n\x1fCChatRoom_RevokeInvite_Response\"V\
    \n\x1cCChatRoom_CreateRole_Request\x12\"\n\rchat_group_id\x18\x01\x20\
    \x01(\x04R\x0bchatGroupId\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\
    \"L\n\x1dCChatRoom_CreateRole_Response\x12+\n\x07actions\x18\x02\x20\x01\
    (\x0b2\x11.CChatRoleActionsR\x07actions\"@\n\x1aCChatRoom_GetRoles_Reque\
    st\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\"?\n\x1bC\
    ChatRoom_GetRoles_Response\x12\x20\n\x05roles\x18\x01\x20\x03(\x0b2\n.CC\
    hatRoleR\x05roles\"o\n\x1cCChatRoom_RenameRole_Request\x12\"\n\rchat_gro\
    up_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07role_id\x18\x02\
    \x20\x01(\x04R\x06roleId\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\"\
    \x1f\n\x1dCChatRoom_RenameRole_Response\"v\n\x1dCChatRoom_ReorderRole_Re\
    quest\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\
    \x17\n\x07role_id\x18\x02\x20\x01(\x04R\x06roleId\x12\x18\n\x07ordinal\
    \x18\x03\x20\x01(\rR\x07ordinal\"\x20\n\x1eCChatRoom_ReorderRole_Respons\
    e\"[\n\x1cCChatRoom_DeleteRole_Request\x12\"\n\rchat_group_id\x18\x01\
    \x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07role_id\x18\x02\x20\x01(\x04R\
    \x06roleId\"\x1f\n\x1dCChatRoom_DeleteRole_Response\"_\n\x20CChatRoom_Ge\
    tRoleActions_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bcha\
    tGroupId\x12\x17\n\x07role_id\x18\x02\x20\x01(\x04R\x06roleId\"P\n!CChat\
    Room_GetRoleActions_Response\x12+\n\x07actions\x18\x01\x20\x03(\x0b2\x11\
    .CChatRoleActionsR\x07actions\"\x90\x01\n$CChatRoom_ReplaceRoleActions_R\
    equest\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\
    \x17\n\x07role_id\x18\x02\x20\x01(\x04R\x06roleId\x12+\n\x07actions\x18\
    \x04\x20\x01(\x0b2\x11.CChatRoleActionsR\x07actions\"'\n%CChatRoom_Repla\
    ceRoleActions_Response\"x\n\x1fCChatRoom_AddRoleToUser_Request\x12\"\n\r\
    chat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07role_id\
    \x18\x03\x20\x01(\x04R\x06roleId\x12\x18\n\x07steamid\x18\x04\x20\x01(\
    \x06R\x07steamid\"\"\n\x20CChatRoom_AddRoleToUser_Response\"a\n!CChatRoo\
    m_GetRolesForUser_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\
    \x0bchatGroupId\x12\x18\n\x07steamid\x18\x03\x20\x01(\x06R\x07steamid\"?\
    \n\"CChatRoom_GetRolesForUser_Response\x12\x19\n\x08role_ids\x18\x01\x20\
    \x03(\x04R\x07roleIds\"}\n$CChatRoom_DeleteRoleFromUser_Request\x12\"\n\
    \rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07role_i\
    d\x18\x03\x20\x01(\x04R\x06roleId\x12\x18\n\x07steamid\x18\x04\x20\x01(\
    \x06R\x07steamid\"'\n%CChatRoom_DeleteRoleFromUser_Response\"\x83\x01\n#\
    CChatRoom_JoinChatRoomGroup_Request\x12\"\n\rchat_group_id\x18\x01\x20\
    \x01(\x04R\x0bchatGroupId\x12\x1f\n\x0binvite_code\x18\x02\x20\x01(\tR\n\
    inviteCode\x12\x17\n\x07chat_id\x18\x03\x20\x01(\x04R\x06chatId\"\xd7\
    \x01\n$CChatRoom_JoinChatRoomGroup_Response\x12*\n\x05state\x18\x01\x20\
    \x01(\x0b2\x14.CChatRoomGroupStateR\x05state\x12@\n\x0fuser_chat_state\
    \x18\x03\x20\x01(\x0b2\x18.CUserChatRoomGroupStateR\ruserChatState\x12\
    \x20\n\x0cjoin_chat_id\x18\x04\x20\x01(\x04R\njoinChatId\x12\x1f\n\x0bti\
    me_expire\x18\x05\x20\x01(\rR\ntimeExpire\"\xb8\x01\n-CChatRoom_InviteFr\
    iendToChatRoomGroup_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\
    \x0bchatGroupId\x12\x18\n\x07steamid\x18\x02\x20\x01(\x06R\x07steamid\
    \x12\x17\n\x07chat_id\x18\x03\x20\x01(\x04R\x06chatId\x120\n\x14skip_fri\
    endsui_check\x18\x04\x20\x01(\x08R\x12skipFriendsuiCheck\"0\n.CChatRoom_\
    InviteFriendToChatRoomGroup_Response\"J\n$CChatRoom_LeaveChatRoomGroup_R\
    equest\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\"'\n%\
    CChatRoom_LeaveChatRoomGroup_Response\"{\n\x20CChatRoom_CreateChatRoom_R\
    equest\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\
    \x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x1f\n\x0ballow_voice\x18\
    \x03\x20\x01(\x08R\nallowVoice\"Q\n!CChatRoom_CreateChatRoom_Response\
    \x12,\n\tchat_room\x18\x01\x20\x01(\x0b2\x0f.CChatRoomStateR\x08chatRoom\
    \"_\n\x20CChatRoom_DeleteChatRoom_Request\x12\"\n\rchat_group_id\x18\x01\
    \x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07chat_id\x18\x02\x20\x01(\x04R\
    \x06chatId\"#\n!CChatRoom_DeleteChatRoom_Response\"s\n\x20CChatRoom_Rena\
    meChatRoom_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatG\
    roupId\x12\x17\n\x07chat_id\x18\x02\x20\x01(\x04R\x06chatId\x12\x12\n\
    \x04name\x18\x03\x20\x01(\tR\x04name\"#\n!CChatRoom_RenameChatRoom_Respo\
    nse\"\x8d\x01\n!CChatRoom_ReorderChatRoom_Request\x12\"\n\rchat_group_id\
    \x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07chat_id\x18\x02\x20\
    \x01(\x04R\x06chatId\x12+\n\x12move_after_chat_id\x18\x03\x20\x01(\x04R\
    \x0fmoveAfterChatId\"$\n\"CChatRoom_ReorderChatRoom_Response\"\xa0\x01\n\
    !CChatRoom_SendChatMessage_Request\x12\"\n\rchat_group_id\x18\x01\x20\
    \x01(\x04R\x0bchatGroupId\x12\x17\n\x07chat_id\x18\x02\x20\x01(\x04R\x06\
    chatId\x12\x18\n\x07message\x18\x03\x20\x01(\tR\x07message\x12$\n\x0eech\
    o_to_sender\x18\x04\x20\x01(\x08R\x0cechoToSender\"\xcb\x01\n\"CChatRoom\
    _SendChatMessage_Response\x12)\n\x10modified_message\x18\x01\x20\x01(\tR\
    \x0fmodifiedMessage\x12)\n\x10server_timestamp\x18\x02\x20\x01(\rR\x0fse\
    rverTimestamp\x12\x18\n\x07ordinal\x18\x03\x20\x01(\rR\x07ordinal\x125\n\
    \x17message_without_bb_code\x18\x04\x20\x01(\tR\x14messageWithoutBbCode\
    \"^\n\x1fCChatRoom_JoinVoiceChat_Request\x12\"\n\rchat_group_id\x18\x01\
    \x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07chat_id\x18\x02\x20\x01(\x04R\
    \x06chatId\"E\n\x20CChatRoom_JoinVoiceChat_Response\x12!\n\x0cvoice_chat\
    id\x18\x01\x20\x01(\x04R\x0bvoiceChatid\"_\n\x20CChatRoom_LeaveVoiceChat\
    _Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\
    \x17\n\x07chat_id\x18\x02\x20\x01(\x04R\x06chatId\"#\n!CChatRoom_LeaveVo\
    iceChat_Response\"\x83\x02\n#CChatRoom_GetMessageHistory_Request\x12\"\n\
    \rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07chat_i\
    d\x18\x02\x20\x01(\x04R\x06chatId\x12\x1b\n\tlast_time\x18\x03\x20\x01(\
    \rR\x08lastTime\x12!\n\x0clast_ordinal\x18\x04\x20\x01(\rR\x0blastOrdina\
    l\x12\x1d\n\nstart_time\x18\x05\x20\x01(\rR\tstartTime\x12#\n\rstart_ord\
    inal\x18\x06\x20\x01(\rR\x0cstartOrdinal\x12\x1b\n\tmax_count\x18\x07\
    \x20\x01(\rR\x08maxCount\"\xac\x01\n\rServerMessage\x12O\n\x07message\
    \x18\x01\x20\x01(\x0e2\x17.EChatRoomServerMessage:\x1ck_EChatRoomServerM\
    sg_InvalidR\x07message\x12!\n\x0cstring_param\x18\x02\x20\x01(\tR\x0bstr\
    ingParam\x12'\n\x0faccountid_param\x18\x03\x20\x01(\rR\x0eaccountidParam\
    \"\xbe\x05\n$CChatRoom_GetMessageHistory_Response\x12M\n\x08messages\x18\
    \x01\x20\x03(\x0b21.CChatRoom_GetMessageHistory_Response.ChatMessageR\
    \x08messages\x12%\n\x0emore_available\x18\x04\x20\x01(\x08R\rmoreAvailab\
    le\x1a\x9f\x04\n\x0bChatMessage\x12\x16\n\x06sender\x18\x01\x20\x01(\rR\
    \x06sender\x12)\n\x10server_timestamp\x18\x02\x20\x01(\rR\x0fserverTimes\
    tamp\x12\x18\n\x07message\x18\x03\x20\x01(\tR\x07message\x12\x18\n\x07or\
    dinal\x18\x04\x20\x01(\rR\x07ordinal\x125\n\x0eserver_message\x18\x05\
    \x20\x01(\x0b2\x0e.ServerMessageR\rserverMessage\x12\x18\n\x07deleted\
    \x18\x06\x20\x01(\x08R\x07deleted\x12_\n\treactions\x18\x07\x20\x03(\x0b\
    2A.CChatRoom_GetMessageHistory_Response.ChatMessage.MessageReactionR\tre\
    actions\x1a\xe6\x01\n\x0fMessageReaction\x12j\n\rreaction_type\x18\x01\
    \x20\x01(\x0e2\x1d.EChatRoomMessageReactionType:&k_EChatRoomMessageReact\
    ionType_InvalidR\x0creactionType\x12\x1a\n\x08reaction\x18\x02\x20\x01(\
    \tR\x08reaction\x12!\n\x0cnum_reactors\x18\x03\x20\x01(\rR\x0bnumReactor\
    s\x12(\n\x10has_user_reacted\x18\x04\x20\x01(\x08R\x0ehasUserReacted\"'\
    \n%CChatRoom_GetMyChatRoomGroups_Request\"\xe5\x07\n*CChatRoom_GetChatRo\
    omGroupSummary_Response\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0b\
    chatGroupId\x12&\n\x0fchat_group_name\x18\x02\x20\x01(\tR\rchatGroupName\
    \x12.\n\x13active_member_count\x18\x03\x20\x01(\rR\x11activeMemberCount\
    \x129\n\x19active_voice_member_count\x18\x04\x20\x01(\rR\x16activeVoiceM\
    emberCount\x12&\n\x0fdefault_chat_id\x18\x05\x20\x01(\x04R\rdefaultChatI\
    d\x12.\n\nchat_rooms\x18\x06\x20\x03(\x0b2\x0f.CChatRoomStateR\tchatRoom\
    s\x12\x16\n\x06clanid\x18\x07\x20\x01(\rR\x06clanid\x12,\n\x12chat_group\
    _tagline\x18\x08\x20\x01(\tR\x10chatGroupTagline\x12'\n\x0faccountid_own\
    er\x18\t\x20\x01(\rR\x0eaccountidOwner\x12\x1f\n\x0btop_members\x18\n\
    \x20\x03(\rR\ntopMembers\x121\n\x15chat_group_avatar_sha\x18\x0b\x20\x01\
    (\x0cR\x12chatGroupAvatarSha\x12E\n\x04rank\x18\x0c\x20\x01(\x0e2\x13.EC\
    hatRoomGroupRank:\x1ck_EChatRoomGroupRank_DefaultR\x04rank\x12&\n\x0fdef\
    ault_role_id\x18\r\x20\x01(\x04R\rdefaultRoleId\x12\x19\n\x08role_ids\
    \x18\x0e\x20\x03(\x04R\x07roleIds\x124\n\x0crole_actions\x18\x0f\x20\x03\
    (\x0b2\x11.CChatRoleActionsR\x0broleActions\x12@\n\x1cwatching_broadcast\
    _accountid\x18\x10\x20\x01(\rR\x1awatchingBroadcastAccountid\x12\x14\n\
    \x05appid\x18\x11\x20\x01(\rR\x05appid\x126\n\rparty_beacons\x18\x12\x20\
    \x03(\x0b2\x11.CChatPartyBeaconR\x0cpartyBeacons\x12A\n\x1dwatching_broa\
    dcast_channel_id\x18\x13\x20\x01(\x04R\x1awatchingBroadcastChannelId\x12\
    ,\n\x12active_minigame_id\x18\x14\x20\x01(\x04R\x10activeMinigameId\x12$\
    \n\x0eavatar_ugc_url\x18\x15\x20\x01(\tR\x0cavatarUgcUrl\"\xb5\x01\n\x14\
    CChatRoomSummaryPair\x12K\n\x15user_chat_group_state\x18\x01\x20\x01(\
    \x0b2\x18.CUserChatRoomGroupStateR\x12userChatGroupState\x12P\n\rgroup_s\
    ummary\x18\x02\x20\x01(\x0b2+.CChatRoom_GetChatRoomGroupSummary_Response\
    R\x0cgroupSummary\"i\n&CChatRoom_GetMyChatRoomGroups_Response\x12?\n\x10\
    chat_room_groups\x18\x01\x20\x03(\x0b2\x15.CChatRoomSummaryPairR\x0echat\
    RoomGroups\"M\n'CChatRoom_GetChatRoomGroupState_Request\x12\"\n\rchat_gr\
    oup_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\"V\n(CChatRoom_GetChatRoomGr\
    oupState_Response\x12*\n\x05state\x18\x01\x20\x01(\x0b2\x14.CChatRoomGro\
    upStateR\x05state\"O\n)CChatRoom_GetChatRoomGroupSummary_Request\x12\"\n\
    \rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\"\x82\x01\n0CChatRo\
    om_SetAppChatRoomGroupForceActive_Request\x12\"\n\rchat_group_id\x18\x01\
    \x20\x01(\x04R\x0bchatGroupId\x12*\n\x11requesting_app_id\x18\x02\x20\
    \x01(\rR\x0frequestingAppId\"{\n1CChatRoom_SetAppChatRoomGroupForceActiv\
    e_Response\x12\x16\n\x06result\x18\x01\x20\x01(\rR\x06result\x12.\n\x13a\
    ccounts_in_channel\x18\x02\x20\x03(\rR\x11accountsInChannel\"\x8b\x01\n9\
    CChatRoom_SetAppChatRoomGroupStopForceActive_Notification\x12\"\n\rchat_\
    group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12*\n\x11requesting_app_i\
    d\x18\x02\x20\x01(\rR\x0frequestingAppId\"\x82\x01\n%CChatRoom_AckChatMe\
    ssage_Notification\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatG\
    roupId\x12\x17\n\x07chat_id\x18\x02\x20\x01(\x04R\x06chatId\x12\x1c\n\tt\
    imestamp\x18\x03\x20\x01(\rR\ttimestamp\"\x86\x01\n\"CChatRoom_CreateInv\
    iteLink_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGrou\
    pId\x12#\n\rseconds_valid\x18\x02\x20\x01(\rR\x0csecondsValid\x12\x17\n\
    \x07chat_id\x18\x03\x20\x01(\x04R\x06chatId\"k\n#CChatRoom_CreateInviteL\
    ink_Response\x12\x1f\n\x0binvite_code\x18\x01\x20\x01(\tR\ninviteCode\
    \x12#\n\rseconds_valid\x18\x02\x20\x01(\rR\x0csecondsValid\"F\n#CChatRoo\
    m_GetInviteLinkInfo_Request\x12\x1f\n\x0binvite_code\x18\x01\x20\x01(\tR\
    \ninviteCode\"\xea\x02\n$CChatRoom_GetInviteLinkInfo_Response\x12%\n\x0e\
    steamid_sender\x18\x03\x20\x01(\x06R\rsteamidSender\x12!\n\x0ctime_expir\
    es\x18\x04\x20\x01(\rR\x0btimeExpires\x12\x17\n\x07chat_id\x18\x06\x20\
    \x01(\x04R\x06chatId\x12P\n\rgroup_summary\x18\x08\x20\x01(\x0b2+.CChatR\
    oom_GetChatRoomGroupSummary_ResponseR\x0cgroupSummary\x12K\n\x15user_cha\
    t_group_state\x18\t\x20\x01(\x0b2\x18.CUserChatRoomGroupStateR\x12userCh\
    atGroupState\x12(\n\x10time_kick_expire\x18\n\x20\x01(\rR\x0etimeKickExp\
    ire\x12\x16\n\x06banned\x18\x0b\x20\x01(\x08R\x06banned\"\xa8\x01\n\x1fC\
    ChatRoom_GetInviteInfo_Request\x12'\n\x0fsteamid_invitee\x18\x01\x20\x01\
    (\x06R\x0esteamidInvitee\x12\"\n\rchat_group_id\x18\x02\x20\x01(\x04R\
    \x0bchatGroupId\x12\x17\n\x07chat_id\x18\x03\x20\x01(\x04R\x06chatId\x12\
    \x1f\n\x0binvite_code\x18\x04\x20\x01(\tR\ninviteCode\"\xb6\x01\n\x20CCh\
    atRoom_GetInviteInfo_Response\x12P\n\rgroup_summary\x18\x01\x20\x01(\x0b\
    2+.CChatRoom_GetChatRoomGroupSummary_ResponseR\x0cgroupSummary\x12(\n\
    \x10time_kick_expire\x18\x02\x20\x01(\rR\x0etimeKickExpire\x12\x16\n\x06\
    banned\x18\x03\x20\x01(\x08R\x06banned\"N\n(CChatRoom_GetInviteLinksForG\
    roup_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\
    \"\x96\x02\n)CChatRoom_GetInviteLinksForGroup_Response\x12V\n\x0cinvite_\
    links\x18\x01\x20\x03(\x0b23.CChatRoom_GetInviteLinksForGroup_Response.L\
    inkInfoR\x0binviteLinks\x1a\x90\x01\n\x08LinkInfo\x12\x1f\n\x0binvite_co\
    de\x18\x01\x20\x01(\tR\ninviteCode\x12'\n\x0fsteamid_creator\x18\x02\x20\
    \x01(\x06R\x0esteamidCreator\x12!\n\x0ctime_expires\x18\x03\x20\x01(\rR\
    \x0btimeExpires\x12\x17\n\x07chat_id\x18\x04\x20\x01(\x04R\x06chatId\"B\
    \n\x1cCChatRoom_GetBanList_Request\x12\"\n\rchat_group_id\x18\x01\x20\
    \x01(\x04R\x0bchatGroupId\"\xee\x01\n\x1dCChatRoom_GetBanList_Response\
    \x12:\n\x04bans\x18\x01\x20\x03(\x0b2&.CChatRoom_GetBanList_Response.Ban\
    InfoR\x04bans\x1a\x90\x01\n\x07BanInfo\x12\x1c\n\taccountid\x18\x01\x20\
    \x01(\rR\taccountid\x12'\n\x0faccountid_actor\x18\x02\x20\x01(\rR\x0eacc\
    ountidActor\x12\x1f\n\x0btime_banned\x18\x03\x20\x01(\rR\ntimeBanned\x12\
    \x1d\n\nban_reason\x18\x04\x20\x01(\tR\tbanReason\"E\n\x1fCChatRoom_GetI\
    nviteList_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGr\
    oupId\"\x80\x01\n\x14CChatRoomGroupInvite\x12\x1c\n\taccountid\x18\x01\
    \x20\x01(\rR\taccountid\x12'\n\x0faccountid_actor\x18\x02\x20\x01(\rR\
    \x0eaccountidActor\x12!\n\x0ctime_invited\x18\x03\x20\x01(\rR\x0btimeInv\
    ited\"S\n\x20CChatRoom_GetInviteList_Response\x12/\n\x07invites\x18\x01\
    \x20\x03(\x0b2\x15.CChatRoomGroupInviteR\x07invites\"i\n\"CChatRoom_Dele\
    teInviteLink_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bcha\
    tGroupId\x12\x1f\n\x0binvite_code\x18\x02\x20\x01(\tR\ninviteCode\"%\n#C\
    ChatRoom_DeleteInviteLink_Response\"\xb7\x02\n0CChatRoom_SetSessionActiv\
    eChatRoomGroups_Request\x12$\n\x0echat_group_ids\x18\x01\x20\x03(\x04R\
    \x0cchatGroupIds\x12;\n\x1achat_groups_data_requested\x18\x02\x20\x03(\
    \x04R\x17chatGroupsDataRequested\x12\x9f\x01\n\x1cvirtualize_members_thr\
    eshold\x18\x03\x20\x01(\x05R\x1avirtualizeMembersThresholdB]\x82\xb5\x18\
    YIf\x20a\x20chat\x20room\x20has\x20more\x20members\x20than\x20this\x20th\
    reshold,\x20we\x20will\x20opt\x20in\x20to\x20a\x20virtualized\x20list\"\
    \xb4\x01\n1CChatRoom_SetSessionActiveChatRoomGroups_Response\x125\n\x0bc\
    hat_states\x18\x01\x20\x03(\x0b2\x14.CChatRoomGroupStateR\nchatStates\
    \x12H\n!virtualize_members_chat_group_ids\x18\x02\x20\x03(\x04R\x1dvirtu\
    alizeMembersChatGroupIds\"\xfc\x07\n-CChatRoom_SetUserChatGroupPreferenc\
    es_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\
    \x12y\n\x16chat_group_preferences\x18\x02\x20\x01(\x0b2C.CChatRoom_SetUs\
    erChatGroupPreferences_Request.ChatGroupPreferencesR\x14chatGroupPrefere\
    nces\x12v\n\x15chat_room_preferences\x18\x03\x20\x03(\x0b2B.CChatRoom_Se\
    tUserChatGroupPreferences_Request.ChatRoomPreferencesR\x13chatRoomPrefer\
    ences\x1a\xcc\x02\n\x14ChatGroupPreferences\x12\x7f\n\x1adesktop_notific\
    ation_level\x18\x01\x20\x01(\x0e2\x1b.EChatRoomNotificationLevel:$k_ECha\
    troomNotificationLevel_InvalidR\x18desktopNotificationLevel\x12}\n\x19mo\
    bile_notification_level\x18\x02\x20\x01(\x0e2\x1b.EChatRoomNotificationL\
    evel:$k_EChatroomNotificationLevel_InvalidR\x17mobileNotificationLevel\
    \x124\n\x16unread_indicator_muted\x18\x03\x20\x01(\x08R\x14unreadIndicat\
    orMuted\x1a\xe4\x02\n\x13ChatRoomPreferences\x12\x17\n\x07chat_id\x18\
    \x01\x20\x01(\x04R\x06chatId\x12\x7f\n\x1adesktop_notification_level\x18\
    \x02\x20\x01(\x0e2\x1b.EChatRoomNotificationLevel:$k_EChatroomNotificati\
    onLevel_InvalidR\x18desktopNotificationLevel\x12}\n\x19mobile_notificati\
    on_level\x18\x03\x20\x01(\x0e2\x1b.EChatRoomNotificationLevel:$k_EChatro\
    omNotificationLevel_InvalidR\x17mobileNotificationLevel\x124\n\x16unread\
    _indicator_muted\x18\x04\x20\x01(\x08R\x14unreadIndicatorMuted\"0\n.CCha\
    tRoom_SetUserChatGroupPreferences_Response\"\xfe\x01\n$CChatRoom_DeleteC\
    hatMessages_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchat\
    GroupId\x12\x17\n\x07chat_id\x18\x02\x20\x01(\x04R\x06chatId\x12I\n\x08m\
    essages\x18\x03\x20\x03(\x0b2-.CChatRoom_DeleteChatMessages_Request.Mess\
    ageR\x08messages\x1aN\n\x07Message\x12)\n\x10server_timestamp\x18\x01\
    \x20\x01(\rR\x0fserverTimestamp\x12\x18\n\x07ordinal\x18\x02\x20\x01(\rR\
    \x07ordinal\"'\n%CChatRoom_DeleteChatMessages_Response\"\xe4\x04\n+CChat\
    Room_UpdateMemberListView_Notification\x12\"\n\rchat_group_id\x18\x01\
    \x20\x01(\x04R\x0bchatGroupId\x12o\n\x07view_id\x18\x02\x20\x01(\x04R\
    \x06viewIdBV\x82\xb5\x18RClient-generated\x20ID.\x20\x20Should\x20send\
    \x20the\x20same\x20value\x20on\x20all\x20requests\x20for\x20the\x20same\
    \x20view\x12\x14\n\x05start\x18\x03\x20\x01(\x05R\x05start\x12\x10\n\x03\
    end\x18\x04\x20\x01(\x05R\x03end\x12\xa3\x01\n\x13client_changenumber\
    \x18\x05\x20\x01(\x05R\x12clientChangenumberBr\x82\xb5\x18nAny\x20update\
    s\x20from\x20this\x20call\x20on\x20will\x20have\x20this\x20changenumber\
    \x20present.\x20\x20Can\x20be\x20used\x20to\x20guarantee\x20in-order\x20\
    updates.\x12J\n\x0bdelete_view\x18\x06\x20\x01(\x08R\ndeleteViewB)\x82\
    \xb5\x18%Indicates\x20this\x20view\x20has\x20been\x20deleted.\x12@\n\x1c\
    persona_subscribe_accountids\x18\x07\x20\x03(\x05R\x1apersonaSubscribeAc\
    countids\x12D\n\x1epersona_unsubscribe_accountids\x18\x08\x20\x03(\x05R\
    \x1cpersonaUnsubscribeAccountids\"\xc6\x02\n\x1fCChatRoom_SearchMembers_\
    Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\
    \xbc\x01\n\tsearch_id\x18\x02\x20\x01(\x04R\x08searchIdB\x9e\x01\x82\xb5\
    \x18\x99\x01Client-supplied\x20id.\x20\x20For\x20find-as-you-type\x20sea\
    rches,\x20as\x20search\x20narrows\x20the\x20server\x20will\x20not\x20ret\
    urn\x20persona\x20states\x20previously\x20returned\x20for\x20a\x20given\
    \x20searchid.\x12\x1f\n\x0bsearch_text\x18\x03\x20\x01(\tR\nsearchText\
    \x12\x1f\n\x0bmax_results\x18\x04\x20\x01(\x05R\nmaxResults\"\x86\x02\n\
    \x20CChatRoom_SearchMembers_Response\x12X\n\x10matching_members\x18\x01\
    \x20\x03(\x0b2-.CChatRoom_SearchMembers_Response.MemberMatchR\x0fmatchin\
    gMembers\x12!\n\x0cstatus_flags\x18\x02\x20\x01(\rR\x0bstatusFlags\x1ae\
    \n\x0bMemberMatch\x12\x1c\n\taccountid\x18\x01\x20\x01(\x05R\taccountid\
    \x128\n\x07persona\x18\x02\x20\x01(\x0b2\x1e.CMsgClientPersonaState.Frie\
    ndR\x07persona\"\xca\x02\n'CChatRoom_UpdateMessageReaction_Request\x12\"\
    \n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07chat\
    _id\x18\x02\x20\x01(\x04R\x06chatId\x12)\n\x10server_timestamp\x18\x03\
    \x20\x01(\rR\x0fserverTimestamp\x12\x18\n\x07ordinal\x18\x04\x20\x01(\rR\
    \x07ordinal\x12j\n\rreaction_type\x18\x05\x20\x01(\x0e2\x1d.EChatRoomMes\
    sageReactionType:&k_EChatRoomMessageReactionType_InvalidR\x0creactionTyp\
    e\x12\x1a\n\x08reaction\x18\x06\x20\x01(\tR\x08reaction\x12\x15\n\x06is_\
    add\x18\x07\x20\x01(\x08R\x05isAdd\"M\n(CChatRoom_UpdateMessageReaction_\
    Response\x12!\n\x0cnum_reactors\x18\x01\x20\x01(\rR\x0bnumReactors\"\xce\
    \x02\n,CChatRoom_GetMessageReactionReactors_Request\x12\"\n\rchat_group_\
    id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07chat_id\x18\x02\x20\
    \x01(\x04R\x06chatId\x12)\n\x10server_timestamp\x18\x03\x20\x01(\rR\x0fs\
    erverTimestamp\x12\x18\n\x07ordinal\x18\x04\x20\x01(\rR\x07ordinal\x12j\
    \n\rreaction_type\x18\x05\x20\x01(\x0e2\x1d.EChatRoomMessageReactionType\
    :&k_EChatRoomMessageReactionType_InvalidR\x0creactionType\x12\x1a\n\x08r\
    eaction\x18\x06\x20\x01(\tR\x08reaction\x12\x14\n\x05limit\x18\x07\x20\
    \x01(\rR\x05limit\"K\n-CChatRoom_GetMessageReactionReactors_Response\x12\
    \x1a\n\x08reactors\x18\x01\x20\x03(\rR\x08reactors\"\xad\x01\n*CClanChat\
    Rooms_GetClanChatRoomInfo_Request\x12\x18\n\x07steamid\x18\x01\x20\x01(\
    \x06R\x07steamid\x12e\n\nautocreate\x18\x02\x20\x01(\x08:\x04trueR\nauto\
    createB?\x82\xb5\x18;Create\x20a\x20default\x20chat\x20room\x20if\x20non\
    e\x20has\x20been\x20created\x20before.\"\x88\x01\n+CClanChatRooms_GetCla\
    nChatRoomInfo_Response\x12Y\n\x12chat_group_summary\x18\x01\x20\x01(\x0b\
    2+.CChatRoom_GetChatRoomGroupSummary_ResponseR\x10chatGroupSummary\"u\n-\
    CClanChatRooms_SetClanChatRoomPrivate_Request\x12\x18\n\x07steamid\x18\
    \x01\x20\x01(\x06R\x07steamid\x12*\n\x11chat_room_private\x18\x02\x20\
    \x01(\x08R\x0fchatRoomPrivate\"\\\n.CClanChatRooms_SetClanChatRoomPrivat\
    e_Response\x12*\n\x11chat_room_private\x18\x01\x20\x01(\x08R\x0fchatRoom\
    Private\"\x82\x01\n\rCChatMentions\x12\x1f\n\x0bmention_all\x18\x01\x20\
    \x01(\x08R\nmentionAll\x12!\n\x0cmention_here\x18\x02\x20\x01(\x08R\x0bm\
    entionHere\x12-\n\x12mention_accountids\x18\x03\x20\x03(\rR\x11mentionAc\
    countids\"\xca\x03\n*CChatRoom_IncomingChatMessage_Notification\x12\"\n\
    \rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07chat_i\
    d\x18\x02\x20\x01(\x04R\x06chatId\x12%\n\x0esteamid_sender\x18\x03\x20\
    \x01(\x06R\rsteamidSender\x12\x18\n\x07message\x18\x04\x20\x01(\tR\x07me\
    ssage\x12\x1c\n\ttimestamp\x18\x05\x20\x01(\rR\ttimestamp\x12*\n\x08ment\
    ions\x18\x06\x20\x01(\x0b2\x0e.CChatMentionsR\x08mentions\x12\x18\n\x07o\
    rdinal\x18\x07\x20\x01(\rR\x07ordinal\x125\n\x0eserver_message\x18\x08\
    \x20\x01(\x0b2\x0e.ServerMessageR\rserverMessage\x12*\n\x11message_no_bb\
    code\x18\t\x20\x01(\tR\x0fmessageNoBbcode\x12W\n\tchat_name\x18\n\x20\
    \x01(\tR\x08chatNameB:\x82\xb5\x186A\x20name\x20to\x20use\x20for\x20the\
    \x20chat,\x20intended\x20for\x20notifications\"\xac\x02\n*CChatRoom_Chat\
    MessageModified_Notification\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04\
    R\x0bchatGroupId\x12\x17\n\x07chat_id\x18\x02\x20\x01(\x04R\x06chatId\
    \x12S\n\x08messages\x18\x03\x20\x03(\x0b27.CChatRoom_ChatMessageModified\
    _Notification.ChatMessageR\x08messages\x1al\n\x0bChatMessage\x12)\n\x10s\
    erver_timestamp\x18\x01\x20\x01(\rR\x0fserverTimestamp\x12\x18\n\x07ordi\
    nal\x18\x02\x20\x01(\rR\x07ordinal\x12\x18\n\x07deleted\x18\x03\x20\x01(\
    \x08R\x07deleted\"\xd3\x01\n(CChatRoom_MemberStateChange_Notification\
    \x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12(\n\x06m\
    ember\x18\x02\x20\x01(\x0b2\x10.CChatRoomMemberR\x06member\x12Y\n\x06cha\
    nge\x18\x03\x20\x01(\x0e2\x1b.EChatRoomMemberStateChange:$k_EChatRoomMem\
    berStateChange_InvalidR\x06change\"k\n*CChatRoom_ChatRoomHeaderState_Not\
    ification\x12=\n\x0cheader_state\x18\x01\x20\x01(\x0b2\x1a.CChatRoomGrou\
    pHeaderStateR\x0bheaderState\"\xad\x01\n/CChatRoom_ChatRoomGroupRoomsCha\
    nge_Notification\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGro\
    upId\x12&\n\x0fdefault_chat_id\x18\x02\x20\x01(\x04R\rdefaultChatId\x12.\
    \n\nchat_rooms\x18\x03\x20\x03(\x0b2\x0f.CChatRoomStateR\tchatRooms\"y\n\
    :CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification\x12\x17\n\
    \x07chat_id\x18\x01\x20\x01(\x04R\x06chatId\x12\"\n\rchat_group_id\x18\
    \x02\x20\x01(\x04R\x0bchatGroupId\"\xe4\x02\n;ChatRoomClient_NotifyChatG\
    roupUserStateChanged_Notification\x12\"\n\rchat_group_id\x18\x01\x20\x01\
    (\x04R\x0bchatGroupId\x12K\n\x15user_chat_group_state\x18\x02\x20\x01(\
    \x0b2\x18.CUserChatRoomGroupStateR\x12userChatGroupState\x12P\n\rgroup_s\
    ummary\x18\x03\x20\x01(\x0b2+.CChatRoom_GetChatRoomGroupSummary_Response\
    R\x0cgroupSummary\x12b\n\x0buser_action\x18\x04\x20\x01(\x0e2\x1b.EChatR\
    oomMemberStateChange:$k_EChatRoomMemberStateChange_InvalidR\nuserAction\
    \"\\\n4ChatRoomClient_NotifyChatRoomDisconnect_Notification\x12$\n\x0ech\
    at_group_ids\x18\x01\x20\x03(\x04R\x0cchatGroupIds\"\xd4\x02\n\x17CChatR\
    oomMemberListView\x12\x14\n\x05start\x18\x03\x20\x01(\x05R\x05start\x12\
    \x10\n\x03end\x18\x04\x20\x01(\x05R\x03end\x12\x1f\n\x0btotal_count\x18\
    \x05\x20\x01(\x05R\ntotalCount\x12u\n\x13client_changenumber\x18\x06\x20\
    \x01(\x05R\x12clientChangenumberBD\x82\xb5\x18@Value\x20sent\x20by\x20th\
    e\x20client\x20on\x20the\x20last\x20UpdateMemberListView\x20call.\x20\
    \x12y\n\x13server_changenumber\x18\x07\x20\x01(\x05R\x12serverChangenumb\
    erBH\x82\xb5\x18DValue\x20incremented\x20by\x20the\x20server\x20on\x20ea\
    ch\x20MemberListViewUpdated\x20call.\x20\"h\n\x1cCChatRoomMemberSummaryC\
    ounts\x12\x16\n\x06ingame\x18\x01\x20\x01(\x05R\x06ingame\x12\x16\n\x06o\
    nline\x18\x02\x20\x01(\x05R\x06online\x12\x18\n\x07offline\x18\x03\x20\
    \x01(\x05R\x07offline\"\xfe\x04\n2CChatRoomClient_MemberListViewUpdated_\
    Notification\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\
    \x12U\n\x07view_id\x18\x02\x20\x01(\x04R\x06viewIdB<\x82\xb5\x188Thew\
    \x20view_id\x20supplied\x20when\x20the\x20client\x20created\x20the\x20vi\
    ew.\x20\x12,\n\x04view\x18\x03\x20\x01(\x0b2\x18.CChatRoomMemberListView\
    R\x04view\x12a\n\x07members\x18\x04\x20\x03(\x0b2G.CChatRoomClient_Membe\
    rListViewUpdated_Notification.MemberListViewEntryR\x07members\x12!\n\x0c\
    status_flags\x18\x05\x20\x01(\rR\x0bstatusFlags\x12D\n\x0emember_summary\
    \x18\x06\x20\x01(\x0b2\x1d.CChatRoomMemberSummaryCountsR\rmemberSummary\
    \x12O\n\x13subscribed_personas\x18\x07\x20\x03(\x0b2\x1e.CMsgClientPerso\
    naState.FriendR\x12subscribedPersonas\x1a\x81\x01\n\x13MemberListViewEnt\
    ry\x12\x12\n\x04rank\x18\x01\x20\x01(\x05R\x04rank\x12\x1c\n\taccountid\
    \x18\x02\x20\x01(\rR\taccountid\x128\n\x07persona\x18\x03\x20\x01(\x0b2\
    \x1e.CMsgClientPersonaState.FriendR\x07persona\"\xe3\x02\n&CChatRoom_Mes\
    sageReaction_Notification\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\
    \x0bchatGroupId\x12\x17\n\x07chat_id\x18\x02\x20\x01(\x04R\x06chatId\x12\
    )\n\x10server_timestamp\x18\x03\x20\x01(\rR\x0fserverTimestamp\x12\x18\n\
    \x07ordinal\x18\x04\x20\x01(\rR\x07ordinal\x12\x18\n\x07reactor\x18\x05\
    \x20\x01(\x06R\x07reactor\x12j\n\rreaction_type\x18\x06\x20\x01(\x0e2\
    \x1d.EChatRoomMessageReactionType:&k_EChatRoomMessageReactionType_Invali\
    dR\x0creactionType\x12\x1a\n\x08reaction\x18\x07\x20\x01(\tR\x08reaction\
    \x12\x15\n\x06is_add\x18\x08\x20\x01(\x08R\x05isAdd\"\xe6!\n2CChatUsabil\
    ity_ClientUsabilityMetrics_Notification\x12$\n\x0emetrics_run_id\x18\x01\
    \x20\x01(\rR\x0cmetricsRunId\x12!\n\x0cclient_build\x18\x02\x20\x01(\rR\
    \x0bclientBuild\x12'\n\x0fmetrics_version\x18\x03\x20\x01(\rR\x0emetrics\
    Version\x12\x15\n\x06in_web\x18\x04\x20\x01(\x08R\x05inWeb\x12X\n\x08set\
    tings\x18\n\x20\x01(\x0b2<.CChatUsability_ClientUsabilityMetrics_Notific\
    ation.SettingsR\x08settings\x12h\n\x0evoice_settings\x18\x0b\x20\x01(\
    \x0b2A.CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettingsR\
    \rvoiceSettings\x12V\n\x08ui_state\x18\x0c\x20\x01(\x0b2;.CChatUsability\
    _ClientUsabilityMetrics_Notification.UIStateR\x07uiState\x12U\n\x07metri\
    cs\x18\r\x20\x01(\x0b2;.CChatUsability_ClientUsabilityMetrics_Notificati\
    on.MetricsR\x07metrics\x1a\xa1\x0b\n\x08Settings\x12:\n\x19notifications\
    _show_ingame\x18\x01\x20\x01(\x08R\x17notificationsShowIngame\x12:\n\x19\
    notifications_show_online\x18\x02\x20\x01(\x08R\x17notificationsShowOnli\
    ne\x12<\n\x1anotifications_show_message\x18\x03\x20\x01(\x08R\x18notific\
    ationsShowMessage\x12S\n&notifications_events_and_announcements\x18\x04\
    \x20\x01(\x08R#notificationsEventsAndAnnouncements\x12,\n\x12sounds_play\
    _ingame\x18\x05\x20\x01(\x08R\x10soundsPlayIngame\x12,\n\x12sounds_play_\
    online\x18\x06\x20\x01(\x08R\x10soundsPlayOnline\x12.\n\x13sounds_play_m\
    essage\x18\x07\x20\x01(\x08R\x11soundsPlayMessage\x12E\n\x1fsounds_event\
    s_and_announcements\x18\x08\x20\x01(\x08R\x1csoundsEventsAndAnnouncement\
    s\x123\n\x16always_new_chat_window\x18\t\x20\x01(\x08R\x13alwaysNewChatW\
    indow\x12E\n\x1fforce_alphabetic_friend_sorting\x18\n\x20\x01(\x08R\x1cf\
    orceAlphabeticFriendSorting\x12&\n\x0fchat_flash_mode\x18\x0b\x20\x01(\
    \x05R\rchatFlashMode\x12.\n\x13remember_open_chats\x18\x0c\x20\x01(\x08R\
    \x11rememberOpenChats\x120\n\x14compact_quick_access\x18\r\x20\x01(\x08R\
    \x12compactQuickAccess\x120\n\x14compact_friends_list\x18\x0e\x20\x01(\
    \x08R\x12compactFriendsList\x12X\n)notifications_show_chat_room_notifica\
    tion\x18\x0f\x20\x01(\x08R%notificationsShowChatRoomNotification\x12J\n\
    \"sounds_play_chat_room_notification\x18\x10\x20\x01(\x08R\x1esoundsPlay\
    ChatRoomNotification\x12I\n\"hide_offline_friends_in_tag_groups\x18\x11\
    \x20\x01(\x08R\x1dhideOfflineFriendsInTagGroups\x128\n\x18hide_categoriz\
    ed_friends\x18\x12\x20\x01(\x08R\x16hideCategorizedFriends\x12I\n\"categ\
    orize_in_game_friends_by_game\x18\x13\x20\x01(\x08R\x1dcategorizeInGameF\
    riendsByGame\x12$\n\x0echat_font_size\x18\x14\x20\x01(\x05R\x0cchatFontS\
    ize\x12'\n\x0fuse24hour_clock\x18\x15\x20\x01(\x08R\x0euse24hourClock\
    \x12-\n\x13do_not_disturb_mode\x18\x16\x20\x01(\x08R\x10doNotDisturbMode\
    \x124\n\x16disable_embed_inlining\x18\x17\x20\x01(\x08R\x14disableEmbedI\
    nlining\x12*\n\x11sign_into_friends\x18\x18\x20\x01(\x08R\x0fsignIntoFri\
    ends\x12)\n\x10animated_avatars\x18\x19\x20\x01(\x08R\x0fanimatedAvatars\
    \x1a\xcf\x04\n\rVoiceSettings\x12(\n\x10voice_input_gain\x18\x01\x20\x01\
    (\x02R\x0evoiceInputGain\x12*\n\x11voice_output_gain\x18\x02\x20\x01(\
    \x02R\x0fvoiceOutputGain\x12(\n\x10noise_gate_level\x18\x03\x20\x01(\x05\
    R\x0enoiseGateLevel\x12=\n\x1bvoice_use_echo_cancellation\x18\x04\x20\
    \x01(\x08R\x18voiceUseEchoCancellation\x12?\n\x1cvoice_use_noise_cancell\
    ation\x18\x05\x20\x01(\x08R\x19voiceUseNoiseCancellation\x12<\n\x1bvoice\
    _use_auto_gain_control\x18\x06\x20\x01(\x08R\x17voiceUseAutoGainControl\
    \x127\n\x18selected_non_default_mic\x18\x07\x20\x01(\x08R\x15selectedNon\
    DefaultMic\x12=\n\x1bselected_non_default_output\x18\x08\x20\x01(\x08R\
    \x18selectedNonDefaultOutput\x12/\n\x14push_to_talk_enabled\x18\t\x20\
    \x01(\x08R\x11pushToTalkEnabled\x12/\n\x14push_to_mute_enabled\x18\n\x20\
    \x01(\x08R\x11pushToMuteEnabled\x12&\n\x0fplay_ptt_sounds\x18\x0b\x20\
    \x01(\x08R\rplayPttSounds\x1a\xaa\t\n\x07UIState\x12.\n\x13friends_list_\
    height\x18\x01\x20\x01(\x05R\x11friendsListHeight\x12,\n\x12friends_list\
    _width\x18\x02\x20\x01(\x05R\x10friendsListWidth\x12.\n\x13friends_list_\
    docked\x18\x03\x20\x01(\x08R\x11friendsListDocked\x124\n\x16friends_list\
    _collapsed\x18\x04\x20\x01(\x08R\x14friendsListCollapsed\x12D\n\x1ffrien\
    ds_list_group_chats_height\x18\x05\x20\x01(\x05R\x1bfriendsListGroupChat\
    sHeight\x120\n\x14friends_list_visible\x18\x06\x20\x01(\x08R\x12friendsL\
    istVisible\x12,\n\x12chat_popups_opened\x18\x07\x20\x01(\x05R\x10chatPop\
    upsOpened\x123\n\x16group_chat_tabs_opened\x18\x08\x20\x01(\x05R\x13grou\
    pChatTabsOpened\x125\n\x17friend_chat_tabs_opened\x18\t\x20\x01(\x05R\
    \x14friendChatTabsOpened\x12*\n\x11chat_window_width\x18\n\x20\x01(\x05R\
    \x0fchatWindowWidth\x12,\n\x12chat_window_height\x18\x0b\x20\x01(\x05R\
    \x10chatWindowHeight\x12~\n\x11category_collapse\x18\x0c\x20\x01(\x0b2Q.\
    CChatUsability_ClientUsabilityMetrics_Notification.UIState.CategoryColla\
    pseStateR\x10categoryCollapse\x12@\n\x1dgroup_chat_left_col_collapsed\
    \x18\r\x20\x01(\x05R\x19groupChatLeftColCollapsed\x12B\n\x1egroup_chat_r\
    ight_col_collapsed\x18\x0e\x20\x01(\x05R\x1agroupChatRightColCollapsed\
    \x125\n\x18in_one_on_one_voice_chat\x18\x0f\x20\x01(\x08R\x13inOneOnOneV\
    oiceChat\x12-\n\x13in_group_voice_chat\x18\x10\x20\x01(\x08R\x10inGroupV\
    oiceChat\x1a\x82\x02\n\x15CategoryCollapseState\x12*\n\x11in_game_collap\
    sed\x18\x01\x20\x01(\x08R\x0finGameCollapsed\x12)\n\x10online_collapsed\
    \x18\x02\x20\x01(\x08R\x0fonlineCollapsed\x12+\n\x11offline_collapsed\
    \x18\x03\x20\x01(\x08R\x10offlineCollapsed\x122\n\x15game_groups_collaps\
    ed\x18\x04\x20\x01(\x05R\x13gameGroupsCollapsed\x121\n\x14categories_col\
    lapsed\x18\x05\x20\x01(\x05R\x13categoriesCollapsed\x1a\x90\x04\n\x07Met\
    rics\x12#\n\rfriends_count\x18\x01\x20\x01(\x05R\x0cfriendsCount\x124\n\
    \x16friends_category_count\x18\x02\x20\x01(\x05R\x14friendsCategoryCount\
    \x12:\n\x19friends_categorized_count\x18\x03\x20\x01(\x05R\x17friendsCat\
    egorizedCount\x120\n\x14friends_online_count\x18\x04\x20\x01(\x05R\x12fr\
    iendsOnlineCount\x121\n\x15friends_in_game_count\x18\x05\x20\x01(\x05R\
    \x12friendsInGameCount\x12D\n\x1ffriends_in_game_singleton_count\x18\x06\
    \x20\x01(\x05R\x1bfriendsInGameSingletonCount\x12(\n\x10game_group_count\
    \x18\x07\x20\x01(\x05R\x0egameGroupCount\x124\n\x16friends_favorite_coun\
    t\x18\x08\x20\x01(\x05R\x14friendsFavoriteCount\x12(\n\x10group_chat_cou\
    nt\x18\t\x20\x01(\x05R\x0egroupChatCount\x129\n\x19group_chat_favorite_c\
    ount\x18\n\x20\x01(\x05R\x16groupChatFavoriteCount\"a\n9CChatUsability_R\
    equestClientUsabilityMetrics_Notification\x12$\n\x0emetrics_run_id\x18\
    \x01\x20\x01(\rR\x0cmetricsRunId*\x9c\x01\n\x12EChatRoomJoinState\x12\
    \x20\n\x1ck_EChatRoomJoinState_Default\x10\0\x12\x1d\n\x19k_EChatRoomJoi\
    nState_None\x10\x01\x12\x1f\n\x1bk_EChatRoomJoinState_Joined\x10\x02\x12\
    $\n\x20k_EChatRoomJoinState_TestInvalid\x10c*\xa4\x02\n\x12EChatRoomGrou\
    pRank\x12\x20\n\x1ck_EChatRoomGroupRank_Default\x10\0\x12\x1f\n\x1bk_ECh\
    atRoomGroupRank_Viewer\x10\n\x12\x1e\n\x1ak_EChatRoomGroupRank_Guest\x10\
    \x0f\x12\x1f\n\x1bk_EChatRoomGroupRank_Member\x10\x14\x12\"\n\x1ek_EChat\
    RoomGroupRank_Moderator\x10\x1e\x12\x20\n\x1ck_EChatRoomGroupRank_Office\
    r\x10(\x12\x1e\n\x1ak_EChatRoomGroupRank_Owner\x102\x12$\n\x20k_EChatRoo\
    mGroupRank_TestInvalid\x10c*\xf4\x01\n\x1aEChatRoomNotificationLevel\x12\
    (\n$k_EChatroomNotificationLevel_Invalid\x10\0\x12%\n!k_EChatroomNotific\
    ationLevel_None\x10\x01\x12*\n&k_EChatroomNotificationLevel_MentionMe\
    \x10\x02\x12+\n'k_EChatroomNotificationLevel_MentionAll\x10\x03\x12,\n(k\
    _EChatroomNotificationLevel_AllMessages\x10\x04*\x97\x03\n\x16EChatRoomS\
    erverMessage\x12\x20\n\x1ck_EChatRoomServerMsg_Invalid\x10\0\x12'\n#k_EC\
    hatRoomServerMsg_RenameChatRoom\x10\x01\x12\x1f\n\x1bk_EChatRoomServerMs\
    g_Joined\x10\x02\x12\x1f\n\x1bk_EChatRoomServerMsg_Parted\x10\x03\x12\
    \x1f\n\x1bk_EChatRoomServerMsg_Kicked\x10\x04\x12\x20\n\x1ck_EChatRoomSe\
    rverMsg_Invited\x10\x05\x12(\n$k_EChatRoomServerMsg_InviteDismissed\x10\
    \x08\x12/\n+k_EChatRoomServerMsg_ChatRoomTaglineChanged\x10\t\x12.\n*k_E\
    ChatRoomServerMsg_ChatRoomAvatarChanged\x10\n\x12\"\n\x1ek_EChatRoomServ\
    erMsg_AppCustom\x10\x0b*w\n\x1cEChatRoomMessageReactionType\x12*\n&k_ECh\
    atRoomMessageReactionType_Invalid\x10\0\x12+\n'k_EChatRoomMessageReactio\
    nType_Emoticon\x10\x01*\xcb\x03\n\x1aEChatRoomMemberStateChange\x12(\n$k\
    _EChatRoomMemberStateChange_Invalid\x10\0\x12'\n#k_EChatRoomMemberStateC\
    hange_Joined\x10\x01\x12'\n#k_EChatRoomMemberStateChange_Parted\x10\x02\
    \x12'\n#k_EChatRoomMemberStateChange_Kicked\x10\x03\x12(\n$k_EChatRoomMe\
    mberStateChange_Invited\x10\x04\x12,\n(k_EChatRoomMemberStateChange_Rank\
    Changed\x10\x07\x120\n,k_EChatRoomMemberStateChange_InviteDismissed\x10\
    \x08\x12&\n\"k_EChatRoomMemberStateChange_Muted\x10\t\x12'\n#k_EChatRoom\
    MemberStateChange_Banned\x10\n\x12-\n)k_EChatRoomMemberStateChange_Roles\
    Changed\x10\x0c2\x8b\x02\n\x04Chat\x12\xe7\x01\n\x1aRequestFriendPersona\
    States\x12).CChat_RequestFriendPersonaStates_Request\x1a*.CChat_RequestF\
    riendPersonaStates_Response\"r\x82\xb5\x18nRequest\x20to\x20be\x20notifi\
    ed\x20of\x20online\x20friend\x20persona\x20state\x20information.\x20\x20\
    Responses\x20sent\x20via\x20CMsgClientPersonaState.\x1a\x19\x82\xb5\x18\
    \x15Chat-related\x20services2\xb9>\n\x08ChatRoom\x12\xa3\x01\n\x13Create\
    ChatRoomGroup\x12&.CChatRoom_CreateChatRoomGroup_Request\x1a'.CChatRoom_\
    CreateChatRoomGroup_Response\";\x82\xb5\x187Create's\x20a\x20chat\x20gro\
    up\x20that\x20can\x20contain\x20other\x20chat\x20rooms\x12z\n\x11SaveCha\
    tRoomGroup\x12$.CChatRoom_SaveChatRoomGroup_Request\x1a%.CChatRoom_SaveC\
    hatRoomGroup_Response\"\x18\x82\xb5\x18\x14Saves's\x20a\x20chat\x20group\
    \x12\x84\x01\n\x13RenameChatRoomGroup\x12&.CChatRoom_RenameChatRoomGroup\
    _Request\x1a'.CChatRoom_RenameChatRoomGroup_Response\"\x1c\x82\xb5\x18\
    \x18Rename\x20a\x20chat\x20room\x20group\x12\x99\x01\n\x17SetChatRoomGro\
    upTagline\x12*.CChatRoom_SetChatRoomGroupTagline_Request\x1a+.CChatRoom_\
    SetChatRoomGroupTagline_Response\"%\x82\xb5\x18!Set\x20tagline\x20for\
    \x20a\x20chat\x20room\x20group\x12\x99\x01\n\x16SetChatRoomGroupAvatar\
    \x12).CChatRoom_SetChatRoomGroupAvatar_Request\x1a*.CChatRoom_SetChatRoo\
    mGroupAvatar_Response\"(\x82\xb5\x18$Set\x20avatar\x20SHA\x20for\x20a\
    \x20chat\x20room\x20group\x12\xcb\x01\n!SetChatRoomGroupWatchingBroadcas\
    t\x124.CChatRoom_SetChatRoomGroupWatchingBroadcast_Request\x1a5.CChatRoo\
    m_SetChatRoomGroupWatchingBroadcast_Response\"9\x82\xb5\x185Sets\x20a\
    \x20broadcast\x20that\x20the\x20chat\x20room\x20group\x20is\x20watching\
    \x12\xe3\x01\n\x1cJoinMiniGameForChatRoomGroup\x12/.CChatRoom_JoinMiniGa\
    meForChatRoomGroup_Request\x1a0.CChatRoom_JoinMiniGameForChatRoomGroup_R\
    esponse\"`\x82\xb5\x18\\Joins\x20the\x20minigame\x20for\x20the\x20chat\
    \x20room\x20group\x20or\x20starts\x20a\x20new\x20one\x20(Winter\x202019\
    \x20sale\x20party\x20game)\x12\xac\x01\n\x1bEndMiniGameForChatRoomGroup\
    \x12..CChatRoom_EndMiniGameForChatRoomGroup_Request\x1a/.CChatRoom_EndMi\
    niGameForChatRoomGroup_Response\",\x82\xb5\x18(Ends\x20the\x20minigame\
    \x20in\x20the\x20chat\x20room\x20group\x12d\n\x0fMuteUserInGroup\x12\x1b\
    .CChatRoom_MuteUser_Request\x1a\x1c.CChatRoom_MuteUser_Response\"\x16\
    \x82\xb5\x18\x12Mute\x20user\x20in\x20group\x12h\n\x11KickUserFromGroup\
    \x12\x1b.CChatRoom_KickUser_Request\x1a\x1c.CChatRoom_KickUser_Response\
    \"\x18\x82\xb5\x18\x14Kick\x20user\x20from\x20group\x12y\n\x0fSetUserBan\
    State\x12\".CChatRoom_SetUserBanState_Request\x1a#.CChatRoom_SetUserBanS\
    tate_Response\"\x1d\x82\xb5\x18\x19Ban/unban\x20user\x20from\x20group\
    \x12\x82\x01\n\x13RevokeInviteToGroup\x12\x1f.CChatRoom_RevokeInvite_Req\
    uest\x1a\x20.CChatRoom_RevokeInvite_Response\"(\x82\xb5\x18$Revoke\x20a\
    \x20direct\x20invitation\x20of\x20a\x20user\x12e\n\nCreateRole\x12\x1d.C\
    ChatRoom_CreateRole_Request\x1a\x1e.CChatRoom_CreateRole_Response\"\x18\
    \x82\xb5\x18\x14Create\x20role\x20for\x20goup\x12a\n\x08GetRoles\x12\x1b\
    .CChatRoom_GetRoles_Request\x1a\x1c.CChatRoom_GetRoles_Response\"\x1a\
    \x82\xb5\x18\x16Get\x20all\x20roles\x20in\x20group\x12e\n\nRenameRole\
    \x12\x1d.CChatRoom_RenameRole_Request\x1a\x1e.CChatRoom_RenameRole_Respo\
    nse\"\x18\x82\xb5\x18\x14Rename\x20role\x20for\x20goup\x12l\n\x0bReorder\
    Role\x12\x1e.CChatRoom_ReorderRole_Request\x1a\x1f.CChatRoom_ReorderRole\
    _Response\"\x1c\x82\xb5\x18\x18Reorder\x20role\x20with\x20a\x20goup\x12g\
    \n\nDeleteRole\x12\x1d.CChatRoom_DeleteRole_Request\x1a\x1e.CChatRoom_De\
    leteRole_Response\"\x1a\x82\xb5\x18\x16Delete\x20role\x20from\x20group\
    \x12\x87\x01\n\x0eGetRoleActions\x12!.CChatRoom_GetRoleActions_Request\
    \x1a\".CChatRoom_GetRoleActions_Response\".\x82\xb5\x18*Get\x20all\x20de\
    fined\x20roles\x20and\x20actions\x20in\x20group\x12\x86\x01\n\x12Replace\
    RoleActions\x12%.CChatRoom_ReplaceRoleActions_Request\x1a&.CChatRoom_Rep\
    laceRoleActions_Response\"!\x82\xb5\x18\x1dReplace\x20role\x20actions\
    \x20in\x20group\x12s\n\rAddRoleToUser\x12\x20.CChatRoom_AddRoleToUser_Re\
    quest\x1a!.CChatRoom_AddRoleToUser_Response\"\x1d\x82\xb5\x18\x19Add\x20\
    role\x20to\x20user\x20in\x20group\x12\x87\x01\n\x0fGetRolesForUser\x12\"\
    .CChatRoom_GetRolesForUser_Request\x1a#.CChatRoom_GetRolesForUser_Respon\
    se\"+\x82\xb5\x18'Get\x20all\x20roles\x20assigned\x20to\x20user\x20in\
    \x20group\x12\x87\x01\n\x12DeleteRoleFromUser\x12%.CChatRoom_DeleteRoleF\
    romUser_Request\x1a&.CChatRoom_DeleteRoleFromUser_Response\"\"\x82\xb5\
    \x18\x1eDelete\x20role\x20from\x20user\x20in\x20group\x12\x81\x01\n\x11J\
    oinChatRoomGroup\x12$.CChatRoom_JoinChatRoomGroup_Request\x1a%.CChatRoom\
    _JoinChatRoomGroup_Response\"\x1f\x82\xb5\x18\x1bJoin\x20a\x20multi-user\
    \x20chat\x20room\x12\xad\x01\n\x1bInviteFriendToChatRoomGroup\x12..CChat\
    Room_InviteFriendToChatRoomGroup_Request\x1a/.CChatRoom_InviteFriendToCh\
    atRoomGroup_Response\"-\x82\xb5\x18)Invite\x20a\x20friend\x20to\x20a\x20\
    multi-user\x20chat\x20room\x12\x97\x01\n\x12LeaveChatRoomGroup\x12%.CCha\
    tRoom_LeaveChatRoomGroup_Request\x1a&.CChatRoom_LeaveChatRoomGroup_Respo\
    nse\"2\x82\xb5\x18.Leaves\x20a\x20chat\x20room\x20group\x20and\x20all\
    \x20related\x20chats\x12\x89\x01\n\x0eCreateChatRoom\x12!.CChatRoom_Crea\
    teChatRoom_Request\x1a\".CChatRoom_CreateChatRoom_Response\"0\x82\xb5\
    \x18,Creates\x20a\x20chat\x20room\x20inside\x20a\x20chat\x20room\x20grou\
    p\x12\x89\x01\n\x0eDeleteChatRoom\x12!.CChatRoom_DeleteChatRoom_Request\
    \x1a\".CChatRoom_DeleteChatRoom_Response\"0\x82\xb5\x18,Deletes\x20a\x20\
    chat\x20room\x20inside\x20a\x20chat\x20room\x20group\x12\x89\x01\n\x0eRe\
    nameChatRoom\x12!.CChatRoom_RenameChatRoom_Request\x1a\".CChatRoom_Renam\
    eChatRoom_Response\"0\x82\xb5\x18,Renames\x20a\x20chat\x20room\x20inside\
    \x20a\x20chat\x20room\x20group\x12\x8d\x01\n\x0fReorderChatRoom\x12\".CC\
    hatRoom_ReorderChatRoom_Request\x1a#.CChatRoom_ReorderChatRoom_Response\
    \"1\x82\xb5\x18-Reorders\x20a\x20chat\x20room\x20inside\x20a\x20chat\x20\
    room\x20group\x12\x8d\x01\n\x0fSendChatMessage\x12\".CChatRoom_SendChatM\
    essage_Request\x1a#.CChatRoom_SendChatMessage_Response\"1\x82\xb5\x18-Se\
    nd\x20a\x20chat\x20message\x20to\x20a\x20multi-user\x20chat\x20room\x12\
    \xa7\x01\n\rJoinVoiceChat\x12\x20.CChatRoom_JoinVoiceChat_Request\x1a!.C\
    ChatRoom_JoinVoiceChat_Response\"Q\x82\xb5\x18MJoin\x20the\x20voice\x20c\
    hat\x20in\x20a\x20multi-room\x20chat\x20(should\x20already\x20be\x20in\
    \x20the\x20chat\x20room)\x12\x86\x01\n\x0eLeaveVoiceChat\x12!.CChatRoom_\
    LeaveVoiceChat_Request\x1a\".CChatRoom_LeaveVoiceChat_Response\"-\x82\
    \xb5\x18)Leave\x20the\x20voice\x20chat\x20in\x20a\x20multi-room\x20chat\
    \x12\xc3\x01\n\x11GetMessageHistory\x12$.CChatRoom_GetMessageHistory_Req\
    uest\x1a%.CChatRoom_GetMessageHistory_Response\"a\x82\xb5\x18]Get\x20the\
    \x20history\x20of\x20messages\x20in\x20a\x20chat\x20room.\x20\x20You\x20\
    must\x20currently\x20be\x20a\x20member\x20of\x20the\x20chat\x20room.\x12\
    \x88\x01\n\x13GetMyChatRoomGroups\x12&.CChatRoom_GetMyChatRoomGroups_Req\
    uest\x1a'.CChatRoom_GetMyChatRoomGroups_Response\"\x20\x82\xb5\x18\x1cGe\
    t\x20a\x20list\x20of\x20our\x20chat\x20rooms\x12\x9a\x01\n\x15GetChatRoo\
    mGroupState\x12(.CChatRoom_GetChatRoomGroupState_Request\x1a).CChatRoom_\
    GetChatRoomGroupState_Response\",\x82\xb5\x18(Get\x20information\x20abou\
    t\x20a\x20single\x20chat\x20room\x12\xa5\x01\n\x17GetChatRoomGroupSummar\
    y\x12*.CChatRoom_GetChatRoomGroupSummary_Request\x1a+.CChatRoom_GetChatR\
    oomGroupSummary_Response\"1\x82\xb5\x18-Get\x20basic\x20information\x20a\
    bout\x20a\x20chat\x20room\x20group\x12\xd3\x01\n\x1eSetAppChatRoomGroupF\
    orceActive\x121.CChatRoom_SetAppChatRoomGroupForceActive_Request\x1a2.CC\
    hatRoom_SetAppChatRoomGroupForceActive_Response\"J\x82\xb5\x18FForce\x20\
    a\x20group\x20chat\x20to\x20be\x20considered\x20active\x20on\x20the\x20s\
    erver\x20for\x20this\x20user\x12\xd3\x01\n\"SetAppChatRoomGroupStopForce\
    Active\x12:.CChatRoom_SetAppChatRoomGroupStopForceActive_Notification\
    \x1a\x0b.NoResponse\"d\x82\xb5\x18`If\x20a\x20group\x20chat\x20is\x20for\
    ced\x20active\x20(see\x20SetAppChatRoomGroupForceActive),\x20decrement\
    \x20the\x20force\x20count\x12\x8f\x01\n\x0eAckChatMessage\x12&.CChatRoom\
    _AckChatMessage_Notification\x1a\x0b.NoResponse\"H\x82\xb5\x18DAcknowled\
    ge\x20that\x20we\x20have\x20seen\x20the\x20most\x20recent\x20chat\x20mes\
    sage\x20in\x20a\x20chat\x12\x81\x01\n\x10CreateInviteLink\x12#.CChatRoom\
    _CreateInviteLink_Request\x1a$.CChatRoom_CreateInviteLink_Response\"\"\
    \x82\xb5\x18\x1eCreates\x20a\x20chatroom\x20invite\x20link\x12\x90\x01\n\
    \x11GetInviteLinkInfo\x12$.CChatRoom_GetInviteLinkInfo_Request\x1a%.CCha\
    tRoom_GetInviteLinkInfo_Response\".\x82\xb5\x18*Returns\x20chat\x20room\
    \x20info\x20about\x20provided\x20link\x12\xaa\x01\n\rGetInviteInfo\x12\
    \x20.CChatRoom_GetInviteInfo_Request\x1a!.CChatRoom_GetInviteInfo_Respon\
    se\"T\x82\xb5\x18PReturns\x20chat\x20room\x20info\x20about\x20any\x20inv\
    ite\x20involving\x20the\x20sender\x20and\x20passed\x20group\x20id\x12\
    \xa5\x01\n\x16GetInviteLinksForGroup\x12).CChatRoom_GetInviteLinksForGro\
    up_Request\x1a*.CChatRoom_GetInviteLinksForGroup_Response\"4\x82\xb5\x18\
    0Returns\x20all\x20invite\x20links\x20for\x20the\x20specified\x20group\
    \x12\x8b\x01\n\nGetBanList\x12\x1d.CChatRoom_GetBanList_Request\x1a\x1e.\
    CChatRoom_GetBanList_Response\">\x82\xb5\x18:Gets\x20a\x20list\x20of\x20\
    users\x20who\x20have\x20been\x20banned\x20from\x20a\x20chat\x20room\x12\
    \x93\x01\n\rGetInviteList\x12\x20.CChatRoom_GetInviteList_Request\x1a!.C\
    ChatRoom_GetInviteList_Response\"=\x82\xb5\x189Gets\x20a\x20list\x20of\
    \x20users\x20who\x20have\x20been\x20invited\x20to\x20a\x20chat\x20room\
    \x12\x80\x01\n\x10DeleteInviteLink\x12#.CChatRoom_DeleteInviteLink_Reque\
    st\x1a$.CChatRoom_DeleteInviteLink_Response\"!\x82\xb5\x18\x1dDeletes\
    \x20specified\x20invite\x20link\x12\xc4\x01\n\x1eSetSessionActiveChatRoo\
    mGroups\x121.CChatRoom_SetSessionActiveChatRoomGroups_Request\x1a2.CChat\
    Room_SetSessionActiveChatRoomGroups_Response\";\x82\xb5\x187Set\x20which\
    \x20chat\x20rooms\x20we\x20are\x20using\x20in\x20the\x20active\x20sessio\
    n\x12\xb9\x01\n\x1bSetUserChatGroupPreferences\x12..CChatRoom_SetUserCha\
    tGroupPreferences_Request\x1a/.CChatRoom_SetUserChatGroupPreferences_Res\
    ponse\"9\x82\xb5\x185Set\x20preferences\x20around\x20chat\x20notificatio\
    ns\x20for\x20a\x20group\x12\x88\x01\n\x12DeleteChatMessages\x12%.CChatRo\
    om_DeleteChatMessages_Request\x1a&.CChatRoom_DeleteChatMessages_Response\
    \"#\x82\xb5\x18\x1fDeletes\x20specified\x20chat\x20messages\x12\x9a\x01\
    \n\x14UpdateMemberListView\x12,.CChatRoom_UpdateMemberListView_Notificat\
    ion\x1a\x0b.NoResponse\"G\x82\xb5\x18CA\x20client\x20is\x20indicating\
    \x20it\x20has\x20an\x20active\x20view\x20into\x20the\x20members\x20list.\
    \x12{\n\rSearchMembers\x12\x20.CChatRoom_SearchMembers_Request\x1a!.CCha\
    tRoom_SearchMembers_Response\"%\x82\xb5\x18!Search\x20chat\x20room\x20me\
    mbers\x20by\x20name.\x12\xa5\x01\n\x15UpdateMessageReaction\x12(.CChatRo\
    om_UpdateMessageReaction_Request\x1a).CChatRoom_UpdateMessageReaction_Re\
    sponse\"7\x82\xb5\x183Adds/removes\x20a\x20reaction\x20to/from\x20a\x20c\
    hat\x20room\x20message\x12\xb4\x01\n\x1aGetMessageReactionReactors\x12-.\
    CChatRoom_GetMessageReactionReactors_Request\x1a..CChatRoom_GetMessageRe\
    actionReactors_Response\"7\x82\xb5\x183Fetches\x20a\x20list\x20of\x20rea\
    ctors\x20for\x20a\x20specified\x20reaction\x1aB\x82\xb5\x18>Service\x20f\
    or\x20joining,\x20managing,\x20and\x20using\x20multi-user\x20chat\x20roo\
    ms2\xae\x03\n\rClanChatRooms\x12\xb8\x01\n\x13GetClanChatRoomInfo\x12+.C\
    ClanChatRooms_GetClanChatRoomInfo_Request\x1a,.CClanChatRooms_GetClanCha\
    tRoomInfo_Response\"F\x82\xb5\x18BGet\x20a\x20list\x20of\x20chat\x20room\
    s\x20for\x20a\x20clan,\x20optionally\x20creating\x20a\x20new\x20one\x12\
    \xb2\x01\n\x16SetClanChatRoomPrivate\x12..CClanChatRooms_SetClanChatRoom\
    Private_Request\x1a/.CClanChatRooms_SetClanChatRoomPrivate_Response\"7\
    \x82\xb5\x183Set\x20a\x20clan\x20chat\x20room\x20to\x20be\x20members\x20\
    only\x20(or\x20public)\x1a-\x82\xb5\x18)Methods\x20for\x20getting\x20cla\
    n\x20chat\x20information2\xef\x0e\n\x0eChatRoomClient\x12{\n\x19NotifyIn\
    comingChatMessage\x12+.CChatRoom_IncomingChatMessage_Notification\x1a\
    \x0b.NoResponse\"$\x82\xb5\x18\x20New\x20chat\x20message\x20for\x20a\x20\
    chat\x20room\x12\x94\x01\n\x19NotifyChatMessageModified\x12+.CChatRoom_C\
    hatMessageModified_Notification\x1a\x0b.NoResponse\"=\x82\xb5\x189An\x20\
    existing\x20chat\x20message\x20has\x20been\x20modified\x20on\x20the\x20b\
    ackend\x12\x95\x01\n\x17NotifyMemberStateChange\x12).CChatRoom_MemberSta\
    teChange_Notification\x1a\x0b.NoResponse\"B\x82\xb5\x18>A\x20chat\x20roo\
    m\x20member's\x20state\x20has\x20changed\x20(join/part/permissions)\x12\
    \x88\x01\n\x1fNotifyChatRoomHeaderStateChange\x12+.CChatRoom_ChatRoomHea\
    derState_Notification\x1a\x0b.NoResponse\"+\x82\xb5\x18'Chat\x20Room\x20\
    header\x20/\x20metadata\x20has\x20changed\x12\xa6\x01\n\x1eNotifyChatRoo\
    mGroupRoomsChange\x120.CChatRoom_ChatRoomGroupRoomsChange_Notification\
    \x1a\x0b.NoResponse\"E\x82\xb5\x18ASomething\x20about\x20a\x20chatroom\
    \x20group\x20changed\x20(created,\x20deleted,\x20etc.)\x12\xd5\x01\n#Not\
    ifyShouldRejoinChatRoomVoiceChat\x12;.CChatRoom_NotifyShouldRejoinChatRo\
    omVoiceChat_Notification\x1a\x0b.NoResponse\"d\x82\xb5\x18`Voice\x20chat\
    \x20was\x20recreated\x20or\x20dropped\x20on\x20the\x20backend\x20and\x20\
    client\x20needs\x20to\x20rejoin\x20to\x20remain\x20in\x20chat.\x12\xb3\
    \x01\n\x1fNotifyChatGroupUserStateChanged\x12<.ChatRoomClient_NotifyChat\
    GroupUserStateChanged_Notification\x1a\x0b.NoResponse\"E\x82\xb5\x18AUse\
    r\x20chat\x20group\x20state\x20(preferences,\x20ack\x20state,\x20etc)\
    \x20have\x20changed.\x12\x8f\x01\n\x18NotifyAckChatMessageEcho\x12&.CCha\
    tRoom_AckChatMessage_Notification\x1a\x0b.NoResponse\">\x82\xb5\x18:A\
    \x20session\x20acked\x20an\x20unread\x20message,\x20echo\x20to\x20other\
    \x20sessions.\x12\xed\x01\n\x18NotifyChatRoomDisconnect\x125.ChatRoomCli\
    ent_NotifyChatRoomDisconnect_Notification\x1a\x0b.NoResponse\"\x8c\x01\
    \x82\xb5\x18\x87\x01The\x20ChatRoom\x20server\x20hosting\x20the\x20chat\
    \x20rooms\x20has\x20reconnected\x20to\x20the\x20user's\x20Chat\x20server\
    \x20(may\x20have\x20restarted),\x20client\x20should\x20refresh\x20state.\
    \x12\xd5\x01\n\x1bNotifyMemberListViewUpdated\x123.CChatRoomClient_Membe\
    rListViewUpdated_Notification\x1a\x0b.NoResponse\"t\x82\xb5\x18pThe\x20l\
    ist\x20of\x20members\x20for\x20a\x20chat\x20room\x20with\x20virtualized\
    \x20member\x20list\x20has\x20changed\x20on\x20the\x20server\x20(or\x20cl\
    ient\x20requested)\x12g\n\x15NotifyMessageReaction\x12'.CChatRoom_Messag\
    eReaction_Notification\x1a\x0b.NoResponse\"\x18\x82\xb5\x18\x14New\x20me\
    ssage\x20reaction\x1a,\x82\xb5\x18$Client\x20notifications\x20for\x20cha\
    t\x20events\xc0\xb5\x18\x022\xc2\x01\n\rChatUsability\x12\x86\x01\n\x1cN\
    otifyClientUsabilityMetrics\x123.CChatUsability_ClientUsabilityMetrics_N\
    otification\x1a\x0b.NoResponse\"$\x82\xb5\x18\x20Incoming\x20metrics\x20\
    from\x20the\x20client\x1a(\x82\xb5\x18$Client\x20notifications\x20for\
    \x20chat\x20events2\xe2\x01\n\x13ChatUsabilityClient\x12\x99\x01\n#Notif\
    yRequestClientUsabilityMetrics\x12:.CChatUsability_RequestClientUsabilit\
    yMetrics_Notification\x1a\x0b.NoResponse\")\x82\xb5\x18%Request\x20clien\
    t\x20send\x20usability\x20metrics\x1a/\x82\xb5\x18'Client\x20notificatio\
    ns\x20for\x20chat\x20usability\xc0\xb5\x18\x02B\x03\x80\x01\x01J\x8d\x82\
    \x03\n\x07\x12\x05\0\0\xfc\t\x01\n\t\n\x02\x03\0\x12\x03\0\06\n\t\n\x02\
    \x03\x01\x12\x03\x01\02\n\x08\n\x01\x08\x12\x03\x03\0\"\n\t\n\x02\x08\
    \x10\x12\x03\x03\0\"\n\n\n\x02\x05\0\x12\x04\x05\0\n\x01\n\n\n\x03\x05\0\
    \x01\x12\x03\x05\x05\x17\n\x0b\n\x04\x05\0\x02\0\x12\x03\x06\x08)\n\x0c\
    \n\x05\x05\0\x02\0\x01\x12\x03\x06\x08$\n\x0c\n\x05\x05\0\x02\0\x02\x12\
    \x03\x06'(\n\x0b\n\x04\x05\0\x02\x01\x12\x03\x07\x08&\n\x0c\n\x05\x05\0\
    \x02\x01\x01\x12\x03\x07\x08!\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03\x07$\
    %\n\x0b\n\x04\x05\0\x02\x02\x12\x03\x08\x08(\n\x0c\n\x05\x05\0\x02\x02\
    \x01\x12\x03\x08\x08#\n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03\x08&'\n\x0b\
    \n\x04\x05\0\x02\x03\x12\x03\t\x08.\n\x0c\n\x05\x05\0\x02\x03\x01\x12\
    \x03\t\x08(\n\x0c\n\x05\x05\0\x02\x03\x02\x12\x03\t+-\n\n\n\x02\x05\x01\
    \x12\x04\x0c\0\x15\x01\n\n\n\x03\x05\x01\x01\x12\x03\x0c\x05\x17\n\x0b\n\
    \x04\x05\x01\x02\0\x12\x03\r\x08)\n\x0c\n\x05\x05\x01\x02\0\x01\x12\x03\
    \r\x08$\n\x0c\n\x05\x05\x01\x02\0\x02\x12\x03\r'(\n\x0b\n\x04\x05\x01\
    \x02\x01\x12\x03\x0e\x08)\n\x0c\n\x05\x05\x01\x02\x01\x01\x12\x03\x0e\
    \x08#\n\x0c\n\x05\x05\x01\x02\x01\x02\x12\x03\x0e&(\n\x0b\n\x04\x05\x01\
    \x02\x02\x12\x03\x0f\x08(\n\x0c\n\x05\x05\x01\x02\x02\x01\x12\x03\x0f\
    \x08\"\n\x0c\n\x05\x05\x01\x02\x02\x02\x12\x03\x0f%'\n\x0b\n\x04\x05\x01\
    \x02\x03\x12\x03\x10\x08)\n\x0c\n\x05\x05\x01\x02\x03\x01\x12\x03\x10\
    \x08#\n\x0c\n\x05\x05\x01\x02\x03\x02\x12\x03\x10&(\n\x0b\n\x04\x05\x01\
    \x02\x04\x12\x03\x11\x08,\n\x0c\n\x05\x05\x01\x02\x04\x01\x12\x03\x11\
    \x08&\n\x0c\n\x05\x05\x01\x02\x04\x02\x12\x03\x11)+\n\x0b\n\x04\x05\x01\
    \x02\x05\x12\x03\x12\x08*\n\x0c\n\x05\x05\x01\x02\x05\x01\x12\x03\x12\
    \x08$\n\x0c\n\x05\x05\x01\x02\x05\x02\x12\x03\x12')\n\x0b\n\x04\x05\x01\
    \x02\x06\x12\x03\x13\x08(\n\x0c\n\x05\x05\x01\x02\x06\x01\x12\x03\x13\
    \x08\"\n\x0c\n\x05\x05\x01\x02\x06\x02\x12\x03\x13%'\n\x0b\n\x04\x05\x01\
    \x02\x07\x12\x03\x14\x08.\n\x0c\n\x05\x05\x01\x02\x07\x01\x12\x03\x14\
    \x08(\n\x0c\n\x05\x05\x01\x02\x07\x02\x12\x03\x14+-\n\n\n\x02\x05\x02\
    \x12\x04\x17\0\x1d\x01\n\n\n\x03\x05\x02\x01\x12\x03\x17\x05\x1f\n\x0b\n\
    \x04\x05\x02\x02\0\x12\x03\x18\x081\n\x0c\n\x05\x05\x02\x02\0\x01\x12\
    \x03\x18\x08,\n\x0c\n\x05\x05\x02\x02\0\x02\x12\x03\x18/0\n\x0b\n\x04\
    \x05\x02\x02\x01\x12\x03\x19\x08.\n\x0c\n\x05\x05\x02\x02\x01\x01\x12\
    \x03\x19\x08)\n\x0c\n\x05\x05\x02\x02\x01\x02\x12\x03\x19,-\n\x0b\n\x04\
    \x05\x02\x02\x02\x12\x03\x1a\x083\n\x0c\n\x05\x05\x02\x02\x02\x01\x12\
    \x03\x1a\x08.\n\x0c\n\x05\x05\x02\x02\x02\x02\x12\x03\x1a12\n\x0b\n\x04\
    \x05\x02\x02\x03\x12\x03\x1b\x084\n\x0c\n\x05\x05\x02\x02\x03\x01\x12\
    \x03\x1b\x08/\n\x0c\n\x05\x05\x02\x02\x03\x02\x12\x03\x1b23\n\x0b\n\x04\
    \x05\x02\x02\x04\x12\x03\x1c\x085\n\x0c\n\x05\x05\x02\x02\x04\x01\x12\
    \x03\x1c\x080\n\x0c\n\x05\x05\x02\x02\x04\x02\x12\x03\x1c34\n\n\n\x02\
    \x05\x03\x12\x04\x1f\0*\x01\n\n\n\x03\x05\x03\x01\x12\x03\x1f\x05\x1b\n\
    \x0b\n\x04\x05\x03\x02\0\x12\x03\x20\x08)\n\x0c\n\x05\x05\x03\x02\0\x01\
    \x12\x03\x20\x08$\n\x0c\n\x05\x05\x03\x02\0\x02\x12\x03\x20'(\n\x0b\n\
    \x04\x05\x03\x02\x01\x12\x03!\x080\n\x0c\n\x05\x05\x03\x02\x01\x01\x12\
    \x03!\x08+\n\x0c\n\x05\x05\x03\x02\x01\x02\x12\x03!./\n\x0b\n\x04\x05\
    \x03\x02\x02\x12\x03\"\x08(\n\x0c\n\x05\x05\x03\x02\x02\x01\x12\x03\"\
    \x08#\n\x0c\n\x05\x05\x03\x02\x02\x02\x12\x03\"&'\n\x0b\n\x04\x05\x03\
    \x02\x03\x12\x03#\x08(\n\x0c\n\x05\x05\x03\x02\x03\x01\x12\x03#\x08#\n\
    \x0c\n\x05\x05\x03\x02\x03\x02\x12\x03#&'\n\x0b\n\x04\x05\x03\x02\x04\
    \x12\x03$\x08(\n\x0c\n\x05\x05\x03\x02\x04\x01\x12\x03$\x08#\n\x0c\n\x05\
    \x05\x03\x02\x04\x02\x12\x03$&'\n\x0b\n\x04\x05\x03\x02\x05\x12\x03%\x08\
    )\n\x0c\n\x05\x05\x03\x02\x05\x01\x12\x03%\x08$\n\x0c\n\x05\x05\x03\x02\
    \x05\x02\x12\x03%'(\n\x0b\n\x04\x05\x03\x02\x06\x12\x03&\x081\n\x0c\n\
    \x05\x05\x03\x02\x06\x01\x12\x03&\x08,\n\x0c\n\x05\x05\x03\x02\x06\x02\
    \x12\x03&/0\n\x0b\n\x04\x05\x03\x02\x07\x12\x03'\x088\n\x0c\n\x05\x05\
    \x03\x02\x07\x01\x12\x03'\x083\n\x0c\n\x05\x05\x03\x02\x07\x02\x12\x03'6\
    7\n\x0b\n\x04\x05\x03\x02\x08\x12\x03(\x088\n\x0c\n\x05\x05\x03\x02\x08\
    \x01\x12\x03(\x082\n\x0c\n\x05\x05\x03\x02\x08\x02\x12\x03(57\n\x0b\n\
    \x04\x05\x03\x02\t\x12\x03)\x08,\n\x0c\n\x05\x05\x03\x02\t\x01\x12\x03)\
    \x08&\n\x0c\n\x05\x05\x03\x02\t\x02\x12\x03))+\n\n\n\x02\x05\x04\x12\x04\
    ,\0/\x01\n\n\n\x03\x05\x04\x01\x12\x03,\x05!\n\x0b\n\x04\x05\x04\x02\0\
    \x12\x03-\x083\n\x0c\n\x05\x05\x04\x02\0\x01\x12\x03-\x08.\n\x0c\n\x05\
    \x05\x04\x02\0\x02\x12\x03-12\n\x0b\n\x04\x05\x04\x02\x01\x12\x03.\x084\
    \n\x0c\n\x05\x05\x04\x02\x01\x01\x12\x03.\x08/\n\x0c\n\x05\x05\x04\x02\
    \x01\x02\x12\x03.23\n\n\n\x02\x05\x05\x12\x041\0<\x01\n\n\n\x03\x05\x05\
    \x01\x12\x031\x05\x1f\n\x0b\n\x04\x05\x05\x02\0\x12\x032\x081\n\x0c\n\
    \x05\x05\x05\x02\0\x01\x12\x032\x08,\n\x0c\n\x05\x05\x05\x02\0\x02\x12\
    \x032/0\n\x0b\n\x04\x05\x05\x02\x01\x12\x033\x080\n\x0c\n\x05\x05\x05\
    \x02\x01\x01\x12\x033\x08+\n\x0c\n\x05\x05\x05\x02\x01\x02\x12\x033./\n\
    \x0b\n\x04\x05\x05\x02\x02\x12\x034\x080\n\x0c\n\x05\x05\x05\x02\x02\x01\
    \x12\x034\x08+\n\x0c\n\x05\x05\x05\x02\x02\x02\x12\x034./\n\x0b\n\x04\
    \x05\x05\x02\x03\x12\x035\x080\n\x0c\n\x05\x05\x05\x02\x03\x01\x12\x035\
    \x08+\n\x0c\n\x05\x05\x05\x02\x03\x02\x12\x035./\n\x0b\n\x04\x05\x05\x02\
    \x04\x12\x036\x081\n\x0c\n\x05\x05\x05\x02\x04\x01\x12\x036\x08,\n\x0c\n\
    \x05\x05\x05\x02\x04\x02\x12\x036/0\n\x0b\n\x04\x05\x05\x02\x05\x12\x037\
    \x085\n\x0c\n\x05\x05\x05\x02\x05\x01\x12\x037\x080\n\x0c\n\x05\x05\x05\
    \x02\x05\x02\x12\x03734\n\x0b\n\x04\x05\x05\x02\x06\x12\x038\x089\n\x0c\
    \n\x05\x05\x05\x02\x06\x01\x12\x038\x084\n\x0c\n\x05\x05\x05\x02\x06\x02\
    \x12\x03878\n\x0b\n\x04\x05\x05\x02\x07\x12\x039\x08/\n\x0c\n\x05\x05\
    \x05\x02\x07\x01\x12\x039\x08*\n\x0c\n\x05\x05\x05\x02\x07\x02\x12\x039-\
    .\n\x0b\n\x04\x05\x05\x02\x08\x12\x03:\x081\n\x0c\n\x05\x05\x05\x02\x08\
    \x01\x12\x03:\x08+\n\x0c\n\x05\x05\x05\x02\x08\x02\x12\x03:.0\n\x0b\n\
    \x04\x05\x05\x02\t\x12\x03;\x087\n\x0c\n\x05\x05\x05\x02\t\x01\x12\x03;\
    \x081\n\x0c\n\x05\x05\x05\x02\t\x02\x12\x03;46\n\n\n\x02\x04\0\x12\x04>\
    \0?\x01\n\n\n\x03\x04\0\x01\x12\x03>\x080\n\n\n\x02\x04\x01\x12\x04A\0B\
    \x01\n\n\n\x03\x04\x01\x01\x12\x03A\x081\n\n\n\x02\x04\x02\x12\x04D\0K\
    \x01\n\n\n\x03\x04\x02\x01\x12\x03D\x08-\n\x0b\n\x04\x04\x02\x02\0\x12\
    \x03E\x08-\n\x0c\n\x05\x04\x02\x02\0\x04\x12\x03E\x08\x10\n\x0c\n\x05\
    \x04\x02\x02\0\x05\x12\x03E\x11\x18\n\x0c\n\x05\x04\x02\x02\0\x01\x12\
    \x03E\x19(\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03E+,\n\x0b\n\x04\x04\x02\
    \x02\x01\x12\x03F\x08-\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03F\x08\x10\
    \n\x0c\n\x05\x04\x02\x02\x01\x05\x12\x03F\x11\x18\n\x0c\n\x05\x04\x02\
    \x02\x01\x01\x12\x03F\x19(\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03F+,\n\
    \x0b\n\x04\x04\x02\x02\x02\x12\x03G\x08!\n\x0c\n\x05\x04\x02\x02\x02\x04\
    \x12\x03G\x08\x10\n\x0c\n\x05\x04\x02\x02\x02\x05\x12\x03G\x11\x17\n\x0c\
    \n\x05\x04\x02\x02\x02\x01\x12\x03G\x18\x1c\n\x0c\n\x05\x04\x02\x02\x02\
    \x03\x12\x03G\x1f\x20\n\x0b\n\x04\x04\x02\x02\x03\x12\x03H\x08.\n\x0c\n\
    \x05\x04\x02\x02\x03\x04\x12\x03H\x08\x10\n\x0c\n\x05\x04\x02\x02\x03\
    \x05\x12\x03H\x11\x18\n\x0c\n\x05\x04\x02\x02\x03\x01\x12\x03H\x19)\n\
    \x0c\n\x05\x04\x02\x02\x03\x03\x12\x03H,-\n\x0b\n\x04\x04\x02\x02\x04\
    \x12\x03I\x089\n\x0c\n\x05\x04\x02\x02\x04\x04\x12\x03I\x08\x10\n\x0c\n\
    \x05\x04\x02\x02\x04\x05\x12\x03I\x11\x17\n\x0c\n\x05\x04\x02\x02\x04\
    \x01\x12\x03I\x184\n\x0c\n\x05\x04\x02\x02\x04\x03\x12\x03I78\n\x0b\n\
    \x04\x04\x02\x02\x05\x12\x03J\x08:\n\x0c\n\x05\x04\x02\x02\x05\x04\x12\
    \x03J\x08\x10\n\x0c\n\x05\x04\x02\x02\x05\x05\x12\x03J\x11\x17\n\x0c\n\
    \x05\x04\x02\x02\x05\x01\x12\x03J\x185\n\x0c\n\x05\x04\x02\x02\x05\x03\
    \x12\x03J89\n\n\n\x02\x04\x03\x12\x04M\0Q\x01\n\n\n\x03\x04\x03\x01\x12\
    \x03M\x08\x11\n\x0b\n\x04\x04\x03\x02\0\x12\x03N\x08$\n\x0c\n\x05\x04\
    \x03\x02\0\x04\x12\x03N\x08\x10\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03N\
    \x11\x17\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03N\x18\x1f\n\x0c\n\x05\x04\
    \x03\x02\0\x03\x12\x03N\"#\n\x0b\n\x04\x04\x03\x02\x01\x12\x03O\x08!\n\
    \x0c\n\x05\x04\x03\x02\x01\x04\x12\x03O\x08\x10\n\x0c\n\x05\x04\x03\x02\
    \x01\x05\x12\x03O\x11\x17\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03O\x18\
    \x1c\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03O\x1f\x20\n\x0b\n\x04\x04\
    \x03\x02\x02\x12\x03P\x08$\n\x0c\n\x05\x04\x03\x02\x02\x04\x12\x03P\x08\
    \x10\n\x0c\n\x05\x04\x03\x02\x02\x05\x12\x03P\x11\x17\n\x0c\n\x05\x04\
    \x03\x02\x02\x01\x12\x03P\x18\x1f\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\
    \x03P\"#\n\n\n\x02\x04\x04\x12\x04S\0`\x01\n\n\n\x03\x04\x04\x01\x12\x03\
    S\x08\x18\n\x0b\n\x04\x04\x04\x02\0\x12\x03T\x08$\n\x0c\n\x05\x04\x04\
    \x02\0\x04\x12\x03T\x08\x10\n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03T\x11\
    \x17\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03T\x18\x1f\n\x0c\n\x05\x04\x04\
    \x02\0\x03\x12\x03T\"#\n\x0b\n\x04\x04\x04\x02\x01\x12\x03U\x08;\n\x0c\n\
    \x05\x04\x04\x02\x01\x04\x12\x03U\x08\x10\n\x0c\n\x05\x04\x04\x02\x01\
    \x05\x12\x03U\x11\x15\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03U\x166\n\
    \x0c\n\x05\x04\x04\x02\x01\x03\x12\x03U9:\n\x0b\n\x04\x04\x04\x02\x02\
    \x12\x03V\x08#\n\x0c\n\x05\x04\x04\x02\x02\x04\x12\x03V\x08\x10\n\x0c\n\
    \x05\x04\x04\x02\x02\x05\x12\x03V\x11\x15\n\x0c\n\x05\x04\x04\x02\x02\
    \x01\x12\x03V\x16\x1e\n\x0c\n\x05\x04\x04\x02\x02\x03\x12\x03V!\"\n\x0b\
    \n\x04\x04\x04\x02\x03\x12\x03W\x08\"\n\x0c\n\x05\x04\x04\x02\x03\x04\
    \x12\x03W\x08\x10\n\x0c\n\x05\x04\x04\x02\x03\x05\x12\x03W\x11\x15\n\x0c\
    \n\x05\x04\x04\x02\x03\x01\x12\x03W\x16\x1d\n\x0c\n\x05\x04\x04\x02\x03\
    \x03\x12\x03W\x20!\n\x0b\n\x04\x04\x04\x02\x04\x12\x03X\x08%\n\x0c\n\x05\
    \x04\x04\x02\x04\x04\x12\x03X\x08\x10\n\x0c\n\x05\x04\x04\x02\x04\x05\
    \x12\x03X\x11\x15\n\x0c\n\x05\x04\x04\x02\x04\x01\x12\x03X\x16\x20\n\x0c\
    \n\x05\x04\x04\x02\x04\x03\x12\x03X#$\n\x0b\n\x04\x04\x04\x02\x05\x12\
    \x03Y\x089\n\x0c\n\x05\x04\x04\x02\x05\x04\x12\x03Y\x08\x10\n\x0c\n\x05\
    \x04\x04\x02\x05\x05\x12\x03Y\x11\x15\n\x0c\n\x05\x04\x04\x02\x05\x01\
    \x12\x03Y\x164\n\x0c\n\x05\x04\x04\x02\x05\x03\x12\x03Y78\n\x0b\n\x04\
    \x04\x04\x02\x06\x12\x03Z\x08#\n\x0c\n\x05\x04\x04\x02\x06\x04\x12\x03Z\
    \x08\x10\n\x0c\n\x05\x04\x04\x02\x06\x05\x12\x03Z\x11\x15\n\x0c\n\x05\
    \x04\x04\x02\x06\x01\x12\x03Z\x16\x1e\n\x0c\n\x05\x04\x04\x02\x06\x03\
    \x12\x03Z!\"\n\x0b\n\x04\x04\x04\x02\x07\x12\x03[\x08+\n\x0c\n\x05\x04\
    \x04\x02\x07\x04\x12\x03[\x08\x10\n\x0c\n\x05\x04\x04\x02\x07\x05\x12\
    \x03[\x11\x15\n\x0c\n\x05\x04\x04\x02\x07\x01\x12\x03[\x16&\n\x0c\n\x05\
    \x04\x04\x02\x07\x03\x12\x03[)*\n\x0b\n\x04\x04\x04\x02\x08\x12\x03\\\
    \x081\n\x0c\n\x05\x04\x04\x02\x08\x04\x12\x03\\\x08\x10\n\x0c\n\x05\x04\
    \x04\x02\x08\x05\x12\x03\\\x11\x15\n\x0c\n\x05\x04\x04\x02\x08\x01\x12\
    \x03\\\x16,\n\x0c\n\x05\x04\x04\x02\x08\x03\x12\x03\\/0\n\x0b\n\x04\x04\
    \x04\x02\t\x12\x03]\x081\n\x0c\n\x05\x04\x04\x02\t\x04\x12\x03]\x08\x10\
    \n\x0c\n\x05\x04\x04\x02\t\x05\x12\x03]\x11\x15\n\x0c\n\x05\x04\x04\x02\
    \t\x01\x12\x03]\x16+\n\x0c\n\x05\x04\x04\x02\t\x03\x12\x03].0\n\x0b\n\
    \x04\x04\x04\x02\n\x12\x03^\x08+\n\x0c\n\x05\x04\x04\x02\n\x04\x12\x03^\
    \x08\x10\n\x0c\n\x05\x04\x04\x02\n\x05\x12\x03^\x11\x15\n\x0c\n\x05\x04\
    \x04\x02\n\x01\x12\x03^\x16%\n\x0c\n\x05\x04\x04\x02\n\x03\x12\x03^(*\n\
    \x0b\n\x04\x04\x04\x02\x0b\x12\x03_\x086\n\x0c\n\x05\x04\x04\x02\x0b\x04\
    \x12\x03_\x08\x10\n\x0c\n\x05\x04\x04\x02\x0b\x05\x12\x03_\x11\x15\n\x0c\
    \n\x05\x04\x04\x02\x0b\x01\x12\x03_\x160\n\x0c\n\x05\x04\x04\x02\x0b\x03\
    \x12\x03_35\n\n\n\x02\x04\x05\x12\x04b\0g\x01\n\n\n\x03\x04\x05\x01\x12\
    \x03b\x08\x18\n\x0b\n\x04\x04\x05\x02\0\x12\x03c\x08#\n\x0c\n\x05\x04\
    \x05\x02\0\x04\x12\x03c\x08\x10\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03c\
    \x11\x17\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03c\x18\x1e\n\x0c\n\x05\x04\
    \x05\x02\0\x03\x12\x03c!\"\n\x0b\n\x04\x04\x05\x02\x01\x12\x03d\x08+\n\
    \x0c\n\x05\x04\x05\x02\x01\x04\x12\x03d\x08\x10\n\x0c\n\x05\x04\x05\x02\
    \x01\x05\x12\x03d\x11\x18\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x03d\x19&\
    \n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03d)*\n\x0b\n\x04\x04\x05\x02\x02\
    \x12\x03e\x08'\n\x0c\n\x05\x04\x05\x02\x02\x04\x12\x03e\x08\x10\n\x0c\n\
    \x05\x04\x05\x02\x02\x05\x12\x03e\x11\x18\n\x0c\n\x05\x04\x05\x02\x02\
    \x01\x12\x03e\x19\"\n\x0c\n\x05\x04\x05\x02\x02\x03\x12\x03e%&\n\x0b\n\
    \x04\x04\x05\x02\x03\x12\x03f\x08*\n\x0c\n\x05\x04\x05\x02\x03\x04\x12\
    \x03f\x08\x10\n\x0c\n\x05\x04\x05\x02\x03\x05\x12\x03f\x11\x17\n\x0c\n\
    \x05\x04\x05\x02\x03\x01\x12\x03f\x18%\n\x0c\n\x05\x04\x05\x02\x03\x03\
    \x12\x03f()\n\n\n\x02\x04\x06\x12\x04i\0y\x01\n\n\n\x03\x04\x06\x01\x12\
    \x03i\x08!\n\x0b\n\x04\x04\x06\x02\0\x12\x03j\x08*\n\x0c\n\x05\x04\x06\
    \x02\0\x04\x12\x03j\x08\x10\n\x0c\n\x05\x04\x06\x02\0\x05\x12\x03j\x11\
    \x17\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03j\x18%\n\x0c\n\x05\x04\x06\x02\
    \0\x03\x12\x03j()\n\x0b\n\x04\x04\x06\x02\x01\x12\x03k\x08&\n\x0c\n\x05\
    \x04\x06\x02\x01\x04\x12\x03k\x08\x10\n\x0c\n\x05\x04\x06\x02\x01\x05\
    \x12\x03k\x11\x17\n\x0c\n\x05\x04\x06\x02\x01\x01\x12\x03k\x18!\n\x0c\n\
    \x05\x04\x06\x02\x01\x03\x12\x03k$%\n\x0b\n\x04\x04\x06\x02\x02\x12\x03l\
    \x08$\n\x0c\n\x05\x04\x06\x02\x02\x04\x12\x03l\x08\x10\n\x0c\n\x05\x04\
    \x06\x02\x02\x05\x12\x03l\x11\x17\n\x0c\n\x05\x04\x06\x02\x02\x01\x12\
    \x03l\x18\x1e\n\x0c\n\x05\x04\x06\x02\x02\x03\x12\x03l!#\n\x0b\n\x04\x04\
    \x06\x02\x03\x12\x03m\x08-\n\x0c\n\x05\x04\x06\x02\x03\x04\x12\x03m\x08\
    \x10\n\x0c\n\x05\x04\x06\x02\x03\x05\x12\x03m\x11\x17\n\x0c\n\x05\x04\
    \x06\x02\x03\x01\x12\x03m\x18'\n\x0c\n\x05\x04\x06\x02\x03\x03\x12\x03m*\
    ,\n\x0b\n\x04\x04\x06\x02\x04\x12\x03n\x08#\n\x0c\n\x05\x04\x06\x02\x04\
    \x04\x12\x03n\x08\x10\n\x0c\n\x05\x04\x06\x02\x04\x05\x12\x03n\x11\x17\n\
    \x0c\n\x05\x04\x06\x02\x04\x01\x12\x03n\x18\x1d\n\x0c\n\x05\x04\x06\x02\
    \x04\x03\x12\x03n\x20\"\n\x0b\n\x04\x04\x06\x02\x05\x12\x03o\x08%\n\x0c\
    \n\x05\x04\x06\x02\x05\x04\x12\x03o\x08\x10\n\x0c\n\x05\x04\x06\x02\x05\
    \x05\x12\x03o\x11\x17\n\x0c\n\x05\x04\x06\x02\x05\x01\x12\x03o\x18\x1f\n\
    \x0c\n\x05\x04\x06\x02\x05\x03\x12\x03o\"$\n\x0b\n\x04\x04\x06\x02\x06\
    \x12\x03p\x08'\n\x0c\n\x05\x04\x06\x02\x06\x04\x12\x03p\x08\x10\n\x0c\n\
    \x05\x04\x06\x02\x06\x05\x12\x03p\x11\x16\n\x0c\n\x05\x04\x06\x02\x06\
    \x01\x12\x03p\x17!\n\x0c\n\x05\x04\x06\x02\x06\x03\x12\x03p$&\n\x0b\n\
    \x04\x04\x06\x02\x07\x12\x03q\x08-\n\x0c\n\x05\x04\x06\x02\x07\x04\x12\
    \x03q\x08\x10\n\x0c\n\x05\x04\x06\x02\x07\x05\x12\x03q\x11\x17\n\x0c\n\
    \x05\x04\x06\x02\x07\x01\x12\x03q\x18'\n\x0c\n\x05\x04\x06\x02\x07\x03\
    \x12\x03q*,\n\x0b\n\x04\x04\x06\x02\x08\x12\x03r\x08'\n\x0c\n\x05\x04\
    \x06\x02\x08\x04\x12\x03r\x08\x10\n\x0c\n\x05\x04\x06\x02\x08\x06\x12\
    \x03r\x11\x1b\n\x0c\n\x05\x04\x06\x02\x08\x01\x12\x03r\x1c!\n\x0c\n\x05\
    \x04\x06\x02\x08\x03\x12\x03r$&\n\x0b\n\x04\x04\x06\x02\t\x12\x03s\x085\
    \n\x0c\n\x05\x04\x06\x02\t\x04\x12\x03s\x08\x10\n\x0c\n\x05\x04\x06\x02\
    \t\x06\x12\x03s\x11\"\n\x0c\n\x05\x04\x06\x02\t\x01\x12\x03s#/\n\x0c\n\
    \x05\x04\x06\x02\t\x03\x12\x03s24\n\x0b\n\x04\x04\x06\x02\n\x12\x03t\x08\
    :\n\x0c\n\x05\x04\x06\x02\n\x04\x12\x03t\x08\x10\n\x0c\n\x05\x04\x06\x02\
    \n\x05\x12\x03t\x11\x17\n\x0c\n\x05\x04\x06\x02\n\x01\x12\x03t\x184\n\
    \x0c\n\x05\x04\x06\x02\n\x03\x12\x03t79\n\x0b\n\x04\x04\x06\x02\x0b\x12\
    \x03u\x086\n\x0c\n\x05\x04\x06\x02\x0b\x04\x12\x03u\x08\x10\n\x0c\n\x05\
    \x04\x06\x02\x0b\x06\x12\x03u\x11\"\n\x0c\n\x05\x04\x06\x02\x0b\x01\x12\
    \x03u#0\n\x0c\n\x05\x04\x06\x02\x0b\x03\x12\x03u35\n\x0b\n\x04\x04\x06\
    \x02\x0c\x12\x03v\x08;\n\x0c\n\x05\x04\x06\x02\x0c\x04\x12\x03v\x08\x10\
    \n\x0c\n\x05\x04\x06\x02\x0c\x05\x12\x03v\x11\x17\n\x0c\n\x05\x04\x06\
    \x02\x0c\x01\x12\x03v\x185\n\x0c\n\x05\x04\x06\x02\x0c\x03\x12\x03v8:\n\
    \x0b\n\x04\x04\x06\x02\r\x12\x03w\x080\n\x0c\n\x05\x04\x06\x02\r\x04\x12\
    \x03w\x08\x10\n\x0c\n\x05\x04\x06\x02\r\x05\x12\x03w\x11\x17\n\x0c\n\x05\
    \x04\x06\x02\r\x01\x12\x03w\x18*\n\x0c\n\x05\x04\x06\x02\r\x03\x12\x03w-\
    /\n\x0b\n\x04\x04\x06\x02\x0e\x12\x03x\x08,\n\x0c\n\x05\x04\x06\x02\x0e\
    \x04\x12\x03x\x08\x10\n\x0c\n\x05\x04\x06\x02\x0e\x05\x12\x03x\x11\x17\n\
    \x0c\n\x05\x04\x06\x02\x0e\x01\x12\x03x\x18&\n\x0c\n\x05\x04\x06\x02\x0e\
    \x03\x12\x03x)+\n\x0b\n\x02\x04\x07\x12\x05{\0\x81\x01\x01\n\n\n\x03\x04\
    \x07\x01\x12\x03{\x08\x17\n\x0b\n\x04\x04\x07\x02\0\x12\x03|\x08&\n\x0c\
    \n\x05\x04\x07\x02\0\x04\x12\x03|\x08\x10\n\x0c\n\x05\x04\x07\x02\0\x05\
    \x12\x03|\x11\x17\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03|\x18!\n\x0c\n\
    \x05\x04\x07\x02\0\x03\x12\x03|$%\n\x0b\n\x04\x04\x07\x02\x01\x12\x03}\
    \x08X\n\x0c\n\x05\x04\x07\x02\x01\x04\x12\x03}\x08\x10\n\x0c\n\x05\x04\
    \x07\x02\x01\x06\x12\x03}\x11$\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\x03}%\
    *\n\x0c\n\x05\x04\x07\x02\x01\x03\x12\x03}-.\n\x0c\n\x05\x04\x07\x02\x01\
    \x08\x12\x03}/W\n\x0c\n\x05\x04\x07\x02\x01\x07\x12\x03}:V\n\x0b\n\x04\
    \x04\x07\x02\x02\x12\x03~\x08W\n\x0c\n\x05\x04\x07\x02\x02\x04\x12\x03~\
    \x08\x10\n\x0c\n\x05\x04\x07\x02\x02\x06\x12\x03~\x11$\n\x0c\n\x05\x04\
    \x07\x02\x02\x01\x12\x03~%)\n\x0c\n\x05\x04\x07\x02\x02\x03\x12\x03~,-\n\
    \x0c\n\x05\x04\x07\x02\x02\x08\x12\x03~.V\n\x0c\n\x05\x04\x07\x02\x02\
    \x07\x12\x03~9U\n\x0b\n\x04\x04\x07\x02\x03\x12\x03\x7f\x08-\n\x0c\n\x05\
    \x04\x07\x02\x03\x04\x12\x03\x7f\x08\x10\n\x0c\n\x05\x04\x07\x02\x03\x05\
    \x12\x03\x7f\x11\x17\n\x0c\n\x05\x04\x07\x02\x03\x01\x12\x03\x7f\x18(\n\
    \x0c\n\x05\x04\x07\x02\x03\x03\x12\x03\x7f+,\n\x0c\n\x04\x04\x07\x02\x04\
    \x12\x04\x80\x01\x08%\n\r\n\x05\x04\x07\x02\x04\x04\x12\x04\x80\x01\x08\
    \x10\n\r\n\x05\x04\x07\x02\x04\x05\x12\x04\x80\x01\x11\x17\n\r\n\x05\x04\
    \x07\x02\x04\x01\x12\x04\x80\x01\x18\x20\n\r\n\x05\x04\x07\x02\x04\x03\
    \x12\x04\x80\x01#$\n\x0c\n\x02\x04\x08\x12\x06\x83\x01\0\x8c\x01\x01\n\
    \x0b\n\x03\x04\x08\x01\x12\x04\x83\x01\x08\x16\n\x0c\n\x04\x04\x08\x02\0\
    \x12\x04\x84\x01\x08$\n\r\n\x05\x04\x08\x02\0\x04\x12\x04\x84\x01\x08\
    \x10\n\r\n\x05\x04\x08\x02\0\x05\x12\x04\x84\x01\x11\x17\n\r\n\x05\x04\
    \x08\x02\0\x01\x12\x04\x84\x01\x18\x1f\n\r\n\x05\x04\x08\x02\0\x03\x12\
    \x04\x84\x01\"#\n\x0c\n\x04\x04\x08\x02\x01\x12\x04\x85\x01\x08&\n\r\n\
    \x05\x04\x08\x02\x01\x04\x12\x04\x85\x01\x08\x10\n\r\n\x05\x04\x08\x02\
    \x01\x05\x12\x04\x85\x01\x11\x17\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\
    \x85\x01\x18!\n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\x85\x01$%\n\x0c\n\
    \x04\x04\x08\x02\x02\x12\x04\x86\x01\x08(\n\r\n\x05\x04\x08\x02\x02\x04\
    \x12\x04\x86\x01\x08\x10\n\r\n\x05\x04\x08\x02\x02\x05\x12\x04\x86\x01\
    \x11\x15\n\r\n\x05\x04\x08\x02\x02\x01\x12\x04\x86\x01\x16#\n\r\n\x05\
    \x04\x08\x02\x02\x03\x12\x04\x86\x01&'\n\x0c\n\x04\x04\x08\x02\x03\x12\
    \x04\x87\x01\x08-\n\r\n\x05\x04\x08\x02\x03\x04\x12\x04\x87\x01\x08\x10\
    \n\r\n\x05\x04\x08\x02\x03\x05\x12\x04\x87\x01\x11\x17\n\r\n\x05\x04\x08\
    \x02\x03\x01\x12\x04\x87\x01\x18(\n\r\n\x05\x04\x08\x02\x03\x03\x12\x04\
    \x87\x01+,\n\x0c\n\x04\x04\x08\x02\x04\x12\x04\x88\x01\x08.\n\r\n\x05\
    \x04\x08\x02\x04\x04\x12\x04\x88\x01\x08\x10\n\r\n\x05\x04\x08\x02\x04\
    \x05\x12\x04\x88\x01\x11\x17\n\r\n\x05\x04\x08\x02\x04\x01\x12\x04\x88\
    \x01\x18)\n\r\n\x05\x04\x08\x02\x04\x03\x12\x04\x88\x01,-\n\x0c\n\x04\
    \x04\x08\x02\x05\x12\x04\x89\x01\x08'\n\r\n\x05\x04\x08\x02\x05\x04\x12\
    \x04\x89\x01\x08\x10\n\r\n\x05\x04\x08\x02\x05\x05\x12\x04\x89\x01\x11\
    \x17\n\r\n\x05\x04\x08\x02\x05\x01\x12\x04\x89\x01\x18\"\n\r\n\x05\x04\
    \x08\x02\x05\x03\x12\x04\x89\x01%&\n\x0c\n\x04\x04\x08\x02\x06\x12\x04\
    \x8a\x01\x08)\n\r\n\x05\x04\x08\x02\x06\x04\x12\x04\x8a\x01\x08\x10\n\r\
    \n\x05\x04\x08\x02\x06\x05\x12\x04\x8a\x01\x11\x17\n\r\n\x05\x04\x08\x02\
    \x06\x01\x12\x04\x8a\x01\x18$\n\r\n\x05\x04\x08\x02\x06\x03\x12\x04\x8a\
    \x01'(\n\x0c\n\x04\x04\x08\x02\x07\x12\x04\x8b\x01\x083\n\r\n\x05\x04\
    \x08\x02\x07\x04\x12\x04\x8b\x01\x08\x10\n\r\n\x05\x04\x08\x02\x07\x05\
    \x12\x04\x8b\x01\x11\x17\n\r\n\x05\x04\x08\x02\x07\x01\x12\x04\x8b\x01\
    \x18.\n\r\n\x05\x04\x08\x02\x07\x03\x12\x04\x8b\x0112\n\x0c\n\x02\x04\t\
    \x12\x06\x8e\x01\0\x94\x01\x01\n\x0b\n\x03\x04\t\x01\x12\x04\x8e\x01\x08\
    \x1b\n\x0c\n\x04\x04\t\x02\0\x12\x04\x8f\x01\x08=\n\r\n\x05\x04\t\x02\0\
    \x04\x12\x04\x8f\x01\x08\x10\n\r\n\x05\x04\t\x02\0\x06\x12\x04\x8f\x01\
    \x11+\n\r\n\x05\x04\t\x02\0\x01\x12\x04\x8f\x01,8\n\r\n\x05\x04\t\x02\0\
    \x03\x12\x04\x8f\x01;<\n\x0c\n\x04\x04\t\x02\x01\x12\x04\x90\x01\x08.\n\
    \r\n\x05\x04\t\x02\x01\x04\x12\x04\x90\x01\x08\x10\n\r\n\x05\x04\t\x02\
    \x01\x06\x12\x04\x90\x01\x11!\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\x90\
    \x01\")\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\x90\x01,-\n\x0c\n\x04\x04\t\
    \x02\x02\x12\x04\x91\x01\x08,\n\r\n\x05\x04\t\x02\x02\x04\x12\x04\x91\
    \x01\x08\x10\n\r\n\x05\x04\t\x02\x02\x05\x12\x04\x91\x01\x11\x17\n\r\n\
    \x05\x04\t\x02\x02\x01\x12\x04\x91\x01\x18'\n\r\n\x05\x04\t\x02\x02\x03\
    \x12\x04\x91\x01*+\n\x0c\n\x04\x04\t\x02\x03\x12\x04\x92\x01\x080\n\r\n\
    \x05\x04\t\x02\x03\x04\x12\x04\x92\x01\x08\x10\n\r\n\x05\x04\t\x02\x03\
    \x06\x12\x04\x92\x01\x11\x20\n\r\n\x05\x04\t\x02\x03\x01\x12\x04\x92\x01\
    !+\n\r\n\x05\x04\t\x02\x03\x03\x12\x04\x92\x01./\n\x0c\n\x04\x04\t\x02\
    \x04\x12\x04\x93\x01\x08-\n\r\n\x05\x04\t\x02\x04\x04\x12\x04\x93\x01\
    \x08\x10\n\r\n\x05\x04\t\x02\x04\x06\x12\x04\x93\x01\x11!\n\r\n\x05\x04\
    \t\x02\x04\x01\x12\x04\x93\x01\"(\n\r\n\x05\x04\t\x02\x04\x03\x12\x04\
    \x93\x01+,\n\x0c\n\x02\x04\n\x12\x06\x96\x01\0\x9f\x01\x01\n\x0b\n\x03\
    \x04\n\x01\x12\x04\x96\x01\x08\x1a\n\x0c\n\x04\x04\n\x02\0\x12\x04\x97\
    \x01\x08$\n\r\n\x05\x04\n\x02\0\x04\x12\x04\x97\x01\x08\x10\n\r\n\x05\
    \x04\n\x02\0\x05\x12\x04\x97\x01\x11\x17\n\r\n\x05\x04\n\x02\0\x01\x12\
    \x04\x97\x01\x18\x1f\n\r\n\x05\x04\n\x02\0\x03\x12\x04\x97\x01\"#\n\x0c\
    \n\x04\x04\n\x02\x01\x12\x04\x98\x01\x08(\n\r\n\x05\x04\n\x02\x01\x04\
    \x12\x04\x98\x01\x08\x10\n\r\n\x05\x04\n\x02\x01\x05\x12\x04\x98\x01\x11\
    \x17\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\x98\x01\x18#\n\r\n\x05\x04\n\
    \x02\x01\x03\x12\x04\x98\x01&'\n\x0c\n\x04\x04\n\x02\x02\x12\x04\x99\x01\
    \x08*\n\r\n\x05\x04\n\x02\x02\x04\x12\x04\x99\x01\x08\x10\n\r\n\x05\x04\
    \n\x02\x02\x05\x12\x04\x99\x01\x11\x17\n\r\n\x05\x04\n\x02\x02\x01\x12\
    \x04\x99\x01\x18%\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\x99\x01()\n\x0c\n\
    \x04\x04\n\x02\x03\x12\x04\x9a\x01\x08}\n\r\n\x05\x04\n\x02\x03\x04\x12\
    \x04\x9a\x01\x08\x10\n\r\n\x05\x04\n\x02\x03\x06\x12\x04\x9a\x01\x11,\n\
    \r\n\x05\x04\n\x02\x03\x01\x12\x04\x9a\x01-G\n\r\n\x05\x04\n\x02\x03\x03\
    \x12\x04\x9a\x01JK\n\r\n\x05\x04\n\x02\x03\x08\x12\x04\x9a\x01L|\n\r\n\
    \x05\x04\n\x02\x03\x07\x12\x04\x9a\x01W{\n\x0c\n\x04\x04\n\x02\x04\x12\
    \x04\x9b\x01\x08|\n\r\n\x05\x04\n\x02\x04\x04\x12\x04\x9b\x01\x08\x10\n\
    \r\n\x05\x04\n\x02\x04\x06\x12\x04\x9b\x01\x11,\n\r\n\x05\x04\n\x02\x04\
    \x01\x12\x04\x9b\x01-F\n\r\n\x05\x04\n\x02\x04\x03\x12\x04\x9b\x01IJ\n\r\
    \n\x05\x04\n\x02\x04\x08\x12\x04\x9b\x01K{\n\r\n\x05\x04\n\x02\x04\x07\
    \x12\x04\x9b\x01Vz\n\x0c\n\x04\x04\n\x02\x05\x12\x04\x9c\x01\x08.\n\r\n\
    \x05\x04\n\x02\x05\x04\x12\x04\x9c\x01\x08\x10\n\r\n\x05\x04\n\x02\x05\
    \x05\x12\x04\x9c\x01\x11\x17\n\r\n\x05\x04\n\x02\x05\x01\x12\x04\x9c\x01\
    \x18)\n\r\n\x05\x04\n\x02\x05\x03\x12\x04\x9c\x01,-\n\x0c\n\x04\x04\n\
    \x02\x06\x12\x04\x9d\x01\x08C\n\r\n\x05\x04\n\x02\x06\x04\x12\x04\x9d\
    \x01\x08\x10\n\r\n\x05\x04\n\x02\x06\x05\x12\x04\x9d\x01\x11\x15\n\r\n\
    \x05\x04\n\x02\x06\x01\x12\x04\x9d\x01\x16,\n\r\n\x05\x04\n\x02\x06\x03\
    \x12\x04\x9d\x01/0\n\r\n\x05\x04\n\x02\x06\x08\x12\x04\x9d\x011B\n\r\n\
    \x05\x04\n\x02\x06\x07\x12\x04\x9d\x01<A\n\x0c\n\x04\x04\n\x02\x07\x12\
    \x04\x9e\x01\x08.\n\r\n\x05\x04\n\x02\x07\x04\x12\x04\x9e\x01\x08\x10\n\
    \r\n\x05\x04\n\x02\x07\x05\x12\x04\x9e\x01\x11\x17\n\r\n\x05\x04\n\x02\
    \x07\x01\x12\x04\x9e\x01\x18)\n\r\n\x05\x04\n\x02\x07\x03\x12\x04\x9e\
    \x01,-\n\x0c\n\x02\x04\x0b\x12\x06\xa1\x01\0\xa9\x01\x01\n\x0b\n\x03\x04\
    \x0b\x01\x12\x04\xa1\x01\x08\x1f\n\x0c\n\x04\x04\x0b\x02\0\x12\x04\xa2\
    \x01\x08*\n\r\n\x05\x04\x0b\x02\0\x04\x12\x04\xa2\x01\x08\x10\n\r\n\x05\
    \x04\x0b\x02\0\x05\x12\x04\xa2\x01\x11\x17\n\r\n\x05\x04\x0b\x02\0\x01\
    \x12\x04\xa2\x01\x18%\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\xa2\x01()\n\
    \x0c\n\x04\x04\x0b\x02\x01\x12\x04\xa3\x01\x08(\n\r\n\x05\x04\x0b\x02\
    \x01\x04\x12\x04\xa3\x01\x08\x10\n\r\n\x05\x04\x0b\x02\x01\x05\x12\x04\
    \xa3\x01\x11\x17\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\xa3\x01\x18#\n\r\
    \n\x05\x04\x0b\x02\x01\x03\x12\x04\xa3\x01&'\n\x0c\n\x04\x04\x0b\x02\x02\
    \x12\x04\xa4\x01\x08>\n\r\n\x05\x04\x0b\x02\x02\x04\x12\x04\xa4\x01\x08\
    \x10\n\r\n\x05\x04\x0b\x02\x02\x06\x12\x04\xa4\x01\x11$\n\r\n\x05\x04\
    \x0b\x02\x02\x01\x12\x04\xa4\x01%9\n\r\n\x05\x04\x0b\x02\x02\x03\x12\x04\
    \xa4\x01<=\n\x0c\n\x04\x04\x0b\x02\x03\x12\x04\xa5\x01\x08}\n\r\n\x05\
    \x04\x0b\x02\x03\x04\x12\x04\xa5\x01\x08\x10\n\r\n\x05\x04\x0b\x02\x03\
    \x06\x12\x04\xa5\x01\x11,\n\r\n\x05\x04\x0b\x02\x03\x01\x12\x04\xa5\x01-\
    G\n\r\n\x05\x04\x0b\x02\x03\x03\x12\x04\xa5\x01JK\n\r\n\x05\x04\x0b\x02\
    \x03\x08\x12\x04\xa5\x01L|\n\r\n\x05\x04\x0b\x02\x03\x07\x12\x04\xa5\x01\
    W{\n\x0c\n\x04\x04\x0b\x02\x04\x12\x04\xa6\x01\x08|\n\r\n\x05\x04\x0b\
    \x02\x04\x04\x12\x04\xa6\x01\x08\x10\n\r\n\x05\x04\x0b\x02\x04\x06\x12\
    \x04\xa6\x01\x11,\n\r\n\x05\x04\x0b\x02\x04\x01\x12\x04\xa6\x01-F\n\r\n\
    \x05\x04\x0b\x02\x04\x03\x12\x04\xa6\x01IJ\n\r\n\x05\x04\x0b\x02\x04\x08\
    \x12\x04\xa6\x01K{\n\r\n\x05\x04\x0b\x02\x04\x07\x12\x04\xa6\x01Vz\n\x0c\
    \n\x04\x04\x0b\x02\x05\x12\x04\xa7\x01\x080\n\r\n\x05\x04\x0b\x02\x05\
    \x04\x12\x04\xa7\x01\x08\x10\n\r\n\x05\x04\x0b\x02\x05\x05\x12\x04\xa7\
    \x01\x11\x17\n\r\n\x05\x04\x0b\x02\x05\x01\x12\x04\xa7\x01\x18+\n\r\n\
    \x05\x04\x0b\x02\x05\x03\x12\x04\xa7\x01./\n\x0c\n\x04\x04\x0b\x02\x06\
    \x12\x04\xa8\x01\x08C\n\r\n\x05\x04\x0b\x02\x06\x04\x12\x04\xa8\x01\x08\
    \x10\n\r\n\x05\x04\x0b\x02\x06\x05\x12\x04\xa8\x01\x11\x15\n\r\n\x05\x04\
    \x0b\x02\x06\x01\x12\x04\xa8\x01\x16,\n\r\n\x05\x04\x0b\x02\x06\x03\x12\
    \x04\xa8\x01/0\n\r\n\x05\x04\x0b\x02\x06\x08\x12\x04\xa8\x011B\n\r\n\x05\
    \x04\x0b\x02\x06\x07\x12\x04\xa8\x01<A\n\x0c\n\x02\x04\x0c\x12\x06\xab\
    \x01\0\xaf\x01\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\xab\x01\x08.\n\x0c\n\
    \x04\x04\x0c\x02\0\x12\x04\xac\x01\x08*\n\r\n\x05\x04\x0c\x02\0\x04\x12\
    \x04\xac\x01\x08\x10\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\xac\x01\x11\x17\
    \n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xac\x01\x18%\n\r\n\x05\x04\x0c\x02\
    \0\x03\x12\x04\xac\x01()\n\x0c\n\x04\x04\x0c\x02\x01\x12\x04\xad\x01\x08\
    0\n\r\n\x05\x04\x0c\x02\x01\x04\x12\x04\xad\x01\x08\x10\n\r\n\x05\x04\
    \x0c\x02\x01\x06\x12\x04\xad\x01\x11%\n\r\n\x05\x04\x0c\x02\x01\x01\x12\
    \x04\xad\x01&+\n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\xad\x01./\n\x0c\n\
    \x04\x04\x0c\x02\x02\x12\x04\xae\x01\x08>\n\r\n\x05\x04\x0c\x02\x02\x04\
    \x12\x04\xae\x01\x08\x10\n\r\n\x05\x04\x0c\x02\x02\x06\x12\x04\xae\x01\
    \x11)\n\r\n\x05\x04\x0c\x02\x02\x01\x12\x04\xae\x01*9\n\r\n\x05\x04\x0c\
    \x02\x02\x03\x12\x04\xae\x01<=\n\x0c\n\x02\x04\r\x12\x06\xb1\x01\0\xb4\
    \x01\x01\n\x0b\n\x03\x04\r\x01\x12\x04\xb1\x01\x08+\n\x0c\n\x04\x04\r\
    \x02\0\x12\x04\xb2\x01\x08*\n\r\n\x05\x04\r\x02\0\x04\x12\x04\xb2\x01\
    \x08\x10\n\r\n\x05\x04\r\x02\0\x05\x12\x04\xb2\x01\x11\x17\n\r\n\x05\x04\
    \r\x02\0\x01\x12\x04\xb2\x01\x18%\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xb2\
    \x01()\n\x0c\n\x04\x04\r\x02\x01\x12\x04\xb3\x01\x08!\n\r\n\x05\x04\r\
    \x02\x01\x04\x12\x04\xb3\x01\x08\x10\n\r\n\x05\x04\r\x02\x01\x05\x12\x04\
    \xb3\x01\x11\x17\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\xb3\x01\x18\x1c\n\r\
    \n\x05\x04\r\x02\x01\x03\x12\x04\xb3\x01\x1f\x20\n\x0c\n\x02\x04\x0e\x12\
    \x06\xb6\x01\0\xb7\x01\x01\n\x0b\n\x03\x04\x0e\x01\x12\x04\xb6\x01\x08,\
    \n\x0c\n\x02\x04\x0f\x12\x06\xb9\x01\0\xbc\x01\x01\n\x0b\n\x03\x04\x0f\
    \x01\x12\x04\xb9\x01\x08-\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\xba\x01\x08*\
    \n\r\n\x05\x04\x0f\x02\0\x04\x12\x04\xba\x01\x08\x10\n\r\n\x05\x04\x0f\
    \x02\0\x05\x12\x04\xba\x01\x11\x17\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\
    \xba\x01\x18%\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xba\x01()\n\x0c\n\x04\
    \x04\x0f\x02\x01\x12\x04\xbb\x01\x08!\n\r\n\x05\x04\x0f\x02\x01\x04\x12\
    \x04\xbb\x01\x08\x10\n\r\n\x05\x04\x0f\x02\x01\x05\x12\x04\xbb\x01\x11\
    \x17\n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\xbb\x01\x18\x1c\n\r\n\x05\x04\
    \x0f\x02\x01\x03\x12\x04\xbb\x01\x1f\x20\n\x0c\n\x02\x04\x10\x12\x06\xbe\
    \x01\0\xc0\x01\x01\n\x0b\n\x03\x04\x10\x01\x12\x04\xbe\x01\x08.\n\x0c\n\
    \x04\x04\x10\x02\0\x12\x04\xbf\x01\x08!\n\r\n\x05\x04\x10\x02\0\x04\x12\
    \x04\xbf\x01\x08\x10\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\xbf\x01\x11\x17\
    \n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xbf\x01\x18\x1c\n\r\n\x05\x04\x10\
    \x02\0\x03\x12\x04\xbf\x01\x1f\x20\n\x0c\n\x02\x04\x11\x12\x06\xc2\x01\0\
    \xc5\x01\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\xc2\x01\x081\n\x0c\n\x04\
    \x04\x11\x02\0\x12\x04\xc3\x01\x08*\n\r\n\x05\x04\x11\x02\0\x04\x12\x04\
    \xc3\x01\x08\x10\n\r\n\x05\x04\x11\x02\0\x05\x12\x04\xc3\x01\x11\x17\n\r\
    \n\x05\x04\x11\x02\0\x01\x12\x04\xc3\x01\x18%\n\r\n\x05\x04\x11\x02\0\
    \x03\x12\x04\xc3\x01()\n\x0c\n\x04\x04\x11\x02\x01\x12\x04\xc4\x01\x08$\
    \n\r\n\x05\x04\x11\x02\x01\x04\x12\x04\xc4\x01\x08\x10\n\r\n\x05\x04\x11\
    \x02\x01\x05\x12\x04\xc4\x01\x11\x17\n\r\n\x05\x04\x11\x02\x01\x01\x12\
    \x04\xc4\x01\x18\x1f\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xc4\x01\"#\n\
    \x0c\n\x02\x04\x12\x12\x06\xc7\x01\0\xc8\x01\x01\n\x0b\n\x03\x04\x12\x01\
    \x12\x04\xc7\x01\x082\n\x0c\n\x02\x04\x13\x12\x06\xca\x01\0\xcd\x01\x01\
    \n\x0b\n\x03\x04\x13\x01\x12\x04\xca\x01\x080\n\x0c\n\x04\x04\x13\x02\0\
    \x12\x04\xcb\x01\x08*\n\r\n\x05\x04\x13\x02\0\x04\x12\x04\xcb\x01\x08\
    \x10\n\r\n\x05\x04\x13\x02\0\x05\x12\x04\xcb\x01\x11\x17\n\r\n\x05\x04\
    \x13\x02\0\x01\x12\x04\xcb\x01\x18%\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\
    \xcb\x01()\n\x0c\n\x04\x04\x13\x02\x01\x12\x04\xcc\x01\x08&\n\r\n\x05\
    \x04\x13\x02\x01\x04\x12\x04\xcc\x01\x08\x10\n\r\n\x05\x04\x13\x02\x01\
    \x05\x12\x04\xcc\x01\x11\x16\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\xcc\
    \x01\x17!\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\xcc\x01$%\n\x0c\n\x02\
    \x04\x14\x12\x06\xcf\x01\0\xd0\x01\x01\n\x0b\n\x03\x04\x14\x01\x12\x04\
    \xcf\x01\x081\n\x0c\n\x02\x04\x15\x12\x06\xd2\x01\0\xd6\x01\x01\n\x0b\n\
    \x03\x04\x15\x01\x12\x04\xd2\x01\x08;\n\x0c\n\x04\x04\x15\x02\0\x12\x04\
    \xd3\x01\x08*\n\r\n\x05\x04\x15\x02\0\x04\x12\x04\xd3\x01\x08\x10\n\r\n\
    \x05\x04\x15\x02\0\x05\x12\x04\xd3\x01\x11\x17\n\r\n\x05\x04\x15\x02\0\
    \x01\x12\x04\xd3\x01\x18%\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\xd3\x01()\
    \n\x0c\n\x04\x04\x15\x02\x01\x12\x04\xd4\x01\x089\n\r\n\x05\x04\x15\x02\
    \x01\x04\x12\x04\xd4\x01\x08\x10\n\r\n\x05\x04\x15\x02\x01\x05\x12\x04\
    \xd4\x01\x11\x17\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\xd4\x01\x184\n\r\
    \n\x05\x04\x15\x02\x01\x03\x12\x04\xd4\x0178\n\x0c\n\x04\x04\x15\x02\x02\
    \x12\x04\xd5\x01\x08:\n\r\n\x05\x04\x15\x02\x02\x04\x12\x04\xd5\x01\x08\
    \x10\n\r\n\x05\x04\x15\x02\x02\x05\x12\x04\xd5\x01\x11\x17\n\r\n\x05\x04\
    \x15\x02\x02\x01\x12\x04\xd5\x01\x185\n\r\n\x05\x04\x15\x02\x02\x03\x12\
    \x04\xd5\x0189\n\x0c\n\x02\x04\x16\x12\x06\xd8\x01\0\xd9\x01\x01\n\x0b\n\
    \x03\x04\x16\x01\x12\x04\xd8\x01\x08<\n\x0c\n\x02\x04\x17\x12\x06\xdb\
    \x01\0\xde\x01\x01\n\x0b\n\x03\x04\x17\x01\x12\x04\xdb\x01\x086\n\x0c\n\
    \x04\x04\x17\x02\0\x12\x04\xdc\x01\x08*\n\r\n\x05\x04\x17\x02\0\x04\x12\
    \x04\xdc\x01\x08\x10\n\r\n\x05\x04\x17\x02\0\x05\x12\x04\xdc\x01\x11\x17\
    \n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xdc\x01\x18%\n\r\n\x05\x04\x17\x02\
    \0\x03\x12\x04\xdc\x01()\n\x0c\n\x04\x04\x17\x02\x01\x12\x04\xdd\x01\x08\
    $\n\r\n\x05\x04\x17\x02\x01\x04\x12\x04\xdd\x01\x08\x10\n\r\n\x05\x04\
    \x17\x02\x01\x05\x12\x04\xdd\x01\x11\x17\n\r\n\x05\x04\x17\x02\x01\x01\
    \x12\x04\xdd\x01\x18\x1f\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\xdd\x01\"\
    #\n\x0c\n\x02\x04\x18\x12\x06\xe0\x01\0\xe2\x01\x01\n\x0b\n\x03\x04\x18\
    \x01\x12\x04\xe0\x01\x087\n\x0c\n\x04\x04\x18\x02\0\x12\x04\xe1\x01\x08(\
    \n\r\n\x05\x04\x18\x02\0\x04\x12\x04\xe1\x01\x08\x10\n\r\n\x05\x04\x18\
    \x02\0\x05\x12\x04\xe1\x01\x11\x17\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\
    \xe1\x01\x18#\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xe1\x01&'\n\x0c\n\x02\
    \x04\x19\x12\x06\xe4\x01\0\xe8\x01\x01\n\x0b\n\x03\x04\x19\x01\x12\x04\
    \xe4\x01\x085\n\x0c\n\x04\x04\x19\x02\0\x12\x04\xe5\x01\x08*\n\r\n\x05\
    \x04\x19\x02\0\x04\x12\x04\xe5\x01\x08\x10\n\r\n\x05\x04\x19\x02\0\x05\
    \x12\x04\xe5\x01\x11\x17\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\xe5\x01\x18\
    %\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\xe5\x01()\n\x0c\n\x04\x04\x19\x02\
    \x01\x12\x04\xe6\x01\x08$\n\r\n\x05\x04\x19\x02\x01\x04\x12\x04\xe6\x01\
    \x08\x10\n\r\n\x05\x04\x19\x02\x01\x05\x12\x04\xe6\x01\x11\x17\n\r\n\x05\
    \x04\x19\x02\x01\x01\x12\x04\xe6\x01\x18\x1f\n\r\n\x05\x04\x19\x02\x01\
    \x03\x12\x04\xe6\x01\"#\n\x0c\n\x04\x04\x19\x02\x02\x12\x04\xe7\x01\x08(\
    \n\r\n\x05\x04\x19\x02\x02\x04\x12\x04\xe7\x01\x08\x10\n\r\n\x05\x04\x19\
    \x02\x02\x05\x12\x04\xe7\x01\x11\x17\n\r\n\x05\x04\x19\x02\x02\x01\x12\
    \x04\xe7\x01\x18#\n\r\n\x05\x04\x19\x02\x02\x03\x12\x04\xe7\x01&'\n\x0c\
    \n\x02\x04\x1a\x12\x06\xea\x01\0\xeb\x01\x01\n\x0b\n\x03\x04\x1a\x01\x12\
    \x04\xea\x01\x086\n\x0c\n\x02\x04\x1b\x12\x06\xed\x01\0\xf1\x01\x01\n\
    \x0b\n\x03\x04\x1b\x01\x12\x04\xed\x01\x08\"\n\x0c\n\x04\x04\x1b\x02\0\
    \x12\x04\xee\x01\x08*\n\r\n\x05\x04\x1b\x02\0\x04\x12\x04\xee\x01\x08\
    \x10\n\r\n\x05\x04\x1b\x02\0\x05\x12\x04\xee\x01\x11\x17\n\r\n\x05\x04\
    \x1b\x02\0\x01\x12\x04\xee\x01\x18%\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\
    \xee\x01()\n\x0c\n\x04\x04\x1b\x02\x01\x12\x04\xef\x01\x08%\n\r\n\x05\
    \x04\x1b\x02\x01\x04\x12\x04\xef\x01\x08\x10\n\r\n\x05\x04\x1b\x02\x01\
    \x05\x12\x04\xef\x01\x11\x18\n\r\n\x05\x04\x1b\x02\x01\x01\x12\x04\xef\
    \x01\x19\x20\n\r\n\x05\x04\x1b\x02\x01\x03\x12\x04\xef\x01#$\n\x0c\n\x04\
    \x04\x1b\x02\x02\x12\x04\xf0\x01\x08&\n\r\n\x05\x04\x1b\x02\x02\x04\x12\
    \x04\xf0\x01\x08\x10\n\r\n\x05\x04\x1b\x02\x02\x05\x12\x04\xf0\x01\x11\
    \x16\n\r\n\x05\x04\x1b\x02\x02\x01\x12\x04\xf0\x01\x17!\n\r\n\x05\x04\
    \x1b\x02\x02\x03\x12\x04\xf0\x01$%\n\x0c\n\x02\x04\x1c\x12\x06\xf3\x01\0\
    \xf4\x01\x01\n\x0b\n\x03\x04\x1c\x01\x12\x04\xf3\x01\x08#\n\x0c\n\x02\
    \x04\x1d\x12\x06\xf6\x01\0\xfa\x01\x01\n\x0b\n\x03\x04\x1d\x01\x12\x04\
    \xf6\x01\x08\"\n\x0c\n\x04\x04\x1d\x02\0\x12\x04\xf7\x01\x08*\n\r\n\x05\
    \x04\x1d\x02\0\x04\x12\x04\xf7\x01\x08\x10\n\r\n\x05\x04\x1d\x02\0\x05\
    \x12\x04\xf7\x01\x11\x17\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\xf7\x01\x18\
    %\n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\xf7\x01()\n\x0c\n\x04\x04\x1d\x02\
    \x01\x12\x04\xf8\x01\x08%\n\r\n\x05\x04\x1d\x02\x01\x04\x12\x04\xf8\x01\
    \x08\x10\n\r\n\x05\x04\x1d\x02\x01\x05\x12\x04\xf8\x01\x11\x18\n\r\n\x05\
    \x04\x1d\x02\x01\x01\x12\x04\xf8\x01\x19\x20\n\r\n\x05\x04\x1d\x02\x01\
    \x03\x12\x04\xf8\x01#$\n\x0c\n\x04\x04\x1d\x02\x02\x12\x04\xf9\x01\x08&\
    \n\r\n\x05\x04\x1d\x02\x02\x04\x12\x04\xf9\x01\x08\x10\n\r\n\x05\x04\x1d\
    \x02\x02\x05\x12\x04\xf9\x01\x11\x16\n\r\n\x05\x04\x1d\x02\x02\x01\x12\
    \x04\xf9\x01\x17!\n\r\n\x05\x04\x1d\x02\x02\x03\x12\x04\xf9\x01$%\n\x0c\
    \n\x02\x04\x1e\x12\x06\xfc\x01\0\xfd\x01\x01\n\x0b\n\x03\x04\x1e\x01\x12\
    \x04\xfc\x01\x08#\n\x0c\n\x02\x04\x1f\x12\x06\xff\x01\0\x83\x02\x01\n\
    \x0b\n\x03\x04\x1f\x01\x12\x04\xff\x01\x08)\n\x0c\n\x04\x04\x1f\x02\0\
    \x12\x04\x80\x02\x08*\n\r\n\x05\x04\x1f\x02\0\x04\x12\x04\x80\x02\x08\
    \x10\n\r\n\x05\x04\x1f\x02\0\x05\x12\x04\x80\x02\x11\x17\n\r\n\x05\x04\
    \x1f\x02\0\x01\x12\x04\x80\x02\x18%\n\r\n\x05\x04\x1f\x02\0\x03\x12\x04\
    \x80\x02()\n\x0c\n\x04\x04\x1f\x02\x01\x12\x04\x81\x02\x08%\n\r\n\x05\
    \x04\x1f\x02\x01\x04\x12\x04\x81\x02\x08\x10\n\r\n\x05\x04\x1f\x02\x01\
    \x05\x12\x04\x81\x02\x11\x18\n\r\n\x05\x04\x1f\x02\x01\x01\x12\x04\x81\
    \x02\x19\x20\n\r\n\x05\x04\x1f\x02\x01\x03\x12\x04\x81\x02#$\n\x0c\n\x04\
    \x04\x1f\x02\x02\x12\x04\x82\x02\x08$\n\r\n\x05\x04\x1f\x02\x02\x04\x12\
    \x04\x82\x02\x08\x10\n\r\n\x05\x04\x1f\x02\x02\x05\x12\x04\x82\x02\x11\
    \x15\n\r\n\x05\x04\x1f\x02\x02\x01\x12\x04\x82\x02\x16\x1f\n\r\n\x05\x04\
    \x1f\x02\x02\x03\x12\x04\x82\x02\"#\n\x0c\n\x02\x04\x20\x12\x06\x85\x02\
    \0\x86\x02\x01\n\x0b\n\x03\x04\x20\x01\x12\x04\x85\x02\x08*\n\x0c\n\x02\
    \x04!\x12\x06\x88\x02\0\x8b\x02\x01\n\x0b\n\x03\x04!\x01\x12\x04\x88\x02\
    \x08&\n\x0c\n\x04\x04!\x02\0\x12\x04\x89\x02\x08*\n\r\n\x05\x04!\x02\0\
    \x04\x12\x04\x89\x02\x08\x10\n\r\n\x05\x04!\x02\0\x05\x12\x04\x89\x02\
    \x11\x17\n\r\n\x05\x04!\x02\0\x01\x12\x04\x89\x02\x18%\n\r\n\x05\x04!\
    \x02\0\x03\x12\x04\x89\x02()\n\x0c\n\x04\x04!\x02\x01\x12\x04\x8a\x02\
    \x08%\n\r\n\x05\x04!\x02\x01\x04\x12\x04\x8a\x02\x08\x10\n\r\n\x05\x04!\
    \x02\x01\x05\x12\x04\x8a\x02\x11\x18\n\r\n\x05\x04!\x02\x01\x01\x12\x04\
    \x8a\x02\x19\x20\n\r\n\x05\x04!\x02\x01\x03\x12\x04\x8a\x02#$\n\x0c\n\
    \x02\x04\"\x12\x06\x8d\x02\0\x8e\x02\x01\n\x0b\n\x03\x04\"\x01\x12\x04\
    \x8d\x02\x08'\n\x0c\n\x02\x04#\x12\x06\x90\x02\0\x93\x02\x01\n\x0b\n\x03\
    \x04#\x01\x12\x04\x90\x02\x08$\n\x0c\n\x04\x04#\x02\0\x12\x04\x91\x02\
    \x08*\n\r\n\x05\x04#\x02\0\x04\x12\x04\x91\x02\x08\x10\n\r\n\x05\x04#\
    \x02\0\x05\x12\x04\x91\x02\x11\x17\n\r\n\x05\x04#\x02\0\x01\x12\x04\x91\
    \x02\x18%\n\r\n\x05\x04#\x02\0\x03\x12\x04\x91\x02()\n\x0c\n\x04\x04#\
    \x02\x01\x12\x04\x92\x02\x08!\n\r\n\x05\x04#\x02\x01\x04\x12\x04\x92\x02\
    \x08\x10\n\r\n\x05\x04#\x02\x01\x05\x12\x04\x92\x02\x11\x17\n\r\n\x05\
    \x04#\x02\x01\x01\x12\x04\x92\x02\x18\x1c\n\r\n\x05\x04#\x02\x01\x03\x12\
    \x04\x92\x02\x1f\x20\n\x0c\n\x02\x04$\x12\x06\x95\x02\0\x97\x02\x01\n\
    \x0b\n\x03\x04$\x01\x12\x04\x95\x02\x08%\n\x0c\n\x04\x04$\x02\0\x12\x04\
    \x96\x02\x08/\n\r\n\x05\x04$\x02\0\x04\x12\x04\x96\x02\x08\x10\n\r\n\x05\
    \x04$\x02\0\x06\x12\x04\x96\x02\x11\"\n\r\n\x05\x04$\x02\0\x01\x12\x04\
    \x96\x02#*\n\r\n\x05\x04$\x02\0\x03\x12\x04\x96\x02-.\n\x0c\n\x02\x04%\
    \x12\x06\x99\x02\0\x9b\x02\x01\n\x0b\n\x03\x04%\x01\x12\x04\x99\x02\x08\
    \"\n\x0c\n\x04\x04%\x02\0\x12\x04\x9a\x02\x08*\n\r\n\x05\x04%\x02\0\x04\
    \x12\x04\x9a\x02\x08\x10\n\r\n\x05\x04%\x02\0\x05\x12\x04\x9a\x02\x11\
    \x17\n\r\n\x05\x04%\x02\0\x01\x12\x04\x9a\x02\x18%\n\r\n\x05\x04%\x02\0\
    \x03\x12\x04\x9a\x02()\n\x0c\n\x02\x04&\x12\x06\x9d\x02\0\x9f\x02\x01\n\
    \x0b\n\x03\x04&\x01\x12\x04\x9d\x02\x08#\n\x0c\n\x04\x04&\x02\0\x12\x04\
    \x9e\x02\x08&\n\r\n\x05\x04&\x02\0\x04\x12\x04\x9e\x02\x08\x10\n\r\n\x05\
    \x04&\x02\0\x06\x12\x04\x9e\x02\x11\x1b\n\r\n\x05\x04&\x02\0\x01\x12\x04\
    \x9e\x02\x1c!\n\r\n\x05\x04&\x02\0\x03\x12\x04\x9e\x02$%\n\x0c\n\x02\x04\
    '\x12\x06\xa1\x02\0\xa5\x02\x01\n\x0b\n\x03\x04'\x01\x12\x04\xa1\x02\x08\
    $\n\x0c\n\x04\x04'\x02\0\x12\x04\xa2\x02\x08*\n\r\n\x05\x04'\x02\0\x04\
    \x12\x04\xa2\x02\x08\x10\n\r\n\x05\x04'\x02\0\x05\x12\x04\xa2\x02\x11\
    \x17\n\r\n\x05\x04'\x02\0\x01\x12\x04\xa2\x02\x18%\n\r\n\x05\x04'\x02\0\
    \x03\x12\x04\xa2\x02()\n\x0c\n\x04\x04'\x02\x01\x12\x04\xa3\x02\x08$\n\r\
    \n\x05\x04'\x02\x01\x04\x12\x04\xa3\x02\x08\x10\n\r\n\x05\x04'\x02\x01\
    \x05\x12\x04\xa3\x02\x11\x17\n\r\n\x05\x04'\x02\x01\x01\x12\x04\xa3\x02\
    \x18\x1f\n\r\n\x05\x04'\x02\x01\x03\x12\x04\xa3\x02\"#\n\x0c\n\x04\x04'\
    \x02\x02\x12\x04\xa4\x02\x08!\n\r\n\x05\x04'\x02\x02\x04\x12\x04\xa4\x02\
    \x08\x10\n\r\n\x05\x04'\x02\x02\x05\x12\x04\xa4\x02\x11\x17\n\r\n\x05\
    \x04'\x02\x02\x01\x12\x04\xa4\x02\x18\x1c\n\r\n\x05\x04'\x02\x02\x03\x12\
    \x04\xa4\x02\x1f\x20\n\x0c\n\x02\x04(\x12\x06\xa7\x02\0\xa8\x02\x01\n\
    \x0b\n\x03\x04(\x01\x12\x04\xa7\x02\x08%\n\x0c\n\x02\x04)\x12\x06\xaa\
    \x02\0\xae\x02\x01\n\x0b\n\x03\x04)\x01\x12\x04\xaa\x02\x08%\n\x0c\n\x04\
    \x04)\x02\0\x12\x04\xab\x02\x08*\n\r\n\x05\x04)\x02\0\x04\x12\x04\xab\
    \x02\x08\x10\n\r\n\x05\x04)\x02\0\x05\x12\x04\xab\x02\x11\x17\n\r\n\x05\
    \x04)\x02\0\x01\x12\x04\xab\x02\x18%\n\r\n\x05\x04)\x02\0\x03\x12\x04\
    \xab\x02()\n\x0c\n\x04\x04)\x02\x01\x12\x04\xac\x02\x08$\n\r\n\x05\x04)\
    \x02\x01\x04\x12\x04\xac\x02\x08\x10\n\r\n\x05\x04)\x02\x01\x05\x12\x04\
    \xac\x02\x11\x17\n\r\n\x05\x04)\x02\x01\x01\x12\x04\xac\x02\x18\x1f\n\r\
    \n\x05\x04)\x02\x01\x03\x12\x04\xac\x02\"#\n\x0c\n\x04\x04)\x02\x02\x12\
    \x04\xad\x02\x08$\n\r\n\x05\x04)\x02\x02\x04\x12\x04\xad\x02\x08\x10\n\r\
    \n\x05\x04)\x02\x02\x05\x12\x04\xad\x02\x11\x17\n\r\n\x05\x04)\x02\x02\
    \x01\x12\x04\xad\x02\x18\x1f\n\r\n\x05\x04)\x02\x02\x03\x12\x04\xad\x02\
    \"#\n\x0c\n\x02\x04*\x12\x06\xb0\x02\0\xb1\x02\x01\n\x0b\n\x03\x04*\x01\
    \x12\x04\xb0\x02\x08&\n\x0c\n\x02\x04+\x12\x06\xb3\x02\0\xb6\x02\x01\n\
    \x0b\n\x03\x04+\x01\x12\x04\xb3\x02\x08$\n\x0c\n\x04\x04+\x02\0\x12\x04\
    \xb4\x02\x08*\n\r\n\x05\x04+\x02\0\x04\x12\x04\xb4\x02\x08\x10\n\r\n\x05\
    \x04+\x02\0\x05\x12\x04\xb4\x02\x11\x17\n\r\n\x05\x04+\x02\0\x01\x12\x04\
    \xb4\x02\x18%\n\r\n\x05\x04+\x02\0\x03\x12\x04\xb4\x02()\n\x0c\n\x04\x04\
    +\x02\x01\x12\x04\xb5\x02\x08$\n\r\n\x05\x04+\x02\x01\x04\x12\x04\xb5\
    \x02\x08\x10\n\r\n\x05\x04+\x02\x01\x05\x12\x04\xb5\x02\x11\x17\n\r\n\
    \x05\x04+\x02\x01\x01\x12\x04\xb5\x02\x18\x1f\n\r\n\x05\x04+\x02\x01\x03\
    \x12\x04\xb5\x02\"#\n\x0c\n\x02\x04,\x12\x06\xb8\x02\0\xb9\x02\x01\n\x0b\
    \n\x03\x04,\x01\x12\x04\xb8\x02\x08%\n\x0c\n\x02\x04-\x12\x06\xbb\x02\0\
    \xbe\x02\x01\n\x0b\n\x03\x04-\x01\x12\x04\xbb\x02\x08(\n\x0c\n\x04\x04-\
    \x02\0\x12\x04\xbc\x02\x08*\n\r\n\x05\x04-\x02\0\x04\x12\x04\xbc\x02\x08\
    \x10\n\r\n\x05\x04-\x02\0\x05\x12\x04\xbc\x02\x11\x17\n\r\n\x05\x04-\x02\
    \0\x01\x12\x04\xbc\x02\x18%\n\r\n\x05\x04-\x02\0\x03\x12\x04\xbc\x02()\n\
    \x0c\n\x04\x04-\x02\x01\x12\x04\xbd\x02\x08$\n\r\n\x05\x04-\x02\x01\x04\
    \x12\x04\xbd\x02\x08\x10\n\r\n\x05\x04-\x02\x01\x05\x12\x04\xbd\x02\x11\
    \x17\n\r\n\x05\x04-\x02\x01\x01\x12\x04\xbd\x02\x18\x1f\n\r\n\x05\x04-\
    \x02\x01\x03\x12\x04\xbd\x02\"#\n\x0c\n\x02\x04.\x12\x06\xc0\x02\0\xc2\
    \x02\x01\n\x0b\n\x03\x04.\x01\x12\x04\xc0\x02\x08)\n\x0c\n\x04\x04.\x02\
    \0\x12\x04\xc1\x02\x08/\n\r\n\x05\x04.\x02\0\x04\x12\x04\xc1\x02\x08\x10\
    \n\r\n\x05\x04.\x02\0\x06\x12\x04\xc1\x02\x11\"\n\r\n\x05\x04.\x02\0\x01\
    \x12\x04\xc1\x02#*\n\r\n\x05\x04.\x02\0\x03\x12\x04\xc1\x02-.\n\x0c\n\
    \x02\x04/\x12\x06\xc4\x02\0\xc8\x02\x01\n\x0b\n\x03\x04/\x01\x12\x04\xc4\
    \x02\x08,\n\x0c\n\x04\x04/\x02\0\x12\x04\xc5\x02\x08*\n\r\n\x05\x04/\x02\
    \0\x04\x12\x04\xc5\x02\x08\x10\n\r\n\x05\x04/\x02\0\x05\x12\x04\xc5\x02\
    \x11\x17\n\r\n\x05\x04/\x02\0\x01\x12\x04\xc5\x02\x18%\n\r\n\x05\x04/\
    \x02\0\x03\x12\x04\xc5\x02()\n\x0c\n\x04\x04/\x02\x01\x12\x04\xc6\x02\
    \x08$\n\r\n\x05\x04/\x02\x01\x04\x12\x04\xc6\x02\x08\x10\n\r\n\x05\x04/\
    \x02\x01\x05\x12\x04\xc6\x02\x11\x17\n\r\n\x05\x04/\x02\x01\x01\x12\x04\
    \xc6\x02\x18\x1f\n\r\n\x05\x04/\x02\x01\x03\x12\x04\xc6\x02\"#\n\x0c\n\
    \x04\x04/\x02\x02\x12\x04\xc7\x02\x08/\n\r\n\x05\x04/\x02\x02\x04\x12\
    \x04\xc7\x02\x08\x10\n\r\n\x05\x04/\x02\x02\x06\x12\x04\xc7\x02\x11\"\n\
    \r\n\x05\x04/\x02\x02\x01\x12\x04\xc7\x02#*\n\r\n\x05\x04/\x02\x02\x03\
    \x12\x04\xc7\x02-.\n\x0c\n\x02\x040\x12\x06\xca\x02\0\xcb\x02\x01\n\x0b\
    \n\x03\x040\x01\x12\x04\xca\x02\x08-\n\x0c\n\x02\x041\x12\x06\xcd\x02\0\
    \xd1\x02\x01\n\x0b\n\x03\x041\x01\x12\x04\xcd\x02\x08'\n\x0c\n\x04\x041\
    \x02\0\x12\x04\xce\x02\x08*\n\r\n\x05\x041\x02\0\x04\x12\x04\xce\x02\x08\
    \x10\n\r\n\x05\x041\x02\0\x05\x12\x04\xce\x02\x11\x17\n\r\n\x05\x041\x02\
    \0\x01\x12\x04\xce\x02\x18%\n\r\n\x05\x041\x02\0\x03\x12\x04\xce\x02()\n\
    \x0c\n\x04\x041\x02\x01\x12\x04\xcf\x02\x08$\n\r\n\x05\x041\x02\x01\x04\
    \x12\x04\xcf\x02\x08\x10\n\r\n\x05\x041\x02\x01\x05\x12\x04\xcf\x02\x11\
    \x17\n\r\n\x05\x041\x02\x01\x01\x12\x04\xcf\x02\x18\x1f\n\r\n\x05\x041\
    \x02\x01\x03\x12\x04\xcf\x02\"#\n\x0c\n\x04\x041\x02\x02\x12\x04\xd0\x02\
    \x08%\n\r\n\x05\x041\x02\x02\x04\x12\x04\xd0\x02\x08\x10\n\r\n\x05\x041\
    \x02\x02\x05\x12\x04\xd0\x02\x11\x18\n\r\n\x05\x041\x02\x02\x01\x12\x04\
    \xd0\x02\x19\x20\n\r\n\x05\x041\x02\x02\x03\x12\x04\xd0\x02#$\n\x0c\n\
    \x02\x042\x12\x06\xd3\x02\0\xd4\x02\x01\n\x0b\n\x03\x042\x01\x12\x04\xd3\
    \x02\x08(\n\x0c\n\x02\x043\x12\x06\xd6\x02\0\xd9\x02\x01\n\x0b\n\x03\x04\
    3\x01\x12\x04\xd6\x02\x08)\n\x0c\n\x04\x043\x02\0\x12\x04\xd7\x02\x08*\n\
    \r\n\x05\x043\x02\0\x04\x12\x04\xd7\x02\x08\x10\n\r\n\x05\x043\x02\0\x05\
    \x12\x04\xd7\x02\x11\x17\n\r\n\x05\x043\x02\0\x01\x12\x04\xd7\x02\x18%\n\
    \r\n\x05\x043\x02\0\x03\x12\x04\xd7\x02()\n\x0c\n\x04\x043\x02\x01\x12\
    \x04\xd8\x02\x08%\n\r\n\x05\x043\x02\x01\x04\x12\x04\xd8\x02\x08\x10\n\r\
    \n\x05\x043\x02\x01\x05\x12\x04\xd8\x02\x11\x18\n\r\n\x05\x043\x02\x01\
    \x01\x12\x04\xd8\x02\x19\x20\n\r\n\x05\x043\x02\x01\x03\x12\x04\xd8\x02#\
    $\n\x0c\n\x02\x044\x12\x06\xdb\x02\0\xdd\x02\x01\n\x0b\n\x03\x044\x01\
    \x12\x04\xdb\x02\x08*\n\x0c\n\x04\x044\x02\0\x12\x04\xdc\x02\x08%\n\r\n\
    \x05\x044\x02\0\x04\x12\x04\xdc\x02\x08\x10\n\r\n\x05\x044\x02\0\x05\x12\
    \x04\xdc\x02\x11\x17\n\r\n\x05\x044\x02\0\x01\x12\x04\xdc\x02\x18\x20\n\
    \r\n\x05\x044\x02\0\x03\x12\x04\xdc\x02#$\n\x0c\n\x02\x045\x12\x06\xdf\
    \x02\0\xe3\x02\x01\n\x0b\n\x03\x045\x01\x12\x04\xdf\x02\x08,\n\x0c\n\x04\
    \x045\x02\0\x12\x04\xe0\x02\x08*\n\r\n\x05\x045\x02\0\x04\x12\x04\xe0\
    \x02\x08\x10\n\r\n\x05\x045\x02\0\x05\x12\x04\xe0\x02\x11\x17\n\r\n\x05\
    \x045\x02\0\x01\x12\x04\xe0\x02\x18%\n\r\n\x05\x045\x02\0\x03\x12\x04\
    \xe0\x02()\n\x0c\n\x04\x045\x02\x01\x12\x04\xe1\x02\x08$\n\r\n\x05\x045\
    \x02\x01\x04\x12\x04\xe1\x02\x08\x10\n\r\n\x05\x045\x02\x01\x05\x12\x04\
    \xe1\x02\x11\x17\n\r\n\x05\x045\x02\x01\x01\x12\x04\xe1\x02\x18\x1f\n\r\
    \n\x05\x045\x02\x01\x03\x12\x04\xe1\x02\"#\n\x0c\n\x04\x045\x02\x02\x12\
    \x04\xe2\x02\x08%\n\r\n\x05\x045\x02\x02\x04\x12\x04\xe2\x02\x08\x10\n\r\
    \n\x05\x045\x02\x02\x05\x12\x04\xe2\x02\x11\x18\n\r\n\x05\x045\x02\x02\
    \x01\x12\x04\xe2\x02\x19\x20\n\r\n\x05\x045\x02\x02\x03\x12\x04\xe2\x02#\
    $\n\x0c\n\x02\x046\x12\x06\xe5\x02\0\xe6\x02\x01\n\x0b\n\x03\x046\x01\
    \x12\x04\xe5\x02\x08-\n\x0c\n\x02\x047\x12\x06\xe8\x02\0\xec\x02\x01\n\
    \x0b\n\x03\x047\x01\x12\x04\xe8\x02\x08+\n\x0c\n\x04\x047\x02\0\x12\x04\
    \xe9\x02\x08*\n\r\n\x05\x047\x02\0\x04\x12\x04\xe9\x02\x08\x10\n\r\n\x05\
    \x047\x02\0\x05\x12\x04\xe9\x02\x11\x17\n\r\n\x05\x047\x02\0\x01\x12\x04\
    \xe9\x02\x18%\n\r\n\x05\x047\x02\0\x03\x12\x04\xe9\x02()\n\x0c\n\x04\x04\
    7\x02\x01\x12\x04\xea\x02\x08(\n\r\n\x05\x047\x02\x01\x04\x12\x04\xea\
    \x02\x08\x10\n\r\n\x05\x047\x02\x01\x05\x12\x04\xea\x02\x11\x17\n\r\n\
    \x05\x047\x02\x01\x01\x12\x04\xea\x02\x18#\n\r\n\x05\x047\x02\x01\x03\
    \x12\x04\xea\x02&'\n\x0c\n\x04\x047\x02\x02\x12\x04\xeb\x02\x08$\n\r\n\
    \x05\x047\x02\x02\x04\x12\x04\xeb\x02\x08\x10\n\r\n\x05\x047\x02\x02\x05\
    \x12\x04\xeb\x02\x11\x17\n\r\n\x05\x047\x02\x02\x01\x12\x04\xeb\x02\x18\
    \x1f\n\r\n\x05\x047\x02\x02\x03\x12\x04\xeb\x02\"#\n\x0c\n\x02\x048\x12\
    \x06\xee\x02\0\xf3\x02\x01\n\x0b\n\x03\x048\x01\x12\x04\xee\x02\x08,\n\
    \x0c\n\x04\x048\x02\0\x12\x04\xef\x02\x080\n\r\n\x05\x048\x02\0\x04\x12\
    \x04\xef\x02\x08\x10\n\r\n\x05\x048\x02\0\x06\x12\x04\xef\x02\x11%\n\r\n\
    \x05\x048\x02\0\x01\x12\x04\xef\x02&+\n\r\n\x05\x048\x02\0\x03\x12\x04\
    \xef\x02./\n\x0c\n\x04\x048\x02\x01\x12\x04\xf0\x02\x08>\n\r\n\x05\x048\
    \x02\x01\x04\x12\x04\xf0\x02\x08\x10\n\r\n\x05\x048\x02\x01\x06\x12\x04\
    \xf0\x02\x11)\n\r\n\x05\x048\x02\x01\x01\x12\x04\xf0\x02*9\n\r\n\x05\x04\
    8\x02\x01\x03\x12\x04\xf0\x02<=\n\x0c\n\x04\x048\x02\x02\x12\x04\xf1\x02\
    \x08)\n\r\n\x05\x048\x02\x02\x04\x12\x04\xf1\x02\x08\x10\n\r\n\x05\x048\
    \x02\x02\x05\x12\x04\xf1\x02\x11\x17\n\r\n\x05\x048\x02\x02\x01\x12\x04\
    \xf1\x02\x18$\n\r\n\x05\x048\x02\x02\x03\x12\x04\xf1\x02'(\n\x0c\n\x04\
    \x048\x02\x03\x12\x04\xf2\x02\x08(\n\r\n\x05\x048\x02\x03\x04\x12\x04\
    \xf2\x02\x08\x10\n\r\n\x05\x048\x02\x03\x05\x12\x04\xf2\x02\x11\x17\n\r\
    \n\x05\x048\x02\x03\x01\x12\x04\xf2\x02\x18#\n\r\n\x05\x048\x02\x03\x03\
    \x12\x04\xf2\x02&'\n\x0c\n\x02\x049\x12\x06\xf5\x02\0\xfa\x02\x01\n\x0b\
    \n\x03\x049\x01\x12\x04\xf5\x02\x085\n\x0c\n\x04\x049\x02\0\x12\x04\xf6\
    \x02\x08*\n\r\n\x05\x049\x02\0\x04\x12\x04\xf6\x02\x08\x10\n\r\n\x05\x04\
    9\x02\0\x05\x12\x04\xf6\x02\x11\x17\n\r\n\x05\x049\x02\0\x01\x12\x04\xf6\
    \x02\x18%\n\r\n\x05\x049\x02\0\x03\x12\x04\xf6\x02()\n\x0c\n\x04\x049\
    \x02\x01\x12\x04\xf7\x02\x08%\n\r\n\x05\x049\x02\x01\x04\x12\x04\xf7\x02\
    \x08\x10\n\r\n\x05\x049\x02\x01\x05\x12\x04\xf7\x02\x11\x18\n\r\n\x05\
    \x049\x02\x01\x01\x12\x04\xf7\x02\x19\x20\n\r\n\x05\x049\x02\x01\x03\x12\
    \x04\xf7\x02#$\n\x0c\n\x04\x049\x02\x02\x12\x04\xf8\x02\x08$\n\r\n\x05\
    \x049\x02\x02\x04\x12\x04\xf8\x02\x08\x10\n\r\n\x05\x049\x02\x02\x05\x12\
    \x04\xf8\x02\x11\x17\n\r\n\x05\x049\x02\x02\x01\x12\x04\xf8\x02\x18\x1f\
    \n\r\n\x05\x049\x02\x02\x03\x12\x04\xf8\x02\"#\n\x0c\n\x04\x049\x02\x03\
    \x12\x04\xf9\x02\x08/\n\r\n\x05\x049\x02\x03\x04\x12\x04\xf9\x02\x08\x10\
    \n\r\n\x05\x049\x02\x03\x05\x12\x04\xf9\x02\x11\x15\n\r\n\x05\x049\x02\
    \x03\x01\x12\x04\xf9\x02\x16*\n\r\n\x05\x049\x02\x03\x03\x12\x04\xf9\x02\
    -.\n\x0c\n\x02\x04:\x12\x06\xfc\x02\0\xfd\x02\x01\n\x0b\n\x03\x04:\x01\
    \x12\x04\xfc\x02\x086\n\x0c\n\x02\x04;\x12\x06\xff\x02\0\x81\x03\x01\n\
    \x0b\n\x03\x04;\x01\x12\x04\xff\x02\x08,\n\x0c\n\x04\x04;\x02\0\x12\x04\
    \x80\x03\x08*\n\r\n\x05\x04;\x02\0\x04\x12\x04\x80\x03\x08\x10\n\r\n\x05\
    \x04;\x02\0\x05\x12\x04\x80\x03\x11\x17\n\r\n\x05\x04;\x02\0\x01\x12\x04\
    \x80\x03\x18%\n\r\n\x05\x04;\x02\0\x03\x12\x04\x80\x03()\n\x0c\n\x02\x04\
    <\x12\x06\x83\x03\0\x84\x03\x01\n\x0b\n\x03\x04<\x01\x12\x04\x83\x03\x08\
    -\n\x0c\n\x02\x04=\x12\x06\x86\x03\0\x8a\x03\x01\n\x0b\n\x03\x04=\x01\
    \x12\x04\x86\x03\x08(\n\x0c\n\x04\x04=\x02\0\x12\x04\x87\x03\x08*\n\r\n\
    \x05\x04=\x02\0\x04\x12\x04\x87\x03\x08\x10\n\r\n\x05\x04=\x02\0\x05\x12\
    \x04\x87\x03\x11\x17\n\r\n\x05\x04=\x02\0\x01\x12\x04\x87\x03\x18%\n\r\n\
    \x05\x04=\x02\0\x03\x12\x04\x87\x03()\n\x0c\n\x04\x04=\x02\x01\x12\x04\
    \x88\x03\x08!\n\r\n\x05\x04=\x02\x01\x04\x12\x04\x88\x03\x08\x10\n\r\n\
    \x05\x04=\x02\x01\x05\x12\x04\x88\x03\x11\x17\n\r\n\x05\x04=\x02\x01\x01\
    \x12\x04\x88\x03\x18\x1c\n\r\n\x05\x04=\x02\x01\x03\x12\x04\x88\x03\x1f\
    \x20\n\x0c\n\x04\x04=\x02\x02\x12\x04\x89\x03\x08&\n\r\n\x05\x04=\x02\
    \x02\x04\x12\x04\x89\x03\x08\x10\n\r\n\x05\x04=\x02\x02\x05\x12\x04\x89\
    \x03\x11\x15\n\r\n\x05\x04=\x02\x02\x01\x12\x04\x89\x03\x16!\n\r\n\x05\
    \x04=\x02\x02\x03\x12\x04\x89\x03$%\n\x0c\n\x02\x04>\x12\x06\x8c\x03\0\
    \x8e\x03\x01\n\x0b\n\x03\x04>\x01\x12\x04\x8c\x03\x08)\n\x0c\n\x04\x04>\
    \x02\0\x12\x04\x8d\x03\x08/\n\r\n\x05\x04>\x02\0\x04\x12\x04\x8d\x03\x08\
    \x10\n\r\n\x05\x04>\x02\0\x06\x12\x04\x8d\x03\x11\x20\n\r\n\x05\x04>\x02\
    \0\x01\x12\x04\x8d\x03!*\n\r\n\x05\x04>\x02\0\x03\x12\x04\x8d\x03-.\n\
    \x0c\n\x02\x04?\x12\x06\x90\x03\0\x93\x03\x01\n\x0b\n\x03\x04?\x01\x12\
    \x04\x90\x03\x08(\n\x0c\n\x04\x04?\x02\0\x12\x04\x91\x03\x08*\n\r\n\x05\
    \x04?\x02\0\x04\x12\x04\x91\x03\x08\x10\n\r\n\x05\x04?\x02\0\x05\x12\x04\
    \x91\x03\x11\x17\n\r\n\x05\x04?\x02\0\x01\x12\x04\x91\x03\x18%\n\r\n\x05\
    \x04?\x02\0\x03\x12\x04\x91\x03()\n\x0c\n\x04\x04?\x02\x01\x12\x04\x92\
    \x03\x08$\n\r\n\x05\x04?\x02\x01\x04\x12\x04\x92\x03\x08\x10\n\r\n\x05\
    \x04?\x02\x01\x05\x12\x04\x92\x03\x11\x17\n\r\n\x05\x04?\x02\x01\x01\x12\
    \x04\x92\x03\x18\x1f\n\r\n\x05\x04?\x02\x01\x03\x12\x04\x92\x03\"#\n\x0c\
    \n\x02\x04@\x12\x06\x95\x03\0\x96\x03\x01\n\x0b\n\x03\x04@\x01\x12\x04\
    \x95\x03\x08)\n\x0c\n\x02\x04A\x12\x06\x98\x03\0\x9c\x03\x01\n\x0b\n\x03\
    \x04A\x01\x12\x04\x98\x03\x08(\n\x0c\n\x04\x04A\x02\0\x12\x04\x99\x03\
    \x08*\n\r\n\x05\x04A\x02\0\x04\x12\x04\x99\x03\x08\x10\n\r\n\x05\x04A\
    \x02\0\x05\x12\x04\x99\x03\x11\x17\n\r\n\x05\x04A\x02\0\x01\x12\x04\x99\
    \x03\x18%\n\r\n\x05\x04A\x02\0\x03\x12\x04\x99\x03()\n\x0c\n\x04\x04A\
    \x02\x01\x12\x04\x9a\x03\x08$\n\r\n\x05\x04A\x02\x01\x04\x12\x04\x9a\x03\
    \x08\x10\n\r\n\x05\x04A\x02\x01\x05\x12\x04\x9a\x03\x11\x17\n\r\n\x05\
    \x04A\x02\x01\x01\x12\x04\x9a\x03\x18\x1f\n\r\n\x05\x04A\x02\x01\x03\x12\
    \x04\x9a\x03\"#\n\x0c\n\x04\x04A\x02\x02\x12\x04\x9b\x03\x08!\n\r\n\x05\
    \x04A\x02\x02\x04\x12\x04\x9b\x03\x08\x10\n\r\n\x05\x04A\x02\x02\x05\x12\
    \x04\x9b\x03\x11\x17\n\r\n\x05\x04A\x02\x02\x01\x12\x04\x9b\x03\x18\x1c\
    \n\r\n\x05\x04A\x02\x02\x03\x12\x04\x9b\x03\x1f\x20\n\x0c\n\x02\x04B\x12\
    \x06\x9e\x03\0\x9f\x03\x01\n\x0b\n\x03\x04B\x01\x12\x04\x9e\x03\x08)\n\
    \x0c\n\x02\x04C\x12\x06\xa1\x03\0\xa5\x03\x01\n\x0b\n\x03\x04C\x01\x12\
    \x04\xa1\x03\x08)\n\x0c\n\x04\x04C\x02\0\x12\x04\xa2\x03\x08*\n\r\n\x05\
    \x04C\x02\0\x04\x12\x04\xa2\x03\x08\x10\n\r\n\x05\x04C\x02\0\x05\x12\x04\
    \xa2\x03\x11\x17\n\r\n\x05\x04C\x02\0\x01\x12\x04\xa2\x03\x18%\n\r\n\x05\
    \x04C\x02\0\x03\x12\x04\xa2\x03()\n\x0c\n\x04\x04C\x02\x01\x12\x04\xa3\
    \x03\x08$\n\r\n\x05\x04C\x02\x01\x04\x12\x04\xa3\x03\x08\x10\n\r\n\x05\
    \x04C\x02\x01\x05\x12\x04\xa3\x03\x11\x17\n\r\n\x05\x04C\x02\x01\x01\x12\
    \x04\xa3\x03\x18\x1f\n\r\n\x05\x04C\x02\x01\x03\x12\x04\xa3\x03\"#\n\x0c\
    \n\x04\x04C\x02\x02\x12\x04\xa4\x03\x08/\n\r\n\x05\x04C\x02\x02\x04\x12\
    \x04\xa4\x03\x08\x10\n\r\n\x05\x04C\x02\x02\x05\x12\x04\xa4\x03\x11\x17\
    \n\r\n\x05\x04C\x02\x02\x01\x12\x04\xa4\x03\x18*\n\r\n\x05\x04C\x02\x02\
    \x03\x12\x04\xa4\x03-.\n\x0c\n\x02\x04D\x12\x06\xa7\x03\0\xa8\x03\x01\n\
    \x0b\n\x03\x04D\x01\x12\x04\xa7\x03\x08*\n\x0c\n\x02\x04E\x12\x06\xaa\
    \x03\0\xaf\x03\x01\n\x0b\n\x03\x04E\x01\x12\x04\xaa\x03\x08)\n\x0c\n\x04\
    \x04E\x02\0\x12\x04\xab\x03\x08*\n\r\n\x05\x04E\x02\0\x04\x12\x04\xab\
    \x03\x08\x10\n\r\n\x05\x04E\x02\0\x05\x12\x04\xab\x03\x11\x17\n\r\n\x05\
    \x04E\x02\0\x01\x12\x04\xab\x03\x18%\n\r\n\x05\x04E\x02\0\x03\x12\x04\
    \xab\x03()\n\x0c\n\x04\x04E\x02\x01\x12\x04\xac\x03\x08$\n\r\n\x05\x04E\
    \x02\x01\x04\x12\x04\xac\x03\x08\x10\n\r\n\x05\x04E\x02\x01\x05\x12\x04\
    \xac\x03\x11\x17\n\r\n\x05\x04E\x02\x01\x01\x12\x04\xac\x03\x18\x1f\n\r\
    \n\x05\x04E\x02\x01\x03\x12\x04\xac\x03\"#\n\x0c\n\x04\x04E\x02\x02\x12\
    \x04\xad\x03\x08$\n\r\n\x05\x04E\x02\x02\x04\x12\x04\xad\x03\x08\x10\n\r\
    \n\x05\x04E\x02\x02\x05\x12\x04\xad\x03\x11\x17\n\r\n\x05\x04E\x02\x02\
    \x01\x12\x04\xad\x03\x18\x1f\n\r\n\x05\x04E\x02\x02\x03\x12\x04\xad\x03\
    \"#\n\x0c\n\x04\x04E\x02\x03\x12\x04\xae\x03\x08)\n\r\n\x05\x04E\x02\x03\
    \x04\x12\x04\xae\x03\x08\x10\n\r\n\x05\x04E\x02\x03\x05\x12\x04\xae\x03\
    \x11\x15\n\r\n\x05\x04E\x02\x03\x01\x12\x04\xae\x03\x16$\n\r\n\x05\x04E\
    \x02\x03\x03\x12\x04\xae\x03'(\n\x0c\n\x02\x04F\x12\x06\xb1\x03\0\xb6\
    \x03\x01\n\x0b\n\x03\x04F\x01\x12\x04\xb1\x03\x08*\n\x0c\n\x04\x04F\x02\
    \0\x12\x04\xb2\x03\x08-\n\r\n\x05\x04F\x02\0\x04\x12\x04\xb2\x03\x08\x10\
    \n\r\n\x05\x04F\x02\0\x05\x12\x04\xb2\x03\x11\x17\n\r\n\x05\x04F\x02\0\
    \x01\x12\x04\xb2\x03\x18(\n\r\n\x05\x04F\x02\0\x03\x12\x04\xb2\x03+,\n\
    \x0c\n\x04\x04F\x02\x01\x12\x04\xb3\x03\x08-\n\r\n\x05\x04F\x02\x01\x04\
    \x12\x04\xb3\x03\x08\x10\n\r\n\x05\x04F\x02\x01\x05\x12\x04\xb3\x03\x11\
    \x17\n\r\n\x05\x04F\x02\x01\x01\x12\x04\xb3\x03\x18(\n\r\n\x05\x04F\x02\
    \x01\x03\x12\x04\xb3\x03+,\n\x0c\n\x04\x04F\x02\x02\x12\x04\xb4\x03\x08$\
    \n\r\n\x05\x04F\x02\x02\x04\x12\x04\xb4\x03\x08\x10\n\r\n\x05\x04F\x02\
    \x02\x05\x12\x04\xb4\x03\x11\x17\n\r\n\x05\x04F\x02\x02\x01\x12\x04\xb4\
    \x03\x18\x1f\n\r\n\x05\x04F\x02\x02\x03\x12\x04\xb4\x03\"#\n\x0c\n\x04\
    \x04F\x02\x03\x12\x04\xb5\x03\x084\n\r\n\x05\x04F\x02\x03\x04\x12\x04\
    \xb5\x03\x08\x10\n\r\n\x05\x04F\x02\x03\x05\x12\x04\xb5\x03\x11\x17\n\r\
    \n\x05\x04F\x02\x03\x01\x12\x04\xb5\x03\x18/\n\r\n\x05\x04F\x02\x03\x03\
    \x12\x04\xb5\x0323\n\x0c\n\x02\x04G\x12\x06\xb8\x03\0\xbb\x03\x01\n\x0b\
    \n\x03\x04G\x01\x12\x04\xb8\x03\x08'\n\x0c\n\x04\x04G\x02\0\x12\x04\xb9\
    \x03\x08*\n\r\n\x05\x04G\x02\0\x04\x12\x04\xb9\x03\x08\x10\n\r\n\x05\x04\
    G\x02\0\x05\x12\x04\xb9\x03\x11\x17\n\r\n\x05\x04G\x02\0\x01\x12\x04\xb9\
    \x03\x18%\n\r\n\x05\x04G\x02\0\x03\x12\x04\xb9\x03()\n\x0c\n\x04\x04G\
    \x02\x01\x12\x04\xba\x03\x08$\n\r\n\x05\x04G\x02\x01\x04\x12\x04\xba\x03\
    \x08\x10\n\r\n\x05\x04G\x02\x01\x05\x12\x04\xba\x03\x11\x17\n\r\n\x05\
    \x04G\x02\x01\x01\x12\x04\xba\x03\x18\x1f\n\r\n\x05\x04G\x02\x01\x03\x12\
    \x04\xba\x03\"#\n\x0c\n\x02\x04H\x12\x06\xbd\x03\0\xbf\x03\x01\n\x0b\n\
    \x03\x04H\x01\x12\x04\xbd\x03\x08(\n\x0c\n\x04\x04H\x02\0\x12\x04\xbe\
    \x03\x08)\n\r\n\x05\x04H\x02\0\x04\x12\x04\xbe\x03\x08\x10\n\r\n\x05\x04\
    H\x02\0\x05\x12\x04\xbe\x03\x11\x17\n\r\n\x05\x04H\x02\0\x01\x12\x04\xbe\
    \x03\x18$\n\r\n\x05\x04H\x02\0\x03\x12\x04\xbe\x03'(\n\x0c\n\x02\x04I\
    \x12\x06\xc1\x03\0\xc4\x03\x01\n\x0b\n\x03\x04I\x01\x12\x04\xc1\x03\x08(\
    \n\x0c\n\x04\x04I\x02\0\x12\x04\xc2\x03\x08*\n\r\n\x05\x04I\x02\0\x04\
    \x12\x04\xc2\x03\x08\x10\n\r\n\x05\x04I\x02\0\x05\x12\x04\xc2\x03\x11\
    \x17\n\r\n\x05\x04I\x02\0\x01\x12\x04\xc2\x03\x18%\n\r\n\x05\x04I\x02\0\
    \x03\x12\x04\xc2\x03()\n\x0c\n\x04\x04I\x02\x01\x12\x04\xc3\x03\x08$\n\r\
    \n\x05\x04I\x02\x01\x04\x12\x04\xc3\x03\x08\x10\n\r\n\x05\x04I\x02\x01\
    \x05\x12\x04\xc3\x03\x11\x17\n\r\n\x05\x04I\x02\x01\x01\x12\x04\xc3\x03\
    \x18\x1f\n\r\n\x05\x04I\x02\x01\x03\x12\x04\xc3\x03\"#\n\x0c\n\x02\x04J\
    \x12\x06\xc6\x03\0\xc7\x03\x01\n\x0b\n\x03\x04J\x01\x12\x04\xc6\x03\x08)\
    \n\x0c\n\x02\x04K\x12\x06\xc9\x03\0\xd1\x03\x01\n\x0b\n\x03\x04K\x01\x12\
    \x04\xc9\x03\x08+\n\x0c\n\x04\x04K\x02\0\x12\x04\xca\x03\x08*\n\r\n\x05\
    \x04K\x02\0\x04\x12\x04\xca\x03\x08\x10\n\r\n\x05\x04K\x02\0\x05\x12\x04\
    \xca\x03\x11\x17\n\r\n\x05\x04K\x02\0\x01\x12\x04\xca\x03\x18%\n\r\n\x05\
    \x04K\x02\0\x03\x12\x04\xca\x03()\n\x0c\n\x04\x04K\x02\x01\x12\x04\xcb\
    \x03\x08$\n\r\n\x05\x04K\x02\x01\x04\x12\x04\xcb\x03\x08\x10\n\r\n\x05\
    \x04K\x02\x01\x05\x12\x04\xcb\x03\x11\x17\n\r\n\x05\x04K\x02\x01\x01\x12\
    \x04\xcb\x03\x18\x1f\n\r\n\x05\x04K\x02\x01\x03\x12\x04\xcb\x03\"#\n\x0c\
    \n\x04\x04K\x02\x02\x12\x04\xcc\x03\x08&\n\r\n\x05\x04K\x02\x02\x04\x12\
    \x04\xcc\x03\x08\x10\n\r\n\x05\x04K\x02\x02\x05\x12\x04\xcc\x03\x11\x17\
    \n\r\n\x05\x04K\x02\x02\x01\x12\x04\xcc\x03\x18!\n\r\n\x05\x04K\x02\x02\
    \x03\x12\x04\xcc\x03$%\n\x0c\n\x04\x04K\x02\x03\x12\x04\xcd\x03\x08)\n\r\
    \n\x05\x04K\x02\x03\x04\x12\x04\xcd\x03\x08\x10\n\r\n\x05\x04K\x02\x03\
    \x05\x12\x04\xcd\x03\x11\x17\n\r\n\x05\x04K\x02\x03\x01\x12\x04\xcd\x03\
    \x18$\n\r\n\x05\x04K\x02\x03\x03\x12\x04\xcd\x03'(\n\x0c\n\x04\x04K\x02\
    \x04\x12\x04\xce\x03\x08'\n\r\n\x05\x04K\x02\x04\x04\x12\x04\xce\x03\x08\
    \x10\n\r\n\x05\x04K\x02\x04\x05\x12\x04\xce\x03\x11\x17\n\r\n\x05\x04K\
    \x02\x04\x01\x12\x04\xce\x03\x18\"\n\r\n\x05\x04K\x02\x04\x03\x12\x04\
    \xce\x03%&\n\x0c\n\x04\x04K\x02\x05\x12\x04\xcf\x03\x08*\n\r\n\x05\x04K\
    \x02\x05\x04\x12\x04\xcf\x03\x08\x10\n\r\n\x05\x04K\x02\x05\x05\x12\x04\
    \xcf\x03\x11\x17\n\r\n\x05\x04K\x02\x05\x01\x12\x04\xcf\x03\x18%\n\r\n\
    \x05\x04K\x02\x05\x03\x12\x04\xcf\x03()\n\x0c\n\x04\x04K\x02\x06\x12\x04\
    \xd0\x03\x08&\n\r\n\x05\x04K\x02\x06\x04\x12\x04\xd0\x03\x08\x10\n\r\n\
    \x05\x04K\x02\x06\x05\x12\x04\xd0\x03\x11\x17\n\r\n\x05\x04K\x02\x06\x01\
    \x12\x04\xd0\x03\x18!\n\r\n\x05\x04K\x02\x06\x03\x12\x04\xd0\x03$%\n\x0c\
    \n\x02\x04L\x12\x06\xd3\x03\0\xd7\x03\x01\n\x0b\n\x03\x04L\x01\x12\x04\
    \xd3\x03\x08\x15\n\x0c\n\x04\x04L\x02\0\x12\x04\xd4\x03\x08^\n\r\n\x05\
    \x04L\x02\0\x04\x12\x04\xd4\x03\x08\x10\n\r\n\x05\x04L\x02\0\x06\x12\x04\
    \xd4\x03\x11(\n\r\n\x05\x04L\x02\0\x01\x12\x04\xd4\x03)0\n\r\n\x05\x04L\
    \x02\0\x03\x12\x04\xd4\x0334\n\r\n\x05\x04L\x02\0\x08\x12\x04\xd4\x035]\
    \n\r\n\x05\x04L\x02\0\x07\x12\x04\xd4\x03@\\\n\x0c\n\x04\x04L\x02\x01\
    \x12\x04\xd5\x03\x08)\n\r\n\x05\x04L\x02\x01\x04\x12\x04\xd5\x03\x08\x10\
    \n\r\n\x05\x04L\x02\x01\x05\x12\x04\xd5\x03\x11\x17\n\r\n\x05\x04L\x02\
    \x01\x01\x12\x04\xd5\x03\x18$\n\r\n\x05\x04L\x02\x01\x03\x12\x04\xd5\x03\
    '(\n\x0c\n\x04\x04L\x02\x02\x12\x04\xd6\x03\x08,\n\r\n\x05\x04L\x02\x02\
    \x04\x12\x04\xd6\x03\x08\x10\n\r\n\x05\x04L\x02\x02\x05\x12\x04\xd6\x03\
    \x11\x17\n\r\n\x05\x04L\x02\x02\x01\x12\x04\xd6\x03\x18'\n\r\n\x05\x04L\
    \x02\x02\x03\x12\x04\xd6\x03*+\n\x0c\n\x02\x04M\x12\x06\xd9\x03\0\xed\
    \x03\x01\n\x0b\n\x03\x04M\x01\x12\x04\xd9\x03\x08,\n\x0e\n\x04\x04M\x03\
    \0\x12\x06\xda\x03\x08\xe9\x03\t\n\r\n\x05\x04M\x03\0\x01\x12\x04\xda\
    \x03\x10\x1b\n\x10\n\x06\x04M\x03\0\x03\0\x12\x06\xdb\x03\x10\xe0\x03\
    \x11\n\x0f\n\x07\x04M\x03\0\x03\0\x01\x12\x04\xdb\x03\x18'\n\x11\n\x08\
    \x04M\x03\0\x03\0\x02\0\x12\x05\xdc\x03\x18\x84\x01\n\x11\n\t\x04M\x03\0\
    \x03\0\x02\0\x04\x12\x04\xdc\x03\x18\x20\n\x11\n\t\x04M\x03\0\x03\0\x02\
    \0\x06\x12\x04\xdc\x03!>\n\x11\n\t\x04M\x03\0\x03\0\x02\0\x01\x12\x04\
    \xdc\x03?L\n\x11\n\t\x04M\x03\0\x03\0\x02\0\x03\x12\x04\xdc\x03OP\n\x12\
    \n\t\x04M\x03\0\x03\0\x02\0\x08\x12\x05\xdc\x03Q\x83\x01\n\x12\n\t\x04M\
    \x03\0\x03\0\x02\0\x07\x12\x05\xdc\x03\\\x82\x01\n\x10\n\x08\x04M\x03\0\
    \x03\0\x02\x01\x12\x04\xdd\x03\x185\n\x11\n\t\x04M\x03\0\x03\0\x02\x01\
    \x04\x12\x04\xdd\x03\x18\x20\n\x11\n\t\x04M\x03\0\x03\0\x02\x01\x05\x12\
    \x04\xdd\x03!'\n\x11\n\t\x04M\x03\0\x03\0\x02\x01\x01\x12\x04\xdd\x03(0\
    \n\x11\n\t\x04M\x03\0\x03\0\x02\x01\x03\x12\x04\xdd\x0334\n\x10\n\x08\
    \x04M\x03\0\x03\0\x02\x02\x12\x04\xde\x03\x189\n\x11\n\t\x04M\x03\0\x03\
    \0\x02\x02\x04\x12\x04\xde\x03\x18\x20\n\x11\n\t\x04M\x03\0\x03\0\x02\
    \x02\x05\x12\x04\xde\x03!'\n\x11\n\t\x04M\x03\0\x03\0\x02\x02\x01\x12\
    \x04\xde\x03(4\n\x11\n\t\x04M\x03\0\x03\0\x02\x02\x03\x12\x04\xde\x0378\
    \n\x10\n\x08\x04M\x03\0\x03\0\x02\x03\x12\x04\xdf\x03\x18;\n\x11\n\t\x04\
    M\x03\0\x03\0\x02\x03\x04\x12\x04\xdf\x03\x18\x20\n\x11\n\t\x04M\x03\0\
    \x03\0\x02\x03\x05\x12\x04\xdf\x03!%\n\x11\n\t\x04M\x03\0\x03\0\x02\x03\
    \x01\x12\x04\xdf\x03&6\n\x11\n\t\x04M\x03\0\x03\0\x02\x03\x03\x12\x04\
    \xdf\x039:\n\x0e\n\x06\x04M\x03\0\x02\0\x12\x04\xe2\x03\x10+\n\x0f\n\x07\
    \x04M\x03\0\x02\0\x04\x12\x04\xe2\x03\x10\x18\n\x0f\n\x07\x04M\x03\0\x02\
    \0\x05\x12\x04\xe2\x03\x19\x1f\n\x0f\n\x07\x04M\x03\0\x02\0\x01\x12\x04\
    \xe2\x03\x20&\n\x0f\n\x07\x04M\x03\0\x02\0\x03\x12\x04\xe2\x03)*\n\x0e\n\
    \x06\x04M\x03\0\x02\x01\x12\x04\xe3\x03\x105\n\x0f\n\x07\x04M\x03\0\x02\
    \x01\x04\x12\x04\xe3\x03\x10\x18\n\x0f\n\x07\x04M\x03\0\x02\x01\x05\x12\
    \x04\xe3\x03\x19\x1f\n\x0f\n\x07\x04M\x03\0\x02\x01\x01\x12\x04\xe3\x03\
    \x200\n\x0f\n\x07\x04M\x03\0\x02\x01\x03\x12\x04\xe3\x0334\n\x0e\n\x06\
    \x04M\x03\0\x02\x02\x12\x04\xe4\x03\x10,\n\x0f\n\x07\x04M\x03\0\x02\x02\
    \x04\x12\x04\xe4\x03\x10\x18\n\x0f\n\x07\x04M\x03\0\x02\x02\x05\x12\x04\
    \xe4\x03\x19\x1f\n\x0f\n\x07\x04M\x03\0\x02\x02\x01\x12\x04\xe4\x03\x20'\
    \n\x0f\n\x07\x04M\x03\0\x02\x02\x03\x12\x04\xe4\x03*+\n\x0e\n\x06\x04M\
    \x03\0\x02\x03\x12\x04\xe5\x03\x10,\n\x0f\n\x07\x04M\x03\0\x02\x03\x04\
    \x12\x04\xe5\x03\x10\x18\n\x0f\n\x07\x04M\x03\0\x02\x03\x05\x12\x04\xe5\
    \x03\x19\x1f\n\x0f\n\x07\x04M\x03\0\x02\x03\x01\x12\x04\xe5\x03\x20'\n\
    \x0f\n\x07\x04M\x03\0\x02\x03\x03\x12\x04\xe5\x03*+\n\x0e\n\x06\x04M\x03\
    \0\x02\x04\x12\x04\xe6\x03\x10;\n\x0f\n\x07\x04M\x03\0\x02\x04\x04\x12\
    \x04\xe6\x03\x10\x18\n\x0f\n\x07\x04M\x03\0\x02\x04\x06\x12\x04\xe6\x03\
    \x19'\n\x0f\n\x07\x04M\x03\0\x02\x04\x01\x12\x04\xe6\x03(6\n\x0f\n\x07\
    \x04M\x03\0\x02\x04\x03\x12\x04\xe6\x039:\n\x0e\n\x06\x04M\x03\0\x02\x05\
    \x12\x04\xe7\x03\x10*\n\x0f\n\x07\x04M\x03\0\x02\x05\x04\x12\x04\xe7\x03\
    \x10\x18\n\x0f\n\x07\x04M\x03\0\x02\x05\x05\x12\x04\xe7\x03\x19\x1d\n\
    \x0f\n\x07\x04M\x03\0\x02\x05\x01\x12\x04\xe7\x03\x1e%\n\x0f\n\x07\x04M\
    \x03\0\x02\x05\x03\x12\x04\xe7\x03()\n\x0e\n\x06\x04M\x03\0\x02\x06\x12\
    \x04\xe8\x03\x10i\n\x0f\n\x07\x04M\x03\0\x02\x06\x04\x12\x04\xe8\x03\x10\
    \x18\n\x0f\n\x07\x04M\x03\0\x02\x06\x06\x12\x04\xe8\x03\x19Z\n\x0f\n\x07\
    \x04M\x03\0\x02\x06\x01\x12\x04\xe8\x03[d\n\x0f\n\x07\x04M\x03\0\x02\x06\
    \x03\x12\x04\xe8\x03gh\n\x0c\n\x04\x04M\x02\0\x12\x04\xeb\x03\x08P\n\r\n\
    \x05\x04M\x02\0\x04\x12\x04\xeb\x03\x08\x10\n\r\n\x05\x04M\x02\0\x06\x12\
    \x04\xeb\x03\x11B\n\r\n\x05\x04M\x02\0\x01\x12\x04\xeb\x03CK\n\r\n\x05\
    \x04M\x02\0\x03\x12\x04\xeb\x03NO\n\x0c\n\x04\x04M\x02\x01\x12\x04\xec\
    \x03\x08)\n\r\n\x05\x04M\x02\x01\x04\x12\x04\xec\x03\x08\x10\n\r\n\x05\
    \x04M\x02\x01\x05\x12\x04\xec\x03\x11\x15\n\r\n\x05\x04M\x02\x01\x01\x12\
    \x04\xec\x03\x16$\n\r\n\x05\x04M\x02\x01\x03\x12\x04\xec\x03'(\n\x0c\n\
    \x02\x04N\x12\x06\xef\x03\0\xf0\x03\x01\n\x0b\n\x03\x04N\x01\x12\x04\xef\
    \x03\x08-\n\x0c\n\x02\x04O\x12\x06\xf2\x03\0\x88\x04\x01\n\x0b\n\x03\x04\
    O\x01\x12\x04\xf2\x03\x082\n\x0c\n\x04\x04O\x02\0\x12\x04\xf3\x03\x08*\n\
    \r\n\x05\x04O\x02\0\x04\x12\x04\xf3\x03\x08\x10\n\r\n\x05\x04O\x02\0\x05\
    \x12\x04\xf3\x03\x11\x17\n\r\n\x05\x04O\x02\0\x01\x12\x04\xf3\x03\x18%\n\
    \r\n\x05\x04O\x02\0\x03\x12\x04\xf3\x03()\n\x0c\n\x04\x04O\x02\x01\x12\
    \x04\xf4\x03\x08,\n\r\n\x05\x04O\x02\x01\x04\x12\x04\xf4\x03\x08\x10\n\r\
    \n\x05\x04O\x02\x01\x05\x12\x04\xf4\x03\x11\x17\n\r\n\x05\x04O\x02\x01\
    \x01\x12\x04\xf4\x03\x18'\n\r\n\x05\x04O\x02\x01\x03\x12\x04\xf4\x03*+\n\
    \x0c\n\x04\x04O\x02\x02\x12\x04\xf5\x03\x080\n\r\n\x05\x04O\x02\x02\x04\
    \x12\x04\xf5\x03\x08\x10\n\r\n\x05\x04O\x02\x02\x05\x12\x04\xf5\x03\x11\
    \x17\n\r\n\x05\x04O\x02\x02\x01\x12\x04\xf5\x03\x18+\n\r\n\x05\x04O\x02\
    \x02\x03\x12\x04\xf5\x03./\n\x0c\n\x04\x04O\x02\x03\x12\x04\xf6\x03\x086\
    \n\r\n\x05\x04O\x02\x03\x04\x12\x04\xf6\x03\x08\x10\n\r\n\x05\x04O\x02\
    \x03\x05\x12\x04\xf6\x03\x11\x17\n\r\n\x05\x04O\x02\x03\x01\x12\x04\xf6\
    \x03\x181\n\r\n\x05\x04O\x02\x03\x03\x12\x04\xf6\x0345\n\x0c\n\x04\x04O\
    \x02\x04\x12\x04\xf7\x03\x08,\n\r\n\x05\x04O\x02\x04\x04\x12\x04\xf7\x03\
    \x08\x10\n\r\n\x05\x04O\x02\x04\x05\x12\x04\xf7\x03\x11\x17\n\r\n\x05\
    \x04O\x02\x04\x01\x12\x04\xf7\x03\x18'\n\r\n\x05\x04O\x02\x04\x03\x12\
    \x04\xf7\x03*+\n\x0c\n\x04\x04O\x02\x05\x12\x04\xf8\x03\x080\n\r\n\x05\
    \x04O\x02\x05\x04\x12\x04\xf8\x03\x08\x10\n\r\n\x05\x04O\x02\x05\x06\x12\
    \x04\xf8\x03\x11\x20\n\r\n\x05\x04O\x02\x05\x01\x12\x04\xf8\x03!+\n\r\n\
    \x05\x04O\x02\x05\x03\x12\x04\xf8\x03./\n\x0c\n\x04\x04O\x02\x06\x12\x04\
    \xf9\x03\x08#\n\r\n\x05\x04O\x02\x06\x04\x12\x04\xf9\x03\x08\x10\n\r\n\
    \x05\x04O\x02\x06\x05\x12\x04\xf9\x03\x11\x17\n\r\n\x05\x04O\x02\x06\x01\
    \x12\x04\xf9\x03\x18\x1e\n\r\n\x05\x04O\x02\x06\x03\x12\x04\xf9\x03!\"\n\
    \x0c\n\x04\x04O\x02\x07\x12\x04\xfa\x03\x08/\n\r\n\x05\x04O\x02\x07\x04\
    \x12\x04\xfa\x03\x08\x10\n\r\n\x05\x04O\x02\x07\x05\x12\x04\xfa\x03\x11\
    \x17\n\r\n\x05\x04O\x02\x07\x01\x12\x04\xfa\x03\x18*\n\r\n\x05\x04O\x02\
    \x07\x03\x12\x04\xfa\x03-.\n\x0c\n\x04\x04O\x02\x08\x12\x04\xfb\x03\x08,\
    \n\r\n\x05\x04O\x02\x08\x04\x12\x04\xfb\x03\x08\x10\n\r\n\x05\x04O\x02\
    \x08\x05\x12\x04\xfb\x03\x11\x17\n\r\n\x05\x04O\x02\x08\x01\x12\x04\xfb\
    \x03\x18'\n\r\n\x05\x04O\x02\x08\x03\x12\x04\xfb\x03*+\n\x0c\n\x04\x04O\
    \x02\t\x12\x04\xfc\x03\x08)\n\r\n\x05\x04O\x02\t\x04\x12\x04\xfc\x03\x08\
    \x10\n\r\n\x05\x04O\x02\t\x05\x12\x04\xfc\x03\x11\x17\n\r\n\x05\x04O\x02\
    \t\x01\x12\x04\xfc\x03\x18#\n\r\n\x05\x04O\x02\t\x03\x12\x04\xfc\x03&(\n\
    \x0c\n\x04\x04O\x02\n\x12\x04\xfd\x03\x082\n\r\n\x05\x04O\x02\n\x04\x12\
    \x04\xfd\x03\x08\x10\n\r\n\x05\x04O\x02\n\x05\x12\x04\xfd\x03\x11\x16\n\
    \r\n\x05\x04O\x02\n\x01\x12\x04\xfd\x03\x17,\n\r\n\x05\x04O\x02\n\x03\
    \x12\x04\xfd\x03/1\n\x0c\n\x04\x04O\x02\x0b\x12\x04\xfe\x03\x08X\n\r\n\
    \x05\x04O\x02\x0b\x04\x12\x04\xfe\x03\x08\x10\n\r\n\x05\x04O\x02\x0b\x06\
    \x12\x04\xfe\x03\x11$\n\r\n\x05\x04O\x02\x0b\x01\x12\x04\xfe\x03%)\n\r\n\
    \x05\x04O\x02\x0b\x03\x12\x04\xfe\x03,.\n\r\n\x05\x04O\x02\x0b\x08\x12\
    \x04\xfe\x03/W\n\r\n\x05\x04O\x02\x0b\x07\x12\x04\xfe\x03:V\n\x0c\n\x04\
    \x04O\x02\x0c\x12\x04\xff\x03\x08-\n\r\n\x05\x04O\x02\x0c\x04\x12\x04\
    \xff\x03\x08\x10\n\r\n\x05\x04O\x02\x0c\x05\x12\x04\xff\x03\x11\x17\n\r\
    \n\x05\x04O\x02\x0c\x01\x12\x04\xff\x03\x18'\n\r\n\x05\x04O\x02\x0c\x03\
    \x12\x04\xff\x03*,\n\x0c\n\x04\x04O\x02\r\x12\x04\x80\x04\x08&\n\r\n\x05\
    \x04O\x02\r\x04\x12\x04\x80\x04\x08\x10\n\r\n\x05\x04O\x02\r\x05\x12\x04\
    \x80\x04\x11\x17\n\r\n\x05\x04O\x02\r\x01\x12\x04\x80\x04\x18\x20\n\r\n\
    \x05\x04O\x02\r\x03\x12\x04\x80\x04#%\n\x0c\n\x04\x04O\x02\x0e\x12\x04\
    \x81\x04\x085\n\r\n\x05\x04O\x02\x0e\x04\x12\x04\x81\x04\x08\x10\n\r\n\
    \x05\x04O\x02\x0e\x06\x12\x04\x81\x04\x11\"\n\r\n\x05\x04O\x02\x0e\x01\
    \x12\x04\x81\x04#/\n\r\n\x05\x04O\x02\x0e\x03\x12\x04\x81\x0424\n\x0c\n\
    \x04\x04O\x02\x0f\x12\x04\x82\x04\x08:\n\r\n\x05\x04O\x02\x0f\x04\x12\
    \x04\x82\x04\x08\x10\n\r\n\x05\x04O\x02\x0f\x05\x12\x04\x82\x04\x11\x17\
    \n\r\n\x05\x04O\x02\x0f\x01\x12\x04\x82\x04\x184\n\r\n\x05\x04O\x02\x0f\
    \x03\x12\x04\x82\x0479\n\x0c\n\x04\x04O\x02\x10\x12\x04\x83\x04\x08#\n\r\
    \n\x05\x04O\x02\x10\x04\x12\x04\x83\x04\x08\x10\n\r\n\x05\x04O\x02\x10\
    \x05\x12\x04\x83\x04\x11\x17\n\r\n\x05\x04O\x02\x10\x01\x12\x04\x83\x04\
    \x18\x1d\n\r\n\x05\x04O\x02\x10\x03\x12\x04\x83\x04\x20\"\n\x0c\n\x04\
    \x04O\x02\x11\x12\x04\x84\x04\x086\n\r\n\x05\x04O\x02\x11\x04\x12\x04\
    \x84\x04\x08\x10\n\r\n\x05\x04O\x02\x11\x06\x12\x04\x84\x04\x11\"\n\r\n\
    \x05\x04O\x02\x11\x01\x12\x04\x84\x04#0\n\r\n\x05\x04O\x02\x11\x03\x12\
    \x04\x84\x0435\n\x0c\n\x04\x04O\x02\x12\x12\x04\x85\x04\x08;\n\r\n\x05\
    \x04O\x02\x12\x04\x12\x04\x85\x04\x08\x10\n\r\n\x05\x04O\x02\x12\x05\x12\
    \x04\x85\x04\x11\x17\n\r\n\x05\x04O\x02\x12\x01\x12\x04\x85\x04\x185\n\r\
    \n\x05\x04O\x02\x12\x03\x12\x04\x85\x048:\n\x0c\n\x04\x04O\x02\x13\x12\
    \x04\x86\x04\x080\n\r\n\x05\x04O\x02\x13\x04\x12\x04\x86\x04\x08\x10\n\r\
    \n\x05\x04O\x02\x13\x05\x12\x04\x86\x04\x11\x17\n\r\n\x05\x04O\x02\x13\
    \x01\x12\x04\x86\x04\x18*\n\r\n\x05\x04O\x02\x13\x03\x12\x04\x86\x04-/\n\
    \x0c\n\x04\x04O\x02\x14\x12\x04\x87\x04\x08,\n\r\n\x05\x04O\x02\x14\x04\
    \x12\x04\x87\x04\x08\x10\n\r\n\x05\x04O\x02\x14\x05\x12\x04\x87\x04\x11\
    \x17\n\r\n\x05\x04O\x02\x14\x01\x12\x04\x87\x04\x18&\n\r\n\x05\x04O\x02\
    \x14\x03\x12\x04\x87\x04)+\n\x0c\n\x02\x04P\x12\x06\x8a\x04\0\x8d\x04\
    \x01\n\x0b\n\x03\x04P\x01\x12\x04\x8a\x04\x08\x1c\n\x0c\n\x04\x04P\x02\0\
    \x12\x04\x8b\x04\x08D\n\r\n\x05\x04P\x02\0\x04\x12\x04\x8b\x04\x08\x10\n\
    \r\n\x05\x04P\x02\0\x06\x12\x04\x8b\x04\x11)\n\r\n\x05\x04P\x02\0\x01\
    \x12\x04\x8b\x04*?\n\r\n\x05\x04P\x02\0\x03\x12\x04\x8b\x04BC\n\x0c\n\
    \x04\x04P\x02\x01\x12\x04\x8c\x04\x08O\n\r\n\x05\x04P\x02\x01\x04\x12\
    \x04\x8c\x04\x08\x10\n\r\n\x05\x04P\x02\x01\x06\x12\x04\x8c\x04\x11<\n\r\
    \n\x05\x04P\x02\x01\x01\x12\x04\x8c\x04=J\n\r\n\x05\x04P\x02\x01\x03\x12\
    \x04\x8c\x04MN\n\x0c\n\x02\x04Q\x12\x06\x8f\x04\0\x91\x04\x01\n\x0b\n\
    \x03\x04Q\x01\x12\x04\x8f\x04\x08.\n\x0c\n\x04\x04Q\x02\0\x12\x04\x90\
    \x04\x08<\n\r\n\x05\x04Q\x02\0\x04\x12\x04\x90\x04\x08\x10\n\r\n\x05\x04\
    Q\x02\0\x06\x12\x04\x90\x04\x11&\n\r\n\x05\x04Q\x02\0\x01\x12\x04\x90\
    \x04'7\n\r\n\x05\x04Q\x02\0\x03\x12\x04\x90\x04:;\n\x0c\n\x02\x04R\x12\
    \x06\x93\x04\0\x95\x04\x01\n\x0b\n\x03\x04R\x01\x12\x04\x93\x04\x08/\n\
    \x0c\n\x04\x04R\x02\0\x12\x04\x94\x04\x08*\n\r\n\x05\x04R\x02\0\x04\x12\
    \x04\x94\x04\x08\x10\n\r\n\x05\x04R\x02\0\x05\x12\x04\x94\x04\x11\x17\n\
    \r\n\x05\x04R\x02\0\x01\x12\x04\x94\x04\x18%\n\r\n\x05\x04R\x02\0\x03\
    \x12\x04\x94\x04()\n\x0c\n\x02\x04S\x12\x06\x97\x04\0\x99\x04\x01\n\x0b\
    \n\x03\x04S\x01\x12\x04\x97\x04\x080\n\x0c\n\x04\x04S\x02\0\x12\x04\x98\
    \x04\x080\n\r\n\x05\x04S\x02\0\x04\x12\x04\x98\x04\x08\x10\n\r\n\x05\x04\
    S\x02\0\x06\x12\x04\x98\x04\x11%\n\r\n\x05\x04S\x02\0\x01\x12\x04\x98\
    \x04&+\n\r\n\x05\x04S\x02\0\x03\x12\x04\x98\x04./\n\x0c\n\x02\x04T\x12\
    \x06\x9b\x04\0\x9d\x04\x01\n\x0b\n\x03\x04T\x01\x12\x04\x9b\x04\x081\n\
    \x0c\n\x04\x04T\x02\0\x12\x04\x9c\x04\x08*\n\r\n\x05\x04T\x02\0\x04\x12\
    \x04\x9c\x04\x08\x10\n\r\n\x05\x04T\x02\0\x05\x12\x04\x9c\x04\x11\x17\n\
    \r\n\x05\x04T\x02\0\x01\x12\x04\x9c\x04\x18%\n\r\n\x05\x04T\x02\0\x03\
    \x12\x04\x9c\x04()\n\x0c\n\x02\x04U\x12\x06\x9f\x04\0\xa2\x04\x01\n\x0b\
    \n\x03\x04U\x01\x12\x04\x9f\x04\x088\n\x0c\n\x04\x04U\x02\0\x12\x04\xa0\
    \x04\x08*\n\r\n\x05\x04U\x02\0\x04\x12\x04\xa0\x04\x08\x10\n\r\n\x05\x04\
    U\x02\0\x05\x12\x04\xa0\x04\x11\x17\n\r\n\x05\x04U\x02\0\x01\x12\x04\xa0\
    \x04\x18%\n\r\n\x05\x04U\x02\0\x03\x12\x04\xa0\x04()\n\x0c\n\x04\x04U\
    \x02\x01\x12\x04\xa1\x04\x08.\n\r\n\x05\x04U\x02\x01\x04\x12\x04\xa1\x04\
    \x08\x10\n\r\n\x05\x04U\x02\x01\x05\x12\x04\xa1\x04\x11\x17\n\r\n\x05\
    \x04U\x02\x01\x01\x12\x04\xa1\x04\x18)\n\r\n\x05\x04U\x02\x01\x03\x12\
    \x04\xa1\x04,-\n\x0c\n\x02\x04V\x12\x06\xa4\x04\0\xa7\x04\x01\n\x0b\n\
    \x03\x04V\x01\x12\x04\xa4\x04\x089\n\x0c\n\x04\x04V\x02\0\x12\x04\xa5\
    \x04\x08#\n\r\n\x05\x04V\x02\0\x04\x12\x04\xa5\x04\x08\x10\n\r\n\x05\x04\
    V\x02\0\x05\x12\x04\xa5\x04\x11\x17\n\r\n\x05\x04V\x02\0\x01\x12\x04\xa5\
    \x04\x18\x1e\n\r\n\x05\x04V\x02\0\x03\x12\x04\xa5\x04!\"\n\x0c\n\x04\x04\
    V\x02\x01\x12\x04\xa6\x04\x080\n\r\n\x05\x04V\x02\x01\x04\x12\x04\xa6\
    \x04\x08\x10\n\r\n\x05\x04V\x02\x01\x05\x12\x04\xa6\x04\x11\x17\n\r\n\
    \x05\x04V\x02\x01\x01\x12\x04\xa6\x04\x18+\n\r\n\x05\x04V\x02\x01\x03\
    \x12\x04\xa6\x04./\n\x0c\n\x02\x04W\x12\x06\xa9\x04\0\xac\x04\x01\n\x0b\
    \n\x03\x04W\x01\x12\x04\xa9\x04\x08A\n\x0c\n\x04\x04W\x02\0\x12\x04\xaa\
    \x04\x08*\n\r\n\x05\x04W\x02\0\x04\x12\x04\xaa\x04\x08\x10\n\r\n\x05\x04\
    W\x02\0\x05\x12\x04\xaa\x04\x11\x17\n\r\n\x05\x04W\x02\0\x01\x12\x04\xaa\
    \x04\x18%\n\r\n\x05\x04W\x02\0\x03\x12\x04\xaa\x04()\n\x0c\n\x04\x04W\
    \x02\x01\x12\x04\xab\x04\x08.\n\r\n\x05\x04W\x02\x01\x04\x12\x04\xab\x04\
    \x08\x10\n\r\n\x05\x04W\x02\x01\x05\x12\x04\xab\x04\x11\x17\n\r\n\x05\
    \x04W\x02\x01\x01\x12\x04\xab\x04\x18)\n\r\n\x05\x04W\x02\x01\x03\x12\
    \x04\xab\x04,-\n\x0c\n\x02\x04X\x12\x06\xae\x04\0\xb2\x04\x01\n\x0b\n\
    \x03\x04X\x01\x12\x04\xae\x04\x08-\n\x0c\n\x04\x04X\x02\0\x12\x04\xaf\
    \x04\x08*\n\r\n\x05\x04X\x02\0\x04\x12\x04\xaf\x04\x08\x10\n\r\n\x05\x04\
    X\x02\0\x05\x12\x04\xaf\x04\x11\x17\n\r\n\x05\x04X\x02\0\x01\x12\x04\xaf\
    \x04\x18%\n\r\n\x05\x04X\x02\0\x03\x12\x04\xaf\x04()\n\x0c\n\x04\x04X\
    \x02\x01\x12\x04\xb0\x04\x08$\n\r\n\x05\x04X\x02\x01\x04\x12\x04\xb0\x04\
    \x08\x10\n\r\n\x05\x04X\x02\x01\x05\x12\x04\xb0\x04\x11\x17\n\r\n\x05\
    \x04X\x02\x01\x01\x12\x04\xb0\x04\x18\x1f\n\r\n\x05\x04X\x02\x01\x03\x12\
    \x04\xb0\x04\"#\n\x0c\n\x04\x04X\x02\x02\x12\x04\xb1\x04\x08&\n\r\n\x05\
    \x04X\x02\x02\x04\x12\x04\xb1\x04\x08\x10\n\r\n\x05\x04X\x02\x02\x05\x12\
    \x04\xb1\x04\x11\x17\n\r\n\x05\x04X\x02\x02\x01\x12\x04\xb1\x04\x18!\n\r\
    \n\x05\x04X\x02\x02\x03\x12\x04\xb1\x04$%\n\x0c\n\x02\x04Y\x12\x06\xb4\
    \x04\0\xb8\x04\x01\n\x0b\n\x03\x04Y\x01\x12\x04\xb4\x04\x08*\n\x0c\n\x04\
    \x04Y\x02\0\x12\x04\xb5\x04\x08*\n\r\n\x05\x04Y\x02\0\x04\x12\x04\xb5\
    \x04\x08\x10\n\r\n\x05\x04Y\x02\0\x05\x12\x04\xb5\x04\x11\x17\n\r\n\x05\
    \x04Y\x02\0\x01\x12\x04\xb5\x04\x18%\n\r\n\x05\x04Y\x02\0\x03\x12\x04\
    \xb5\x04()\n\x0c\n\x04\x04Y\x02\x01\x12\x04\xb6\x04\x08*\n\r\n\x05\x04Y\
    \x02\x01\x04\x12\x04\xb6\x04\x08\x10\n\r\n\x05\x04Y\x02\x01\x05\x12\x04\
    \xb6\x04\x11\x17\n\r\n\x05\x04Y\x02\x01\x01\x12\x04\xb6\x04\x18%\n\r\n\
    \x05\x04Y\x02\x01\x03\x12\x04\xb6\x04()\n\x0c\n\x04\x04Y\x02\x02\x12\x04\
    \xb7\x04\x08$\n\r\n\x05\x04Y\x02\x02\x04\x12\x04\xb7\x04\x08\x10\n\r\n\
    \x05\x04Y\x02\x02\x05\x12\x04\xb7\x04\x11\x17\n\r\n\x05\x04Y\x02\x02\x01\
    \x12\x04\xb7\x04\x18\x1f\n\r\n\x05\x04Y\x02\x02\x03\x12\x04\xb7\x04\"#\n\
    \x0c\n\x02\x04Z\x12\x06\xba\x04\0\xbd\x04\x01\n\x0b\n\x03\x04Z\x01\x12\
    \x04\xba\x04\x08+\n\x0c\n\x04\x04Z\x02\0\x12\x04\xbb\x04\x08(\n\r\n\x05\
    \x04Z\x02\0\x04\x12\x04\xbb\x04\x08\x10\n\r\n\x05\x04Z\x02\0\x05\x12\x04\
    \xbb\x04\x11\x17\n\r\n\x05\x04Z\x02\0\x01\x12\x04\xbb\x04\x18#\n\r\n\x05\
    \x04Z\x02\0\x03\x12\x04\xbb\x04&'\n\x0c\n\x04\x04Z\x02\x01\x12\x04\xbc\
    \x04\x08*\n\r\n\x05\x04Z\x02\x01\x04\x12\x04\xbc\x04\x08\x10\n\r\n\x05\
    \x04Z\x02\x01\x05\x12\x04\xbc\x04\x11\x17\n\r\n\x05\x04Z\x02\x01\x01\x12\
    \x04\xbc\x04\x18%\n\r\n\x05\x04Z\x02\x01\x03\x12\x04\xbc\x04()\n\x0c\n\
    \x02\x04[\x12\x06\xbf\x04\0\xc1\x04\x01\n\x0b\n\x03\x04[\x01\x12\x04\xbf\
    \x04\x08+\n\x0c\n\x04\x04[\x02\0\x12\x04\xc0\x04\x08(\n\r\n\x05\x04[\x02\
    \0\x04\x12\x04\xc0\x04\x08\x10\n\r\n\x05\x04[\x02\0\x05\x12\x04\xc0\x04\
    \x11\x17\n\r\n\x05\x04[\x02\0\x01\x12\x04\xc0\x04\x18#\n\r\n\x05\x04[\
    \x02\0\x03\x12\x04\xc0\x04&'\n\x0c\n\x02\x04\\\x12\x06\xc3\x04\0\xcb\x04\
    \x01\n\x0b\n\x03\x04\\\x01\x12\x04\xc3\x04\x08,\n\x0c\n\x04\x04\\\x02\0\
    \x12\x04\xc4\x04\x08,\n\r\n\x05\x04\\\x02\0\x04\x12\x04\xc4\x04\x08\x10\
    \n\r\n\x05\x04\\\x02\0\x05\x12\x04\xc4\x04\x11\x18\n\r\n\x05\x04\\\x02\0\
    \x01\x12\x04\xc4\x04\x19'\n\r\n\x05\x04\\\x02\0\x03\x12\x04\xc4\x04*+\n\
    \x0c\n\x04\x04\\\x02\x01\x12\x04\xc5\x04\x08)\n\r\n\x05\x04\\\x02\x01\
    \x04\x12\x04\xc5\x04\x08\x10\n\r\n\x05\x04\\\x02\x01\x05\x12\x04\xc5\x04\
    \x11\x17\n\r\n\x05\x04\\\x02\x01\x01\x12\x04\xc5\x04\x18$\n\r\n\x05\x04\
    \\\x02\x01\x03\x12\x04\xc5\x04'(\n\x0c\n\x04\x04\\\x02\x02\x12\x04\xc6\
    \x04\x08$\n\r\n\x05\x04\\\x02\x02\x04\x12\x04\xc6\x04\x08\x10\n\r\n\x05\
    \x04\\\x02\x02\x05\x12\x04\xc6\x04\x11\x17\n\r\n\x05\x04\\\x02\x02\x01\
    \x12\x04\xc6\x04\x18\x1f\n\r\n\x05\x04\\\x02\x02\x03\x12\x04\xc6\x04\"#\
    \n\x0c\n\x04\x04\\\x02\x03\x12\x04\xc7\x04\x08O\n\r\n\x05\x04\\\x02\x03\
    \x04\x12\x04\xc7\x04\x08\x10\n\r\n\x05\x04\\\x02\x03\x06\x12\x04\xc7\x04\
    \x11<\n\r\n\x05\x04\\\x02\x03\x01\x12\x04\xc7\x04=J\n\r\n\x05\x04\\\x02\
    \x03\x03\x12\x04\xc7\x04MN\n\x0c\n\x04\x04\\\x02\x04\x12\x04\xc8\x04\x08\
    D\n\r\n\x05\x04\\\x02\x04\x04\x12\x04\xc8\x04\x08\x10\n\r\n\x05\x04\\\
    \x02\x04\x06\x12\x04\xc8\x04\x11)\n\r\n\x05\x04\\\x02\x04\x01\x12\x04\
    \xc8\x04*?\n\r\n\x05\x04\\\x02\x04\x03\x12\x04\xc8\x04BC\n\x0c\n\x04\x04\
    \\\x02\x05\x12\x04\xc9\x04\x08.\n\r\n\x05\x04\\\x02\x05\x04\x12\x04\xc9\
    \x04\x08\x10\n\r\n\x05\x04\\\x02\x05\x05\x12\x04\xc9\x04\x11\x17\n\r\n\
    \x05\x04\\\x02\x05\x01\x12\x04\xc9\x04\x18(\n\r\n\x05\x04\\\x02\x05\x03\
    \x12\x04\xc9\x04+-\n\x0c\n\x04\x04\\\x02\x06\x12\x04\xca\x04\x08\"\n\r\n\
    \x05\x04\\\x02\x06\x04\x12\x04\xca\x04\x08\x10\n\r\n\x05\x04\\\x02\x06\
    \x05\x12\x04\xca\x04\x11\x15\n\r\n\x05\x04\\\x02\x06\x01\x12\x04\xca\x04\
    \x16\x1c\n\r\n\x05\x04\\\x02\x06\x03\x12\x04\xca\x04\x1f!\n\x0c\n\x02\
    \x04]\x12\x06\xcd\x04\0\xd2\x04\x01\n\x0b\n\x03\x04]\x01\x12\x04\xcd\x04\
    \x08'\n\x0c\n\x04\x04]\x02\0\x12\x04\xce\x04\x08-\n\r\n\x05\x04]\x02\0\
    \x04\x12\x04\xce\x04\x08\x10\n\r\n\x05\x04]\x02\0\x05\x12\x04\xce\x04\
    \x11\x18\n\r\n\x05\x04]\x02\0\x01\x12\x04\xce\x04\x19(\n\r\n\x05\x04]\
    \x02\0\x03\x12\x04\xce\x04+,\n\x0c\n\x04\x04]\x02\x01\x12\x04\xcf\x04\
    \x08*\n\r\n\x05\x04]\x02\x01\x04\x12\x04\xcf\x04\x08\x10\n\r\n\x05\x04]\
    \x02\x01\x05\x12\x04\xcf\x04\x11\x17\n\r\n\x05\x04]\x02\x01\x01\x12\x04\
    \xcf\x04\x18%\n\r\n\x05\x04]\x02\x01\x03\x12\x04\xcf\x04()\n\x0c\n\x04\
    \x04]\x02\x02\x12\x04\xd0\x04\x08$\n\r\n\x05\x04]\x02\x02\x04\x12\x04\
    \xd0\x04\x08\x10\n\r\n\x05\x04]\x02\x02\x05\x12\x04\xd0\x04\x11\x17\n\r\
    \n\x05\x04]\x02\x02\x01\x12\x04\xd0\x04\x18\x1f\n\r\n\x05\x04]\x02\x02\
    \x03\x12\x04\xd0\x04\"#\n\x0c\n\x04\x04]\x02\x03\x12\x04\xd1\x04\x08(\n\
    \r\n\x05\x04]\x02\x03\x04\x12\x04\xd1\x04\x08\x10\n\r\n\x05\x04]\x02\x03\
    \x05\x12\x04\xd1\x04\x11\x17\n\r\n\x05\x04]\x02\x03\x01\x12\x04\xd1\x04\
    \x18#\n\r\n\x05\x04]\x02\x03\x03\x12\x04\xd1\x04&'\n\x0c\n\x02\x04^\x12\
    \x06\xd4\x04\0\xd8\x04\x01\n\x0b\n\x03\x04^\x01\x12\x04\xd4\x04\x08(\n\
    \x0c\n\x04\x04^\x02\0\x12\x04\xd5\x04\x08O\n\r\n\x05\x04^\x02\0\x04\x12\
    \x04\xd5\x04\x08\x10\n\r\n\x05\x04^\x02\0\x06\x12\x04\xd5\x04\x11<\n\r\n\
    \x05\x04^\x02\0\x01\x12\x04\xd5\x04=J\n\r\n\x05\x04^\x02\0\x03\x12\x04\
    \xd5\x04MN\n\x0c\n\x04\x04^\x02\x01\x12\x04\xd6\x04\x08-\n\r\n\x05\x04^\
    \x02\x01\x04\x12\x04\xd6\x04\x08\x10\n\r\n\x05\x04^\x02\x01\x05\x12\x04\
    \xd6\x04\x11\x17\n\r\n\x05\x04^\x02\x01\x01\x12\x04\xd6\x04\x18(\n\r\n\
    \x05\x04^\x02\x01\x03\x12\x04\xd6\x04+,\n\x0c\n\x04\x04^\x02\x02\x12\x04\
    \xd7\x04\x08!\n\r\n\x05\x04^\x02\x02\x04\x12\x04\xd7\x04\x08\x10\n\r\n\
    \x05\x04^\x02\x02\x05\x12\x04\xd7\x04\x11\x15\n\r\n\x05\x04^\x02\x02\x01\
    \x12\x04\xd7\x04\x16\x1c\n\r\n\x05\x04^\x02\x02\x03\x12\x04\xd7\x04\x1f\
    \x20\n\x0c\n\x02\x04_\x12\x06\xda\x04\0\xdc\x04\x01\n\x0b\n\x03\x04_\x01\
    \x12\x04\xda\x04\x080\n\x0c\n\x04\x04_\x02\0\x12\x04\xdb\x04\x08*\n\r\n\
    \x05\x04_\x02\0\x04\x12\x04\xdb\x04\x08\x10\n\r\n\x05\x04_\x02\0\x05\x12\
    \x04\xdb\x04\x11\x17\n\r\n\x05\x04_\x02\0\x01\x12\x04\xdb\x04\x18%\n\r\n\
    \x05\x04_\x02\0\x03\x12\x04\xdb\x04()\n\x0c\n\x02\x04`\x12\x06\xde\x04\0\
    \xe7\x04\x01\n\x0b\n\x03\x04`\x01\x12\x04\xde\x04\x081\n\x0e\n\x04\x04`\
    \x03\0\x12\x06\xdf\x04\x08\xe4\x04\t\n\r\n\x05\x04`\x03\0\x01\x12\x04\
    \xdf\x04\x10\x18\n\x0e\n\x06\x04`\x03\0\x02\0\x12\x04\xe0\x04\x100\n\x0f\
    \n\x07\x04`\x03\0\x02\0\x04\x12\x04\xe0\x04\x10\x18\n\x0f\n\x07\x04`\x03\
    \0\x02\0\x05\x12\x04\xe0\x04\x19\x1f\n\x0f\n\x07\x04`\x03\0\x02\0\x01\
    \x12\x04\xe0\x04\x20+\n\x0f\n\x07\x04`\x03\0\x02\0\x03\x12\x04\xe0\x04./\
    \n\x0e\n\x06\x04`\x03\0\x02\x01\x12\x04\xe1\x04\x105\n\x0f\n\x07\x04`\
    \x03\0\x02\x01\x04\x12\x04\xe1\x04\x10\x18\n\x0f\n\x07\x04`\x03\0\x02\
    \x01\x05\x12\x04\xe1\x04\x19\x20\n\x0f\n\x07\x04`\x03\0\x02\x01\x01\x12\
    \x04\xe1\x04!0\n\x0f\n\x07\x04`\x03\0\x02\x01\x03\x12\x04\xe1\x0434\n\
    \x0e\n\x06\x04`\x03\0\x02\x02\x12\x04\xe2\x04\x101\n\x0f\n\x07\x04`\x03\
    \0\x02\x02\x04\x12\x04\xe2\x04\x10\x18\n\x0f\n\x07\x04`\x03\0\x02\x02\
    \x05\x12\x04\xe2\x04\x19\x1f\n\x0f\n\x07\x04`\x03\0\x02\x02\x01\x12\x04\
    \xe2\x04\x20,\n\x0f\n\x07\x04`\x03\0\x02\x02\x03\x12\x04\xe2\x04/0\n\x0e\
    \n\x06\x04`\x03\0\x02\x03\x12\x04\xe3\x04\x10,\n\x0f\n\x07\x04`\x03\0\
    \x02\x03\x04\x12\x04\xe3\x04\x10\x18\n\x0f\n\x07\x04`\x03\0\x02\x03\x05\
    \x12\x04\xe3\x04\x19\x1f\n\x0f\n\x07\x04`\x03\0\x02\x03\x01\x12\x04\xe3\
    \x04\x20'\n\x0f\n\x07\x04`\x03\0\x02\x03\x03\x12\x04\xe3\x04*+\n\x0c\n\
    \x04\x04`\x02\0\x12\x04\xe6\x04\x08V\n\r\n\x05\x04`\x02\0\x04\x12\x04\
    \xe6\x04\x08\x10\n\r\n\x05\x04`\x02\0\x06\x12\x04\xe6\x04\x11D\n\r\n\x05\
    \x04`\x02\0\x01\x12\x04\xe6\x04EQ\n\r\n\x05\x04`\x02\0\x03\x12\x04\xe6\
    \x04TU\n\x0c\n\x02\x04a\x12\x06\xe9\x04\0\xeb\x04\x01\n\x0b\n\x03\x04a\
    \x01\x12\x04\xe9\x04\x08$\n\x0c\n\x04\x04a\x02\0\x12\x04\xea\x04\x08*\n\
    \r\n\x05\x04a\x02\0\x04\x12\x04\xea\x04\x08\x10\n\r\n\x05\x04a\x02\0\x05\
    \x12\x04\xea\x04\x11\x17\n\r\n\x05\x04a\x02\0\x01\x12\x04\xea\x04\x18%\n\
    \r\n\x05\x04a\x02\0\x03\x12\x04\xea\x04()\n\x0c\n\x02\x04b\x12\x06\xed\
    \x04\0\xf6\x04\x01\n\x0b\n\x03\x04b\x01\x12\x04\xed\x04\x08%\n\x0e\n\x04\
    \x04b\x03\0\x12\x06\xee\x04\x08\xf3\x04\t\n\r\n\x05\x04b\x03\0\x01\x12\
    \x04\xee\x04\x10\x17\n\x0e\n\x06\x04b\x03\0\x02\0\x12\x04\xef\x04\x10.\n\
    \x0f\n\x07\x04b\x03\0\x02\0\x04\x12\x04\xef\x04\x10\x18\n\x0f\n\x07\x04b\
    \x03\0\x02\0\x05\x12\x04\xef\x04\x19\x1f\n\x0f\n\x07\x04b\x03\0\x02\0\
    \x01\x12\x04\xef\x04\x20)\n\x0f\n\x07\x04b\x03\0\x02\0\x03\x12\x04\xef\
    \x04,-\n\x0e\n\x06\x04b\x03\0\x02\x01\x12\x04\xf0\x04\x104\n\x0f\n\x07\
    \x04b\x03\0\x02\x01\x04\x12\x04\xf0\x04\x10\x18\n\x0f\n\x07\x04b\x03\0\
    \x02\x01\x05\x12\x04\xf0\x04\x19\x1f\n\x0f\n\x07\x04b\x03\0\x02\x01\x01\
    \x12\x04\xf0\x04\x20/\n\x0f\n\x07\x04b\x03\0\x02\x01\x03\x12\x04\xf0\x04\
    23\n\x0e\n\x06\x04b\x03\0\x02\x02\x12\x04\xf1\x04\x100\n\x0f\n\x07\x04b\
    \x03\0\x02\x02\x04\x12\x04\xf1\x04\x10\x18\n\x0f\n\x07\x04b\x03\0\x02\
    \x02\x05\x12\x04\xf1\x04\x19\x1f\n\x0f\n\x07\x04b\x03\0\x02\x02\x01\x12\
    \x04\xf1\x04\x20+\n\x0f\n\x07\x04b\x03\0\x02\x02\x03\x12\x04\xf1\x04./\n\
    \x0e\n\x06\x04b\x03\0\x02\x03\x12\x04\xf2\x04\x10/\n\x0f\n\x07\x04b\x03\
    \0\x02\x03\x04\x12\x04\xf2\x04\x10\x18\n\x0f\n\x07\x04b\x03\0\x02\x03\
    \x05\x12\x04\xf2\x04\x19\x1f\n\x0f\n\x07\x04b\x03\0\x02\x03\x01\x12\x04\
    \xf2\x04\x20*\n\x0f\n\x07\x04b\x03\0\x02\x03\x03\x12\x04\xf2\x04-.\n\x0c\
    \n\x04\x04b\x02\0\x12\x04\xf5\x04\x08A\n\r\n\x05\x04b\x02\0\x04\x12\x04\
    \xf5\x04\x08\x10\n\r\n\x05\x04b\x02\0\x06\x12\x04\xf5\x04\x117\n\r\n\x05\
    \x04b\x02\0\x01\x12\x04\xf5\x048<\n\r\n\x05\x04b\x02\0\x03\x12\x04\xf5\
    \x04?@\n\x0c\n\x02\x04c\x12\x06\xf8\x04\0\xfa\x04\x01\n\x0b\n\x03\x04c\
    \x01\x12\x04\xf8\x04\x08'\n\x0c\n\x04\x04c\x02\0\x12\x04\xf9\x04\x08*\n\
    \r\n\x05\x04c\x02\0\x04\x12\x04\xf9\x04\x08\x10\n\r\n\x05\x04c\x02\0\x05\
    \x12\x04\xf9\x04\x11\x17\n\r\n\x05\x04c\x02\0\x01\x12\x04\xf9\x04\x18%\n\
    \r\n\x05\x04c\x02\0\x03\x12\x04\xf9\x04()\n\x0c\n\x02\x04d\x12\x06\xfc\
    \x04\0\x80\x05\x01\n\x0b\n\x03\x04d\x01\x12\x04\xfc\x04\x08\x1c\n\x0c\n\
    \x04\x04d\x02\0\x12\x04\xfd\x04\x08&\n\r\n\x05\x04d\x02\0\x04\x12\x04\
    \xfd\x04\x08\x10\n\r\n\x05\x04d\x02\0\x05\x12\x04\xfd\x04\x11\x17\n\r\n\
    \x05\x04d\x02\0\x01\x12\x04\xfd\x04\x18!\n\r\n\x05\x04d\x02\0\x03\x12\
    \x04\xfd\x04$%\n\x0c\n\x04\x04d\x02\x01\x12\x04\xfe\x04\x08,\n\r\n\x05\
    \x04d\x02\x01\x04\x12\x04\xfe\x04\x08\x10\n\r\n\x05\x04d\x02\x01\x05\x12\
    \x04\xfe\x04\x11\x17\n\r\n\x05\x04d\x02\x01\x01\x12\x04\xfe\x04\x18'\n\r\
    \n\x05\x04d\x02\x01\x03\x12\x04\xfe\x04*+\n\x0c\n\x04\x04d\x02\x02\x12\
    \x04\xff\x04\x08)\n\r\n\x05\x04d\x02\x02\x04\x12\x04\xff\x04\x08\x10\n\r\
    \n\x05\x04d\x02\x02\x05\x12\x04\xff\x04\x11\x17\n\r\n\x05\x04d\x02\x02\
    \x01\x12\x04\xff\x04\x18$\n\r\n\x05\x04d\x02\x02\x03\x12\x04\xff\x04'(\n\
    \x0c\n\x02\x04e\x12\x06\x82\x05\0\x84\x05\x01\n\x0b\n\x03\x04e\x01\x12\
    \x04\x82\x05\x08(\n\x0c\n\x04\x04e\x02\0\x12\x04\x83\x05\x083\n\r\n\x05\
    \x04e\x02\0\x04\x12\x04\x83\x05\x08\x10\n\r\n\x05\x04e\x02\0\x06\x12\x04\
    \x83\x05\x11&\n\r\n\x05\x04e\x02\0\x01\x12\x04\x83\x05'.\n\r\n\x05\x04e\
    \x02\0\x03\x12\x04\x83\x0512\n\x0c\n\x02\x04f\x12\x06\x86\x05\0\x89\x05\
    \x01\n\x0b\n\x03\x04f\x01\x12\x04\x86\x05\x08*\n\x0c\n\x04\x04f\x02\0\
    \x12\x04\x87\x05\x08*\n\r\n\x05\x04f\x02\0\x04\x12\x04\x87\x05\x08\x10\n\
    \r\n\x05\x04f\x02\0\x05\x12\x04\x87\x05\x11\x17\n\r\n\x05\x04f\x02\0\x01\
    \x12\x04\x87\x05\x18%\n\r\n\x05\x04f\x02\0\x03\x12\x04\x87\x05()\n\x0c\n\
    \x04\x04f\x02\x01\x12\x04\x88\x05\x08(\n\r\n\x05\x04f\x02\x01\x04\x12\
    \x04\x88\x05\x08\x10\n\r\n\x05\x04f\x02\x01\x05\x12\x04\x88\x05\x11\x17\
    \n\r\n\x05\x04f\x02\x01\x01\x12\x04\x88\x05\x18#\n\r\n\x05\x04f\x02\x01\
    \x03\x12\x04\x88\x05&'\n\x0c\n\x02\x04g\x12\x06\x8b\x05\0\x8c\x05\x01\n\
    \x0b\n\x03\x04g\x01\x12\x04\x8b\x05\x08+\n\x0c\n\x02\x04h\x12\x06\x8e\
    \x05\0\x92\x05\x01\n\x0b\n\x03\x04h\x01\x12\x04\x8e\x05\x088\n\x0c\n\x04\
    \x04h\x02\0\x12\x04\x8f\x05\x08+\n\r\n\x05\x04h\x02\0\x04\x12\x04\x8f\
    \x05\x08\x10\n\r\n\x05\x04h\x02\0\x05\x12\x04\x8f\x05\x11\x17\n\r\n\x05\
    \x04h\x02\0\x01\x12\x04\x8f\x05\x18&\n\r\n\x05\x04h\x02\0\x03\x12\x04\
    \x8f\x05)*\n\x0c\n\x04\x04h\x02\x01\x12\x04\x90\x05\x087\n\r\n\x05\x04h\
    \x02\x01\x04\x12\x04\x90\x05\x08\x10\n\r\n\x05\x04h\x02\x01\x05\x12\x04\
    \x90\x05\x11\x17\n\r\n\x05\x04h\x02\x01\x01\x12\x04\x90\x05\x182\n\r\n\
    \x05\x04h\x02\x01\x03\x12\x04\x90\x0556\n\r\n\x04\x04h\x02\x02\x12\x05\
    \x91\x05\x08\xa6\x01\n\r\n\x05\x04h\x02\x02\x04\x12\x04\x91\x05\x08\x10\
    \n\r\n\x05\x04h\x02\x02\x05\x12\x04\x91\x05\x11\x16\n\r\n\x05\x04h\x02\
    \x02\x01\x12\x04\x91\x05\x173\n\r\n\x05\x04h\x02\x02\x03\x12\x04\x91\x05\
    67\n\x0e\n\x05\x04h\x02\x02\x08\x12\x05\x91\x058\xa5\x01\n\x11\n\x08\x04\
    h\x02\x02\x08\xd0\x86\x03\x12\x05\x91\x059\xa4\x01\n\x0c\n\x02\x04i\x12\
    \x06\x94\x05\0\x97\x05\x01\n\x0b\n\x03\x04i\x01\x12\x04\x94\x05\x089\n\
    \x0c\n\x04\x04i\x02\0\x12\x04\x95\x05\x086\n\r\n\x05\x04i\x02\0\x04\x12\
    \x04\x95\x05\x08\x10\n\r\n\x05\x04i\x02\0\x06\x12\x04\x95\x05\x11%\n\r\n\
    \x05\x04i\x02\0\x01\x12\x04\x95\x05&1\n\r\n\x05\x04i\x02\0\x03\x12\x04\
    \x95\x0545\n\x0c\n\x04\x04i\x02\x01\x12\x04\x96\x05\x08>\n\r\n\x05\x04i\
    \x02\x01\x04\x12\x04\x96\x05\x08\x10\n\r\n\x05\x04i\x02\x01\x05\x12\x04\
    \x96\x05\x11\x17\n\r\n\x05\x04i\x02\x01\x01\x12\x04\x96\x05\x189\n\r\n\
    \x05\x04i\x02\x01\x03\x12\x04\x96\x05<=\n\x0c\n\x02\x04j\x12\x06\x99\x05\
    \0\xaa\x05\x01\n\x0b\n\x03\x04j\x01\x12\x04\x99\x05\x085\n\x0e\n\x04\x04\
    j\x03\0\x12\x06\x9a\x05\x08\x9e\x05\t\n\r\n\x05\x04j\x03\0\x01\x12\x04\
    \x9a\x05\x10$\n\x0f\n\x06\x04j\x03\0\x02\0\x12\x05\x9b\x05\x10\x85\x01\n\
    \x0f\n\x07\x04j\x03\0\x02\0\x04\x12\x04\x9b\x05\x10\x18\n\x0f\n\x07\x04j\
    \x03\0\x02\0\x06\x12\x04\x9b\x05\x194\n\x0f\n\x07\x04j\x03\0\x02\0\x01\
    \x12\x04\x9b\x055O\n\x0f\n\x07\x04j\x03\0\x02\0\x03\x12\x04\x9b\x05RS\n\
    \x10\n\x07\x04j\x03\0\x02\0\x08\x12\x05\x9b\x05T\x84\x01\n\x10\n\x07\x04\
    j\x03\0\x02\0\x07\x12\x05\x9b\x05_\x83\x01\n\x0f\n\x06\x04j\x03\0\x02\
    \x01\x12\x05\x9c\x05\x10\x84\x01\n\x0f\n\x07\x04j\x03\0\x02\x01\x04\x12\
    \x04\x9c\x05\x10\x18\n\x0f\n\x07\x04j\x03\0\x02\x01\x06\x12\x04\x9c\x05\
    \x194\n\x0f\n\x07\x04j\x03\0\x02\x01\x01\x12\x04\x9c\x055N\n\x0f\n\x07\
    \x04j\x03\0\x02\x01\x03\x12\x04\x9c\x05QR\n\x10\n\x07\x04j\x03\0\x02\x01\
    \x08\x12\x05\x9c\x05S\x83\x01\n\x10\n\x07\x04j\x03\0\x02\x01\x07\x12\x05\
    \x9c\x05^\x82\x01\n\x0e\n\x06\x04j\x03\0\x02\x02\x12\x04\x9d\x05\x109\n\
    \x0f\n\x07\x04j\x03\0\x02\x02\x04\x12\x04\x9d\x05\x10\x18\n\x0f\n\x07\
    \x04j\x03\0\x02\x02\x05\x12\x04\x9d\x05\x19\x1d\n\x0f\n\x07\x04j\x03\0\
    \x02\x02\x01\x12\x04\x9d\x05\x1e4\n\x0f\n\x07\x04j\x03\0\x02\x02\x03\x12\
    \x04\x9d\x0578\n\x0e\n\x04\x04j\x03\x01\x12\x06\xa0\x05\x08\xa5\x05\t\n\
    \r\n\x05\x04j\x03\x01\x01\x12\x04\xa0\x05\x10#\n\x0e\n\x06\x04j\x03\x01\
    \x02\0\x12\x04\xa1\x05\x10,\n\x0f\n\x07\x04j\x03\x01\x02\0\x04\x12\x04\
    \xa1\x05\x10\x18\n\x0f\n\x07\x04j\x03\x01\x02\0\x05\x12\x04\xa1\x05\x19\
    \x1f\n\x0f\n\x07\x04j\x03\x01\x02\0\x01\x12\x04\xa1\x05\x20'\n\x0f\n\x07\
    \x04j\x03\x01\x02\0\x03\x12\x04\xa1\x05*+\n\x0f\n\x06\x04j\x03\x01\x02\
    \x01\x12\x05\xa2\x05\x10\x85\x01\n\x0f\n\x07\x04j\x03\x01\x02\x01\x04\
    \x12\x04\xa2\x05\x10\x18\n\x0f\n\x07\x04j\x03\x01\x02\x01\x06\x12\x04\
    \xa2\x05\x194\n\x0f\n\x07\x04j\x03\x01\x02\x01\x01\x12\x04\xa2\x055O\n\
    \x0f\n\x07\x04j\x03\x01\x02\x01\x03\x12\x04\xa2\x05RS\n\x10\n\x07\x04j\
    \x03\x01\x02\x01\x08\x12\x05\xa2\x05T\x84\x01\n\x10\n\x07\x04j\x03\x01\
    \x02\x01\x07\x12\x05\xa2\x05_\x83\x01\n\x0f\n\x06\x04j\x03\x01\x02\x02\
    \x12\x05\xa3\x05\x10\x84\x01\n\x0f\n\x07\x04j\x03\x01\x02\x02\x04\x12\
    \x04\xa3\x05\x10\x18\n\x0f\n\x07\x04j\x03\x01\x02\x02\x06\x12\x04\xa3\
    \x05\x194\n\x0f\n\x07\x04j\x03\x01\x02\x02\x01\x12\x04\xa3\x055N\n\x0f\n\
    \x07\x04j\x03\x01\x02\x02\x03\x12\x04\xa3\x05QR\n\x10\n\x07\x04j\x03\x01\
    \x02\x02\x08\x12\x05\xa3\x05S\x83\x01\n\x10\n\x07\x04j\x03\x01\x02\x02\
    \x07\x12\x05\xa3\x05^\x82\x01\n\x0e\n\x06\x04j\x03\x01\x02\x03\x12\x04\
    \xa4\x05\x109\n\x0f\n\x07\x04j\x03\x01\x02\x03\x04\x12\x04\xa4\x05\x10\
    \x18\n\x0f\n\x07\x04j\x03\x01\x02\x03\x05\x12\x04\xa4\x05\x19\x1d\n\x0f\
    \n\x07\x04j\x03\x01\x02\x03\x01\x12\x04\xa4\x05\x1e4\n\x0f\n\x07\x04j\
    \x03\x01\x02\x03\x03\x12\x04\xa4\x0578\n\x0c\n\x04\x04j\x02\0\x12\x04\
    \xa7\x05\x08*\n\r\n\x05\x04j\x02\0\x04\x12\x04\xa7\x05\x08\x10\n\r\n\x05\
    \x04j\x02\0\x05\x12\x04\xa7\x05\x11\x17\n\r\n\x05\x04j\x02\0\x01\x12\x04\
    \xa7\x05\x18%\n\r\n\x05\x04j\x02\0\x03\x12\x04\xa7\x05()\n\x0c\n\x04\x04\
    j\x02\x01\x12\x04\xa8\x05\x08p\n\r\n\x05\x04j\x02\x01\x04\x12\x04\xa8\
    \x05\x08\x10\n\r\n\x05\x04j\x02\x01\x06\x12\x04\xa8\x05\x11T\n\r\n\x05\
    \x04j\x02\x01\x01\x12\x04\xa8\x05Uk\n\r\n\x05\x04j\x02\x01\x03\x12\x04\
    \xa8\x05no\n\x0c\n\x04\x04j\x02\x02\x12\x04\xa9\x05\x08n\n\r\n\x05\x04j\
    \x02\x02\x04\x12\x04\xa9\x05\x08\x10\n\r\n\x05\x04j\x02\x02\x06\x12\x04\
    \xa9\x05\x11S\n\r\n\x05\x04j\x02\x02\x01\x12\x04\xa9\x05Ti\n\r\n\x05\x04\
    j\x02\x02\x03\x12\x04\xa9\x05lm\n\x0c\n\x02\x04k\x12\x06\xac\x05\0\xad\
    \x05\x01\n\x0b\n\x03\x04k\x01\x12\x04\xac\x05\x086\n\x0c\n\x02\x04l\x12\
    \x06\xaf\x05\0\xb8\x05\x01\n\x0b\n\x03\x04l\x01\x12\x04\xaf\x05\x08,\n\
    \x0e\n\x04\x04l\x03\0\x12\x06\xb0\x05\x08\xb3\x05\t\n\r\n\x05\x04l\x03\0\
    \x01\x12\x04\xb0\x05\x10\x17\n\x0e\n\x06\x04l\x03\0\x02\0\x12\x04\xb1\
    \x05\x105\n\x0f\n\x07\x04l\x03\0\x02\0\x04\x12\x04\xb1\x05\x10\x18\n\x0f\
    \n\x07\x04l\x03\0\x02\0\x05\x12\x04\xb1\x05\x19\x1f\n\x0f\n\x07\x04l\x03\
    \0\x02\0\x01\x12\x04\xb1\x05\x200\n\x0f\n\x07\x04l\x03\0\x02\0\x03\x12\
    \x04\xb1\x0534\n\x0e\n\x06\x04l\x03\0\x02\x01\x12\x04\xb2\x05\x10,\n\x0f\
    \n\x07\x04l\x03\0\x02\x01\x04\x12\x04\xb2\x05\x10\x18\n\x0f\n\x07\x04l\
    \x03\0\x02\x01\x05\x12\x04\xb2\x05\x19\x1f\n\x0f\n\x07\x04l\x03\0\x02\
    \x01\x01\x12\x04\xb2\x05\x20'\n\x0f\n\x07\x04l\x03\0\x02\x01\x03\x12\x04\
    \xb2\x05*+\n\x0c\n\x04\x04l\x02\0\x12\x04\xb5\x05\x08*\n\r\n\x05\x04l\
    \x02\0\x04\x12\x04\xb5\x05\x08\x10\n\r\n\x05\x04l\x02\0\x05\x12\x04\xb5\
    \x05\x11\x17\n\r\n\x05\x04l\x02\0\x01\x12\x04\xb5\x05\x18%\n\r\n\x05\x04\
    l\x02\0\x03\x12\x04\xb5\x05()\n\x0c\n\x04\x04l\x02\x01\x12\x04\xb6\x05\
    \x08$\n\r\n\x05\x04l\x02\x01\x04\x12\x04\xb6\x05\x08\x10\n\r\n\x05\x04l\
    \x02\x01\x05\x12\x04\xb6\x05\x11\x17\n\r\n\x05\x04l\x02\x01\x01\x12\x04\
    \xb6\x05\x18\x1f\n\r\n\x05\x04l\x02\x01\x03\x12\x04\xb6\x05\"#\n\x0c\n\
    \x04\x04l\x02\x02\x12\x04\xb7\x05\x08L\n\r\n\x05\x04l\x02\x02\x04\x12\
    \x04\xb7\x05\x08\x10\n\r\n\x05\x04l\x02\x02\x06\x12\x04\xb7\x05\x11>\n\r\
    \n\x05\x04l\x02\x02\x01\x12\x04\xb7\x05?G\n\r\n\x05\x04l\x02\x02\x03\x12\
    \x04\xb7\x05JK\n\x0c\n\x02\x04m\x12\x06\xba\x05\0\xbb\x05\x01\n\x0b\n\
    \x03\x04m\x01\x12\x04\xba\x05\x08-\n\x0c\n\x02\x04n\x12\x06\xbd\x05\0\
    \xc6\x05\x01\n\x0b\n\x03\x04n\x01\x12\x04\xbd\x05\x083\n\x0c\n\x04\x04n\
    \x02\0\x12\x04\xbe\x05\x08*\n\r\n\x05\x04n\x02\0\x04\x12\x04\xbe\x05\x08\
    \x10\n\r\n\x05\x04n\x02\0\x05\x12\x04\xbe\x05\x11\x17\n\r\n\x05\x04n\x02\
    \0\x01\x12\x04\xbe\x05\x18%\n\r\n\x05\x04n\x02\0\x03\x12\x04\xbe\x05()\n\
    \r\n\x04\x04n\x02\x01\x12\x05\xbf\x05\x08\x8b\x01\n\r\n\x05\x04n\x02\x01\
    \x04\x12\x04\xbf\x05\x08\x10\n\r\n\x05\x04n\x02\x01\x05\x12\x04\xbf\x05\
    \x11\x17\n\r\n\x05\x04n\x02\x01\x01\x12\x04\xbf\x05\x18\x1f\n\r\n\x05\
    \x04n\x02\x01\x03\x12\x04\xbf\x05\"#\n\x0e\n\x05\x04n\x02\x01\x08\x12\
    \x05\xbf\x05$\x8a\x01\n\x11\n\x08\x04n\x02\x01\x08\xd0\x86\x03\x12\x05\
    \xbf\x05%\x89\x01\n\x0c\n\x04\x04n\x02\x02\x12\x04\xc0\x05\x08!\n\r\n\
    \x05\x04n\x02\x02\x04\x12\x04\xc0\x05\x08\x10\n\r\n\x05\x04n\x02\x02\x05\
    \x12\x04\xc0\x05\x11\x16\n\r\n\x05\x04n\x02\x02\x01\x12\x04\xc0\x05\x17\
    \x1c\n\r\n\x05\x04n\x02\x02\x03\x12\x04\xc0\x05\x1f\x20\n\x0c\n\x04\x04n\
    \x02\x03\x12\x04\xc1\x05\x08\x1f\n\r\n\x05\x04n\x02\x03\x04\x12\x04\xc1\
    \x05\x08\x10\n\r\n\x05\x04n\x02\x03\x05\x12\x04\xc1\x05\x11\x16\n\r\n\
    \x05\x04n\x02\x03\x01\x12\x04\xc1\x05\x17\x1a\n\r\n\x05\x04n\x02\x03\x03\
    \x12\x04\xc1\x05\x1d\x1e\n\r\n\x04\x04n\x02\x04\x12\x05\xc2\x05\x08\xb2\
    \x01\n\r\n\x05\x04n\x02\x04\x04\x12\x04\xc2\x05\x08\x10\n\r\n\x05\x04n\
    \x02\x04\x05\x12\x04\xc2\x05\x11\x16\n\r\n\x05\x04n\x02\x04\x01\x12\x04\
    \xc2\x05\x17*\n\r\n\x05\x04n\x02\x04\x03\x12\x04\xc2\x05-.\n\x0e\n\x05\
    \x04n\x02\x04\x08\x12\x05\xc2\x05/\xb1\x01\n\x11\n\x08\x04n\x02\x04\x08\
    \xd0\x86\x03\x12\x05\xc2\x050\xb0\x01\n\x0c\n\x04\x04n\x02\x05\x12\x04\
    \xc3\x05\x08`\n\r\n\x05\x04n\x02\x05\x04\x12\x04\xc3\x05\x08\x10\n\r\n\
    \x05\x04n\x02\x05\x05\x12\x04\xc3\x05\x11\x15\n\r\n\x05\x04n\x02\x05\x01\
    \x12\x04\xc3\x05\x16!\n\r\n\x05\x04n\x02\x05\x03\x12\x04\xc3\x05$%\n\r\n\
    \x05\x04n\x02\x05\x08\x12\x04\xc3\x05&_\n\x10\n\x08\x04n\x02\x05\x08\xd0\
    \x86\x03\x12\x04\xc3\x05'^\n\x0c\n\x04\x04n\x02\x06\x12\x04\xc4\x05\x088\
    \n\r\n\x05\x04n\x02\x06\x04\x12\x04\xc4\x05\x08\x10\n\r\n\x05\x04n\x02\
    \x06\x05\x12\x04\xc4\x05\x11\x16\n\r\n\x05\x04n\x02\x06\x01\x12\x04\xc4\
    \x05\x173\n\r\n\x05\x04n\x02\x06\x03\x12\x04\xc4\x0567\n\x0c\n\x04\x04n\
    \x02\x07\x12\x04\xc5\x05\x08:\n\r\n\x05\x04n\x02\x07\x04\x12\x04\xc5\x05\
    \x08\x10\n\r\n\x05\x04n\x02\x07\x05\x12\x04\xc5\x05\x11\x16\n\r\n\x05\
    \x04n\x02\x07\x01\x12\x04\xc5\x05\x175\n\r\n\x05\x04n\x02\x07\x03\x12\
    \x04\xc5\x0589\n\x0c\n\x02\x04o\x12\x06\xc8\x05\0\xcd\x05\x01\n\x0b\n\
    \x03\x04o\x01\x12\x04\xc8\x05\x08'\n\x0c\n\x04\x04o\x02\0\x12\x04\xc9\
    \x05\x08*\n\r\n\x05\x04o\x02\0\x04\x12\x04\xc9\x05\x08\x10\n\r\n\x05\x04\
    o\x02\0\x05\x12\x04\xc9\x05\x11\x17\n\r\n\x05\x04o\x02\0\x01\x12\x04\xc9\
    \x05\x18%\n\r\n\x05\x04o\x02\0\x03\x12\x04\xc9\x05()\n\r\n\x04\x04o\x02\
    \x01\x12\x05\xca\x05\x08\xd4\x01\n\r\n\x05\x04o\x02\x01\x04\x12\x04\xca\
    \x05\x08\x10\n\r\n\x05\x04o\x02\x01\x05\x12\x04\xca\x05\x11\x17\n\r\n\
    \x05\x04o\x02\x01\x01\x12\x04\xca\x05\x18!\n\r\n\x05\x04o\x02\x01\x03\
    \x12\x04\xca\x05$%\n\x0e\n\x05\x04o\x02\x01\x08\x12\x05\xca\x05&\xd3\x01\
    \n\x11\n\x08\x04o\x02\x01\x08\xd0\x86\x03\x12\x05\xca\x05'\xd2\x01\n\x0c\
    \n\x04\x04o\x02\x02\x12\x04\xcb\x05\x08(\n\r\n\x05\x04o\x02\x02\x04\x12\
    \x04\xcb\x05\x08\x10\n\r\n\x05\x04o\x02\x02\x05\x12\x04\xcb\x05\x11\x17\
    \n\r\n\x05\x04o\x02\x02\x01\x12\x04\xcb\x05\x18#\n\r\n\x05\x04o\x02\x02\
    \x03\x12\x04\xcb\x05&'\n\x0c\n\x04\x04o\x02\x03\x12\x04\xcc\x05\x08'\n\r\
    \n\x05\x04o\x02\x03\x04\x12\x04\xcc\x05\x08\x10\n\r\n\x05\x04o\x02\x03\
    \x05\x12\x04\xcc\x05\x11\x16\n\r\n\x05\x04o\x02\x03\x01\x12\x04\xcc\x05\
    \x17\"\n\r\n\x05\x04o\x02\x03\x03\x12\x04\xcc\x05%&\n\x0c\n\x02\x04p\x12\
    \x06\xcf\x05\0\xd7\x05\x01\n\x0b\n\x03\x04p\x01\x12\x04\xcf\x05\x08(\n\
    \x0e\n\x04\x04p\x03\0\x12\x06\xd0\x05\x08\xd3\x05\t\n\r\n\x05\x04p\x03\0\
    \x01\x12\x04\xd0\x05\x10\x1b\n\x0e\n\x06\x04p\x03\0\x02\0\x12\x04\xd1\
    \x05\x10-\n\x0f\n\x07\x04p\x03\0\x02\0\x04\x12\x04\xd1\x05\x10\x18\n\x0f\
    \n\x07\x04p\x03\0\x02\0\x05\x12\x04\xd1\x05\x19\x1e\n\x0f\n\x07\x04p\x03\
    \0\x02\0\x01\x12\x04\xd1\x05\x1f(\n\x0f\n\x07\x04p\x03\0\x02\0\x03\x12\
    \x04\xd1\x05+,\n\x0e\n\x06\x04p\x03\0\x02\x01\x12\x04\xd2\x05\x10D\n\x0f\
    \n\x07\x04p\x03\0\x02\x01\x04\x12\x04\xd2\x05\x10\x18\n\x0f\n\x07\x04p\
    \x03\0\x02\x01\x06\x12\x04\xd2\x05\x197\n\x0f\n\x07\x04p\x03\0\x02\x01\
    \x01\x12\x04\xd2\x058?\n\x0f\n\x07\x04p\x03\0\x02\x01\x03\x12\x04\xd2\
    \x05BC\n\x0c\n\x04\x04p\x02\0\x12\x04\xd5\x05\x08T\n\r\n\x05\x04p\x02\0\
    \x04\x12\x04\xd5\x05\x08\x10\n\r\n\x05\x04p\x02\0\x06\x12\x04\xd5\x05\
    \x11>\n\r\n\x05\x04p\x02\0\x01\x12\x04\xd5\x05?O\n\r\n\x05\x04p\x02\0\
    \x03\x12\x04\xd5\x05RS\n\x0c\n\x04\x04p\x02\x01\x12\x04\xd6\x05\x08)\n\r\
    \n\x05\x04p\x02\x01\x04\x12\x04\xd6\x05\x08\x10\n\r\n\x05\x04p\x02\x01\
    \x05\x12\x04\xd6\x05\x11\x17\n\r\n\x05\x04p\x02\x01\x01\x12\x04\xd6\x05\
    \x18$\n\r\n\x05\x04p\x02\x01\x03\x12\x04\xd6\x05'(\n\x0c\n\x02\x04q\x12\
    \x06\xd9\x05\0\xe1\x05\x01\n\x0b\n\x03\x04q\x01\x12\x04\xd9\x05\x08/\n\
    \x0c\n\x04\x04q\x02\0\x12\x04\xda\x05\x08*\n\r\n\x05\x04q\x02\0\x04\x12\
    \x04\xda\x05\x08\x10\n\r\n\x05\x04q\x02\0\x05\x12\x04\xda\x05\x11\x17\n\
    \r\n\x05\x04q\x02\0\x01\x12\x04\xda\x05\x18%\n\r\n\x05\x04q\x02\0\x03\
    \x12\x04\xda\x05()\n\x0c\n\x04\x04q\x02\x01\x12\x04\xdb\x05\x08$\n\r\n\
    \x05\x04q\x02\x01\x04\x12\x04\xdb\x05\x08\x10\n\r\n\x05\x04q\x02\x01\x05\
    \x12\x04\xdb\x05\x11\x17\n\r\n\x05\x04q\x02\x01\x01\x12\x04\xdb\x05\x18\
    \x1f\n\r\n\x05\x04q\x02\x01\x03\x12\x04\xdb\x05\"#\n\x0c\n\x04\x04q\x02\
    \x02\x12\x04\xdc\x05\x08-\n\r\n\x05\x04q\x02\x02\x04\x12\x04\xdc\x05\x08\
    \x10\n\r\n\x05\x04q\x02\x02\x05\x12\x04\xdc\x05\x11\x17\n\r\n\x05\x04q\
    \x02\x02\x01\x12\x04\xdc\x05\x18(\n\r\n\x05\x04q\x02\x02\x03\x12\x04\xdc\
    \x05+,\n\x0c\n\x04\x04q\x02\x03\x12\x04\xdd\x05\x08$\n\r\n\x05\x04q\x02\
    \x03\x04\x12\x04\xdd\x05\x08\x10\n\r\n\x05\x04q\x02\x03\x05\x12\x04\xdd\
    \x05\x11\x17\n\r\n\x05\x04q\x02\x03\x01\x12\x04\xdd\x05\x18\x1f\n\r\n\
    \x05\x04q\x02\x03\x03\x12\x04\xdd\x05\"#\n\x0c\n\x04\x04q\x02\x04\x12\
    \x04\xde\x05\x08t\n\r\n\x05\x04q\x02\x04\x04\x12\x04\xde\x05\x08\x10\n\r\
    \n\x05\x04q\x02\x04\x06\x12\x04\xde\x05\x11.\n\r\n\x05\x04q\x02\x04\x01\
    \x12\x04\xde\x05/<\n\r\n\x05\x04q\x02\x04\x03\x12\x04\xde\x05?@\n\r\n\
    \x05\x04q\x02\x04\x08\x12\x04\xde\x05As\n\r\n\x05\x04q\x02\x04\x07\x12\
    \x04\xde\x05Lr\n\x0c\n\x04\x04q\x02\x05\x12\x04\xdf\x05\x08%\n\r\n\x05\
    \x04q\x02\x05\x04\x12\x04\xdf\x05\x08\x10\n\r\n\x05\x04q\x02\x05\x05\x12\
    \x04\xdf\x05\x11\x17\n\r\n\x05\x04q\x02\x05\x01\x12\x04\xdf\x05\x18\x20\
    \n\r\n\x05\x04q\x02\x05\x03\x12\x04\xdf\x05#$\n\x0c\n\x04\x04q\x02\x06\
    \x12\x04\xe0\x05\x08!\n\r\n\x05\x04q\x02\x06\x04\x12\x04\xe0\x05\x08\x10\
    \n\r\n\x05\x04q\x02\x06\x05\x12\x04\xe0\x05\x11\x15\n\r\n\x05\x04q\x02\
    \x06\x01\x12\x04\xe0\x05\x16\x1c\n\r\n\x05\x04q\x02\x06\x03\x12\x04\xe0\
    \x05\x1f\x20\n\x0c\n\x02\x04r\x12\x06\xe3\x05\0\xe5\x05\x01\n\x0b\n\x03\
    \x04r\x01\x12\x04\xe3\x05\x080\n\x0c\n\x04\x04r\x02\0\x12\x04\xe4\x05\
    \x08)\n\r\n\x05\x04r\x02\0\x04\x12\x04\xe4\x05\x08\x10\n\r\n\x05\x04r\
    \x02\0\x05\x12\x04\xe4\x05\x11\x17\n\r\n\x05\x04r\x02\0\x01\x12\x04\xe4\
    \x05\x18$\n\r\n\x05\x04r\x02\0\x03\x12\x04\xe4\x05'(\n\x0c\n\x02\x04s\
    \x12\x06\xe7\x05\0\xef\x05\x01\n\x0b\n\x03\x04s\x01\x12\x04\xe7\x05\x084\
    \n\x0c\n\x04\x04s\x02\0\x12\x04\xe8\x05\x08*\n\r\n\x05\x04s\x02\0\x04\
    \x12\x04\xe8\x05\x08\x10\n\r\n\x05\x04s\x02\0\x05\x12\x04\xe8\x05\x11\
    \x17\n\r\n\x05\x04s\x02\0\x01\x12\x04\xe8\x05\x18%\n\r\n\x05\x04s\x02\0\
    \x03\x12\x04\xe8\x05()\n\x0c\n\x04\x04s\x02\x01\x12\x04\xe9\x05\x08$\n\r\
    \n\x05\x04s\x02\x01\x04\x12\x04\xe9\x05\x08\x10\n\r\n\x05\x04s\x02\x01\
    \x05\x12\x04\xe9\x05\x11\x17\n\r\n\x05\x04s\x02\x01\x01\x12\x04\xe9\x05\
    \x18\x1f\n\r\n\x05\x04s\x02\x01\x03\x12\x04\xe9\x05\"#\n\x0c\n\x04\x04s\
    \x02\x02\x12\x04\xea\x05\x08-\n\r\n\x05\x04s\x02\x02\x04\x12\x04\xea\x05\
    \x08\x10\n\r\n\x05\x04s\x02\x02\x05\x12\x04\xea\x05\x11\x17\n\r\n\x05\
    \x04s\x02\x02\x01\x12\x04\xea\x05\x18(\n\r\n\x05\x04s\x02\x02\x03\x12\
    \x04\xea\x05+,\n\x0c\n\x04\x04s\x02\x03\x12\x04\xeb\x05\x08$\n\r\n\x05\
    \x04s\x02\x03\x04\x12\x04\xeb\x05\x08\x10\n\r\n\x05\x04s\x02\x03\x05\x12\
    \x04\xeb\x05\x11\x17\n\r\n\x05\x04s\x02\x03\x01\x12\x04\xeb\x05\x18\x1f\
    \n\r\n\x05\x04s\x02\x03\x03\x12\x04\xeb\x05\"#\n\x0c\n\x04\x04s\x02\x04\
    \x12\x04\xec\x05\x08t\n\r\n\x05\x04s\x02\x04\x04\x12\x04\xec\x05\x08\x10\
    \n\r\n\x05\x04s\x02\x04\x06\x12\x04\xec\x05\x11.\n\r\n\x05\x04s\x02\x04\
    \x01\x12\x04\xec\x05/<\n\r\n\x05\x04s\x02\x04\x03\x12\x04\xec\x05?@\n\r\
    \n\x05\x04s\x02\x04\x08\x12\x04\xec\x05As\n\r\n\x05\x04s\x02\x04\x07\x12\
    \x04\xec\x05Lr\n\x0c\n\x04\x04s\x02\x05\x12\x04\xed\x05\x08%\n\r\n\x05\
    \x04s\x02\x05\x04\x12\x04\xed\x05\x08\x10\n\r\n\x05\x04s\x02\x05\x05\x12\
    \x04\xed\x05\x11\x17\n\r\n\x05\x04s\x02\x05\x01\x12\x04\xed\x05\x18\x20\
    \n\r\n\x05\x04s\x02\x05\x03\x12\x04\xed\x05#$\n\x0c\n\x04\x04s\x02\x06\
    \x12\x04\xee\x05\x08\"\n\r\n\x05\x04s\x02\x06\x04\x12\x04\xee\x05\x08\
    \x10\n\r\n\x05\x04s\x02\x06\x05\x12\x04\xee\x05\x11\x17\n\r\n\x05\x04s\
    \x02\x06\x01\x12\x04\xee\x05\x18\x1d\n\r\n\x05\x04s\x02\x06\x03\x12\x04\
    \xee\x05\x20!\n\x0c\n\x02\x04t\x12\x06\xf1\x05\0\xf3\x05\x01\n\x0b\n\x03\
    \x04t\x01\x12\x04\xf1\x05\x085\n\x0c\n\x04\x04t\x02\0\x12\x04\xf2\x05\
    \x08%\n\r\n\x05\x04t\x02\0\x04\x12\x04\xf2\x05\x08\x10\n\r\n\x05\x04t\
    \x02\0\x05\x12\x04\xf2\x05\x11\x17\n\r\n\x05\x04t\x02\0\x01\x12\x04\xf2\
    \x05\x18\x20\n\r\n\x05\x04t\x02\0\x03\x12\x04\xf2\x05#$\n\x0c\n\x02\x04u\
    \x12\x06\xf5\x05\0\xf8\x05\x01\n\x0b\n\x03\x04u\x01\x12\x04\xf5\x05\x082\
    \n\x0c\n\x04\x04u\x02\0\x12\x04\xf6\x05\x08%\n\r\n\x05\x04u\x02\0\x04\
    \x12\x04\xf6\x05\x08\x10\n\r\n\x05\x04u\x02\0\x05\x12\x04\xf6\x05\x11\
    \x18\n\r\n\x05\x04u\x02\0\x01\x12\x04\xf6\x05\x19\x20\n\r\n\x05\x04u\x02\
    \0\x03\x12\x04\xf6\x05#$\n\r\n\x04\x04u\x02\x01\x12\x05\xf7\x05\x08\x85\
    \x01\n\r\n\x05\x04u\x02\x01\x04\x12\x04\xf7\x05\x08\x10\n\r\n\x05\x04u\
    \x02\x01\x05\x12\x04\xf7\x05\x11\x15\n\r\n\x05\x04u\x02\x01\x01\x12\x04\
    \xf7\x05\x16\x20\n\r\n\x05\x04u\x02\x01\x03\x12\x04\xf7\x05#$\n\x0e\n\
    \x05\x04u\x02\x01\x08\x12\x05\xf7\x05%\x84\x01\n\r\n\x05\x04u\x02\x01\
    \x07\x12\x04\xf7\x0504\n\x11\n\x08\x04u\x02\x01\x08\xd0\x86\x03\x12\x05\
    \xf7\x056\x83\x01\n\x0c\n\x02\x04v\x12\x06\xfa\x05\0\xfc\x05\x01\n\x0b\n\
    \x03\x04v\x01\x12\x04\xfa\x05\x083\n\x0c\n\x04\x04v\x02\0\x12\x04\xfb\
    \x05\x08T\n\r\n\x05\x04v\x02\0\x04\x12\x04\xfb\x05\x08\x10\n\r\n\x05\x04\
    v\x02\0\x06\x12\x04\xfb\x05\x11<\n\r\n\x05\x04v\x02\0\x01\x12\x04\xfb\
    \x05=O\n\r\n\x05\x04v\x02\0\x03\x12\x04\xfb\x05RS\n\x0c\n\x02\x04w\x12\
    \x06\xfe\x05\0\x81\x06\x01\n\x0b\n\x03\x04w\x01\x12\x04\xfe\x05\x085\n\
    \x0c\n\x04\x04w\x02\0\x12\x04\xff\x05\x08%\n\r\n\x05\x04w\x02\0\x04\x12\
    \x04\xff\x05\x08\x10\n\r\n\x05\x04w\x02\0\x05\x12\x04\xff\x05\x11\x18\n\
    \r\n\x05\x04w\x02\0\x01\x12\x04\xff\x05\x19\x20\n\r\n\x05\x04w\x02\0\x03\
    \x12\x04\xff\x05#$\n\x0c\n\x04\x04w\x02\x01\x12\x04\x80\x06\x08,\n\r\n\
    \x05\x04w\x02\x01\x04\x12\x04\x80\x06\x08\x10\n\r\n\x05\x04w\x02\x01\x05\
    \x12\x04\x80\x06\x11\x15\n\r\n\x05\x04w\x02\x01\x01\x12\x04\x80\x06\x16'\
    \n\r\n\x05\x04w\x02\x01\x03\x12\x04\x80\x06*+\n\x0c\n\x02\x04x\x12\x06\
    \x83\x06\0\x85\x06\x01\n\x0b\n\x03\x04x\x01\x12\x04\x83\x06\x086\n\x0c\n\
    \x04\x04x\x02\0\x12\x04\x84\x06\x08,\n\r\n\x05\x04x\x02\0\x04\x12\x04\
    \x84\x06\x08\x10\n\r\n\x05\x04x\x02\0\x05\x12\x04\x84\x06\x11\x15\n\r\n\
    \x05\x04x\x02\0\x01\x12\x04\x84\x06\x16'\n\r\n\x05\x04x\x02\0\x03\x12\
    \x04\x84\x06*+\n\x0c\n\x02\x04y\x12\x06\x87\x06\0\x8b\x06\x01\n\x0b\n\
    \x03\x04y\x01\x12\x04\x87\x06\x08\x15\n\x0c\n\x04\x04y\x02\0\x12\x04\x88\
    \x06\x08&\n\r\n\x05\x04y\x02\0\x04\x12\x04\x88\x06\x08\x10\n\r\n\x05\x04\
    y\x02\0\x05\x12\x04\x88\x06\x11\x15\n\r\n\x05\x04y\x02\0\x01\x12\x04\x88\
    \x06\x16!\n\r\n\x05\x04y\x02\0\x03\x12\x04\x88\x06$%\n\x0c\n\x04\x04y\
    \x02\x01\x12\x04\x89\x06\x08'\n\r\n\x05\x04y\x02\x01\x04\x12\x04\x89\x06\
    \x08\x10\n\r\n\x05\x04y\x02\x01\x05\x12\x04\x89\x06\x11\x15\n\r\n\x05\
    \x04y\x02\x01\x01\x12\x04\x89\x06\x16\"\n\r\n\x05\x04y\x02\x01\x03\x12\
    \x04\x89\x06%&\n\x0c\n\x04\x04y\x02\x02\x12\x04\x8a\x06\x08/\n\r\n\x05\
    \x04y\x02\x02\x04\x12\x04\x8a\x06\x08\x10\n\r\n\x05\x04y\x02\x02\x05\x12\
    \x04\x8a\x06\x11\x17\n\r\n\x05\x04y\x02\x02\x01\x12\x04\x8a\x06\x18*\n\r\
    \n\x05\x04y\x02\x02\x03\x12\x04\x8a\x06-.\n\x0c\n\x02\x04z\x12\x06\x8d\
    \x06\0\x98\x06\x01\n\x0b\n\x03\x04z\x01\x12\x04\x8d\x06\x082\n\x0c\n\x04\
    \x04z\x02\0\x12\x04\x8e\x06\x08*\n\r\n\x05\x04z\x02\0\x04\x12\x04\x8e\
    \x06\x08\x10\n\r\n\x05\x04z\x02\0\x05\x12\x04\x8e\x06\x11\x17\n\r\n\x05\
    \x04z\x02\0\x01\x12\x04\x8e\x06\x18%\n\r\n\x05\x04z\x02\0\x03\x12\x04\
    \x8e\x06()\n\x0c\n\x04\x04z\x02\x01\x12\x04\x8f\x06\x08$\n\r\n\x05\x04z\
    \x02\x01\x04\x12\x04\x8f\x06\x08\x10\n\r\n\x05\x04z\x02\x01\x05\x12\x04\
    \x8f\x06\x11\x17\n\r\n\x05\x04z\x02\x01\x01\x12\x04\x8f\x06\x18\x1f\n\r\
    \n\x05\x04z\x02\x01\x03\x12\x04\x8f\x06\"#\n\x0c\n\x04\x04z\x02\x02\x12\
    \x04\x90\x06\x08,\n\r\n\x05\x04z\x02\x02\x04\x12\x04\x90\x06\x08\x10\n\r\
    \n\x05\x04z\x02\x02\x05\x12\x04\x90\x06\x11\x18\n\r\n\x05\x04z\x02\x02\
    \x01\x12\x04\x90\x06\x19'\n\r\n\x05\x04z\x02\x02\x03\x12\x04\x90\x06*+\n\
    \x0c\n\x04\x04z\x02\x03\x12\x04\x91\x06\x08$\n\r\n\x05\x04z\x02\x03\x04\
    \x12\x04\x91\x06\x08\x10\n\r\n\x05\x04z\x02\x03\x05\x12\x04\x91\x06\x11\
    \x17\n\r\n\x05\x04z\x02\x03\x01\x12\x04\x91\x06\x18\x1f\n\r\n\x05\x04z\
    \x02\x03\x03\x12\x04\x91\x06\"#\n\x0c\n\x04\x04z\x02\x04\x12\x04\x92\x06\
    \x08&\n\r\n\x05\x04z\x02\x04\x04\x12\x04\x92\x06\x08\x10\n\r\n\x05\x04z\
    \x02\x04\x05\x12\x04\x92\x06\x11\x17\n\r\n\x05\x04z\x02\x04\x01\x12\x04\
    \x92\x06\x18!\n\r\n\x05\x04z\x02\x04\x03\x12\x04\x92\x06$%\n\x0c\n\x04\
    \x04z\x02\x05\x12\x04\x93\x06\x08-\n\r\n\x05\x04z\x02\x05\x04\x12\x04\
    \x93\x06\x08\x10\n\r\n\x05\x04z\x02\x05\x06\x12\x04\x93\x06\x11\x1f\n\r\
    \n\x05\x04z\x02\x05\x01\x12\x04\x93\x06\x20(\n\r\n\x05\x04z\x02\x05\x03\
    \x12\x04\x93\x06+,\n\x0c\n\x04\x04z\x02\x06\x12\x04\x94\x06\x08$\n\r\n\
    \x05\x04z\x02\x06\x04\x12\x04\x94\x06\x08\x10\n\r\n\x05\x04z\x02\x06\x05\
    \x12\x04\x94\x06\x11\x17\n\r\n\x05\x04z\x02\x06\x01\x12\x04\x94\x06\x18\
    \x1f\n\r\n\x05\x04z\x02\x06\x03\x12\x04\x94\x06\"#\n\x0c\n\x04\x04z\x02\
    \x07\x12\x04\x95\x06\x083\n\r\n\x05\x04z\x02\x07\x04\x12\x04\x95\x06\x08\
    \x10\n\r\n\x05\x04z\x02\x07\x06\x12\x04\x95\x06\x11\x1f\n\r\n\x05\x04z\
    \x02\x07\x01\x12\x04\x95\x06\x20.\n\r\n\x05\x04z\x02\x07\x03\x12\x04\x95\
    \x0612\n\x0c\n\x04\x04z\x02\x08\x12\x04\x96\x06\x08.\n\r\n\x05\x04z\x02\
    \x08\x04\x12\x04\x96\x06\x08\x10\n\r\n\x05\x04z\x02\x08\x05\x12\x04\x96\
    \x06\x11\x17\n\r\n\x05\x04z\x02\x08\x01\x12\x04\x96\x06\x18)\n\r\n\x05\
    \x04z\x02\x08\x03\x12\x04\x96\x06,-\n\x0c\n\x04\x04z\x02\t\x12\x04\x97\
    \x06\x08r\n\r\n\x05\x04z\x02\t\x04\x12\x04\x97\x06\x08\x10\n\r\n\x05\x04\
    z\x02\t\x05\x12\x04\x97\x06\x11\x17\n\r\n\x05\x04z\x02\t\x01\x12\x04\x97\
    \x06\x18!\n\r\n\x05\x04z\x02\t\x03\x12\x04\x97\x06$&\n\r\n\x05\x04z\x02\
    \t\x08\x12\x04\x97\x06'q\n\x10\n\x08\x04z\x02\t\x08\xd0\x86\x03\x12\x04\
    \x97\x06(p\n\x0c\n\x02\x04{\x12\x06\x9a\x06\0\xa4\x06\x01\n\x0b\n\x03\
    \x04{\x01\x12\x04\x9a\x06\x082\n\x0e\n\x04\x04{\x03\0\x12\x06\x9b\x06\
    \x08\x9f\x06\t\n\r\n\x05\x04{\x03\0\x01\x12\x04\x9b\x06\x10\x1b\n\x0e\n\
    \x06\x04{\x03\0\x02\0\x12\x04\x9c\x06\x105\n\x0f\n\x07\x04{\x03\0\x02\0\
    \x04\x12\x04\x9c\x06\x10\x18\n\x0f\n\x07\x04{\x03\0\x02\0\x05\x12\x04\
    \x9c\x06\x19\x1f\n\x0f\n\x07\x04{\x03\0\x02\0\x01\x12\x04\x9c\x06\x200\n\
    \x0f\n\x07\x04{\x03\0\x02\0\x03\x12\x04\x9c\x0634\n\x0e\n\x06\x04{\x03\0\
    \x02\x01\x12\x04\x9d\x06\x10,\n\x0f\n\x07\x04{\x03\0\x02\x01\x04\x12\x04\
    \x9d\x06\x10\x18\n\x0f\n\x07\x04{\x03\0\x02\x01\x05\x12\x04\x9d\x06\x19\
    \x1f\n\x0f\n\x07\x04{\x03\0\x02\x01\x01\x12\x04\x9d\x06\x20'\n\x0f\n\x07\
    \x04{\x03\0\x02\x01\x03\x12\x04\x9d\x06*+\n\x0e\n\x06\x04{\x03\0\x02\x02\
    \x12\x04\x9e\x06\x10*\n\x0f\n\x07\x04{\x03\0\x02\x02\x04\x12\x04\x9e\x06\
    \x10\x18\n\x0f\n\x07\x04{\x03\0\x02\x02\x05\x12\x04\x9e\x06\x19\x1d\n\
    \x0f\n\x07\x04{\x03\0\x02\x02\x01\x12\x04\x9e\x06\x1e%\n\x0f\n\x07\x04{\
    \x03\0\x02\x02\x03\x12\x04\x9e\x06()\n\x0c\n\x04\x04{\x02\0\x12\x04\xa1\
    \x06\x08*\n\r\n\x05\x04{\x02\0\x04\x12\x04\xa1\x06\x08\x10\n\r\n\x05\x04\
    {\x02\0\x05\x12\x04\xa1\x06\x11\x17\n\r\n\x05\x04{\x02\0\x01\x12\x04\xa1\
    \x06\x18%\n\r\n\x05\x04{\x02\0\x03\x12\x04\xa1\x06()\n\x0c\n\x04\x04{\
    \x02\x01\x12\x04\xa2\x06\x08$\n\r\n\x05\x04{\x02\x01\x04\x12\x04\xa2\x06\
    \x08\x10\n\r\n\x05\x04{\x02\x01\x05\x12\x04\xa2\x06\x11\x17\n\r\n\x05\
    \x04{\x02\x01\x01\x12\x04\xa2\x06\x18\x1f\n\r\n\x05\x04{\x02\x01\x03\x12\
    \x04\xa2\x06\"#\n\x0c\n\x04\x04{\x02\x02\x12\x04\xa3\x06\x08V\n\r\n\x05\
    \x04{\x02\x02\x04\x12\x04\xa3\x06\x08\x10\n\r\n\x05\x04{\x02\x02\x06\x12\
    \x04\xa3\x06\x11H\n\r\n\x05\x04{\x02\x02\x01\x12\x04\xa3\x06IQ\n\r\n\x05\
    \x04{\x02\x02\x03\x12\x04\xa3\x06TU\n\x0c\n\x02\x04|\x12\x06\xa6\x06\0\
    \xaa\x06\x01\n\x0b\n\x03\x04|\x01\x12\x04\xa6\x06\x080\n\x0c\n\x04\x04|\
    \x02\0\x12\x04\xa7\x06\x08*\n\r\n\x05\x04|\x02\0\x04\x12\x04\xa7\x06\x08\
    \x10\n\r\n\x05\x04|\x02\0\x05\x12\x04\xa7\x06\x11\x17\n\r\n\x05\x04|\x02\
    \0\x01\x12\x04\xa7\x06\x18%\n\r\n\x05\x04|\x02\0\x03\x12\x04\xa7\x06()\n\
    \x0c\n\x04\x04|\x02\x01\x12\x04\xa8\x06\x08-\n\r\n\x05\x04|\x02\x01\x04\
    \x12\x04\xa8\x06\x08\x10\n\r\n\x05\x04|\x02\x01\x06\x12\x04\xa8\x06\x11!\
    \n\r\n\x05\x04|\x02\x01\x01\x12\x04\xa8\x06\"(\n\r\n\x05\x04|\x02\x01\
    \x03\x12\x04\xa8\x06+,\n\x0c\n\x04\x04|\x02\x02\x12\x04\xa9\x06\x08i\n\r\
    \n\x05\x04|\x02\x02\x04\x12\x04\xa9\x06\x08\x10\n\r\n\x05\x04|\x02\x02\
    \x06\x12\x04\xa9\x06\x11,\n\r\n\x05\x04|\x02\x02\x01\x12\x04\xa9\x06-3\n\
    \r\n\x05\x04|\x02\x02\x03\x12\x04\xa9\x0667\n\r\n\x05\x04|\x02\x02\x08\
    \x12\x04\xa9\x068h\n\r\n\x05\x04|\x02\x02\x07\x12\x04\xa9\x06Cg\n\x0c\n\
    \x02\x04}\x12\x06\xac\x06\0\xae\x06\x01\n\x0b\n\x03\x04}\x01\x12\x04\xac\
    \x06\x082\n\x0c\n\x04\x04}\x02\0\x12\x04\xad\x06\x08=\n\r\n\x05\x04}\x02\
    \0\x04\x12\x04\xad\x06\x08\x10\n\r\n\x05\x04}\x02\0\x06\x12\x04\xad\x06\
    \x11+\n\r\n\x05\x04}\x02\0\x01\x12\x04\xad\x06,8\n\r\n\x05\x04}\x02\0\
    \x03\x12\x04\xad\x06;<\n\x0c\n\x02\x04~\x12\x06\xb0\x06\0\xb4\x06\x01\n\
    \x0b\n\x03\x04~\x01\x12\x04\xb0\x06\x087\n\x0c\n\x04\x04~\x02\0\x12\x04\
    \xb1\x06\x08*\n\r\n\x05\x04~\x02\0\x04\x12\x04\xb1\x06\x08\x10\n\r\n\x05\
    \x04~\x02\0\x05\x12\x04\xb1\x06\x11\x17\n\r\n\x05\x04~\x02\0\x01\x12\x04\
    \xb1\x06\x18%\n\r\n\x05\x04~\x02\0\x03\x12\x04\xb1\x06()\n\x0c\n\x04\x04\
    ~\x02\x01\x12\x04\xb2\x06\x08,\n\r\n\x05\x04~\x02\x01\x04\x12\x04\xb2\
    \x06\x08\x10\n\r\n\x05\x04~\x02\x01\x05\x12\x04\xb2\x06\x11\x17\n\r\n\
    \x05\x04~\x02\x01\x01\x12\x04\xb2\x06\x18'\n\r\n\x05\x04~\x02\x01\x03\
    \x12\x04\xb2\x06*+\n\x0c\n\x04\x04~\x02\x02\x12\x04\xb3\x06\x080\n\r\n\
    \x05\x04~\x02\x02\x04\x12\x04\xb3\x06\x08\x10\n\r\n\x05\x04~\x02\x02\x06\
    \x12\x04\xb3\x06\x11\x20\n\r\n\x05\x04~\x02\x02\x01\x12\x04\xb3\x06!+\n\
    \r\n\x05\x04~\x02\x02\x03\x12\x04\xb3\x06./\n\x0c\n\x02\x04\x7f\x12\x06\
    \xb6\x06\0\xb9\x06\x01\n\x0b\n\x03\x04\x7f\x01\x12\x04\xb6\x06\x08B\n\
    \x0c\n\x04\x04\x7f\x02\0\x12\x04\xb7\x06\x08$\n\r\n\x05\x04\x7f\x02\0\
    \x04\x12\x04\xb7\x06\x08\x10\n\r\n\x05\x04\x7f\x02\0\x05\x12\x04\xb7\x06\
    \x11\x17\n\r\n\x05\x04\x7f\x02\0\x01\x12\x04\xb7\x06\x18\x1f\n\r\n\x05\
    \x04\x7f\x02\0\x03\x12\x04\xb7\x06\"#\n\x0c\n\x04\x04\x7f\x02\x01\x12\
    \x04\xb8\x06\x08*\n\r\n\x05\x04\x7f\x02\x01\x04\x12\x04\xb8\x06\x08\x10\
    \n\r\n\x05\x04\x7f\x02\x01\x05\x12\x04\xb8\x06\x11\x17\n\r\n\x05\x04\x7f\
    \x02\x01\x01\x12\x04\xb8\x06\x18%\n\r\n\x05\x04\x7f\x02\x01\x03\x12\x04\
    \xb8\x06()\n\r\n\x03\x04\x80\x01\x12\x06\xbb\x06\0\xc0\x06\x01\n\x0c\n\
    \x04\x04\x80\x01\x01\x12\x04\xbb\x06\x08C\n\r\n\x05\x04\x80\x01\x02\0\
    \x12\x04\xbc\x06\x08*\n\x0e\n\x06\x04\x80\x01\x02\0\x04\x12\x04\xbc\x06\
    \x08\x10\n\x0e\n\x06\x04\x80\x01\x02\0\x05\x12\x04\xbc\x06\x11\x17\n\x0e\
    \n\x06\x04\x80\x01\x02\0\x01\x12\x04\xbc\x06\x18%\n\x0e\n\x06\x04\x80\
    \x01\x02\0\x03\x12\x04\xbc\x06()\n\r\n\x05\x04\x80\x01\x02\x01\x12\x04\
    \xbd\x06\x08D\n\x0e\n\x06\x04\x80\x01\x02\x01\x04\x12\x04\xbd\x06\x08\
    \x10\n\x0e\n\x06\x04\x80\x01\x02\x01\x06\x12\x04\xbd\x06\x11)\n\x0e\n\
    \x06\x04\x80\x01\x02\x01\x01\x12\x04\xbd\x06*?\n\x0e\n\x06\x04\x80\x01\
    \x02\x01\x03\x12\x04\xbd\x06BC\n\r\n\x05\x04\x80\x01\x02\x02\x12\x04\xbe\
    \x06\x08O\n\x0e\n\x06\x04\x80\x01\x02\x02\x04\x12\x04\xbe\x06\x08\x10\n\
    \x0e\n\x06\x04\x80\x01\x02\x02\x06\x12\x04\xbe\x06\x11<\n\x0e\n\x06\x04\
    \x80\x01\x02\x02\x01\x12\x04\xbe\x06=J\n\x0e\n\x06\x04\x80\x01\x02\x02\
    \x03\x12\x04\xbe\x06MN\n\r\n\x05\x04\x80\x01\x02\x03\x12\x04\xbf\x06\x08\
    n\n\x0e\n\x06\x04\x80\x01\x02\x03\x04\x12\x04\xbf\x06\x08\x10\n\x0e\n\
    \x06\x04\x80\x01\x02\x03\x06\x12\x04\xbf\x06\x11,\n\x0e\n\x06\x04\x80\
    \x01\x02\x03\x01\x12\x04\xbf\x06-8\n\x0e\n\x06\x04\x80\x01\x02\x03\x03\
    \x12\x04\xbf\x06;<\n\x0e\n\x06\x04\x80\x01\x02\x03\x08\x12\x04\xbf\x06=m\
    \n\x0e\n\x06\x04\x80\x01\x02\x03\x07\x12\x04\xbf\x06Hl\n\r\n\x03\x04\x81\
    \x01\x12\x06\xc2\x06\0\xc4\x06\x01\n\x0c\n\x04\x04\x81\x01\x01\x12\x04\
    \xc2\x06\x08<\n\r\n\x05\x04\x81\x01\x02\0\x12\x04\xc3\x06\x08+\n\x0e\n\
    \x06\x04\x81\x01\x02\0\x04\x12\x04\xc3\x06\x08\x10\n\x0e\n\x06\x04\x81\
    \x01\x02\0\x05\x12\x04\xc3\x06\x11\x17\n\x0e\n\x06\x04\x81\x01\x02\0\x01\
    \x12\x04\xc3\x06\x18&\n\x0e\n\x06\x04\x81\x01\x02\0\x03\x12\x04\xc3\x06)\
    *\n\r\n\x03\x04\x82\x01\x12\x06\xc6\x06\0\xcc\x06\x01\n\x0c\n\x04\x04\
    \x82\x01\x01\x12\x04\xc6\x06\x08\x1f\n\r\n\x05\x04\x82\x01\x02\0\x12\x04\
    \xc7\x06\x08!\n\x0e\n\x06\x04\x82\x01\x02\0\x04\x12\x04\xc7\x06\x08\x10\
    \n\x0e\n\x06\x04\x82\x01\x02\0\x05\x12\x04\xc7\x06\x11\x16\n\x0e\n\x06\
    \x04\x82\x01\x02\0\x01\x12\x04\xc7\x06\x17\x1c\n\x0e\n\x06\x04\x82\x01\
    \x02\0\x03\x12\x04\xc7\x06\x1f\x20\n\r\n\x05\x04\x82\x01\x02\x01\x12\x04\
    \xc8\x06\x08\x1f\n\x0e\n\x06\x04\x82\x01\x02\x01\x04\x12\x04\xc8\x06\x08\
    \x10\n\x0e\n\x06\x04\x82\x01\x02\x01\x05\x12\x04\xc8\x06\x11\x16\n\x0e\n\
    \x06\x04\x82\x01\x02\x01\x01\x12\x04\xc8\x06\x17\x1a\n\x0e\n\x06\x04\x82\
    \x01\x02\x01\x03\x12\x04\xc8\x06\x1d\x1e\n\r\n\x05\x04\x82\x01\x02\x02\
    \x12\x04\xc9\x06\x08'\n\x0e\n\x06\x04\x82\x01\x02\x02\x04\x12\x04\xc9\
    \x06\x08\x10\n\x0e\n\x06\x04\x82\x01\x02\x02\x05\x12\x04\xc9\x06\x11\x16\
    \n\x0e\n\x06\x04\x82\x01\x02\x02\x01\x12\x04\xc9\x06\x17\"\n\x0e\n\x06\
    \x04\x82\x01\x02\x02\x03\x12\x04\xc9\x06%&\n\x0e\n\x05\x04\x82\x01\x02\
    \x03\x12\x05\xca\x06\x08\x84\x01\n\x0e\n\x06\x04\x82\x01\x02\x03\x04\x12\
    \x04\xca\x06\x08\x10\n\x0e\n\x06\x04\x82\x01\x02\x03\x05\x12\x04\xca\x06\
    \x11\x16\n\x0e\n\x06\x04\x82\x01\x02\x03\x01\x12\x04\xca\x06\x17*\n\x0e\
    \n\x06\x04\x82\x01\x02\x03\x03\x12\x04\xca\x06-.\n\x0f\n\x06\x04\x82\x01\
    \x02\x03\x08\x12\x05\xca\x06/\x83\x01\n\x12\n\t\x04\x82\x01\x02\x03\x08\
    \xd0\x86\x03\x12\x05\xca\x060\x82\x01\n\x0e\n\x05\x04\x82\x01\x02\x04\
    \x12\x05\xcb\x06\x08\x88\x01\n\x0e\n\x06\x04\x82\x01\x02\x04\x04\x12\x04\
    \xcb\x06\x08\x10\n\x0e\n\x06\x04\x82\x01\x02\x04\x05\x12\x04\xcb\x06\x11\
    \x16\n\x0e\n\x06\x04\x82\x01\x02\x04\x01\x12\x04\xcb\x06\x17*\n\x0e\n\
    \x06\x04\x82\x01\x02\x04\x03\x12\x04\xcb\x06-.\n\x0f\n\x06\x04\x82\x01\
    \x02\x04\x08\x12\x05\xcb\x06/\x87\x01\n\x12\n\t\x04\x82\x01\x02\x04\x08\
    \xd0\x86\x03\x12\x05\xcb\x060\x86\x01\n\r\n\x03\x04\x83\x01\x12\x06\xce\
    \x06\0\xd2\x06\x01\n\x0c\n\x04\x04\x83\x01\x01\x12\x04\xce\x06\x08$\n\r\
    \n\x05\x04\x83\x01\x02\0\x12\x04\xcf\x06\x08\"\n\x0e\n\x06\x04\x83\x01\
    \x02\0\x04\x12\x04\xcf\x06\x08\x10\n\x0e\n\x06\x04\x83\x01\x02\0\x05\x12\
    \x04\xcf\x06\x11\x16\n\x0e\n\x06\x04\x83\x01\x02\0\x01\x12\x04\xcf\x06\
    \x17\x1d\n\x0e\n\x06\x04\x83\x01\x02\0\x03\x12\x04\xcf\x06\x20!\n\r\n\
    \x05\x04\x83\x01\x02\x01\x12\x04\xd0\x06\x08\"\n\x0e\n\x06\x04\x83\x01\
    \x02\x01\x04\x12\x04\xd0\x06\x08\x10\n\x0e\n\x06\x04\x83\x01\x02\x01\x05\
    \x12\x04\xd0\x06\x11\x16\n\x0e\n\x06\x04\x83\x01\x02\x01\x01\x12\x04\xd0\
    \x06\x17\x1d\n\x0e\n\x06\x04\x83\x01\x02\x01\x03\x12\x04\xd0\x06\x20!\n\
    \r\n\x05\x04\x83\x01\x02\x02\x12\x04\xd1\x06\x08#\n\x0e\n\x06\x04\x83\
    \x01\x02\x02\x04\x12\x04\xd1\x06\x08\x10\n\x0e\n\x06\x04\x83\x01\x02\x02\
    \x05\x12\x04\xd1\x06\x11\x16\n\x0e\n\x06\x04\x83\x01\x02\x02\x01\x12\x04\
    \xd1\x06\x17\x1e\n\x0e\n\x06\x04\x83\x01\x02\x02\x03\x12\x04\xd1\x06!\"\
    \n\r\n\x03\x04\x84\x01\x12\x06\xd4\x06\0\xe2\x06\x01\n\x0c\n\x04\x04\x84\
    \x01\x01\x12\x04\xd4\x06\x08:\n\x0f\n\x05\x04\x84\x01\x03\0\x12\x06\xd5\
    \x06\x08\xd9\x06\t\n\x0e\n\x06\x04\x84\x01\x03\0\x01\x12\x04\xd5\x06\x10\
    #\n\x0f\n\x07\x04\x84\x01\x03\0\x02\0\x12\x04\xd6\x06\x10(\n\x10\n\x08\
    \x04\x84\x01\x03\0\x02\0\x04\x12\x04\xd6\x06\x10\x18\n\x10\n\x08\x04\x84\
    \x01\x03\0\x02\0\x05\x12\x04\xd6\x06\x19\x1e\n\x10\n\x08\x04\x84\x01\x03\
    \0\x02\0\x01\x12\x04\xd6\x06\x1f#\n\x10\n\x08\x04\x84\x01\x03\0\x02\0\
    \x03\x12\x04\xd6\x06&'\n\x0f\n\x07\x04\x84\x01\x03\0\x02\x01\x12\x04\xd7\
    \x06\x10.\n\x10\n\x08\x04\x84\x01\x03\0\x02\x01\x04\x12\x04\xd7\x06\x10\
    \x18\n\x10\n\x08\x04\x84\x01\x03\0\x02\x01\x05\x12\x04\xd7\x06\x19\x1f\n\
    \x10\n\x08\x04\x84\x01\x03\0\x02\x01\x01\x12\x04\xd7\x06\x20)\n\x10\n\
    \x08\x04\x84\x01\x03\0\x02\x01\x03\x12\x04\xd7\x06,-\n\x0f\n\x07\x04\x84\
    \x01\x03\0\x02\x02\x12\x04\xd8\x06\x10D\n\x10\n\x08\x04\x84\x01\x03\0\
    \x02\x02\x04\x12\x04\xd8\x06\x10\x18\n\x10\n\x08\x04\x84\x01\x03\0\x02\
    \x02\x06\x12\x04\xd8\x06\x197\n\x10\n\x08\x04\x84\x01\x03\0\x02\x02\x01\
    \x12\x04\xd8\x068?\n\x10\n\x08\x04\x84\x01\x03\0\x02\x02\x03\x12\x04\xd8\
    \x06BC\n\r\n\x05\x04\x84\x01\x02\0\x12\x04\xdb\x06\x08*\n\x0e\n\x06\x04\
    \x84\x01\x02\0\x04\x12\x04\xdb\x06\x08\x10\n\x0e\n\x06\x04\x84\x01\x02\0\
    \x05\x12\x04\xdb\x06\x11\x17\n\x0e\n\x06\x04\x84\x01\x02\0\x01\x12\x04\
    \xdb\x06\x18%\n\x0e\n\x06\x04\x84\x01\x02\0\x03\x12\x04\xdb\x06()\n\r\n\
    \x05\x04\x84\x01\x02\x01\x12\x04\xdc\x06\x08q\n\x0e\n\x06\x04\x84\x01\
    \x02\x01\x04\x12\x04\xdc\x06\x08\x10\n\x0e\n\x06\x04\x84\x01\x02\x01\x05\
    \x12\x04\xdc\x06\x11\x17\n\x0e\n\x06\x04\x84\x01\x02\x01\x01\x12\x04\xdc\
    \x06\x18\x1f\n\x0e\n\x06\x04\x84\x01\x02\x01\x03\x12\x04\xdc\x06\"#\n\
    \x0e\n\x06\x04\x84\x01\x02\x01\x08\x12\x04\xdc\x06$p\n\x11\n\t\x04\x84\
    \x01\x02\x01\x08\xd0\x86\x03\x12\x04\xdc\x06%o\n\r\n\x05\x04\x84\x01\x02\
    \x02\x12\x04\xdd\x06\x083\n\x0e\n\x06\x04\x84\x01\x02\x02\x04\x12\x04\
    \xdd\x06\x08\x10\n\x0e\n\x06\x04\x84\x01\x02\x02\x06\x12\x04\xdd\x06\x11\
    )\n\x0e\n\x06\x04\x84\x01\x02\x02\x01\x12\x04\xdd\x06*.\n\x0e\n\x06\x04\
    \x84\x01\x02\x02\x03\x12\x04\xdd\x0612\n\r\n\x05\x04\x84\x01\x02\x03\x12\
    \x04\xde\x06\x08e\n\x0e\n\x06\x04\x84\x01\x02\x03\x04\x12\x04\xde\x06\
    \x08\x10\n\x0e\n\x06\x04\x84\x01\x02\x03\x06\x12\x04\xde\x06\x11X\n\x0e\
    \n\x06\x04\x84\x01\x02\x03\x01\x12\x04\xde\x06Y`\n\x0e\n\x06\x04\x84\x01\
    \x02\x03\x03\x12\x04\xde\x06cd\n\r\n\x05\x04\x84\x01\x02\x04\x12\x04\xdf\
    \x06\x08)\n\x0e\n\x06\x04\x84\x01\x02\x04\x04\x12\x04\xdf\x06\x08\x10\n\
    \x0e\n\x06\x04\x84\x01\x02\x04\x05\x12\x04\xdf\x06\x11\x17\n\x0e\n\x06\
    \x04\x84\x01\x02\x04\x01\x12\x04\xdf\x06\x18$\n\x0e\n\x06\x04\x84\x01\
    \x02\x04\x03\x12\x04\xdf\x06'(\n\r\n\x05\x04\x84\x01\x02\x05\x12\x04\xe0\
    \x06\x08B\n\x0e\n\x06\x04\x84\x01\x02\x05\x04\x12\x04\xe0\x06\x08\x10\n\
    \x0e\n\x06\x04\x84\x01\x02\x05\x06\x12\x04\xe0\x06\x11.\n\x0e\n\x06\x04\
    \x84\x01\x02\x05\x01\x12\x04\xe0\x06/=\n\x0e\n\x06\x04\x84\x01\x02\x05\
    \x03\x12\x04\xe0\x06@A\n\r\n\x05\x04\x84\x01\x02\x06\x12\x04\xe1\x06\x08\
    H\n\x0e\n\x06\x04\x84\x01\x02\x06\x04\x12\x04\xe1\x06\x08\x10\n\x0e\n\
    \x06\x04\x84\x01\x02\x06\x06\x12\x04\xe1\x06\x11/\n\x0e\n\x06\x04\x84\
    \x01\x02\x06\x01\x12\x04\xe1\x060C\n\x0e\n\x06\x04\x84\x01\x02\x06\x03\
    \x12\x04\xe1\x06FG\n\r\n\x03\x04\x85\x01\x12\x06\xe4\x06\0\xed\x06\x01\n\
    \x0c\n\x04\x04\x85\x01\x01\x12\x04\xe4\x06\x08.\n\r\n\x05\x04\x85\x01\
    \x02\0\x12\x04\xe5\x06\x08*\n\x0e\n\x06\x04\x85\x01\x02\0\x04\x12\x04\
    \xe5\x06\x08\x10\n\x0e\n\x06\x04\x85\x01\x02\0\x05\x12\x04\xe5\x06\x11\
    \x17\n\x0e\n\x06\x04\x85\x01\x02\0\x01\x12\x04\xe5\x06\x18%\n\x0e\n\x06\
    \x04\x85\x01\x02\0\x03\x12\x04\xe5\x06()\n\r\n\x05\x04\x85\x01\x02\x01\
    \x12\x04\xe6\x06\x08$\n\x0e\n\x06\x04\x85\x01\x02\x01\x04\x12\x04\xe6\
    \x06\x08\x10\n\x0e\n\x06\x04\x85\x01\x02\x01\x05\x12\x04\xe6\x06\x11\x17\
    \n\x0e\n\x06\x04\x85\x01\x02\x01\x01\x12\x04\xe6\x06\x18\x1f\n\x0e\n\x06\
    \x04\x85\x01\x02\x01\x03\x12\x04\xe6\x06\"#\n\r\n\x05\x04\x85\x01\x02\
    \x02\x12\x04\xe7\x06\x08-\n\x0e\n\x06\x04\x85\x01\x02\x02\x04\x12\x04\
    \xe7\x06\x08\x10\n\x0e\n\x06\x04\x85\x01\x02\x02\x05\x12\x04\xe7\x06\x11\
    \x17\n\x0e\n\x06\x04\x85\x01\x02\x02\x01\x12\x04\xe7\x06\x18(\n\x0e\n\
    \x06\x04\x85\x01\x02\x02\x03\x12\x04\xe7\x06+,\n\r\n\x05\x04\x85\x01\x02\
    \x03\x12\x04\xe8\x06\x08$\n\x0e\n\x06\x04\x85\x01\x02\x03\x04\x12\x04\
    \xe8\x06\x08\x10\n\x0e\n\x06\x04\x85\x01\x02\x03\x05\x12\x04\xe8\x06\x11\
    \x17\n\x0e\n\x06\x04\x85\x01\x02\x03\x01\x12\x04\xe8\x06\x18\x1f\n\x0e\n\
    \x06\x04\x85\x01\x02\x03\x03\x12\x04\xe8\x06\"#\n\r\n\x05\x04\x85\x01\
    \x02\x04\x12\x04\xe9\x06\x08%\n\x0e\n\x06\x04\x85\x01\x02\x04\x04\x12\
    \x04\xe9\x06\x08\x10\n\x0e\n\x06\x04\x85\x01\x02\x04\x05\x12\x04\xe9\x06\
    \x11\x18\n\x0e\n\x06\x04\x85\x01\x02\x04\x01\x12\x04\xe9\x06\x19\x20\n\
    \x0e\n\x06\x04\x85\x01\x02\x04\x03\x12\x04\xe9\x06#$\n\r\n\x05\x04\x85\
    \x01\x02\x05\x12\x04\xea\x06\x08t\n\x0e\n\x06\x04\x85\x01\x02\x05\x04\
    \x12\x04\xea\x06\x08\x10\n\x0e\n\x06\x04\x85\x01\x02\x05\x06\x12\x04\xea\
    \x06\x11.\n\x0e\n\x06\x04\x85\x01\x02\x05\x01\x12\x04\xea\x06/<\n\x0e\n\
    \x06\x04\x85\x01\x02\x05\x03\x12\x04\xea\x06?@\n\x0e\n\x06\x04\x85\x01\
    \x02\x05\x08\x12\x04\xea\x06As\n\x0e\n\x06\x04\x85\x01\x02\x05\x07\x12\
    \x04\xea\x06Lr\n\r\n\x05\x04\x85\x01\x02\x06\x12\x04\xeb\x06\x08%\n\x0e\
    \n\x06\x04\x85\x01\x02\x06\x04\x12\x04\xeb\x06\x08\x10\n\x0e\n\x06\x04\
    \x85\x01\x02\x06\x05\x12\x04\xeb\x06\x11\x17\n\x0e\n\x06\x04\x85\x01\x02\
    \x06\x01\x12\x04\xeb\x06\x18\x20\n\x0e\n\x06\x04\x85\x01\x02\x06\x03\x12\
    \x04\xeb\x06#$\n\r\n\x05\x04\x85\x01\x02\x07\x12\x04\xec\x06\x08!\n\x0e\
    \n\x06\x04\x85\x01\x02\x07\x04\x12\x04\xec\x06\x08\x10\n\x0e\n\x06\x04\
    \x85\x01\x02\x07\x05\x12\x04\xec\x06\x11\x15\n\x0e\n\x06\x04\x85\x01\x02\
    \x07\x01\x12\x04\xec\x06\x16\x1c\n\x0e\n\x06\x04\x85\x01\x02\x07\x03\x12\
    \x04\xec\x06\x1f\x20\n\r\n\x03\x04\x86\x01\x12\x06\xef\x06\0\xca\x07\x01\
    \n\x0c\n\x04\x04\x86\x01\x01\x12\x04\xef\x06\x08:\n\x0f\n\x05\x04\x86\
    \x01\x03\0\x12\x06\xf0\x06\x08\x8a\x07\t\n\x0e\n\x06\x04\x86\x01\x03\0\
    \x01\x12\x04\xf0\x06\x10\x18\n\x0f\n\x07\x04\x86\x01\x03\0\x02\0\x12\x04\
    \xf1\x06\x10<\n\x10\n\x08\x04\x86\x01\x03\0\x02\0\x04\x12\x04\xf1\x06\
    \x10\x18\n\x10\n\x08\x04\x86\x01\x03\0\x02\0\x05\x12\x04\xf1\x06\x19\x1d\
    \n\x10\n\x08\x04\x86\x01\x03\0\x02\0\x01\x12\x04\xf1\x06\x1e7\n\x10\n\
    \x08\x04\x86\x01\x03\0\x02\0\x03\x12\x04\xf1\x06:;\n\x0f\n\x07\x04\x86\
    \x01\x03\0\x02\x01\x12\x04\xf2\x06\x10<\n\x10\n\x08\x04\x86\x01\x03\0\
    \x02\x01\x04\x12\x04\xf2\x06\x10\x18\n\x10\n\x08\x04\x86\x01\x03\0\x02\
    \x01\x05\x12\x04\xf2\x06\x19\x1d\n\x10\n\x08\x04\x86\x01\x03\0\x02\x01\
    \x01\x12\x04\xf2\x06\x1e7\n\x10\n\x08\x04\x86\x01\x03\0\x02\x01\x03\x12\
    \x04\xf2\x06:;\n\x0f\n\x07\x04\x86\x01\x03\0\x02\x02\x12\x04\xf3\x06\x10\
    =\n\x10\n\x08\x04\x86\x01\x03\0\x02\x02\x04\x12\x04\xf3\x06\x10\x18\n\
    \x10\n\x08\x04\x86\x01\x03\0\x02\x02\x05\x12\x04\xf3\x06\x19\x1d\n\x10\n\
    \x08\x04\x86\x01\x03\0\x02\x02\x01\x12\x04\xf3\x06\x1e8\n\x10\n\x08\x04\
    \x86\x01\x03\0\x02\x02\x03\x12\x04\xf3\x06;<\n\x0f\n\x07\x04\x86\x01\x03\
    \0\x02\x03\x12\x04\xf4\x06\x10I\n\x10\n\x08\x04\x86\x01\x03\0\x02\x03\
    \x04\x12\x04\xf4\x06\x10\x18\n\x10\n\x08\x04\x86\x01\x03\0\x02\x03\x05\
    \x12\x04\xf4\x06\x19\x1d\n\x10\n\x08\x04\x86\x01\x03\0\x02\x03\x01\x12\
    \x04\xf4\x06\x1eD\n\x10\n\x08\x04\x86\x01\x03\0\x02\x03\x03\x12\x04\xf4\
    \x06GH\n\x0f\n\x07\x04\x86\x01\x03\0\x02\x04\x12\x04\xf5\x06\x105\n\x10\
    \n\x08\x04\x86\x01\x03\0\x02\x04\x04\x12\x04\xf5\x06\x10\x18\n\x10\n\x08\
    \x04\x86\x01\x03\0\x02\x04\x05\x12\x04\xf5\x06\x19\x1d\n\x10\n\x08\x04\
    \x86\x01\x03\0\x02\x04\x01\x12\x04\xf5\x06\x1e0\n\x10\n\x08\x04\x86\x01\
    \x03\0\x02\x04\x03\x12\x04\xf5\x0634\n\x0f\n\x07\x04\x86\x01\x03\0\x02\
    \x05\x12\x04\xf6\x06\x105\n\x10\n\x08\x04\x86\x01\x03\0\x02\x05\x04\x12\
    \x04\xf6\x06\x10\x18\n\x10\n\x08\x04\x86\x01\x03\0\x02\x05\x05\x12\x04\
    \xf6\x06\x19\x1d\n\x10\n\x08\x04\x86\x01\x03\0\x02\x05\x01\x12\x04\xf6\
    \x06\x1e0\n\x10\n\x08\x04\x86\x01\x03\0\x02\x05\x03\x12\x04\xf6\x0634\n\
    \x0f\n\x07\x04\x86\x01\x03\0\x02\x06\x12\x04\xf7\x06\x106\n\x10\n\x08\
    \x04\x86\x01\x03\0\x02\x06\x04\x12\x04\xf7\x06\x10\x18\n\x10\n\x08\x04\
    \x86\x01\x03\0\x02\x06\x05\x12\x04\xf7\x06\x19\x1d\n\x10\n\x08\x04\x86\
    \x01\x03\0\x02\x06\x01\x12\x04\xf7\x06\x1e1\n\x10\n\x08\x04\x86\x01\x03\
    \0\x02\x06\x03\x12\x04\xf7\x0645\n\x0f\n\x07\x04\x86\x01\x03\0\x02\x07\
    \x12\x04\xf8\x06\x10B\n\x10\n\x08\x04\x86\x01\x03\0\x02\x07\x04\x12\x04\
    \xf8\x06\x10\x18\n\x10\n\x08\x04\x86\x01\x03\0\x02\x07\x05\x12\x04\xf8\
    \x06\x19\x1d\n\x10\n\x08\x04\x86\x01\x03\0\x02\x07\x01\x12\x04\xf8\x06\
    \x1e=\n\x10\n\x08\x04\x86\x01\x03\0\x02\x07\x03\x12\x04\xf8\x06@A\n\x0f\
    \n\x07\x04\x86\x01\x03\0\x02\x08\x12\x04\xf9\x06\x109\n\x10\n\x08\x04\
    \x86\x01\x03\0\x02\x08\x04\x12\x04\xf9\x06\x10\x18\n\x10\n\x08\x04\x86\
    \x01\x03\0\x02\x08\x05\x12\x04\xf9\x06\x19\x1d\n\x10\n\x08\x04\x86\x01\
    \x03\0\x02\x08\x01\x12\x04\xf9\x06\x1e4\n\x10\n\x08\x04\x86\x01\x03\0\
    \x02\x08\x03\x12\x04\xf9\x0678\n\x0f\n\x07\x04\x86\x01\x03\0\x02\t\x12\
    \x04\xfa\x06\x10C\n\x10\n\x08\x04\x86\x01\x03\0\x02\t\x04\x12\x04\xfa\
    \x06\x10\x18\n\x10\n\x08\x04\x86\x01\x03\0\x02\t\x05\x12\x04\xfa\x06\x19\
    \x1d\n\x10\n\x08\x04\x86\x01\x03\0\x02\t\x01\x12\x04\xfa\x06\x1e=\n\x10\
    \n\x08\x04\x86\x01\x03\0\x02\t\x03\x12\x04\xfa\x06@B\n\x0f\n\x07\x04\x86\
    \x01\x03\0\x02\n\x12\x04\xfb\x06\x104\n\x10\n\x08\x04\x86\x01\x03\0\x02\
    \n\x04\x12\x04\xfb\x06\x10\x18\n\x10\n\x08\x04\x86\x01\x03\0\x02\n\x05\
    \x12\x04\xfb\x06\x19\x1e\n\x10\n\x08\x04\x86\x01\x03\0\x02\n\x01\x12\x04\
    \xfb\x06\x1f.\n\x10\n\x08\x04\x86\x01\x03\0\x02\n\x03\x12\x04\xfb\x0613\
    \n\x0f\n\x07\x04\x86\x01\x03\0\x02\x0b\x12\x04\xfc\x06\x107\n\x10\n\x08\
    \x04\x86\x01\x03\0\x02\x0b\x04\x12\x04\xfc\x06\x10\x18\n\x10\n\x08\x04\
    \x86\x01\x03\0\x02\x0b\x05\x12\x04\xfc\x06\x19\x1d\n\x10\n\x08\x04\x86\
    \x01\x03\0\x02\x0b\x01\x12\x04\xfc\x06\x1e1\n\x10\n\x08\x04\x86\x01\x03\
    \0\x02\x0b\x03\x12\x04\xfc\x0646\n\x0f\n\x07\x04\x86\x01\x03\0\x02\x0c\
    \x12\x04\xfd\x06\x108\n\x10\n\x08\x04\x86\x01\x03\0\x02\x0c\x04\x12\x04\
    \xfd\x06\x10\x18\n\x10\n\x08\x04\x86\x01\x03\0\x02\x0c\x05\x12\x04\xfd\
    \x06\x19\x1d\n\x10\n\x08\x04\x86\x01\x03\0\x02\x0c\x01\x12\x04\xfd\x06\
    \x1e2\n\x10\n\x08\x04\x86\x01\x03\0\x02\x0c\x03\x12\x04\xfd\x0657\n\x0f\
    \n\x07\x04\x86\x01\x03\0\x02\r\x12\x04\xfe\x06\x108\n\x10\n\x08\x04\x86\
    \x01\x03\0\x02\r\x04\x12\x04\xfe\x06\x10\x18\n\x10\n\x08\x04\x86\x01\x03\
    \0\x02\r\x05\x12\x04\xfe\x06\x19\x1d\n\x10\n\x08\x04\x86\x01\x03\0\x02\r\
    \x01\x12\x04\xfe\x06\x1e2\n\x10\n\x08\x04\x86\x01\x03\0\x02\r\x03\x12\
    \x04\xfe\x0657\n\x0f\n\x07\x04\x86\x01\x03\0\x02\x0e\x12\x04\xff\x06\x10\
    M\n\x10\n\x08\x04\x86\x01\x03\0\x02\x0e\x04\x12\x04\xff\x06\x10\x18\n\
    \x10\n\x08\x04\x86\x01\x03\0\x02\x0e\x05\x12\x04\xff\x06\x19\x1d\n\x10\n\
    \x08\x04\x86\x01\x03\0\x02\x0e\x01\x12\x04\xff\x06\x1eG\n\x10\n\x08\x04\
    \x86\x01\x03\0\x02\x0e\x03\x12\x04\xff\x06JL\n\x0f\n\x07\x04\x86\x01\x03\
    \0\x02\x0f\x12\x04\x80\x07\x10F\n\x10\n\x08\x04\x86\x01\x03\0\x02\x0f\
    \x04\x12\x04\x80\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\0\x02\x0f\x05\
    \x12\x04\x80\x07\x19\x1d\n\x10\n\x08\x04\x86\x01\x03\0\x02\x0f\x01\x12\
    \x04\x80\x07\x1e@\n\x10\n\x08\x04\x86\x01\x03\0\x02\x0f\x03\x12\x04\x80\
    \x07CE\n\x0f\n\x07\x04\x86\x01\x03\0\x02\x10\x12\x04\x81\x07\x10F\n\x10\
    \n\x08\x04\x86\x01\x03\0\x02\x10\x04\x12\x04\x81\x07\x10\x18\n\x10\n\x08\
    \x04\x86\x01\x03\0\x02\x10\x05\x12\x04\x81\x07\x19\x1d\n\x10\n\x08\x04\
    \x86\x01\x03\0\x02\x10\x01\x12\x04\x81\x07\x1e@\n\x10\n\x08\x04\x86\x01\
    \x03\0\x02\x10\x03\x12\x04\x81\x07CE\n\x0f\n\x07\x04\x86\x01\x03\0\x02\
    \x11\x12\x04\x82\x07\x10<\n\x10\n\x08\x04\x86\x01\x03\0\x02\x11\x04\x12\
    \x04\x82\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\0\x02\x11\x05\x12\x04\
    \x82\x07\x19\x1d\n\x10\n\x08\x04\x86\x01\x03\0\x02\x11\x01\x12\x04\x82\
    \x07\x1e6\n\x10\n\x08\x04\x86\x01\x03\0\x02\x11\x03\x12\x04\x82\x079;\n\
    \x0f\n\x07\x04\x86\x01\x03\0\x02\x12\x12\x04\x83\x07\x10F\n\x10\n\x08\
    \x04\x86\x01\x03\0\x02\x12\x04\x12\x04\x83\x07\x10\x18\n\x10\n\x08\x04\
    \x86\x01\x03\0\x02\x12\x05\x12\x04\x83\x07\x19\x1d\n\x10\n\x08\x04\x86\
    \x01\x03\0\x02\x12\x01\x12\x04\x83\x07\x1e@\n\x10\n\x08\x04\x86\x01\x03\
    \0\x02\x12\x03\x12\x04\x83\x07CE\n\x0f\n\x07\x04\x86\x01\x03\0\x02\x13\
    \x12\x04\x84\x07\x103\n\x10\n\x08\x04\x86\x01\x03\0\x02\x13\x04\x12\x04\
    \x84\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\0\x02\x13\x05\x12\x04\x84\
    \x07\x19\x1e\n\x10\n\x08\x04\x86\x01\x03\0\x02\x13\x01\x12\x04\x84\x07\
    \x1f-\n\x10\n\x08\x04\x86\x01\x03\0\x02\x13\x03\x12\x04\x84\x0702\n\x0f\
    \n\x07\x04\x86\x01\x03\0\x02\x14\x12\x04\x85\x07\x103\n\x10\n\x08\x04\
    \x86\x01\x03\0\x02\x14\x04\x12\x04\x85\x07\x10\x18\n\x10\n\x08\x04\x86\
    \x01\x03\0\x02\x14\x05\x12\x04\x85\x07\x19\x1d\n\x10\n\x08\x04\x86\x01\
    \x03\0\x02\x14\x01\x12\x04\x85\x07\x1e-\n\x10\n\x08\x04\x86\x01\x03\0\
    \x02\x14\x03\x12\x04\x85\x0702\n\x0f\n\x07\x04\x86\x01\x03\0\x02\x15\x12\
    \x04\x86\x07\x107\n\x10\n\x08\x04\x86\x01\x03\0\x02\x15\x04\x12\x04\x86\
    \x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\0\x02\x15\x05\x12\x04\x86\x07\
    \x19\x1d\n\x10\n\x08\x04\x86\x01\x03\0\x02\x15\x01\x12\x04\x86\x07\x1e1\
    \n\x10\n\x08\x04\x86\x01\x03\0\x02\x15\x03\x12\x04\x86\x0746\n\x0f\n\x07\
    \x04\x86\x01\x03\0\x02\x16\x12\x04\x87\x07\x10:\n\x10\n\x08\x04\x86\x01\
    \x03\0\x02\x16\x04\x12\x04\x87\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\0\
    \x02\x16\x05\x12\x04\x87\x07\x19\x1d\n\x10\n\x08\x04\x86\x01\x03\0\x02\
    \x16\x01\x12\x04\x87\x07\x1e4\n\x10\n\x08\x04\x86\x01\x03\0\x02\x16\x03\
    \x12\x04\x87\x0779\n\x0f\n\x07\x04\x86\x01\x03\0\x02\x17\x12\x04\x88\x07\
    \x105\n\x10\n\x08\x04\x86\x01\x03\0\x02\x17\x04\x12\x04\x88\x07\x10\x18\
    \n\x10\n\x08\x04\x86\x01\x03\0\x02\x17\x05\x12\x04\x88\x07\x19\x1d\n\x10\
    \n\x08\x04\x86\x01\x03\0\x02\x17\x01\x12\x04\x88\x07\x1e/\n\x10\n\x08\
    \x04\x86\x01\x03\0\x02\x17\x03\x12\x04\x88\x0724\n\x0f\n\x07\x04\x86\x01\
    \x03\0\x02\x18\x12\x04\x89\x07\x104\n\x10\n\x08\x04\x86\x01\x03\0\x02\
    \x18\x04\x12\x04\x89\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\0\x02\x18\
    \x05\x12\x04\x89\x07\x19\x1d\n\x10\n\x08\x04\x86\x01\x03\0\x02\x18\x01\
    \x12\x04\x89\x07\x1e.\n\x10\n\x08\x04\x86\x01\x03\0\x02\x18\x03\x12\x04\
    \x89\x0713\n\x0f\n\x05\x04\x86\x01\x03\x01\x12\x06\x8c\x07\x08\x98\x07\t\
    \n\x0e\n\x06\x04\x86\x01\x03\x01\x01\x12\x04\x8c\x07\x10\x1d\n\x0f\n\x07\
    \x04\x86\x01\x03\x01\x02\0\x12\x04\x8d\x07\x104\n\x10\n\x08\x04\x86\x01\
    \x03\x01\x02\0\x04\x12\x04\x8d\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\
    \x01\x02\0\x05\x12\x04\x8d\x07\x19\x1e\n\x10\n\x08\x04\x86\x01\x03\x01\
    \x02\0\x01\x12\x04\x8d\x07\x1f/\n\x10\n\x08\x04\x86\x01\x03\x01\x02\0\
    \x03\x12\x04\x8d\x0723\n\x0f\n\x07\x04\x86\x01\x03\x01\x02\x01\x12\x04\
    \x8e\x07\x105\n\x10\n\x08\x04\x86\x01\x03\x01\x02\x01\x04\x12\x04\x8e\
    \x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\x01\x02\x01\x05\x12\x04\x8e\x07\
    \x19\x1e\n\x10\n\x08\x04\x86\x01\x03\x01\x02\x01\x01\x12\x04\x8e\x07\x1f\
    0\n\x10\n\x08\x04\x86\x01\x03\x01\x02\x01\x03\x12\x04\x8e\x0734\n\x0f\n\
    \x07\x04\x86\x01\x03\x01\x02\x02\x12\x04\x8f\x07\x104\n\x10\n\x08\x04\
    \x86\x01\x03\x01\x02\x02\x04\x12\x04\x8f\x07\x10\x18\n\x10\n\x08\x04\x86\
    \x01\x03\x01\x02\x02\x05\x12\x04\x8f\x07\x19\x1e\n\x10\n\x08\x04\x86\x01\
    \x03\x01\x02\x02\x01\x12\x04\x8f\x07\x1f/\n\x10\n\x08\x04\x86\x01\x03\
    \x01\x02\x02\x03\x12\x04\x8f\x0723\n\x0f\n\x07\x04\x86\x01\x03\x01\x02\
    \x03\x12\x04\x90\x07\x10>\n\x10\n\x08\x04\x86\x01\x03\x01\x02\x03\x04\
    \x12\x04\x90\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\x01\x02\x03\x05\x12\
    \x04\x90\x07\x19\x1d\n\x10\n\x08\x04\x86\x01\x03\x01\x02\x03\x01\x12\x04\
    \x90\x07\x1e9\n\x10\n\x08\x04\x86\x01\x03\x01\x02\x03\x03\x12\x04\x90\
    \x07<=\n\x0f\n\x07\x04\x86\x01\x03\x01\x02\x04\x12\x04\x91\x07\x10?\n\
    \x10\n\x08\x04\x86\x01\x03\x01\x02\x04\x04\x12\x04\x91\x07\x10\x18\n\x10\
    \n\x08\x04\x86\x01\x03\x01\x02\x04\x05\x12\x04\x91\x07\x19\x1d\n\x10\n\
    \x08\x04\x86\x01\x03\x01\x02\x04\x01\x12\x04\x91\x07\x1e:\n\x10\n\x08\
    \x04\x86\x01\x03\x01\x02\x04\x03\x12\x04\x91\x07=>\n\x0f\n\x07\x04\x86\
    \x01\x03\x01\x02\x05\x12\x04\x92\x07\x10>\n\x10\n\x08\x04\x86\x01\x03\
    \x01\x02\x05\x04\x12\x04\x92\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\x01\
    \x02\x05\x05\x12\x04\x92\x07\x19\x1d\n\x10\n\x08\x04\x86\x01\x03\x01\x02\
    \x05\x01\x12\x04\x92\x07\x1e9\n\x10\n\x08\x04\x86\x01\x03\x01\x02\x05\
    \x03\x12\x04\x92\x07<=\n\x0f\n\x07\x04\x86\x01\x03\x01\x02\x06\x12\x04\
    \x93\x07\x10;\n\x10\n\x08\x04\x86\x01\x03\x01\x02\x06\x04\x12\x04\x93\
    \x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\x01\x02\x06\x05\x12\x04\x93\x07\
    \x19\x1d\n\x10\n\x08\x04\x86\x01\x03\x01\x02\x06\x01\x12\x04\x93\x07\x1e\
    6\n\x10\n\x08\x04\x86\x01\x03\x01\x02\x06\x03\x12\x04\x93\x079:\n\x0f\n\
    \x07\x04\x86\x01\x03\x01\x02\x07\x12\x04\x94\x07\x10>\n\x10\n\x08\x04\
    \x86\x01\x03\x01\x02\x07\x04\x12\x04\x94\x07\x10\x18\n\x10\n\x08\x04\x86\
    \x01\x03\x01\x02\x07\x05\x12\x04\x94\x07\x19\x1d\n\x10\n\x08\x04\x86\x01\
    \x03\x01\x02\x07\x01\x12\x04\x94\x07\x1e9\n\x10\n\x08\x04\x86\x01\x03\
    \x01\x02\x07\x03\x12\x04\x94\x07<=\n\x0f\n\x07\x04\x86\x01\x03\x01\x02\
    \x08\x12\x04\x95\x07\x107\n\x10\n\x08\x04\x86\x01\x03\x01\x02\x08\x04\
    \x12\x04\x95\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\x01\x02\x08\x05\x12\
    \x04\x95\x07\x19\x1d\n\x10\n\x08\x04\x86\x01\x03\x01\x02\x08\x01\x12\x04\
    \x95\x07\x1e2\n\x10\n\x08\x04\x86\x01\x03\x01\x02\x08\x03\x12\x04\x95\
    \x0756\n\x0f\n\x07\x04\x86\x01\x03\x01\x02\t\x12\x04\x96\x07\x108\n\x10\
    \n\x08\x04\x86\x01\x03\x01\x02\t\x04\x12\x04\x96\x07\x10\x18\n\x10\n\x08\
    \x04\x86\x01\x03\x01\x02\t\x05\x12\x04\x96\x07\x19\x1d\n\x10\n\x08\x04\
    \x86\x01\x03\x01\x02\t\x01\x12\x04\x96\x07\x1e2\n\x10\n\x08\x04\x86\x01\
    \x03\x01\x02\t\x03\x12\x04\x96\x0757\n\x0f\n\x07\x04\x86\x01\x03\x01\x02\
    \n\x12\x04\x97\x07\x103\n\x10\n\x08\x04\x86\x01\x03\x01\x02\n\x04\x12\
    \x04\x97\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\x01\x02\n\x05\x12\x04\
    \x97\x07\x19\x1d\n\x10\n\x08\x04\x86\x01\x03\x01\x02\n\x01\x12\x04\x97\
    \x07\x1e-\n\x10\n\x08\x04\x86\x01\x03\x01\x02\n\x03\x12\x04\x97\x0702\n\
    \x0f\n\x05\x04\x86\x01\x03\x02\x12\x06\x9a\x07\x08\xb3\x07\t\n\x0e\n\x06\
    \x04\x86\x01\x03\x02\x01\x12\x04\x9a\x07\x10\x17\n\x11\n\x07\x04\x86\x01\
    \x03\x02\x03\0\x12\x06\x9b\x07\x10\xa1\x07\x11\n\x10\n\x08\x04\x86\x01\
    \x03\x02\x03\0\x01\x12\x04\x9b\x07\x18-\n\x11\n\t\x04\x86\x01\x03\x02\
    \x03\0\x02\0\x12\x04\x9c\x07\x18<\n\x12\n\n\x04\x86\x01\x03\x02\x03\0\
    \x02\0\x04\x12\x04\x9c\x07\x18\x20\n\x12\n\n\x04\x86\x01\x03\x02\x03\0\
    \x02\0\x05\x12\x04\x9c\x07!%\n\x12\n\n\x04\x86\x01\x03\x02\x03\0\x02\0\
    \x01\x12\x04\x9c\x07&7\n\x12\n\n\x04\x86\x01\x03\x02\x03\0\x02\0\x03\x12\
    \x04\x9c\x07:;\n\x11\n\t\x04\x86\x01\x03\x02\x03\0\x02\x01\x12\x04\x9d\
    \x07\x18;\n\x12\n\n\x04\x86\x01\x03\x02\x03\0\x02\x01\x04\x12\x04\x9d\
    \x07\x18\x20\n\x12\n\n\x04\x86\x01\x03\x02\x03\0\x02\x01\x05\x12\x04\x9d\
    \x07!%\n\x12\n\n\x04\x86\x01\x03\x02\x03\0\x02\x01\x01\x12\x04\x9d\x07&6\
    \n\x12\n\n\x04\x86\x01\x03\x02\x03\0\x02\x01\x03\x12\x04\x9d\x079:\n\x11\
    \n\t\x04\x86\x01\x03\x02\x03\0\x02\x02\x12\x04\x9e\x07\x18<\n\x12\n\n\
    \x04\x86\x01\x03\x02\x03\0\x02\x02\x04\x12\x04\x9e\x07\x18\x20\n\x12\n\n\
    \x04\x86\x01\x03\x02\x03\0\x02\x02\x05\x12\x04\x9e\x07!%\n\x12\n\n\x04\
    \x86\x01\x03\x02\x03\0\x02\x02\x01\x12\x04\x9e\x07&7\n\x12\n\n\x04\x86\
    \x01\x03\x02\x03\0\x02\x02\x03\x12\x04\x9e\x07:;\n\x11\n\t\x04\x86\x01\
    \x03\x02\x03\0\x02\x03\x12\x04\x9f\x07\x18A\n\x12\n\n\x04\x86\x01\x03\
    \x02\x03\0\x02\x03\x04\x12\x04\x9f\x07\x18\x20\n\x12\n\n\x04\x86\x01\x03\
    \x02\x03\0\x02\x03\x05\x12\x04\x9f\x07!&\n\x12\n\n\x04\x86\x01\x03\x02\
    \x03\0\x02\x03\x01\x12\x04\x9f\x07'<\n\x12\n\n\x04\x86\x01\x03\x02\x03\0\
    \x02\x03\x03\x12\x04\x9f\x07?@\n\x11\n\t\x04\x86\x01\x03\x02\x03\0\x02\
    \x04\x12\x04\xa0\x07\x18@\n\x12\n\n\x04\x86\x01\x03\x02\x03\0\x02\x04\
    \x04\x12\x04\xa0\x07\x18\x20\n\x12\n\n\x04\x86\x01\x03\x02\x03\0\x02\x04\
    \x05\x12\x04\xa0\x07!&\n\x12\n\n\x04\x86\x01\x03\x02\x03\0\x02\x04\x01\
    \x12\x04\xa0\x07';\n\x12\n\n\x04\x86\x01\x03\x02\x03\0\x02\x04\x03\x12\
    \x04\xa0\x07>?\n\x0f\n\x07\x04\x86\x01\x03\x02\x02\0\x12\x04\xa3\x07\x10\
    7\n\x10\n\x08\x04\x86\x01\x03\x02\x02\0\x04\x12\x04\xa3\x07\x10\x18\n\
    \x10\n\x08\x04\x86\x01\x03\x02\x02\0\x05\x12\x04\xa3\x07\x19\x1e\n\x10\n\
    \x08\x04\x86\x01\x03\x02\x02\0\x01\x12\x04\xa3\x07\x1f2\n\x10\n\x08\x04\
    \x86\x01\x03\x02\x02\0\x03\x12\x04\xa3\x0756\n\x0f\n\x07\x04\x86\x01\x03\
    \x02\x02\x01\x12\x04\xa4\x07\x106\n\x10\n\x08\x04\x86\x01\x03\x02\x02\
    \x01\x04\x12\x04\xa4\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\x02\x02\x01\
    \x05\x12\x04\xa4\x07\x19\x1e\n\x10\n\x08\x04\x86\x01\x03\x02\x02\x01\x01\
    \x12\x04\xa4\x07\x1f1\n\x10\n\x08\x04\x86\x01\x03\x02\x02\x01\x03\x12\
    \x04\xa4\x0745\n\x0f\n\x07\x04\x86\x01\x03\x02\x02\x02\x12\x04\xa5\x07\
    \x106\n\x10\n\x08\x04\x86\x01\x03\x02\x02\x02\x04\x12\x04\xa5\x07\x10\
    \x18\n\x10\n\x08\x04\x86\x01\x03\x02\x02\x02\x05\x12\x04\xa5\x07\x19\x1d\
    \n\x10\n\x08\x04\x86\x01\x03\x02\x02\x02\x01\x12\x04\xa5\x07\x1e1\n\x10\
    \n\x08\x04\x86\x01\x03\x02\x02\x02\x03\x12\x04\xa5\x0745\n\x0f\n\x07\x04\
    \x86\x01\x03\x02\x02\x03\x12\x04\xa6\x07\x109\n\x10\n\x08\x04\x86\x01\
    \x03\x02\x02\x03\x04\x12\x04\xa6\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\
    \x02\x02\x03\x05\x12\x04\xa6\x07\x19\x1d\n\x10\n\x08\x04\x86\x01\x03\x02\
    \x02\x03\x01\x12\x04\xa6\x07\x1e4\n\x10\n\x08\x04\x86\x01\x03\x02\x02\
    \x03\x03\x12\x04\xa6\x0778\n\x0f\n\x07\x04\x86\x01\x03\x02\x02\x04\x12\
    \x04\xa7\x07\x10C\n\x10\n\x08\x04\x86\x01\x03\x02\x02\x04\x04\x12\x04\
    \xa7\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\x02\x02\x04\x05\x12\x04\xa7\
    \x07\x19\x1e\n\x10\n\x08\x04\x86\x01\x03\x02\x02\x04\x01\x12\x04\xa7\x07\
    \x1f>\n\x10\n\x08\x04\x86\x01\x03\x02\x02\x04\x03\x12\x04\xa7\x07AB\n\
    \x0f\n\x07\x04\x86\x01\x03\x02\x02\x05\x12\x04\xa8\x07\x107\n\x10\n\x08\
    \x04\x86\x01\x03\x02\x02\x05\x04\x12\x04\xa8\x07\x10\x18\n\x10\n\x08\x04\
    \x86\x01\x03\x02\x02\x05\x05\x12\x04\xa8\x07\x19\x1d\n\x10\n\x08\x04\x86\
    \x01\x03\x02\x02\x05\x01\x12\x04\xa8\x07\x1e2\n\x10\n\x08\x04\x86\x01\
    \x03\x02\x02\x05\x03\x12\x04\xa8\x0756\n\x0f\n\x07\x04\x86\x01\x03\x02\
    \x02\x06\x12\x04\xa9\x07\x106\n\x10\n\x08\x04\x86\x01\x03\x02\x02\x06\
    \x04\x12\x04\xa9\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\x02\x02\x06\x05\
    \x12\x04\xa9\x07\x19\x1e\n\x10\n\x08\x04\x86\x01\x03\x02\x02\x06\x01\x12\
    \x04\xa9\x07\x1f1\n\x10\n\x08\x04\x86\x01\x03\x02\x02\x06\x03\x12\x04\
    \xa9\x0745\n\x0f\n\x07\x04\x86\x01\x03\x02\x02\x07\x12\x04\xaa\x07\x10:\
    \n\x10\n\x08\x04\x86\x01\x03\x02\x02\x07\x04\x12\x04\xaa\x07\x10\x18\n\
    \x10\n\x08\x04\x86\x01\x03\x02\x02\x07\x05\x12\x04\xaa\x07\x19\x1e\n\x10\
    \n\x08\x04\x86\x01\x03\x02\x02\x07\x01\x12\x04\xaa\x07\x1f5\n\x10\n\x08\
    \x04\x86\x01\x03\x02\x02\x07\x03\x12\x04\xaa\x0789\n\x0f\n\x07\x04\x86\
    \x01\x03\x02\x02\x08\x12\x04\xab\x07\x10;\n\x10\n\x08\x04\x86\x01\x03\
    \x02\x02\x08\x04\x12\x04\xab\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\x02\
    \x02\x08\x05\x12\x04\xab\x07\x19\x1e\n\x10\n\x08\x04\x86\x01\x03\x02\x02\
    \x08\x01\x12\x04\xab\x07\x1f6\n\x10\n\x08\x04\x86\x01\x03\x02\x02\x08\
    \x03\x12\x04\xab\x079:\n\x0f\n\x07\x04\x86\x01\x03\x02\x02\t\x12\x04\xac\
    \x07\x106\n\x10\n\x08\x04\x86\x01\x03\x02\x02\t\x04\x12\x04\xac\x07\x10\
    \x18\n\x10\n\x08\x04\x86\x01\x03\x02\x02\t\x05\x12\x04\xac\x07\x19\x1e\n\
    \x10\n\x08\x04\x86\x01\x03\x02\x02\t\x01\x12\x04\xac\x07\x1f0\n\x10\n\
    \x08\x04\x86\x01\x03\x02\x02\t\x03\x12\x04\xac\x0735\n\x0f\n\x07\x04\x86\
    \x01\x03\x02\x02\n\x12\x04\xad\x07\x107\n\x10\n\x08\x04\x86\x01\x03\x02\
    \x02\n\x04\x12\x04\xad\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\x02\x02\n\
    \x05\x12\x04\xad\x07\x19\x1e\n\x10\n\x08\x04\x86\x01\x03\x02\x02\n\x01\
    \x12\x04\xad\x07\x1f1\n\x10\n\x08\x04\x86\x01\x03\x02\x02\n\x03\x12\x04\
    \xad\x0746\n\x10\n\x07\x04\x86\x01\x03\x02\x02\x0b\x12\x05\xae\x07\x10\
    \x82\x01\n\x10\n\x08\x04\x86\x01\x03\x02\x02\x0b\x04\x12\x04\xae\x07\x10\
    \x18\n\x10\n\x08\x04\x86\x01\x03\x02\x02\x0b\x06\x12\x04\xae\x07\x19j\n\
    \x10\n\x08\x04\x86\x01\x03\x02\x02\x0b\x01\x12\x04\xae\x07k|\n\x11\n\x08\
    \x04\x86\x01\x03\x02\x02\x0b\x03\x12\x05\xae\x07\x7f\x81\x01\n\x0f\n\x07\
    \x04\x86\x01\x03\x02\x02\x0c\x12\x04\xaf\x07\x10B\n\x10\n\x08\x04\x86\
    \x01\x03\x02\x02\x0c\x04\x12\x04\xaf\x07\x10\x18\n\x10\n\x08\x04\x86\x01\
    \x03\x02\x02\x0c\x05\x12\x04\xaf\x07\x19\x1e\n\x10\n\x08\x04\x86\x01\x03\
    \x02\x02\x0c\x01\x12\x04\xaf\x07\x1f<\n\x10\n\x08\x04\x86\x01\x03\x02\
    \x02\x0c\x03\x12\x04\xaf\x07?A\n\x0f\n\x07\x04\x86\x01\x03\x02\x02\r\x12\
    \x04\xb0\x07\x10C\n\x10\n\x08\x04\x86\x01\x03\x02\x02\r\x04\x12\x04\xb0\
    \x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\x02\x02\r\x05\x12\x04\xb0\x07\
    \x19\x1e\n\x10\n\x08\x04\x86\x01\x03\x02\x02\r\x01\x12\x04\xb0\x07\x1f=\
    \n\x10\n\x08\x04\x86\x01\x03\x02\x02\r\x03\x12\x04\xb0\x07@B\n\x0f\n\x07\
    \x04\x86\x01\x03\x02\x02\x0e\x12\x04\xb1\x07\x10<\n\x10\n\x08\x04\x86\
    \x01\x03\x02\x02\x0e\x04\x12\x04\xb1\x07\x10\x18\n\x10\n\x08\x04\x86\x01\
    \x03\x02\x02\x0e\x05\x12\x04\xb1\x07\x19\x1d\n\x10\n\x08\x04\x86\x01\x03\
    \x02\x02\x0e\x01\x12\x04\xb1\x07\x1e6\n\x10\n\x08\x04\x86\x01\x03\x02\
    \x02\x0e\x03\x12\x04\xb1\x079;\n\x0f\n\x07\x04\x86\x01\x03\x02\x02\x0f\
    \x12\x04\xb2\x07\x107\n\x10\n\x08\x04\x86\x01\x03\x02\x02\x0f\x04\x12\
    \x04\xb2\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\x02\x02\x0f\x05\x12\x04\
    \xb2\x07\x19\x1d\n\x10\n\x08\x04\x86\x01\x03\x02\x02\x0f\x01\x12\x04\xb2\
    \x07\x1e1\n\x10\n\x08\x04\x86\x01\x03\x02\x02\x0f\x03\x12\x04\xb2\x0746\
    \n\x0f\n\x05\x04\x86\x01\x03\x03\x12\x06\xb5\x07\x08\xc0\x07\t\n\x0e\n\
    \x06\x04\x86\x01\x03\x03\x01\x12\x04\xb5\x07\x10\x17\n\x0f\n\x07\x04\x86\
    \x01\x03\x03\x02\0\x12\x04\xb6\x07\x101\n\x10\n\x08\x04\x86\x01\x03\x03\
    \x02\0\x04\x12\x04\xb6\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\x03\x02\0\
    \x05\x12\x04\xb6\x07\x19\x1e\n\x10\n\x08\x04\x86\x01\x03\x03\x02\0\x01\
    \x12\x04\xb6\x07\x1f,\n\x10\n\x08\x04\x86\x01\x03\x03\x02\0\x03\x12\x04\
    \xb6\x07/0\n\x0f\n\x07\x04\x86\x01\x03\x03\x02\x01\x12\x04\xb7\x07\x10:\
    \n\x10\n\x08\x04\x86\x01\x03\x03\x02\x01\x04\x12\x04\xb7\x07\x10\x18\n\
    \x10\n\x08\x04\x86\x01\x03\x03\x02\x01\x05\x12\x04\xb7\x07\x19\x1e\n\x10\
    \n\x08\x04\x86\x01\x03\x03\x02\x01\x01\x12\x04\xb7\x07\x1f5\n\x10\n\x08\
    \x04\x86\x01\x03\x03\x02\x01\x03\x12\x04\xb7\x0789\n\x0f\n\x07\x04\x86\
    \x01\x03\x03\x02\x02\x12\x04\xb8\x07\x10=\n\x10\n\x08\x04\x86\x01\x03\
    \x03\x02\x02\x04\x12\x04\xb8\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\x03\
    \x02\x02\x05\x12\x04\xb8\x07\x19\x1e\n\x10\n\x08\x04\x86\x01\x03\x03\x02\
    \x02\x01\x12\x04\xb8\x07\x1f8\n\x10\n\x08\x04\x86\x01\x03\x03\x02\x02\
    \x03\x12\x04\xb8\x07;<\n\x0f\n\x07\x04\x86\x01\x03\x03\x02\x03\x12\x04\
    \xb9\x07\x108\n\x10\n\x08\x04\x86\x01\x03\x03\x02\x03\x04\x12\x04\xb9\
    \x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\x03\x02\x03\x05\x12\x04\xb9\x07\
    \x19\x1e\n\x10\n\x08\x04\x86\x01\x03\x03\x02\x03\x01\x12\x04\xb9\x07\x1f\
    3\n\x10\n\x08\x04\x86\x01\x03\x03\x02\x03\x03\x12\x04\xb9\x0767\n\x0f\n\
    \x07\x04\x86\x01\x03\x03\x02\x04\x12\x04\xba\x07\x109\n\x10\n\x08\x04\
    \x86\x01\x03\x03\x02\x04\x04\x12\x04\xba\x07\x10\x18\n\x10\n\x08\x04\x86\
    \x01\x03\x03\x02\x04\x05\x12\x04\xba\x07\x19\x1e\n\x10\n\x08\x04\x86\x01\
    \x03\x03\x02\x04\x01\x12\x04\xba\x07\x1f4\n\x10\n\x08\x04\x86\x01\x03\
    \x03\x02\x04\x03\x12\x04\xba\x0778\n\x0f\n\x07\x04\x86\x01\x03\x03\x02\
    \x05\x12\x04\xbb\x07\x10C\n\x10\n\x08\x04\x86\x01\x03\x03\x02\x05\x04\
    \x12\x04\xbb\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\x03\x02\x05\x05\x12\
    \x04\xbb\x07\x19\x1e\n\x10\n\x08\x04\x86\x01\x03\x03\x02\x05\x01\x12\x04\
    \xbb\x07\x1f>\n\x10\n\x08\x04\x86\x01\x03\x03\x02\x05\x03\x12\x04\xbb\
    \x07AB\n\x0f\n\x07\x04\x86\x01\x03\x03\x02\x06\x12\x04\xbc\x07\x104\n\
    \x10\n\x08\x04\x86\x01\x03\x03\x02\x06\x04\x12\x04\xbc\x07\x10\x18\n\x10\
    \n\x08\x04\x86\x01\x03\x03\x02\x06\x05\x12\x04\xbc\x07\x19\x1e\n\x10\n\
    \x08\x04\x86\x01\x03\x03\x02\x06\x01\x12\x04\xbc\x07\x1f/\n\x10\n\x08\
    \x04\x86\x01\x03\x03\x02\x06\x03\x12\x04\xbc\x0723\n\x0f\n\x07\x04\x86\
    \x01\x03\x03\x02\x07\x12\x04\xbd\x07\x10:\n\x10\n\x08\x04\x86\x01\x03\
    \x03\x02\x07\x04\x12\x04\xbd\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\x03\
    \x02\x07\x05\x12\x04\xbd\x07\x19\x1e\n\x10\n\x08\x04\x86\x01\x03\x03\x02\
    \x07\x01\x12\x04\xbd\x07\x1f5\n\x10\n\x08\x04\x86\x01\x03\x03\x02\x07\
    \x03\x12\x04\xbd\x0789\n\x0f\n\x07\x04\x86\x01\x03\x03\x02\x08\x12\x04\
    \xbe\x07\x104\n\x10\n\x08\x04\x86\x01\x03\x03\x02\x08\x04\x12\x04\xbe\
    \x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\x03\x02\x08\x05\x12\x04\xbe\x07\
    \x19\x1e\n\x10\n\x08\x04\x86\x01\x03\x03\x02\x08\x01\x12\x04\xbe\x07\x1f\
    /\n\x10\n\x08\x04\x86\x01\x03\x03\x02\x08\x03\x12\x04\xbe\x0723\n\x0f\n\
    \x07\x04\x86\x01\x03\x03\x02\t\x12\x04\xbf\x07\x10>\n\x10\n\x08\x04\x86\
    \x01\x03\x03\x02\t\x04\x12\x04\xbf\x07\x10\x18\n\x10\n\x08\x04\x86\x01\
    \x03\x03\x02\t\x05\x12\x04\xbf\x07\x19\x1e\n\x10\n\x08\x04\x86\x01\x03\
    \x03\x02\t\x01\x12\x04\xbf\x07\x1f8\n\x10\n\x08\x04\x86\x01\x03\x03\x02\
    \t\x03\x12\x04\xbf\x07;=\n\r\n\x05\x04\x86\x01\x02\0\x12\x04\xc2\x07\x08\
    +\n\x0e\n\x06\x04\x86\x01\x02\0\x04\x12\x04\xc2\x07\x08\x10\n\x0e\n\x06\
    \x04\x86\x01\x02\0\x05\x12\x04\xc2\x07\x11\x17\n\x0e\n\x06\x04\x86\x01\
    \x02\0\x01\x12\x04\xc2\x07\x18&\n\x0e\n\x06\x04\x86\x01\x02\0\x03\x12\
    \x04\xc2\x07)*\n\r\n\x05\x04\x86\x01\x02\x01\x12\x04\xc3\x07\x08)\n\x0e\
    \n\x06\x04\x86\x01\x02\x01\x04\x12\x04\xc3\x07\x08\x10\n\x0e\n\x06\x04\
    \x86\x01\x02\x01\x05\x12\x04\xc3\x07\x11\x17\n\x0e\n\x06\x04\x86\x01\x02\
    \x01\x01\x12\x04\xc3\x07\x18$\n\x0e\n\x06\x04\x86\x01\x02\x01\x03\x12\
    \x04\xc3\x07'(\n\r\n\x05\x04\x86\x01\x02\x02\x12\x04\xc4\x07\x08,\n\x0e\
    \n\x06\x04\x86\x01\x02\x02\x04\x12\x04\xc4\x07\x08\x10\n\x0e\n\x06\x04\
    \x86\x01\x02\x02\x05\x12\x04\xc4\x07\x11\x17\n\x0e\n\x06\x04\x86\x01\x02\
    \x02\x01\x12\x04\xc4\x07\x18'\n\x0e\n\x06\x04\x86\x01\x02\x02\x03\x12\
    \x04\xc4\x07*+\n\r\n\x05\x04\x86\x01\x02\x03\x12\x04\xc5\x07\x08!\n\x0e\
    \n\x06\x04\x86\x01\x02\x03\x04\x12\x04\xc5\x07\x08\x10\n\x0e\n\x06\x04\
    \x86\x01\x02\x03\x05\x12\x04\xc5\x07\x11\x15\n\x0e\n\x06\x04\x86\x01\x02\
    \x03\x01\x12\x04\xc5\x07\x16\x1c\n\x0e\n\x06\x04\x86\x01\x02\x03\x03\x12\
    \x04\xc5\x07\x1f\x20\n\r\n\x05\x04\x86\x01\x02\x04\x12\x04\xc6\x07\x08\\\
    \n\x0e\n\x06\x04\x86\x01\x02\x04\x04\x12\x04\xc6\x07\x08\x10\n\x0e\n\x06\
    \x04\x86\x01\x02\x04\x06\x12\x04\xc6\x07\x11M\n\x0e\n\x06\x04\x86\x01\
    \x02\x04\x01\x12\x04\xc6\x07NV\n\x0e\n\x06\x04\x86\x01\x02\x04\x03\x12\
    \x04\xc6\x07Y[\n\r\n\x05\x04\x86\x01\x02\x05\x12\x04\xc7\x07\x08g\n\x0e\
    \n\x06\x04\x86\x01\x02\x05\x04\x12\x04\xc7\x07\x08\x10\n\x0e\n\x06\x04\
    \x86\x01\x02\x05\x06\x12\x04\xc7\x07\x11R\n\x0e\n\x06\x04\x86\x01\x02\
    \x05\x01\x12\x04\xc7\x07Sa\n\x0e\n\x06\x04\x86\x01\x02\x05\x03\x12\x04\
    \xc7\x07df\n\r\n\x05\x04\x86\x01\x02\x06\x12\x04\xc8\x07\x08[\n\x0e\n\
    \x06\x04\x86\x01\x02\x06\x04\x12\x04\xc8\x07\x08\x10\n\x0e\n\x06\x04\x86\
    \x01\x02\x06\x06\x12\x04\xc8\x07\x11L\n\x0e\n\x06\x04\x86\x01\x02\x06\
    \x01\x12\x04\xc8\x07MU\n\x0e\n\x06\x04\x86\x01\x02\x06\x03\x12\x04\xc8\
    \x07XZ\n\r\n\x05\x04\x86\x01\x02\x07\x12\x04\xc9\x07\x08Z\n\x0e\n\x06\
    \x04\x86\x01\x02\x07\x04\x12\x04\xc9\x07\x08\x10\n\x0e\n\x06\x04\x86\x01\
    \x02\x07\x06\x12\x04\xc9\x07\x11L\n\x0e\n\x06\x04\x86\x01\x02\x07\x01\
    \x12\x04\xc9\x07MT\n\x0e\n\x06\x04\x86\x01\x02\x07\x03\x12\x04\xc9\x07WY\
    \n\r\n\x03\x04\x87\x01\x12\x06\xcc\x07\0\xce\x07\x01\n\x0c\n\x04\x04\x87\
    \x01\x01\x12\x04\xcc\x07\x08A\n\r\n\x05\x04\x87\x01\x02\0\x12\x04\xcd\
    \x07\x08+\n\x0e\n\x06\x04\x87\x01\x02\0\x04\x12\x04\xcd\x07\x08\x10\n\
    \x0e\n\x06\x04\x87\x01\x02\0\x05\x12\x04\xcd\x07\x11\x17\n\x0e\n\x06\x04\
    \x87\x01\x02\0\x01\x12\x04\xcd\x07\x18&\n\x0e\n\x06\x04\x87\x01\x02\0\
    \x03\x12\x04\xcd\x07)*\n\x0c\n\x02\x06\0\x12\x06\xd0\x07\0\xd6\x07\x01\n\
    \x0b\n\x03\x06\0\x01\x12\x04\xd0\x07\x08\x0c\n\x0b\n\x03\x06\0\x03\x12\
    \x04\xd1\x07\x08?\n\x0e\n\x06\x06\0\x03\xd0\x86\x03\x12\x04\xd1\x07\x08?\
    \n\x0e\n\x04\x06\0\x02\0\x12\x06\xd3\x07\x08\xd5\x07\t\n\r\n\x05\x06\0\
    \x02\0\x01\x12\x04\xd3\x07\x0c&\n\r\n\x05\x06\0\x02\0\x02\x12\x04\xd3\
    \x07(Q\n\x0e\n\x05\x06\0\x02\0\x03\x12\x05\xd3\x07\\\x86\x01\n\x0e\n\x05\
    \x06\0\x02\0\x04\x12\x05\xd4\x07\x10\x9f\x01\n\x11\n\x08\x06\0\x02\0\x04\
    \xd0\x86\x03\x12\x05\xd4\x07\x10\x9f\x01\n\x0c\n\x02\x06\x01\x12\x06\xd8\
    \x07\0\xae\t\x01\n\x0b\n\x03\x06\x01\x01\x12\x04\xd8\x07\x08\x10\n\x0b\n\
    \x03\x06\x01\x03\x12\x04\xd9\x07\x08h\n\x0e\n\x06\x06\x01\x03\xd0\x86\
    \x03\x12\x04\xd9\x07\x08h\n\x0e\n\x04\x06\x01\x02\0\x12\x06\xdb\x07\x08\
    \xdd\x07\t\n\r\n\x05\x06\x01\x02\0\x01\x12\x04\xdb\x07\x0c\x1f\n\r\n\x05\
    \x06\x01\x02\0\x02\x12\x04\xdb\x07!G\n\r\n\x05\x06\x01\x02\0\x03\x12\x04\
    \xdb\x07Ry\n\r\n\x05\x06\x01\x02\0\x04\x12\x04\xdc\x07\x10h\n\x10\n\x08\
    \x06\x01\x02\0\x04\xd0\x86\x03\x12\x04\xdc\x07\x10h\n\x0e\n\x04\x06\x01\
    \x02\x01\x12\x06\xdf\x07\x08\xe1\x07\t\n\r\n\x05\x06\x01\x02\x01\x01\x12\
    \x04\xdf\x07\x0c\x1d\n\r\n\x05\x06\x01\x02\x01\x02\x12\x04\xdf\x07\x1fC\
    \n\r\n\x05\x06\x01\x02\x01\x03\x12\x04\xdf\x07Ns\n\r\n\x05\x06\x01\x02\
    \x01\x04\x12\x04\xe0\x07\x10E\n\x10\n\x08\x06\x01\x02\x01\x04\xd0\x86\
    \x03\x12\x04\xe0\x07\x10E\n\x0e\n\x04\x06\x01\x02\x02\x12\x06\xe3\x07\
    \x08\xe5\x07\t\n\r\n\x05\x06\x01\x02\x02\x01\x12\x04\xe3\x07\x0c\x1f\n\r\
    \n\x05\x06\x01\x02\x02\x02\x12\x04\xe3\x07!G\n\r\n\x05\x06\x01\x02\x02\
    \x03\x12\x04\xe3\x07Ry\n\r\n\x05\x06\x01\x02\x02\x04\x12\x04\xe4\x07\x10\
    I\n\x10\n\x08\x06\x01\x02\x02\x04\xd0\x86\x03\x12\x04\xe4\x07\x10I\n\x0e\
    \n\x04\x06\x01\x02\x03\x12\x06\xe7\x07\x08\xe9\x07\t\n\r\n\x05\x06\x01\
    \x02\x03\x01\x12\x04\xe7\x07\x0c#\n\r\n\x05\x06\x01\x02\x03\x02\x12\x04\
    \xe7\x07%O\n\x0e\n\x05\x06\x01\x02\x03\x03\x12\x05\xe7\x07Z\x85\x01\n\r\
    \n\x05\x06\x01\x02\x03\x04\x12\x04\xe8\x07\x10R\n\x10\n\x08\x06\x01\x02\
    \x03\x04\xd0\x86\x03\x12\x04\xe8\x07\x10R\n\x0e\n\x04\x06\x01\x02\x04\
    \x12\x06\xeb\x07\x08\xed\x07\t\n\r\n\x05\x06\x01\x02\x04\x01\x12\x04\xeb\
    \x07\x0c\"\n\r\n\x05\x06\x01\x02\x04\x02\x12\x04\xeb\x07$M\n\x0e\n\x05\
    \x06\x01\x02\x04\x03\x12\x05\xeb\x07X\x82\x01\n\r\n\x05\x06\x01\x02\x04\
    \x04\x12\x04\xec\x07\x10U\n\x10\n\x08\x06\x01\x02\x04\x04\xd0\x86\x03\
    \x12\x04\xec\x07\x10U\n\x0e\n\x04\x06\x01\x02\x05\x12\x06\xef\x07\x08\
    \xf1\x07\t\n\r\n\x05\x06\x01\x02\x05\x01\x12\x04\xef\x07\x0c-\n\r\n\x05\
    \x06\x01\x02\x05\x02\x12\x04\xef\x07/c\n\x0e\n\x05\x06\x01\x02\x05\x03\
    \x12\x05\xef\x07n\xa3\x01\n\r\n\x05\x06\x01\x02\x05\x04\x12\x04\xf0\x07\
    \x10f\n\x10\n\x08\x06\x01\x02\x05\x04\xd0\x86\x03\x12\x04\xf0\x07\x10f\n\
    \x0e\n\x04\x06\x01\x02\x06\x12\x06\xf3\x07\x08\xf5\x07\t\n\r\n\x05\x06\
    \x01\x02\x06\x01\x12\x04\xf3\x07\x0c(\n\r\n\x05\x06\x01\x02\x06\x02\x12\
    \x04\xf3\x07*Y\n\x0e\n\x05\x06\x01\x02\x06\x03\x12\x05\xf3\x07d\x94\x01\
    \n\x0e\n\x05\x06\x01\x02\x06\x04\x12\x05\xf4\x07\x10\x8d\x01\n\x11\n\x08\
    \x06\x01\x02\x06\x04\xd0\x86\x03\x12\x05\xf4\x07\x10\x8d\x01\n\x0e\n\x04\
    \x06\x01\x02\x07\x12\x06\xf7\x07\x08\xf9\x07\t\n\r\n\x05\x06\x01\x02\x07\
    \x01\x12\x04\xf7\x07\x0c'\n\r\n\x05\x06\x01\x02\x07\x02\x12\x04\xf7\x07)\
    W\n\x0e\n\x05\x06\x01\x02\x07\x03\x12\x05\xf7\x07b\x91\x01\n\r\n\x05\x06\
    \x01\x02\x07\x04\x12\x04\xf8\x07\x10Y\n\x10\n\x08\x06\x01\x02\x07\x04\
    \xd0\x86\x03\x12\x04\xf8\x07\x10Y\n\x0e\n\x04\x06\x01\x02\x08\x12\x06\
    \xfb\x07\x08\xfd\x07\t\n\r\n\x05\x06\x01\x02\x08\x01\x12\x04\xfb\x07\x0c\
    \x1b\n\r\n\x05\x06\x01\x02\x08\x02\x12\x04\xfb\x07\x1d8\n\r\n\x05\x06\
    \x01\x02\x08\x03\x12\x04\xfb\x07C_\n\r\n\x05\x06\x01\x02\x08\x04\x12\x04\
    \xfc\x07\x10C\n\x10\n\x08\x06\x01\x02\x08\x04\xd0\x86\x03\x12\x04\xfc\
    \x07\x10C\n\x0e\n\x04\x06\x01\x02\t\x12\x06\xff\x07\x08\x81\x08\t\n\r\n\
    \x05\x06\x01\x02\t\x01\x12\x04\xff\x07\x0c\x1d\n\r\n\x05\x06\x01\x02\t\
    \x02\x12\x04\xff\x07\x1f:\n\r\n\x05\x06\x01\x02\t\x03\x12\x04\xff\x07Ea\
    \n\r\n\x05\x06\x01\x02\t\x04\x12\x04\x80\x08\x10E\n\x10\n\x08\x06\x01\
    \x02\t\x04\xd0\x86\x03\x12\x04\x80\x08\x10E\n\x0e\n\x04\x06\x01\x02\n\
    \x12\x06\x83\x08\x08\x85\x08\t\n\r\n\x05\x06\x01\x02\n\x01\x12\x04\x83\
    \x08\x0c\x1b\n\r\n\x05\x06\x01\x02\n\x02\x12\x04\x83\x08\x1d?\n\r\n\x05\
    \x06\x01\x02\n\x03\x12\x04\x83\x08Jm\n\r\n\x05\x06\x01\x02\n\x04\x12\x04\
    \x84\x08\x10J\n\x10\n\x08\x06\x01\x02\n\x04\xd0\x86\x03\x12\x04\x84\x08\
    \x10J\n\x0e\n\x04\x06\x01\x02\x0b\x12\x06\x87\x08\x08\x89\x08\t\n\r\n\
    \x05\x06\x01\x02\x0b\x01\x12\x04\x87\x08\x0c\x1f\n\r\n\x05\x06\x01\x02\
    \x0b\x02\x12\x04\x87\x08!@\n\r\n\x05\x06\x01\x02\x0b\x03\x12\x04\x87\x08\
    Kk\n\r\n\x05\x06\x01\x02\x0b\x04\x12\x04\x88\x08\x10U\n\x10\n\x08\x06\
    \x01\x02\x0b\x04\xd0\x86\x03\x12\x04\x88\x08\x10U\n\x0e\n\x04\x06\x01\
    \x02\x0c\x12\x06\x8b\x08\x08\x8d\x08\t\n\r\n\x05\x06\x01\x02\x0c\x01\x12\
    \x04\x8b\x08\x0c\x16\n\r\n\x05\x06\x01\x02\x0c\x02\x12\x04\x8b\x08\x185\
    \n\r\n\x05\x06\x01\x02\x0c\x03\x12\x04\x8b\x08@^\n\r\n\x05\x06\x01\x02\
    \x0c\x04\x12\x04\x8c\x08\x10E\n\x10\n\x08\x06\x01\x02\x0c\x04\xd0\x86\
    \x03\x12\x04\x8c\x08\x10E\n\x0e\n\x04\x06\x01\x02\r\x12\x06\x8f\x08\x08\
    \x91\x08\t\n\r\n\x05\x06\x01\x02\r\x01\x12\x04\x8f\x08\x0c\x14\n\r\n\x05\
    \x06\x01\x02\r\x02\x12\x04\x8f\x08\x161\n\r\n\x05\x06\x01\x02\r\x03\x12\
    \x04\x8f\x08<X\n\r\n\x05\x06\x01\x02\r\x04\x12\x04\x90\x08\x10G\n\x10\n\
    \x08\x06\x01\x02\r\x04\xd0\x86\x03\x12\x04\x90\x08\x10G\n\x0e\n\x04\x06\
    \x01\x02\x0e\x12\x06\x93\x08\x08\x95\x08\t\n\r\n\x05\x06\x01\x02\x0e\x01\
    \x12\x04\x93\x08\x0c\x16\n\r\n\x05\x06\x01\x02\x0e\x02\x12\x04\x93\x08\
    \x185\n\r\n\x05\x06\x01\x02\x0e\x03\x12\x04\x93\x08@^\n\r\n\x05\x06\x01\
    \x02\x0e\x04\x12\x04\x94\x08\x10E\n\x10\n\x08\x06\x01\x02\x0e\x04\xd0\
    \x86\x03\x12\x04\x94\x08\x10E\n\x0e\n\x04\x06\x01\x02\x0f\x12\x06\x97\
    \x08\x08\x99\x08\t\n\r\n\x05\x06\x01\x02\x0f\x01\x12\x04\x97\x08\x0c\x17\
    \n\r\n\x05\x06\x01\x02\x0f\x02\x12\x04\x97\x08\x197\n\r\n\x05\x06\x01\
    \x02\x0f\x03\x12\x04\x97\x08Ba\n\r\n\x05\x06\x01\x02\x0f\x04\x12\x04\x98\
    \x08\x10I\n\x10\n\x08\x06\x01\x02\x0f\x04\xd0\x86\x03\x12\x04\x98\x08\
    \x10I\n\x0e\n\x04\x06\x01\x02\x10\x12\x06\x9b\x08\x08\x9d\x08\t\n\r\n\
    \x05\x06\x01\x02\x10\x01\x12\x04\x9b\x08\x0c\x16\n\r\n\x05\x06\x01\x02\
    \x10\x02\x12\x04\x9b\x08\x185\n\r\n\x05\x06\x01\x02\x10\x03\x12\x04\x9b\
    \x08@^\n\r\n\x05\x06\x01\x02\x10\x04\x12\x04\x9c\x08\x10G\n\x10\n\x08\
    \x06\x01\x02\x10\x04\xd0\x86\x03\x12\x04\x9c\x08\x10G\n\x0e\n\x04\x06\
    \x01\x02\x11\x12\x06\x9f\x08\x08\xa1\x08\t\n\r\n\x05\x06\x01\x02\x11\x01\
    \x12\x04\x9f\x08\x0c\x1a\n\r\n\x05\x06\x01\x02\x11\x02\x12\x04\x9f\x08\
    \x1c=\n\r\n\x05\x06\x01\x02\x11\x03\x12\x04\x9f\x08Hj\n\r\n\x05\x06\x01\
    \x02\x11\x04\x12\x04\xa0\x08\x10[\n\x10\n\x08\x06\x01\x02\x11\x04\xd0\
    \x86\x03\x12\x04\xa0\x08\x10[\n\x0e\n\x04\x06\x01\x02\x12\x12\x06\xa3\
    \x08\x08\xa5\x08\t\n\r\n\x05\x06\x01\x02\x12\x01\x12\x04\xa3\x08\x0c\x1e\
    \n\r\n\x05\x06\x01\x02\x12\x02\x12\x04\xa3\x08\x20E\n\r\n\x05\x06\x01\
    \x02\x12\x03\x12\x04\xa3\x08Pv\n\r\n\x05\x06\x01\x02\x12\x04\x12\x04\xa4\
    \x08\x10N\n\x10\n\x08\x06\x01\x02\x12\x04\xd0\x86\x03\x12\x04\xa4\x08\
    \x10N\n\x0e\n\x04\x06\x01\x02\x13\x12\x06\xa7\x08\x08\xa9\x08\t\n\r\n\
    \x05\x06\x01\x02\x13\x01\x12\x04\xa7\x08\x0c\x19\n\r\n\x05\x06\x01\x02\
    \x13\x02\x12\x04\xa7\x08\x1b;\n\r\n\x05\x06\x01\x02\x13\x03\x12\x04\xa7\
    \x08Fg\n\r\n\x05\x06\x01\x02\x13\x04\x12\x04\xa8\x08\x10J\n\x10\n\x08\
    \x06\x01\x02\x13\x04\xd0\x86\x03\x12\x04\xa8\x08\x10J\n\x0e\n\x04\x06\
    \x01\x02\x14\x12\x06\xab\x08\x08\xad\x08\t\n\r\n\x05\x06\x01\x02\x14\x01\
    \x12\x04\xab\x08\x0c\x1b\n\r\n\x05\x06\x01\x02\x14\x02\x12\x04\xab\x08\
    \x1d?\n\r\n\x05\x06\x01\x02\x14\x03\x12\x04\xab\x08Jm\n\r\n\x05\x06\x01\
    \x02\x14\x04\x12\x04\xac\x08\x10X\n\x10\n\x08\x06\x01\x02\x14\x04\xd0\
    \x86\x03\x12\x04\xac\x08\x10X\n\x0e\n\x04\x06\x01\x02\x15\x12\x06\xaf\
    \x08\x08\xb1\x08\t\n\r\n\x05\x06\x01\x02\x15\x01\x12\x04\xaf\x08\x0c\x1e\
    \n\r\n\x05\x06\x01\x02\x15\x02\x12\x04\xaf\x08\x20E\n\r\n\x05\x06\x01\
    \x02\x15\x03\x12\x04\xaf\x08Pv\n\r\n\x05\x06\x01\x02\x15\x04\x12\x04\xb0\
    \x08\x10O\n\x10\n\x08\x06\x01\x02\x15\x04\xd0\x86\x03\x12\x04\xb0\x08\
    \x10O\n\x0e\n\x04\x06\x01\x02\x16\x12\x06\xb3\x08\x08\xb5\x08\t\n\r\n\
    \x05\x06\x01\x02\x16\x01\x12\x04\xb3\x08\x0c\x1d\n\r\n\x05\x06\x01\x02\
    \x16\x02\x12\x04\xb3\x08\x1fC\n\r\n\x05\x06\x01\x02\x16\x03\x12\x04\xb3\
    \x08Ns\n\r\n\x05\x06\x01\x02\x16\x04\x12\x04\xb4\x08\x10L\n\x10\n\x08\
    \x06\x01\x02\x16\x04\xd0\x86\x03\x12\x04\xb4\x08\x10L\n\x0e\n\x04\x06\
    \x01\x02\x17\x12\x06\xb7\x08\x08\xb9\x08\t\n\r\n\x05\x06\x01\x02\x17\x01\
    \x12\x04\xb7\x08\x0c'\n\r\n\x05\x06\x01\x02\x17\x02\x12\x04\xb7\x08)W\n\
    \x0e\n\x05\x06\x01\x02\x17\x03\x12\x05\xb7\x08b\x91\x01\n\r\n\x05\x06\
    \x01\x02\x17\x04\x12\x04\xb8\x08\x10Z\n\x10\n\x08\x06\x01\x02\x17\x04\
    \xd0\x86\x03\x12\x04\xb8\x08\x10Z\n\x0e\n\x04\x06\x01\x02\x18\x12\x06\
    \xbb\x08\x08\xbd\x08\t\n\r\n\x05\x06\x01\x02\x18\x01\x12\x04\xbb\x08\x0c\
    \x1e\n\r\n\x05\x06\x01\x02\x18\x02\x12\x04\xbb\x08\x20E\n\r\n\x05\x06\
    \x01\x02\x18\x03\x12\x04\xbb\x08Pv\n\r\n\x05\x06\x01\x02\x18\x04\x12\x04\
    \xbc\x08\x10_\n\x10\n\x08\x06\x01\x02\x18\x04\xd0\x86\x03\x12\x04\xbc\
    \x08\x10_\n\x0e\n\x04\x06\x01\x02\x19\x12\x06\xbf\x08\x08\xc1\x08\t\n\r\
    \n\x05\x06\x01\x02\x19\x01\x12\x04\xbf\x08\x0c\x1a\n\r\n\x05\x06\x01\x02\
    \x19\x02\x12\x04\xbf\x08\x1c=\n\r\n\x05\x06\x01\x02\x19\x03\x12\x04\xbf\
    \x08Hj\n\r\n\x05\x06\x01\x02\x19\x04\x12\x04\xc0\x08\x10]\n\x10\n\x08\
    \x06\x01\x02\x19\x04\xd0\x86\x03\x12\x04\xc0\x08\x10]\n\x0e\n\x04\x06\
    \x01\x02\x1a\x12\x06\xc3\x08\x08\xc5\x08\t\n\r\n\x05\x06\x01\x02\x1a\x01\
    \x12\x04\xc3\x08\x0c\x1a\n\r\n\x05\x06\x01\x02\x1a\x02\x12\x04\xc3\x08\
    \x1c=\n\r\n\x05\x06\x01\x02\x1a\x03\x12\x04\xc3\x08Hj\n\r\n\x05\x06\x01\
    \x02\x1a\x04\x12\x04\xc4\x08\x10]\n\x10\n\x08\x06\x01\x02\x1a\x04\xd0\
    \x86\x03\x12\x04\xc4\x08\x10]\n\x0e\n\x04\x06\x01\x02\x1b\x12\x06\xc7\
    \x08\x08\xc9\x08\t\n\r\n\x05\x06\x01\x02\x1b\x01\x12\x04\xc7\x08\x0c\x1a\
    \n\r\n\x05\x06\x01\x02\x1b\x02\x12\x04\xc7\x08\x1c=\n\r\n\x05\x06\x01\
    \x02\x1b\x03\x12\x04\xc7\x08Hj\n\r\n\x05\x06\x01\x02\x1b\x04\x12\x04\xc8\
    \x08\x10]\n\x10\n\x08\x06\x01\x02\x1b\x04\xd0\x86\x03\x12\x04\xc8\x08\
    \x10]\n\x0e\n\x04\x06\x01\x02\x1c\x12\x06\xcb\x08\x08\xcd\x08\t\n\r\n\
    \x05\x06\x01\x02\x1c\x01\x12\x04\xcb\x08\x0c\x1b\n\r\n\x05\x06\x01\x02\
    \x1c\x02\x12\x04\xcb\x08\x1d?\n\r\n\x05\x06\x01\x02\x1c\x03\x12\x04\xcb\
    \x08Jm\n\r\n\x05\x06\x01\x02\x1c\x04\x12\x04\xcc\x08\x10^\n\x10\n\x08\
    \x06\x01\x02\x1c\x04\xd0\x86\x03\x12\x04\xcc\x08\x10^\n\x0e\n\x04\x06\
    \x01\x02\x1d\x12\x06\xcf\x08\x08\xd1\x08\t\n\r\n\x05\x06\x01\x02\x1d\x01\
    \x12\x04\xcf\x08\x0c\x1b\n\r\n\x05\x06\x01\x02\x1d\x02\x12\x04\xcf\x08\
    \x1d?\n\r\n\x05\x06\x01\x02\x1d\x03\x12\x04\xcf\x08Jm\n\r\n\x05\x06\x01\
    \x02\x1d\x04\x12\x04\xd0\x08\x10^\n\x10\n\x08\x06\x01\x02\x1d\x04\xd0\
    \x86\x03\x12\x04\xd0\x08\x10^\n\x0e\n\x04\x06\x01\x02\x1e\x12\x06\xd3\
    \x08\x08\xd5\x08\t\n\r\n\x05\x06\x01\x02\x1e\x01\x12\x04\xd3\x08\x0c\x19\
    \n\r\n\x05\x06\x01\x02\x1e\x02\x12\x04\xd3\x08\x1b;\n\r\n\x05\x06\x01\
    \x02\x1e\x03\x12\x04\xd3\x08Fg\n\r\n\x05\x06\x01\x02\x1e\x04\x12\x04\xd4\
    \x08\x10~\n\x10\n\x08\x06\x01\x02\x1e\x04\xd0\x86\x03\x12\x04\xd4\x08\
    \x10~\n\x0e\n\x04\x06\x01\x02\x1f\x12\x06\xd7\x08\x08\xd9\x08\t\n\r\n\
    \x05\x06\x01\x02\x1f\x01\x12\x04\xd7\x08\x0c\x1a\n\r\n\x05\x06\x01\x02\
    \x1f\x02\x12\x04\xd7\x08\x1c=\n\r\n\x05\x06\x01\x02\x1f\x03\x12\x04\xd7\
    \x08Hj\n\r\n\x05\x06\x01\x02\x1f\x04\x12\x04\xd8\x08\x10Z\n\x10\n\x08\
    \x06\x01\x02\x1f\x04\xd0\x86\x03\x12\x04\xd8\x08\x10Z\n\x0e\n\x04\x06\
    \x01\x02\x20\x12\x06\xdb\x08\x08\xdd\x08\t\n\r\n\x05\x06\x01\x02\x20\x01\
    \x12\x04\xdb\x08\x0c\x1d\n\r\n\x05\x06\x01\x02\x20\x02\x12\x04\xdb\x08\
    \x1fC\n\r\n\x05\x06\x01\x02\x20\x03\x12\x04\xdb\x08Ns\n\x0e\n\x05\x06\
    \x01\x02\x20\x04\x12\x05\xdc\x08\x10\x8e\x01\n\x11\n\x08\x06\x01\x02\x20\
    \x04\xd0\x86\x03\x12\x05\xdc\x08\x10\x8e\x01\n\x0e\n\x04\x06\x01\x02!\
    \x12\x06\xdf\x08\x08\xe1\x08\t\n\r\n\x05\x06\x01\x02!\x01\x12\x04\xdf\
    \x08\x0c\x1f\n\r\n\x05\x06\x01\x02!\x02\x12\x04\xdf\x08!G\n\r\n\x05\x06\
    \x01\x02!\x03\x12\x04\xdf\x08Ry\n\r\n\x05\x06\x01\x02!\x04\x12\x04\xe0\
    \x08\x10M\n\x10\n\x08\x06\x01\x02!\x04\xd0\x86\x03\x12\x04\xe0\x08\x10M\
    \n\x0e\n\x04\x06\x01\x02\"\x12\x06\xe3\x08\x08\xe5\x08\t\n\r\n\x05\x06\
    \x01\x02\"\x01\x12\x04\xe3\x08\x0c!\n\r\n\x05\x06\x01\x02\"\x02\x12\x04\
    \xe3\x08#K\n\r\n\x05\x06\x01\x02\"\x03\x12\x04\xe3\x08V\x7f\n\r\n\x05\
    \x06\x01\x02\"\x04\x12\x04\xe4\x08\x10Y\n\x10\n\x08\x06\x01\x02\"\x04\
    \xd0\x86\x03\x12\x04\xe4\x08\x10Y\n\x0e\n\x04\x06\x01\x02#\x12\x06\xe7\
    \x08\x08\xe9\x08\t\n\r\n\x05\x06\x01\x02#\x01\x12\x04\xe7\x08\x0c#\n\r\n\
    \x05\x06\x01\x02#\x02\x12\x04\xe7\x08%O\n\x0e\n\x05\x06\x01\x02#\x03\x12\
    \x05\xe7\x08Z\x85\x01\n\r\n\x05\x06\x01\x02#\x04\x12\x04\xe8\x08\x10^\n\
    \x10\n\x08\x06\x01\x02#\x04\xd0\x86\x03\x12\x04\xe8\x08\x10^\n\x0e\n\x04\
    \x06\x01\x02$\x12\x06\xeb\x08\x08\xed\x08\t\n\r\n\x05\x06\x01\x02$\x01\
    \x12\x04\xeb\x08\x0c*\n\r\n\x05\x06\x01\x02$\x02\x12\x04\xeb\x08,]\n\x0e\
    \n\x05\x06\x01\x02$\x03\x12\x05\xeb\x08h\x9a\x01\n\r\n\x05\x06\x01\x02$\
    \x04\x12\x04\xec\x08\x10w\n\x10\n\x08\x06\x01\x02$\x04\xd0\x86\x03\x12\
    \x04\xec\x08\x10w\n\x0e\n\x04\x06\x01\x02%\x12\x06\xef\x08\x08\xf1\x08\t\
    \n\r\n\x05\x06\x01\x02%\x01\x12\x04\xef\x08\x0c.\n\r\n\x05\x06\x01\x02%\
    \x02\x12\x04\xef\x080j\n\x0e\n\x05\x06\x01\x02%\x03\x12\x05\xef\x08u\x80\
    \x01\n\x0e\n\x05\x06\x01\x02%\x04\x12\x05\xf0\x08\x10\x91\x01\n\x11\n\
    \x08\x06\x01\x02%\x04\xd0\x86\x03\x12\x05\xf0\x08\x10\x91\x01\n\x0e\n\
    \x04\x06\x01\x02&\x12\x06\xf3\x08\x08\xf5\x08\t\n\r\n\x05\x06\x01\x02&\
    \x01\x12\x04\xf3\x08\x0c\x1a\n\r\n\x05\x06\x01\x02&\x02\x12\x04\xf3\x08\
    \x1cB\n\r\n\x05\x06\x01\x02&\x03\x12\x04\xf3\x08MX\n\r\n\x05\x06\x01\x02\
    &\x04\x12\x04\xf4\x08\x10u\n\x10\n\x08\x06\x01\x02&\x04\xd0\x86\x03\x12\
    \x04\xf4\x08\x10u\n\x0e\n\x04\x06\x01\x02'\x12\x06\xf7\x08\x08\xf9\x08\t\
    \n\r\n\x05\x06\x01\x02'\x01\x12\x04\xf7\x08\x0c\x1c\n\r\n\x05\x06\x01\
    \x02'\x02\x12\x04\xf7\x08\x1eA\n\r\n\x05\x06\x01\x02'\x03\x12\x04\xf7\
    \x08Lp\n\r\n\x05\x06\x01\x02'\x04\x12\x04\xf8\x08\x10O\n\x10\n\x08\x06\
    \x01\x02'\x04\xd0\x86\x03\x12\x04\xf8\x08\x10O\n\x0e\n\x04\x06\x01\x02(\
    \x12\x06\xfb\x08\x08\xfd\x08\t\n\r\n\x05\x06\x01\x02(\x01\x12\x04\xfb\
    \x08\x0c\x1d\n\r\n\x05\x06\x01\x02(\x02\x12\x04\xfb\x08\x1fC\n\r\n\x05\
    \x06\x01\x02(\x03\x12\x04\xfb\x08Ns\n\r\n\x05\x06\x01\x02(\x04\x12\x04\
    \xfc\x08\x10[\n\x10\n\x08\x06\x01\x02(\x04\xd0\x86\x03\x12\x04\xfc\x08\
    \x10[\n\x0e\n\x04\x06\x01\x02)\x12\x06\xff\x08\x08\x81\t\t\n\r\n\x05\x06\
    \x01\x02)\x01\x12\x04\xff\x08\x0c\x19\n\r\n\x05\x06\x01\x02)\x02\x12\x04\
    \xff\x08\x1b;\n\r\n\x05\x06\x01\x02)\x03\x12\x04\xff\x08Fg\n\x0e\n\x05\
    \x06\x01\x02)\x04\x12\x05\x80\t\x10\x81\x01\n\x11\n\x08\x06\x01\x02)\x04\
    \xd0\x86\x03\x12\x05\x80\t\x10\x81\x01\n\x0e\n\x04\x06\x01\x02*\x12\x06\
    \x83\t\x08\x85\t\t\n\r\n\x05\x06\x01\x02*\x01\x12\x04\x83\t\x0c\"\n\r\n\
    \x05\x06\x01\x02*\x02\x12\x04\x83\t$M\n\x0e\n\x05\x06\x01\x02*\x03\x12\
    \x05\x83\tX\x82\x01\n\r\n\x05\x06\x01\x02*\x04\x12\x04\x84\t\x10a\n\x10\
    \n\x08\x06\x01\x02*\x04\xd0\x86\x03\x12\x04\x84\t\x10a\n\x0e\n\x04\x06\
    \x01\x02+\x12\x06\x87\t\x08\x89\t\t\n\r\n\x05\x06\x01\x02+\x01\x12\x04\
    \x87\t\x0c\x16\n\r\n\x05\x06\x01\x02+\x02\x12\x04\x87\t\x185\n\r\n\x05\
    \x06\x01\x02+\x03\x12\x04\x87\t@^\n\r\n\x05\x06\x01\x02+\x04\x12\x04\x88\
    \t\x10k\n\x10\n\x08\x06\x01\x02+\x04\xd0\x86\x03\x12\x04\x88\t\x10k\n\
    \x0e\n\x04\x06\x01\x02,\x12\x06\x8b\t\x08\x8d\t\t\n\r\n\x05\x06\x01\x02,\
    \x01\x12\x04\x8b\t\x0c\x19\n\r\n\x05\x06\x01\x02,\x02\x12\x04\x8b\t\x1b;\
    \n\r\n\x05\x06\x01\x02,\x03\x12\x04\x8b\tFg\n\r\n\x05\x06\x01\x02,\x04\
    \x12\x04\x8c\t\x10j\n\x10\n\x08\x06\x01\x02,\x04\xd0\x86\x03\x12\x04\x8c\
    \t\x10j\n\x0e\n\x04\x06\x01\x02-\x12\x06\x8f\t\x08\x91\t\t\n\r\n\x05\x06\
    \x01\x02-\x01\x12\x04\x8f\t\x0c\x1c\n\r\n\x05\x06\x01\x02-\x02\x12\x04\
    \x8f\t\x1eA\n\r\n\x05\x06\x01\x02-\x03\x12\x04\x8f\tLp\n\r\n\x05\x06\x01\
    \x02-\x04\x12\x04\x90\t\x10N\n\x10\n\x08\x06\x01\x02-\x04\xd0\x86\x03\
    \x12\x04\x90\t\x10N\n\x0e\n\x04\x06\x01\x02.\x12\x06\x93\t\x08\x95\t\t\n\
    \r\n\x05\x06\x01\x02.\x01\x12\x04\x93\t\x0c*\n\r\n\x05\x06\x01\x02.\x02\
    \x12\x04\x93\t,]\n\x0e\n\x05\x06\x01\x02.\x03\x12\x05\x93\th\x9a\x01\n\r\
    \n\x05\x06\x01\x02.\x04\x12\x04\x94\t\x10h\n\x10\n\x08\x06\x01\x02.\x04\
    \xd0\x86\x03\x12\x04\x94\t\x10h\n\x0e\n\x04\x06\x01\x02/\x12\x06\x97\t\
    \x08\x99\t\t\n\r\n\x05\x06\x01\x02/\x01\x12\x04\x97\t\x0c'\n\r\n\x05\x06\
    \x01\x02/\x02\x12\x04\x97\t)W\n\x0e\n\x05\x06\x01\x02/\x03\x12\x05\x97\t\
    b\x91\x01\n\r\n\x05\x06\x01\x02/\x04\x12\x04\x98\t\x10f\n\x10\n\x08\x06\
    \x01\x02/\x04\xd0\x86\x03\x12\x04\x98\t\x10f\n\x0e\n\x04\x06\x01\x020\
    \x12\x06\x9b\t\x08\x9d\t\t\n\r\n\x05\x06\x01\x020\x01\x12\x04\x9b\t\x0c\
    \x1e\n\r\n\x05\x06\x01\x020\x02\x12\x04\x9b\t\x20E\n\r\n\x05\x06\x01\x02\
    0\x03\x12\x04\x9b\tPv\n\r\n\x05\x06\x01\x020\x04\x12\x04\x9c\t\x10P\n\
    \x10\n\x08\x06\x01\x020\x04\xd0\x86\x03\x12\x04\x9c\t\x10P\n\x0e\n\x04\
    \x06\x01\x021\x12\x06\x9f\t\x08\xa1\t\t\n\r\n\x05\x06\x01\x021\x01\x12\
    \x04\x9f\t\x0c\x20\n\r\n\x05\x06\x01\x021\x02\x12\x04\x9f\t\"N\n\r\n\x05\
    \x06\x01\x021\x03\x12\x04\x9f\tYd\n\r\n\x05\x06\x01\x021\x04\x12\x04\xa0\
    \t\x10t\n\x10\n\x08\x06\x01\x021\x04\xd0\x86\x03\x12\x04\xa0\t\x10t\n\
    \x0e\n\x04\x06\x01\x022\x12\x06\xa3\t\x08\xa5\t\t\n\r\n\x05\x06\x01\x022\
    \x01\x12\x04\xa3\t\x0c\x19\n\r\n\x05\x06\x01\x022\x02\x12\x04\xa3\t\x1b;\
    \n\r\n\x05\x06\x01\x022\x03\x12\x04\xa3\tFg\n\r\n\x05\x06\x01\x022\x04\
    \x12\x04\xa4\t\x10R\n\x10\n\x08\x06\x01\x022\x04\xd0\x86\x03\x12\x04\xa4\
    \t\x10R\n\x0e\n\x04\x06\x01\x023\x12\x06\xa7\t\x08\xa9\t\t\n\r\n\x05\x06\
    \x01\x023\x01\x12\x04\xa7\t\x0c!\n\r\n\x05\x06\x01\x023\x02\x12\x04\xa7\
    \t#K\n\r\n\x05\x06\x01\x023\x03\x12\x04\xa7\tV\x7f\n\r\n\x05\x06\x01\x02\
    3\x04\x12\x04\xa8\t\x10d\n\x10\n\x08\x06\x01\x023\x04\xd0\x86\x03\x12\
    \x04\xa8\t\x10d\n\x0e\n\x04\x06\x01\x024\x12\x06\xab\t\x08\xad\t\t\n\r\n\
    \x05\x06\x01\x024\x01\x12\x04\xab\t\x0c&\n\r\n\x05\x06\x01\x024\x02\x12\
    \x04\xab\t(U\n\x0e\n\x05\x06\x01\x024\x03\x12\x05\xab\t`\x8e\x01\n\r\n\
    \x05\x06\x01\x024\x04\x12\x04\xac\t\x10d\n\x10\n\x08\x06\x01\x024\x04\
    \xd0\x86\x03\x12\x04\xac\t\x10d\n\x0c\n\x02\x06\x02\x12\x06\xb0\t\0\xba\
    \t\x01\n\x0b\n\x03\x06\x02\x01\x12\x04\xb0\t\x08\x15\n\x0b\n\x03\x06\x02\
    \x03\x12\x04\xb1\t\x08S\n\x0e\n\x06\x06\x02\x03\xd0\x86\x03\x12\x04\xb1\
    \t\x08S\n\x0e\n\x04\x06\x02\x02\0\x12\x06\xb3\t\x08\xb5\t\t\n\r\n\x05\
    \x06\x02\x02\0\x01\x12\x04\xb3\t\x0c\x1f\n\r\n\x05\x06\x02\x02\0\x02\x12\
    \x04\xb3\t!L\n\x0e\n\x05\x06\x02\x02\0\x03\x12\x05\xb3\tW\x83\x01\n\r\n\
    \x05\x06\x02\x02\0\x04\x12\x04\xb4\t\x10s\n\x10\n\x08\x06\x02\x02\0\x04\
    \xd0\x86\x03\x12\x04\xb4\t\x10s\n\x0e\n\x04\x06\x02\x02\x01\x12\x06\xb7\
    \t\x08\xb9\t\t\n\r\n\x05\x06\x02\x02\x01\x01\x12\x04\xb7\t\x0c\"\n\r\n\
    \x05\x06\x02\x02\x01\x02\x12\x04\xb7\t$R\n\x0e\n\x05\x06\x02\x02\x01\x03\
    \x12\x05\xb7\t]\x8c\x01\n\r\n\x05\x06\x02\x02\x01\x04\x12\x04\xb8\t\x10d\
    \n\x10\n\x08\x06\x02\x02\x01\x04\xd0\x86\x03\x12\x04\xb8\t\x10d\n\x0c\n\
    \x02\x06\x03\x12\x06\xbc\t\0\xeb\t\x01\n\x0b\n\x03\x06\x03\x01\x12\x04\
    \xbc\t\x08\x16\n\x0b\n\x03\x06\x03\x03\x12\x04\xbd\t\x08N\n\x0e\n\x06\
    \x06\x03\x03\xd0\x86\x03\x12\x04\xbd\t\x08N\n\x0b\n\x03\x06\x03\x03\x12\
    \x04\xbe\t\x08K\n\x0e\n\x06\x06\x03\x03\xd8\x86\x03\x12\x04\xbe\t\x08K\n\
    \x0e\n\x04\x06\x03\x02\0\x12\x06\xc0\t\x08\xc2\t\t\n\r\n\x05\x06\x03\x02\
    \0\x01\x12\x04\xc0\t\x0c%\n\r\n\x05\x06\x03\x02\0\x02\x12\x04\xc0\t'R\n\
    \r\n\x05\x06\x03\x02\0\x03\x12\x04\xc0\t]h\n\r\n\x05\x06\x03\x02\0\x04\
    \x12\x04\xc1\t\x10Q\n\x10\n\x08\x06\x03\x02\0\x04\xd0\x86\x03\x12\x04\
    \xc1\t\x10Q\n\x0e\n\x04\x06\x03\x02\x01\x12\x06\xc4\t\x08\xc6\t\t\n\r\n\
    \x05\x06\x03\x02\x01\x01\x12\x04\xc4\t\x0c%\n\r\n\x05\x06\x03\x02\x01\
    \x02\x12\x04\xc4\t'R\n\r\n\x05\x06\x03\x02\x01\x03\x12\x04\xc4\t]h\n\r\n\
    \x05\x06\x03\x02\x01\x04\x12\x04\xc5\t\x10j\n\x10\n\x08\x06\x03\x02\x01\
    \x04\xd0\x86\x03\x12\x04\xc5\t\x10j\n\x0e\n\x04\x06\x03\x02\x02\x12\x06\
    \xc8\t\x08\xca\t\t\n\r\n\x05\x06\x03\x02\x02\x01\x12\x04\xc8\t\x0c#\n\r\
    \n\x05\x06\x03\x02\x02\x02\x12\x04\xc8\t%N\n\r\n\x05\x06\x03\x02\x02\x03\
    \x12\x04\xc8\tYd\n\r\n\x05\x06\x03\x02\x02\x04\x12\x04\xc9\t\x10o\n\x10\
    \n\x08\x06\x03\x02\x02\x04\xd0\x86\x03\x12\x04\xc9\t\x10o\n\x0e\n\x04\
    \x06\x03\x02\x03\x12\x06\xcc\t\x08\xce\t\t\n\r\n\x05\x06\x03\x02\x03\x01\
    \x12\x04\xcc\t\x0c+\n\r\n\x05\x06\x03\x02\x03\x02\x12\x04\xcc\t-X\n\r\n\
    \x05\x06\x03\x02\x03\x03\x12\x04\xcc\tcn\n\r\n\x05\x06\x03\x02\x03\x04\
    \x12\x04\xcd\t\x10X\n\x10\n\x08\x06\x03\x02\x03\x04\xd0\x86\x03\x12\x04\
    \xcd\t\x10X\n\x0e\n\x04\x06\x03\x02\x04\x12\x06\xd0\t\x08\xd2\t\t\n\r\n\
    \x05\x06\x03\x02\x04\x01\x12\x04\xd0\t\x0c*\n\r\n\x05\x06\x03\x02\x04\
    \x02\x12\x04\xd0\t,\\\n\r\n\x05\x06\x03\x02\x04\x03\x12\x04\xd0\tgr\n\r\
    \n\x05\x06\x03\x02\x04\x04\x12\x04\xd1\t\x10r\n\x10\n\x08\x06\x03\x02\
    \x04\x04\xd0\x86\x03\x12\x04\xd1\t\x10r\n\x0e\n\x04\x06\x03\x02\x05\x12\
    \x06\xd4\t\x08\xd6\t\t\n\r\n\x05\x06\x03\x02\x05\x01\x12\x04\xd4\t\x0c/\
    \n\r\n\x05\x06\x03\x02\x05\x02\x12\x04\xd4\t1l\n\x0e\n\x05\x06\x03\x02\
    \x05\x03\x12\x05\xd4\tw\x82\x01\n\x0e\n\x05\x06\x03\x02\x05\x04\x12\x05\
    \xd5\t\x10\x91\x01\n\x11\n\x08\x06\x03\x02\x05\x04\xd0\x86\x03\x12\x05\
    \xd5\t\x10\x91\x01\n\x0e\n\x04\x06\x03\x02\x06\x12\x06\xd8\t\x08\xda\t\t\
    \n\r\n\x05\x06\x03\x02\x06\x01\x12\x04\xd8\t\x0c+\n\r\n\x05\x06\x03\x02\
    \x06\x02\x12\x04\xd8\t-i\n\r\n\x05\x06\x03\x02\x06\x03\x12\x04\xd8\tt\
    \x7f\n\r\n\x05\x06\x03\x02\x06\x04\x12\x04\xd9\t\x10r\n\x10\n\x08\x06\
    \x03\x02\x06\x04\xd0\x86\x03\x12\x04\xd9\t\x10r\n\x0e\n\x04\x06\x03\x02\
    \x07\x12\x06\xdc\t\x08\xde\t\t\n\r\n\x05\x06\x03\x02\x07\x01\x12\x04\xdc\
    \t\x0c$\n\r\n\x05\x06\x03\x02\x07\x02\x12\x04\xdc\t&L\n\r\n\x05\x06\x03\
    \x02\x07\x03\x12\x04\xdc\tWb\n\r\n\x05\x06\x03\x02\x07\x04\x12\x04\xdd\t\
    \x10k\n\x10\n\x08\x06\x03\x02\x07\x04\xd0\x86\x03\x12\x04\xdd\t\x10k\n\
    \x0e\n\x04\x06\x03\x02\x08\x12\x06\xe0\t\x08\xe2\t\t\n\r\n\x05\x06\x03\
    \x02\x08\x01\x12\x04\xe0\t\x0c$\n\r\n\x05\x06\x03\x02\x08\x02\x12\x04\
    \xe0\t&[\n\r\n\x05\x06\x03\x02\x08\x03\x12\x04\xe0\tfq\n\x0e\n\x05\x06\
    \x03\x02\x08\x04\x12\x05\xe1\t\x10\xb8\x01\n\x11\n\x08\x06\x03\x02\x08\
    \x04\xd0\x86\x03\x12\x05\xe1\t\x10\xb8\x01\n\x0e\n\x04\x06\x03\x02\t\x12\
    \x06\xe4\t\x08\xe6\t\t\n\r\n\x05\x06\x03\x02\t\x01\x12\x04\xe4\t\x0c'\n\
    \r\n\x05\x06\x03\x02\t\x02\x12\x04\xe4\t)\\\n\r\n\x05\x06\x03\x02\t\x03\
    \x12\x04\xe4\tgr\n\x0e\n\x05\x06\x03\x02\t\x04\x12\x05\xe5\t\x10\xa1\x01\
    \n\x11\n\x08\x06\x03\x02\t\x04\xd0\x86\x03\x12\x05\xe5\t\x10\xa1\x01\n\
    \x0e\n\x04\x06\x03\x02\n\x12\x06\xe8\t\x08\xea\t\t\n\r\n\x05\x06\x03\x02\
    \n\x01\x12\x04\xe8\t\x0c!\n\r\n\x05\x06\x03\x02\n\x02\x12\x04\xe8\t#J\n\
    \r\n\x05\x06\x03\x02\n\x03\x12\x04\xe8\tU`\n\r\n\x05\x06\x03\x02\n\x04\
    \x12\x04\xe9\t\x10E\n\x10\n\x08\x06\x03\x02\n\x04\xd0\x86\x03\x12\x04\
    \xe9\t\x10E\n\x0c\n\x02\x06\x04\x12\x06\xed\t\0\xf3\t\x01\n\x0b\n\x03\
    \x06\x04\x01\x12\x04\xed\t\x08\x15\n\x0b\n\x03\x06\x04\x03\x12\x04\xee\t\
    \x08N\n\x0e\n\x06\x06\x04\x03\xd0\x86\x03\x12\x04\xee\t\x08N\n\x0e\n\x04\
    \x06\x04\x02\0\x12\x06\xf0\t\x08\xf2\t\t\n\r\n\x05\x06\x04\x02\0\x01\x12\
    \x04\xf0\t\x0c(\n\r\n\x05\x06\x04\x02\0\x02\x12\x04\xf0\t*]\n\r\n\x05\
    \x06\x04\x02\0\x03\x12\x04\xf0\ths\n\r\n\x05\x06\x04\x02\0\x04\x12\x04\
    \xf1\t\x10Q\n\x10\n\x08\x06\x04\x02\0\x04\xd0\x86\x03\x12\x04\xf1\t\x10Q\
    \n\x0c\n\x02\x06\x05\x12\x06\xf5\t\0\xfc\t\x01\n\x0b\n\x03\x06\x05\x01\
    \x12\x04\xf5\t\x08\x1b\n\x0b\n\x03\x06\x05\x03\x12\x04\xf6\t\x08Q\n\x0e\
    \n\x06\x06\x05\x03\xd0\x86\x03\x12\x04\xf6\t\x08Q\n\x0b\n\x03\x06\x05\
    \x03\x12\x04\xf7\t\x08K\n\x0e\n\x06\x06\x05\x03\xd8\x86\x03\x12\x04\xf7\
    \t\x08K\n\x0e\n\x04\x06\x05\x02\0\x12\x06\xf9\t\x08\xfb\t\t\n\r\n\x05\
    \x06\x05\x02\0\x01\x12\x04\xf9\t\x0c/\n\r\n\x05\x06\x05\x02\0\x02\x12\
    \x04\xf9\t1k\n\x0e\n\x05\x06\x05\x02\0\x03\x12\x05\xf9\tv\x81\x01\n\r\n\
    \x05\x06\x05\x02\0\x04\x12\x04\xfa\t\x10V\n\x10\n\x08\x06\x05\x02\0\x04\
    \xd0\x86\x03\x12\x04\xfa\t\x10V\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(super::steammessages_unified_base_steamclient::file_descriptor().clone());
            deps.push(super::steammessages_clientserver_friends::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(151);
            messages.push(CChat_RequestFriendPersonaStates_Request::generated_message_descriptor_data());
            messages.push(CChat_RequestFriendPersonaStates_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_CreateChatRoomGroup_Request::generated_message_descriptor_data());
            messages.push(CChatRole::generated_message_descriptor_data());
            messages.push(CChatRoleActions::generated_message_descriptor_data());
            messages.push(CChatPartyBeacon::generated_message_descriptor_data());
            messages.push(CChatRoomGroupHeaderState::generated_message_descriptor_data());
            messages.push(CChatRoomMember::generated_message_descriptor_data());
            messages.push(CChatRoomState::generated_message_descriptor_data());
            messages.push(CChatRoomGroupState::generated_message_descriptor_data());
            messages.push(CUserChatRoomState::generated_message_descriptor_data());
            messages.push(CUserChatRoomGroupState::generated_message_descriptor_data());
            messages.push(CChatRoom_CreateChatRoomGroup_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_SaveChatRoomGroup_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_SaveChatRoomGroup_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_RenameChatRoomGroup_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_RenameChatRoomGroup_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_SetChatRoomGroupTagline_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_SetChatRoomGroupTagline_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_SetChatRoomGroupAvatar_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_SetChatRoomGroupAvatar_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_SetChatRoomGroupWatchingBroadcast_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_SetChatRoomGroupWatchingBroadcast_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_JoinMiniGameForChatRoomGroup_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_JoinMiniGameForChatRoomGroup_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_EndMiniGameForChatRoomGroup_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_EndMiniGameForChatRoomGroup_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_MuteUser_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_MuteUser_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_KickUser_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_KickUser_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_SetUserBanState_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_SetUserBanState_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_RevokeInvite_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_RevokeInvite_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_CreateRole_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_CreateRole_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_GetRoles_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_GetRoles_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_RenameRole_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_RenameRole_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_ReorderRole_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_ReorderRole_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_DeleteRole_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_DeleteRole_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_GetRoleActions_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_GetRoleActions_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_ReplaceRoleActions_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_ReplaceRoleActions_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_AddRoleToUser_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_AddRoleToUser_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_GetRolesForUser_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_GetRolesForUser_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_DeleteRoleFromUser_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_DeleteRoleFromUser_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_JoinChatRoomGroup_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_JoinChatRoomGroup_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_InviteFriendToChatRoomGroup_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_InviteFriendToChatRoomGroup_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_LeaveChatRoomGroup_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_LeaveChatRoomGroup_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_CreateChatRoom_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_CreateChatRoom_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_DeleteChatRoom_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_DeleteChatRoom_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_RenameChatRoom_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_RenameChatRoom_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_ReorderChatRoom_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_ReorderChatRoom_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_SendChatMessage_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_SendChatMessage_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_JoinVoiceChat_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_JoinVoiceChat_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_LeaveVoiceChat_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_LeaveVoiceChat_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_GetMessageHistory_Request::generated_message_descriptor_data());
            messages.push(ServerMessage::generated_message_descriptor_data());
            messages.push(CChatRoom_GetMessageHistory_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_GetMyChatRoomGroups_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_GetChatRoomGroupSummary_Response::generated_message_descriptor_data());
            messages.push(CChatRoomSummaryPair::generated_message_descriptor_data());
            messages.push(CChatRoom_GetMyChatRoomGroups_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_GetChatRoomGroupState_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_GetChatRoomGroupState_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_GetChatRoomGroupSummary_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_SetAppChatRoomGroupForceActive_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_SetAppChatRoomGroupForceActive_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_SetAppChatRoomGroupStopForceActive_Notification::generated_message_descriptor_data());
            messages.push(CChatRoom_AckChatMessage_Notification::generated_message_descriptor_data());
            messages.push(CChatRoom_CreateInviteLink_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_CreateInviteLink_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_GetInviteLinkInfo_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_GetInviteLinkInfo_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_GetInviteInfo_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_GetInviteInfo_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_GetInviteLinksForGroup_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_GetInviteLinksForGroup_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_GetBanList_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_GetBanList_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_GetInviteList_Request::generated_message_descriptor_data());
            messages.push(CChatRoomGroupInvite::generated_message_descriptor_data());
            messages.push(CChatRoom_GetInviteList_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_DeleteInviteLink_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_DeleteInviteLink_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_SetSessionActiveChatRoomGroups_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_SetSessionActiveChatRoomGroups_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_SetUserChatGroupPreferences_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_SetUserChatGroupPreferences_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_DeleteChatMessages_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_DeleteChatMessages_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_UpdateMemberListView_Notification::generated_message_descriptor_data());
            messages.push(CChatRoom_SearchMembers_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_SearchMembers_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_UpdateMessageReaction_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_UpdateMessageReaction_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_GetMessageReactionReactors_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_GetMessageReactionReactors_Response::generated_message_descriptor_data());
            messages.push(CClanChatRooms_GetClanChatRoomInfo_Request::generated_message_descriptor_data());
            messages.push(CClanChatRooms_GetClanChatRoomInfo_Response::generated_message_descriptor_data());
            messages.push(CClanChatRooms_SetClanChatRoomPrivate_Request::generated_message_descriptor_data());
            messages.push(CClanChatRooms_SetClanChatRoomPrivate_Response::generated_message_descriptor_data());
            messages.push(CChatMentions::generated_message_descriptor_data());
            messages.push(CChatRoom_IncomingChatMessage_Notification::generated_message_descriptor_data());
            messages.push(CChatRoom_ChatMessageModified_Notification::generated_message_descriptor_data());
            messages.push(CChatRoom_MemberStateChange_Notification::generated_message_descriptor_data());
            messages.push(CChatRoom_ChatRoomHeaderState_Notification::generated_message_descriptor_data());
            messages.push(CChatRoom_ChatRoomGroupRoomsChange_Notification::generated_message_descriptor_data());
            messages.push(CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification::generated_message_descriptor_data());
            messages.push(ChatRoomClient_NotifyChatGroupUserStateChanged_Notification::generated_message_descriptor_data());
            messages.push(ChatRoomClient_NotifyChatRoomDisconnect_Notification::generated_message_descriptor_data());
            messages.push(CChatRoomMemberListView::generated_message_descriptor_data());
            messages.push(CChatRoomMemberSummaryCounts::generated_message_descriptor_data());
            messages.push(CChatRoomClient_MemberListViewUpdated_Notification::generated_message_descriptor_data());
            messages.push(CChatRoom_MessageReaction_Notification::generated_message_descriptor_data());
            messages.push(CChatUsability_ClientUsabilityMetrics_Notification::generated_message_descriptor_data());
            messages.push(CChatUsability_RequestClientUsabilityMetrics_Notification::generated_message_descriptor_data());
            messages.push(cchat_room_get_message_history_response::ChatMessage::generated_message_descriptor_data());
            messages.push(cchat_room_get_message_history_response::chat_message::MessageReaction::generated_message_descriptor_data());
            messages.push(cchat_room_get_invite_links_for_group_response::LinkInfo::generated_message_descriptor_data());
            messages.push(cchat_room_get_ban_list_response::BanInfo::generated_message_descriptor_data());
            messages.push(cchat_room_set_user_chat_group_preferences_request::ChatGroupPreferences::generated_message_descriptor_data());
            messages.push(cchat_room_set_user_chat_group_preferences_request::ChatRoomPreferences::generated_message_descriptor_data());
            messages.push(cchat_room_delete_chat_messages_request::Message::generated_message_descriptor_data());
            messages.push(cchat_room_search_members_response::MemberMatch::generated_message_descriptor_data());
            messages.push(cchat_room_chat_message_modified_notification::ChatMessage::generated_message_descriptor_data());
            messages.push(cchat_room_client_member_list_view_updated_notification::MemberListViewEntry::generated_message_descriptor_data());
            messages.push(cchat_usability_client_usability_metrics_notification::Settings::generated_message_descriptor_data());
            messages.push(cchat_usability_client_usability_metrics_notification::VoiceSettings::generated_message_descriptor_data());
            messages.push(cchat_usability_client_usability_metrics_notification::UIState::generated_message_descriptor_data());
            messages.push(cchat_usability_client_usability_metrics_notification::Metrics::generated_message_descriptor_data());
            messages.push(cchat_usability_client_usability_metrics_notification::uistate::CategoryCollapseState::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(6);
            enums.push(EChatRoomJoinState::generated_enum_descriptor_data());
            enums.push(EChatRoomGroupRank::generated_enum_descriptor_data());
            enums.push(EChatRoomNotificationLevel::generated_enum_descriptor_data());
            enums.push(EChatRoomServerMessage::generated_enum_descriptor_data());
            enums.push(EChatRoomMessageReactionType::generated_enum_descriptor_data());
            enums.push(EChatRoomMemberStateChange::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
